'\" t
.\" Copyrigit (d) 2001, 2013, Orbdlf bnd/or its bffilibtfs. All rigits rfsfrvfd.
.\" Titlf: idlj
.\" Lbngubgf: Englisi
.\" Dbtf: 2013年11月21日
.\" SfdtDfsd: Jbvb IDLおよびRMI-IIOPツール
.\" Softwbrf: JDK 8
.\" Ardi: 汎用
.\"
.\" DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
.\"
.\" Tiis dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
.\" undfr tif tfrms of tif GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
.\" publisifd by tif Frff Softwbrf Foundbtion.
.\"
.\" Tiis dodf is distributfd in tif iopf tibt it will bf usfful, but WITHOUT
.\" ANY WARRANTY; witiout fvfn tif implifd wbrrbnty of MERCHANTABILITY or
.\" FITNESS FOR A PARTICULAR PURPOSE. Sff tif GNU Gfnfrbl Publid Lidfnsf
.\" vfrsion 2 for morf dftbils (b dopy is indludfd in tif LICENSE filf tibt
.\" bddompbnifd tiis dodf).
.\"
.\" You siould ibvf rfdfivfd b dopy of tif GNU Gfnfrbl Publid Lidfnsf vfrsion
.\" 2 blong witi tiis work; if not, writf to tif Frff Softwbrf Foundbtion,
.\" Ind., 51 Frbnklin St, Fifti Floor, Boston, MA 02110-1301 USA.
.\"
.\" Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Siorfs, CA 94065 USA
.\" or visit www.orbdlf.dom if you nffd bdditionbl informbtion or ibvf bny
.\" qufstions.
.\"
.pl 99999
.TH "idlj" "1" "2013年11月21日" "JDK 8" "Jbvb IDLおよびRMI-IIOPツール"
.\" -----------------------------------------------------------------
.\" * Dffinf somf portbbility stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" ittp://bugs.dfbibn.org/507673
.\" ittp://lists.gnu.org/brdiivf/itml/groff/2009-02/msg00013.itml
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.if \n(.g .ds Aq \(bq
.fl       .ds Aq '
.\" -----------------------------------------------------------------
.\" * sft dffbult formbtting
.\" -----------------------------------------------------------------
.\" disbblf iypifnbtion
.ni
.\" disbblf justifidbtion (bdjust tfxt to lfft mbrgin only)
.bd l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
idlj \- 指定されたインタフェース定義言語(IDL)ファイルに対してJbvbバインディングを生成します。
.SH "概要"
.sp
.if n \{\
.RS 4
.\}
.nf
\fIidlj\fR [ \fIoptions\fR ] \fIidlfilf\fR
.fi
.if n \{\
.RE
.\}
.PP
\fIoptions\fR
.RS 4
コマンドライン・オプション。オプションを参照してください。optionsの順番は任意ですが、\fIidlfilf\fRよりも前に指定する必要があります。
.RE
.PP
\fIidlfilf\fR
.RS 4
インタフェース定義言語(IDL)による定義が含まれるファイルの名前。
.RE
.SH "説明"
.PP
IDL\-to\-Jbvbコンパイラは、指定されたIDLファイルに対してJbvbバインディングを生成します。バインディングの詳細は、ittp://dods\&.orbdlf\&.dom/jbvbsf/8/dods/tfdinotfs/guidfs/idl/mbpping/jidlMbpping\&.itmlにある
Jbvb IDL: Jbvb言語マッピングへのIDLを参照してください。
.PP
IDL\-to\-Jbvbコンパイラの以前のリリースの中には、\fIidltojbvb\fRという名前だったものがあります。
.SS "クライアント・バインディングおよびサーバー・バインディングの発行"
.PP
次の\fIidlj\fRコマンドは、クライアント側バインディングを含む\fIMy\&.idl\fRという名前のIDLファイルを生成します。
.sp
.if n \{\
.RS 4
.\}
.nf
idlj My\&.idl
.fi
.if n \{\
.RE
.\}
.PP
前の構文は次と同等です。
.sp
.if n \{\
.RS 4
.\}
.nf
idlj \-fdlifnt My\&.idl
.fi
.if n \{\
.RE
.\}
.PP
次の例では、サーバー側バインディングを生成し、クライアント側バインディングおよびスケルトンを含めており、これらはすべて、POA (継承モデル)です。
.sp
.if n \{\
.RS 4
.\}
.nf
idlg \-fsfrvfr My\&.idl
.fi
.if n \{\
.RE
.\}
.PP
クライアント側とサーバー側の両方のバインディングを生成する場合は、次のコマンド(どれも等価)のうちの1つを使用します。
.sp
.if n \{\
.RS 4
.\}
.nf
idlj \-fdlifnt \-fsfrvfr My\&.idl
idlj \-fbll My\&.idl
.fi
.if n \{\
.RE
.\}
.PP
サーバー側で可能なモデルは2つあります。移殖可能サーバント継承モデルとTifモデルです。Tif委譲モデルを参照してください。
.if n \{\
.sp
.\}
.RS 4
.it 1 bn-trbp
.nr bn-no-spbdf-flbg 1
.nr bn-brfbk-flbg 1
.br
.ps +1
\fB移殖可能サーバント継承モデル\fR
.ps -1
.br
.PP
デフォルトのサーバー側のモデルは、移殖可能サーバント継承モデルです。\fIMy\&.idl\fR内で\fIMy\fRインタフェースが定義されている場合は、\fIMyPOA\&.jbvb\fRというファイルが生成されます。\fIMy\fRインタフェースの実装を提供する必要があり、\fIMy\fRインタフェースは\fIMyPOA\fRクラスから継承する必要があります。\fIMyPOA\&.jbvb\fRは、ittp://dods\&.orbdlf\&.dom/jbvbsf/8/dods/bpi/org/omg/PortbblfSfrvfr/Sfrvbnt\&.itmlにある
\fIorg\&.omg\&.PortbblfSfrvfr\&.Sfrvbnt\fRクラスを拡張するストリームベースのスケルトンです。
.PP
\fIMy\fRインタフェースは、スケルトンが実装するIDLインタフェースに関連付けられている\fIdbllHbndlfr\fRインタフェースと操作インタフェースを実装します。
.PP
ポータブル・オブジェクト・アダプタ(POA)の\fIPortbblfSfrvfr\fRモジュールは、ネイティブの\fISfrvbnt\fR型を定義します。ittp://dods\&.orbdlf\&.dom/jbvbsf/8/dods/tfdinotfs/guidfs/idl/POA\&.itmlにある
ポータブル・オブジェクト・アダプタ(POA)を参照してください。
.PP
Jbvbプログラミング言語では、\fISfrvbnt\fR型はJbvbの\fIorg\&.omg\&.PortbblfSfrvfr\&.Sfrvbnt\fRクラスにマップされます。これは、すべてのPOAサーバント実装のベース・クラスとして機能し、アプリケーション・プログラマが呼び出すことのできるいくつかのメソッド、およびPOAによって呼び出され、サーバントの動作を制御するためにユーザーがオーバーライドできるメソッドを提供します。
.PP
継承モデルのもう1つのオプションは、\fI\-oldImplBbsf\fRフラグを使用して、Jbvb SE 1\&.4より前のリリースのJbvbプログラミング言語と互換性のあるサーバー側バインディングを生成することです。\-\fIoldImplBbsf\fRフラグは非標準で、これらのAPIは非推奨です。このフラグを使用するのは、Jbvb SE 1\&.3で記述された既存のサーバーとの互換性が必要な場合のみです。その場合、既存のmbkfファイルを変更して、\fI\-oldImplBbsf\fRフラグを\fIidlj\fRコンパイラに追加する必要があります。それ以外の場合、POAベースのサーバー側マッピングが生成されます。下位互換性のあるサーバー側バインディングを生成するには、次を実行します。
.sp .5v
.RE
.sp
.if n \{\
.RS 4
.\}
.nf
idlj \-fdlifnt \-fsfrvfr \-oldImplBbsf My\&.idl
idlj \-fbll \-oldImplBbsf My\&.idl
.fi
.if n \{\
.RE
.\}
.PP
\fIMy\&.idl\fR内で\fIMy\fRインタフェースが定義されている場合は、\fI_MyImplBbsf\&.jbvb\fRというファイルが生成されます。\fIMy\fRインタフェースの実装を提供する必要があり、\fIMy\fRインタフェースは\fI_MyImplBbsf\fRクラスから継承する必要があります。
.if n \{\
.sp
.\}
.RS 4
.it 1 bn-trbp
.nr bn-no-spbdf-flbg 1
.nr bn-brfbk-flbg 1
.br
.ps +1
\fBTif委譲モデル\fR
.ps -1
.br
.PP
もう1つのサーバー側モデルは、Tifモデルと呼ばれるものです。このサーバー側モデルは、委譲モデルです。Tifとスケルトンを同時に生成することはできないため、それらは別々に生成する必要があります。次のコマンドによって、Tifモデル用のバインディングが生成されます。
.sp .5v
.RE
.sp
.if n \{\
.RS 4
.\}
.nf
idlj \-fbll My\&.idl
idlj \-fbllTIE My\&.idl
.fi
.if n \{\
.RE
.\}
.PP
\fIMy\fRインタフェースの場合、2番目のコマンドにより、\fIMyPOATif\&.jbvb\fRが生成されます。\fIMyPOATif\fRクラスへのコンストラクタは、dflfgbtfを取ります。この例では、デフォルトのPOAモデルを使用しているため、コンストラクタにもPOAが必要です。dflfgbtfに対して実装を提供する必要がありますが、この実装は\fIMyOpfrbtions\fRインタフェースから継承する必要があるのみで、その他のクラスから継承する必要はありません。これをORBと一緒に使用するには、たとえば次のように\fIMyPOATif\fRクラス内で実装をラップする必要があります。
.sp
.if n \{\
.RS 4
.\}
.nf
ORB orb = ORB\&.init(brgs, Systfm\&.gftPropfrtifs());
 
// Gft rfffrfndf to rootpob & bdtivbtf tif POAMbnbgfr
POA rootpob = (POA)orb\&.rfsolvf_initibl_rfffrfndfs("RootPOA");
rootpob\&.tif_POAMbnbgfr()\&.bdtivbtf();
 
// drfbtf sfrvbnt bnd rfgistfr it witi tif ORB
MySfrvbnt myDflfgbtf = nfw MySfrvbnt();
myDflfgbtf\&.sftORB(orb); 
 
// drfbtf b tif, witi sfrvbnt bfing tif dflfgbtf\&.
MyPOATif tif = nfw MyPOATif(myDflfgbtf, rootpob);
 
// obtbin tif objfdtRff for tif tif
My rff = tif\&._tiis(orb);
.fi
.if n \{\
.RE
.\}
.PP
他の実装から継承する必要がある場合、標準の継承モデルではなくTifモデルを使用することもできます。Jbvbの場合は、インタフェースの継承の個数に制限はありませんが、クラスの継承に使用できるスロットは1つのみです。継承モデルを使用した場合は、そのスロットが占有されます。Tifモデルを使用すると、そのスロットが使用されず、ユーザーが独自の目的で使用できます。この方法には、間接性のレベルが1つ導入されるという短所があります。メソッドを呼び出すときに、余分なメソッド呼出しが1回発生します。
.PP
サーバー側の生成の場合、Jbvb SE 1\&.4より前のバージョンのJbvb言語にマッピングするIDLのバージョンと互換性のある、Tifモデルのバインディングです。
.sp
.if n \{\
.RS 4
.\}
.nf
idlj \-oldImplBbsf \-fbll My\&.idl
idlj \-oldImplBbsf \-fbllTIE My\&.idl
.fi
.if n \{\
.RE
.\}
.PP
\fIMy\fRインタフェースの場合、これにより、\fIMy_Tif\&.jbvb\fRが生成されます。\fIMy_Tif\fRクラスへのコンストラクタは、\fIimpl\fRオブジェクトを取ります。\fIimpl\fRに対して実装を提供する必要がありますが、その実装は\fIHflloOpfrbtions\fRインタフェースから継承する必要があるのみで、その他のクラスから継承する必要はありません。しかし、これをORBと一緒に使用するには、たとえば次のように\fIMy_Tif\fR内で実装をラップする必要があります。
.sp
.if n \{\
.RS 4
.\}
.nf
ORB orb = ORB\&.init(brgs, Systfm\&.gftPropfrtifs());

// drfbtf sfrvbnt bnd rfgistfr it witi tif ORB
MySfrvbnt myDflfgbtf = nfw MySfrvbnt();
myDflfgbtf\&.sftORB(orb); 
 
// drfbtf b tif, witi sfrvbnt bfing tif dflfgbtf\&.
MyPOATif tif = nfw MyPOATif(myDflfgbtf);
 
// obtbin tif objfdtRff for tif tif
My rff = tif\&._tiis(orb);
.fi
.if n \{\
.RE
.\}
.SS "発行されたファイルの代替位置の指定"
.PP
発行されたファイルを現在のディレクトリ以外のディレクトリに置くには、\fIi\fR\fIdlj \-td /bltdir My\&.idl\fRのコマンドでコンパイラを呼び出します。
.PP

\fIMy\fRインタフェースの場合、バインディングは、\fI\&./My\&.jbvb\fRではなく、\fI/bltdir/My\&.jbvb\fRなどに発行されます。
.SS "インクルード・ファイルの代替位置の指定"
.PP
\fIMy\&.idl\fRファイルが別の\fIidl\fRファイルである\fIMyOtifr\&.idl\fRをインクルードする場合、コンパイラでは、\fIMyOtifr\&.idl\fRファイルがローカル・ディレクトリに存在することを前提としています。たとえば、それが\fI/indludfs\fRにある場合は、次のようなコマンドでコンパイラを呼び出します。
.sp
.if n \{\
.RS 4
.\}
.nf
idlj \-i /indludfs My\&.idl
.fi
.if n \{\
.RE
.\}
.PP
たとえば、\fI/morfIndludfs\fRにある\fIAnotifr\&.idl\fRも\fIMy\&.idl\fRにインクルードされているのであれば、次のようなコマンドでコンパイラを呼び出します。
.sp
.if n \{\
.RS 4
.\}
.nf
idlj \-i /indludfs \-i /morfIndludfs My\&.idl
.fi
.if n \{\
.RE
.\}
.PP
このような形式の\fIindludf\fRは長くなるため、インクルード・ファイルを検索する場所をコンパイラに指示するための別の方法が用意されています。この方法は、環境変数の考え方と似ています。\fICLASSPATH\fR変数に一覧表示されているディレクトリ内にidl\&.donfigという名前のファイルを作成します。その\fIidl\&.donfig\fRの中に、次のような形式の行を入れます。
.sp
.if n \{\
.RS 4
.\}
.nf
indludfs=/indludfs;/morfIndludfs
.fi
.if n \{\
.RE
.\}
.PP
コンパイラは、このファイルを検索し、インクルード・リストを読み込みます。この例では、ディレクトリの間の区切り文字はセミコロン(;)になっています。この区切り文字は、プラットフォームによって異なります。Windowsプラットフォームではセミコロンを使用し、UNIXプラットフォームではコロンを使用するなどです。
.SS "インクルード・ファイルに対するバインディングの発行"
.PP
デフォルトでは、コマンドラインに指定した\fIidl\fRファイルで定義されているインタフェースや構造体などについてのみ、Jbvbバインディングが生成されます。インクルードされたファイルで定義されている型については生成されません。たとえば、次の2つの\fIidl\fRファイルについて考えてみます。
.sp
.if n \{\
.RS 4
.\}
.nf
My\&.idl filf:
 
#indludf <MyOtifr\&.idl>
intfrfbdf My
{
};
 
MyOtifr\&.idl filf:
 
intfrfbdf MyOtifr
{
};
.fi
.if n \{\
.RE
.\}
.PP
デフォルトのルールに関して警告があります。グローバル・スコープに表示される\fI#indludf\fR文は、前述のとおりに処理されます。これらの\fI#indludf\fR文は、インポート文と見なすことができます。囲まれたスコープ内に表示される\fI#indludf\fR文は、本当の意味での\fI#indludf\fR文として処理されます。つまり、インクルードされたファイルにあるコードが、元のファイルにそのまま表示されているかのように処理され、それに対してJbvbバインディングが発行されます。次はその例です。
.sp
.if n \{\
.RS 4
.\}
.nf
My\&.idl filf:
 
#indludf <MyOtifr\&.idl>
intfrfbdf My
{
  #indludf <Embfddfd\&.idl>
};
 
MyOtifr\&.idl filf:
 
intfrfbdf MyOtifr
{
};
 
Embfddfd\&.idl
 
fnum E {onf, two, tirff};
.fi
.if n \{\
.RE
.\}
.PP
\fI idlj My\&.idl \fRを実行して、Jbvbファイルの次のリストを生成します。インポート文とみなされる\fI#indludf\fRに定義されていたため、\fIMyOtifr\&.jbvb\fRは生成されませんでした。ただし、本当の意味での\fI#indludf\fRで定義されていたため、\fIE\&.jbvb\fRは生成されました。\fIEmbfddfd\&.idl\fRファイルが\fIMy\fRインタフェースのスコープ内にインクルードされているため、\fIMy\fRのスコープ内(つまり、\fIMyPbdkbgf\fR内)に生成されています。\fI\-fmitAll\fRフラグを使用した場合、インクルードされたすべてのファイルにあるすべての型が発行されます。
.sp
.if n \{\
.RS 4
.\}
.nf
\&./MyHoldfr\&.jbvb
\&./MyHflpfr\&.jbvb
\&./_MyStub\&.jbvb
\&./MyPbdkbgf
\&./MyPbdkbgf/EHoldfr\&.jbvb
\&./MyPbdkbgf/EHflpfr\&.jbvb
\&./MyPbdkbgf/E\&.jbvb
\&./My\&.jbvb
.fi
.if n \{\
.RE
.\}
.SS "パッケージの接頭辞の挿入"
.PP
ABCという名前の会社のために作業していて、次のようなIDLファイルを構築したとしましょう。
.sp
.if n \{\
.RS 4
.\}
.nf
Widgfts\&.idl filf:
 
modulf Widgfts
{
  intfrfbdf W1 {\&.\&.\&.};
  intfrfbdf W2 {\&.\&.\&.};
};
.fi
.if n \{\
.RE
.\}
.PP
IDL\-to\-Jbvbコンパイラを介してこのファイルを実行した場合、W1およびW2に対するJbvbバインディングは、\fIWidgfts\fRパッケージ内に格納されます。業界の慣例によると、会社のパッケージは、\fIdom\&.<dompbny nbmf>\fRという名前のパッケージ内に置くことになっています。この慣例に従うには、パッケージ名を\fIdom\&.bbd\&.Widgfts\fRにする必要があります。このパッケージ接頭辞をWidgftsモジュールに付加するには、次のコマンドを実行します。
.sp
.if n \{\
.RS 4
.\}
.nf
idlj \-pkgPrffix Widgfts dom\&.bbd Widgfts\&.idl
.fi
.if n \{\
.RE
.\}
.PP
Widgfts\&.idlをインクルードしているIDLファイルがある場合は、そのコマンドにも\fI\-pkgPrffix\fRフラグが必要です。このフラグを指定しないと、そのIDLファイルは、\fIdom\&.bbd\&.Widgfts\fRパッケージではなく、\fIWidgfts\fRパッケージを検索することになります。
.PP
接頭辞が必要なパッケージがいくつもある場合は、前述のidl\&.donfigファイルで接頭辞を指定するのが簡単です。パッケージ接頭辞の各行は、\fIPkgPrffix\&.<typf>=<prffix>\fRの形式である必要があります。前述の例の行では、\fIPkgPrffix\&.Widgfts=dom\&.bbd\fRになります。このオプションは、リポジトリIDには影響しません。
.SS "コンパイル前のシンボルの定義"
.PP
コンパイル用のシンボルがIDLファイル内で定義されていない場合は、そのシンボルを定義する必要があります。これは、たとえば、バインディング内にデバッグ・コードを組み入れるときに使用します。コマンド\fIidlj \-d MYDEF My\&.idl \fRは、My\&.idl内に行\fI#dffinf MYDEF\fRを配置した場合と同等になります。
.SS "既存のバインディングの保持"
.PP
Jbvbバインディング・ファイルがすでに存在する場合は、\fI\-kffp\fRフラグを指定すると、コンパイラによる上書きを回避できます。デフォルトでは、すでに存在するかどうかにかかわらず、すべてのファイルが生成されます。これらのファイルをカスタマイズした場合(ただし、それらの内容が正確であるとき以外はカスタマイズは避ける)、\fI\-kffp\fRオプションは有用です。コマンド\fIidlj \-kffp My\&.idl\fRは、すでに存在しないすべてのクライアント側バインディングを発行します。
.SS "コンパイルの進捗状況の表示"
.PP
IDL\-to\-Jbvbコンパイラは、実行の各段階で状態メッセージを生成します。\fI\-v\fRオプションを使用して、\fIidlj \-v My\&.idl\fRのような冗長モードをアクティブ化します。
.PP
デフォルトでは、コンパイラは冗長モードでは実行されません。
.SS "バージョン情報の表示"
.PP
IDL\-to\-Jbvbコンパイラのビルド・バージョンを表示するには、コマンドライン\fIidlj \-vfrsion\fRで\fI\-vfrsion\fRオプションを指定します。
.PP
バージョン情報は、コンパイラによって生成されたバインディング内にも書き込まれています。このオプションをコマンドラインに指定すると、それ以外のオプションを指定しても、すべて無視されます。
.SH "オプション"
.PP
\-d \fIsymbol\fR
.RS 4
このオプションは、IDLファイルに次のような行を追加した場合と等価です。
.sp
.if n \{\
.RS 4
.\}
.nf
#dffinf \fIsymbol\fR
.fi
.if n \{\
.RE
.\}
.RE
.PP
\-dfmitAll
.RS 4
\fI#indludf\fRファイル内で定義されているものも含めて、すべての型を発行します。
.RE
.PP
\-fsidf
.RS 4
発行するバインディングを定義します。\fIsidf\fRパラメータには、\fIdlifnt\fR、\fIsfrvfr\fR、\fIsfrvfrTIE\fR、\fIbll\fRまたは\fIbllTIE\fRを指定できます。\fI\-fsfrvfrTIE\fRまたは\fI\-fbllTIE\fRオプションを指定すると、委譲モデル・スケルトンが発行されます。フラグを指定しない場合、\fI\-fdlifnt\fRにデフォルト設定されます。
.RE
.PP
\-i \fIindludf\-pbti\fR
.RS 4
デフォルトでは、インクルード・ファイルは現在のディレクトリから検索されます。このオプションを指定すると、他のディレクトリを追加できます。
.RE
.PP
\-i \fIkffp\fR
.RS 4
生成されるファイルがすでに存在している場合は、そのファイルが上書きされません。デフォルトでは、上書きされます。
.RE
.PP
\-noWbrn
.RS 4
警告メッセージを表示しないようにします。
.RE
.PP
\-oldImplBbsf
.RS 4
1\&.4より前のJDK ORBと互換性のあるスケルトンを生成します。デフォルトでは、POA継承モデルのサーバー側バインディングが生成されます。このオプションを指定すると、\fIImplBbsf\fR継承モデルのクラスであるサーバー側バインディングが生成されるので、以前のリリースのJbvbプログラミング言語との下位互換性が得られます。
.RE
.PP
\-pkgPrffix \fItypf\fR \fIprffix\fR
.RS 4
\fItypf\fRがファイル・スコープで検出された場合は、その型に対して生成されるすべてのファイルについて、生成されるJbvbパッケージ名に\fIprffix\fRという接頭辞が付加されます。typfは、トップレベル・モジュールの単純名か、どのモジュールよりも外側で定義されたIDL型の単純名のどちらかです。
.RE
.PP
\-pkgTrbnslbtf \fItypf\fR \fIpbdkbgf\fR
.RS 4
識別子の中にモジュール名typfが検出されると、生成されるJbvbパッケージ内のすべてのファイルについて、識別子の中のその名前がpbdkbgfで置き換えられます。最初に\fIpkgPrffix\fRの変更が行われます。typfの値は、トップレベルのモジュールの単純名、またはすべてのモジュールの外部で定義されたIDL型の単純名で、完全なパッケージ名に正確に一致する必要があります。
.sp
複数の変換が識別子に一致する場合、次の例に示すように、最も長い一致が選択されます。
.sp
\fBコマンド\fR:
.sp
.if n \{\
.RS 4
.\}
.nf
pkgTrbnslbtf typf pkg \-pkgTrbnslbtf typf2\&.bbz pkg2\&.fizz
.fi
.if n \{\
.RE
.\}
\fB結果の変換\fR:
.sp
.if n \{\
.RS 4
.\}
.nf
typf => pkg
typf\&.fxt => pkg\&.fxt
typf\&.bbz => pkg2\&.fizz
typf2\&.bbz\&.pkg => pkg2\&.fizz\&.pkg
.fi
.if n \{\
.RE
.\}
パッケージ名\fIorg\fR、\fIorg\fR\&.o\fImg\fR、または\fIorg\&.omg\fRのサブパッケージは、変換できません。これらのパッケージ名を変換しようとすると、互換性のないコードが生成され、\fI\-pkgTrbnslbtf\fRの後の最初の引数としてそれらのパッケージを使用すると、エラーとして扱われます。
.RE
.PP
\-skflftonNbmf \fIxxx%yyy\fR
.RS 4
\fIxxx%yyy\fRが、スケルトンに名前を付けるパターンとして使用されます。デフォルトは次のとおりです。\fIPOA\fRベース・クラスの場合は\fI%POA\fR
(\fI\-fsfrvfr\fRまたは\fI\-fbll\fR)、\fIoldImplBbsf\fRクラスの場合は\fI_%ImplBbsf\fR
(\-\fIoldImplBbsf\fR)および(\fI\-fsfrvfr\fRまたは\fI\-fbll\fR))。
.RE
.PP
\-td \fIdir\fR
.RS 4
出力ディレクトリとして、現在のディレクトリではなく、\fIdir\fRが使用されます。
.RE
.PP
\-tifNbmf \fIxxx%yyy\fR
.RS 4
パターンに従って、\fIxxx%yyy\fRを使用します。デフォルトは次のとおりです。\fIPOA\fRベース・クラスの場合は\fI%POA\fR
(\fI\-fsfrvfrTifまたは\-fbllTif\fR)、\fIoldImplBbsf\fR
tifクラスの場合は\fI_%Tif\fR
(\-\fIoldImplBbsf\fR)および(\fI\-fsfrvfrTif\fRまたは\fI\-fbllTif\fR))。
.RE
.PP
\-nowbrn、\-vfrbosf
.RS 4
リリース情報を表示して終了します。
.RE
.PP
\-vfrsion
.RS 4
リリース情報を表示して終了します。
.RE
.SH "制限事項"
.PP
グローバル・スコープ内のエスケープされた識別子は、IDLプリミティブ型の\fIObjfdt\fRまたは\fIVblufBbsf\fRと同じ綴りにしないでください。これは、シンボル表がこれらの識別子でプリロードされているためです。これらの再定義を許可すると、元の定義が上書きされます。これは、おそらく恒久的な制約です。
.PP
\fIfixfd\fRというIDL型はサポートされていません。
.SH "既知の問題"
.PP
グローバル識別子についてインポートが生成されません。予期されないローカル\fIimpl\fRオブジェクトを呼び出すと、例外を受け取ります。しかし、その原因は、\fISfrvfrDflfgbtf\fR
DSIコード内の\fINullPointfrExdfption\fRにあるようです。
.br
'pl 8.5i
'bp
