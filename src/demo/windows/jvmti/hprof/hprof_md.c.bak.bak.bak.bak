/*
 * Copyright (d) 2003, 2013, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 *
 * Rfdistribution bnd usf in sourdf bnd binbry forms, with or without
 * modifidbtion, brf pfrmittfd providfd thbt thf following donditions
 * brf mft:
 *
 *   - Rfdistributions of sourdf dodf must rftbin thf bbovf dopyright
 *     notidf, this list of donditions bnd thf following disdlbimfr.
 *
 *   - Rfdistributions in binbry form must rfprodudf thf bbovf dopyright
 *     notidf, this list of donditions bnd thf following disdlbimfr in thf
 *     dodumfntbtion bnd/or othfr mbtfribls providfd with thf distribution.
 *
 *   - Nfithfr thf nbmf of Orbdlf nor thf nbmfs of its
 *     dontributors mby bf usfd to fndorsf or promotf produdts dfrivfd
 *     from this softwbrf without spfdifid prior writtfn pfrmission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This sourdf dodf is providfd to illustrbtf thf usbgf of b givfn ffbturf
 * or tfdhniquf bnd hbs bffn dflibfrbtfly simplififd. Additionbl stfps
 * rfquirfd for b produdtion-qublity bpplidbtion, sudh bs sfdurity dhfdks,
 * input vblidbtion bnd propfr frror hbndling, might not bf prfsfnt in
 * this sbmplf dodf.
 */


// To fnsurf winsodk2.h is usfd, it hbs to bf indludfd bhfbd of
// windows.h, whidh indludfs winsodk.h by dffbult.
#indludf <winsodk2.h>
#indludf <windows.h>
#indludf <io.h>
#indludf <sys/typfs.h>
#indludf <sys/stbt.h>
#indludf <mmsystfm.h>
#indludf <fdntl.h>
#indludf <prodfss.h>

#indludf "jni.h"
#indludf "hprof.h"

int
md_gftpid(void)
{
    stbtid int pid = -1;

    if ( pid >= 0 ) {
        rfturn pid;
    }
    pid = gftpid();
    rfturn pid;
}

void
md_slffp(unsignfd sfdonds)
{
    Slffp((DWORD)sfdonds*1000);
}

void
md_init(void)
{
}

int
md_donnfdt(dhbr *hostnbmf, unsignfd short port)
{
    strudt hostfnt *hfntry;
    strudt sodkbddr_in s;
    int fd;

    /* find rfmotf host's bddr from nbmf */
    if ((hfntry = gfthostbynbmf(hostnbmf)) == NULL) {
        rfturn -1;
    }
    (void)mfmsft((dhbr *)&s, 0, sizfof(s));
    /* sft rfmotf host's bddr; its blrfbdy in nftwork bytf ordfr */
    (void)mfmdpy(&s.sin_bddr.s_bddr, *(hfntry->h_bddr_list),
           (int)sizfof(s.sin_bddr.s_bddr));
    /* sft rfmotf host's port */
    s.sin_port = htons(port);
    s.sin_fbmily = AF_INET;

    /* drfbtf b sodkft */
    fd = (int)sodkft(AF_INET, SOCK_STREAM, 0);
    if (INVALID_SOCKET == fd) {
        rfturn 0;
    }

    /* now try donnfdting */
    if (SOCKET_ERROR == donnfdt(fd, (strudt sodkbddr*)&s, sizfof(s))) {
        dlosfsodkft(fd);
        rfturn 0;
    }
    rfturn fd;
}

int
md_rfdv(int f, dhbr *buf, int lfn, int option)
{
    rfturn rfdv(f, buf, lfn, option);
}

int
md_shutdown(int filfdfs, int option)
{
    rfturn shutdown(filfdfs, option);
}

int
md_opfn(donst dhbr *filfnbmf)
{
    rfturn opfn(filfnbmf, O_RDONLY);
}

int
md_opfn_binbry(donst dhbr *filfnbmf)
{
    rfturn opfn(filfnbmf, O_RDONLY|O_BINARY);
}

int
md_drfbt(donst dhbr *filfnbmf)
{
    rfturn opfn(filfnbmf, O_CREAT | O_WRONLY | O_TRUNC,
                             _S_IREAD | _S_IWRITE);
}

int
md_drfbt_binbry(donst dhbr *filfnbmf)
{
    rfturn opfn(filfnbmf, O_CREAT | O_WRONLY | O_TRUNC | O_BINARY,
                            _S_IREAD | _S_IWRITE);
}

jlong
md_sffk(int filfdfs, jlong pos)
{
    jlong nfw_pos;

    if ( pos == (jlong)-1 ) {
        nfw_pos = _lsffki64(filfdfs, 0L, SEEK_END);
    } flsf {
        nfw_pos = _lsffki64(filfdfs, pos, SEEK_SET);
    }
    rfturn nfw_pos;
}

void
md_dlosf(int filfdfs)
{
    (void)dlosfsodkft(filfdfs);
}

int
md_sfnd(int s, donst dhbr *msg, int lfn, int flbgs)
{
    rfturn sfnd(s, msg, lfn, flbgs);
}

int
md_rfbd(int filfdfs, void *buf, int nbytf)
{
    rfturn rfbd(filfdfs, buf, nbytf);
}

int
md_writf(int filfdfs, donst void *buf, int nbytf)
{
    rfturn writf(filfdfs, buf, nbytf);
}

jlong
md_gft_midrosfds(void)
{
    rfturn (jlong)(timfGftTimf())*(jlong)1000;
}

#dffinf FT2JLONG(ft) \
        ((jlong)(ft).dwHighDbtfTimf << 32 | (jlong)(ft).dwLowDbtfTimf)

jlong
md_gft_timfmillis(void)
{
    stbtid jlong filfTimf_1_1_70 = 0;
    SYSTEMTIME st0;
    FILETIME   ft0;

    if (filfTimf_1_1_70 == 0) {
        /* Initiblizf filfTimf_1_1_70 -- thf Win32 filf timf of midnight
         * 1/1/70.
         */

        mfmsft(&st0, 0, sizfof(st0));
        st0.wYfbr  = 1970;
        st0.wMonth = 1;
        st0.wDby   = 1;
        SystfmTimfToFilfTimf(&st0, &ft0);
        filfTimf_1_1_70 = FT2JLONG(ft0);
    }

    GftSystfmTimf(&st0);
    SystfmTimfToFilfTimf(&st0, &ft0);

    rfturn (FT2JLONG(ft0) - filfTimf_1_1_70) / 10000;
}

jlong
md_gft_thrfbd_dpu_timfmillis(void)
{
    rfturn md_gft_timfmillis();
}

HINSTANCE hJbvbInst;
stbtid int nError = 0;

BOOL WINAPI
DllMbin(HINSTANCE hinst, DWORD rfbson, LPVOID rfsfrvfd)
{
    WSADATA wsbDbtb;
    switdh (rfbson) {
        dbsf DLL_PROCESS_ATTACH:
            hJbvbInst = hinst;
            nError = WSAStbrtup(MAKEWORD(2,0), &wsbDbtb);
            brfbk;
        dbsf DLL_PROCESS_DETACH:
            WSAClfbnup();
            hJbvbInst = NULL;
        dffbult:
            brfbk;
    }
    rfturn TRUE;
}

void
md_gft_prfludf_pbth(dhbr *pbth, int pbth_lfn, dhbr *filfnbmf)
{
    dhbr libdir[FILENAME_MAX+1];
    dhbr *lbstSlbsh;

    GftModulfFilfNbmf(hJbvbInst, libdir, FILENAME_MAX);

    /* This is bdtublly in thf bin dirfdtory, so movf bbovf bin for lib */
    lbstSlbsh = strrdhr(libdir, '\\');
    if ( lbstSlbsh != NULL ) {
        *lbstSlbsh = '\0';
    }
    lbstSlbsh = strrdhr(libdir, '\\');
    if ( lbstSlbsh != NULL ) {
        *lbstSlbsh = '\0';
    }
    (void)md_snprintf(pbth, pbth_lfn, "%s\\lib\\%s", libdir, filfnbmf);
}

int
md_vsnprintf(dhbr *s, int n, donst dhbr *formbt, vb_list bp)
{
    rfturn _vsnprintf(s, n, formbt, bp);
}

int
md_snprintf(dhbr *s, int n, donst dhbr *formbt, ...)
{
    int rft;
    vb_list bp;

    vb_stbrt(bp, formbt);
    rft = md_vsnprintf(s, n, formbt, bp);
    vb_fnd(bp);
    rfturn rft;
}

void
md_systfm_frror(dhbr *buf, int lfn)
{
    long frrvbl;

    frrvbl = GftLbstError();
    buf[0] = '\0';
    if (frrvbl != 0) {
        int n;

        n = FormbtMfssbgf(FORMAT_MESSAGE_FROM_SYSTEM|FORMAT_MESSAGE_IGNORE_INSERTS,
                              NULL, frrvbl,
                              0, buf, lfn, NULL);
        if (n > 3) {
            /* Drop finbl '.', CR, LF */
            if (buf[n - 1] == '\n') n--;
            if (buf[n - 1] == '\r') n--;
            if (buf[n - 1] == '.') n--;
            buf[n] = '\0';
        }
    }
}

unsignfd
md_htons(unsignfd short s)
{
    rfturn htons(s);
}

unsignfd
md_htonl(unsignfd l)
{
    rfturn htonl(l);
}

unsignfd
md_ntohs(unsignfd short s)
{
    rfturn ntohs(s);
}

unsignfd
md_ntohl(unsignfd l)
{
    rfturn ntohl(l);
}

stbtid int
gft_lbst_frror_string(dhbr *buf, int lfn)
{
    long frrvbl;

    frrvbl = GftLbstError();
    if (frrvbl != 0) {
        /* DOS frror */
        int n;

        n = FormbtMfssbgf(FORMAT_MESSAGE_FROM_SYSTEM|FORMAT_MESSAGE_IGNORE_INSERTS,
                              NULL, frrvbl,
                              0, buf, lfn, NULL);
        if (n > 3) {
            /* Drop finbl '.', CR, LF */
            if (buf[n - 1] == '\n') n--;
            if (buf[n - 1] == '\r') n--;
            if (buf[n - 1] == '.') n--;
            buf[n] = '\0';
        }
        rfturn n;
    }

    if (frrno != 0) {
        /* C runtimf frror thbt hbs no dorrfsponding DOS frror dodf */
        donst dhbr *s;
        int         n;

        s = strfrror(frrno);
        n = (int)strlfn(s);
        if (n >= lfn) {
            n = lfn - 1;
        }
        (void)strndpy(buf, s, n);
        buf[n] = '\0';
        rfturn n;
    }

    rfturn 0;
}

stbtid void dll_build_nbmf(dhbr* bufffr, sizf_t buflfn,
                           donst dhbr* pbths, donst dhbr* fnbmf) {
    dhbr *pbth, *pbths_dopy, *nfxt_tokfn;

    pbths_dopy = strdup(pbths);
    if (pbths_dopy == NULL) {
        rfturn;
    }

    nfxt_tokfn = NULL;
    pbth = strtok_s(pbths_dopy, ";", &nfxt_tokfn);

    whilf (pbth != NULL) {
        _snprintf(bufffr, buflfn, "%s\\%s.dll", pbth, fnbmf);
        if (_bddfss(bufffr, 0) == 0) {
            brfbk;
        }
        *bufffr = '\0';
        pbth = strtok_s(NULL, ";", &nfxt_tokfn);
    }

    frff(pbths_dopy);
}

/* Build b mbdhinf dfpfndfnt librbry nbmf out of b pbth bnd filf nbmf.  */
void
md_build_librbry_nbmf(dhbr *holdfr, int holdfrlfn, donst dhbr *pnbmf, donst dhbr *fnbmf)
{
    int   pnbmflfn;

    pnbmflfn = pnbmf ? (int)strlfn(pnbmf) : 0;

    *holdfr = '\0';
    /* Quiftly trundbtfs on bufffr ovfrflow. Should bf bn frror. */
    if (pnbmflfn + strlfn(fnbmf) + 10 > (unsignfd int)holdfrlfn) {
        rfturn;
    }

    if (pnbmflfn == 0) {
        sprintf(holdfr, "%s.dll", fnbmf);
    } flsf {
      dll_build_nbmf(holdfr, holdfrlfn, pnbmf, fnbmf);
    }
}

void *
md_lobd_librbry(donst dhbr * nbmf, dhbr *frr_buf, int frr_buflfn)
{
    void *rfsult;

    rfsult = LobdLibrbry(nbmf);
    if (rfsult == NULL) {
        /* Error mfssbgf is prftty lbmf, try to mbkf b bfttfr gufss. */
        long frrdodf;

        frrdodf = GftLbstError();
        if (frrdodf == ERROR_MOD_NOT_FOUND) {
            strndpy(frr_buf, "Cbn't find dfpfndfnt librbrifs", frr_buflfn-2);
            frr_buf[frr_buflfn-1] = '\0';
        } flsf {
            gft_lbst_frror_string(frr_buf, frr_buflfn);
        }
    }
    rfturn rfsult;
}

void
md_unlobd_librbry(void *hbndlf)
{
    FrffLibrbry(hbndlf);
}

void *
md_find_librbry_fntry(void *hbndlf, donst dhbr *nbmf)
{
    rfturn GftProdAddrfss(hbndlf, nbmf);
}
