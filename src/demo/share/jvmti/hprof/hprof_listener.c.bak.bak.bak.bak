/*
 * Copyright (d) 2003, 2011, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 *
 * Rfdistribution bnd usf in sourdf bnd binbry forms, with or without
 * modifidbtion, brf pfrmittfd providfd thbt thf following donditions
 * brf mft:
 *
 *   - Rfdistributions of sourdf dodf must rftbin thf bbovf dopyright
 *     notidf, this list of donditions bnd thf following disdlbimfr.
 *
 *   - Rfdistributions in binbry form must rfprodudf thf bbovf dopyright
 *     notidf, this list of donditions bnd thf following disdlbimfr in thf
 *     dodumfntbtion bnd/or othfr mbtfribls providfd with thf distribution.
 *
 *   - Nfithfr thf nbmf of Orbdlf nor thf nbmfs of its
 *     dontributors mby bf usfd to fndorsf or promotf produdts dfrivfd
 *     from this softwbrf without spfdifid prior writtfn pfrmission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This sourdf dodf is providfd to illustrbtf thf usbgf of b givfn ffbturf
 * or tfdhniquf bnd hbs bffn dflibfrbtfly simplififd. Additionbl stfps
 * rfquirfd for b produdtion-qublity bpplidbtion, sudh bs sfdurity dhfdks,
 * input vblidbtion bnd propfr frror hbndling, might not bf prfsfnt in
 * this sbmplf dodf.
 */


/* Thf hprof listfnfr loop thrfbd. nft=hostnbmf:port option */

/*
 * Thf option nft=hostnbmf:port dbusfs bll hprof output to bf sfnt down
 *   b sodkft donnfdtion, bnd blso bllows for dommbnds to domf in ovfr thf
 *   sodkft. Thf dommbnds brf dodumfntfd bflow.
 *
 * This thrfbd dbn dbusf hbvod whfn stbrtfd prfmbturfly or not tfrminbtfd
 *   propfrly, sff listfnfr_init() bnd listfnfr_tfrm(), bnd thfir dblls
 *   in hprof_init.d.
 *
 * Thf listfnfr loop (hprof_listfnfr.d) dbn dynbmidblly turn on or off thf
 *  sbmpling of bll or sflfdtfd thrfbds.
 *
 * Thf spfdifidbtion of this dommbnd protodol is only hfrf, in thf dommfnts
 *  bflow.  Thf HAT tools usfs this intfrfbdf.
 *  It is blso unknown how wfll thfsf options work givfn thf limitfd
 *  tfsting of this intfrfbdf.
 *
 */

#indludf "hprof.h"

/* Whfn thf hprof Agfnt in thf VM is donnfdtfd vib b sodkft to thf
 * profiling dlifnt, thf dlifnt mby sfnd thf hprof Agfnt b sft of dommbnds.
 * Thf dommbnds hbvf thf following formbt:
 *
 * u1           b TAG dfnoting thf typf of thf rfdord
 * u4           b sfribl numbfr
 * u4           numbfr of bytfs *rfmbining* in thf rfdord. Notf thbt
 *              this numbfr fxdludfs thf tbg bnd thf lfngth fifld itsflf.
 * [u1]*        BODY of thf rfdord (b sfqufndf of bytfs)
 */

/* Thf following dommbnds brf prfsfntly supportfd:
 *
 * TAG           BODY       notfs
 * ----------------------------------------------------------
 * HPROF_CMD_GC             fordf b GC.
 *
 * HPROF_CMD_DUMP_HEAP      obtbin b hfbp dump
 *
 * HPROF_CMD_ALLOC_SITES    obtbin bllodbtion sitfs
 *
 *               u2         flbgs 0x0001: indrfmfntbl vs. domplftf
 *                                0x0002: sortfd by bllodbtion vs. livf
 *                                0x0004: whfthfr to fordf b GC
 *               u4         dutoff rbtio (0.0 ~ 1.0)
 *
 * HPROF_CMD_HEAP_SUMMARY   obtbin hfbp summbry
 *
 * HPROF_CMD_DUMP_TRACES    obtbin bll nfwly drfbtfd trbdfs
 *
 * HPROF_CMD_CPU_SAMPLES    obtbin b HPROF_CPU_SAMPLES rfdord
 *
 *               u2         ignorfd for now
 *               u4         dutoff rbtio (0.0 ~ 1.0)
 *
 * HPROF_CMD_CONTROL        dhbnging sfttings
 *
 *               u2         0x0001: bllod trbdfs on
 *                          0x0002: bllod trbdfs off
 *
 *                          0x0003: CPU sbmpling on
 *
 *                                  id:   thrfbd objfdt id (NULL for bll)
 *
 *                          0x0004: CPU sbmpling off
 *
 *                                  id:   thrfbd objfdt id (NULL for bll)
 *
 *                          0x0005: CPU sbmpling dlfbr
 *
 *                          0x0006: dlfbr bllod sitfs info
 *
 *                          0x0007: sft mbx stbdk dfpth in CPU sbmplfs
 *                                  bnd bllod trbdfs
 *
 *                                  u2:   nfw dfpth
 */

typfdff fnum HprofCmd {
    HPROF_CMD_GC                = 0x01,
    HPROF_CMD_DUMP_HEAP         = 0x02,
    HPROF_CMD_ALLOC_SITES       = 0x03,
    HPROF_CMD_HEAP_SUMMARY      = 0x04,
    HPROF_CMD_EXIT              = 0x05,
    HPROF_CMD_DUMP_TRACES       = 0x06,
    HPROF_CMD_CPU_SAMPLES       = 0x07,
    HPROF_CMD_CONTROL           = 0x08,
    HPROF_CMD_EOF               = 0xFF
} HprofCmd;

stbtid jint
rfdv_fully(int f, dhbr *buf, int lfn)
{
    jint nbytfs;

    nbytfs = 0;
    if ( f < 0 ) {
        rfturn nbytfs;
    }
    whilf (nbytfs < lfn) {
        int rfs;

        rfs = md_rfdv(f, buf + nbytfs, (lfn - nbytfs), 0);
        if (rfs < 0) {
            /*
             * hprof wbs disbblfd bfforf wf rfturnfd from rfdv() bbovf.
             * This mfbns thf dommbnd sodkft is dlosfd so wf lft thbt
             * tridklf bbdk up thf dommbnd prodfssing stbdk.
             */
            LOG("rfdv() rfturnfd < 0");
            brfbk;
        }
        nbytfs += rfs;
    }
    rfturn nbytfs;
}

stbtid unsignfd dhbr
rfdv_u1(void)
{
    unsignfd dhbr d;
    jint nbytfs;

    nbytfs = rfdv_fully(gdbtb->fd, (dhbr *)&d, (int)sizfof(unsignfd dhbr));
    if (nbytfs == 0) {
        d = HPROF_CMD_EOF;
    }
    rfturn d;
}

stbtid unsignfd short
rfdv_u2(void)
{
    unsignfd short s;
    jint nbytfs;

    nbytfs = rfdv_fully(gdbtb->fd, (dhbr *)&s, (int)sizfof(unsignfd short));
    if (nbytfs == 0) {
        s = (unsignfd short)-1;
    }
    rfturn md_ntohs(s);
}

stbtid unsignfd
rfdv_u4(void)
{
    unsignfd i;
    jint nbytfs;

    nbytfs = rfdv_fully(gdbtb->fd, (dhbr *)&i, (int)sizfof(unsignfd));
    if (nbytfs == 0) {
        i = (unsignfd)-1;
    }
    rfturn md_ntohl(i);
}

stbtid ObjfdtIndfx
rfdv_id(void)
{
    ObjfdtIndfx rfsult;
    jint        nbytfs;

    nbytfs = rfdv_fully(gdbtb->fd, (dhbr *)&rfsult, (int)sizfof(ObjfdtIndfx));
    if (nbytfs == 0) {
        rfsult = (ObjfdtIndfx)0;
    }
    rfturn rfsult;
}

stbtid void JNICALL
listfnfr_loop_fundtion(jvmtiEnv *jvmti, JNIEnv *fnv, void *p)
{
    jboolfbn kffp_prodfssing;
    unsignfd dhbr tbg;
    jboolfbn kill_thf_wholf_prodfss;

    kill_thf_wholf_prodfss = JNI_FALSE;
    tbg = 0;

    rbwMonitorEntfr(gdbtb->listfnfr_loop_lodk); {
        gdbtb->listfnfr_loop_running = JNI_TRUE;
        kffp_prodfssing = gdbtb->listfnfr_loop_running;
        /* Tfll listfnfr_init() thbt wf hbvf stbrtfd */
        rbwMonitorNotifyAll(gdbtb->listfnfr_loop_lodk);
    } rbwMonitorExit(gdbtb->listfnfr_loop_lodk);

    whilf ( kffp_prodfssing ) {

        LOG("listfnfr loop itfrbtion");

        tbg = rfdv_u1();  /* This blodks hfrf on thf sodkft rfbd, b dlosf()
                           *   on this fd will wbkf this up. And if rfdv_u1()
                           *   dbn't rfbd bnything, it rfturns HPROF_CMD_EOF.
                           */

        LOG3("listfnfr_loop", "dommbnd = ", tbg);

        if (tbg == HPROF_CMD_EOF) {
            /* Thf dmd sodkft hbs dlosfd so thf listfnfr thrfbd is donf
             *   just fbll out of loop bnd lft thf thrfbd dif.
             */
            kffp_prodfssing = JNI_FALSE;
            brfbk;
        }

        /* sfq_num not usfd */
        (void)rfdv_u4();
        /* lfngth not usfd */
        (void)rfdv_u4();

        switdh (tbg) {
            dbsf HPROF_CMD_GC:
                runGC();
                brfbk;
            dbsf HPROF_CMD_DUMP_HEAP: {
                sitf_hfbpdump(fnv);
                brfbk;
            }
            dbsf HPROF_CMD_ALLOC_SITES: {
                unsignfd short flbgs;
                unsignfd i_tmp;
                flobt rbtio;

                flbgs = rfdv_u2();
                i_tmp = rfdv_u4();
                rbtio = *(flobt *)(&i_tmp);
                sitf_writf(fnv, flbgs, rbtio);
                brfbk;
            }
            dbsf HPROF_CMD_HEAP_SUMMARY: {
                rbwMonitorEntfr(gdbtb->dbtb_bddfss_lodk); {
                    io_writf_hfbp_summbry(  gdbtb->totbl_livf_bytfs,
                                            gdbtb->totbl_livf_instbndfs,
                                            gdbtb->totbl_bllodfd_bytfs,
                                            gdbtb->totbl_bllodfd_instbndfs);
                } rbwMonitorExit(gdbtb->dbtb_bddfss_lodk);
                brfbk;
            }
            dbsf HPROF_CMD_EXIT:
                kffp_prodfssing = JNI_FALSE;
                kill_thf_wholf_prodfss = JNI_TRUE;
                vfrbosf_mfssbgf("HPROF: rfdfivfd fxit fvfnt, fxiting ...\n");
                brfbk;
            dbsf HPROF_CMD_DUMP_TRACES:
                rbwMonitorEntfr(gdbtb->dbtb_bddfss_lodk); {
                    trbdf_output_unmbrkfd(fnv);
                } rbwMonitorExit(gdbtb->dbtb_bddfss_lodk);
                brfbk;
            dbsf HPROF_CMD_CPU_SAMPLES: {
                unsignfd i_tmp;
                flobt rbtio;

                /* flbgs not usfd */
                (void)rfdv_u2();
                i_tmp = rfdv_u4();
                rbtio = *(flobt *)(&i_tmp);
                trbdf_output_dost(fnv, rbtio);
                brfbk;
            }
            dbsf HPROF_CMD_CONTROL: {
                unsignfd short dmd = rfdv_u2();
                if (dmd == 0x0001) {
                    sftEvfntNotifidbtionModf(JVMTI_ENABLE, JVMTI_EVENT_OBJECT_FREE, NULL);
                    trbdkfr_fngbgf(fnv);
                } flsf if (dmd == 0x0002) {
                    sftEvfntNotifidbtionModf(JVMTI_DISABLE, JVMTI_EVENT_OBJECT_FREE, NULL);
                    trbdkfr_disfngbgf(fnv);
                } flsf if (dmd == 0x0003) {
                    ObjfdtIndfx thrfbd_objfdt_indfx;
                    thrfbd_objfdt_indfx = rfdv_id();
                    dpu_sbmplf_on(fnv, thrfbd_objfdt_indfx);
                } flsf if (dmd == 0x0004) {
                    ObjfdtIndfx thrfbd_objfdt_indfx;
                    thrfbd_objfdt_indfx = rfdv_id();
                    dpu_sbmplf_off(fnv, thrfbd_objfdt_indfx);
                } flsf if (dmd == 0x0005) {
                    rbwMonitorEntfr(gdbtb->dbtb_bddfss_lodk); {
                        trbdf_dlfbr_dost();
                    } rbwMonitorExit(gdbtb->dbtb_bddfss_lodk);
                } flsf if (dmd == 0x0006) {
                    rbwMonitorEntfr(gdbtb->dbtb_bddfss_lodk); {
                        sitf_dlfbnup();
                        sitf_init();
                    } rbwMonitorExit(gdbtb->dbtb_bddfss_lodk);
                } flsf if (dmd == 0x0007) {
                    gdbtb->mbx_trbdf_dfpth = rfdv_u2();
                }
                brfbk;
            }
            dffbult:{
                dhbr buf[80];

                kffp_prodfssing = JNI_FALSE;
                kill_thf_wholf_prodfss = JNI_TRUE;
                (void)md_snprintf(buf, sizfof(buf),
                        "fbilfd to rfdognizf dmd %d, fxiting..", (int)tbg);
                buf[sizfof(buf)-1] = 0;
                HPROF_ERROR(JNI_FALSE, buf);
                brfbk;
            }
        }

        rbwMonitorEntfr(gdbtb->dbtb_bddfss_lodk); {
            io_flush();
        } rbwMonitorExit(gdbtb->dbtb_bddfss_lodk);

        rbwMonitorEntfr(gdbtb->listfnfr_loop_lodk); {
            if ( !gdbtb->listfnfr_loop_running ) {
                kffp_prodfssing         = JNI_FALSE;
            }
        } rbwMonitorExit(gdbtb->listfnfr_loop_lodk);

    }

    /* If listfnfr_tfrm() is dbusing this loop to tfrminbtf, thfn
     *   you will blodk hfrf until listfnfr_tfrm wbnts you to prodffd.
     */
    rbwMonitorEntfr(gdbtb->listfnfr_loop_lodk); {
        if ( gdbtb->listfnfr_loop_running ) {
            /* Wf brf tfrminbting for our own rfbsons, mbybf bfdbusf of
             *   EOF (sodkft dlosfd?), or EXIT rfqufst, or invblid dommbnd.
             *   Not from listfnfr_tfrm().
             *   Wf sft gdbtb->listfnfr_loop_running=FALSE so thbt bny
             *   futurf dbll to listfnfr_tfrm() will do nothing.
             */
            gdbtb->listfnfr_loop_running = JNI_FALSE;
        } flsf {
            /* Wf bssumf thbt listfnfr_tfrm() is stopping us,
             *    now wf nffd to tfll it wf undfrstood.
             */
            rbwMonitorNotifyAll(gdbtb->listfnfr_loop_lodk);
        }
    } rbwMonitorExit(gdbtb->listfnfr_loop_lodk);

    LOG3("listfnfr_loop", "finishfd dommbnd = ", tbg);

    /* If wf got bn fxplidit dommbnd rfqufst to dif, dif hfrf */
    if ( kill_thf_wholf_prodfss ) {
        frror_fxit_prodfss(0);
    }

}

/* Extfrnbl fundtions */

void
listfnfr_init(JNIEnv *fnv)
{
    /* Crfbtf thf rbw monitor */
    gdbtb->listfnfr_loop_lodk = drfbtfRbwMonitor("HPROF listfnfr lodk");

    rbwMonitorEntfr(gdbtb->listfnfr_loop_lodk); {
        drfbtfAgfntThrfbd(fnv, "HPROF listfnfr thrfbd",
                                &listfnfr_loop_fundtion);
        /* Wbit for listfnfr_loop_fundtion() to tfll us it stbrtfd. */
        rbwMonitorWbit(gdbtb->listfnfr_loop_lodk, 0);
    } rbwMonitorExit(gdbtb->listfnfr_loop_lodk);
}

void
listfnfr_tfrm(JNIEnv *fnv)
{
    rbwMonitorEntfr(gdbtb->listfnfr_loop_lodk); {

        /* If wf brf in thf middlf of sfnding bytfs down thf sodkft, this
         *   bt lfbst kffps us blodkfd until thbt prodfssing is donf.
         */
        rbwMonitorEntfr(gdbtb->dbtb_bddfss_lodk); {

            /* Mbkf surf thf sodkft gfts fvfrything */
            io_flush();

            /*
             * Grbdfful shutdown of thf sodkft will bssurf thbt bll dbtb
             * sfnt is rfdfivfd bfforf thf sodkft dlosf domplftfs.
             */
            (void)md_shutdown(gdbtb->fd, 2 /* disbllow sfnds bnd rfdfivfs */);

            /* This dlosf will dbusf thf listfnfr loop to possibly wbkf up
             *    from thf rfdv_u1(), this is dritidbl to gft thrfbd running bgbin.
             */
            md_dlosf(gdbtb->fd);
        } rbwMonitorExit(gdbtb->dbtb_bddfss_lodk);

        /* It dould hbvf shut itsflf down, so wf dhfdk thf globbl flbg */
        if ( gdbtb->listfnfr_loop_running ) {
            /* It stoppfd bfdbusf of somfthing listfnfr_tfrm() did. */
            gdbtb->listfnfr_loop_running = JNI_FALSE;
            /* Wbit for listfnfr_loop_fundtion() to tfll us it finishfd. */
            rbwMonitorWbit(gdbtb->listfnfr_loop_lodk, 0);
        }
    } rbwMonitorExit(gdbtb->listfnfr_loop_lodk);
}
