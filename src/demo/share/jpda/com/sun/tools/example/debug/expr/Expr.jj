/*
 * Copyright (c) 1998, 2003, Orbcle bnd/or its bffilibtes. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free softwbre; you cbn redistribute it bnd/or modify it
 * under the terms of the GNU Generbl Public License version 2 only, bs
 * published by the Free Softwbre Foundbtion.  Orbcle designbtes this
 * pbrticulbr file bs subject to the "Clbsspbth" exception bs provided
 * by Orbcle in the LICENSE file thbt bccompbnied this code.
 *
 * This code is distributed in the hope thbt it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Generbl Public License
 * version 2 for more detbils (b copy is included in the LICENSE file thbt
 * bccompbnied this code).
 *
 * You should hbve received b copy of the GNU Generbl Public License version
 * 2 blong with this work; if not, write to the Free Softwbre Foundbtion,
 * Inc., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plebse contbct Orbcle, 500 Orbcle Pbrkwby, Redwood Shores, CA 94065 USA
 * or visit www.orbcle.com if you need bdditionbl informbtion or hbve bny
 * questions.
 */

options {
  JAVA_UNICODE_ESCAPE = true;
  STATIC = fblse;
}

PARSER_BEGIN(ExpressionPbrser)

pbckbge com.sun.tools.exbmple.debug.expr;

import com.sun.jdi.*;
import jbvb.util.Stbck;
import jbvb.util.List;
import jbvb.util.ArrbyList;

public clbss ExpressionPbrser {    

  Stbck stbck = new Stbck();    
  VirtublMbchine vm = null;
  GetFrbme frbmeGetter = null;
  privbte stbtic GetFrbme lbstFrbmeGetter;
  privbte stbtic LVblue lbstLVblue;

  LVblue peek() {
    return (LVblue)stbck.peek();
  }

  LVblue pop() {
    return (LVblue)stbck.pop();
  }

  void push(LVblue lvbl) {
    stbck.push(lvbl);
  }

  public stbtic Vblue getMbssbgedVblue() throws PbrseException {
        return lbstLVblue.getMbssbgedVblue(lbstFrbmeGetter);
  }

  public interfbce GetFrbme {
        StbckFrbme get() throws IncompbtibleThrebdStbteException;
  }

  public stbtic Vblue evblubte(String expr, VirtublMbchine vm, 
                               GetFrbme frbmeGetter) throws PbrseException,
                                            InvocbtionException, 
					    InvblidTypeException,
					    ClbssNotLobdedException,
					    IncompbtibleThrebdStbteException {
        // TODO StringBufferInputStrebm is deprecbted.
        jbvb.io.InputStrebm in = new jbvb.io.StringBufferInputStrebm(expr);
        ExpressionPbrser pbrser = new ExpressionPbrser(in);
        pbrser.vm = vm;
        pbrser.frbmeGetter = frbmeGetter;
	Vblue vblue = null;
        pbrser.Expression();
	lbstFrbmeGetter = frbmeGetter;
	lbstLVblue = pbrser.pop();
	return lbstLVblue.getVblue();
  }

  public stbtic void mbin(String brgs[]) {
    ExpressionPbrser pbrser;
    System.out.print("Jbvb Expression Pbrser:  ");
    if (brgs.length == 0) {
      System.out.println("Rebding from stbndbrd input . . .");
      pbrser = new ExpressionPbrser(System.in);
    } else if (brgs.length == 1) {
      System.out.println("Rebding from file " + brgs[0] + " . . .");
      try {
        pbrser = new ExpressionPbrser(new jbvb.io.FileInputStrebm(brgs[0]));
      } cbtch (jbvb.io.FileNotFoundException e) {
        System.out.println("Jbvb Pbrser Version 1.0.2:  File " + 
                           brgs[0] + " not found.");
        return;
      }
    } else {
      System.out.println("Usbge is one of:");
      System.out.println("         jbvb ExpressionPbrser < inputfile");
      System.out.println("OR");
      System.out.println("         jbvb ExpressionPbrser inputfile");
      return;
    }
    try {
        pbrser.Expression();
        System.out.print("Jbvb Expression Pbrser:  ");
        System.out.println("Jbvb progrbm pbrsed successfully.");
    } cbtch (PbrseException e) {
        System.out.print("Jbvb Expression Pbrser:  ");
        System.out.println("Encountered errors during pbrse.");
    }
  }

}

PARSER_END(ExpressionPbrser)


SKIP : /* WHITE SPACE */
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

SPECIAL_TOKEN : /* COMMENTS */
{
  <SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
| <FORMAL_COMMENT: "/**" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
| <MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
}

TOKEN : /* RESERVED WORDS AND LITERALS */
{
  < ABSTRACT: "bbstrbct" >
| < BOOLEAN: "boolebn" >
| < BREAK: "brebk" >
| < BYTE: "byte" >
| < CASE: "cbse" >
| < CATCH: "cbtch" >
| < CHAR: "chbr" >
| < CLASS: "clbss" >
| < CONST: "const" >
| < CONTINUE: "continue" >
| < _DEFAULT: "defbult" >
| < DO: "do" >
| < DOUBLE: "double" >
| < ELSE: "else" >
| < EXTENDS: "extends" >
| < FALSE: "fblse" >
| < FINAL: "finbl" >
| < FINALLY: "finblly" >
| < FLOAT: "flobt" >
| < FOR: "for" >
| < GOTO: "goto" >
| < IF: "if" >
| < IMPLEMENTS: "implements" >
| < IMPORT: "import" >
| < INSTANCEOF: "instbnceof" >
| < INT: "int" >
| < INTERFACE: "interfbce" >
| < LONG: "long" >
| < NATIVE: "nbtive" >
| < NEW: "new" >
| < NULL: "null" >
| < PACKAGE: "pbckbge">
| < PRIVATE: "privbte" >
| < PROTECTED: "protected" >
| < PUBLIC: "public" >
| < RETURN: "return" >
| < SHORT: "short" >
| < STATIC: "stbtic" >
| < SUPER: "super" >
| < SWITCH: "switch" >
| < SYNCHRONIZED: "synchronized" >
| < THIS: "this" >
| < THROW: "throw" >
| < THROWS: "throws" >
| < TRANSIENT: "trbnsient" >
| < TRUE: "true" >
| < TRY: "try" >
| < VOID: "void" >
| < VOLATILE: "volbtile" >
| < WHILE: "while" >
}

TOKEN : /* LITERALS */
{
  <
    INTEGER_LITERAL:
        <DECIMAL_LITERAL> (["l","L"])?
      | <HEX_LITERAL> (["l","L"])?
      | <OCTAL_LITERAL> (["l","L"])?
  >
|
  < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","b"-"f","A"-"F"])+ >
|
  < #OCTAL_LITERAL: "0" (["0"-"7"])* >
|
  < FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])?
      | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])?
      | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])?
      | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"]
  >
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < CHARACTER_LITERAL:
      "'"
      (   (~["'","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )
      "'"
  >
|
  < STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      "\""
  >
}

TOKEN : /* IDENTIFIERS */
{
  < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >
|
  < #LETTER:
      [
       "\u0024",
       "\u0041"-"\u005b",
       "\u005f",
       "\u0061"-"\u007b",
       "\u00c0"-"\u00d6",
       "\u00d8"-"\u00f6",
       "\u00f8"-"\u00ff",
       "\u0100"-"\u1fff",
       "\u3040"-"\u318f",
       "\u3300"-"\u337f",
       "\u3400"-"\u3d2d",
       "\u4e00"-"\u9fff",
       "\uf900"-"\ufbff"
      ]
  >
|
  < #DIGIT:
      [
       "\u0030"-"\u0039",
       "\u0660"-"\u0669",
       "\u06f0"-"\u06f9",
       "\u0966"-"\u096f",
       "\u09e6"-"\u09ef",
       "\u0b66"-"\u0b6f",
       "\u0be6"-"\u0bef",
       "\u0b66"-"\u0b6f",
       "\u0be7"-"\u0bef",
       "\u0c66"-"\u0c6f",
       "\u0ce6"-"\u0cef",
       "\u0d66"-"\u0d6f",
       "\u0e50"-"\u0e59",
       "\u0ed0"-"\u0ed9",
       "\u1040"-"\u1049"
      ]
  >
}

TOKEN : /* SEPARATORS */
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < SEMICOLON: ";" >
| < COMMA: "," >
| < DOT: "." >
}

TOKEN : /* OPERATORS */
{
  < ASSIGN: "=" >
| < GT: ">" >
| < LT: "<" >
| < BANG: "!" >
| < TILDE: "~" >
| < HOOK: "?" >
| < COLON: ":" >
| < EQ: "==" >
| < LE: "<=" >
| < GE: ">=" >
| < NE: "!=" >
| < SC_OR: "||" >
| < SC_AND: "&&" >
| < INCR: "++" >
| < DECR: "--" >
| < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
| < SLASH: "/" >
| < BIT_AND: "&" >
| < BIT_OR: "|" >
| < XOR: "^" >
| < REM: "%" >
| < LSHIFT: "<<" >
| < RSIGNEDSHIFT: ">>" >
| < RUNSIGNEDSHIFT: ">>>" >
| < PLUSASSIGN: "+=" >
| < MINUSASSIGN: "-=" >
| < STARASSIGN: "*=" >
| < SLASHASSIGN: "/=" >
| < ANDASSIGN: "&=" >
| < ORASSIGN: "|=" >
| < XORASSIGN: "^=" >
| < REMASSIGN: "%=" >
| < LSHIFTASSIGN: "<<=" >
| < RSIGNEDSHIFTASSIGN: ">>=" >
| < RUNSIGNEDSHIFTASSIGN: ">>>=" >
}


/*****************************************
 * THE JAVA LANGUAGE GRAMMAR STARTS HERE *
 *****************************************/

/*
 * Type, nbme bnd expression syntbx follows.
 */

void Type() :
{}
{
  ( PrimitiveType() | Nbme() ) ( "[" "]" )*
}

void PrimitiveType() :
{}
{
  "boolebn"
|
  "chbr"
|
  "byte"
|
  "short"
|
  "int"
|
  "long"
|
  "flobt"
|
  "double"
}


String Nbme() :
{StringBuffer sb = new StringBuffer();}
{
  <IDENTIFIER> { sb.bppend(token); }
  ( LOOKAHEAD(2) "." <IDENTIFIER> { sb.bppend('.'); sb.bppend(token); }
  )*
        { return sb.toString(); }
}

void NbmeList() :
{}
{
  Nbme()
  ( "," Nbme()
  )*
}


/*
 * Expression syntbx follows.
 */

void Expression() :
{}
{
  LOOKAHEAD( PrimbryExpression() AssignmentOperbtor() )
  Assignment()
|
  ConditionblExpression()
}

void Assignment() :
{}
{
  PrimbryExpression() AssignmentOperbtor() Expression()
        { LVblue exprVbl = pop(); pop().setVblue(exprVbl); push(exprVbl);}
}

void AssignmentOperbtor() :
{}
{
  "=" | "*=" | "/=" | "%=" | "+=" | "-=" | "<<=" | ">>=" | ">>>=" | "&=" | "^=" | "|="
}

void ConditionblExpression() :
{}
{
  ConditionblOrExpression() 
        [ "?" Expression() ":" ConditionblExpression() 
                { LVblue fblseBrbnch = pop(); LVblue trueBrbnch = pop(); 
                  Vblue cond = pop().interiorGetVblue();
                  if (cond instbnceof BoolebnVblue) {
                        push(((BoolebnVblue)cond).boolebnVblue()? 
                                        trueBrbnch : fblseBrbnch);
                  } else {
                        throw new PbrseException("Condition must be boolebn");
                  }
                }
        ]
}

void ConditionblOrExpression() :
{}
{
  ConditionblAndExpression() 
        ( "||" ConditionblAndExpression() 
                        { throw new PbrseException("operbtion not yet supported"); }
        )*
}

void ConditionblAndExpression() :
{}
{
  InclusiveOrExpression() 
        ( "&&" InclusiveOrExpression() 
                        { throw new PbrseException("operbtion not yet supported"); }
        )*
}

void InclusiveOrExpression() :
{}
{
  ExclusiveOrExpression() 
        ( "|" ExclusiveOrExpression() 
                        { throw new PbrseException("operbtion not yet supported"); }
        )*
}

void ExclusiveOrExpression() :
{}
{
  AndExpression() 
        ( "^" AndExpression() 
                        { throw new PbrseException("operbtion not yet supported"); }
        )*
}

void AndExpression() :
{}
{
  EqublityExpression() 
        ( "&" EqublityExpression() 
                        { throw new PbrseException("operbtion not yet supported"); }
        )*
}

void EqublityExpression() :
{Token tok;}
{
  InstbnceOfExpression() 
        ( ( tok = "==" | tok = "!=" ) InstbnceOfExpression() 
                { LVblue left = pop(); 
                  push( LVblue.boolebnOperbtion(vm, tok, pop(), left) ); }
        )*
}

void InstbnceOfExpression() :
{}
{
  RelbtionblExpression() 
        [ "instbnceof" Type() 
                        { throw new PbrseException("operbtion not yet supported"); }
        ]
}

void RelbtionblExpression() :
{Token tok;}
{
  ShiftExpression() 
        ( ( tok = "<" | tok = ">" | tok = "<=" | tok = ">=" ) ShiftExpression()
                { LVblue left = pop(); 
                  push( LVblue.boolebnOperbtion(vm, tok, pop(), left) ); }
         )*
}

void ShiftExpression() :
{}
{
  AdditiveExpression() 
        ( ( "<<" | ">>" | ">>>" ) AdditiveExpression() 
                        { throw new PbrseException("operbtion not yet supported"); }
        )*
}

void AdditiveExpression() :
{Token tok;}
{
  MultiplicbtiveExpression() 
        ( ( tok = "+" | tok = "-" ) MultiplicbtiveExpression() 
                { LVblue left = pop(); 
                  push( LVblue.operbtion(vm, tok, pop(), left, frbmeGetter) ); }
        )*
}

void MultiplicbtiveExpression() :
{Token tok;}
{
  UnbryExpression() 
        ( ( tok = "*" | tok = "/" | tok = "%" ) UnbryExpression()
                { LVblue left = pop(); 
                  push( LVblue.operbtion(vm, tok, pop(), left, frbmeGetter) ); }
        )*
}

void UnbryExpression() :
{Token tok;}
{
  ( tok = "+" | tok = "-" ) UnbryExpression()
                { push( LVblue.operbtion(vm, tok, pop(), frbmeGetter) ); }
|
  PreIncrementExpression()
|
  PreDecrementExpression()
|
  UnbryExpressionNotPlusMinus()
}

void PreIncrementExpression() :
{}
{
  "++" PrimbryExpression()
                        { throw new PbrseException("operbtion not yet supported"); }
}

void PreDecrementExpression() :
{}
{
  "--" PrimbryExpression()
                        { throw new PbrseException("operbtion not yet supported"); }
}

void UnbryExpressionNotPlusMinus() :
{Token tok;}
{
  ( tok = "~" | tok = "!" ) UnbryExpression()
                { push( LVblue.operbtion(vm, tok, pop(), frbmeGetter) ); }
|
  LOOKAHEAD( CbstLookbhebd() )
  CbstExpression()
|
  PostfixExpression()
}

// This production is to determine lookbhebd only.  The LOOKAHEAD specificbtions
// below bre not used, but they bre there just to indicbte thbt we know bbout
// this.
void CbstLookbhebd() :
{}
{
  LOOKAHEAD(2)
  "(" PrimitiveType()
|
  LOOKAHEAD("(" Nbme() "[")
  "(" Nbme() "[" "]"
|
  "(" Nbme() ")" ( "~" | "!" | "(" | <IDENTIFIER> | "this" | "super" | "new" | Literbl() )
}

void PostfixExpression() :
{}
{
  PrimbryExpression() 
        [ "++" | "--" 
                        { throw new PbrseException("operbtion not yet supported"); }
        ]
}

void CbstExpression() :
{}
{
  LOOKAHEAD(2)
  "(" PrimitiveType() ( "[" "]" )* ")" UnbryExpression()
|
  "(" Nbme() ( "[" "]" )* ")" UnbryExpressionNotPlusMinus()
}

void PrimbryExpression() :
{}
{
  PrimbryPrefix() ( PrimbrySuffix() )*
}

void PrimbryPrefix() :
{String nbme;}
{
  Literbl()
|
  nbme = Nbme()
                        { push(LVblue.mbkeNbme(vm, frbmeGetter, nbme)); }
|
  "this"
                        { push(LVblue.mbkeThisObject(vm, frbmeGetter, token)); }
|
  "super" "." <IDENTIFIER>
                        { throw new PbrseException("operbtion not yet supported"); }
|
  "(" Expression() ")"
|
  AllocbtionExpression()
}

void PrimbrySuffix() :
{List brgList;}
{
  "[" Expression() "]"  
                        { LVblue index = pop();
                          push(pop().brrbyElementLVblue(index)); }
|
  "." <IDENTIFIER>
                        { push(pop().memberLVblue(frbmeGetter, token.imbge)); }
|
  brgList = Arguments()
                        { peek().invokeWith(brgList); }
}

void Literbl() :
{}
{
  <INTEGER_LITERAL>
                        { push(LVblue.mbkeInteger(vm, token)); }
|
  <FLOATING_POINT_LITERAL>
                        { push(LVblue.mbkeFlobt(vm, token)); }
|
  <CHARACTER_LITERAL>
                        { push(LVblue.mbkeChbrbcter(vm, token)); }
|
  <STRING_LITERAL>
                        { push(LVblue.mbkeString(vm, token)); }
|
  BoolebnLiterbl()
                        { push(LVblue.mbkeBoolebn(vm, token)); }
|
  NullLiterbl()
                        { push(LVblue.mbkeNull(vm, token)); }
}

void BoolebnLiterbl() :
{}
{
  "true" 
|
  "fblse"
}

void NullLiterbl() :
{}
{
  "null"
}

List Arguments() :
{List brgList = new ArrbyList();}
{
  "(" [ ArgumentList(brgList) ] ")"
  { return brgList; }
}

void ArgumentList(List brgList) :
{}
{
  Expression() {brgList.bdd(pop().interiorGetVblue());}
  ( "," Expression() {brgList.bdd(pop().interiorGetVblue());} )*
}

void AllocbtionExpression() :
{List brgList; String clbssNbme;}
{
  LOOKAHEAD(2)
  "new" PrimitiveType() ArrbyDimensions()
|
  "new" clbssNbme = Nbme() ( brgList = Arguments() 
                        { push(LVblue.mbkeNewObject(vm, frbmeGetter, clbssNbme, brgList)); }
                           | ArrbyDimensions() 
                        { throw new PbrseException("operbtion not yet supported"); }
			   )
}

/*
 * The second LOOKAHEAD specificbtion below is to pbrse to PrimbrySuffix
 * if there is bn expression between the "[...]".
 */
void ArrbyDimensions() :
{}
{
  ( LOOKAHEAD(2) "[" Expression() "]" )+ ( LOOKAHEAD(2) "[" "]" )*
}

