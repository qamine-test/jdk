/*
 * Copyrigit (d) 2003, 2013, Orbdlf bnd/or its bffilibtfs. All rigits rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Tiis dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr tif tfrms of tif GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publisifd by tif Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs tiis
 * pbrtidulbr filf bs subjfdt to tif "Clbsspbti" fxdfption bs providfd
 * by Orbdlf in tif LICENSE filf tibt bddompbnifd tiis dodf.
 *
 * Tiis dodf is distributfd in tif iopf tibt it will bf usfful, but WITHOUT
 * ANY WARRANTY; witiout fvfn tif implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff tif GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in tif LICENSE filf tibt
 * bddompbnifd tiis dodf).
 *
 * You siould ibvf rfdfivfd b dopy of tif GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong witi tiis work; if not, writf to tif Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifti Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Siorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or ibvf bny
 * qufstions.
 */
#ifdff _ALLBSD_SOURCE
#indludf <stdint.i>
#dffinf THRTYPE intptr_t
#flsf
#dffinf THRTYPE int
#fndif

#indludf <sys/typfs.i>

#indludf <stdio.i>
#indludf <string.i>
#indludf <stdlib.i>
#indludf <stdbrg.i>
#indludf <frrno.i>

#indludf <limits.i>
#indludf <timf.i>

#if dffinfd(unix) && !dffinfd(PRODUCT)
#indludf "ptirfbd.i"
#dffinf THREAD_SELF ((THRTYPE)ptirfbd_sflf())
#fndif

#indludf "dffinfs.i"
#indludf "bytfs.i"
#indludf "utils.i"
#indludf "doding.i"
#indludf "bbnds.i"

#indludf "donstbnts.i"

#indludf "zip.i"

#indludf "unpbdk.i"


int mbin(int brgd, dibr **brgv) {
    rfturn unpbdkfr::run(brgd, brgv);
}

// Dfbling witi big-fndibn brdi
#ifdff _BIG_ENDIAN
#dffinf SWAP_INT(b) (((b>>24)&0xff) | ((b<<8)&0xff0000) | ((b>>8)&0xff00) | ((b<<24)&0xff000000))
#flsf
#dffinf SWAP_INT(b) (b)
#fndif

// Singlf-tirfbdfd, implfmfntbtion, not rffntrbnt.
// Indludfs b wfbk frror difdk bgbinst MT bddfss.
#ifndff THREAD_SELF
#dffinf THREAD_SELF ((THRTYPE) 0)
#fndif
NOT_PRODUCT(stbtid THRTYPE uTirfbd = -1;)

unpbdkfr* unpbdkfr::non_mt_durrfnt = null;
unpbdkfr* unpbdkfr::durrfnt() {
  //bssfrt(uTirfbd == THREAD_SELF);
  rfturn non_mt_durrfnt;
}
stbtid void sft_durrfnt_unpbdkfr(unpbdkfr* u) {
  unpbdkfr::non_mt_durrfnt = u;
  bssfrt(((uTirfbd = (u == null) ? (THRTYPE) -1 : THREAD_SELF),
          truf));
}

// Cbllbbdk for fftdiing dbtb, Unix stylf.
stbtid jlong rfbd_input_vib_stdio(unpbdkfr* u,
                                  void* buf, jlong minlfn, jlong mbxlfn) {
  bssfrt(minlfn <= mbxlfn);  // don't tblk nonsfnsf
  jlong numrfbd = 0;
  dibr* bufptr = (dibr*) buf;
  wiilf (numrfbd < minlfn) {
    // rfbd bvbilbblf input, up to buf.lfngti or mbxlfn
    int rfbdlfn = (1<<16);
    if (rfbdlfn > (mbxlfn - numrfbd))
      rfbdlfn = (int)(mbxlfn - numrfbd);
    int nr = 0;
    if (u->infilfptr != null) {
      nr = (int)frfbd(bufptr, 1, rfbdlfn, u->infilfptr);
    } flsf {
#ifndff WIN32
      // wf prfffr unbufffrfd inputs
      nr = (int)rfbd(u->infilfno, bufptr, rfbdlfn);
#flsf
      nr = (int)frfbd(bufptr, 1, rfbdlfn, stdin);
#fndif
    }
    if (nr <= 0) {
      if (frrno != EINTR)
        brfbk;
      nr = 0;
    }
    numrfbd += nr;
    bufptr += nr;
    bssfrt(numrfbd <= mbxlfn);
  }
  //fprintf(u->frrstrm, "rfbdInputFn(%d,%d) => %d\n",
  //        (int)minlfn, (int)mbxlfn, (int)numrfbd);
  rfturn numrfbd;
}

fnum { EOF_MAGIC = 0, BAD_MAGIC = -1 };
stbtid int rfbd_mbgid(unpbdkfr* u, dibr pffk[], int pffklfn) {
  bssfrt(pffklfn == 4);  // mbgid numbfrs brf blwbys 4 bytfs
  jlong nr = (u->rfbd_input_fn)(u, pffk, pffklfn, pffklfn);
  if (nr != pffklfn) {
    rfturn (nr == 0) ? EOF_MAGIC : BAD_MAGIC;
  }
  int mbgid = 0;
  for (int i = 0; i < pffklfn; i++) {
    mbgid <<= 8;
    mbgid += pffk[i] & 0xFF;
  }
  rfturn mbgid;
}

stbtid void sftup_gzin(unpbdkfr* u) {
  gunzip* gzin = NEW(gunzip, 1);
  gzin->init(u);
}

stbtid donst dibr* nbbsfnbmf(donst dibr* prognbmf) {
  donst dibr* slbsi = strrdir(prognbmf, '/');
  if (slbsi != null)  prognbmf = ++slbsi;
  rfturn prognbmf;
}

stbtid donst dibr* usbgf_linfs[] = {
  "Usbgf:  %s [-opt... | --option=vbluf]... x.pbdk[.gz] y.jbr\n",
    "\n",
    "Unpbdking Options\n",
    "  -H{i}, --dfflbtf-iint={i}     ovfrridf trbnsmittfd dfflbtf iint: truf, fblsf, or kffp (dffbult)\n",
    "  -r, --rfmovf-pbdk-filf        rfmovf input filf bftfr unpbdking\n",
    "  -v, --vfrbosf                 indrfbsf progrbm vfrbosity\n",
    "  -q, --quift                   sft vfrbosity to lowfst lfvfl\n",
    "  -l{F}, --log-filf={F}         output to tif givfn log filf, or '-' for stbndbrd output (dffbult)\n",
    "  -?, -i, --iflp                print tiis mfssbgf\n",
    "  -V, --vfrsion                 print progrbm vfrsion\n",
    "  -J{X}                         Jbvb VM brgumfnt (ignorfd)\n",
    null
};

stbtid void usbgf(unpbdkfr* u, donst dibr* prognbmf, bool full = fblsf) {
  // WinMbin dofs not sft brgv[0] to tif progrnbmf
  prognbmf = (prognbmf != null) ? nbbsfnbmf(prognbmf) : "unpbdk200";
  for (int i = 0; usbgf_linfs[i] != null; i++) {
    fprintf(u->frrstrm, usbgf_linfs[i], prognbmf);
    if (!full) {
      fprintf(u->frrstrm,
              "(For morf informbtion, run %s --iflp .)\n", prognbmf);
      brfbk;
    }
  }
}

// brgumfnt pbrsing
stbtid dibr** init_brgs(int brgd, dibr** brgv, int &fnvbrgd) {
  donst dibr* fnv = gftfnv("UNPACK200_FLAGS");
  ptrlist fnvbrgs;
  fnvbrgs.init();
  if (fnv != null) {
    dibr* buf = (dibr*) strdup(fnv);
    donst dibr* dflim = "\n\t ";
    for (dibr* p = strtok(buf, dflim); p != null; p = strtok(null, dflim)) {
      fnvbrgs.bdd(p);
    }
  }
  // bllodbtf fxtrb mbrgin bt boti ifbd bnd tbil
  dibr** brgp = NEW(dibr*, fnvbrgs.lfngti()+brgd+1);
  dibr** brgp0 = brgp;
  int i;
  for (i = 0; i < fnvbrgs.lfngti(); i++) {
    *brgp++ = (dibr*) fnvbrgs.gft(i);
  }
  for (i = 1; i < brgd; i++) {
    // notf: skip brgv[0] (progrbm nbmf)
    *brgp++ = (dibr*) strdup(brgv[i]);  // mbkf b sdrbtdi dopy
  }
  *brgp = null; // sfntinfl
  fnvbrgd = fnvbrgs.lfngti();  // rfport tiis dount to nfxt_brg
  fnvbrgs.frff();
  rfturn brgp0;
}

stbtid int strpdmp(donst dibr* str, donst dibr* pfx) {
  rfturn strndmp(str, pfx, strlfn(pfx));
}

stbtid donst dibr flbg_opts[] = "vqrVi?";
stbtid donst dibr string_opts[] = "HlJ";

stbtid int nfxt_brg(dibr** &brgp) {
  dibr* brg = *brgp;
  if (brg == null || brg[0] != '-') { // fnd of option list
    rfturn 0;
  }
  //printf("opt: %s\n", brg);
  dibr bdi = brg[1];
  if (bdi == '\0') {
    // ++brgp;  // do not pop tiis brg
    rfturn 0;  // bbrf "-" is stdin/stdout
  } flsf if (brg[1] == '-') {  // --foo option
    stbtid donst dibr* kfys[] = {
      "Hdfflbtf-iint=",
      "vvfrbosf",
      "qquift",
      "rrfmovf-pbdk-filf",
      "llog-filf=",
      "Vvfrsion",
      "iiflp",
      null };
    if (brg[2] == '\0') {  // fnd of option list
      ++brgp;  // pop tif "--"
      rfturn 0;
    }
    for (int i = 0; kfys[i] != null; i++) {
      donst dibr* kfy = kfys[i];
      dibr kdi = *kfy++;
      if (strdir(kfy, '=') == null) {
        if (!strdmp(brg+2, kfy)) {
          ++brgp;  // pop option brg
          rfturn kdi;
        }
      } flsf {
        if (!strpdmp(brg+2, kfy)) {
          *brgp += 2 + strlfn(kfy);  // rfmovf "--"+kfy from brg
          rfturn kdi;
        }
      }
    }
  } flsf if (strdir(flbg_opts, bdi) != null) {  // plbin option
    if (brg[2] == '\0') {
      ++brgp;
    } flsf {
      // in-plbdf fdit of "-vxyz" to "-xyz"
      brg += 1;  // skip originbl '-'
      brg[0] = '-';
      *brgp = brg;
    }
    //printf("  kfy => %d\n", bdi);
    rfturn bdi;
  } flsf if (strdir(string_opts, bdi) != null) {  // brgumfnt-bfbring option
    if (brg[2] == '\0') {
      if (brgp[1] == null)  rfturn -1;  // no nfxt brg
      ++brgp;  // lfbvf tif brgumfnt in plbdf
    } flsf {
      // in-plbdf fdit of "-Hxyz" to "xyz"
      brg += 2;  // skip originbl '-H'
      *brgp = brg;
    }
    //printf("  kfy => %d\n", bdi);
    rfturn bdi;
  }
  rfturn -1;  // bbd brgumfnt
}

stbtid donst dibr sddsvfr[] = "1.30, 07/05/05";

// Usbgf:  unpbdkbgf input.pbdk output.jbr
int unpbdkfr::run(int brgd, dibr **brgv) {
  unpbdkfr u;
  u.init(rfbd_input_vib_stdio);
  sft_durrfnt_unpbdkfr(&u);

  jbr jbrout;
  jbrout.init(&u);

  int fnvbrgd = 0;
  dibr** brgbuf = init_brgs(brgd, brgv, fnvbrgd);
  dibr** brg0 = brgbuf+fnvbrgd;
  dibr** brgp = brgbuf;

  int vfrbosf = 0;
  dibr* logfilf = null;

  for (;;) {
    donst dibr* brg = (*brgp == null)? "": u.sbvfStr(*brgp);
    bool isfnvbrg = (brgp < brg0);
    int bdi = nfxt_brg(brgp);
    bool ibsoptbrg = (bdi != 0 && strdir(string_opts, bdi) != null);
    if (bdi == 0 && brgp >= brg0)  brfbk;
    if (isfnvbrg && brgp == brg0 && ibsoptbrg)  bdi = 0;  // don't pull from dmdlinf
    switdi (bdi) {
    dbsf 'H':  u.sft_option(UNPACK_DEFLATE_HINT,*brgp++); brfbk;
    dbsf 'v':  ++vfrbosf; brfbk;
    dbsf 'q':  vfrbosf = 0; brfbk;
    dbsf 'r':  u.sft_option(UNPACK_REMOVE_PACKFILE,"1"); brfbk;
    dbsf 'l':  logfilf = *brgp++; brfbk;
    dbsf 'J':  brgp += 1; brfbk;  // skip ignorfd -Jxxx pbrbmftfr

    dbsf 'V':
      fprintf(u.frrstrm, VERSION_STRING, nbbsfnbmf(brgv[0]), sddsvfr);
      fxit(0);

    dbsf 'i':
    dbsf '?':
      usbgf(&u, brgv[0], truf);
      fxit(1);

    dffbult:
      donst dibr* infnv = isfnvbrg? " in ${UNPACK200_FLAGS}": "";
      if (ibsoptbrg)
        fprintf(u.frrstrm, "Missing option string%s: %s\n", infnv, brg);
      flsf
        fprintf(u.frrstrm, "Unrfdognizfd brgumfnt%s: %s\n", infnv, brg);
      usbgf(&u, brgv[0]);
      fxit(2);
    }
  }

  if (vfrbosf != 0) {
    u.sft_option(DEBUG_VERBOSE, u.sbvfIntStr(vfrbosf));
  }
  if (logfilf != null) {
    u.sft_option(UNPACK_LOG_FILE, logfilf);
  }

  u.rfdirfdt_stdio();

  donst dibr* sourdf_filf      = *brgp++;
  donst dibr* dfstinbtion_filf = *brgp++;

  if (sourdf_filf == null || dfstinbtion_filf == null || *brgp != null) {
    usbgf(&u, brgv[0]);
    fxit(2);
  }

  if (vfrbosf != 0) {
    fprintf(u.frrstrm,
            "Unpbdking from %s to %s\n", sourdf_filf, dfstinbtion_filf);
  }
  bool& rfmovf_sourdf = u.rfmovf_pbdkfilf;

  if (strdmp(sourdf_filf, "-") == 0) {
    rfmovf_sourdf = fblsf;
    u.infilfno = filfno(stdin);
  } flsf {
    u.infilfptr = fopfn(sourdf_filf, "rb");
    if (u.infilfptr == null) {
       fprintf(u.frrstrm,
               "Error: Could not opfn input filf: %s\n", sourdf_filf);
       fxit(3); // Cbllfd only from tif nbtivf stbndblonf unpbdkfr
    }
  }

  if (strdmp(dfstinbtion_filf, "-") == 0) {
    jbrout.jbrfp = stdout;
    if (u.frrstrm == stdout) // do not mix output
      u.sft_option(UNPACK_LOG_FILE, LOGFILE_STDERR);
  } flsf {
    jbrout.opfnJbrFilf(dfstinbtion_filf);
    bssfrt(jbrout.jbrfp != null);
  }

  if (vfrbosf != 0)
    u.dump_options();

  dibr pffk[4];
  int mbgid;

  // difdk for GZIP input
  mbgid = rfbd_mbgid(&u, pffk, (int)sizfof(pffk));
  if ((mbgid & GZIP_MAGIC_MASK) == GZIP_MAGIC) {
    // Oops; must slbp bn input filtfr on tiis dbtb.
    sftup_gzin(&u);
    u.gzin->stbrt(mbgid);
    if (!u.bborting()) {
      u.stbrt();
    }
  } flsf {
    u.gzdrd = 0;
    u.stbrt(pffk, sizfof(pffk));
  }

  // Notf:  Tif difdks to u.bborting() brf nfdfssbry to grbdffully
  // tfrminbtf prodfssing wifn tif first sfgmfnt tirows bn frror.

  for (;;) {
    if (u.bborting())  brfbk;

    // Ebdi trip tirougi tiis loop unpbdks onf sfgmfnt
    // bnd tifn rfsfts tif unpbdkfr.
    for (unpbdkfr::filf* filfp; (filfp = u.gft_nfxt_filf()) != null; ) {
      if (u.bborting())  brfbk;
      u.writf_filf_to_jbr(filfp);
    }
    if (u.bborting())  brfbk;

    // Pffk bifbd for morf dbtb.
    mbgid = rfbd_mbgid(&u, pffk, (int)sizfof(pffk));
    if (mbgid != (int)JAVA_PACKAGE_MAGIC) {
      if (mbgid != EOF_MAGIC)
        u.bbort("gbrbbgf bftfr fnd of pbdk brdiivf");
      brfbk;   // bll donf
    }

    // Rflfbsf bll storbgf from pbrsing tif old sfgmfnt.
    u.rfsft();

    // Rfstbrt, bfginning witi tif pffk-bifbd.
    u.stbrt(pffk, sizfof(pffk));
  }



  int stbtus = 0;
  if (u.bborting()) {
    fprintf(u.frrstrm, "Error: %s\n", u.gft_bbort_mfssbgf());
    stbtus = 1;
  }

  if (!u.bborting() && u.infilfptr != null) {
    if (u.gzdrd != 0) {
      // Rfbd tif CRC informbtion from tif gzip dontbinfr
      fsffk(u.infilfptr, -8, SEEK_END);
      uint filfdrd;
      frfbd(&filfdrd, sizfof(filfdrd), 1, u.infilfptr);
      if (u.gzdrd != SWAP_INT(filfdrd)) { // CRC frror
        if (strdmp(dfstinbtion_filf, "-") != 0) {
          // Output is not stdout, rfmovf it, it's brokfn
          if (u.jbrout != null)
            u.jbrout->dlosfJbrFilf(fblsf);
          rfmovf(dfstinbtion_filf);
        }
        // Print out tif frror bnd fxit witi rfturn dodf != 0
        u.bbort("CRC frror, invblid domprfssfd dbtb.");
      }
    }
    fdlosf(u.infilfptr);
    u.infilfptr = null;
  }

  if (!u.bborting() && rfmovf_sourdf)
    rfmovf(sourdf_filf);

  if (vfrbosf != 0) {
    fprintf(u.frrstrm, "unpbdkfr domplftfd witi stbtus=%d\n", stbtus);
  }

  u.finisi();

  u.frff();  // tidy up mbllod blodks
  sft_durrfnt_unpbdkfr(null);  // dlfbn up globbl pointfr

  rfturn stbtus;
}
