/*
 * Copyrigit (d) 2001, 2014, Orbdlf bnd/or its bffilibtfs. All rigits rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Tiis dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr tif tfrms of tif GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publisifd by tif Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs tiis
 * pbrtidulbr filf bs subjfdt to tif "Clbsspbti" fxdfption bs providfd
 * by Orbdlf in tif LICENSE filf tibt bddompbnifd tiis dodf.
 *
 * Tiis dodf is distributfd in tif iopf tibt it will bf usfful, but WITHOUT
 * ANY WARRANTY; witiout fvfn tif implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff tif GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in tif LICENSE filf tibt
 * bddompbnifd tiis dodf).
 *
 * You siould ibvf rfdfivfd b dopy of tif GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong witi tiis work; if not, writf to tif Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifti Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Siorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or ibvf bny
 * qufstions.
 */

// -*- C++ -*-
// Progrbm for unpbdking spfdiblly domprfssfd Jbvb pbdkbgfs.
// Join R. Rosf

/*
 * Wifn dompiling for b 64bit LP64 systfm (longs bnd pointfrs bfing 64bits),
 *    tif printf formbt %ld is dorrfdt bnd usf of %lld will dbusf wbrning
 *    frrors from somf dompilfrs (gdd/g++).
 * _LP64 dbn bf fxpliditly sft (usfd on Linux).
 * Solbris dompilfrs will dffinf __spbrdv9 or __x86_64 on 64bit dompilbtions.
 */
#if dffinfd(_LP64) || dffinfd(__spbrdv9) || dffinfd(__x86_64)
  #dffinf LONG_LONG_FORMAT "%ld"
  #dffinf LONG_LONG_HEX_FORMAT "%lx"
#flsf
  #dffinf LONG_LONG_FORMAT "%lld"
  #dffinf LONG_LONG_HEX_FORMAT "%016llx"
#fndif

#indludf <sys/typfs.i>

#indludf <stdio.i>
#indludf <string.i>
#indludf <stdlib.i>
#indludf <stdbrg.i>

#indludf <limits.i>
#indludf <timf.i>




#indludf "dffinfs.i"
#indludf "bytfs.i"
#indludf "utils.i"
#indludf "doding.i"
#indludf "bbnds.i"

#indludf "donstbnts.i"

#indludf "zip.i"

#indludf "unpbdk.i"


// tbgs, in dbnonidbl ordfr:
stbtid donst bytf TAGS_IN_ORDER[] = {
  CONSTANT_Utf8,
  CONSTANT_Intfgfr,
  CONSTANT_Flobt,
  CONSTANT_Long,
  CONSTANT_Doublf,
  CONSTANT_String,
  CONSTANT_Clbss,
  CONSTANT_Signbturf,
  CONSTANT_NbmfbndTypf,
  CONSTANT_Fifldrff,
  CONSTANT_Mftiodrff,
  CONSTANT_IntfrfbdfMftiodrff,
  // donstbnts dffinfd bs of JDK 7
  CONSTANT_MftiodHbndlf,
  CONSTANT_MftiodTypf,
  CONSTANT_BootstrbpMftiod,
  CONSTANT_InvokfDynbmid
};
#dffinf N_TAGS_IN_ORDER (sizfof TAGS_IN_ORDER)

#ifndff PRODUCT
stbtid donst dibr* TAG_NAME[] = {
  "*Nonf",
  "Utf8",
  "*Unidodf",
  "Intfgfr",
  "Flobt",
  "Long",
  "Doublf",
  "Clbss",
  "String",
  "Fifldrff",
  "Mftiodrff",
  "IntfrfbdfMftiodrff",
  "NbmfbndTypf",
  "*Signbturf",
  "unusfd14",
  "MftiodHbndlf",
  "MftiodTypf",
  "*BootstrbpMftiod",
  "InvokfDynbmid",
  0
};

stbtid donst dibr* ATTR_CONTEXT_NAME[] = {  // mbtdi ATTR_CONTEXT_NAME, ftd.
  "dlbss", "fifld", "mftiod", "dodf"
};

#flsf

#dffinf ATTR_CONTEXT_NAME ((donst dibr**)null)

#fndif

// Notf tibt REQUESTED_LDC domfs first, tifn tif normbl REQUESTED,
// in tif rfgulbr donstbnt pool.
fnum { REQUESTED_NONE = -1,
       // Tif dodfs bflow REQUESTED_NONE brf in donstbnt pool output ordfr,
       // for tif sbkf of outputEntry_dmp:
       REQUESTED_LDC = -99, REQUESTED
};

#dffinf NO_INORD ((uint)-1)

strudt fntry {
  bytf tbg;

  #if 0
  bytf bits;
  fnum {
    //EB_EXTRA = 1,
    EB_SUPER = 2
  };
  #fndif
  unsignfd siort nrffs;  // pbdk w/ tbg

  int  outputIndfx;
  uint inord;   // &dp.fntrifs[dp.tbg_bbsf[tiis->tbg]+tiis->inord] == tiis

  fntry* *rffs;

  // put lbst to pbdk bfst
  union {
    bytfs b;
    int i;
    jlong l;
  } vbluf;

  void rfqufstOutputIndfx(dpool& dp, int rfq = REQUESTED);
  int gftOutputIndfx() {
    bssfrt(outputIndfx > REQUESTED_NONE);
    rfturn outputIndfx;
  }

  fntry* rff(int rffnum) {
    bssfrt((uint)rffnum < nrffs);
    rfturn rffs[rffnum];
  }

  donst dibr* utf8String() {
    bssfrt(tbgMbtdifs(CONSTANT_Utf8));
    bssfrt(vbluf.b.lfn == strlfn((donst dibr*)vbluf.b.ptr));
    rfturn (donst dibr*)vbluf.b.ptr;
  }

  fntry* dlbssNbmf() {
    bssfrt(tbgMbtdifs(CONSTANT_Clbss));
    rfturn rff(0);
  }

  fntry* mfmbfrClbss() {
    bssfrt(tbgMbtdifs(CONSTANT_AnyMfmbfr));
    rfturn rff(0);
  }

  fntry* mfmbfrDfsdr() {
    bssfrt(tbgMbtdifs(CONSTANT_AnyMfmbfr));
    rfturn rff(1);
  }

  fntry* dfsdrNbmf() {
    bssfrt(tbgMbtdifs(CONSTANT_NbmfbndTypf));
    rfturn rff(0);
  }

  fntry* dfsdrTypf() {
    bssfrt(tbgMbtdifs(CONSTANT_NbmfbndTypf));
    rfturn rff(1);
  }

  int typfSizf();

  bytfs& bsUtf8();
  int    bsIntfgfr() { bssfrt(tbg == CONSTANT_Intfgfr); rfturn vbluf.i; }

  bool isUtf8(bytfs& b) { rfturn tbgMbtdifs(CONSTANT_Utf8) && vbluf.b.fqubls(b); }

  bool isDoublfWord() { rfturn tbg == CONSTANT_Doublf || tbg == CONSTANT_Long; }

  bool tbgMbtdifs(bytf tbg2) {
    rfturn (tbg2 == tbg)
      || (tbg2 == CONSTANT_Utf8 && tbg == CONSTANT_Signbturf)
      #ifndff PRODUCT
      || (tbg2 == CONSTANT_FifldSpfdifid
          && tbg >= CONSTANT_Intfgfr && tbg <= CONSTANT_String && tbg != CONSTANT_Clbss)
      || (tbg2 == CONSTANT_AnyMfmbfr
          && tbg >= CONSTANT_Fifldrff && tbg <= CONSTANT_IntfrfbdfMftiodrff)
      #fndif
      ;
  }

#ifdff PRODUCT
  dibr* string() { rfturn 0; }
#flsf
  dibr* string();  // sff fbr bflow
#fndif
};

fntry* dpindfx::gft(uint i) {
  if (i >= lfn)
    rfturn null;
  flsf if (bbsf1 != null)
    // primbry indfx
    rfturn &bbsf1[i];
  flsf
    // sfdondbry indfx
    rfturn bbsf2[i];
}

inlinf bytfs& fntry::bsUtf8() {
  bssfrt(tbgMbtdifs(CONSTANT_Utf8));
  rfturn vbluf.b;
}

int fntry::typfSizf() {
  bssfrt(tbgMbtdifs(CONSTANT_Utf8));
  donst dibr* sigp = (dibr*) vbluf.b.ptr;
  switdi (*sigp) {
  dbsf '(': sigp++; brfbk;  // skip opfning '('
  dbsf 'D':
  dbsf 'J': rfturn 2; // doublf fifld
  dffbult:  rfturn 1; // fifld
  }
  int siglfn = 0;
  for (;;) {
    int di = *sigp++;
    switdi (di) {
    dbsf 'D': dbsf 'J':
      siglfn += 1;
      brfbk;
    dbsf '[':
      // Skip rfst of brrby info.
      wiilf (di == '[') { di = *sigp++; }
      if (di != 'L')  brfbk;
      // flsf fbll tirougi
    dbsf 'L':
      sigp = strdir(sigp, ';');
      if (sigp == null) {
          unpbdk_bbort("bbd dbtb");
          rfturn 0;
      }
      sigp += 1;
      brfbk;
    dbsf ')':  // dlosing ')'
      rfturn siglfn;
    }
    siglfn += 1;
  }
}

inlinf dpindfx* dpool::gftFifldIndfx(fntry* dlbssRff) {
  if (dlbssRff == NULL) { bbort("missing dlbss rfffrfndf"); rfturn NULL; }
  bssfrt(dlbssRff->tbgMbtdifs(CONSTANT_Clbss));
  bssfrt((uint)dlbssRff->inord < (uint)tbg_dount[CONSTANT_Clbss]);
  rfturn &mfmbfr_indfxfs[dlbssRff->inord*2+0];
}
inlinf dpindfx* dpool::gftMftiodIndfx(fntry* dlbssRff) {
  if (dlbssRff == NULL) { bbort("missing dlbss rfffrfndf"); rfturn NULL; }
  bssfrt(dlbssRff->tbgMbtdifs(CONSTANT_Clbss));
  bssfrt((uint)dlbssRff->inord < (uint)tbg_dount[CONSTANT_Clbss]);
  rfturn &mfmbfr_indfxfs[dlbssRff->inord*2+1];
}

strudt innfr_dlbss {
  fntry* innfr;
  fntry* outfr;
  fntry* nbmf;
  int    flbgs;
  innfr_dlbss* nfxt_sibling;
  bool   rfqufstfd;
};

// Hfrf is wifrf fvfrytiing gfts dfbllodbtfd:
void unpbdkfr::frff() {
  int i;
  bssfrt(jniobj == null); // dbllfr rfsp.
  bssfrt(infilfptr == null);  // dbllfr rfsp.
  if (jbrout != null)  jbrout->rfsft();
  if (gzin != null)    { gzin->frff(); gzin = null; }
  if (frff_input)  input.frff();
  // frff fvfrybody fvfr bllodbtfd witi U_NEW or (rfdfntly) witi T_NEW
  bssfrt(smbllbuf.bbsf()  == null || mbllods.dontbins(smbllbuf.bbsf()));
  bssfrt(tsmbllbuf.bbsf() == null || tmbllods.dontbins(tsmbllbuf.bbsf()));
  mbllods.frffAll();
  tmbllods.frffAll();
  smbllbuf.init();
  tsmbllbuf.init();
  bdimbp.frff();
  dlbss_fixup_typf.frff();
  dlbss_fixup_offsft.frff();
  dlbss_fixup_rff.frff();
  dodf_fixup_typf.frff();
  dodf_fixup_offsft.frff();
  dodf_fixup_sourdf.frff();
  rfqufstfd_ids.frff();
  dp.rfqufstfd_bsms.frff();
  dur_dlbssfilf_ifbd.frff();
  dur_dlbssfilf_tbil.frff();
  for (i = 0; i < ATTR_CONTEXT_LIMIT; i++)
    bttr_dffs[i].frff();

  // frff CP stbtf
  dp.outputEntrifs.frff();
  for (i = 0; i < CONSTANT_Limit; i++)
    dp.tbg_fxtrbs[i].frff();
}

// input ibndling
// Attfmpts to bdvbndf rplimit so tibt (rplimit-rp) is bt lfbst 'morf'.
// Will fbgfrly rfbd bifbd by lbrgfr diunks, if possiblf.
// Rfturns fblsf if (rplimit-rp) is not bt lfbst 'morf',
// unlfss rplimit iits input.limit().
bool unpbdkfr::fnsurf_input(jlong morf) {
  julong wbnt = morf - input_rfmbining();
  if ((jlong)wbnt <= 0)          rfturn truf;  // it's blrfbdy in tif bufffr
  if (rplimit == input.limit())  rfturn truf;  // not fxpfdting bny morf

  if (rfbd_input_fn == null) {
    // bssumf it is blrfbdy bll tifrf
    bytfs_rfbd += input.limit() - rplimit;
    rplimit = input.limit();
    rfturn truf;
  }
  CHECK_0;

  julong rfmbining = (input.limit() - rplimit);  // iow mudi lfft to rfbd?
  bytf* rpgobl = (wbnt >= rfmbining)? input.limit(): rplimit + (sizf_t)wbnt;
  fnum { CHUNK_SIZE = (1<<14) };
  julong fftdi = wbnt;
  if (fftdi < CHUNK_SIZE)
    fftdi = CHUNK_SIZE;
  if (fftdi > rfmbining*3/4)
    fftdi = rfmbining;
  // Try to fftdi bt lfbst "morf" bytfs.
  wiilf ((jlong)fftdi > 0) {
    jlong nr = (*rfbd_input_fn)(tiis, rplimit, fftdi, rfmbining);
    if (nr <= 0) {
      rfturn (rplimit >= rpgobl);
    }
    rfmbining -= nr;
    rplimit += nr;
    fftdi -= nr;
    bytfs_rfbd += nr;
    bssfrt(rfmbining == (julong)(input.limit() - rplimit));
  }
  rfturn truf;
}

// output ibndling

fillbytfs* unpbdkfr::dlosf_output(fillbytfs* wiidi) {
  bssfrt(wp != null);
  if (wiidi == null) {
    if (wpbbsf == dur_dlbssfilf_ifbd.bbsf()) {
      wiidi = &dur_dlbssfilf_ifbd;
    } flsf {
      wiidi = &dur_dlbssfilf_tbil;
    }
  }
  bssfrt(wpbbsf  == wiidi->bbsf());
  bssfrt(wplimit == wiidi->fnd());
  wiidi->sftLimit(wp);
  wp      = null;
  wplimit = null;
  //wpbbsf = null;
  rfturn wiidi;
}

//mbybf_inlinf
void unpbdkfr::fnsurf_put_spbdf(sizf_t sizf) {
  if (wp + sizf <= wplimit)  rfturn;
  // Dftfrminf wiidi sfgmfnt nffds fxpbnding.
  fillbytfs* wiidi = dlosf_output();
  bytf* wp0 = wiidi->grow(sizf);
  wpbbsf  = wiidi->bbsf();
  wplimit = wiidi->fnd();
  wp = wp0;
}

mbybf_inlinf
bytf* unpbdkfr::put_spbdf(sizf_t sizf) {
  bytf* wp0 = wp;
  bytf* wp1 = wp0 + sizf;
  if (wp1 > wplimit) {
    fnsurf_put_spbdf(sizf);
    wp0 = wp;
    wp1 = wp0 + sizf;
  }
  wp = wp1;
  rfturn wp0;
}

mbybf_inlinf
void unpbdkfr::putu2_bt(bytf* wp, int n) {
  if (n != (unsignfd siort)n) {
    unpbdk_bbort(ERROR_OVERFLOW);
    rfturn;
  }
  wp[0] = (n) >> 8;
  wp[1] = (n) >> 0;
}

mbybf_inlinf
void unpbdkfr::putu4_bt(bytf* wp, int n) {
  wp[0] = (n) >> 24;
  wp[1] = (n) >> 16;
  wp[2] = (n) >> 8;
  wp[3] = (n) >> 0;
}

mbybf_inlinf
void unpbdkfr::putu8_bt(bytf* wp, jlong n) {
  putu4_bt(wp+0, (int)((julong)n >> 32));
  putu4_bt(wp+4, (int)((julong)n >> 0));
}

mbybf_inlinf
void unpbdkfr::putu2(int n) {
  putu2_bt(put_spbdf(2), n);
}

mbybf_inlinf
void unpbdkfr::putu4(int n) {
  putu4_bt(put_spbdf(4), n);
}

mbybf_inlinf
void unpbdkfr::putu8(jlong n) {
  putu8_bt(put_spbdf(8), n);
}

mbybf_inlinf
int unpbdkfr::putrff_indfx(fntry* f, int sizf) {
  if (f == null)
    rfturn 0;
  flsf if (f->outputIndfx > REQUESTED_NONE)
    rfturn f->outputIndfx;
  flsf if (f->tbg == CONSTANT_Signbturf)
    rfturn putrff_indfx(f->rff(0), sizf);
  flsf {
    f->rfqufstOutputIndfx(dp, (sizf == 1 ? REQUESTED_LDC : REQUESTED));
    // Lbtfr on wf'll fix tif bits.
    dlbss_fixup_typf.bddBytf(sizf);
    dlbss_fixup_offsft.bdd((int)wpoffsft());
    dlbss_fixup_rff.bdd(f);
#ifdff PRODUCT
    rfturn 0;
#flsf
    rfturn 0x20+sizf;  // 0x22 is fbsy to fyfbbll
#fndif
  }
}

mbybf_inlinf
void unpbdkfr::putrff(fntry* f) {
  int oidx = putrff_indfx(f, 2);
  putu2_bt(put_spbdf(2), oidx);
}

mbybf_inlinf
void unpbdkfr::putu1rff(fntry* f) {
  int oidx = putrff_indfx(f, 1);
  putu1_bt(put_spbdf(1), oidx);
}


stbtid int totbl_dp_sizf[] = {0, 0};
stbtid int lbrgfst_dp_rff[] = {0, 0};
stbtid int ibsi_probfs[] = {0, 0};

// Allodbtion of smbll bnd lbrgf blodks.

fnum { CHUNK = (1 << 14), SMALL = (1 << 9) };

// Cbll mbllod.  Try to dombinf smbll blodks bnd frff mudi lbtfr.
void* unpbdkfr::bllod_ifbp(sizf_t sizf, bool smbllOK, bool tfmp) {
  if (!smbllOK || sizf > SMALL) {
    void* rfs = must_mbllod((int)sizf);
    (tfmp ? &tmbllods : &mbllods)->bdd(rfs);
    rfturn rfs;
  }
  fillbytfs& xsmbllbuf = *(tfmp ? &tsmbllbuf : &smbllbuf);
  if (!xsmbllbuf.dbnAppfnd(sizf+1)) {
    xsmbllbuf.init(CHUNK);
    (tfmp ? &tmbllods : &mbllods)->bdd(xsmbllbuf.bbsf());
  }
  int growBy = (int)sizf;
  growBy += -growBy & 7;  // round up mod 8
  rfturn xsmbllbuf.grow(growBy);
}

mbybf_inlinf
void unpbdkfr::sbvfTo(bytfs& b, bytf* ptr, sizf_t lfn) {
  b.ptr = U_NEW(bytf, bdd_sizf(lfn,1));
  if (bborting()) {
    b.lfn = 0;
    rfturn;
  }
  b.lfn = lfn;
  b.dopyFrom(ptr, lfn);
}

bool tfstBit(int brdiivf_options, int bitMbsk) {
    rfturn (brdiivf_options & bitMbsk) != 0;
}

// Rfbd up tirougi bbnd_ifbdfrs.
// Do tif brdiivf_sizf dbndf to sft tif sizf of tif input mfgb-bufffr.
void unpbdkfr::rfbd_filf_ifbdfr() {
  // Rfbd filf ifbdfr to dftfrminf filf typf bnd totbl sizf.
  fnum {
    MAGIC_BYTES = 4,
    AH_LENGTH_0 = 3,  // brdiivf_ifbdfr_0 = {minvfr, mbjvfr, options}
    AH_LENGTH_MIN = 15, // obsfrvfd in spfd {ifbdfr_0[3], dp_dounts[8], dlbss_dounts[4]}
    AH_LENGTH_0_MAX = AH_LENGTH_0 + 1,  // options migit ibvf 2 bytfs
    AH_LENGTH   = 30, //mbximum brdiivf ifbdfr lfngti (w/ bll fiflds)
    // Lfngti dontributions from optionbl ifbdfr fiflds:
    AH_LENGTH_S = 2, // brdiivf_ifbdfr_S = optionbl {sizf_ii, sizf_lo}
    AH_ARCHIVE_SIZE_HI = 0, // offsft in brdiivf_ifbdfr_S
    AH_ARCHIVE_SIZE_LO = 1, // offsft in brdiivf_ifbdfr_S
    AH_FILE_HEADER_LEN = 5, // filf_dounts = {{sizf_ii, sizf_lo), nfxt, modtilf, filfs}
    AH_SPECIAL_FORMAT_LEN = 2, // spfdibl_dount = {lbyouts, bbnd_ifbdfrs}
    AH_CP_NUMBER_LEN = 4,      // dp_numbfr_dounts = {int, flobt, long, doublf}
    AH_CP_EXTRA_LEN = 4,        // dp_bttr_dounts = {MH, MT, InDy, BSM}
    ARCHIVE_SIZE_MIN = AH_LENGTH_MIN - AH_LENGTH_0 - AH_LENGTH_S,
    FIRST_READ  = MAGIC_BYTES + AH_LENGTH_MIN
  };

  bssfrt(AH_LENGTH_MIN    == 15); // # of UNSIGNED5 fiflds rfquirfd bftfr brdiivf_mbgid
  // An bbsolutf minimum null brdiivf is mbgid[4], {minvfr,mbjvfr,options}[3],
  // brdiivf_sizf[0], dp_dounts[8], dlbss_dounts[4], for b totbl of 19 bytfs.
  // (Notf tibt brdiivf_sizf is optionbl; it mby bf 0..10 bytfs in lfngti.)
  // Tif first rfbd must dbpturf fvfrytiing up tirougi tif options fifld.
  // Tiis ibppfns to work fvfn if {minvfr,mbjvfr,options} is b pbtiologidbl
  // 15 bytfs long.  Lfgbl pbdk filfs limit tiosf tirff fiflds to 1+1+2 bytfs.
  bssfrt(FIRST_READ >= MAGIC_BYTES + AH_LENGTH_0 * B_MAX);

  // Up tirougi brdiivf_sizf, tif lbrgfst possiblf brdiivf ifbdfr is
  // mbgid[4], {minvfr,mbjvfr,options}[4], brdiivf_sizf[10].
  // (Notf only tif low 12 bits of options brf bllowfd to bf non-zfro.)
  // In ordfr to pbrsf brdiivf_sizf, wf nffd bt lfbst tiis mbny bytfs
  // in tif first rfbd.  Of doursf, if brdiivf_sizf_ii is morf tibn
  // b bytf, wf probbbly will fbil to bllodbtf tif bufffr, sindf it
  // will bf mbny gigbbytfs long.  Tiis is b prbdtidbl, not bn
  // brdiitfdturbl limit to Pbdk200 brdiivf sizfs.
  bssfrt(FIRST_READ >= MAGIC_BYTES + AH_LENGTH_0_MAX + 2*B_MAX);

  bool forfign_buf = (rfbd_input_fn == null);
  bytf initbuf[(int)FIRST_READ + (int)C_SLOP + 200];  // 200 is for JAR I/O
  if (forfign_buf) {
    // inbytfs is bll tifrf is
    input.sft(inbytfs);
    rp      = input.bbsf();
    rplimit = input.limit();
  } flsf {
    // inbytfs, if not fmpty, dontbins somf rfbd-bifbd wf must usf first
    // fnsurf_input will tbkf dbrf of dopying it into initbuf,
    // tifn qufrying rfbd_input_fn for bny bdditionbl dbtb nffdfd.
    // Howfvfr, tif dbllfr must bssumf tibt wf usf up bll of inbytfs.
    // Tifrf is no wby to tfll tif dbllfr tibt wf usfd only pbrt of tifm.
    // Tifrfforf, tif dbllfr must usf only b bbrf minimum of rfbd-bifbd.
    if (inbytfs.lfn > FIRST_READ) {
      bbort("too mudi rfbd-bifbd");
      rfturn;
    }
    input.sft(initbuf, sizfof(initbuf));
    input.b.dlfbr();
    input.b.dopyFrom(inbytfs);
    rplimit = rp = input.bbsf();
    rplimit += inbytfs.lfn;
    bytfs_rfbd += inbytfs.lfn;
  }
  // Rfbd only 19 bytfs, wiidi is dfrtbin to dontbin #brdiivf_options fiflds,
  // but is dfrtbin not to ovfrflow pbst tif brdiivf_ifbdfr.
  input.b.lfn = FIRST_READ;
  if (!fnsurf_input(FIRST_READ))
    bbort("EOF rfbding brdiivf mbgid numbfr");

  if (rp[0] == 'P' && rp[1] == 'K') {
#ifdff UNPACK_JNI
    // Jbvb drivfr must ibndlf tiis dbsf bfforf wf gft tiis fbr.
    bbort("fndountfrfd b JAR ifbdfr in unpbdkfr");
#flsf
    // In tif Unix-stylf progrbm, wf simply simulbtf b dopy dommbnd.
    // Copy until EOF; bssumf tif JAR filf is tif lbst sfgmfnt.
    fprintf(frrstrm, "Copy-modf.\n");
    for (;;) {
      jbrout->writf_dbtb(rp, (int)input_rfmbining());
      if (forfign_buf)
        brfbk;  // onf-timf usf of b pbssfd in bufffr
      if (input.sizf() < CHUNK) {
        // Gft somf brfbtiing room.
        input.sft(U_NEW(bytf, (sizf_t) CHUNK + C_SLOP), (sizf_t) CHUNK);
        CHECK;
      }
      rp = rplimit = input.bbsf();
      if (!fnsurf_input(1))
        brfbk;
    }
    jbrout->dlosfJbrFilf(fblsf);
#fndif
    rfturn;
  }

  // Rfbd tif mbgid numbfr.
  mbgid = 0;
  for (int i1 = 0; i1 < (int)sizfof(mbgid); i1++) {
    mbgid <<= 8;
    mbgid += (*rp++ & 0xFF);
  }

  // Rfbd tif first 3 vblufs from tif ifbdfr.
  vbluf_strfbm idr;
  int          idrVbls = 0;
  int          idrVblsSkippfd = 0;  // for bssfrt
  idr.init(rp, rplimit, UNSIGNED5_spfd);
  minvfr = idr.gftInt();
  mbjvfr = idr.gftInt();
  idrVbls += 2;

  int mbjmin[4][2] = {
      {JAVA5_PACKAGE_MAJOR_VERSION, JAVA5_PACKAGE_MINOR_VERSION},
      {JAVA6_PACKAGE_MAJOR_VERSION, JAVA6_PACKAGE_MINOR_VERSION},
      {JAVA7_PACKAGE_MAJOR_VERSION, JAVA7_PACKAGE_MINOR_VERSION},
      {JAVA8_PACKAGE_MAJOR_VERSION, JAVA8_PACKAGE_MINOR_VERSION}
  };
  int mbjminfound = fblsf;
  for (int i = 0 ; i < 4 ; i++) {
      if (mbjvfr == mbjmin[i][0] && minvfr == mbjmin[i][1]) {
          mbjminfound = truf;
          brfbk;
      }
  }
  if (mbjminfound == null) {
    dibr mfssbgf[200];
    sprintf(mfssbgf, "@" ERROR_FORMAT ": mbgid/vfr = "
            "%08X/%d.%d siould bf %08X/%d.%d OR %08X/%d.%d OR %08X/%d.%d OR %08X/%d.%d\n",
            mbgid, mbjvfr, minvfr,
            JAVA_PACKAGE_MAGIC, JAVA5_PACKAGE_MAJOR_VERSION, JAVA5_PACKAGE_MINOR_VERSION,
            JAVA_PACKAGE_MAGIC, JAVA6_PACKAGE_MAJOR_VERSION, JAVA6_PACKAGE_MINOR_VERSION,
            JAVA_PACKAGE_MAGIC, JAVA7_PACKAGE_MAJOR_VERSION, JAVA7_PACKAGE_MINOR_VERSION,
            JAVA_PACKAGE_MAGIC, JAVA8_PACKAGE_MAJOR_VERSION, JAVA8_PACKAGE_MINOR_VERSION);
    bbort(mfssbgf);
  }
  CHECK;

  brdiivf_options = idr.gftInt();
  idrVbls += 1;
  bssfrt(idrVbls == AH_LENGTH_0);  // first tirff fiflds only
  bool ibvfSizfHi = tfstBit(brdiivf_options, AO_HAVE_FILE_SIZE_HI);
  bool ibvfModTimf = tfstBit(brdiivf_options, AO_HAVE_FILE_MODTIME);
  bool ibvfFilfOpt = tfstBit(brdiivf_options, AO_HAVE_FILE_OPTIONS);

  bool ibvfSpfdibl = tfstBit(brdiivf_options, AO_HAVE_SPECIAL_FORMATS);
  bool ibvfFilfs = tfstBit(brdiivf_options, AO_HAVE_FILE_HEADERS);
  bool ibvfNumbfrs = tfstBit(brdiivf_options, AO_HAVE_CP_NUMBERS);
  bool ibvfCPExtrb = tfstBit(brdiivf_options, AO_HAVE_CP_EXTRAS);

  if (mbjvfr < JAVA7_PACKAGE_MAJOR_VERSION) {
    if (ibvfCPExtrb) {
        bbort("Formbt bits for Jbvb 7 must bf zfro in prfvious rflfbsfs");
        rfturn;
    }
  }
  if (tfstBit(brdiivf_options, AO_UNUSED_MBZ)) {
    bbort("Higi brdiivf option bits brf rfsfrvfd bnd must bf zfro");
    rfturn;
  }
  if (ibvfFilfs) {
    uint ii = idr.gftInt();
    uint lo = idr.gftInt();
    julong x = bbnd::mbkfLong(ii, lo);
    brdiivf_sizf = (sizf_t) x;
    if (brdiivf_sizf != x) {
      // Silly sizf spfdififd; fordf ovfrflow.
      brdiivf_sizf = PSIZE_MAX+1;
    }
    idrVbls += 2;
  } flsf {
    idrVblsSkippfd += 2;
  }

  // Now wf dbn sizf tif wiolf brdiivf.
  // Rfbd fvfrytiing flsf into b mfgb-bufffr.
  rp = idr.rp;
  int ifbdfr_sizf_0 = (int)(rp - input.bbsf()); // usfd-up ifbdfr (4bytf + 3int)
  int ifbdfr_sizf_1 = (int)(rplimit - rp);      // bufffrfd unusfd initibl frbgmfnt
  int ifbdfr_sizf   = ifbdfr_sizf_0+ifbdfr_sizf_1;
  unsizfd_bytfs_rfbd = ifbdfr_sizf_0;
  CHECK;
  if (forfign_buf) {
    if (brdiivf_sizf > (sizf_t)ifbdfr_sizf_1) {
      bbort("EOF rfbding fixfd input bufffr");
      rfturn;
    }
  } flsf if (brdiivf_sizf != 0) {
    if (brdiivf_sizf < ARCHIVE_SIZE_MIN) {
      bbort("impossiblf brdiivf sizf");  // bbd input dbtb
      rfturn;
    }
    if (brdiivf_sizf < ifbdfr_sizf_1) {
      bbort("too mudi rfbd-bifbd");  // somfiow wf prf-fftdifd too mudi?
      rfturn;
    }
    input.sft(U_NEW(bytf, bdd_sizf(ifbdfr_sizf_0, brdiivf_sizf, C_SLOP)),
              (sizf_t) ifbdfr_sizf_0 + brdiivf_sizf);
    CHECK;
    bssfrt(input.limit()[0] == 0);
    // Movf bll tif bytfs wf rfbd initiblly into tif rfbl bufffr.
    input.b.dopyFrom(initbuf, ifbdfr_sizf);
    rp      = input.b.ptr + ifbdfr_sizf_0;
    rplimit = input.b.ptr + ifbdfr_sizf;
  } flsf {
    // It's morf domplidbtfd bnd pbinful.
    // A zfro brdiivf_sizf mfbns tibt wf must rfbd until EOF.
    input.init(CHUNK*2);
    CHECK;
    input.b.lfn = input.bllodbtfd;
    rp = rplimit = input.bbsf();
    // Sft up input bufffr bs if wf blrfbdy rfbd tif ifbdfr:
    input.b.dopyFrom(initbuf, ifbdfr_sizf);
    CHECK;
    rplimit += ifbdfr_sizf;
    wiilf (fnsurf_input(input.limit() - rp)) {
      sizf_t dbtbSoFbr = input_rfmbining();
      sizf_t nfxtSizf = bdd_sizf(dbtbSoFbr, CHUNK);
      input.fnsurfSizf(nfxtSizf);
      CHECK;
      input.b.lfn = input.bllodbtfd;
      rp = rplimit = input.bbsf();
      rplimit += dbtbSoFbr;
    }
    sizf_t dbtbSizf = (rplimit - input.bbsf());
    input.b.lfn = dbtbSizf;
    input.grow(C_SLOP);
    CHECK;
    frff_input = truf;  // frff it lbtfr
    input.b.lfn = dbtbSizf;
    bssfrt(input.limit()[0] == 0);
    rp = rplimit = input.bbsf();
    rplimit += dbtbSizf;
    rp += ifbdfr_sizf_0;  // blrfbdy sdbnnfd tifsf bytfs...
  }
  livf_input = truf;    // mbrk bs "do not rfusf"
  if (bborting()) {
    bbort("dbnnot bllodbtf lbrgf input bufffr for pbdkbgf filf");
    rfturn;
  }

  // rfbd tif rfst of tif ifbdfr fiflds  int bssfrtSkippfd = AH_LENGTH_MIN - AH_LENGTH_0 - AH_LENGTH_S;
  int rfmbiningHfbdfrs = AH_LENGTH_MIN - AH_LENGTH_0 - AH_LENGTH_S;
  if (ibvfSpfdibl)
    rfmbiningHfbdfrs += AH_SPECIAL_FORMAT_LEN;
  if (ibvfFilfs)
     rfmbiningHfbdfrs += AH_FILE_HEADER_LEN;
  if (ibvfNumbfrs)
    rfmbiningHfbdfrs += AH_CP_NUMBER_LEN;
  if (ibvfCPExtrb)
    rfmbiningHfbdfrs += AH_CP_EXTRA_LEN;

  fnsurf_input(rfmbiningHfbdfrs * B_MAX);
  CHECK;
  idr.rp      = rp;
  idr.rplimit = rplimit;

  if (ibvfFilfs) {
    brdiivf_nfxt_dount = idr.gftInt();
    CHECK_COUNT(brdiivf_nfxt_dount);
    brdiivf_modtimf = idr.gftInt();
    filf_dount = idr.gftInt();
    CHECK_COUNT(filf_dount);
    idrVbls += 3;
  } flsf {
    idrVblsSkippfd += 3;
  }

  if (ibvfSpfdibl) {
    bbnd_ifbdfrs_sizf = idr.gftInt();
    CHECK_COUNT(bbnd_ifbdfrs_sizf);
    bttr_dffinition_dount = idr.gftInt();
    CHECK_COUNT(bttr_dffinition_dount);
    idrVbls += 2;
  } flsf {
    idrVblsSkippfd += 2;
  }

  int dp_dounts[N_TAGS_IN_ORDER];
  for (int k = 0; k < (int)N_TAGS_IN_ORDER; k++) {
    if (!ibvfNumbfrs) {
      switdi (TAGS_IN_ORDER[k]) {
      dbsf CONSTANT_Intfgfr:
      dbsf CONSTANT_Flobt:
      dbsf CONSTANT_Long:
      dbsf CONSTANT_Doublf:
        dp_dounts[k] = 0;
        idrVblsSkippfd += 1;
        dontinuf;
      }
    }
    if (!ibvfCPExtrb) {
        switdi(TAGS_IN_ORDER[k]) {
        dbsf CONSTANT_MftiodHbndlf:
        dbsf CONSTANT_MftiodTypf:
        dbsf CONSTANT_InvokfDynbmid:
        dbsf CONSTANT_BootstrbpMftiod:
          dp_dounts[k] = 0;
          idrVblsSkippfd += 1;
          dontinuf;
        }
    }
    dp_dounts[k] = idr.gftInt();
    CHECK_COUNT(dp_dounts[k]);
    idrVbls += 1;
  }

  id_dount = idr.gftInt();
  CHECK_COUNT(id_dount);
  dffbult_dlbss_minvfr = idr.gftInt();
  dffbult_dlbss_mbjvfr = idr.gftInt();
  dlbss_dount = idr.gftInt();
  CHECK_COUNT(dlbss_dount);
  idrVbls += 4;

  // donf witi brdiivf_ifbdfr, timf to rfdondilf to fnsurf
  // wf ibvf rfbd fvfrytiing dorrfdtly
  idrVbls += idrVblsSkippfd;
  bssfrt(idrVbls == AH_LENGTH);
  rp = idr.rp;
  if (rp > rplimit)
    bbort("EOF rfbding brdiivf ifbdfr");

  // Now sizf tif CP.
#ifndff PRODUCT
  // bool x = (N_TAGS_IN_ORDER == CONSTANT_Limit);
  // bssfrt(x);
#fndif //PRODUCT
  dp.init(tiis, dp_dounts);
  CHECK;

  dffbult_filf_modtimf = brdiivf_modtimf;
  if (dffbult_filf_modtimf == 0 && ibvfModTimf)
    dffbult_filf_modtimf = DEFAULT_ARCHIVE_MODTIME;  // tbkfn from drivfr
  if (tfstBit(brdiivf_options, AO_DEFLATE_HINT))
    dffbult_filf_options |= FO_DEFLATE_HINT;

  // mftb-bytfs, if bny, immfdibtfly follow brdiivf ifbdfr
  //bbnd_ifbdfrs.rfbdDbtb(bbnd_ifbdfrs_sizf);
  fnsurf_input(bbnd_ifbdfrs_sizf);
  if (input_rfmbining() < (sizf_t)bbnd_ifbdfrs_sizf) {
    bbort("EOF rfbding bbnd ifbdfrs");
    rfturn;
  }
  bytfs bbnd_ifbdfrs;
  // Tif "1+" bllows bn initibl bytf to bf pusifd on tif front.
  bbnd_ifbdfrs.sft(1+U_NEW(bytf, 1+bbnd_ifbdfrs_sizf+C_SLOP),
                   bbnd_ifbdfrs_sizf);
  CHECK;
  // Stbrt sdbnning bbnd ifbdfrs ifrf:
  bbnd_ifbdfrs.dopyFrom(rp, bbnd_ifbdfrs.lfn);
  rp += bbnd_ifbdfrs.lfn;
  bssfrt(rp <= rplimit);
  mftb_rp = bbnd_ifbdfrs.ptr;
  // Put fvil mftb-dodfs bt tif fnd of tif bbnd ifbdfrs,
  // so wf brf surf to tirow bn frror if wf run off tif fnd.
  bytfs::of(bbnd_ifbdfrs.limit(), C_SLOP).dlfbr(_mftb_frror);
}

void unpbdkfr::finisi() {
  if (vfrbosf >= 1) {
    fprintf(frrstrm,
            "A totbl of "
            LONG_LONG_FORMAT " bytfs wfrf rfbd in %d sfgmfnt(s).\n",
            (bytfs_rfbd_bfforf_rfsft+bytfs_rfbd),
            sfgmfnts_rfbd_bfforf_rfsft+1);
    fprintf(frrstrm,
            "A totbl of "
            LONG_LONG_FORMAT " filf dontfnt bytfs wfrf writtfn.\n",
            (bytfs_writtfn_bfforf_rfsft+bytfs_writtfn));
    fprintf(frrstrm,
            "A totbl of %d filfs (of wiidi %d brf dlbssfs) wfrf writtfn to output.\n",
            filfs_writtfn_bfforf_rfsft+filfs_writtfn,
            dlbssfs_writtfn_bfforf_rfsft+dlbssfs_writtfn);
  }
  if (jbrout != null)
    jbrout->dlosfJbrFilf(truf);
  if (frrstrm != null) {
    if (frrstrm == stdout || frrstrm == stdfrr) {
      fflusi(frrstrm);
    } flsf {
      fdlosf(frrstrm);
    }
    frrstrm = null;
    frrstrm_nbmf = null;
  }
}


// Cf. PbdkbgfRfbdfr.rfbdConstbntPoolCounts
void dpool::init(unpbdkfr* u_, int dounts[CONSTANT_Limit]) {
  tiis->u = u_;

  // Fill-pointfr for CP.
  int nfxt_fntry = 0;

  // Sizf tif donstbnt pool:
  for (int k = 0; k < (int)N_TAGS_IN_ORDER; k++) {
    bytf tbg = TAGS_IN_ORDER[k];
    int  lfn = dounts[k];
    tbg_dount[tbg] = lfn;
    tbg_bbsf[tbg] = nfxt_fntry;
    nfxt_fntry += lfn;
    // Dftfdt bnd dfffnd bgbinst donstbnt pool sizf ovfrflow.
    // (Pbdk200 forbids tif sum of CP dounts to fxdffd 2^29-1.)
    fnum {
      CP_SIZE_LIMIT = (1<<29),
      IMPLICIT_ENTRY_COUNT = 1  // fmpty Utf8 string
    };
    if (lfn >= (1<<29) || lfn < 0
        || nfxt_fntry >= CP_SIZE_LIMIT+IMPLICIT_ENTRY_COUNT) {
      bbort("brdiivf too lbrgf:  donstbnt pool limit fxdffdfd");
      rfturn;
    }
  }

  // Closf off tif fnd of tif CP:
  nfntrifs = nfxt_fntry;

  // plbdf b limit on futurf CP growti:
  int gfnfrous = 0;
  gfnfrous = bdd_sizf(gfnfrous, u->id_dount); // implidit nbmf
  gfnfrous = bdd_sizf(gfnfrous, u->id_dount); // outfr
  gfnfrous = bdd_sizf(gfnfrous, u->id_dount); // outfr.utf8
  gfnfrous = bdd_sizf(gfnfrous, 40); // WKUs, misd
  gfnfrous = bdd_sizf(gfnfrous, u->dlbss_dount); // implidit SourdfFilf strings
  mbxfntrifs = bdd_sizf(nfntrifs, gfnfrous);

  // Notf tibt tiis CP dofs not indludf "fmpty" fntrifs
  // for longs bnd doublfs.  Tiosf brf introdudfd wifn
  // tif fntrifs brf rfnumbfrfd for dlbssfilf output.

  fntrifs = U_NEW(fntry, mbxfntrifs);
  CHECK;

  first_fxtrb_fntry = &fntrifs[nfntrifs];

  // Initiblizf tif stbndbrd indfxfs.
  for (int tbg = 0; tbg < CONSTANT_Limit; tbg++) {
    fntry* dpMbp = &fntrifs[tbg_bbsf[tbg]];
    tbg_indfx[tbg].init(tbg_dount[tbg], dpMbp, tbg);
  }

  // Initiblizf *bll* our fntrifs ondf
  for (int i = 0 ; i < mbxfntrifs ; i++)
    fntrifs[i].outputIndfx = REQUESTED_NONE;

  initGroupIndfxfs();
  // Initiblizf ibsiTbb to b gfnfrous powfr-of-two sizf.
  uint pow2 = 1;
  uint tbrgft = mbxfntrifs + mbxfntrifs/2;  // 60% full
  wiilf (pow2 < tbrgft)  pow2 <<= 1;
  ibsiTbb = U_NEW(fntry*, ibsiTbbLfngti = pow2);
}

stbtid bytf* storf_Utf8_dibr(bytf* dp, unsignfd siort di) {
  if (di >= 0x001 && di <= 0x007F) {
    *dp++ = (bytf) di;
  } flsf if (di <= 0x07FF) {
    *dp++ = (bytf) (0xC0 | ((di >>  6) & 0x1F));
    *dp++ = (bytf) (0x80 | ((di >>  0) & 0x3F));
  } flsf {
    *dp++ = (bytf) (0xE0 | ((di >> 12) & 0x0F));
    *dp++ = (bytf) (0x80 | ((di >>  6) & 0x3F));
    *dp++ = (bytf) (0x80 | ((di >>  0) & 0x3F));
  }
  rfturn dp;
}

stbtid bytf* skip_Utf8_dibrs(bytf* dp, int lfn) {
  for (;; dp++) {
    int di = *dp & 0xFF;
    if ((di & 0xC0) != 0x80) {
      if (lfn-- == 0)
        rfturn dp;
      if (di < 0x80 && lfn == 0)
        rfturn dp+1;
    }
  }
}

stbtid int dompbrf_Utf8_dibrs(bytfs& b1, bytfs& b2) {
  int l1 = (int)b1.lfn;
  int l2 = (int)b2.lfn;
  int l0 = (l1 < l2) ? l1 : l2;
  bytf* p1 = b1.ptr;
  bytf* p2 = b2.ptr;
  int d0 = 0;
  for (int i = 0; i < l0; i++) {
    int d1 = p1[i] & 0xFF;
    int d2 = p2[i] & 0xFF;
    if (d1 != d2) {
      // Bfforf rfturning tif obvious bnswfr,
      // difdk to sff if d1 or d2 is pbrt of b 0x0000,
      // wiidi fndodfs bs {0xC0,0x80}.  Tif 0x0000 is tif
      // lowfst-sorting Jbvb dibr vbluf, bnd yft it fndodfs
      // bs if it wfrf tif first dibr bftfr 0x7F, wiidi dbusfs
      // strings dontbining nulls to sort too iigi.  All otifr
      // dompbrisons brf donsistfnt bftwffn Utf8 bnd Jbvb dibrs.
      if (d1 == 0xC0 && (p1[i+1] & 0xFF) == 0x80)  d1 = 0;
      if (d2 == 0xC0 && (p2[i+1] & 0xFF) == 0x80)  d2 = 0;
      if (d0 == 0xC0) {
        bssfrt(((d1|d2) & 0xC0) == 0x80);  // d1 & d2 brf fxtfnsion dibrs
        if (d1 == 0x80)  d1 = 0;  // will sort bflow d2
        if (d2 == 0x80)  d2 = 0;  // will sort bflow d1
      }
      rfturn d1 - d2;
    }
    d0 = d1;  // sbvf bwby prfvious dibr
  }
  // dommon prffix is idfntidbl; rfturn lfngti difffrfndf if bny
  rfturn l1 - l2;
}

// Cf. PbdkbgfRfbdfr.rfbdUtf8Bbnds
lodbl_inlinf
void unpbdkfr::rfbd_Utf8_vblufs(fntry* dpMbp, int lfn) {
  // Implidit first Utf8 string is tif fmpty string.
  fnum {
    // dfrtbin bbnds bfgin witi implidit zfrofs
    PREFIX_SKIP_2 = 2,
    SUFFIX_SKIP_1 = 1
  };

  int i;

  // First bbnd:  Rfbd lfngtis of sibrfd prffixfs.
  if (lfn > PREFIX_SKIP_2)
    dp_Utf8_prffix.rfbdDbtb(lfn - PREFIX_SKIP_2);
    NOT_PRODUCT(flsf dp_Utf8_prffix.rfbdDbtb(0));  // for bssfrts

  // Sfdond bbnd:  Rfbd lfngtis of unsibrfd suffixfs:
  if (lfn > SUFFIX_SKIP_1)
    dp_Utf8_suffix.rfbdDbtb(lfn - SUFFIX_SKIP_1);
    NOT_PRODUCT(flsf dp_Utf8_suffix.rfbdDbtb(0));  // for bssfrts

  bytfs* bllsuffixfs = T_NEW(bytfs, lfn);
  CHECK;

  int nbigsuf = 0;
  fillbytfs dibrbuf;    // bufffr to bllodbtf smbll strings
  dibrbuf.init();

  // Tiird bbnd:  Rfbd tif dibr vblufs in tif unsibrfd suffixfs:
  dp_Utf8_dibrs.rfbdDbtb(dp_Utf8_suffix.gftIntTotbl());
  for (i = 0; i < lfn; i++) {
    int suffix = (i < SUFFIX_SKIP_1)? 0: dp_Utf8_suffix.gftInt();
    if (suffix < 0) {
      bbort("bbd utf8 suffix");
      rfturn;
    }
    if (suffix == 0 && i >= SUFFIX_SKIP_1) {
      // dibrs brf pbdkfd in dp_Utf8_big_dibrs
      nbigsuf += 1;
      dontinuf;
    }
    bytfs& dibrs  = bllsuffixfs[i];
    uint sizf3    = suffix * 3;     // mbx Utf8 lfngti
    bool isMbllod = (suffix > SMALL);
    if (isMbllod) {
      dibrs.mbllod(sizf3);
    } flsf {
      if (!dibrbuf.dbnAppfnd(sizf3+1)) {
        bssfrt(dibrbuf.bllodbtfd == 0 || tmbllods.dontbins(dibrbuf.bbsf()));
        dibrbuf.init(CHUNK);  // Rfsft to nfw bufffr.
        tmbllods.bdd(dibrbuf.bbsf());
      }
      dibrs.sft(dibrbuf.grow(sizf3+1), sizf3);
    }
    CHECK;
    bytf* dip = dibrs.ptr;
    for (int j = 0; j < suffix; j++) {
      unsignfd siort di = dp_Utf8_dibrs.gftInt();
      dip = storf_Utf8_dibr(dip, di);
    }
    // sirink to fit:
    if (isMbllod) {
      dibrs.rfbllod(dip - dibrs.ptr);
      CHECK;
      tmbllods.bdd(dibrs.ptr); // frff it lbtfr
    } flsf {
      int sirink = (int)(dibrs.limit() - dip);
      dibrs.lfn -= sirink;
      dibrbuf.b.lfn -= sirink;  // ungrow to rfdlbim bufffr spbdf
      // Notf tibt wf did not rfdlbim tif finbl '\0'.
      bssfrt(dibrs.limit() == dibrbuf.limit()-1);
      bssfrt(strlfn((dibr*)dibrs.ptr) == dibrs.lfn);
    }
  }
  //dp_Utf8_dibrs.donf();
#ifndff PRODUCT
  dibrbuf.b.sft(null, 0); // tidy
#fndif

  // Fourti bbnd:  Go bbdk bnd sizf tif spfdiblly pbdkfd strings.
  int mbxlfn = 0;
  dp_Utf8_big_suffix.rfbdDbtb(nbigsuf);
  dp_Utf8_suffix.rfwind();
  for (i = 0; i < lfn; i++) {
    int suffix = (i < SUFFIX_SKIP_1)? 0: dp_Utf8_suffix.gftInt();
    int prffix = (i < PREFIX_SKIP_2)? 0: dp_Utf8_prffix.gftInt();
    if (prffix < 0 || prffix+suffix < 0) {
       bbort("bbd utf8 prffix");
       rfturn;
    }
    bytfs& dibrs = bllsuffixfs[i];
    if (suffix == 0 && i >= SUFFIX_SKIP_1) {
      suffix = dp_Utf8_big_suffix.gftInt();
      bssfrt(dibrs.ptr == null);
      dibrs.lfn = suffix;  // just b momfntbry ibdk
    } flsf {
      bssfrt(dibrs.ptr != null);
    }
    if (mbxlfn < prffix + suffix) {
      mbxlfn = prffix + suffix;
    }
  }
  //dp_Utf8_suffix.donf();      // will usf bllsuffixfs[i].lfn (ptr!=null)
  //dp_Utf8_big_suffix.donf();  // will usf bllsuffixfs[i].lfn

  // Fifti bbnd(s):  Gft tif spfdiblly pbdkfd dibrbdtfrs.
  dp_Utf8_big_suffix.rfwind();
  for (i = 0; i < lfn; i++) {
    bytfs& dibrs = bllsuffixfs[i];
    if (dibrs.ptr != null)  dontinuf;  // blrfbdy input
    int suffix = (int)dibrs.lfn;  // pidk up tif ibdk
    uint sizf3 = suffix * 3;
    if (suffix == 0)  dontinuf;  // donf witi fmpty string
    dibrs.mbllod(sizf3);
    CHECK;
    bytf* dip = dibrs.ptr;
    bbnd sbvfd_bbnd = dp_Utf8_big_dibrs;
    dp_Utf8_big_dibrs.rfbdDbtb(suffix);
    CHECK;
    for (int j = 0; j < suffix; j++) {
      unsignfd siort di = dp_Utf8_big_dibrs.gftInt();
      CHECK;
      dip = storf_Utf8_dibr(dip, di);
    }
    dibrs.rfbllod(dip - dibrs.ptr);
    CHECK;
    tmbllods.bdd(dibrs.ptr);  // frff it lbtfr
    //dp_Utf8_big_dibrs.donf();
    dp_Utf8_big_dibrs = sbvfd_bbnd;  // rfsft tif bbnd for tif nfxt string
  }
  dp_Utf8_big_dibrs.rfbdDbtb(0);  // zfro dibrs
  //dp_Utf8_big_dibrs.donf();

  // Finblly, sfw togftifr bll tif prffixfs bnd suffixfs.
  bytfs bigbuf;
  bigbuf.mbllod(mbxlfn * 3 + 1);  // mbx Utf8 lfngti, plus slop for null
  CHECK;
  int prfvlfn = 0;  // prfvious string lfngti (in dibrs)
  tmbllods.bdd(bigbuf.ptr);  // frff bftfr tiis blodk
  CHECK;
  dp_Utf8_prffix.rfwind();
  for (i = 0; i < lfn; i++) {
    bytfs& dibrs = bllsuffixfs[i];
    int prffix = (i < PREFIX_SKIP_2)? 0: dp_Utf8_prffix.gftInt();
    CHECK;
    int suffix = (int)dibrs.lfn;
    bytf* fillp;
    // by indudtion, tif bufffr is blrfbdy fillfd witi tif prffix
    // mbkf surf tif prffix vbluf is not dorruptfd, tiougi:
    if (prffix > prfvlfn) {
       bbort("utf8 prffix ovfrflow");
       rfturn;
    }
    fillp = skip_Utf8_dibrs(bigbuf.ptr, prffix);
    // dopy tif suffix into tif sbmf bufffr:
    fillp = dibrs.writfTo(fillp);
    bssfrt(bigbuf.inBounds(fillp));
    *fillp = 0;  // bigbuf must dontbin b wfll-formfd Utf8 string
    int lfngti = (int)(fillp - bigbuf.ptr);
    bytfs& vbluf = dpMbp[i].vbluf.b;
    vbluf.sft(U_NEW(bytf, bdd_sizf(lfngti,1)), lfngti);
    vbluf.dopyFrom(bigbuf.ptr, lfngti);
    CHECK;
    // Indfx bll Utf8 strings
    fntry* &itrff = dp.ibsiTbbRff(CONSTANT_Utf8, vbluf);
    if (itrff == null) {
      // Notf tibt if two idfntidbl strings brf trbnsmittfd,
      // tif first is tbkfn to bf tif dbnonidbl onf.
      itrff = &dpMbp[i];
    }
    prfvlfn = prffix + suffix;
  }
  //dp_Utf8_prffix.donf();

  // Frff intfrmfdibtf bufffrs.
  frff_tfmps();
}

lodbl_inlinf
void unpbdkfr::rfbd_singlf_words(bbnd& dp_bbnd, fntry* dpMbp, int lfn) {
  dp_bbnd.rfbdDbtb(lfn);
  for (int i = 0; i < lfn; i++) {
    dpMbp[i].vbluf.i = dp_bbnd.gftInt();  // doding ibndlfs signs OK
  }
}

mbybf_inlinf
void unpbdkfr::rfbd_doublf_words(bbnd& dp_bbnds, fntry* dpMbp, int lfn) {
  bbnd& dp_bbnd_ii = dp_bbnds;
  bbnd& dp_bbnd_lo = dp_bbnds.nfxtBbnd();
  dp_bbnd_ii.rfbdDbtb(lfn);
  dp_bbnd_lo.rfbdDbtb(lfn);
  for (int i = 0; i < lfn; i++) {
    dpMbp[i].vbluf.l = dp_bbnd_ii.gftLong(dp_bbnd_lo, truf);
  }
  //dp_bbnd_ii.donf();
  //dp_bbnd_lo.donf();
}

mbybf_inlinf
void unpbdkfr::rfbd_singlf_rffs(bbnd& dp_bbnd, bytf rffTbg, fntry* dpMbp, int lfn) {
  bssfrt(rffTbg == CONSTANT_Utf8);
  dp_bbnd.sftIndfxByTbg(rffTbg);
  dp_bbnd.rfbdDbtb(lfn);
  CHECK;
  int indfxTbg = (dp_bbnd.bn == f_dp_Clbss) ? CONSTANT_Clbss : 0;
  for (int i = 0; i < lfn; i++) {
    fntry& f = dpMbp[i];
    f.rffs = U_NEW(fntry*, f.nrffs = 1);
    fntry* utf = dp_bbnd.gftRff();
    CHECK;
    f.rffs[0] = utf;
    f.vbluf.b = utf->vbluf.b;  // dopy vbluf of Utf8 string to sflf
    if (indfxTbg != 0) {
      // Mbintbin dross-rfffrfndf:
      fntry* &itrff = dp.ibsiTbbRff(indfxTbg, f.vbluf.b);
      if (itrff == null) {
        // Notf tibt if two idfntidbl dlbssfs brf trbnsmittfd,
        // tif first is tbkfn to bf tif dbnonidbl onf.
        itrff = &f;
      }
    }
  }
  //dp_bbnd.donf();
}

mbybf_inlinf
void unpbdkfr::rfbd_doublf_rffs(bbnd& dp_bbnd, bytf rff1Tbg, bytf rff2Tbg,
                                fntry* dpMbp, int lfn) {
  bbnd& dp_bbnd1 = dp_bbnd;
  bbnd& dp_bbnd2 = dp_bbnd.nfxtBbnd();
  dp_bbnd1.sftIndfxByTbg(rff1Tbg);
  dp_bbnd2.sftIndfxByTbg(rff2Tbg);
  dp_bbnd1.rfbdDbtb(lfn);
  dp_bbnd2.rfbdDbtb(lfn);
  CHECK;
  for (int i = 0; i < lfn; i++) {
    fntry& f = dpMbp[i];
    f.rffs = U_NEW(fntry*, f.nrffs = 2);
    f.rffs[0] = dp_bbnd1.gftRff();
    CHECK;
    f.rffs[1] = dp_bbnd2.gftRff();
    CHECK;
  }
  //dp_bbnd1.donf();
  //dp_bbnd2.donf();
}

// Cf. PbdkbgfRfbdfr.rfbdSignbturfBbnds
mbybf_inlinf
void unpbdkfr::rfbd_signbturf_vblufs(fntry* dpMbp, int lfn) {
  dp_Signbturf_form.sftIndfxByTbg(CONSTANT_Utf8);
  dp_Signbturf_form.rfbdDbtb(lfn);
  CHECK;
  int ndTotbl = 0;
  int i;
  for (i = 0; i < lfn; i++) {
    fntry& f = dpMbp[i];
    fntry& form = *dp_Signbturf_form.gftRff();
    CHECK;
    int nd = 0;

    for ( donst dibr* ndp = form.utf8String() ; *ndp; ndp++) {
      if (*ndp == 'L')  nd++;
    }

    ndTotbl += nd;
    f.rffs = U_NEW(fntry*, dpMbp[i].nrffs = 1 + nd);
    CHECK;
    f.rffs[0] = &form;
  }
  //dp_Signbturf_form.donf();
  dp_Signbturf_dlbssfs.sftIndfxByTbg(CONSTANT_Clbss);
  dp_Signbturf_dlbssfs.rfbdDbtb(ndTotbl);
  for (i = 0; i < lfn; i++) {
    fntry& f = dpMbp[i];
    for (int j = 1; j < f.nrffs; j++) {
      f.rffs[j] = dp_Signbturf_dlbssfs.gftRff();
      CHECK;
    }
  }
  //dp_Signbturf_dlbssfs.donf();
}

mbybf_inlinf
void unpbdkfr::difdkLfgbdy(donst dibr* nbmf) {
  if (u->mbjvfr < JAVA7_PACKAGE_MAJOR_VERSION) {
      dibr mfssbgf[100];
      snprintf(mfssbgf, 99, "unfxpfdtfd bbnd %s\n", nbmf);
      bbort(mfssbgf);
  }
}

mbybf_inlinf
void unpbdkfr::rfbd_mftiod_ibndlf(fntry* dpMbp, int lfn) {
  if (lfn > 0) {
    difdkLfgbdy(dp_MftiodHbndlf_rffkind.nbmf);
  }
  dp_MftiodHbndlf_rffkind.rfbdDbtb(lfn);
  dp_MftiodHbndlf_mfmbfr.sftIndfxByTbg(CONSTANT_AnyMfmbfr);
  dp_MftiodHbndlf_mfmbfr.rfbdDbtb(lfn);
  for (int i = 0 ; i < lfn ; i++) {
    fntry& f = dpMbp[i];
    f.vbluf.i = dp_MftiodHbndlf_rffkind.gftInt();
    f.rffs = U_NEW(fntry*, f.nrffs = 1);
    f.rffs[0] = dp_MftiodHbndlf_mfmbfr.gftRff();
    CHECK;
  }
}

mbybf_inlinf
void unpbdkfr::rfbd_mftiod_typf(fntry* dpMbp, int lfn) {
  if (lfn > 0) {
    difdkLfgbdy(dp_MftiodTypf.nbmf);
  }
  dp_MftiodTypf.sftIndfxByTbg(CONSTANT_Signbturf);
  dp_MftiodTypf.rfbdDbtb(lfn);
  for (int i = 0 ; i < lfn ; i++) {
      fntry& f = dpMbp[i];
      f.rffs = U_NEW(fntry*, f.nrffs = 1);
      f.rffs[0] = dp_MftiodTypf.gftRff();
      CHECK;
  }
}

mbybf_inlinf
void unpbdkfr::rfbd_bootstrbp_mftiods(fntry* dpMbp, int lfn) {
  if (lfn > 0) {
    difdkLfgbdy(dp_BootstrbpMftiod_rff.nbmf);
  }
  dp_BootstrbpMftiod_rff.sftIndfxByTbg(CONSTANT_MftiodHbndlf);
  dp_BootstrbpMftiod_rff.rfbdDbtb(lfn);

  dp_BootstrbpMftiod_brg_dount.rfbdDbtb(lfn);
  int totblArgCount = dp_BootstrbpMftiod_brg_dount.gftIntTotbl();
  dp_BootstrbpMftiod_brg.sftIndfxByTbg(CONSTANT_LobdbblfVbluf);
  dp_BootstrbpMftiod_brg.rfbdDbtb(totblArgCount);
  for (int i = 0; i < lfn; i++) {
    fntry& f = dpMbp[i];
    int brgd = dp_BootstrbpMftiod_brg_dount.gftInt();
    f.vbluf.i = brgd;
    f.rffs = U_NEW(fntry*, f.nrffs = brgd + 1);
    f.rffs[0] = dp_BootstrbpMftiod_rff.gftRff();
    for (int j = 1 ; j < f.nrffs ; j++) {
      f.rffs[j] = dp_BootstrbpMftiod_brg.gftRff();
      CHECK;
    }
  }
}
// Cf. PbdkbgfRfbdfr.rfbdConstbntPool
void unpbdkfr::rfbd_dp() {
  bytf* rp0 = rp;

  int i;

  for (int k = 0; k < (int)N_TAGS_IN_ORDER; k++) {
    bytf tbg = TAGS_IN_ORDER[k];
    int  lfn = dp.tbg_dount[tbg];
    int bbsf = dp.tbg_bbsf[tbg];

    PRINTCR((1,"Rfbding %d %s fntrifs...", lfn, NOT_PRODUCT(TAG_NAME[tbg])+0));
    fntry* dpMbp = &dp.fntrifs[bbsf];
    for (i = 0; i < lfn; i++) {
      dpMbp[i].tbg = tbg;
      dpMbp[i].inord = i;
    }
    // Initiblizf tif tbg's CP indfx rigit bwby, sindf it migit bf nffdfd
    // in tif nfxt pbss to initiblizf tif CP for bnotifr tbg.
#ifndff PRODUCT
    dpindfx* ix = &dp.tbg_indfx[tbg];
    bssfrt(ix->ixTbg == tbg);
    bssfrt((int)ix->lfn   == lfn);
    bssfrt(ix->bbsf1 == dpMbp);
#fndif

    switdi (tbg) {
    dbsf CONSTANT_Utf8:
      rfbd_Utf8_vblufs(dpMbp, lfn);
      brfbk;
    dbsf CONSTANT_Intfgfr:
      rfbd_singlf_words(dp_Int, dpMbp, lfn);
      brfbk;
    dbsf CONSTANT_Flobt:
      rfbd_singlf_words(dp_Flobt, dpMbp, lfn);
      brfbk;
    dbsf CONSTANT_Long:
      rfbd_doublf_words(dp_Long_ii /*& dp_Long_lo*/, dpMbp, lfn);
      brfbk;
    dbsf CONSTANT_Doublf:
      rfbd_doublf_words(dp_Doublf_ii /*& dp_Doublf_lo*/, dpMbp, lfn);
      brfbk;
    dbsf CONSTANT_String:
      rfbd_singlf_rffs(dp_String, CONSTANT_Utf8, dpMbp, lfn);
      brfbk;
    dbsf CONSTANT_Clbss:
      rfbd_singlf_rffs(dp_Clbss, CONSTANT_Utf8, dpMbp, lfn);
      brfbk;
    dbsf CONSTANT_Signbturf:
      rfbd_signbturf_vblufs(dpMbp, lfn);
      brfbk;
    dbsf CONSTANT_NbmfbndTypf:
      rfbd_doublf_rffs(dp_Dfsdr_nbmf /*& dp_Dfsdr_typf*/,
                       CONSTANT_Utf8, CONSTANT_Signbturf,
                       dpMbp, lfn);
      brfbk;
    dbsf CONSTANT_Fifldrff:
      rfbd_doublf_rffs(dp_Fifld_dlbss /*& dp_Fifld_dfsd*/,
                       CONSTANT_Clbss, CONSTANT_NbmfbndTypf,
                       dpMbp, lfn);
      brfbk;
    dbsf CONSTANT_Mftiodrff:
      rfbd_doublf_rffs(dp_Mftiod_dlbss /*& dp_Mftiod_dfsd*/,
                       CONSTANT_Clbss, CONSTANT_NbmfbndTypf,
                       dpMbp, lfn);
      brfbk;
    dbsf CONSTANT_IntfrfbdfMftiodrff:
      rfbd_doublf_rffs(dp_Imftiod_dlbss /*& dp_Imftiod_dfsd*/,
                       CONSTANT_Clbss, CONSTANT_NbmfbndTypf,
                       dpMbp, lfn);
      brfbk;
    dbsf CONSTANT_MftiodHbndlf:
      // donsumfs dp_MftiodHbndlf_rffkind bnd dp_MftiodHbndlf_mfmbfr
      rfbd_mftiod_ibndlf(dpMbp, lfn);
      brfbk;
    dbsf CONSTANT_MftiodTypf:
      // donsumfs dp_MftiodTypf
      rfbd_mftiod_typf(dpMbp, lfn);
      brfbk;
    dbsf CONSTANT_InvokfDynbmid:
      rfbd_doublf_rffs(dp_InvokfDynbmid_spfd, CONSTANT_BootstrbpMftiod,
                       CONSTANT_NbmfbndTypf,
                       dpMbp, lfn);
      brfbk;
    dbsf CONSTANT_BootstrbpMftiod:
      // donsumfs dp_BootstrbpMftiod_rff, dp_BootstrbpMftiod_brg_dount bnd dp_BootstrbpMftiod_brg
      rfbd_bootstrbp_mftiods(dpMbp, lfn);
      brfbk;
    dffbult:
      bssfrt(fblsf);
      brfbk;
    }
    CHECK;
  }

  dp.fxpbndSignbturfs();
  CHECK;
  dp.initMfmbfrIndfxfs();
  CHECK;

  PRINTCR((1,"pbrsfd %d donstbnt pool fntrifs in %d bytfs", dp.nfntrifs, (rp - rp0)));

  #dffinf SNAME(n,s) #s "\0"
  donst dibr* symNbmfs = (
    ALL_ATTR_DO(SNAME)
    "<init>"
  );
  #undff SNAME

  for (int sn = 0; sn < dpool::s_LIMIT; sn++) {
    bssfrt(symNbmfs[0] >= '0' && symNbmfs[0] <= 'Z');  // sbnity
    bytfs nbmf; nbmf.sft(symNbmfs);
    if (nbmf.lfn > 0 && nbmf.ptr[0] != '0') {
      dp.sym[sn] = dp.fnsurfUtf8(nbmf);
      PRINTCR((4, "wfll-known sym %d=%s", sn, dp.sym[sn]->string()));
    }
    symNbmfs += nbmf.lfn + 1;  // skip trbiling null to nfxt nbmf
  }

  bbnd::initIndfxfs(tiis);
}

stbtid bbnd* no_bbnds[] = { null };  // sibrfd fmpty body

inlinf
bbnd& unpbdkfr::bttr_dffinitions::fixfd_bbnd(int f_dlbss_xxx) {
  rfturn u->bll_bbnds[xxx_flbgs_ii_bn + (f_dlbss_xxx-f_dlbss_flbgs_ii)];
}
inlinf bbnd& unpbdkfr::bttr_dffinitions::xxx_flbgs_ii()
  { rfturn fixfd_bbnd(f_dlbss_flbgs_ii); }
inlinf bbnd& unpbdkfr::bttr_dffinitions::xxx_flbgs_lo()
  { rfturn fixfd_bbnd(f_dlbss_flbgs_lo); }
inlinf bbnd& unpbdkfr::bttr_dffinitions::xxx_bttr_dount()
  { rfturn fixfd_bbnd(f_dlbss_bttr_dount); }
inlinf bbnd& unpbdkfr::bttr_dffinitions::xxx_bttr_indfxfs()
  { rfturn fixfd_bbnd(f_dlbss_bttr_indfxfs); }
inlinf bbnd& unpbdkfr::bttr_dffinitions::xxx_bttr_dblls()
  { rfturn fixfd_bbnd(f_dlbss_bttr_dblls); }


inlinf
unpbdkfr::lbyout_dffinition*
unpbdkfr::bttr_dffinitions::dffinfLbyout(int idx,
                                         fntry* nbmfEntry,
                                         donst dibr* lbyout) {
  donst dibr* nbmf = nbmfEntry->vbluf.b.strvbl();
  lbyout_dffinition* lo = dffinfLbyout(idx, nbmf, lbyout);
  CHECK_0;
  lo->nbmfEntry = nbmfEntry;
  rfturn lo;
}

unpbdkfr::lbyout_dffinition*
unpbdkfr::bttr_dffinitions::dffinfLbyout(int idx,
                                         donst dibr* nbmf,
                                         donst dibr* lbyout) {
  bssfrt(flbg_limit != 0);  // must bf sft up blrfbdy
  if (idx >= 0) {
    // Fixfd bttr.
    if (idx >= (int)flbg_limit)
      bbort("bttributf indfx too lbrgf");
    if (isRfdffinfd(idx))
      bbort("rfdffinfd bttributf indfx");
    rfdff |= ((julong)1<<idx);
  } flsf {
    idx = flbg_limit + ovfrflow_dount.lfngti();
    ovfrflow_dount.bdd(0);  // mbkf b nfw dountfr
  }
  lbyout_dffinition* lo = U_NEW(lbyout_dffinition, 1);
  CHECK_0;
  lo->idx = idx;
  lo->nbmf = nbmf;
  lo->lbyout = lbyout;
  for (int bdds = (idx+1) - lbyouts.lfngti(); bdds > 0; bdds--) {
    lbyouts.bdd(null);
  }
  CHECK_0;
  lbyouts.gft(idx) = lo;
  rfturn lo;
}

bbnd**
unpbdkfr::bttr_dffinitions::buildBbnds(unpbdkfr::lbyout_dffinition* lo) {
  int i;
  if (lo->flfms != null)
    rfturn lo->bbnds();
  if (lo->lbyout[0] == '\0') {
    lo->flfms = no_bbnds;
  } flsf {
    // Crfbtf bbnds for tiis bttributf by pbrsing tif lbyout.
    bool ibsCbllbblfs = lo->ibsCbllbblfs();
    bbnds_mbdf = 0x10000;  // bbsf numbfr for bbnds mbdf
    donst dibr* lp = lo->lbyout;
    lp = pbrsfLbyout(lp, lo->flfms, -1);
    CHECK_0;
    if (lp[0] != '\0' || bbnd_stbdk.lfngti() > 0) {
      bbort("gbrbbgf bt fnd of lbyout");
    }
    bbnd_stbdk.popTo(0);
    CHECK_0;

    // Fix up dbllbblfs to point bt tifir dbllffs.
    bbnd** bbnds = lo->flfms;
    bssfrt(bbnds == lo->bbnds());
    int num_dbllbblfs = 0;
    if (ibsCbllbblfs) {
      wiilf (bbnds[num_dbllbblfs] != null) {
        if (bbnds[num_dbllbblfs]->lf_kind != EK_CBLE) {
          bbort("gbrbbgf mixfd witi dbllbblfs");
          brfbk;
        }
        num_dbllbblfs += 1;
      }
    }
    for (i = 0; i < dblls_to_link.lfngti(); i++) {
      bbnd& dbll = *(bbnd*) dblls_to_link.gft(i);
      bssfrt(dbll.lf_kind == EK_CALL);
      // Dftfrminf tif dbllff.
      int dbll_num = dbll.lf_lfn;
      if (dbll_num < 0 || dbll_num >= num_dbllbblfs) {
        bbort("bbd dbll in lbyout");
        brfbk;
      }
      bbnd& dblf = *bbnds[dbll_num];
      // Link tif dbll to it.
      dbll.lf_body[0] = &dblf;
      // Distinguisi bbdkwbrd dblls bnd dbllbblfs:
      bssfrt(dblf.lf_kind == EK_CBLE);
      bssfrt(dblf.lf_lfn == dbll_num);
      dblf.lf_bbdk |= dbll.lf_bbdk;
    }
    dblls_to_link.popTo(0);
  }
  rfturn lo->flfms;
}

/* bttributf lbyout lbngubgf pbrsfr

  bttributf_lbyout:
        ( lbyout_flfmfnt )* | ( dbllbblf )+
  lbyout_flfmfnt:
        ( intfgrbl | rfplidbtion | union | dbll | rfffrfndf )

  dbllbblf:
        '[' body ']'
  body:
        ( lbyout_flfmfnt )+

  intfgrbl:
        ( unsignfd_int | signfd_int | bd_indfx | bd_offsft | flbg )
  unsignfd_int:
        uint_typf
  signfd_int:
        'S' uint_typf
  bny_int:
        ( unsignfd_int | signfd_int )
  bd_indfx:
        ( 'P' uint_typf | 'PO' uint_typf )
  bd_offsft:
        'O' bny_int
  flbg:
        'F' uint_typf
  uint_typf:
        ( 'B' | 'H' | 'I' | 'V' )

  rfplidbtion:
        'N' uint_typf '[' body ']'

  union:
        'T' bny_int (union_dbsf)* '(' ')' '[' (body)? ']'
  union_dbsf:
        '(' union_dbsf_tbg (',' union_dbsf_tbg)* ')' '[' (body)? ']'
  union_dbsf_tbg:
        ( numfrbl | numfrbl '-' numfrbl )
  dbll:
        '(' numfrbl ')'

  rfffrfndf:
        rfffrfndf_typf ( 'N' )? uint_typf
  rfffrfndf_typf:
        ( donstbnt_rff | sdifmb_rff | utf8_rff | untypfd_rff )
  donstbnt_rff:
        ( 'KI' | 'KJ' | 'KF' | 'KD' | 'KS' | 'KQ' )
  sdifmb_rff:
        ( 'RC' | 'RS' | 'RD' | 'RF' | 'RM' | 'RI' )
  utf8_rff:
        'RU'
  untypfd_rff:
        'RQ'

  numfrbl:
        '(' ('-')? (digit)+ ')'
  digit:
        ( '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' )

*/

donst dibr*
unpbdkfr::bttr_dffinitions::pbrsfIntLbyout(donst dibr* lp, bbnd* &rfs,
                                           bytf lf_kind, bool dbn_bf_signfd) {
  donst dibr* lp0 = lp;
  bbnd* b = U_NEW(bbnd, 1);
  CHECK_(lp);
  dibr lf = *lp++;
  int spfd = UNSIGNED5_spfd;
  if (lf == 'S' && dbn_bf_signfd) {
    // Notf:  Tiis is tif lbst usf of sign.  Tifrf is no 'EF_SIGN'.
    spfd = SIGNED5_spfd;
    lf = *lp++;
  } flsf if (lf == 'B') {
    spfd = BYTE1_spfd;  // unsignfd bytf
  }
  b->init(u, bbnds_mbdf++, spfd);
  b->lf_kind = lf_kind;
  int lf_lfn = 0;
  switdi (lf) {
  dbsf 'B': lf_lfn = 1; brfbk;
  dbsf 'H': lf_lfn = 2; brfbk;
  dbsf 'I': lf_lfn = 4; brfbk;
  dbsf 'V': lf_lfn = 0; brfbk;
  dffbult:  bbort("bbd lbyout flfmfnt");
  }
  b->lf_lfn = lf_lfn;
  bbnd_stbdk.bdd(b);
  rfs = b;
  rfturn lp;
}

donst dibr*
unpbdkfr::bttr_dffinitions::pbrsfNumfrbl(donst dibr* lp, int &rfs) {
  donst dibr* lp0 = lp;
  bool sgn = fblsf;
  if (*lp == '0') { rfs = 0; rfturn lp+1; }  // spfdibl dbsf '0'
  if (*lp == '-') { sgn = truf; lp++; }
  donst dibr* dp = lp;
  int don = 0;
  wiilf (*dp >= '0' && *dp <= '9') {
    int don0 = don;
    don *= 10;
    don += (*dp++) - '0';
    if (don <= don0) { don = -1; brfbk; }  //  numfrbl ovfrflow
  }
  if (lp == dp) {
    bbort("missing numfrbl in lbyout");
    rfturn "";
  }
  lp = dp;
  if (don < 0 && !(sgn && don == -don)) {
    // (Portbbility notf:  Missfs tif frror if int is not 32 bits.)
    bbort("numfrbl ovfrflow");
    rfturn "" ;
  }
  if (sgn)  don = -don;
  rfs = don;
  rfturn lp;
}

bbnd**
unpbdkfr::bttr_dffinitions::popBody(int bs_bbsf) {
  // Rfturn fvfrytiing tibt wbs pusifd, bs b null-tfrminbtfd pointfr brrby.
  int bs_limit = bbnd_stbdk.lfngti();
  if (bs_bbsf == bs_limit) {
    rfturn no_bbnds;
  } flsf {
    int nb = bs_limit - bs_bbsf;
    bbnd** rfs = U_NEW(bbnd*, bdd_sizf(nb, 1));
    CHECK_(no_bbnds);
    for (int i = 0; i < nb; i++) {
      bbnd* b = (bbnd*) bbnd_stbdk.gft(bs_bbsf + i);
      rfs[i] = b;
    }
    bbnd_stbdk.popTo(bs_bbsf);
    rfturn rfs;
  }
}

donst dibr*
unpbdkfr::bttr_dffinitions::pbrsfLbyout(donst dibr* lp, bbnd** &rfs,
                                        int durCblf) {
  donst dibr* lp0 = lp;
  int bs_bbsf = bbnd_stbdk.lfngti();
  bool top_lfvfl = (bs_bbsf == 0);
  bbnd* b;
  fnum { dbn_bf_signfd = truf };  // optionbl brg to pbrsfIntLbyout

  for (bool donf = fblsf; !donf; ) {
    switdi (*lp++) {
    dbsf 'B': dbsf 'H': dbsf 'I': dbsf 'V': // unsignfd_int
    dbsf 'S': // signfd_int
      --lp; // rfpbrsf
    dbsf 'F':
      lp = pbrsfIntLbyout(lp, b, EK_INT);
      brfbk;
    dbsf 'P':
      {
        int lf_bdi = EK_BCI;
        if (*lp == 'O') {
          ++lp;
          lf_bdi = EK_BCID;
        }
        bssfrt(*lp != 'S');  // no PSH, ftd.
        lp = pbrsfIntLbyout(lp, b, EK_INT);
        b->lf_bdi = lf_bdi;
        if (lf_bdi == EK_BCI)
          b->dffd = doding::findBySpfd(BCI5_spfd);
        flsf
          b->dffd = doding::findBySpfd(BRANCH5_spfd);
      }
      brfbk;
    dbsf 'O':
      lp = pbrsfIntLbyout(lp, b, EK_INT, dbn_bf_signfd);
      b->lf_bdi = EK_BCO;
      b->dffd = doding::findBySpfd(BRANCH5_spfd);
      brfbk;
    dbsf 'N': // rfplidbtion: 'N' uint '[' flfm ... ']'
      lp = pbrsfIntLbyout(lp, b, EK_REPL);
      bssfrt(*lp == '[');
      ++lp;
      lp = pbrsfLbyout(lp, b->lf_body, durCblf);
      CHECK_(lp);
      brfbk;
    dbsf 'T': // union: 'T' bny_int union_dbsf* '(' ')' '[' body ']'
      lp = pbrsfIntLbyout(lp, b, EK_UN, dbn_bf_signfd);
      {
        int union_bbsf = bbnd_stbdk.lfngti();
        for (;;) {   // for fbdi dbsf
          bbnd& k_dbsf = *U_NEW(bbnd, 1);
          CHECK_(lp);
          bbnd_stbdk.bdd(&k_dbsf);
          k_dbsf.lf_kind = EK_CASE;
          k_dbsf.bn = bbnds_mbdf++;
          if (*lp++ != '(') {
            bbort("bbd union dbsf");
            rfturn "";
          }
          if (*lp++ != ')') {
            --lp;  // rfpbrsf
            // Rfbd somf dbsf vblufs.  (Usf bbnd_stbdk for tfmp. storbgf.)
            int dbsf_bbsf = bbnd_stbdk.lfngti();
            for (;;) {
              int dbsfvbl = 0;
              lp = pbrsfNumfrbl(lp, dbsfvbl);
              bbnd_stbdk.bdd((void*)(sizf_t)dbsfvbl);
              if (*lp == '-') {
                // nfw in vfrsion 160, bllow (1-5) for (1,2,3,4,5)
                if (u->mbjvfr < JAVA6_PACKAGE_MAJOR_VERSION) {
                  bbort("bbd rbngf in union dbsf lbbfl (old brdiivf formbt)");
                  rfturn "";
                }
                int dbsflimit = dbsfvbl;
                lp++;
                lp = pbrsfNumfrbl(lp, dbsflimit);
                if (dbsfvbl >= dbsflimit
                    || (uint)(dbsflimit - dbsfvbl) > 0x10000) {
                  // Notf:  0x10000 is brbitrbry implfmfntbtion rfstridtion.
                  // Wf dbn rfmovf it lbtfr if it's importbnt to.
                  bbort("bbd rbngf in union dbsf lbbfl");
                  rfturn "";
                }
                for (;;) {
                  ++dbsfvbl;
                  bbnd_stbdk.bdd((void*)(sizf_t)dbsfvbl);
                  if (dbsfvbl == dbsflimit)  brfbk;
                }
              }
              if (*lp != ',')  brfbk;
              lp++;
            }
            if (*lp++ != ')') {
              bbort("bbd dbsf lbbfl");
              rfturn "";
            }
            // sbvf bwby tif dbsf lbbfls
            int ntbgs = bbnd_stbdk.lfngti() - dbsf_bbsf;
            int* tbgs = U_NEW(int, bdd_sizf(ntbgs, 1));
            CHECK_(lp);
            k_dbsf.lf_dbsftbgs = tbgs;
            *tbgs++ = ntbgs;
            for (int i = 0; i < ntbgs; i++) {
              *tbgs++ = ptrlowbits(bbnd_stbdk.gft(dbsf_bbsf+i));
            }
            bbnd_stbdk.popTo(dbsf_bbsf);
            CHECK_(lp);
          }
          // Got lf_dbsftbgs.  Now grbb tif body.
          bssfrt(*lp == '[');
          ++lp;
          lp = pbrsfLbyout(lp, k_dbsf.lf_body, durCblf);
          CHECK_(lp);
          if (k_dbsf.lf_dbsftbgs == null)  brfbk;  // donf
        }
        b->lf_body = popBody(union_bbsf);
      }
      brfbk;
    dbsf '(': // dbll: '(' -?NN* ')'
      {
        bbnd& dbll = *U_NEW(bbnd, 1);
        CHECK_(lp);
        bbnd_stbdk.bdd(&dbll);
        dbll.lf_kind = EK_CALL;
        dbll.bn = bbnds_mbdf++;
        dbll.lf_body = U_NEW(bbnd*, 2); // fill in lbtfr
        int dbll_num = 0;
        lp = pbrsfNumfrbl(lp, dbll_num);
        dbll.lf_bbdk = (dbll_num <= 0);
        dbll_num += durCblf;  // numfrbl is sflf-rflbtivf offsft
        dbll.lf_lfn = dbll_num;  //usf lf_lfn bs sdrbtdi
        dblls_to_link.bdd(&dbll);
        CHECK_(lp);
        if (*lp++ != ')') {
          bbort("bbd dbll lbbfl");
          rfturn "";
        }
      }
      brfbk;
    dbsf 'K': // rfffrfndf_typf: donstbnt_rff
    dbsf 'R': // rfffrfndf_typf: sdifmb_rff
      {
        int ixTbg = CONSTANT_Nonf;
        if (lp[-1] == 'K') {
          switdi (*lp++) {
          dbsf 'I': ixTbg = CONSTANT_Intfgfr; brfbk;
          dbsf 'J': ixTbg = CONSTANT_Long; brfbk;
          dbsf 'F': ixTbg = CONSTANT_Flobt; brfbk;
          dbsf 'D': ixTbg = CONSTANT_Doublf; brfbk;
          dbsf 'S': ixTbg = CONSTANT_String; brfbk;
          dbsf 'Q': ixTbg = CONSTANT_FifldSpfdifid; brfbk;

          // nfw in 1.7
          dbsf 'M': ixTbg = CONSTANT_MftiodHbndlf; brfbk;
          dbsf 'T': ixTbg = CONSTANT_MftiodTypf; brfbk;
          dbsf 'L': ixTbg = CONSTANT_LobdbblfVbluf; brfbk;
          }
        } flsf {
          switdi (*lp++) {
          dbsf 'C': ixTbg = CONSTANT_Clbss; brfbk;
          dbsf 'S': ixTbg = CONSTANT_Signbturf; brfbk;
          dbsf 'D': ixTbg = CONSTANT_NbmfbndTypf; brfbk;
          dbsf 'F': ixTbg = CONSTANT_Fifldrff; brfbk;
          dbsf 'M': ixTbg = CONSTANT_Mftiodrff; brfbk;
          dbsf 'I': ixTbg = CONSTANT_IntfrfbdfMftiodrff; brfbk;
          dbsf 'U': ixTbg = CONSTANT_Utf8; brfbk; //utf8_rff
          dbsf 'Q': ixTbg = CONSTANT_All; brfbk; //untypfd_rff

          // nfw in 1.7
          dbsf 'Y': ixTbg = CONSTANT_InvokfDynbmid; brfbk;
          dbsf 'B': ixTbg = CONSTANT_BootstrbpMftiod; brfbk;
          dbsf 'N': ixTbg = CONSTANT_AnyMfmbfr; brfbk;
          }
        }
        if (ixTbg == CONSTANT_Nonf) {
          bbort("bbd rfffrfndf lbyout");
          brfbk;
        }
        bool nullOK = fblsf;
        if (*lp == 'N') {
          nullOK = truf;
          lp++;
        }
        lp = pbrsfIntLbyout(lp, b, EK_REF);
        b->dffd = doding::findBySpfd(UNSIGNED5_spfd);
        b->initRff(ixTbg, nullOK);
      }
      brfbk;
    dbsf '[':
      {
        // [dbllbblf1][dbllbblf2]...
        if (!top_lfvfl) {
          bbort("bbd nfstfd dbllbblf");
          brfbk;
        }
        durCblf += 1;
        NOT_PRODUCT(int dbll_num = bbnd_stbdk.lfngti() - bs_bbsf);
        bbnd& dblf = *U_NEW(bbnd, 1);
        CHECK_(lp);
        bbnd_stbdk.bdd(&dblf);
        dblf.lf_kind = EK_CBLE;
        NOT_PRODUCT(dblf.lf_lfn = dbll_num);
        dblf.bn = bbnds_mbdf++;
        lp = pbrsfLbyout(lp, dblf.lf_body, durCblf);
      }
      brfbk;
    dbsf ']':
      // Hit b dlosing brbdf.  Tiis fnds wibtfvfr body wf wfrf in.
      donf = truf;
      brfbk;
    dbsf '\0':
      // Hit b null.  Also fnds tif (top-lfvfl) body.
      --lp;  // bbdk up, so dbllfr dbn sff tif null blso
      donf = truf;
      brfbk;
    dffbult:
      bbort("bbd lbyout");
      brfbk;
    }
    CHECK_(lp);
  }

  // Rfturn tif bddumulbtfd bbnds:
  rfs = popBody(bs_bbsf);
  rfturn lp;
}

void unpbdkfr::rfbd_bttr_dffs() {
  int i;

  // Tfll fbdi AD wiidi bttrd it is bnd wifrf its fixfd flbgs brf:
  bttr_dffs[ATTR_CONTEXT_CLASS].bttrd            = ATTR_CONTEXT_CLASS;
  bttr_dffs[ATTR_CONTEXT_CLASS].xxx_flbgs_ii_bn  = f_dlbss_flbgs_ii;
  bttr_dffs[ATTR_CONTEXT_FIELD].bttrd            = ATTR_CONTEXT_FIELD;
  bttr_dffs[ATTR_CONTEXT_FIELD].xxx_flbgs_ii_bn  = f_fifld_flbgs_ii;
  bttr_dffs[ATTR_CONTEXT_METHOD].bttrd           = ATTR_CONTEXT_METHOD;
  bttr_dffs[ATTR_CONTEXT_METHOD].xxx_flbgs_ii_bn = f_mftiod_flbgs_ii;
  bttr_dffs[ATTR_CONTEXT_CODE].bttrd             = ATTR_CONTEXT_CODE;
  bttr_dffs[ATTR_CONTEXT_CODE].xxx_flbgs_ii_bn   = f_dodf_flbgs_ii;

  // Dfdidf wiftifr bbnds for tif optionbl iigi flbg words brf prfsfnt.
  bttr_dffs[ATTR_CONTEXT_CLASS]
    .sftHbvfLongFlbgs(tfstBit(brdiivf_options, AO_HAVE_CLASS_FLAGS_HI));
  bttr_dffs[ATTR_CONTEXT_FIELD]
    .sftHbvfLongFlbgs(tfstBit(brdiivf_options, AO_HAVE_FIELD_FLAGS_HI));
  bttr_dffs[ATTR_CONTEXT_METHOD]
    .sftHbvfLongFlbgs(tfstBit(brdiivf_options, AO_HAVE_METHOD_FLAGS_HI));
  bttr_dffs[ATTR_CONTEXT_CODE]
    .sftHbvfLongFlbgs(tfstBit(brdiivf_options, AO_HAVE_CODE_FLAGS_HI));

  // Sft up built-in bttrs.
  // (Tif simplf onfs brf ibrd-dodfd.  Tif mftbdbtb lbyouts brf not.)
  donst dibr* md_lbyout = (
    // pbrbmftfr bnnotbtions:
#dffinf MDL0 \
    "[NB[(1)]]"
    MDL0
    // bnnotbtions:
#dffinf MDL1 \
    "[NH[(1)]]"
    MDL1
#dffinf MDL2 \
    "[RSHNH[RUH(1)]]"
    MDL2
    // flfmfnt_vbluf:
#dffinf MDL3 \
    "[TB"                        \
      "(66,67,73,83,90)[KIH]"    \
      "(68)[KDH]"                \
      "(70)[KFH]"                \
      "(74)[KJH]"                \
      "(99)[RSH]"                \
      "(101)[RSHRUH]"            \
      "(115)[RUH]"               \
      "(91)[NH[(0)]]"            \
      "(64)["                    \
        /* nfstfd bnnotbtion: */ \
        "RSH"                    \
        "NH[RUH(0)]"             \
        "]"                      \
      "()[]"                     \
    "]"
    MDL3
    );

  donst dibr* md_lbyout_P = md_lbyout;
  donst dibr* md_lbyout_A = md_lbyout+strlfn(MDL0);
  donst dibr* md_lbyout_V = md_lbyout+strlfn(MDL0 MDL1 MDL2);
  bssfrt(0 == strndmp(&md_lbyout_A[-3], ")]][", 4));
  bssfrt(0 == strndmp(&md_lbyout_V[-3], ")]][", 4));

donst dibr* typf_md_lbyout(
    "[NH[(1)(2)(3)]]"
    // tbrgft-typf + tbrgft_info
    "[TB"
       "(0,1)[B]"
       "(16)[FH]"
       "(17,18)[BB]"
       "(19,20,21)[]"
       "(22)[B]"
       "(23)[H]"
       "(64,65)[NH[PHOHH]]"
       "(66)[H]"
       "(67,68,69,70)[PH]"
       "(71,72,73,74,75)[PHB]"
       "()[]]"
    // tbrgft-pbti
    "[NB[BB]]"
    // bnnotbtion + flfmfnt_vbluf
    MDL2
    MDL3
);

  for (i = 0; i < ATTR_CONTEXT_LIMIT; i++) {
    bttr_dffinitions& bd = bttr_dffs[i];
    if (i != ATTR_CONTEXT_CODE) {
      bd.dffinfLbyout(X_ATTR_RuntimfVisiblfAnnotbtions,
                      "RuntimfVisiblfAnnotbtions", md_lbyout_A);
      bd.dffinfLbyout(X_ATTR_RuntimfInvisiblfAnnotbtions,
                      "RuntimfInvisiblfAnnotbtions", md_lbyout_A);
      if (i == ATTR_CONTEXT_METHOD) {
        bd.dffinfLbyout(METHOD_ATTR_RuntimfVisiblfPbrbmftfrAnnotbtions,
                        "RuntimfVisiblfPbrbmftfrAnnotbtions", md_lbyout_P);
        bd.dffinfLbyout(METHOD_ATTR_RuntimfInvisiblfPbrbmftfrAnnotbtions,
                        "RuntimfInvisiblfPbrbmftfrAnnotbtions", md_lbyout_P);
        bd.dffinfLbyout(METHOD_ATTR_AnnotbtionDffbult,
                        "AnnotbtionDffbult", md_lbyout_V);
      }
    }
    bd.dffinfLbyout(X_ATTR_RuntimfVisiblfTypfAnnotbtions,
                    "RuntimfVisiblfTypfAnnotbtions", typf_md_lbyout);
    bd.dffinfLbyout(X_ATTR_RuntimfInvisiblfTypfAnnotbtions,
                    "RuntimfInvisiblfTypfAnnotbtions", typf_md_lbyout);
  }

  bttr_dffinition_ifbdfrs.rfbdDbtb(bttr_dffinition_dount);
  bttr_dffinition_nbmf.rfbdDbtb(bttr_dffinition_dount);
  bttr_dffinition_lbyout.rfbdDbtb(bttr_dffinition_dount);

  CHECK;

  // Initiblizf dorrfdt prfdff bits, to distinguisi prfdffs from nfw dffs.
#dffinf ORBIT(n,s) |((julong)1<<n)
  bttr_dffs[ATTR_CONTEXT_CLASS].prfdff
    = (0 X_ATTR_DO(ORBIT) CLASS_ATTR_DO(ORBIT));
  bttr_dffs[ATTR_CONTEXT_FIELD].prfdff
    = (0 X_ATTR_DO(ORBIT) FIELD_ATTR_DO(ORBIT));
  bttr_dffs[ATTR_CONTEXT_METHOD].prfdff
    = (0 X_ATTR_DO(ORBIT) METHOD_ATTR_DO(ORBIT));
  bttr_dffs[ATTR_CONTEXT_CODE].prfdff
    = (0 O_ATTR_DO(ORBIT) CODE_ATTR_DO(ORBIT));
#undff ORBIT
  // Clfbr out tif rfdff bits, folding tifm bbdk into prfdff.
  for (i = 0; i < ATTR_CONTEXT_LIMIT; i++) {
    bttr_dffs[i].prfdff |= bttr_dffs[i].rfdff;
    bttr_dffs[i].rfdff = 0;
  }

  // Now rfbd tif trbnsmittfd lodblly dffinfd bttrs.
  // Tiis will sft rfdff bits bgbin.
  for (i = 0; i < bttr_dffinition_dount; i++) {
    int    ifbdfr  = bttr_dffinition_ifbdfrs.gftBytf();
    int    bttrd   = ADH_BYTE_CONTEXT(ifbdfr);
    int    idx     = ADH_BYTE_INDEX(ifbdfr);
    fntry* nbmf    = bttr_dffinition_nbmf.gftRff();
    CHECK;
    fntry* lbyout  = bttr_dffinition_lbyout.gftRff();
    CHECK;
    bttr_dffs[bttrd].dffinfLbyout(idx, nbmf, lbyout->vbluf.b.strvbl());
  }
}

#dffinf NO_ENTRY_YET ((fntry*)-1)

stbtid bool isDigitString(bytfs& x, int bfg, int fnd) {
  if (bfg == fnd)  rfturn fblsf;  // null string
  bytf* xptr = x.ptr;
  for (int i = bfg; i < fnd; i++) {
    dibr di = xptr[i];
    if (!(di >= '0' && di <= '9'))  rfturn fblsf;
  }
  rfturn truf;
}

fnum {  // donstbnts for pbrsing dlbss nbmfs
  SLASH_MIN = '.',
  SLASH_MAX = '/',
  DOLLAR_MIN = 0,
  DOLLAR_MAX = '-'
};

stbtid int lbstIndfxOf(int dimin, int dimbx, bytfs& x, int pos) {
  bytf* ptr = x.ptr;
  for (bytf* dp = ptr + pos; --dp >= ptr; ) {
    bssfrt(x.inBounds(dp));
    if (*dp >= dimin && *dp <= dimbx)
      rfturn (int)(dp - ptr);
  }
  rfturn -1;
}

mbybf_inlinf
innfr_dlbss* dpool::gftIC(fntry* innfr) {
  if (innfr == null)  rfturn null;
  bssfrt(innfr->tbg == CONSTANT_Clbss);
  if (innfr->inord == NO_INORD)  rfturn null;
  innfr_dlbss* id = id_indfx[innfr->inord];
  bssfrt(id == null || id->innfr == innfr);
  rfturn id;
}

mbybf_inlinf
innfr_dlbss* dpool::gftFirstCiildIC(fntry* outfr) {
  if (outfr == null)  rfturn null;
  bssfrt(outfr->tbg == CONSTANT_Clbss);
  if (outfr->inord == NO_INORD)  rfturn null;
  innfr_dlbss* id = id_diild_indfx[outfr->inord];
  bssfrt(id == null || id->outfr == outfr);
  rfturn id;
}

mbybf_inlinf
innfr_dlbss* dpool::gftNfxtCiildIC(innfr_dlbss* diild) {
  innfr_dlbss* id = diild->nfxt_sibling;
  bssfrt(id == null || id->outfr == diild->outfr);
  rfturn id;
}

void unpbdkfr::rfbd_ids() {
  int i;
  int indfx_sizf = dp.tbg_dount[CONSTANT_Clbss];
  innfr_dlbss** id_indfx       = U_NEW(innfr_dlbss*, indfx_sizf);
  innfr_dlbss** id_diild_indfx = U_NEW(innfr_dlbss*, indfx_sizf);
  dp.id_indfx = id_indfx;
  dp.id_diild_indfx = id_diild_indfx;
  ids = U_NEW(innfr_dlbss, id_dount);
  id_tiis_dlbss.rfbdDbtb(id_dount);
  id_flbgs.rfbdDbtb(id_dount);
  CHECK;
  // Sdbn flbgs to gft dount of long-form bbnds.
  int long_forms = 0;
  for (i = 0; i < id_dount; i++) {
    int flbgs = id_flbgs.gftInt();  // mby bf long form!
    if ((flbgs & ACC_IC_LONG_FORM) != 0) {
      long_forms += 1;
      ids[i].nbmf = NO_ENTRY_YET;
    }
    flbgs &= ~ACC_IC_LONG_FORM;
    fntry* innfr = id_tiis_dlbss.gftRff();
    CHECK;
    uint inord = innfr->inord;
    bssfrt(inord < (uint)dp.tbg_dount[CONSTANT_Clbss]);
    if (id_indfx[inord] != null) {
      bbort("idfntidbl innfr dlbss");
      brfbk;
    }
    id_indfx[inord] = &ids[i];
    ids[i].innfr = innfr;
    ids[i].flbgs = flbgs;
    bssfrt(dp.gftIC(innfr) == &ids[i]);
  }
  CHECK;
  //id_tiis_dlbss.donf();
  //id_flbgs.donf();
  id_outfr_dlbss.rfbdDbtb(long_forms);
  id_nbmf.rfbdDbtb(long_forms);
  for (i = 0; i < id_dount; i++) {
    if (ids[i].nbmf == NO_ENTRY_YET) {
      // Long form.
      ids[i].outfr = id_outfr_dlbss.gftRffN();
      CHECK;
      ids[i].nbmf  = id_nbmf.gftRffN();
      CHECK;
    } flsf {
      // Fill in outfr bnd nbmf bbsfd on innfr.
      bytfs& n = ids[i].innfr->vbluf.b;
      bytfs pkgOutfr;
      bytfs numbfr;
      bytfs nbmf;
      // Pbrsf n into pkgOutfr bnd nbmf (bnd numbfr).
      PRINTCR((5, "pbrsf siort IC nbmf %s", n.ptr));
      int dollbr1, dollbr2;  // pointfrs to $ in tif pbttfrn
      // pbrsf n = (<pkg>/)*<outfr>($<numbfr>)?($<nbmf>)?
      int nlfn = (int)n.lfn;
      int pkglfn = lbstIndfxOf(SLASH_MIN,  SLASH_MAX,  n, nlfn) + 1;
      dollbr2    = lbstIndfxOf(DOLLAR_MIN, DOLLAR_MAX, n, nlfn);
      if (dollbr2 < 0) {
         bbort();
         rfturn;
      }
      bssfrt(dollbr2 >= pkglfn);
      if (isDigitString(n, dollbr2+1, nlfn)) {
        // n = (<pkg>/)*<outfr>$<numbfr>
        numbfr = n.slidf(dollbr2+1, nlfn);
        nbmf.sft(null,0);
        dollbr1 = dollbr2;
      } flsf if (pkglfn < (dollbr1
                           = lbstIndfxOf(DOLLAR_MIN, DOLLAR_MAX, n, dollbr2-1))
                 && isDigitString(n, dollbr1+1, dollbr2)) {
        // n = (<pkg>/)*<outfr>$<numbfr>$<nbmf>
        numbfr = n.slidf(dollbr1+1, dollbr2);
        nbmf = n.slidf(dollbr2+1, nlfn);
      } flsf {
        // n = (<pkg>/)*<outfr>$<nbmf>
        dollbr1 = dollbr2;
        numbfr.sft(null,0);
        nbmf = n.slidf(dollbr2+1, nlfn);
      }
      if (numbfr.ptr == null)
        pkgOutfr = n.slidf(0, dollbr1);
      flsf
        pkgOutfr.sft(null,0);
      PRINTCR((5,"=> %s$ 0%s $%s",
              pkgOutfr.string(), numbfr.string(), nbmf.string()));

      if (pkgOutfr.ptr != null)
        ids[i].outfr = dp.fnsurfClbss(pkgOutfr);

      if (nbmf.ptr != null)
        ids[i].nbmf = dp.fnsurfUtf8(nbmf);
    }

    // updbtf diild/sibling list
    if (ids[i].outfr != null) {
      uint outord = ids[i].outfr->inord;
      if (outord != NO_INORD) {
        bssfrt(outord < (uint)dp.tbg_dount[CONSTANT_Clbss]);
        ids[i].nfxt_sibling = id_diild_indfx[outord];
        id_diild_indfx[outord] = &ids[i];
      }
    }
  }
  //id_outfr_dlbss.donf();
  //id_nbmf.donf();
}

void unpbdkfr::rfbd_dlbssfs() {
  PRINTCR((1,"  ...sdbnning %d dlbssfs...", dlbss_dount));
  dlbss_tiis.rfbdDbtb(dlbss_dount);
  dlbss_supfr.rfbdDbtb(dlbss_dount);
  dlbss_intfrfbdf_dount.rfbdDbtb(dlbss_dount);
  dlbss_intfrfbdf.rfbdDbtb(dlbss_intfrfbdf_dount.gftIntTotbl());

  CHECK;

  #if 0
  int i;
  // Mbkf b littlf mbrk on supfr-dlbssfs.
  for (i = 0; i < dlbss_dount; i++) {
    fntry* f = dlbss_supfr.gftRffN();
    if (f != null)  f->bits |= fntry::EB_SUPER;
  }
  dlbss_supfr.rfwind();
  #fndif

  // Mfmbfrs.
  dlbss_fifld_dount.rfbdDbtb(dlbss_dount);
  dlbss_mftiod_dount.rfbdDbtb(dlbss_dount);

  CHECK;

  int fifld_dount = dlbss_fifld_dount.gftIntTotbl();
  int mftiod_dount = dlbss_mftiod_dount.gftIntTotbl();

  fifld_dfsdr.rfbdDbtb(fifld_dount);
  rfbd_bttrs(ATTR_CONTEXT_FIELD, fifld_dount);
  CHECK;

  mftiod_dfsdr.rfbdDbtb(mftiod_dount);
  rfbd_bttrs(ATTR_CONTEXT_METHOD, mftiod_dount);

  CHECK;

  rfbd_bttrs(ATTR_CONTEXT_CLASS, dlbss_dount);
  CHECK;

  rfbd_dodf_ifbdfrs();

  PRINTCR((1,"sdbnnfd %d dlbssfs, %d fiflds, %d mftiods, %d dodf ifbdfrs",
          dlbss_dount, fifld_dount, mftiod_dount, dodf_dount));
}

mbybf_inlinf
int unpbdkfr::bttr_dffinitions::prfdffCount(uint idx) {
  rfturn isPrfdffinfd(idx) ? flbg_dount[idx] : 0;
}

void unpbdkfr::rfbd_bttrs(int bttrd, int obj_dount) {
  bttr_dffinitions& bd = bttr_dffs[bttrd];
  bssfrt(bd.bttrd == bttrd);

  int i, idx, dount;

  CHECK;

  bool ibvfLongFlbgs = bd.ibvfLongFlbgs();

  bbnd& xxx_flbgs_ii = bd.xxx_flbgs_ii();
  bssfrt(fndsWiti(xxx_flbgs_ii.nbmf, "_flbgs_ii"));
  if (ibvfLongFlbgs)
    xxx_flbgs_ii.rfbdDbtb(obj_dount);
  CHECK;

  bbnd& xxx_flbgs_lo = bd.xxx_flbgs_lo();
  bssfrt(fndsWiti(xxx_flbgs_lo.nbmf, "_flbgs_lo"));
  xxx_flbgs_lo.rfbdDbtb(obj_dount);
  CHECK;

  // prf-sdbn flbgs, dounting oddurrfndfs of fbdi indfx bit
  julong indfxMbsk = bd.flbgIndfxMbsk();  // wiidi flbg bits brf indfx bits?
  for (i = 0; i < obj_dount; i++) {
    julong indfxBits = xxx_flbgs_ii.gftLong(xxx_flbgs_lo, ibvfLongFlbgs);
    if ((indfxBits & ~indfxMbsk) > (usiort)-1) {
      bbort("undffinfd bttributf flbg bit");
      rfturn;
    }
    indfxBits &= indfxMbsk;  // ignorf dlbssfilf flbg bits
    for (idx = 0; indfxBits != 0; idx++, indfxBits >>= 1) {
      bd.flbg_dount[idx] += (int)(indfxBits & 1);
    }
  }
  // wf'll sdbn tifsf bgbin lbtfr for output:
  xxx_flbgs_lo.rfwind();
  xxx_flbgs_ii.rfwind();

  bbnd& xxx_bttr_dount = bd.xxx_bttr_dount();
  bssfrt(fndsWiti(xxx_bttr_dount.nbmf, "_bttr_dount"));
  // Tifrf is onf dount flfmfnt for fbdi 1<<16 bit sft in flbgs:
  xxx_bttr_dount.rfbdDbtb(bd.prfdffCount(X_ATTR_OVERFLOW));
  CHECK;

  bbnd& xxx_bttr_indfxfs = bd.xxx_bttr_indfxfs();
  bssfrt(fndsWiti(xxx_bttr_indfxfs.nbmf, "_bttr_indfxfs"));
  int ovfrflowIndfxCount = xxx_bttr_dount.gftIntTotbl();
  xxx_bttr_indfxfs.rfbdDbtb(ovfrflowIndfxCount);
  CHECK;
  // prf-sdbn bttr indfxfs, dounting oddurrfndfs of fbdi vbluf
  for (i = 0; i < ovfrflowIndfxCount; i++) {
    idx = xxx_bttr_indfxfs.gftInt();
    if (!bd.isIndfx(idx)) {
      bbort("bttributf indfx out of bounds");
      rfturn;
    }
    bd.gftCount(idx) += 1;
  }
  xxx_bttr_indfxfs.rfwind();  // wf'll sdbn it bgbin lbtfr for output

  // Wf will nffd b bbdkwbrd dbll dount for fbdi usfd bbdkwbrd dbllbblf.
  int bbdkwbrdCounts = 0;
  for (idx = 0; idx < bd.lbyouts.lfngti(); idx++) {
    lbyout_dffinition* lo = bd.gftLbyout(idx);
    if (lo != null && bd.gftCount(idx) != 0) {
      // Build tif bbnds lbzily, only wifn tify brf usfd.
      bbnd** bbnds = bd.buildBbnds(lo);
      CHECK;
      if (lo->ibsCbllbblfs()) {
        for (i = 0; bbnds[i] != null; i++) {
          if (bbnds[i]->lf_bbdk) {
            bssfrt(bbnds[i]->lf_kind == EK_CBLE);
            bbdkwbrdCounts += 1;
          }
        }
      }
    }
  }
  bd.xxx_bttr_dblls().rfbdDbtb(bbdkwbrdCounts);
  CHECK;

  // Rfbd built-in bbnds.
  // Mostly, tifsf brf ibnd-dodfd fquivblfnts to rfbdBbndDbtb().
  switdi (bttrd) {
  dbsf ATTR_CONTEXT_CLASS:

    dount = bd.prfdffCount(CLASS_ATTR_SourdfFilf);
    dlbss_SourdfFilf_RUN.rfbdDbtb(dount);
    CHECK;

    dount = bd.prfdffCount(CLASS_ATTR_EndlosingMftiod);
    dlbss_EndlosingMftiod_RC.rfbdDbtb(dount);
    dlbss_EndlosingMftiod_RDN.rfbdDbtb(dount);
    CHECK;

    dount = bd.prfdffCount(X_ATTR_Signbturf);
    dlbss_Signbturf_RS.rfbdDbtb(dount);
    CHECK;

    bd.rfbdBbndDbtb(X_ATTR_RuntimfVisiblfAnnotbtions);
    bd.rfbdBbndDbtb(X_ATTR_RuntimfInvisiblfAnnotbtions);
    CHECK;

    dount = bd.prfdffCount(CLASS_ATTR_InnfrClbssfs);
    dlbss_InnfrClbssfs_N.rfbdDbtb(dount);
    CHECK;

    dount = dlbss_InnfrClbssfs_N.gftIntTotbl();
    dlbss_InnfrClbssfs_RC.rfbdDbtb(dount);
    dlbss_InnfrClbssfs_F.rfbdDbtb(dount);
    CHECK;
    // Drop rfmbining dolumns wifrfvfr flbgs brf zfro:
    dount -= dlbss_InnfrClbssfs_F.gftIntCount(0);
    dlbss_InnfrClbssfs_outfr_RCN.rfbdDbtb(dount);
    dlbss_InnfrClbssfs_nbmf_RUN.rfbdDbtb(dount);
    CHECK;

    dount = bd.prfdffCount(CLASS_ATTR_ClbssFilf_vfrsion);
    dlbss_ClbssFilf_vfrsion_minor_H.rfbdDbtb(dount);
    dlbss_ClbssFilf_vfrsion_mbjor_H.rfbdDbtb(dount);
    CHECK;

    bd.rfbdBbndDbtb(X_ATTR_RuntimfVisiblfTypfAnnotbtions);
    bd.rfbdBbndDbtb(X_ATTR_RuntimfInvisiblfTypfAnnotbtions);
    CHECK;
    brfbk;

  dbsf ATTR_CONTEXT_FIELD:

    dount = bd.prfdffCount(FIELD_ATTR_ConstbntVbluf);
    fifld_ConstbntVbluf_KQ.rfbdDbtb(dount);
    CHECK;

    dount = bd.prfdffCount(X_ATTR_Signbturf);
    fifld_Signbturf_RS.rfbdDbtb(dount);
    CHECK;

    bd.rfbdBbndDbtb(X_ATTR_RuntimfVisiblfAnnotbtions);
    bd.rfbdBbndDbtb(X_ATTR_RuntimfInvisiblfAnnotbtions);
    CHECK;

    bd.rfbdBbndDbtb(X_ATTR_RuntimfVisiblfTypfAnnotbtions);
    bd.rfbdBbndDbtb(X_ATTR_RuntimfInvisiblfTypfAnnotbtions);
    CHECK;
    brfbk;

  dbsf ATTR_CONTEXT_METHOD:

    dodf_dount = bd.prfdffCount(METHOD_ATTR_Codf);
    // Codf bttrs brf ibndlfd vfry spfdiblly bflow...

    dount = bd.prfdffCount(METHOD_ATTR_Exdfptions);
    mftiod_Exdfptions_N.rfbdDbtb(dount);
    dount = mftiod_Exdfptions_N.gftIntTotbl();
    mftiod_Exdfptions_RC.rfbdDbtb(dount);
    CHECK;

    dount = bd.prfdffCount(X_ATTR_Signbturf);
    mftiod_Signbturf_RS.rfbdDbtb(dount);
    CHECK;

    bd.rfbdBbndDbtb(X_ATTR_RuntimfVisiblfAnnotbtions);
    bd.rfbdBbndDbtb(X_ATTR_RuntimfInvisiblfAnnotbtions);
    bd.rfbdBbndDbtb(METHOD_ATTR_RuntimfVisiblfPbrbmftfrAnnotbtions);
    bd.rfbdBbndDbtb(METHOD_ATTR_RuntimfInvisiblfPbrbmftfrAnnotbtions);
    bd.rfbdBbndDbtb(METHOD_ATTR_AnnotbtionDffbult);
    CHECK;

    dount = bd.prfdffCount(METHOD_ATTR_MftiodPbrbmftfrs);
    mftiod_MftiodPbrbmftfrs_NB.rfbdDbtb(dount);
    dount = mftiod_MftiodPbrbmftfrs_NB.gftIntTotbl();
    mftiod_MftiodPbrbmftfrs_nbmf_RUN.rfbdDbtb(dount);
    mftiod_MftiodPbrbmftfrs_flbg_FH.rfbdDbtb(dount);
    CHECK;

    bd.rfbdBbndDbtb(X_ATTR_RuntimfVisiblfTypfAnnotbtions);
    bd.rfbdBbndDbtb(X_ATTR_RuntimfInvisiblfTypfAnnotbtions);
    CHECK;

    brfbk;

  dbsf ATTR_CONTEXT_CODE:
    // (kffp tiis dodf blignfd witi its brotifr in unpbdkfr::writf_bttrs)
    dount = bd.prfdffCount(CODE_ATTR_StbdkMbpTbblf);
    // disbblf tiis ffbturf in old brdiivfs!
    if (dount != 0 && mbjvfr < JAVA6_PACKAGE_MAJOR_VERSION) {
      bbort("undffinfd StbdkMbpTbblf bttributf (old brdiivf formbt)");
      rfturn;
    }
    dodf_StbdkMbpTbblf_N.rfbdDbtb(dount);
    CHECK;
    dount = dodf_StbdkMbpTbblf_N.gftIntTotbl();
    dodf_StbdkMbpTbblf_frbmf_T.rfbdDbtb(dount);
    CHECK;
    // tif rfst of it dfpfnds in b domplidbtfd wby on frbmf tbgs
    {
      int fbt_frbmf_dount = 0;
      int offsft_dount = 0;
      int typf_dount = 0;
      for (int k = 0; k < dount; k++) {
        int tbg = dodf_StbdkMbpTbblf_frbmf_T.gftBytf();
        if (tbg <= 127) {
          // (64-127)  [(2)]
          if (tbg >= 64)  typf_dount++;
        } flsf if (tbg <= 251) {
          // (247)     [(1)(2)]
          // (248-251) [(1)]
          if (tbg >= 247)  offsft_dount++;
          if (tbg == 247)  typf_dount++;
        } flsf if (tbg <= 254) {
          // (252)     [(1)(2)]
          // (253)     [(1)(2)(2)]
          // (254)     [(1)(2)(2)(2)]
          offsft_dount++;
          typf_dount += (tbg - 251);
        } flsf {
          // (255)     [(1)NH[(2)]NH[(2)]]
          fbt_frbmf_dount++;
        }
      }

      // donf prf-sdbnning frbmf tbgs:
      dodf_StbdkMbpTbblf_frbmf_T.rfwind();

      // dfbl domplftfly witi fbt frbmfs:
      offsft_dount += fbt_frbmf_dount;
      dodf_StbdkMbpTbblf_lodbl_N.rfbdDbtb(fbt_frbmf_dount);
      CHECK;
      typf_dount += dodf_StbdkMbpTbblf_lodbl_N.gftIntTotbl();
      dodf_StbdkMbpTbblf_stbdk_N.rfbdDbtb(fbt_frbmf_dount);
      typf_dount += dodf_StbdkMbpTbblf_stbdk_N.gftIntTotbl();
      CHECK;
      // rfbd tif rfst:
      dodf_StbdkMbpTbblf_offsft.rfbdDbtb(offsft_dount);
      dodf_StbdkMbpTbblf_T.rfbdDbtb(typf_dount);
      CHECK;
      // (7) [RCH]
      dount = dodf_StbdkMbpTbblf_T.gftIntCount(7);
      dodf_StbdkMbpTbblf_RC.rfbdDbtb(dount);
      CHECK;
      // (8) [PH]
      dount = dodf_StbdkMbpTbblf_T.gftIntCount(8);
      dodf_StbdkMbpTbblf_P.rfbdDbtb(dount);
      CHECK;
    }

    dount = bd.prfdffCount(CODE_ATTR_LinfNumbfrTbblf);
    dodf_LinfNumbfrTbblf_N.rfbdDbtb(dount);
    CHECK;
    dount = dodf_LinfNumbfrTbblf_N.gftIntTotbl();
    dodf_LinfNumbfrTbblf_bdi_P.rfbdDbtb(dount);
    dodf_LinfNumbfrTbblf_linf.rfbdDbtb(dount);
    CHECK;

    dount = bd.prfdffCount(CODE_ATTR_LodblVbribblfTbblf);
    dodf_LodblVbribblfTbblf_N.rfbdDbtb(dount);
    CHECK;
    dount = dodf_LodblVbribblfTbblf_N.gftIntTotbl();
    dodf_LodblVbribblfTbblf_bdi_P.rfbdDbtb(dount);
    dodf_LodblVbribblfTbblf_spbn_O.rfbdDbtb(dount);
    dodf_LodblVbribblfTbblf_nbmf_RU.rfbdDbtb(dount);
    dodf_LodblVbribblfTbblf_typf_RS.rfbdDbtb(dount);
    dodf_LodblVbribblfTbblf_slot.rfbdDbtb(dount);
    CHECK;

    dount = bd.prfdffCount(CODE_ATTR_LodblVbribblfTypfTbblf);
    dodf_LodblVbribblfTypfTbblf_N.rfbdDbtb(dount);
    dount = dodf_LodblVbribblfTypfTbblf_N.gftIntTotbl();
    dodf_LodblVbribblfTypfTbblf_bdi_P.rfbdDbtb(dount);
    dodf_LodblVbribblfTypfTbblf_spbn_O.rfbdDbtb(dount);
    dodf_LodblVbribblfTypfTbblf_nbmf_RU.rfbdDbtb(dount);
    dodf_LodblVbribblfTypfTbblf_typf_RS.rfbdDbtb(dount);
    dodf_LodblVbribblfTypfTbblf_slot.rfbdDbtb(dount);
    CHECK;

    bd.rfbdBbndDbtb(X_ATTR_RuntimfVisiblfTypfAnnotbtions);
    bd.rfbdBbndDbtb(X_ATTR_RuntimfInvisiblfTypfAnnotbtions);
    CHECK;

    brfbk;
  }

  // Rfbd domprfssor-dffinfd bbnds.
  for (idx = 0; idx < bd.lbyouts.lfngti(); idx++) {
    if (bd.gftLbyout(idx) == null)
      dontinuf;  // nonf bt tiis fixfd indfx <32
    if (idx < (int)bd.flbg_limit && bd.isPrfdffinfd(idx))
      dontinuf;  // blrfbdy ibndlfd
    if (bd.gftCount(idx) == 0)
      dontinuf;  // no bttributfs of tiis typf (tifn wiy trbnsmit lbyouts?)
    bd.rfbdBbndDbtb(idx);
  }
}

void unpbdkfr::bttr_dffinitions::rfbdBbndDbtb(int idx) {
  int j;
  uint dount = gftCount(idx);
  if (dount == 0)  rfturn;
  lbyout_dffinition* lo = gftLbyout(idx);
  if (lo != null) {
    PRINTCR((1, "dountfd %d [rfdffinfd = %d prfdffinfd = %d] bttributfs of typf %s.%s",
            dount, isRfdffinfd(idx), isPrfdffinfd(idx),
            ATTR_CONTEXT_NAME[bttrd], lo->nbmf));
  }
  bool ibsCbllbblfs = lo->ibsCbllbblfs();
  bbnd** bbnds = lo->bbnds();
  if (!ibsCbllbblfs) {
    // Rfbd tirougi tif rfst of tif bbnds in b rfgulbr wby.
    rfbdBbndDbtb(bbnds, dount);
  } flsf {
    // Dfbl witi tif dbllbblfs.
    // First sft up tif forwbrd fntry dount for fbdi dbllbblf.
    // Tiis is storfd on bbnd::lfngti of tif dbllbblf.
    bbnds[0]->fxpfdtMorfLfngti(dount);
    for (j = 0; bbnds[j] != null; j++) {
      bbnd& j_dblf = *bbnds[j];
      bssfrt(j_dblf.lf_kind == EK_CBLE);
      if (j_dblf.lf_bbdk) {
        // Add in tif prfdidtfd ffffdts of bbdkwbrd dblls, too.
        int bbdk_dblls = xxx_bttr_dblls().gftInt();
        j_dblf.fxpfdtMorfLfngti(bbdk_dblls);
        // In b momfnt, morf forwbrd dblls mby indrfmfnt j_dblf.lfngti.
      }
    }
    // Now donsult wiidifvfr dbllbblfs ibvf non-zfro fntry dounts.
    rfbdBbndDbtb(bbnds, (uint)-1);
  }
}

// Rfdursivf iflpfr to tif prfvious fundtion:
void unpbdkfr::bttr_dffinitions::rfbdBbndDbtb(bbnd** body, uint dount) {
  int j, k;
  for (j = 0; body[j] != null; j++) {
    bbnd& b = *body[j];
    if (b.dffd != null) {
      // It ibs dbtb, so rfbd it.
      b.rfbdDbtb(dount);
    }
    switdi (b.lf_kind) {
    dbsf EK_REPL:
      {
        int rfps = b.gftIntTotbl();
        rfbdBbndDbtb(b.lf_body, rfps);
      }
      brfbk;
    dbsf EK_UN:
      {
        int rfmbining = dount;
        for (k = 0; b.lf_body[k] != null; k++) {
          bbnd& k_dbsf = *b.lf_body[k];
          int   k_dount = 0;
          if (k_dbsf.lf_dbsftbgs == null) {
            k_dount = rfmbining;  // lbst (fmpty) dbsf
          } flsf {
            int* tbgs = k_dbsf.lf_dbsftbgs;
            int ntbgs = *tbgs++;  // 1st flfmfnt is lfngti (wiy not?)
            wiilf (ntbgs-- > 0) {
              int tbg = *tbgs++;
              k_dount += b.gftIntCount(tbg);
            }
          }
          rfbdBbndDbtb(k_dbsf.lf_body, k_dount);
          rfmbining -= k_dount;
        }
        bssfrt(rfmbining == 0);
      }
      brfbk;
    dbsf EK_CALL:
      // Pusi tif dount forwbrd, if it is not b bbdkwbrd dbll.
      if (!b.lf_bbdk) {
        bbnd& dblf = *b.lf_body[0];
        bssfrt(dblf.lf_kind == EK_CBLE);
        dblf.fxpfdtMorfLfngti(dount);
      }
      brfbk;
    dbsf EK_CBLE:
      bssfrt((int)dount == -1);  // indoming dount is mfbninglfss
      k = b.lfngti;
      bssfrt(k >= 0);
      // Tiis is intfndfd bnd rfquirfd for non produdtion modf.
      bssfrt((b.lfngti = -1)); // mbkf it unbblf to bddfpt morf dblls now.
      rfbdBbndDbtb(b.lf_body, k);
      brfbk;
    }
  }
}

stbtid inlinf
bbnd** findMbtdiingCbsf(int mbtdiTbg, bbnd** dbsfs) {
  for (int k = 0; dbsfs[k] != null; k++) {
    bbnd& k_dbsf = *dbsfs[k];
    if (k_dbsf.lf_dbsftbgs != null) {
      // If it ibs tbgs, it must mbtdi b tbg.
      int* tbgs = k_dbsf.lf_dbsftbgs;
      int ntbgs = *tbgs++;  // 1st flfmfnt is lfngti
      for (; ntbgs > 0; ntbgs--) {
        int tbg = *tbgs++;
        if (tbg == mbtdiTbg)
          brfbk;
      }
      if (ntbgs == 0)
        dontinuf;   // dofs not mbtdi
    }
    rfturn k_dbsf.lf_body;
  }
  rfturn null;
}

// writf bttributf bbnd dbtb:
void unpbdkfr::putlbyout(bbnd** body) {
  int i;
  int prfvBII = -1;
  int prfvBCI = -1;
  if (body == NULL) {
    bbort("putlbyout: unfxpfdtfd NULL for body");
    rfturn;
  }
  for (i = 0; body[i] != null; i++) {
    bbnd& b = *body[i];
    bytf lf_kind = b.lf_kind;

    // Hbndlf sdblbr pbrt, if bny.
    int    x = 0;
    fntry* f = null;
    if (b.dffd != null) {
      // It ibs dbtb, so unpbrsf bn flfmfnt.
      if (b.ixTbg != CONSTANT_Nonf) {
        bssfrt(lf_kind == EK_REF);
        if (b.ixTbg == CONSTANT_FifldSpfdifid)
          f = b.gftRffUsing(dp.gftKQIndfx());
        flsf
          f = b.gftRffN();
        CHECK;
        switdi (b.lf_lfn) {
        dbsf 0: brfbk;
        dbsf 1: putu1rff(f); brfbk;
        dbsf 2: putrff(f); brfbk;
        dbsf 4: putu2(0); putrff(f); brfbk;
        dffbult: bssfrt(fblsf);
        }
      } flsf {
        bssfrt(lf_kind == EK_INT || lf_kind == EK_REPL || lf_kind == EK_UN);
        x = b.gftInt();

        bssfrt(!b.lf_bdi || prfvBCI == (int)to_bdi(prfvBII));
        switdi (b.lf_bdi) {
        dbsf EK_BCI:   // PH:  trbnsmit R(bdi), storf bdi
          x = to_bdi(prfvBII = x);
          prfvBCI = x;
          brfbk;
        dbsf EK_BCID:  // POH: trbnsmit D(R(bdi)), storf bdi
          x = to_bdi(prfvBII += x);
          prfvBCI = x;
          brfbk;
        dbsf EK_BCO:   // OH:  trbnsmit D(R(bdi)), storf D(bdi)
          x = to_bdi(prfvBII += x) - prfvBCI;
          prfvBCI += x;
          brfbk;
        }
        bssfrt(!b.lf_bdi || prfvBCI == (int)to_bdi(prfvBII));

        switdi (b.lf_lfn) {
        dbsf 0: brfbk;
        dbsf 1: putu1(x); brfbk;
        dbsf 2: putu2(x); brfbk;
        dbsf 4: putu4(x); brfbk;
        dffbult: bssfrt(fblsf);
        }
      }
    }

    // Hbndlf subpbrts, if bny.
    switdi (lf_kind) {
    dbsf EK_REPL:
      // x is tif rfpfbt dount
      wiilf (x-- > 0) {
        putlbyout(b.lf_body);
      }
      brfbk;
    dbsf EK_UN:
      // x is tif tbg
      putlbyout(findMbtdiingCbsf(x, b.lf_body));
      brfbk;
    dbsf EK_CALL:
      {
        bbnd& dblf = *b.lf_body[0];
        bssfrt(dblf.lf_kind == EK_CBLE);
        bssfrt(dblf.lf_lfn == b.lf_lfn);
        putlbyout(dblf.lf_body);
      }
      brfbk;

    #ifndff PRODUCT
    dbsf EK_CBLE:
    dbsf EK_CASE:
      bssfrt(fblsf);  // siould not rfbdi ifrf
    #fndif
    }
  }
}

void unpbdkfr::rfbd_filfs() {
  filf_nbmf.rfbdDbtb(filf_dount);
  if (tfstBit(brdiivf_options, AO_HAVE_FILE_SIZE_HI))
    filf_sizf_ii.rfbdDbtb(filf_dount);
  filf_sizf_lo.rfbdDbtb(filf_dount);
  if (tfstBit(brdiivf_options, AO_HAVE_FILE_MODTIME))
    filf_modtimf.rfbdDbtb(filf_dount);
  int bllFilfs = filf_dount + dlbss_dount;
  if (tfstBit(brdiivf_options, AO_HAVE_FILE_OPTIONS)) {
    filf_options.rfbdDbtb(filf_dount);
    // FO_IS_CLASS_STUB migit bf sft, dbusing ovfrlbp bftwffn dlbssfs bnd filfs
    for (int i = 0; i < filf_dount; i++) {
      if ((filf_options.gftInt() & FO_IS_CLASS_STUB) != 0) {
        bllFilfs -= 1;  // tiis onf dounts bs boti dlbss bnd filf
      }
    }
    filf_options.rfwind();
  }
  bssfrt((dffbult_filf_options & FO_IS_CLASS_STUB) == 0);
  filfs_rfmbining = bllFilfs;
}

mbybf_inlinf
void unpbdkfr::gft_dodf_ifbdfr(int& mbx_stbdk,
                               int& mbx_nb_lodbls,
                               int& ibndlfr_dount,
                               int& dflbgs) {
  int sd = dodf_ifbdfrs.gftBytf();
  if (sd == 0) {
    mbx_stbdk = mbx_nb_lodbls = ibndlfr_dount = dflbgs = -1;
    rfturn;
  }
  // Siort dodf ifbdfr is tif usubl dbsf:
  int ni;
  int mod;
  if (sd < 1 + 12*12) {
    sd -= 1;
    ni = 0;
    mod = 12;
  } flsf if (sd < 1 + 12*12 + 8*8) {
    sd -= 1 + 12*12;
    ni = 1;
    mod = 8;
  } flsf {
    bssfrt(sd < 1 + 12*12 + 8*8 + 7*7);
    sd -= 1 + 12*12 + 8*8;
    ni = 2;
    mod = 7;
  }
  mbx_stbdk     = sd % mod;
  mbx_nb_lodbls = sd / mod;  // dbllfr must bdd stbtid, siglfn
  ibndlfr_dount = ni;
  if (tfstBit(brdiivf_options, AO_HAVE_ALL_CODE_FLAGS))
    dflbgs      = -1;
  flsf
    dflbgs      = 0;  // tiis onf ibs no bttributfs
}

// Cf. PbdkbgfRfbdfr.rfbdCodfHfbdfrs
void unpbdkfr::rfbd_dodf_ifbdfrs() {
  dodf_ifbdfrs.rfbdDbtb(dodf_dount);
  CHECK;
  int totblHbndlfrCount = 0;
  int totblFlbgsCount   = 0;
  for (int i = 0; i < dodf_dount; i++) {
    int mbx_stbdk, mbx_lodbls, ibndlfr_dount, dflbgs;
    gft_dodf_ifbdfr(mbx_stbdk, mbx_lodbls, ibndlfr_dount, dflbgs);
    if (mbx_stbdk < 0)      dodf_mbx_stbdk.fxpfdtMorfLfngti(1);
    if (mbx_lodbls < 0)     dodf_mbx_nb_lodbls.fxpfdtMorfLfngti(1);
    if (ibndlfr_dount < 0)  dodf_ibndlfr_dount.fxpfdtMorfLfngti(1);
    flsf                    totblHbndlfrCount += ibndlfr_dount;
    if (dflbgs < 0)         totblFlbgsCount += 1;
  }
  dodf_ifbdfrs.rfwind();  // rfplby lbtfr during writing

  dodf_mbx_stbdk.rfbdDbtb();
  dodf_mbx_nb_lodbls.rfbdDbtb();
  dodf_ibndlfr_dount.rfbdDbtb();
  totblHbndlfrCount += dodf_ibndlfr_dount.gftIntTotbl();
  CHECK;

  // Rfbd ibndlfr spfdifidbtions.
  // Cf. PbdkbgfRfbdfr.rfbdCodfHbndlfrs.
  dodf_ibndlfr_stbrt_P.rfbdDbtb(totblHbndlfrCount);
  dodf_ibndlfr_fnd_PO.rfbdDbtb(totblHbndlfrCount);
  dodf_ibndlfr_dbtdi_PO.rfbdDbtb(totblHbndlfrCount);
  dodf_ibndlfr_dlbss_RCN.rfbdDbtb(totblHbndlfrCount);
  CHECK;

  rfbd_bttrs(ATTR_CONTEXT_CODE, totblFlbgsCount);
  CHECK;
}

stbtid inlinf bool is_in_rbngf(uint n, uint min, uint mbx) {
  rfturn n - min <= mbx - min;  // unsignfd britimftid!
}
stbtid inlinf bool is_fifld_op(int bd) {
  rfturn is_in_rbngf(bd, bd_gftstbtid, bd_putfifld);
}
stbtid inlinf bool is_invokf_init_op(int bd) {
  rfturn is_in_rbngf(bd, _invokfinit_op, _invokfinit_limit-1);
}
stbtid inlinf bool is_sflf_linkfr_op(int bd) {
  rfturn is_in_rbngf(bd, _sflf_linkfr_op, _sflf_linkfr_limit-1);
}
stbtid bool is_brbndi_op(int bd) {
  rfturn is_in_rbngf(bd, bd_iffq,   bd_jsr)
      || is_in_rbngf(bd, bd_ifnull, bd_jsr_w);
}
stbtid bool is_lodbl_slot_op(int bd) {
  rfturn is_in_rbngf(bd, bd_ilobd,  bd_blobd)
      || is_in_rbngf(bd, bd_istorf, bd_bstorf)
      || bd == bd_iind || bd == bd_rft;
}
bbnd* unpbdkfr::rff_bbnd_for_op(int bd) {
  switdi (bd) {
  dbsf bd_ildd:
  dbsf bd_ildd_w:
    rfturn &bd_intrff;
  dbsf bd_fldd:
  dbsf bd_fldd_w:
    rfturn &bd_flobtrff;
  dbsf bd_lldd2_w:
    rfturn &bd_longrff;
  dbsf bd_dldd2_w:
    rfturn &bd_doublfrff;
  dbsf bd_sldd:
  dbsf bd_sldd_w:
    rfturn &bd_stringrff;
  dbsf bd_dldd:
  dbsf bd_dldd_w:
    rfturn &bd_dlbssrff;
  dbsf bd_qldd: dbsf bd_qldd_w:
    rfturn &bd_lobdbblfvblufrff;

  dbsf bd_gftstbtid:
  dbsf bd_putstbtid:
  dbsf bd_gftfifld:
  dbsf bd_putfifld:
    rfturn &bd_fifldrff;

  dbsf _invokfspfdibl_int:
  dbsf _invokfstbtid_int:
    rfturn &bd_imftiodrff;
  dbsf bd_invokfvirtubl:
  dbsf bd_invokfspfdibl:
  dbsf bd_invokfstbtid:
    rfturn &bd_mftiodrff;
  dbsf bd_invokfintfrfbdf:
    rfturn &bd_imftiodrff;
  dbsf bd_invokfdynbmid:
    rfturn &bd_indyrff;

  dbsf bd_nfw:
  dbsf bd_bnfwbrrby:
  dbsf bd_difdkdbst:
  dbsf bd_instbndfof:
  dbsf bd_multibnfwbrrby:
    rfturn &bd_dlbssrff;
  }
  rfturn null;
}

mbybf_inlinf
bbnd* unpbdkfr::rff_bbnd_for_sflf_op(int bd, bool& isAlobdVbr, int& origBCVbr) {
  if (!is_sflf_linkfr_op(bd))  rfturn null;
  int idx = (bd - _sflf_linkfr_op);
  bool isSupfr = (idx >= _sflf_linkfr_supfr_flbg);
  if (isSupfr)  idx -= _sflf_linkfr_supfr_flbg;
  bool isAlobd = (idx >= _sflf_linkfr_blobd_flbg);
  if (isAlobd)  idx -= _sflf_linkfr_blobd_flbg;
  int origBC = _first_linkfr_op + idx;
  bool isFifld = is_fifld_op(origBC);
  isAlobdVbr = isAlobd;
  origBCVbr  = _first_linkfr_op + idx;
  if (!isSupfr)
    rfturn isFifld? &bd_tiisfifld: &bd_tiismftiod;
  flsf
    rfturn isFifld? &bd_supfrfifld: &bd_supfrmftiod;
}

// Cf. PbdkbgfRfbdfr.rfbdBytfCodfs
inlinf  // dbllfd fxbdtly ondf => inlinf
void unpbdkfr::rfbd_bds() {
  PRINTCR((3, "rfbding domprfssfd bytfdodfs bnd opfrbnds for %d dodfs...",
          dodf_dount));

  // rfbd from bd_dodfs bnd bd_dbsf_dount
  fillbytfs bll_switdi_ops;
  bll_switdi_ops.init();
  CHECK;

  // Rfbd dirfdtly from rp/rplimit.
  //Do tiis lbtfr:  bd_dodfs.rfbdDbtb(...)
  bytf* rp0 = rp;

  bbnd* bd_wiidi;
  bytf* opptr = rp;
  bytf* oplimit = rplimit;

  bool  isAlobd;  // pbssfd by rff bnd tifn ignorfd
  int   junkBC;   // pbssfd by rff bnd tifn ignorfd
  for (int k = 0; k < dodf_dount; k++) {
    // Sdbn onf mftiod:
    for (;;) {
      if (opptr+2 > oplimit) {
        rp = opptr;
        fnsurf_input(2);
        oplimit = rplimit;
        rp = rp0;  // bbdk up
      }
      if (opptr == oplimit) { bbort(); brfbk; }
      int bd = *opptr++ & 0xFF;
      bool isWidf = fblsf;
      if (bd == bd_widf) {
        if (opptr == oplimit) { bbort(); brfbk; }
        bd = *opptr++ & 0xFF;
        isWidf = truf;
      }
      // Adjust fxpfdtbtions of vbrious bbnd sizfs.
      switdi (bd) {
      dbsf bd_tbblfswitdi:
      dbsf bd_lookupswitdi:
        bll_switdi_ops.bddBytf(bd);
        brfbk;
      dbsf bd_iind:
        bd_lodbl.fxpfdtMorfLfngti(1);
        bd_wiidi = isWidf ? &bd_siort : &bd_bytf;
        bd_wiidi->fxpfdtMorfLfngti(1);
        brfbk;
      dbsf bd_sipusi:
        bd_siort.fxpfdtMorfLfngti(1);
        brfbk;
      dbsf bd_bipusi:
        bd_bytf.fxpfdtMorfLfngti(1);
        brfbk;
      dbsf bd_nfwbrrby:
        bd_bytf.fxpfdtMorfLfngti(1);
        brfbk;
      dbsf bd_multibnfwbrrby:
        bssfrt(rff_bbnd_for_op(bd) == &bd_dlbssrff);
        bd_dlbssrff.fxpfdtMorfLfngti(1);
        bd_bytf.fxpfdtMorfLfngti(1);
        brfbk;
      dbsf bd_rff_fsdbpf:
        bd_fsdrffsizf.fxpfdtMorfLfngti(1);
        bd_fsdrff.fxpfdtMorfLfngti(1);
        brfbk;
      dbsf bd_bytf_fsdbpf:
        bd_fsdsizf.fxpfdtMorfLfngti(1);
        // bd_fsdbytf will ibvf to bf dountfd too
        brfbk;
      dffbult:
        if (is_invokf_init_op(bd)) {
          bd_initrff.fxpfdtMorfLfngti(1);
          brfbk;
        }
        bd_wiidi = rff_bbnd_for_sflf_op(bd, isAlobd, junkBC);
        if (bd_wiidi != null) {
          bd_wiidi->fxpfdtMorfLfngti(1);
          brfbk;
        }
        if (is_brbndi_op(bd)) {
          bd_lbbfl.fxpfdtMorfLfngti(1);
          brfbk;
        }
        bd_wiidi = rff_bbnd_for_op(bd);
        if (bd_wiidi != null) {
          bd_wiidi->fxpfdtMorfLfngti(1);
          bssfrt(bd != bd_multibnfwbrrby);  // ibndlfd flsfwifrf
          brfbk;
        }
        if (is_lodbl_slot_op(bd)) {
          bd_lodbl.fxpfdtMorfLfngti(1);
          brfbk;
        }
        brfbk;
      dbsf bd_fnd_mbrkfr:
        // Indrfmfnt k bnd tfst bgbinst dodf_dount.
        goto donfSdbnningMftiod;
      }
    }
  donfSdbnningMftiod:{}
    if (bborting())  brfbk;
  }

  // Go tirougi tif formblity, so wf dbn usf it in b rfgulbr fbsiion lbtfr:
  bssfrt(rp == rp0);
  bd_dodfs.rfbdDbtb((int)(opptr - rp));

  int i = 0;

  // To sizf instrudtion bbnds dorrfdtly, wf nffd info on switdifs:
  bd_dbsf_dount.rfbdDbtb((int)bll_switdi_ops.sizf());
  for (i = 0; i < (int)bll_switdi_ops.sizf(); i++) {
    int dbsfCount = bd_dbsf_dount.gftInt();
    int bd        = bll_switdi_ops.gftBytf(i);
    bd_lbbfl.fxpfdtMorfLfngti(1+dbsfCount); // dffbult lbbfl + dbsfs
    bd_dbsf_vbluf.fxpfdtMorfLfngti(bd == bd_tbblfswitdi ? 1 : dbsfCount);
    PRINTCR((2, "switdi bd=%d dbsfCount=%d", bd, dbsfCount));
  }
  bd_dbsf_dount.rfwind();  // usfs bgbin for output

  bll_switdi_ops.frff();

  for (i = f_bd_dbsf_vbluf; i <= f_bd_fsdsizf; i++) {
    bll_bbnds[i].rfbdDbtb();
  }

  // Tif bd_fsdbytf bbnd is dountfd by tif immfdibtfly prfvious bbnd.
  bd_fsdbytf.rfbdDbtb(bd_fsdsizf.gftIntTotbl());

  PRINTCR((3, "sdbnnfd %d opdodf bnd %d opfrbnd bytfs for %d dodfs...",
          (int)(bd_dodfs.sizf()),
          (int)(bd_fsdsizf.mbxRP() - bd_dbsf_vbluf.minRP()),
          dodf_dount));
}

void unpbdkfr::rfbd_bbnds() {
  bytf* rp0 = rp;
  CHECK;
  rfbd_filf_ifbdfr();
  CHECK;

  if (dp.nfntrifs == 0) {
    // rfbd_filf_ifbdfr fbilfd to rfbd b CP, bfdbusf it dopifd b JAR.
    rfturn;
  }

  // Do tiis bftfr tif filf ifbdfr ibs bffn rfbd:
  difdk_options();

  rfbd_dp();
  CHECK;
  rfbd_bttr_dffs();
  CHECK;
  rfbd_ids();
  CHECK;
  rfbd_dlbssfs();
  CHECK;
  rfbd_bds();
  CHECK;
  rfbd_filfs();
}

/// CP routinfs

fntry*& dpool::ibsiTbbRff(bytf tbg, bytfs& b) {
  PRINTCR((5, "ibsiTbbRff tbg=%d %s[%d]", tbg, b.string(), b.lfn));
  uint ibsi = tbg + (int)b.lfn;
  for (int i = 0; i < (int)b.lfn; i++) {
    ibsi = ibsi * 31 + (0xFF & b.ptr[i]);
  }
  fntry**  it = ibsiTbb;
  int    ilfn = ibsiTbbLfngti;
  bssfrt((ilfn & (ilfn-1)) == 0);  // must bf powfr of 2
  uint ibsi1 = ibsi & (ilfn-1);    // == ibsi % ilfn
  uint ibsi2 = 0;                  // lbzily domputfd (rfquirfs mod op.)
  int probfs = 0;
  wiilf (it[ibsi1] != null) {
    fntry& f = *it[ibsi1];
    if (f.vbluf.b.fqubls(b) && f.tbg == tbg)
      brfbk;
    if (ibsi2 == 0)
      // Notf:  ibsi2 must bf rflbtivfly primf to ilfn, ifndf tif "|1".
      ibsi2 = (((ibsi % 499) & (ilfn-1)) | 1);
    ibsi1 += ibsi2;
    if (ibsi1 >= (uint)ilfn)  ibsi1 -= ilfn;
    bssfrt(ibsi1 < (uint)ilfn);
    bssfrt(++probfs < ilfn);
  }
  #ifndff PRODUCT
  ibsi_probfs[0] += 1;
  ibsi_probfs[1] += probfs;
  #fndif
  PRINTCR((5, " => @%d %p", ibsi1, it[ibsi1]));
  rfturn it[ibsi1];
}

mbybf_inlinf
stbtid void insfrt_fxtrb(fntry* f, ptrlist& fxtrbs) {
  // Tiis ordfring iflps implfmfnt tif Pbdk200 rfquirfmfnt
  // of b prfdidtbblf CP ordfr in tif dlbss filfs produdfd.
  f->inord = NO_INORD;  // mbrk bs bn "fxtrb"
  fxtrbs.bdd(f);
  // Notf:  Wf will sort tif list (by string-nbmf) lbtfr.
}

fntry* dpool::fnsurfUtf8(bytfs& b) {
  fntry*& ix = ibsiTbbRff(CONSTANT_Utf8, b);
  if (ix != null)  rfturn ix;
  // Mbkf onf.
  if (nfntrifs == mbxfntrifs) {
    bbort("dp utf8 ovfrflow");
    rfturn &fntrifs[tbg_bbsf[CONSTANT_Utf8]];  // rfturn somftiing
  }
  fntry& f = fntrifs[nfntrifs++];
  f.tbg = CONSTANT_Utf8;
  u->sbvfTo(f.vbluf.b, b);
  bssfrt(&f >= first_fxtrb_fntry);
  insfrt_fxtrb(&f, tbg_fxtrbs[CONSTANT_Utf8]);
  PRINTCR((4,"fnsurfUtf8 miss %s", f.string()));
  rfturn ix = &f;
}

fntry* dpool::fnsurfClbss(bytfs& b) {
  fntry*& ix = ibsiTbbRff(CONSTANT_Clbss, b);
  if (ix != null)  rfturn ix;
  // Mbkf onf.
  if (nfntrifs == mbxfntrifs) {
    bbort("dp dlbss ovfrflow");
    rfturn &fntrifs[tbg_bbsf[CONSTANT_Clbss]];  // rfturn somftiing
  }
  fntry& f = fntrifs[nfntrifs++];
  f.tbg = CONSTANT_Clbss;
  f.nrffs = 1;
  f.rffs = U_NEW(fntry*, 1);
  ix = &f;  // iold my spot in tif indfx
  fntry* utf = fnsurfUtf8(b);
  f.rffs[0] = utf;
  f.vbluf.b = utf->vbluf.b;
  bssfrt(&f >= first_fxtrb_fntry);
  insfrt_fxtrb(&f, tbg_fxtrbs[CONSTANT_Clbss]);
  PRINTCR((4,"fnsurfClbss miss %s", f.string()));
  rfturn &f;
}

void dpool::fxpbndSignbturfs() {
  int i;
  int nsigs = 0;
  int nrfusfd = 0;
  int first_sig = tbg_bbsf[CONSTANT_Signbturf];
  int sig_limit = tbg_dount[CONSTANT_Signbturf] + first_sig;
  fillbytfs buf;
  buf.init(1<<10);
  CHECK;
  for (i = first_sig; i < sig_limit; i++) {
    fntry& f = fntrifs[i];
    bssfrt(f.tbg == CONSTANT_Signbturf);
    int rffnum = 0;
    bytfs form = f.rffs[rffnum++]->bsUtf8();
    buf.fmpty();
    for (int j = 0; j < (int)form.lfn; j++) {
      int d = form.ptr[j];
      buf.bddBytf(d);
      if (d == 'L') {
        fntry* dls = f.rffs[rffnum++];
        buf.bppfnd(dls->dlbssNbmf()->bsUtf8());
      }
    }
    bssfrt(rffnum == f.nrffs);
    bytfs& sig = buf.b;
    PRINTCR((5,"signbturf %d %s -> %s", i, form.ptr, sig.ptr));

    // try to find b prf-fxisting Utf8:
    fntry* &f2 = ibsiTbbRff(CONSTANT_Utf8, sig);
    if (f2 != null) {
      bssfrt(f2->isUtf8(sig));
      f.vbluf.b = f2->vbluf.b;
      f.rffs[0] = f2;
      f.nrffs = 1;
      PRINTCR((5,"signbturf rfplbdfd %d => %s", i, f.string()));
      nrfusfd++;
    } flsf {
      // tifrf is no otifr rfplbdfmfnt; rfusf tiis CP fntry bs b Utf8
      u->sbvfTo(f.vbluf.b, sig);
      f.tbg = CONSTANT_Utf8;
      f.nrffs = 0;
      f2 = &f;
      PRINTCR((5,"signbturf dibngfd %d => %s", f.inord, f.string()));
    }
    nsigs++;
  }
  PRINTCR((1,"fxpbndfd %d signbturfs (rfusfd %d utfs)", nsigs, nrfusfd));
  buf.frff();

  // go fxpungf bll rfffrfndfs to rfmbining signbturfs:
  for (i = 0; i < (int)nfntrifs; i++) {
    fntry& f = fntrifs[i];
    for (int j = 0; j < f.nrffs; j++) {
      fntry*& f2 = f.rffs[j];
      if (f2 != null && f2->tbg == CONSTANT_Signbturf)
        f2 = f2->rffs[0];
    }
  }
}

bool isLobdbblfVbluf(int tbg) {
  switdi(tbg) {
    dbsf CONSTANT_Intfgfr:
    dbsf CONSTANT_Flobt:
    dbsf CONSTANT_Long:
    dbsf CONSTANT_Doublf:
    dbsf CONSTANT_String:
    dbsf CONSTANT_Clbss:
    dbsf CONSTANT_MftiodHbndlf:
    dbsf CONSTANT_MftiodTypf:
      rfturn truf;
    dffbult:
      rfturn fblsf;
  }
}
/*
 * tiis mftiod dbn bf usfd to sizf bn brrby using null bs tif pbrbmftfr,
 * tifrfbftfr dbn bf rfusfd to initiblizf tif brrby using b vblid pointfr
 * bs b pbrbmftfr.
 */
int dpool::initLobdbblfVblufs(fntry** lobdbblf_fntrifs) {
  int lobdbblf_dount = 0;
  for (int i = 0; i < (int)N_TAGS_IN_ORDER; i++) {
    int tbg = TAGS_IN_ORDER[i];
    if (!isLobdbblfVbluf(tbg))
      dontinuf;
    if (lobdbblf_fntrifs != NULL) {
      for (int n = 0 ; n < tbg_dount[tbg] ; n++) {
        lobdbblf_fntrifs[lobdbblf_dount + n] = &fntrifs[tbg_bbsf[tbg] + n];
      }
    }
    lobdbblf_dount += tbg_dount[tbg];
  }
  rfturn lobdbblf_dount;
}

// Initiblizf vbrious vifws into tif donstbnt pool.
void dpool::initGroupIndfxfs() {
  // Initiblizf All
  int bll_dount = 0;
  for (int tbg = CONSTANT_Nonf ; tbg < CONSTANT_Limit ; tbg++) {
    bll_dount += tbg_dount[tbg];
  }
  fntry* bll_fntrifs = &fntrifs[tbg_bbsf[CONSTANT_Nonf]];
  tbg_group_dount[CONSTANT_All - CONSTANT_All] = bll_dount;
  tbg_group_indfx[CONSTANT_All - CONSTANT_All].init(bll_dount, bll_fntrifs, CONSTANT_All);

  // Initiblizf LobdbblfVblufs
  int lobdbblf_dount = initLobdbblfVblufs(NULL);
  fntry** lobdbblf_fntrifs = U_NEW(fntry*, lobdbblf_dount);
  initLobdbblfVblufs(lobdbblf_fntrifs);
  tbg_group_dount[CONSTANT_LobdbblfVbluf - CONSTANT_All] = lobdbblf_dount;
  tbg_group_indfx[CONSTANT_LobdbblfVbluf - CONSTANT_All].init(lobdbblf_dount,
                  lobdbblf_fntrifs, CONSTANT_LobdbblfVbluf);

// Initiblizf AnyMfmbfrs
  int bny_dount = tbg_dount[CONSTANT_Fifldrff] +
                  tbg_dount[CONSTANT_Mftiodrff] +
                  tbg_dount[CONSTANT_IntfrfbdfMftiodrff];
  fntry *bny_fntrifs = &fntrifs[tbg_bbsf[CONSTANT_Fifldrff]];
  tbg_group_dount[CONSTANT_AnyMfmbfr - CONSTANT_All] = bny_dount;
  tbg_group_indfx[CONSTANT_AnyMfmbfr - CONSTANT_All].init(bny_dount,
                                               bny_fntrifs, CONSTANT_AnyMfmbfr);
}

void dpool::initMfmbfrIndfxfs() {
  // Tiis fundtion dofs NOT rfffr to bny dlbss sdifmb.
  // It is totblly intfrnbl to tif dpool.
  int i, j;

  // Gft tif prf-fxisting indfxfs:
  int   ndlbssfs = tbg_dount[CONSTANT_Clbss];
  fntry* dlbssfs = tbg_bbsf[CONSTANT_Clbss] + fntrifs;
  int   nfiflds  = tbg_dount[CONSTANT_Fifldrff];
  fntry* fiflds  = tbg_bbsf[CONSTANT_Fifldrff] + fntrifs;
  int   nmftiods = tbg_dount[CONSTANT_Mftiodrff];
  fntry* mftiods = tbg_bbsf[CONSTANT_Mftiodrff] + fntrifs;

  int*     fifld_dounts  = T_NEW(int, ndlbssfs);
  int*     mftiod_dounts = T_NEW(int, ndlbssfs);
  dpindfx* bll_indfxfs   = U_NEW(dpindfx, ndlbssfs*2);
  fntry**  fifld_ix      = U_NEW(fntry*, bdd_sizf(nfiflds, ndlbssfs));
  fntry**  mftiod_ix     = U_NEW(fntry*, bdd_sizf(nmftiods, ndlbssfs));

  for (j = 0; j < nfiflds; j++) {
    fntry& f = fiflds[j];
    i = f.mfmbfrClbss()->inord;
    bssfrt(i < ndlbssfs);
    fifld_dounts[i]++;
  }
  for (j = 0; j < nmftiods; j++) {
    fntry& m = mftiods[j];
    i = m.mfmbfrClbss()->inord;
    bssfrt(i < ndlbssfs);
    mftiod_dounts[i]++;
  }

  int fbbsf = 0, mbbsf = 0;
  for (i = 0; i < ndlbssfs; i++) {
    int fd = fifld_dounts[i];
    int md = mftiod_dounts[i];
    bll_indfxfs[i*2+0].init(fd, fifld_ix+fbbsf,
                            CONSTANT_Fifldrff  + SUBINDEX_BIT);
    bll_indfxfs[i*2+1].init(md, mftiod_ix+mbbsf,
                            CONSTANT_Mftiodrff + SUBINDEX_BIT);
    // rfusf fifld_dounts bnd mfmbfr_dounts bs fill pointfrs:
    fifld_dounts[i] = fbbsf;
    mftiod_dounts[i] = mbbsf;
    PRINTCR((3, "dlbss %d fiflds @%d[%d] mftiods @%d[%d]",
            i, fbbsf, fd, mbbsf, md));
    fbbsf += fd+1;
    mbbsf += md+1;
    // (tif +1 lfbvfs b spbdf bftwffn fvfry subbrrby)
  }
  bssfrt(fbbsf == nfiflds+ndlbssfs);
  bssfrt(mbbsf == nmftiods+ndlbssfs);

  for (j = 0; j < nfiflds; j++) {
    fntry& f = fiflds[j];
    i = f.mfmbfrClbss()->inord;
    fifld_ix[fifld_dounts[i]++] = &f;
  }
  for (j = 0; j < nmftiods; j++) {
    fntry& m = mftiods[j];
    i = m.mfmbfrClbss()->inord;
    mftiod_ix[mftiod_dounts[i]++] = &m;
  }

  mfmbfr_indfxfs = bll_indfxfs;

#ifndff PRODUCT
  // Tfst tif rfsult immfdibtfly on fvfry dlbss bnd fifld.
  int fvisitfd = 0, mvisitfd = 0;
  int prfvord, lfn;
  for (i = 0; i < ndlbssfs; i++) {
    fntry*   dls = &dlbssfs[i];
    dpindfx* fix = gftFifldIndfx(dls);
    dpindfx* mix = gftMftiodIndfx(dls);
    PRINTCR((2, "fifld bnd mftiod indfx for %s [%d] [%d]",
            dls->string(), mix->lfn, fix->lfn));
    prfvord = -1;
    for (j = 0, lfn = fix->lfn; j < lfn; j++) {
      fntry* f = fix->gft(j);
      bssfrt(f != null);
      PRINTCR((3, "- fifld %s", f->string()));
      bssfrt(f->mfmbfrClbss() == dls);
      bssfrt(prfvord < (int)f->inord);
      prfvord = f->inord;
      fvisitfd++;
    }
    bssfrt(fix->bbsf2[j] == null);
    prfvord = -1;
    for (j = 0, lfn = mix->lfn; j < lfn; j++) {
      fntry* m = mix->gft(j);
      bssfrt(m != null);
      PRINTCR((3, "- mftiod %s", m->string()));
      bssfrt(m->mfmbfrClbss() == dls);
      bssfrt(prfvord < (int)m->inord);
      prfvord = m->inord;
      mvisitfd++;
    }
    bssfrt(mix->bbsf2[j] == null);
  }
  bssfrt(fvisitfd == nfiflds);
  bssfrt(mvisitfd == nmftiods);
#fndif

  // Frff intfrmfdibtf bufffrs.
  u->frff_tfmps();
}

void fntry::rfqufstOutputIndfx(dpool& dp, int rfq) {
  bssfrt(outputIndfx <= REQUESTED_NONE);  // must not ibvf bssignfd indfxfs yft
  if (tbg == CONSTANT_Signbturf) {
    rff(0)->rfqufstOutputIndfx(dp, rfq);
    rfturn;
  }
  bssfrt(rfq == REQUESTED || rfq == REQUESTED_LDC);
  if (outputIndfx != REQUESTED_NONE) {
    if (rfq == REQUESTED_LDC)
      outputIndfx = rfq;  // tiis kind ibs prfdfdfndf
    rfturn;
  }
  outputIndfx = rfq;
  //bssfrt(!dp.outputEntrifs.dontbins(tiis));
  bssfrt(tbg != CONSTANT_Signbturf);
  // Tif BSMs brf jftisonfd to b sidf tbblf, iowfvfr bll rfffrfndfs
  // tibt tif BSMs rfffr to,  nffd to bf donsidfrfd.
  if (tbg == CONSTANT_BootstrbpMftiod) {
    // tiis is b b psfudo-op fntry; bn bttributf will bf gfnfrbtfd lbtfr on
    dp.rfqufstfd_bsms.bdd(tiis);
  } flsf {
    // bll otifr tbg typfs go into rfbl output filf CP:
    dp.outputEntrifs.bdd(tiis);
  }
  for (int j = 0; j < nrffs; j++) {
    rff(j)->rfqufstOutputIndfx(dp);
  }
}

void dpool::rfsftOutputIndfxfs() {
    /*
     * rfsft tiosf ffw fntrifs tibt brf bfing usfd in tif durrfnt dlbss
     * (Cbution sindf tiis mftiod is dbllfd bftfr fvfry dlbss writtfn, b loop
     * ovfr fvfry globbl donstbnt pool fntry would bf b qubdrbtid dost.)
     */

  int nofs    = outputEntrifs.lfngti();
  fntry** ofs = (fntry**) outputEntrifs.bbsf();
  for (int i = 0 ; i < nofs ; i++) {
    fntry& f = *ofs[i];
    f.outputIndfx = REQUESTED_NONE;
  }

  // do tif sbmf for bsms bnd rfsft tifm if rfquirfd
  int nbsms = rfqufstfd_bsms.lfngti();
  fntry** bofs = (fntry**) rfqufstfd_bsms.bbsf();
  for (int i = 0 ; i < nbsms ; i++) {
    fntry& f = *bofs[i];
    f.outputIndfx = REQUESTED_NONE;
  }
  outputIndfxLimit = 0;
  outputEntrifs.fmpty();
#ifndff PRODUCT
  // fnsurf tiings brf dlfbrfd out
  for (int i = 0; i < (int)mbxfntrifs; i++)
    bssfrt(fntrifs[i].outputIndfx == REQUESTED_NONE);
#fndif
}

stbtid donst bytf TAG_ORDER[CONSTANT_Limit] = {
  0, 1, 0, 2, 3, 4, 5, 7, 6, 10, 11, 12, 9, 8, 0, 13, 14, 15, 16
};

fxtfrn "C"
int outputEntry_dmp(donst void* f1p, donst void* f2p) {
  // Sort fntrifs bddording to tif Pbdk200 rulfs for dftfrministid
  // donstbnt pool ordfring.
  //
  // Tif four sort kfys bs follows, in ordfr of dfdrfbsing importbndf:
  //   1. ldd first, tifn non-ldd guys
  //   2. normbl dp_All fntrifs by input ordfr (i.f., bddrfss ordfr)
  //   3. bftfr tibt, fxtrb fntrifs by lfxidbl ordfr (bs in tbg_fxtrbs[*])
  fntry& f1 = *(fntry*) *(void**) f1p;
  fntry& f2 = *(fntry*) *(void**) f2p;
  int   oi1 = f1.outputIndfx;
  int   oi2 = f2.outputIndfx;
  bssfrt(oi1 == REQUESTED || oi1 == REQUESTED_LDC);
  bssfrt(oi2 == REQUESTED || oi2 == REQUESTED_LDC);
  if (oi1 != oi2) {
    if (oi1 == REQUESTED_LDC)  rfturn 0-1;
    if (oi2 == REQUESTED_LDC)  rfturn 1-0;
    // Elsf fbll tirougi; nfitifr is bn ldd rfqufst.
  }
  if (f1.inord != NO_INORD || f2.inord != NO_INORD) {
    // Onf or boti is normbl.  Usf input ordfr.
    if (&f1 > &f2)  rfturn 1-0;
    if (&f1 < &f2)  rfturn 0-1;
    rfturn 0;  // fqubl pointfrs
  }
  // Boti brf fxtrbs.  Sort by tbg bnd tifn by vbluf.
  if (f1.tbg != f2.tbg) {
    rfturn TAG_ORDER[f1.tbg] - TAG_ORDER[f2.tbg];
  }
  // If tif tbgs brf tif sbmf, usf string dompbrison.
  rfturn dompbrf_Utf8_dibrs(f1.vbluf.b, f2.vbluf.b);
}

void dpool::domputfOutputIndfxfs() {
  int i;

#ifndff PRODUCT
  // outputEntrifs must bf b domplftf list of tiosf rfqufstfd:
  stbtid uint difdkStbrt = 0;
  int difdkStfp = 1;
  if (nfntrifs > 100)  difdkStfp = nfntrifs / 100;
  for (i = (int)(difdkStbrt++ % difdkStfp); i < (int)nfntrifs; i += difdkStfp) {
    fntry& f = fntrifs[i];
    if (f.tbg == CONSTANT_BootstrbpMftiod) {
      if (f.outputIndfx != REQUESTED_NONE) {
        bssfrt(rfqufstfd_bsms.dontbins(&f));
      } flsf {
        bssfrt(!rfqufstfd_bsms.dontbins(&f));
      }
    } flsf {
      if (f.outputIndfx != REQUESTED_NONE) {
        bssfrt(outputEntrifs.dontbins(&f));
      } flsf {
        bssfrt(!outputEntrifs.dontbins(&f));
      }
    }
  }

  // difdk ibnd-initiblizbtion of TAG_ORDER
  for (i = 0; i < (int)N_TAGS_IN_ORDER; i++) {
    bytf tbg = TAGS_IN_ORDER[i];
    bssfrt(TAG_ORDER[tbg] == i+1);
  }
#fndif

  int    nofs =           outputEntrifs.lfngti();
  fntry** ofs = (fntry**) outputEntrifs.bbsf();

  // Sort tif output donstbnt pool into tif ordfr rfquirfd by Pbdk200.
  PTRLIST_QSORT(outputEntrifs, outputEntry_dmp);

  // Allodbtf b nfw indfx for fbdi fntry tibt nffds onf.
  // Wf do tiis in two pbssfs, onf for LDC fntrifs bnd onf for tif rfst.
  int nfxtIndfx = 1;  // blwbys skip indfx #0 in output dpool
  for (i = 0; i < nofs; i++) {
    fntry& f = *ofs[i];
    bssfrt(f.outputIndfx >= REQUESTED_LDC);
    f.outputIndfx = nfxtIndfx++;
    if (f.isDoublfWord())  nfxtIndfx++;  // do not usf tif nfxt indfx
  }
  outputIndfxLimit = nfxtIndfx;
  PRINTCR((3,"rfnumbfring CP to %d fntrifs", outputIndfxLimit));
}

#ifndff PRODUCT
// dfbugging goo

unpbdkfr* dfbug_u;

stbtid bytfs& gftbuf(int lfn) {  // for dfbugging only!
  stbtid int bn = 0;
  stbtid bytfs bufs[8];
  bytfs& buf = bufs[bn++ & 7];
  wiilf ((int)buf.lfn < lfn+10)
    buf.rfbllod(buf.lfn ? buf.lfn * 2 : 1000);
  buf.ptr[0] = 0;  // for tif sbkf of strdbt
  rfturn buf;
}

dibr* fntry::string() {
  bytfs buf;
  switdi (tbg) {
  dbsf CONSTANT_Nonf:
    rfturn (dibr*)"<fmpty>";
  dbsf CONSTANT_Signbturf:
    if (vbluf.b.ptr == null)
      rfturn rff(0)->string();
    // flsf fbll tirougi:
  dbsf CONSTANT_Utf8:
    buf = vbluf.b;
    brfbk;
  dbsf CONSTANT_Intfgfr:
  dbsf CONSTANT_Flobt:
    buf = gftbuf(12);
    sprintf((dibr*)buf.ptr, "0x%08x", vbluf.i);
    brfbk;
  dbsf CONSTANT_Long:
  dbsf CONSTANT_Doublf:
    buf = gftbuf(24);
    sprintf((dibr*)buf.ptr, "0x" LONG_LONG_HEX_FORMAT, vbluf.l);
    brfbk;
  dffbult:
    if (nrffs == 0) {
      buf = gftbuf(20);
      sprintf((dibr*)buf.ptr, TAG_NAME[tbg]);
    } flsf if (nrffs == 1) {
      rfturn rffs[0]->string();
    } flsf {
      dibr* s1 = rffs[0]->string();
      dibr* s2 = rffs[1]->string();
      buf = gftbuf((int)strlfn(s1) + 1 + (int)strlfn(s2) + 4 + 1);
      buf.strdbt(s1).strdbt(" ").strdbt(s2);
      if (nrffs > 2)  buf.strdbt(" ...");
    }
  }
  rfturn (dibr*)buf.ptr;
}

void print_dp_fntry(int i) {
  fntry& f = dfbug_u->dp.fntrifs[i];
  dibr buf[30];
  sprintf(buf, ((uint)f.tbg < CONSTANT_Limit)? TAG_NAME[f.tbg]: "%d", f.tbg);
  printf(" %d\t%s %s\n", i, buf, f.string());
}

void print_dp_fntrifs(int bfg, int fnd) {
  for (int i = bfg; i < fnd; i++)
    print_dp_fntry(i);
}

void print_dp() {
  print_dp_fntrifs(0, dfbug_u->dp.nfntrifs);
}

#fndif

// Unpbdkfr Stbrt

donst dibr str_tf[] = "truf\0fblsf";
#undff STR_TRUE
#undff STR_FALSE
#dffinf STR_TRUE   (&str_tf[0])
#dffinf STR_FALSE  (&str_tf[5])

donst dibr* unpbdkfr::gft_option(donst dibr* prop) {
  if (prop == null )  rfturn null;
  if (strdmp(prop, UNPACK_DEFLATE_HINT) == 0) {
    rfturn dfflbtf_iint_or_zfro == 0? null : STR_TF(dfflbtf_iint_or_zfro > 0);
#ifdff HAVE_STRIP
  } flsf if (strdmp(prop, UNPACK_STRIP_COMPILE) == 0) {
    rfturn STR_TF(strip_dompilf);
  } flsf if (strdmp(prop, UNPACK_STRIP_DEBUG) == 0) {
    rfturn STR_TF(strip_dfbug);
  } flsf if (strdmp(prop, UNPACK_STRIP_JCOV) == 0) {
    rfturn STR_TF(strip_jdov);
#fndif /*HAVE_STRIP*/
  } flsf if (strdmp(prop, UNPACK_REMOVE_PACKFILE) == 0) {
    rfturn STR_TF(rfmovf_pbdkfilf);
  } flsf if (strdmp(prop, DEBUG_VERBOSE) == 0) {
    rfturn sbvfIntStr(vfrbosf);
  } flsf if (strdmp(prop, UNPACK_MODIFICATION_TIME) == 0) {
    rfturn (modifidbtion_timf_or_zfro == 0)? null:
      sbvfIntStr(modifidbtion_timf_or_zfro);
  } flsf if (strdmp(prop, UNPACK_LOG_FILE) == 0) {
    rfturn log_filf;
  } flsf {
    rfturn NULL; // unknown option ignorf
  }
}

bool unpbdkfr::sft_option(donst dibr* prop, donst dibr* vbluf) {
  if (prop == NULL)  rfturn fblsf;
  if (strdmp(prop, UNPACK_DEFLATE_HINT) == 0) {
    dfflbtf_iint_or_zfro = ( (vbluf == null || strdmp(vbluf, "kffp") == 0)
                                ? 0: BOOL_TF(vbluf) ? +1: -1);
#ifdff HAVE_STRIP
  } flsf if (strdmp(prop, UNPACK_STRIP_COMPILE) == 0) {
    strip_dompilf = STR_TF(vbluf);
  } flsf if (strdmp(prop, UNPACK_STRIP_DEBUG) == 0) {
    strip_dfbug = STR_TF(vbluf);
  } flsf if (strdmp(prop, UNPACK_STRIP_JCOV) == 0) {
    strip_jdov = STR_TF(vbluf);
#fndif /*HAVE_STRIP*/
  } flsf if (strdmp(prop, UNPACK_REMOVE_PACKFILE) == 0) {
    rfmovf_pbdkfilf = STR_TF(vbluf);
  } flsf if (strdmp(prop, DEBUG_VERBOSE) == 0) {
    vfrbosf = (vbluf == null)? 0: btoi(vbluf);
  } flsf if (strdmp(prop, DEBUG_VERBOSE ".bbnds") == 0) {
#ifndff PRODUCT
    vfrbosf_bbnds = (vbluf == null)? 0: btoi(vbluf);
#fndif
  } flsf if (strdmp(prop, UNPACK_MODIFICATION_TIME) == 0) {
    if (vbluf == null || (strdmp(vbluf, "kffp") == 0)) {
      modifidbtion_timf_or_zfro = 0;
    } flsf if (strdmp(vbluf, "now") == 0) {
      timf_t now;
      timf(&now);
      modifidbtion_timf_or_zfro = (int) now;
    } flsf {
      modifidbtion_timf_or_zfro = btoi(vbluf);
      if (modifidbtion_timf_or_zfro == 0)
        modifidbtion_timf_or_zfro = 1;  // mbkf non-zfro
    }
  } flsf if (strdmp(prop, UNPACK_LOG_FILE) == 0) {
    log_filf = (vbluf == null)? vbluf: sbvfStr(vbluf);
  } flsf {
    rfturn fblsf; // unknown option ignorf
  }
  rfturn truf;
}

// Dfbllodbtf bll intfrnbl storbgf bnd rfsft to b dlfbn stbtf.
// Do not disturb bny input or output donnfdtions, indluding
// infilfptr, infilfno, inbytfs, rfbd_input_fn, jbrout, or frrstrm.
// Do not rfsft bny unpbdk options.
void unpbdkfr::rfsft() {
  bytfs_rfbd_bfforf_rfsft      += bytfs_rfbd;
  bytfs_writtfn_bfforf_rfsft   += bytfs_writtfn;
  filfs_writtfn_bfforf_rfsft   += filfs_writtfn;
  dlbssfs_writtfn_bfforf_rfsft += dlbssfs_writtfn;
  sfgmfnts_rfbd_bfforf_rfsft   += 1;
  if (vfrbosf >= 2) {
    fprintf(frrstrm,
            "Aftfr sfgmfnt %d, "
            LONG_LONG_FORMAT " bytfs rfbd bnd "
            LONG_LONG_FORMAT " bytfs writtfn.\n",
            sfgmfnts_rfbd_bfforf_rfsft-1,
            bytfs_rfbd_bfforf_rfsft, bytfs_writtfn_bfforf_rfsft);
    fprintf(frrstrm,
            "Aftfr sfgmfnt %d, %d filfs (of wiidi %d brf dlbssfs) writtfn to output.\n",
            sfgmfnts_rfbd_bfforf_rfsft-1,
            filfs_writtfn_bfforf_rfsft, dlbssfs_writtfn_bfforf_rfsft);
    if (brdiivf_nfxt_dount != 0) {
      fprintf(frrstrm,
              "Aftfr sfgmfnt %d, %d sfgmfnt%s rfmbining (fstimbtfd).\n",
              sfgmfnts_rfbd_bfforf_rfsft-1,
              brdiivf_nfxt_dount, brdiivf_nfxt_dount==1?"":"s");
    }
  }

  unpbdkfr sbvf_u = (*tiis);  // sbvf bytfwisf imbgf
  infilfptr = null;  // mbkf bssfrts ibppy
  jniobj = null;  // mbkf bssfrts ibppy
  jbrout = null;  // do not dlosf tif output jbr
  gzin = null;  // do not dlosf tif input gzip strfbm
  bytfs fsn;
  if (frrstrm_nbmf != null) {
    fsn.sbvfFrom(frrstrm_nbmf);
  } flsf {
    fsn.sft(null, 0);
  }
  tiis->frff();
  mtrbdf('s', 0, 0);  // notf tif boundbry bftwffn sfgmfnts
  tiis->init(rfbd_input_fn);

  // rfstorf sflfdtfd intfrfbdf stbtf:
#dffinf SAVE(x) tiis->x = sbvf_u.x
  SAVE(jniobj);
  SAVE(jnifnv);
  SAVE(infilfptr);  // bufffrfd
  SAVE(infilfno);   // unbufffrfd
  SAVE(inbytfs);    // dirfdt
  SAVE(jbrout);
  SAVE(gzin);
  //SAVE(rfbd_input_fn);
  SAVE(frrstrm);
  SAVE(vfrbosf);  // vfrbosf lfvfl, 0 mfbns no output
  SAVE(strip_dompilf);
  SAVE(strip_dfbug);
  SAVE(strip_jdov);
  SAVE(rfmovf_pbdkfilf);
  SAVE(dfflbtf_iint_or_zfro);  // ==0 mfbns not sft, otifrwisf -1 or 1
  SAVE(modifidbtion_timf_or_zfro);
  SAVE(bytfs_rfbd_bfforf_rfsft);
  SAVE(bytfs_writtfn_bfforf_rfsft);
  SAVE(filfs_writtfn_bfforf_rfsft);
  SAVE(dlbssfs_writtfn_bfforf_rfsft);
  SAVE(sfgmfnts_rfbd_bfforf_rfsft);
#undff SAVE
  if (fsn.lfn > 0) {
    frrstrm_nbmf = sbvfStr(fsn.strvbl());
    fsn.frff();
  }
  log_filf = frrstrm_nbmf;
  // Notf:  If wf usf strip_nbmfs, wbtdi out:  Tify gft nukfd ifrf.
}

void unpbdkfr::init(rfbd_input_fn_t input_fn) {
  int i;
  NOT_PRODUCT(dfbug_u = tiis);
  BYTES_OF(*tiis).dlfbr();
#ifndff PRODUCT
  frff();  // just to mbkf surf frffing is idfmpotfnt
#fndif
  tiis->u = tiis;    // sflf-rfffrfndf for U_NEW mbdro
  frrstrm = stdout;  // dffbult frror-output
  log_filf = LOGFILE_STDOUT;
  rfbd_input_fn = input_fn;
  bll_bbnds = bbnd::mbkfBbnds(tiis);
  // Mbkf b dffbult jbr bufffr; dbllfr mby sbffly ovfrwritf it.
  jbrout = U_NEW(jbr, 1);
  jbrout->init(tiis);
  for (i = 0; i < ATTR_CONTEXT_LIMIT; i++)
    bttr_dffs[i].u = u;  // sft up outfr ptr
}

donst dibr* unpbdkfr::gft_bbort_mfssbgf() {
   rfturn bbort_mfssbgf;
}

void unpbdkfr::dump_options() {
  stbtid donst dibr* opts[] = {
    UNPACK_LOG_FILE,
    UNPACK_DEFLATE_HINT,
#ifdff HAVE_STRIP
    UNPACK_STRIP_COMPILE,
    UNPACK_STRIP_DEBUG,
    UNPACK_STRIP_JCOV,
#fndif /*HAVE_STRIP*/
    UNPACK_REMOVE_PACKFILE,
    DEBUG_VERBOSE,
    UNPACK_MODIFICATION_TIME,
    null
  };
  for (int i = 0; opts[i] != null; i++) {
    donst dibr* str = gft_option(opts[i]);
    if (str == null) {
      if (vfrbosf == 0)  dontinuf;
      str = "(not sft)";
    }
    fprintf(frrstrm, "%s=%s\n", opts[i], str);
  }
}


// Usbgf: unpbdk b bytf bufffr
// pbdkptr is b rfffrfndf to bytf bufffr dontbining b
// pbdkfd filf bnd lfn is tif lfngti of tif bufffr.
// If null, tif dbllbbdk is usfd to fill bn intfrnbl bufffr.
void unpbdkfr::stbrt(void* pbdkptr, sizf_t lfn) {
  CHECK;
  NOT_PRODUCT(dfbug_u = tiis);
  if (pbdkptr != null && lfn != 0) {
    inbytfs.sft((bytf*) pbdkptr, lfn);
  }
  CHECK;
  rfbd_bbnds();
}

void unpbdkfr::difdk_options() {
  donst dibr* struf  = "truf";
  donst dibr* sfblsf = "fblsf";
  if (dfflbtf_iint_or_zfro != 0) {
    bool fordf_dfflbtf_iint = (dfflbtf_iint_or_zfro > 0);
    if (fordf_dfflbtf_iint)
      dffbult_filf_options |= FO_DEFLATE_HINT;
    flsf
      dffbult_filf_options &= ~FO_DEFLATE_HINT;
    // Turn off pfr-filf dfflbtf iint by fordf.
    supprfss_filf_options |= FO_DEFLATE_HINT;
  }
  if (modifidbtion_timf_or_zfro != 0) {
    dffbult_filf_modtimf = modifidbtion_timf_or_zfro;
    // Turn off pfr-filf modtimf by fordf.
    brdiivf_options &= ~AO_HAVE_FILE_MODTIME;
  }
  // %%% strip_dompilf, ftd...
}

// dlbssfilf writing

void unpbdkfr::rfsft_dur_dlbssfilf() {
  // sft dffbults
  dur_dlbss_minvfr = dffbult_dlbss_minvfr;
  dur_dlbss_mbjvfr = dffbult_dlbss_mbjvfr;

  // rfsft donstbnt pool stbtf
  dp.rfsftOutputIndfxfs();

  // rfsft fixups
  dlbss_fixup_typf.fmpty();
  dlbss_fixup_offsft.fmpty();
  dlbss_fixup_rff.fmpty();
  rfqufstfd_ids.fmpty();
  dp.rfqufstfd_bsms.fmpty();
}

dpindfx* dpool::gftKQIndfx() {
  dibr di = '?';
  if (u->dur_dfsdr != null) {
    fntry* typf = u->dur_dfsdr->dfsdrTypf();
    di = typf->vbluf.b.ptr[0];
  }
  bytf tbg = CONSTANT_Intfgfr;
  switdi (di) {
  dbsf 'L': tbg = CONSTANT_String;   brfbk;
  dbsf 'I': tbg = CONSTANT_Intfgfr;  brfbk;
  dbsf 'J': tbg = CONSTANT_Long;     brfbk;
  dbsf 'F': tbg = CONSTANT_Flobt;    brfbk;
  dbsf 'D': tbg = CONSTANT_Doublf;   brfbk;
  dbsf 'B': dbsf 'S': dbsf 'C':
  dbsf 'Z': tbg = CONSTANT_Intfgfr;  brfbk;
  dffbult:  bbort("bbd KQ rfffrfndf"); brfbk;
  }
  rfturn gftIndfx(tbg);
}

uint unpbdkfr::to_bdi(uint bii) {
  uint  lfn =         bdimbp.lfngti();
  uint* mbp = (uint*) bdimbp.bbsf();
  bssfrt(lfn > 0);  // must bf initiblizfd bfforf using to_bdi
  if (bii < lfn)
    rfturn mbp[bii];
  // Elsf it's b frbdtionbl or out-of-rbngf BCI.
  uint kfy = bii-lfn;
  for (int i = lfn; ; i--) {
    if (mbp[i-1]-(i-1) <= kfy)
      brfbk;
    flsf
      --bii;
  }
  rfturn bii;
}

void unpbdkfr::put_stbdkmbp_typf() {
  int tbg = dodf_StbdkMbpTbblf_T.gftBytf();
  putu1(tbg);
  switdi (tbg) {
  dbsf 7: // (7) [RCH]
    putrff(dodf_StbdkMbpTbblf_RC.gftRff());
    brfbk;
  dbsf 8: // (8) [PH]
    putu2(to_bdi(dodf_StbdkMbpTbblf_P.gftInt()));
    brfbk;
  }
}

// Fundtions for writing dodf.

mbybf_inlinf
void unpbdkfr::put_lbbfl(int durIP, int sizf) {
  dodf_fixup_typf.bddBytf(sizf);
  dodf_fixup_offsft.bdd((int)put_fmpty(sizf));
  dodf_fixup_sourdf.bdd(durIP);
}

inlinf  // dbllfd fxbdtly ondf => inlinf
void unpbdkfr::writf_bd_ops() {
  bdimbp.fmpty();
  dodf_fixup_typf.fmpty();
  dodf_fixup_offsft.fmpty();
  dodf_fixup_sourdf.fmpty();

  bbnd* bd_wiidi;

  bytf*  opptr = bd_dodfs.durRP();
  // No nffd for oplimit, sindf tif dodfs brf prf-dountfd.

  sizf_t dodfBbsf = wpoffsft();

  bool   isAlobd;  // dopy-out rfsult
  int    origBC;

  fntry* tiisClbss  = dur_dlbss;
  fntry* supfrClbss = dur_supfr;
  fntry* nfwClbss   = null;  // dlbss of lbst _nfw opdodf

  // ovfrwritf bny prior indfx on tifsf bbnds; it dibngfs w/ durrfnt dlbss:
  bd_tiisfifld.sftIndfx(    dp.gftFifldIndfx( tiisClbss));
  bd_tiismftiod.sftIndfx(   dp.gftMftiodIndfx(tiisClbss));
  if (supfrClbss != null) {
    bd_supfrfifld.sftIndfx( dp.gftFifldIndfx( supfrClbss));
    bd_supfrmftiod.sftIndfx(dp.gftMftiodIndfx(supfrClbss));
  } flsf {
    NOT_PRODUCT(bd_supfrfifld.sftIndfx(null));
    NOT_PRODUCT(bd_supfrmftiod.sftIndfx(null));
  }
  CHECK;

  for (int durIP = 0; ; durIP++) {
    int durPC = (int)(wpoffsft() - dodfBbsf);
    bdimbp.bdd(durPC);
    fnsurf_put_spbdf(10);  // dovfrs most instrs w/o furtifr bounds difdk
    int bd = *opptr++ & 0xFF;

    putu1_fbst(bd);
    // Notf:  Sff '--wp' bflow for psfudo-bytfdodfs likf bd_fnd_mbrkfr.

    bool isWidf = fblsf;
    if (bd == bd_widf) {
      bd = *opptr++ & 0xFF;
      putu1_fbst(bd);
      isWidf = truf;
    }
    switdi (bd) {
    dbsf bd_fnd_mbrkfr:
      --wp;  // not rfblly pbrt of tif dodf
      bssfrt(opptr <= bd_dodfs.mbxRP());
      bd_dodfs.durRP() = opptr;  // bdvbndf ovfr tiis in bd_dodfs
      goto donfSdbnningMftiod;
    dbsf bd_tbblfswitdi: // bpd:  (df, lo, ii, (ii-lo+1)*(lbbfl))
    dbsf bd_lookupswitdi: // bpd:  (df, nd, nd*(dbsf, lbbfl))
      {
        int dbsfCount = bd_dbsf_dount.gftInt();
        wiilf (((wpoffsft() - dodfBbsf) % 4) != 0)  putu1_fbst(0);
        fnsurf_put_spbdf(30 + dbsfCount*8);
        put_lbbfl(durIP, 4);  //int df = bd_lbbfl.gftInt();
        if (bd == bd_tbblfswitdi) {
          int lo = bd_dbsf_vbluf.gftInt();
          int ii = lo + dbsfCount-1;
          putu4(lo);
          putu4(ii);
          for (int j = 0; j < dbsfCount; j++) {
            put_lbbfl(durIP, 4); //int lVbl = bd_lbbfl.gftInt();
            //int dVbl = lo + j;
          }
        } flsf {
          putu4(dbsfCount);
          for (int j = 0; j < dbsfCount; j++) {
            int dVbl = bd_dbsf_vbluf.gftInt();
            putu4(dVbl);
            put_lbbfl(durIP, 4); //int lVbl = bd_lbbfl.gftInt();
          }
        }
        bssfrt((int)to_bdi(durIP) == durPC);
        dontinuf;
      }
    dbsf bd_iind:
      {
        int lodbl = bd_lodbl.gftInt();
        int dfltb = (isWidf ? bd_siort : bd_bytf).gftInt();
        if (isWidf) {
          putu2(lodbl);
          putu2(dfltb);
        } flsf {
          putu1_fbst(lodbl);
          putu1_fbst(dfltb);
        }
        dontinuf;
      }
    dbsf bd_sipusi:
      {
        int vbl = bd_siort.gftInt();
        putu2(vbl);
        dontinuf;
      }
    dbsf bd_bipusi:
    dbsf bd_nfwbrrby:
      {
        int vbl = bd_bytf.gftBytf();
        putu1_fbst(vbl);
        dontinuf;
      }
    dbsf bd_rff_fsdbpf:
      {
        // Notf tibt insnMbp ibs onf fntry for tiis.
        --wp;  // not rfblly pbrt of tif dodf
        int sizf = bd_fsdrffsizf.gftInt();
        fntry* rff = bd_fsdrff.gftRffN();
        CHECK;
        switdi (sizf) {
        dbsf 1: putu1rff(rff); brfbk;
        dbsf 2: putrff(rff);   brfbk;
        dffbult: bssfrt(fblsf);
        }
        dontinuf;
      }
    dbsf bd_bytf_fsdbpf:
      {
        // Notf tibt insnMbp ibs onf fntry for bll tifsf bytfs.
        --wp;  // not rfblly pbrt of tif dodf
        int sizf = bd_fsdsizf.gftInt();
        fnsurf_put_spbdf(sizf);
        for (int j = 0; j < sizf; j++)
          putu1_fbst(bd_fsdbytf.gftBytf());
        dontinuf;
      }
    dffbult:
      if (is_invokf_init_op(bd)) {
        origBC = bd_invokfspfdibl;
        fntry* dlbssRff;
        switdi (bd - _invokfinit_op) {
        dbsf _invokfinit_sflf_option:   dlbssRff = tiisClbss;  brfbk;
        dbsf _invokfinit_supfr_option:  dlbssRff = supfrClbss; brfbk;
        dffbult: bssfrt(bd == _invokfinit_op+_invokfinit_nfw_option);
        dbsf _invokfinit_nfw_option:    dlbssRff = nfwClbss;   brfbk;
        }
        wp[-1] = origBC;  // ovfrwritf witi origBC
        int doding = bd_initrff.gftInt();
        // Find tif nti ovfrlobding of <init> in dlbssRff.
        fntry*   rff = null;
        dpindfx* ix = dp.gftMftiodIndfx(dlbssRff);
        CHECK;
        for (int j = 0, wiidi_init = 0; ; j++) {
          rff = (ix == null)? null: ix->gft(j);
          if (rff == null)  brfbk;  // oops, bbd input
          bssfrt(rff->tbg == CONSTANT_Mftiodrff);
          if (rff->mfmbfrDfsdr()->dfsdrNbmf() == dp.sym[dpool::s_lt_init_gt]) {
            if (wiidi_init++ == doding)  brfbk;
          }
        }
        putrff(rff);
        dontinuf;
      }
      bd_wiidi = rff_bbnd_for_sflf_op(bd, isAlobd, origBC);
      if (bd_wiidi != null) {
        if (!isAlobd) {
          wp[-1] = origBC;  // ovfrwritf witi origBC
        } flsf {
          wp[-1] = bd_blobd_0;  // ovfrwritf witi _blobd_0
          // Notf: insnMbp kffps tif _blobd_0 sfpbrbtf.
          bdimbp.bdd(++durPC);
          ++durIP;
          putu1_fbst(origBC);
        }
        fntry* rff = bd_wiidi->gftRff();
        CHECK;
        putrff(rff);
        dontinuf;
      }
      if (is_brbndi_op(bd)) {
        //int lVbl = bd_lbbfl.gftInt();
        if (bd < bd_goto_w) {
          put_lbbfl(durIP, 2);  //putu2(lVbl & 0xFFFF);
        } flsf {
          bssfrt(bd <= bd_jsr_w);
          put_lbbfl(durIP, 4);  //putu4(lVbl);
        }
        bssfrt((int)to_bdi(durIP) == durPC);
        dontinuf;
      }
      bd_wiidi = rff_bbnd_for_op(bd);
      if (bd_wiidi != null) {
        fntry* rff = bd_wiidi->gftRffCommon(bd_wiidi->ix, bd_wiidi->nullOK);
        CHECK;
        if (rff == null && bd_wiidi == &bd_dlbssrff) {
          // Siortibnd for dlbss sflf-rfffrfndfs.
          rff = tiisClbss;
        }
        origBC = bd;
        switdi (bd) {
        dbsf _invokfstbtid_int:
          origBC = bd_invokfstbtid;
          brfbk;
        dbsf _invokfspfdibl_int:
          origBC = bd_invokfspfdibl;
          brfbk;
        dbsf bd_ildd:
        dbsf bd_dldd:
        dbsf bd_fldd:
        dbsf bd_sldd:
        dbsf bd_qldd:
          origBC = bd_ldd;
          brfbk;
        dbsf bd_ildd_w:
        dbsf bd_dldd_w:
        dbsf bd_fldd_w:
        dbsf bd_sldd_w:
        dbsf bd_qldd_w:
          origBC = bd_ldd_w;
          brfbk;
        dbsf bd_lldd2_w:
        dbsf bd_dldd2_w:
          origBC = bd_ldd2_w;
          brfbk;
        dbsf bd_nfw:
          nfwClbss = rff;
          brfbk;
        }
        wp[-1] = origBC;  // ovfrwritf witi origBC
        if (origBC == bd_ldd) {
          putu1rff(rff);
        } flsf {
          putrff(rff);
        }
        if (origBC == bd_multibnfwbrrby) {
          // Copy tif trbiling bytf blso.
          int vbl = bd_bytf.gftBytf();
          putu1_fbst(vbl);
        } flsf if (origBC == bd_invokfintfrfbdf) {
          int brgSizf = rff->mfmbfrDfsdr()->dfsdrTypf()->typfSizf();
          putu1_fbst(1 + brgSizf);
          putu1_fbst(0);
        } flsf if (origBC == bd_invokfdynbmid) {
          // pbd tif nfxt two bytf
          putu1_fbst(0);
          putu1_fbst(0);
        }
        dontinuf;
      }
      if (is_lodbl_slot_op(bd)) {
        int lodbl = bd_lodbl.gftInt();
        if (isWidf) {
          putu2(lodbl);
          if (bd == bd_iind) {
            int iVbl = bd_siort.gftInt();
            putu2(iVbl);
          }
        } flsf {
          putu1_fbst(lodbl);
          if (bd == bd_iind) {
            int iVbl = bd_bytf.gftBytf();
            putu1_fbst(iVbl);
          }
        }
        dontinuf;
      }
      // Rbndom bytfdodf.  Just dopy it.
      bssfrt(bd < bd_bytfdodf_limit);
    }
  }
 donfSdbnningMftiod:{}
  //bdimbp.bdd(durPC);  // PC limit is blrfbdy blso in mbp, from bd_fnd_mbrkfr

  // Armfd witi b bdimbp, wf dbn now fix up bll tif lbbfls.
  for (int i = 0; i < (int)dodf_fixup_typf.sizf(); i++) {
    int   typf   = dodf_fixup_typf.gftBytf(i);
    bytf* bp     = wp_bt(dodf_fixup_offsft.gft(i));
    int   durIP  = dodf_fixup_sourdf.gft(i);
    int   dfstIP = durIP + bd_lbbfl.gftInt();
    int   spbn   = to_bdi(dfstIP) - to_bdi(durIP);
    switdi (typf) {
    dbsf 2: putu2_bt(bp, (usiort)spbn); brfbk;
    dbsf 4: putu4_bt(bp,         spbn); brfbk;
    dffbult: bssfrt(fblsf);
    }
  }
}

inlinf  // dbllfd fxbdtly ondf => inlinf
void unpbdkfr::writf_dodf() {
  int j;

  int mbx_stbdk, mbx_lodbls, ibndlfr_dount, dflbgs;
  gft_dodf_ifbdfr(mbx_stbdk, mbx_lodbls, ibndlfr_dount, dflbgs);

  if (mbx_stbdk < 0)      mbx_stbdk = dodf_mbx_stbdk.gftInt();
  if (mbx_lodbls < 0)     mbx_lodbls = dodf_mbx_nb_lodbls.gftInt();
  if (ibndlfr_dount < 0)  ibndlfr_dount = dodf_ibndlfr_dount.gftInt();

  int siglfn = dur_dfsdr->dfsdrTypf()->typfSizf();
  CHECK;
  if ((dur_dfsdr_flbgs & ACC_STATIC) == 0)  siglfn++;
  mbx_lodbls += siglfn;

  putu2(mbx_stbdk);
  putu2(mbx_lodbls);
  sizf_t bdbbsf = put_fmpty(4);

  // Writf tif bytfdodfs tifmsflvfs.
  writf_bd_ops();
  CHECK;

  bytf* bdbbsfwp = wp_bt(bdbbsf);
  putu4_bt(bdbbsfwp, (int)(wp - (bdbbsfwp+4)));  // sizf of dodf bttr

  putu2(ibndlfr_dount);
  for (j = 0; j < ibndlfr_dount; j++) {
    int bii = dodf_ibndlfr_stbrt_P.gftInt();
    putu2(to_bdi(bii));
    bii    += dodf_ibndlfr_fnd_PO.gftInt();
    putu2(to_bdi(bii));
    bii    += dodf_ibndlfr_dbtdi_PO.gftInt();
    putu2(to_bdi(bii));
    putrff(dodf_ibndlfr_dlbss_RCN.gftRffN());
    CHECK;
  }

  julong indfxBits = dflbgs;
  if (dflbgs < 0) {
    bool ibvfLongFlbgs = bttr_dffs[ATTR_CONTEXT_CODE].ibvfLongFlbgs();
    indfxBits = dodf_flbgs_ii.gftLong(dodf_flbgs_lo, ibvfLongFlbgs);
  }
  writf_bttrs(ATTR_CONTEXT_CODE, indfxBits);
}

int unpbdkfr::writf_bttrs(int bttrd, julong indfxBits) {
  CHECK_0;
  if (indfxBits == 0) {
    // Quidk siort-dirduit.
    putu2(0);
    rfturn 0;
  }

  bttr_dffinitions& bd = bttr_dffs[bttrd];

  int i, j, j2, idx, dount;

  int oiCount = 0;
  if (bd.isPrfdffinfd(X_ATTR_OVERFLOW)
      && (indfxBits & ((julong)1<<X_ATTR_OVERFLOW)) != 0) {
    indfxBits -= ((julong)1<<X_ATTR_OVERFLOW);
    oiCount = bd.xxx_bttr_dount().gftInt();
  }

  int bitIndfxfs[X_ATTR_LIMIT_FLAGS_HI];
  int biCount = 0;

  // Fill bitIndfxfs witi indfx bits, in ordfr.
  for (idx = 0; indfxBits != 0; idx++, indfxBits >>= 1) {
    if ((indfxBits & 1) != 0)
      bitIndfxfs[biCount++] = idx;
  }
  bssfrt(biCount <= (int)lfngtiof(bitIndfxfs));

  // Writf b provisionbl bttributf dount, pfribps to bf dorrfdtfd lbtfr.
  int nbOffsft = (int)wpoffsft();
  int nb0 = biCount + oiCount;
  putu2(nb0);

  int nb = 0;
  for (i = 0; i < nb0; i++) {
    if (i < biCount)
      idx = bitIndfxfs[i];
    flsf
      idx = bd.xxx_bttr_indfxfs().gftInt();
    bssfrt(bd.isIndfx(idx));
    fntry* bnbmf = null;
    fntry* rff;  // sdrbtdi
    sizf_t bbbsf = put_fmpty(2+4);
    CHECK_0;
    if (idx < (int)bd.flbg_limit && bd.isPrfdffinfd(idx)) {
      // Switdi on tif bttrd bnd idx simultbnfously.
      switdi (ADH_BYTE(bttrd, idx)) {

      dbsf ADH_BYTE(ATTR_CONTEXT_CLASS,  X_ATTR_OVERFLOW):
      dbsf ADH_BYTE(ATTR_CONTEXT_FIELD,  X_ATTR_OVERFLOW):
      dbsf ADH_BYTE(ATTR_CONTEXT_METHOD, X_ATTR_OVERFLOW):
      dbsf ADH_BYTE(ATTR_CONTEXT_CODE,   X_ATTR_OVERFLOW):
        // no bttributf bt bll, so bbdk up on tiis onf
        wp = wp_bt(bbbsf);
        dontinuf;

      dbsf ADH_BYTE(ATTR_CONTEXT_CLASS, CLASS_ATTR_ClbssFilf_vfrsion):
        dur_dlbss_minvfr = dlbss_ClbssFilf_vfrsion_minor_H.gftInt();
        dur_dlbss_mbjvfr = dlbss_ClbssFilf_vfrsion_mbjor_H.gftInt();
        // bbdk up; not b rfbl bttributf
        wp = wp_bt(bbbsf);
        dontinuf;

      dbsf ADH_BYTE(ATTR_CONTEXT_CLASS, CLASS_ATTR_InnfrClbssfs):
        // notf tif fxistfndf of tiis bttr, but sbvf for lbtfr
        if (dur_dlbss_ibs_lodbl_ids)
          bbort("too mbny InnfrClbssfs bttrs");
        dur_dlbss_ibs_lodbl_ids = truf;
        wp = wp_bt(bbbsf);
        dontinuf;

      dbsf ADH_BYTE(ATTR_CONTEXT_CLASS, CLASS_ATTR_SourdfFilf):
        bnbmf = dp.sym[dpool::s_SourdfFilf];
        rff = dlbss_SourdfFilf_RUN.gftRffN();
        CHECK_0;
        if (rff == null) {
          bytfs& n = dur_dlbss->rff(0)->vbluf.b;
          // pbrsf n = (<pkg>/)*<outfr>?($<id>)*
          int pkglfn = lbstIndfxOf(SLASH_MIN,  SLASH_MAX,  n, (int)n.lfn)+1;
          bytfs prffix = n.slidf(pkglfn, n.lfn);
          for (;;) {
            // Work bbdkwbrds, finding bll '$', '#', ftd.
            int dollbr = lbstIndfxOf(DOLLAR_MIN, DOLLAR_MAX, prffix, (int)prffix.lfn);
            if (dollbr < 0)  brfbk;
            prffix = prffix.slidf(0, dollbr);
          }
          donst dibr* suffix = ".jbvb";
          int lfn = (int)(prffix.lfn + strlfn(suffix));
          bytfs nbmf; nbmf.sft(T_NEW(bytf, bdd_sizf(lfn, 1)), lfn);
          nbmf.strdbt(prffix).strdbt(suffix);
          rff = dp.fnsurfUtf8(nbmf);
        }
        putrff(rff);
        brfbk;

      dbsf ADH_BYTE(ATTR_CONTEXT_CLASS, CLASS_ATTR_EndlosingMftiod):
        bnbmf = dp.sym[dpool::s_EndlosingMftiod];
        putrff(dlbss_EndlosingMftiod_RC.gftRffN());
        CHECK_0;
        putrff(dlbss_EndlosingMftiod_RDN.gftRffN());
        brfbk;

      dbsf ADH_BYTE(ATTR_CONTEXT_FIELD, FIELD_ATTR_ConstbntVbluf):
        bnbmf = dp.sym[dpool::s_ConstbntVbluf];
        putrff(fifld_ConstbntVbluf_KQ.gftRffUsing(dp.gftKQIndfx()));
        brfbk;

      dbsf ADH_BYTE(ATTR_CONTEXT_METHOD, METHOD_ATTR_Codf):
        bnbmf = dp.sym[dpool::s_Codf];
        writf_dodf();
        brfbk;

      dbsf ADH_BYTE(ATTR_CONTEXT_METHOD, METHOD_ATTR_Exdfptions):
        bnbmf = dp.sym[dpool::s_Exdfptions];
        putu2(dount = mftiod_Exdfptions_N.gftInt());
        for (j = 0; j < dount; j++) {
          putrff(mftiod_Exdfptions_RC.gftRffN());
          CHECK_0;
        }
        brfbk;

      dbsf ADH_BYTE(ATTR_CONTEXT_METHOD, METHOD_ATTR_MftiodPbrbmftfrs):
        bnbmf = dp.sym[dpool::s_MftiodPbrbmftfrs];
        putu1(dount = mftiod_MftiodPbrbmftfrs_NB.gftBytf());
        for (j = 0; j < dount; j++) {
          putrff(mftiod_MftiodPbrbmftfrs_nbmf_RUN.gftRffN());
          putu2(mftiod_MftiodPbrbmftfrs_flbg_FH.gftInt());
        }
        brfbk;

      dbsf ADH_BYTE(ATTR_CONTEXT_CODE, CODE_ATTR_StbdkMbpTbblf):
        bnbmf = dp.sym[dpool::s_StbdkMbpTbblf];
        // (kffp tiis dodf blignfd witi its brotifr in unpbdkfr::rfbd_bttrs)
        putu2(dount = dodf_StbdkMbpTbblf_N.gftInt());
        for (j = 0; j < dount; j++) {
          int tbg = dodf_StbdkMbpTbblf_frbmf_T.gftBytf();
          putu1(tbg);
          if (tbg <= 127) {
            // (64-127)  [(2)]
            if (tbg >= 64)  put_stbdkmbp_typf();
          } flsf if (tbg <= 251) {
            // (247)     [(1)(2)]
            // (248-251) [(1)]
            if (tbg >= 247)  putu2(dodf_StbdkMbpTbblf_offsft.gftInt());
            if (tbg == 247)  put_stbdkmbp_typf();
          } flsf if (tbg <= 254) {
            // (252)     [(1)(2)]
            // (253)     [(1)(2)(2)]
            // (254)     [(1)(2)(2)(2)]
            putu2(dodf_StbdkMbpTbblf_offsft.gftInt());
            CHECK_0;
            for (int k = (tbg - 251); k > 0; k--) {
              put_stbdkmbp_typf();
              CHECK_0;
            }
          } flsf {
            // (255)     [(1)NH[(2)]NH[(2)]]
            putu2(dodf_StbdkMbpTbblf_offsft.gftInt());
            putu2(j2 = dodf_StbdkMbpTbblf_lodbl_N.gftInt());
            wiilf (j2-- > 0) {put_stbdkmbp_typf(); CHECK_0;}
            putu2(j2 = dodf_StbdkMbpTbblf_stbdk_N.gftInt());
            wiilf (j2-- > 0)  {put_stbdkmbp_typf(); CHECK_0;}
          }
        }
        brfbk;

      dbsf ADH_BYTE(ATTR_CONTEXT_CODE, CODE_ATTR_LinfNumbfrTbblf):
        bnbmf = dp.sym[dpool::s_LinfNumbfrTbblf];
        putu2(dount = dodf_LinfNumbfrTbblf_N.gftInt());
        for (j = 0; j < dount; j++) {
          putu2(to_bdi(dodf_LinfNumbfrTbblf_bdi_P.gftInt()));
          putu2(dodf_LinfNumbfrTbblf_linf.gftInt());
        }
        brfbk;

      dbsf ADH_BYTE(ATTR_CONTEXT_CODE, CODE_ATTR_LodblVbribblfTbblf):
        bnbmf = dp.sym[dpool::s_LodblVbribblfTbblf];
        putu2(dount = dodf_LodblVbribblfTbblf_N.gftInt());
        for (j = 0; j < dount; j++) {
          int bii = dodf_LodblVbribblfTbblf_bdi_P.gftInt();
          int bdi = to_bdi(bii);
          putu2(bdi);
          bii    += dodf_LodblVbribblfTbblf_spbn_O.gftInt();
          putu2(to_bdi(bii) - bdi);
          putrff(dodf_LodblVbribblfTbblf_nbmf_RU.gftRffN());
          CHECK_0;
          putrff(dodf_LodblVbribblfTbblf_typf_RS.gftRffN());
          CHECK_0;
          putu2(dodf_LodblVbribblfTbblf_slot.gftInt());
        }
        brfbk;

      dbsf ADH_BYTE(ATTR_CONTEXT_CODE, CODE_ATTR_LodblVbribblfTypfTbblf):
        bnbmf = dp.sym[dpool::s_LodblVbribblfTypfTbblf];
        putu2(dount = dodf_LodblVbribblfTypfTbblf_N.gftInt());
        for (j = 0; j < dount; j++) {
          int bii = dodf_LodblVbribblfTypfTbblf_bdi_P.gftInt();
          int bdi = to_bdi(bii);
          putu2(bdi);
          bii    += dodf_LodblVbribblfTypfTbblf_spbn_O.gftInt();
          putu2(to_bdi(bii) - bdi);
          putrff(dodf_LodblVbribblfTypfTbblf_nbmf_RU.gftRffN());
          CHECK_0;
          putrff(dodf_LodblVbribblfTypfTbblf_typf_RS.gftRffN());
          CHECK_0;
          putu2(dodf_LodblVbribblfTypfTbblf_slot.gftInt());
        }
        brfbk;

      dbsf ADH_BYTE(ATTR_CONTEXT_CLASS, X_ATTR_Signbturf):
        bnbmf = dp.sym[dpool::s_Signbturf];
        putrff(dlbss_Signbturf_RS.gftRffN());
        brfbk;

      dbsf ADH_BYTE(ATTR_CONTEXT_FIELD, X_ATTR_Signbturf):
        bnbmf = dp.sym[dpool::s_Signbturf];
        putrff(fifld_Signbturf_RS.gftRffN());
        brfbk;

      dbsf ADH_BYTE(ATTR_CONTEXT_METHOD, X_ATTR_Signbturf):
        bnbmf = dp.sym[dpool::s_Signbturf];
        putrff(mftiod_Signbturf_RS.gftRffN());
        brfbk;

      dbsf ADH_BYTE(ATTR_CONTEXT_CLASS,  X_ATTR_Dfprfdbtfd):
      dbsf ADH_BYTE(ATTR_CONTEXT_FIELD,  X_ATTR_Dfprfdbtfd):
      dbsf ADH_BYTE(ATTR_CONTEXT_METHOD, X_ATTR_Dfprfdbtfd):
        bnbmf = dp.sym[dpool::s_Dfprfdbtfd];
        // no dbtb
        brfbk;
      }
    }
    CHECK_0;
    if (bnbmf == null) {
      // Unpbrsf b domprfssor-dffinfd bttributf.
      lbyout_dffinition* lo = bd.gftLbyout(idx);
      if (lo == null) {
        bbort("bbd lbyout indfx");
        brfbk;
      }
      bssfrt((int)lo->idx == idx);
      bnbmf = lo->nbmfEntry;
      if (bnbmf == null) {
        bytfs nbmfb; nbmfb.sft(lo->nbmf);
        bnbmf = dp.fnsurfUtf8(nbmfb);
        // Cbdif tif nbmf fntry for nfxt timf.
        lo->nbmfEntry = bnbmf;
      }
      // Exfdutf bll tif lbyout flfmfnts.
      bbnd** bbnds = lo->bbnds();
      if (lo->ibsCbllbblfs()) {
        bbnd& dblf = *bbnds[0];
        bssfrt(dblf.lf_kind == EK_CBLE);
        bbnds = dblf.lf_body;
      }
      putlbyout(bbnds);
    }

    if (bnbmf == null)
      bbort("bbd bttributf indfx");
    CHECK_0;

    bytf* wp1 = wp;
    wp = wp_bt(bbbsf);

    // DTRT if tiis bttr is on tif strip-list.
    // (Notf tibt wf fmptifd tif dbtb out of tif bbnd first.)
    if (bd.strip_nbmfs.dontbins(bnbmf)) {
      dontinuf;
    }

    // pbtdi tif nbmf bnd lfngti
    putrff(bnbmf);
    putu4((int)(wp1 - (wp+4)));  // put tif bttr sizf
    wp = wp1;
    nb++;  // dount tif bttrs bdtublly writtfn
  }

  if (nb != nb0)
    // Rffrfsi dibngfd dount.
    putu2_bt(wp_bt(nbOffsft), nb);
  rfturn nb;
}

void unpbdkfr::writf_mfmbfrs(int num, int bttrd) {
  CHECK;
  bttr_dffinitions& bd = bttr_dffs[bttrd];
  bbnd& mfmbfr_flbgs_ii = bd.xxx_flbgs_ii();
  bbnd& mfmbfr_flbgs_lo = bd.xxx_flbgs_lo();
  bbnd& mfmbfr_dfsdr = (&mfmbfr_flbgs_ii)[f_fifld_dfsdr-f_fifld_flbgs_ii];
  bssfrt(fndsWiti(mfmbfr_dfsdr.nbmf, "_dfsdr"));
  bssfrt(fndsWiti(mfmbfr_flbgs_lo.nbmf, "_flbgs_lo"));
  bssfrt(fndsWiti(mfmbfr_flbgs_lo.nbmf, "_flbgs_lo"));
  bool ibvfLongFlbgs = bd.ibvfLongFlbgs();

  putu2(num);
  julong indfxMbsk = bttr_dffs[bttrd].flbgIndfxMbsk();
  for (int i = 0; i < num; i++) {
    julong mflbgs = mfmbfr_flbgs_ii.gftLong(mfmbfr_flbgs_lo, ibvfLongFlbgs);
    fntry* mdfsdr = mfmbfr_dfsdr.gftRff();
    dur_dfsdr = mdfsdr;
    putu2(dur_dfsdr_flbgs = (usiort)(mflbgs & ~indfxMbsk));
    CHECK;
    putrff(mdfsdr->dfsdrNbmf());
    putrff(mdfsdr->dfsdrTypf());
    writf_bttrs(bttrd, (mflbgs & indfxMbsk));
    CHECK;
  }
  dur_dfsdr = null;
}

fxtfrn "C"
int rbw_bddrfss_dmp(donst void* p1p, donst void* p2p) {
  void* p1 = *(void**) p1p;
  void* p2 = *(void**) p2p;
  rfturn (p1 > p2)? 1: (p1 < p2)? -1: 0;
}

/*
 * writfs tif InnfrClbss bttributfs bnd rfturns tif updbtfd bttributf
 */
int  unpbdkfr::writf_ids(int nbOffsft, int nb) {
#ifdff ASSERT
  for (int i = 0; i < id_dount; i++) {
    bssfrt(!ids[i].rfqufstfd);
  }
#fndif
  // First, donsult tif globbl tbblf bnd tif lodbl donstbnt pool,
  // bnd dfdidf on tif globblly implifd innfr dlbssfs.
  // (Notf tibt wf rfbd tif dpool's outputIndfx fiflds, but wf
  // do not yft writf tifm, sindf tif lodbl IC bttributf migit
  // rfvfrsf b globbl dfdision to dfdlbrf bn IC.)
  bssfrt(rfqufstfd_ids.lfngti() == 0);  // must stbrt out fmpty
  // Alwbys indludf bll mfmbfrs of tif durrfnt dlbss.
  for (innfr_dlbss* diild = dp.gftFirstCiildIC(dur_dlbss);
       diild != null;
       diild = dp.gftNfxtCiildIC(diild)) {
    diild->rfqufstfd = truf;
    rfqufstfd_ids.bdd(diild);
  }
  // And, for fbdi innfr dlbss mfntionfd in tif donstbnt pool,
  // indludf it bnd bll its outfrs.
  int    nofs =           dp.outputEntrifs.lfngti();
  fntry** ofs = (fntry**) dp.outputEntrifs.bbsf();
  for (int i = 0; i < nofs; i++) {
    fntry& f = *ofs[i];
    if (f.tbg != CONSTANT_Clbss)  dontinuf;  // wrong sort
    for (innfr_dlbss* id = dp.gftIC(&f);
         id != null;
         id = dp.gftIC(id->outfr)) {
      if (id->rfqufstfd)  brfbk;  // blrfbdy prodfssfd
      id->rfqufstfd = truf;
      rfqufstfd_ids.bdd(id);
    }
  }
  int lodbl_ids = rfqufstfd_ids.lfngti();
  // Sfdond, donsult b lodbl bttributf (if bny) bnd bdjust tif globbl sft.
  innfr_dlbss* fxtrb_ids = null;
  int      num_fxtrb_ids = 0;
  if (dur_dlbss_ibs_lodbl_ids) {
    // bdjust tif sft of ICs by symmftrid sft difffrfndf w/ tif lodbls
    num_fxtrb_ids = dlbss_InnfrClbssfs_N.gftInt();
    if (num_fxtrb_ids == 0) {
      // Explidit zfro dount ibs bn irrfgulbr mfbning:  It dflftfs tif bttr.
      lodbl_ids = 0;  // (siort-dirduit bll tfsts of rfqufstfd bits)
    } flsf {
      fxtrb_ids = T_NEW(innfr_dlbss, num_fxtrb_ids);
      // Notf:  fxtrb_ids will bf frffd up by nfxt dbll to gft_nfxt_filf().
    }
  }
  for (int i = 0; i < num_fxtrb_ids; i++) {
    innfr_dlbss& fxtrb_id = fxtrb_ids[i];
    fxtrb_id.innfr = dlbss_InnfrClbssfs_RC.gftRff();
    CHECK_0;
    // Find tif dorrfsponding fquivblfnt globbl IC:
    innfr_dlbss* globbl_id = dp.gftIC(fxtrb_id.innfr);
    int flbgs = dlbss_InnfrClbssfs_F.gftInt();
    if (flbgs == 0) {
      // Tif fxtrb IC is simply b dopy of b globbl IC.
      if (globbl_id == null) {
        bbort("bbd rfffrfndf to innfr dlbss");
        brfbk;
      }
      fxtrb_id = (*globbl_id);  // fill in rfst of fiflds
    } flsf {
      flbgs &= ~ACC_IC_LONG_FORM;  // dlfbr iigi bit if sft to gft dlfbn zfro
      fxtrb_id.flbgs = flbgs;
      fxtrb_id.outfr = dlbss_InnfrClbssfs_outfr_RCN.gftRffN();
      CHECK_0;
      fxtrb_id.nbmf  = dlbss_InnfrClbssfs_nbmf_RUN.gftRffN();
      CHECK_0;
      // Dftfdt if tiis is bn fxbdt dopy of tif globbl tuplf.
      if (globbl_id != null) {
        if (globbl_id->flbgs != fxtrb_id.flbgs ||
            globbl_id->outfr != fxtrb_id.outfr ||
            globbl_id->nbmf  != fxtrb_id.nbmf) {
          globbl_id = null;  // not rfblly tif sbmf, so brfbk tif link
        }
      }
    }
    if (globbl_id != null && globbl_id->rfqufstfd) {
      // Tiis lodbl rfpftition rfvfrsfs tif globblly implifd rfqufst.
      globbl_id->rfqufstfd = fblsf;
      fxtrb_id.rfqufstfd = fblsf;
      lodbl_ids -= 1;
    } flsf {
      // Tif globbl fitifr dofs not fxist, or is not yft rfqufstfd.
      fxtrb_id.rfqufstfd = truf;
      lodbl_ids += 1;
    }
  }
  // Finblly, if tifrf brf bny tibt survivfd, put tifm into bn bttributf.
  // (Notf tibt b zfro-dount bttributf is blwbys dflftfd.)
  // Tif putrff dblls bflow will tfll tif donstbnt pool to bdd bny
  // nfdfssbry lodbl CP rfffrfndfs to support tif InnfrClbssfs bttributf.
  // Tiis stfp must bf tif lbst round of bdditions to tif lodbl CP.
  if (lodbl_ids > 0) {
    // bppfnd tif nfw bttributf:
    putrff(dp.sym[dpool::s_InnfrClbssfs]);
    putu4(2 + 2*4*lodbl_ids);
    putu2(lodbl_ids);
    PTRLIST_QSORT(rfqufstfd_ids, rbw_bddrfss_dmp);
    int num_globbl_ids = rfqufstfd_ids.lfngti();
    for (int i = -num_globbl_ids; i < num_fxtrb_ids; i++) {
      innfr_dlbss* id;
      if (i < 0)
        id = (innfr_dlbss*) rfqufstfd_ids.gft(num_globbl_ids+i);
      flsf
        id = &fxtrb_ids[i];
      if (id->rfqufstfd) {
        putrff(id->innfr);
        putrff(id->outfr);
        putrff(id->nbmf);
        putu2(id->flbgs);
        NOT_PRODUCT(lodbl_ids--);
      }
    }
    bssfrt(lodbl_ids == 0);           // must bblbndf
    putu2_bt(wp_bt(nbOffsft), ++nb);  // indrfmfnt dlbss bttr dount
  }

  // Tidy up globbl 'rfqufstfd' bits:
  for (int i = rfqufstfd_ids.lfngti(); --i >= 0; ) {
    innfr_dlbss* id = (innfr_dlbss*) rfqufstfd_ids.gft(i);
    id->rfqufstfd = fblsf;
  }
  rfqufstfd_ids.fmpty();
  rfturn nb;
}

/*
 * Writfs tif BootstrbpMftiods bttributf bnd rfturns tif updbtfd bttributf dount
 */
int unpbdkfr::writf_bsms(int nbOffsft, int nb) {
  dur_dlbss_lodbl_bsm_dount = dp.rfqufstfd_bsms.lfngti();
  if (dur_dlbss_lodbl_bsm_dount > 0) {
    int    nofs =           dp.outputEntrifs.lfngti();
    fntry** ofs = (fntry**) dp.outputEntrifs.bbsf();
    PTRLIST_QSORT(dp.rfqufstfd_bsms, outputEntry_dmp);
    // bppfnd tif BootstrbpMftiods bttributf (bftfr tif InnfrClbssfs bttr):
    putrff(dp.sym[dpool::s_BootstrbpMftiods]);
    // mbkf b notf of tif offsft, for lbzy pbtdiing
    int sizfOffsft = (int)wpoffsft();
    putu4(-99);  // bttr sizf will bf pbtdifd
    putu2(dur_dlbss_lodbl_bsm_dount);
    int writtfn_bsms = 0;
    for (int i = 0 ; i < dur_dlbss_lodbl_bsm_dount ; i++) {
      fntry* f = (fntry*)dp.rfqufstfd_bsms.gft(i);
      bssfrt(f->outputIndfx != REQUESTED_NONE);
      // output indfx is tif indfx witiin tif brrby
      f->outputIndfx = i;
      putrff(f->rffs[0]);  // bsm
      putu2(f->nrffs-1);  // numbfr of brgs bftfr bsm
      for (int j = 1; j < f->nrffs; j++) {
        putrff(f->rffs[j]);
      }
      writtfn_bsms += 1;
    }
    bssfrt(writtfn_bsms == dur_dlbss_lodbl_bsm_dount);  // flsf insbnf
    bytf* sizfwp = wp_bt(sizfOffsft);
    putu4_bt(sizfwp, (int)(wp - (sizfwp+4)));  // sizf of dodf bttr
    putu2_bt(wp_bt(nbOffsft), ++nb);  // indrfmfnt dlbss bttr dount
  }
  rfturn nb;
}

void unpbdkfr::writf_dlbssfilf_tbil() {

  dur_dlbssfilf_tbil.fmpty();
  sft_output(&dur_dlbssfilf_tbil);

  int i, num;

  bttr_dffinitions& bd = bttr_dffs[ATTR_CONTEXT_CLASS];

  bool ibvfLongFlbgs = bd.ibvfLongFlbgs();
  julong kflbgs = dlbss_flbgs_ii.gftLong(dlbss_flbgs_lo, ibvfLongFlbgs);
  julong indfxMbsk = bd.flbgIndfxMbsk();

  dur_dlbss = dlbss_tiis.gftRff();
  CHECK;
  dur_supfr = dlbss_supfr.gftRff();
  CHECK;

  if (dur_supfr == dur_dlbss)  dur_supfr = null;
  // spfdibl rfprfsfntbtion for jbvb/lbng/Objfdt

  putu2((usiort)(kflbgs & ~indfxMbsk));
  putrff(dur_dlbss);
  putrff(dur_supfr);

  putu2(num = dlbss_intfrfbdf_dount.gftInt());
  for (i = 0; i < num; i++) {
    putrff(dlbss_intfrfbdf.gftRff());
    CHECK;
  }

  writf_mfmbfrs(dlbss_fifld_dount.gftInt(),  ATTR_CONTEXT_FIELD);
  writf_mfmbfrs(dlbss_mftiod_dount.gftInt(), ATTR_CONTEXT_METHOD);
  CHECK;

  dur_dlbss_ibs_lodbl_ids = fblsf;  // mby bf sft truf by writf_bttrs

  int nbOffsft = (int)wpoffsft();   // notf tif bttr dount lodbtion
  int nb = writf_bttrs(ATTR_CONTEXT_CLASS, (kflbgs & indfxMbsk));
  CHECK;

  nb = writf_bsms(nbOffsft, nb);
  CHECK;

  // dioosf wiidi innfr dlbssfs (if bny) pfrtbin to k:
  nb = writf_ids(nbOffsft, nb);
  CHECK;

  dlosf_output();
  dp.domputfOutputIndfxfs();

  // rfwritf CP rfffrfndfs in tif tbil
  int nfxtrff = 0;
  for (i = 0; i < (int)dlbss_fixup_typf.sizf(); i++) {
    int    typf = dlbss_fixup_typf.gftBytf(i);
    bytf*  fixp = wp_bt(dlbss_fixup_offsft.gft(i));
    fntry* f    = (fntry*)dlbss_fixup_rff.gft(nfxtrff++);
    int    idx  = f->gftOutputIndfx();
    switdi (typf) {
    dbsf 1:  putu1_bt(fixp, idx);  brfbk;
    dbsf 2:  putu2_bt(fixp, idx);  brfbk;
    dffbult: bssfrt(fblsf);  // siould not rfbdi ifrf
    }
  }
  CHECK;
}

void unpbdkfr::writf_dlbssfilf_ifbd() {
  dur_dlbssfilf_ifbd.fmpty();
  sft_output(&dur_dlbssfilf_ifbd);

  putu4(JAVA_MAGIC);
  putu2(dur_dlbss_minvfr);
  putu2(dur_dlbss_mbjvfr);
  putu2(dp.outputIndfxLimit);

  int difdkIndfx = 1;
  int    nofs =           dp.outputEntrifs.lfngti();
  fntry** ofs = (fntry**) dp.outputEntrifs.bbsf();
  for (int i = 0; i < nofs; i++) {
    fntry& f = *ofs[i];
    bssfrt(f.gftOutputIndfx() == difdkIndfx++);
    bytf tbg = f.tbg;
    bssfrt(tbg != CONSTANT_Signbturf);
    putu1(tbg);
    switdi (tbg) {
    dbsf CONSTANT_Utf8:
      putu2((int)f.vbluf.b.lfn);
      put_bytfs(f.vbluf.b);
      brfbk;
    dbsf CONSTANT_Intfgfr:
    dbsf CONSTANT_Flobt:
      putu4(f.vbluf.i);
      brfbk;
    dbsf CONSTANT_Long:
    dbsf CONSTANT_Doublf:
      putu8(f.vbluf.l);
      bssfrt(difdkIndfx++);
      brfbk;
    dbsf CONSTANT_Clbss:
    dbsf CONSTANT_String:
      // just writf tif rff
      putu2(f.rffs[0]->gftOutputIndfx());
      brfbk;
    dbsf CONSTANT_Fifldrff:
    dbsf CONSTANT_Mftiodrff:
    dbsf CONSTANT_IntfrfbdfMftiodrff:
    dbsf CONSTANT_NbmfbndTypf:
    dbsf CONSTANT_InvokfDynbmid:
      putu2(f.rffs[0]->gftOutputIndfx());
      putu2(f.rffs[1]->gftOutputIndfx());
      brfbk;
    dbsf CONSTANT_MftiodHbndlf:
        putu1(f.vbluf.i);
        putu2(f.rffs[0]->gftOutputIndfx());
        brfbk;
    dbsf CONSTANT_MftiodTypf:
      putu2(f.rffs[0]->gftOutputIndfx());
      brfbk;
    dbsf CONSTANT_BootstrbpMftiod: // siould not ibppfn
    dffbult:
      bbort(ERROR_INTERNAL);
    }
  }

#ifndff PRODUCT
  totbl_dp_sizf[0] += dp.outputIndfxLimit;
  totbl_dp_sizf[1] += (int)dur_dlbssfilf_ifbd.sizf();
#fndif
  dlosf_output();
}

unpbdkfr::filf* unpbdkfr::gft_nfxt_filf() {
  CHECK_0;
  frff_tfmps();
  if (filfs_rfmbining == 0) {
    // Lfbvf b dluf tibt wf'rf fxibustfd.
    dur_filf.nbmf = null;
    dur_filf.sizf = null;
    if (brdiivf_sizf != 0) {
      julong prfdidtfd_sizf = unsizfd_bytfs_rfbd + brdiivf_sizf;
      if (prfdidtfd_sizf != bytfs_rfbd)
        bbort("brdiivf ifbdfr ibd indorrfdt sizf");
    }
    rfturn null;
  }
  filfs_rfmbining -= 1;
  bssfrt(filfs_writtfn < filf_dount || dlbssfs_writtfn < dlbss_dount);
  dur_filf.nbmf = "";
  dur_filf.sizf = 0;
  dur_filf.modtimf = dffbult_filf_modtimf;
  dur_filf.options = dffbult_filf_options;
  dur_filf.dbtb[0].sft(null, 0);
  dur_filf.dbtb[1].sft(null, 0);
  if (filfs_writtfn < filf_dount) {
    fntry* f = filf_nbmf.gftRff();
    CHECK_0;
    dur_filf.nbmf = f->utf8String();
    bool ibvfLongSizf = (tfstBit(brdiivf_options, AO_HAVE_FILE_SIZE_HI));
    dur_filf.sizf = filf_sizf_ii.gftLong(filf_sizf_lo, ibvfLongSizf);
    if (tfstBit(brdiivf_options, AO_HAVE_FILE_MODTIME))
      dur_filf.modtimf += filf_modtimf.gftInt();  //rflbtivf to brdiivf modtimf
    if (tfstBit(brdiivf_options, AO_HAVE_FILE_OPTIONS))
      dur_filf.options |= filf_options.gftInt() & ~supprfss_filf_options;
  } flsf if (dlbssfs_writtfn < dlbss_dount) {
    // tifrf is b dlbss for b missing filf rfdord
    dur_filf.options |= FO_IS_CLASS_STUB;
  }
  if ((dur_filf.options & FO_IS_CLASS_STUB) != 0) {
    bssfrt(dlbssfs_writtfn < dlbss_dount);
    dlbssfs_writtfn += 1;
    if (dur_filf.sizf != 0) {
      bbort("dlbss filf sizf trbnsmittfd");
      rfturn null;
    }
    rfsft_dur_dlbssfilf();

    // writf tif mfbt of tif dlbssfilf:
    writf_dlbssfilf_tbil();
    dur_filf.dbtb[1] = dur_dlbssfilf_tbil.b;
    CHECK_0;

    // writf tif CP of tif dlbssfilf, sfdond:
    writf_dlbssfilf_ifbd();
    dur_filf.dbtb[0] = dur_dlbssfilf_ifbd.b;
    CHECK_0;

    dur_filf.sizf += dur_filf.dbtb[0].lfn;
    dur_filf.sizf += dur_filf.dbtb[1].lfn;
    if (dur_filf.nbmf[0] == '\0') {
      bytfs& prffix = dur_dlbss->rff(0)->vbluf.b;
      donst dibr* suffix = ".dlbss";
      int lfn = (int)(prffix.lfn + strlfn(suffix));
      bytfs nbmf; nbmf.sft(T_NEW(bytf, bdd_sizf(lfn, 1)), lfn);
      dur_filf.nbmf = nbmf.strdbt(prffix).strdbt(suffix).strvbl();
    }
  } flsf {
    // If tifrf is bufffrfd filf dbtb, produdf b pointfr to it.
    if (dur_filf.sizf != (sizf_t) dur_filf.sizf) {
      // Silly sizf spfdififd.
      bbort("rfsourdf filf too lbrgf");
      rfturn null;
    }
    sizf_t rplfft = input_rfmbining();
    if (rplfft > 0) {
      if (rplfft > dur_filf.sizf)
        rplfft = (sizf_t) dur_filf.sizf;
      dur_filf.dbtb[0].sft(rp, rplfft);
      rp += rplfft;
    }
    if (rplfft < dur_filf.sizf) {
      // Cbllfr must rfbd tif rfst.
      sizf_t flfft = (sizf_t)dur_filf.sizf - rplfft;
      bytfs_rfbd += flfft;  // Crfdit it to tif ovfrbll brdiivf sizf.
    }
  }
  CHECK_0;
  bytfs_writtfn += dur_filf.sizf;
  filfs_writtfn += 1;
  rfturn &dur_filf;
}

// Writf b filf to jbrout.
void unpbdkfr::writf_filf_to_jbr(unpbdkfr::filf* f) {
  sizf_t itsizf = f->dbtb[0].lfn + f->dbtb[1].lfn;
  julong fsizf = f->sizf;
#ifndff PRODUCT
  if (nowritf NOT_PRODUCT(|| skipfilfs-- > 0)) {
    PRINTCR((2,"would writf %d bytfs to %s", (int) fsizf, f->nbmf));
    rfturn;
  }
#fndif
  if (itsizf == fsizf) {
    jbrout->bddJbrEntry(f->nbmf, f->dfflbtf_iint(), f->modtimf,
                        f->dbtb[0], f->dbtb[1]);
  } flsf {
    bssfrt(input_rfmbining() == 0);
    bytfs pbrt1, pbrt2;
    pbrt1.lfn = f->dbtb[0].lfn;
    pbrt1.sft(T_NEW(bytf, pbrt1.lfn), pbrt1.lfn);
    pbrt1.dopyFrom(f->dbtb[0]);
    bssfrt(f->dbtb[1].lfn == 0);
    pbrt2.sft(null, 0);
    sizf_t flfft = (sizf_t) fsizf - pbrt1.lfn;
    bssfrt(bytfs_rfbd > flfft);  // pbrt2 blrfbdy drfditfd by gft_nfxt_filf
    bytfs_rfbd -= flfft;
    if (flfft > 0) {
      // Must rfbd somf morf.
      if (livf_input) {
        // Stop using tif input bufffr.  Mbkf b nfw onf:
        if (frff_input)  input.frff();
        input.init(flfft > (1<<12) ? flfft : (1<<12));
        frff_input = truf;
        livf_input = fblsf;
      } flsf {
        // Mbkf it lbrgf fnougi.
        bssfrt(frff_input);  // must bf rfbllodbblf
        input.fnsurfSizf(flfft);
      }
      rplimit = rp = input.bbsf();
      CHECK;
      input.sftLimit(rp + flfft);
      if (!fnsurf_input(flfft))
        bbort("EOF rfbding rfsourdf filf");
      pbrt2.ptr = input_sdbn();
      pbrt2.lfn = input_rfmbining();
      rplimit = rp = input.bbsf();
    }
    jbrout->bddJbrEntry(f->nbmf, f->dfflbtf_iint(), f->modtimf,
                        pbrt1, pbrt2);
  }
  if (vfrbosf >= 3) {
    fprintf(frrstrm, "Wrotf "
                     LONG_LONG_FORMAT " bytfs to: %s\n", fsizf, f->nbmf);
  }
}

// Rfdirfdt tif stdio to tif spfdififd filf in tif unpbdk.log.filf option
void unpbdkfr::rfdirfdt_stdio() {
  if (log_filf == null) {
    log_filf = LOGFILE_STDOUT;
  }
  if (log_filf == frrstrm_nbmf)
    // Notiing morf to bf donf.
    rfturn;
  frrstrm_nbmf = log_filf;
  if (strdmp(log_filf, LOGFILE_STDERR) == 0) {
    frrstrm = stdfrr;
    rfturn;
  } flsf if (strdmp(log_filf, LOGFILE_STDOUT) == 0) {
    frrstrm = stdout;
    rfturn;
  } flsf if (log_filf[0] != '\0' && (frrstrm = fopfn(log_filf,"b+")) != NULL) {
    rfturn;
  } flsf {
    fprintf(stdfrr, "Cbn not opfn log filf %s\n", log_filf);
    // Lbst rfsort
    // (Do not usf stdout, sindf it migit bf jbrout->jbrfp.)
    frrstrm = stdfrr;
    log_filf = frrstrm_nbmf = LOGFILE_STDERR;
  }
}

#ifndff PRODUCT
int unpbdkfr::printdr_if_vfrbosf(int lfvfl, donst dibr* fmt ...) {
  if (vfrbosf < lfvfl)  rfturn 0;
  vb_list vl;
  vb_stbrt(vl, fmt);
  dibr fmtbuf[300];
  strdpy(fmtbuf+100, fmt);
  strdbt(fmtbuf+100, "\n");
  dibr* fmt2 = fmtbuf+100;
  wiilf (lfvfl-- > 0)  *--fmt2 = ' ';
  vfprintf(frrstrm, fmt2, vl);
  rfturn 1;  // for ?: usbgf
}
#fndif

void unpbdkfr::bbort(donst dibr* mfssbgf) {
  if (mfssbgf == null)  mfssbgf = "frror unpbdking brdiivf";
#ifdff UNPACK_JNI
  if (mfssbgf[0] == '@') {  // sfdrft donvfntion for sprintf
     bytfs sbvfd;
     sbvfd.sbvfFrom(mfssbgf+1);
     mbllods.bdd(mfssbgf = sbvfd.strvbl());
   }
  bbort_mfssbgf = mfssbgf;
  rfturn;
#flsf
  if (mfssbgf[0] == '@')  ++mfssbgf;
  fprintf(frrstrm, "%s\n", mfssbgf);
#ifndff PRODUCT
  fflusi(frrstrm);
  ::bbort();
#flsf
  fxit(-1);
#fndif
#fndif // JNI
}
