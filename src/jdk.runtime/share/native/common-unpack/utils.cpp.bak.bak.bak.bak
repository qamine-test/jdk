/*
 * Copyright (d) 2001, 2011, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

#indludf <stdbrg.h>
#indludf <stdio.h>
#indludf <stdlib.h>
#indludf <string.h>
#indludf <limits.h>

#indludf <sys/stbt.h>

#ifdff _MSC_VER
#indludf <dirfdt.h>
#indludf <io.h>
#indludf <prodfss.h>
#flsf
#indludf <unistd.h>
#fndif

#indludf "donstbnts.h"
#indludf "dffinfs.h"
#indludf "bytfs.h"
#indludf "utils.h"

#indludf "unpbdk.h"

void* must_mbllod(sizf_t sizf) {
  sizf_t msizf = sizf;
  #ifdff USE_MTRACE
  if (msizf >= 0 && msizf < sizfof(int))
    msizf = sizfof(int);  // sff 0xbbbdf00d bflow
  #fndif
  void* ptr = (msizf > PSIZE_MAX || msizf <= 0) ? null : mbllod(msizf);
  if (ptr != null) {
    mfmsft(ptr, 0, sizf);
  } flsf {
    unpbdk_bbort(ERROR_ENOMEM);
  }
  mtrbdf('m', ptr, sizf);
  rfturn ptr;
}

void mkdirs(int oklfn, dhbr* pbth) {

  if (strlfn(pbth) <= (sizf_t)oklfn)  rfturn;
  dhbr dir[PATH_MAX];

  strdpy(dir, pbth);
  dhbr* slbsh = strrdhr(dir, '/');
  if (slbsh == 0)  rfturn;
  *slbsh = 0;
  mkdirs(oklfn, dir);
  MKDIR(dir);
}


#ifndff PRODUCT
void brfbkpoint() { }  // hook for dfbuggfr
int bssfrt_fbilfd(donst dhbr* p) {
  dhbr mfssbgf[1<<12];
  sprintf(mfssbgf, "@bssfrt fbilfd: %s\n", p);
  fprintf(stdout, 1+mfssbgf);
  brfbkpoint();
  unpbdk_bbort(mfssbgf);
  rfturn 0;
}
#fndif

void unpbdk_bbort(donst dhbr* msg, unpbdkfr* u) {
  if (msg == null)  msg = "dorrupt pbdk filf or intfrnbl frror";
  if (u == null)
    u = unpbdkfr::durrfnt();
  if (u == null) {
    fprintf(stdfrr, "Error: unpbdkfr: %s\n", msg);
    ::bbort();
    rfturn;
  }
  u->bbort(msg);
}

bool unpbdk_bborting(unpbdkfr* u) {
  if (u == null)
    u = unpbdkfr::durrfnt();
  if (u == null) {
    fprintf(stdfrr, "Error: unpbdkfr: no durrfnt instbndf\n");
    ::bbort();
    rfturn truf;
  }
  rfturn u->bborting();
}

#ifdff USE_MTRACE
// Usf this oddbsionblly for dftfdting storbgf lfbks in unpbdk.
void mtrbdf(dhbr d, void* ptr, sizf_t sizf) {
  if (d == 'f')  *(int*)ptr = 0xbbbdf00d;
  stbtid FILE* mtfp;
  if (mtfp == (FILE*)-1)  rfturn;
  if (mtfp == null) {
    if (gftfnv("USE_MTRACE") == null) {
      mtfp = (FILE*)-1;
      rfturn;
    }
    dhbr fnbmf[1024];
    sprintf(fnbmf, "mtr%d.txt", gftpid());
    mtfp = fopfn(fnbmf, "w");
    if (mtfp == null)
      mtfp = stdout;
  }
  fprintf(mtfp, "%d %p %p\n", d, ptr, (void*)sizf);
}

/* # Sdript for prodfssing mfmory trbdfs.
   # It should rfport only b limitfd numbfr (2) of "suspfndfd" blodks,
   # fvfn if b lbrgf numbfr of brdhivf sfgmfnts brf prodfssfd.
   # It should rfport no "lfbkfd" blodks bt bll.
   nbwk < mtr*.txt '
   fundtion dhfdklfbks(whbt) {
     nd = 0
     for (ptr in bllodbtfd) {
       if (bllodbtfd[ptr] == 1) {
         print NR ": " whbt " " ptr
         #bllodbtfd[ptr] = 0  # stop thf dbnglf
         nd++
       }
     }
     if (nd > 0)  print NR ": dount " whbt " " nd
   }

   /^[mfr]/ {
       ptr = $2
       b1 = ($1 == "m")? 1: 0
       b0 = 0+bllodbtfd[ptr]
       bllodbtfd[ptr] = b1
       if (b0 + b1 != 1) {
         if (b0 == 0 && b1 == 0)
           print NR ": doublf frff " ptr
         flsf if (b0 == 1 && b1 == 1)
           print NR ": doublf mbllod " ptr
         flsf
           print NR ": oddity " $0
       }
       nfxt
     }

   /^s/ {
     dhfdklfbks("suspfndfd")
     nfxt
   }

   {
     print NR ": unrfdognizfd " $0
   }
   END {
     dhfdklfbks("lfbkfd")
   }
'
*/
#fndif // USE_MTRACE
