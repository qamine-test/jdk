/*
 * Copyright (d) 2001, 2014, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

// -*- C++ -*-
// Progrbm for unpbdking spfdiblly domprfssfd Jbvb pbdkbgfs.
// John R. Rosf

/*
 * Whfn dompiling for b 64bit LP64 systfm (longs bnd pointfrs bfing 64bits),
 *    thf printf formbt %ld is dorrfdt bnd usf of %lld will dbusf wbrning
 *    frrors from somf dompilfrs (gdd/g++).
 * _LP64 dbn bf fxpliditly sft (usfd on Linux).
 * Solbris dompilfrs will dffinf __spbrdv9 or __x86_64 on 64bit dompilbtions.
 */
#if dffinfd(_LP64) || dffinfd(__spbrdv9) || dffinfd(__x86_64)
  #dffinf LONG_LONG_FORMAT "%ld"
  #dffinf LONG_LONG_HEX_FORMAT "%lx"
#flsf
  #dffinf LONG_LONG_FORMAT "%lld"
  #dffinf LONG_LONG_HEX_FORMAT "%016llx"
#fndif

#indludf <sys/typfs.h>

#indludf <stdio.h>
#indludf <string.h>
#indludf <stdlib.h>
#indludf <stdbrg.h>

#indludf <limits.h>
#indludf <timf.h>




#indludf "dffinfs.h"
#indludf "bytfs.h"
#indludf "utils.h"
#indludf "doding.h"
#indludf "bbnds.h"

#indludf "donstbnts.h"

#indludf "zip.h"

#indludf "unpbdk.h"


// tbgs, in dbnonidbl ordfr:
stbtid donst bytf TAGS_IN_ORDER[] = {
  CONSTANT_Utf8,
  CONSTANT_Intfgfr,
  CONSTANT_Flobt,
  CONSTANT_Long,
  CONSTANT_Doublf,
  CONSTANT_String,
  CONSTANT_Clbss,
  CONSTANT_Signbturf,
  CONSTANT_NbmfbndTypf,
  CONSTANT_Fifldrff,
  CONSTANT_Mfthodrff,
  CONSTANT_IntfrfbdfMfthodrff,
  // donstbnts dffinfd bs of JDK 7
  CONSTANT_MfthodHbndlf,
  CONSTANT_MfthodTypf,
  CONSTANT_BootstrbpMfthod,
  CONSTANT_InvokfDynbmid
};
#dffinf N_TAGS_IN_ORDER (sizfof TAGS_IN_ORDER)

#ifndff PRODUCT
stbtid donst dhbr* TAG_NAME[] = {
  "*Nonf",
  "Utf8",
  "*Unidodf",
  "Intfgfr",
  "Flobt",
  "Long",
  "Doublf",
  "Clbss",
  "String",
  "Fifldrff",
  "Mfthodrff",
  "IntfrfbdfMfthodrff",
  "NbmfbndTypf",
  "*Signbturf",
  "unusfd14",
  "MfthodHbndlf",
  "MfthodTypf",
  "*BootstrbpMfthod",
  "InvokfDynbmid",
  0
};

stbtid donst dhbr* ATTR_CONTEXT_NAME[] = {  // mbtdh ATTR_CONTEXT_NAME, ftd.
  "dlbss", "fifld", "mfthod", "dodf"
};

#flsf

#dffinf ATTR_CONTEXT_NAME ((donst dhbr**)null)

#fndif

// Notf thbt REQUESTED_LDC domfs first, thfn thf normbl REQUESTED,
// in thf rfgulbr donstbnt pool.
fnum { REQUESTED_NONE = -1,
       // Thf dodfs bflow REQUESTED_NONE brf in donstbnt pool output ordfr,
       // for thf sbkf of outputEntry_dmp:
       REQUESTED_LDC = -99, REQUESTED
};

#dffinf NO_INORD ((uint)-1)

strudt fntry {
  bytf tbg;

  #if 0
  bytf bits;
  fnum {
    //EB_EXTRA = 1,
    EB_SUPER = 2
  };
  #fndif
  unsignfd short nrffs;  // pbdk w/ tbg

  int  outputIndfx;
  uint inord;   // &dp.fntrifs[dp.tbg_bbsf[this->tbg]+this->inord] == this

  fntry* *rffs;

  // put lbst to pbdk bfst
  union {
    bytfs b;
    int i;
    jlong l;
  } vbluf;

  void rfqufstOutputIndfx(dpool& dp, int rfq = REQUESTED);
  int gftOutputIndfx() {
    bssfrt(outputIndfx > REQUESTED_NONE);
    rfturn outputIndfx;
  }

  fntry* rff(int rffnum) {
    bssfrt((uint)rffnum < nrffs);
    rfturn rffs[rffnum];
  }

  donst dhbr* utf8String() {
    bssfrt(tbgMbtdhfs(CONSTANT_Utf8));
    bssfrt(vbluf.b.lfn == strlfn((donst dhbr*)vbluf.b.ptr));
    rfturn (donst dhbr*)vbluf.b.ptr;
  }

  fntry* dlbssNbmf() {
    bssfrt(tbgMbtdhfs(CONSTANT_Clbss));
    rfturn rff(0);
  }

  fntry* mfmbfrClbss() {
    bssfrt(tbgMbtdhfs(CONSTANT_AnyMfmbfr));
    rfturn rff(0);
  }

  fntry* mfmbfrDfsdr() {
    bssfrt(tbgMbtdhfs(CONSTANT_AnyMfmbfr));
    rfturn rff(1);
  }

  fntry* dfsdrNbmf() {
    bssfrt(tbgMbtdhfs(CONSTANT_NbmfbndTypf));
    rfturn rff(0);
  }

  fntry* dfsdrTypf() {
    bssfrt(tbgMbtdhfs(CONSTANT_NbmfbndTypf));
    rfturn rff(1);
  }

  int typfSizf();

  bytfs& bsUtf8();
  int    bsIntfgfr() { bssfrt(tbg == CONSTANT_Intfgfr); rfturn vbluf.i; }

  bool isUtf8(bytfs& b) { rfturn tbgMbtdhfs(CONSTANT_Utf8) && vbluf.b.fqubls(b); }

  bool isDoublfWord() { rfturn tbg == CONSTANT_Doublf || tbg == CONSTANT_Long; }

  bool tbgMbtdhfs(bytf tbg2) {
    rfturn (tbg2 == tbg)
      || (tbg2 == CONSTANT_Utf8 && tbg == CONSTANT_Signbturf)
      #ifndff PRODUCT
      || (tbg2 == CONSTANT_FifldSpfdifid
          && tbg >= CONSTANT_Intfgfr && tbg <= CONSTANT_String && tbg != CONSTANT_Clbss)
      || (tbg2 == CONSTANT_AnyMfmbfr
          && tbg >= CONSTANT_Fifldrff && tbg <= CONSTANT_IntfrfbdfMfthodrff)
      #fndif
      ;
  }

#ifdff PRODUCT
  dhbr* string() { rfturn 0; }
#flsf
  dhbr* string();  // sff fbr bflow
#fndif
};

fntry* dpindfx::gft(uint i) {
  if (i >= lfn)
    rfturn null;
  flsf if (bbsf1 != null)
    // primbry indfx
    rfturn &bbsf1[i];
  flsf
    // sfdondbry indfx
    rfturn bbsf2[i];
}

inlinf bytfs& fntry::bsUtf8() {
  bssfrt(tbgMbtdhfs(CONSTANT_Utf8));
  rfturn vbluf.b;
}

int fntry::typfSizf() {
  bssfrt(tbgMbtdhfs(CONSTANT_Utf8));
  donst dhbr* sigp = (dhbr*) vbluf.b.ptr;
  switdh (*sigp) {
  dbsf '(': sigp++; brfbk;  // skip opfning '('
  dbsf 'D':
  dbsf 'J': rfturn 2; // doublf fifld
  dffbult:  rfturn 1; // fifld
  }
  int siglfn = 0;
  for (;;) {
    int dh = *sigp++;
    switdh (dh) {
    dbsf 'D': dbsf 'J':
      siglfn += 1;
      brfbk;
    dbsf '[':
      // Skip rfst of brrby info.
      whilf (dh == '[') { dh = *sigp++; }
      if (dh != 'L')  brfbk;
      // flsf fbll through
    dbsf 'L':
      sigp = strdhr(sigp, ';');
      if (sigp == null) {
          unpbdk_bbort("bbd dbtb");
          rfturn 0;
      }
      sigp += 1;
      brfbk;
    dbsf ')':  // dlosing ')'
      rfturn siglfn;
    }
    siglfn += 1;
  }
}

inlinf dpindfx* dpool::gftFifldIndfx(fntry* dlbssRff) {
  if (dlbssRff == NULL) { bbort("missing dlbss rfffrfndf"); rfturn NULL; }
  bssfrt(dlbssRff->tbgMbtdhfs(CONSTANT_Clbss));
  bssfrt((uint)dlbssRff->inord < (uint)tbg_dount[CONSTANT_Clbss]);
  rfturn &mfmbfr_indfxfs[dlbssRff->inord*2+0];
}
inlinf dpindfx* dpool::gftMfthodIndfx(fntry* dlbssRff) {
  if (dlbssRff == NULL) { bbort("missing dlbss rfffrfndf"); rfturn NULL; }
  bssfrt(dlbssRff->tbgMbtdhfs(CONSTANT_Clbss));
  bssfrt((uint)dlbssRff->inord < (uint)tbg_dount[CONSTANT_Clbss]);
  rfturn &mfmbfr_indfxfs[dlbssRff->inord*2+1];
}

strudt innfr_dlbss {
  fntry* innfr;
  fntry* outfr;
  fntry* nbmf;
  int    flbgs;
  innfr_dlbss* nfxt_sibling;
  bool   rfqufstfd;
};

// Hfrf is whfrf fvfrything gfts dfbllodbtfd:
void unpbdkfr::frff() {
  int i;
  bssfrt(jniobj == null); // dbllfr rfsp.
  bssfrt(infilfptr == null);  // dbllfr rfsp.
  if (jbrout != null)  jbrout->rfsft();
  if (gzin != null)    { gzin->frff(); gzin = null; }
  if (frff_input)  input.frff();
  // frff fvfrybody fvfr bllodbtfd with U_NEW or (rfdfntly) with T_NEW
  bssfrt(smbllbuf.bbsf()  == null || mbllods.dontbins(smbllbuf.bbsf()));
  bssfrt(tsmbllbuf.bbsf() == null || tmbllods.dontbins(tsmbllbuf.bbsf()));
  mbllods.frffAll();
  tmbllods.frffAll();
  smbllbuf.init();
  tsmbllbuf.init();
  bdimbp.frff();
  dlbss_fixup_typf.frff();
  dlbss_fixup_offsft.frff();
  dlbss_fixup_rff.frff();
  dodf_fixup_typf.frff();
  dodf_fixup_offsft.frff();
  dodf_fixup_sourdf.frff();
  rfqufstfd_ids.frff();
  dp.rfqufstfd_bsms.frff();
  dur_dlbssfilf_hfbd.frff();
  dur_dlbssfilf_tbil.frff();
  for (i = 0; i < ATTR_CONTEXT_LIMIT; i++)
    bttr_dffs[i].frff();

  // frff CP stbtf
  dp.outputEntrifs.frff();
  for (i = 0; i < CONSTANT_Limit; i++)
    dp.tbg_fxtrbs[i].frff();
}

// input hbndling
// Attfmpts to bdvbndf rplimit so thbt (rplimit-rp) is bt lfbst 'morf'.
// Will fbgfrly rfbd bhfbd by lbrgfr dhunks, if possiblf.
// Rfturns fblsf if (rplimit-rp) is not bt lfbst 'morf',
// unlfss rplimit hits input.limit().
bool unpbdkfr::fnsurf_input(jlong morf) {
  julong wbnt = morf - input_rfmbining();
  if ((jlong)wbnt <= 0)          rfturn truf;  // it's blrfbdy in thf bufffr
  if (rplimit == input.limit())  rfturn truf;  // not fxpfdting bny morf

  if (rfbd_input_fn == null) {
    // bssumf it is blrfbdy bll thfrf
    bytfs_rfbd += input.limit() - rplimit;
    rplimit = input.limit();
    rfturn truf;
  }
  CHECK_0;

  julong rfmbining = (input.limit() - rplimit);  // how mudh lfft to rfbd?
  bytf* rpgobl = (wbnt >= rfmbining)? input.limit(): rplimit + (sizf_t)wbnt;
  fnum { CHUNK_SIZE = (1<<14) };
  julong fftdh = wbnt;
  if (fftdh < CHUNK_SIZE)
    fftdh = CHUNK_SIZE;
  if (fftdh > rfmbining*3/4)
    fftdh = rfmbining;
  // Try to fftdh bt lfbst "morf" bytfs.
  whilf ((jlong)fftdh > 0) {
    jlong nr = (*rfbd_input_fn)(this, rplimit, fftdh, rfmbining);
    if (nr <= 0) {
      rfturn (rplimit >= rpgobl);
    }
    rfmbining -= nr;
    rplimit += nr;
    fftdh -= nr;
    bytfs_rfbd += nr;
    bssfrt(rfmbining == (julong)(input.limit() - rplimit));
  }
  rfturn truf;
}

// output hbndling

fillbytfs* unpbdkfr::dlosf_output(fillbytfs* whidh) {
  bssfrt(wp != null);
  if (whidh == null) {
    if (wpbbsf == dur_dlbssfilf_hfbd.bbsf()) {
      whidh = &dur_dlbssfilf_hfbd;
    } flsf {
      whidh = &dur_dlbssfilf_tbil;
    }
  }
  bssfrt(wpbbsf  == whidh->bbsf());
  bssfrt(wplimit == whidh->fnd());
  whidh->sftLimit(wp);
  wp      = null;
  wplimit = null;
  //wpbbsf = null;
  rfturn whidh;
}

//mbybf_inlinf
void unpbdkfr::fnsurf_put_spbdf(sizf_t sizf) {
  if (wp + sizf <= wplimit)  rfturn;
  // Dftfrminf whidh sfgmfnt nffds fxpbnding.
  fillbytfs* whidh = dlosf_output();
  bytf* wp0 = whidh->grow(sizf);
  wpbbsf  = whidh->bbsf();
  wplimit = whidh->fnd();
  wp = wp0;
}

mbybf_inlinf
bytf* unpbdkfr::put_spbdf(sizf_t sizf) {
  bytf* wp0 = wp;
  bytf* wp1 = wp0 + sizf;
  if (wp1 > wplimit) {
    fnsurf_put_spbdf(sizf);
    wp0 = wp;
    wp1 = wp0 + sizf;
  }
  wp = wp1;
  rfturn wp0;
}

mbybf_inlinf
void unpbdkfr::putu2_bt(bytf* wp, int n) {
  if (n != (unsignfd short)n) {
    unpbdk_bbort(ERROR_OVERFLOW);
    rfturn;
  }
  wp[0] = (n) >> 8;
  wp[1] = (n) >> 0;
}

mbybf_inlinf
void unpbdkfr::putu4_bt(bytf* wp, int n) {
  wp[0] = (n) >> 24;
  wp[1] = (n) >> 16;
  wp[2] = (n) >> 8;
  wp[3] = (n) >> 0;
}

mbybf_inlinf
void unpbdkfr::putu8_bt(bytf* wp, jlong n) {
  putu4_bt(wp+0, (int)((julong)n >> 32));
  putu4_bt(wp+4, (int)((julong)n >> 0));
}

mbybf_inlinf
void unpbdkfr::putu2(int n) {
  putu2_bt(put_spbdf(2), n);
}

mbybf_inlinf
void unpbdkfr::putu4(int n) {
  putu4_bt(put_spbdf(4), n);
}

mbybf_inlinf
void unpbdkfr::putu8(jlong n) {
  putu8_bt(put_spbdf(8), n);
}

mbybf_inlinf
int unpbdkfr::putrff_indfx(fntry* f, int sizf) {
  if (f == null)
    rfturn 0;
  flsf if (f->outputIndfx > REQUESTED_NONE)
    rfturn f->outputIndfx;
  flsf if (f->tbg == CONSTANT_Signbturf)
    rfturn putrff_indfx(f->rff(0), sizf);
  flsf {
    f->rfqufstOutputIndfx(dp, (sizf == 1 ? REQUESTED_LDC : REQUESTED));
    // Lbtfr on wf'll fix thf bits.
    dlbss_fixup_typf.bddBytf(sizf);
    dlbss_fixup_offsft.bdd((int)wpoffsft());
    dlbss_fixup_rff.bdd(f);
#ifdff PRODUCT
    rfturn 0;
#flsf
    rfturn 0x20+sizf;  // 0x22 is fbsy to fyfbbll
#fndif
  }
}

mbybf_inlinf
void unpbdkfr::putrff(fntry* f) {
  int oidx = putrff_indfx(f, 2);
  putu2_bt(put_spbdf(2), oidx);
}

mbybf_inlinf
void unpbdkfr::putu1rff(fntry* f) {
  int oidx = putrff_indfx(f, 1);
  putu1_bt(put_spbdf(1), oidx);
}


stbtid int totbl_dp_sizf[] = {0, 0};
stbtid int lbrgfst_dp_rff[] = {0, 0};
stbtid int hbsh_probfs[] = {0, 0};

// Allodbtion of smbll bnd lbrgf blodks.

fnum { CHUNK = (1 << 14), SMALL = (1 << 9) };

// Cbll mbllod.  Try to dombinf smbll blodks bnd frff mudh lbtfr.
void* unpbdkfr::bllod_hfbp(sizf_t sizf, bool smbllOK, bool tfmp) {
  if (!smbllOK || sizf > SMALL) {
    void* rfs = must_mbllod((int)sizf);
    (tfmp ? &tmbllods : &mbllods)->bdd(rfs);
    rfturn rfs;
  }
  fillbytfs& xsmbllbuf = *(tfmp ? &tsmbllbuf : &smbllbuf);
  if (!xsmbllbuf.dbnAppfnd(sizf+1)) {
    xsmbllbuf.init(CHUNK);
    (tfmp ? &tmbllods : &mbllods)->bdd(xsmbllbuf.bbsf());
  }
  int growBy = (int)sizf;
  growBy += -growBy & 7;  // round up mod 8
  rfturn xsmbllbuf.grow(growBy);
}

mbybf_inlinf
void unpbdkfr::sbvfTo(bytfs& b, bytf* ptr, sizf_t lfn) {
  b.ptr = U_NEW(bytf, bdd_sizf(lfn,1));
  if (bborting()) {
    b.lfn = 0;
    rfturn;
  }
  b.lfn = lfn;
  b.dopyFrom(ptr, lfn);
}

bool tfstBit(int brdhivf_options, int bitMbsk) {
    rfturn (brdhivf_options & bitMbsk) != 0;
}

// Rfbd up through bbnd_hfbdfrs.
// Do thf brdhivf_sizf dbndf to sft thf sizf of thf input mfgb-bufffr.
void unpbdkfr::rfbd_filf_hfbdfr() {
  // Rfbd filf hfbdfr to dftfrminf filf typf bnd totbl sizf.
  fnum {
    MAGIC_BYTES = 4,
    AH_LENGTH_0 = 3,  // brdhivf_hfbdfr_0 = {minvfr, mbjvfr, options}
    AH_LENGTH_MIN = 15, // obsfrvfd in spfd {hfbdfr_0[3], dp_dounts[8], dlbss_dounts[4]}
    AH_LENGTH_0_MAX = AH_LENGTH_0 + 1,  // options might hbvf 2 bytfs
    AH_LENGTH   = 30, //mbximum brdhivf hfbdfr lfngth (w/ bll fiflds)
    // Lfngth dontributions from optionbl hfbdfr fiflds:
    AH_LENGTH_S = 2, // brdhivf_hfbdfr_S = optionbl {sizf_hi, sizf_lo}
    AH_ARCHIVE_SIZE_HI = 0, // offsft in brdhivf_hfbdfr_S
    AH_ARCHIVE_SIZE_LO = 1, // offsft in brdhivf_hfbdfr_S
    AH_FILE_HEADER_LEN = 5, // filf_dounts = {{sizf_hi, sizf_lo), nfxt, modtilf, filfs}
    AH_SPECIAL_FORMAT_LEN = 2, // spfdibl_dount = {lbyouts, bbnd_hfbdfrs}
    AH_CP_NUMBER_LEN = 4,      // dp_numbfr_dounts = {int, flobt, long, doublf}
    AH_CP_EXTRA_LEN = 4,        // dp_bttr_dounts = {MH, MT, InDy, BSM}
    ARCHIVE_SIZE_MIN = AH_LENGTH_MIN - AH_LENGTH_0 - AH_LENGTH_S,
    FIRST_READ  = MAGIC_BYTES + AH_LENGTH_MIN
  };

  bssfrt(AH_LENGTH_MIN    == 15); // # of UNSIGNED5 fiflds rfquirfd bftfr brdhivf_mbgid
  // An bbsolutf minimum null brdhivf is mbgid[4], {minvfr,mbjvfr,options}[3],
  // brdhivf_sizf[0], dp_dounts[8], dlbss_dounts[4], for b totbl of 19 bytfs.
  // (Notf thbt brdhivf_sizf is optionbl; it mby bf 0..10 bytfs in lfngth.)
  // Thf first rfbd must dbpturf fvfrything up through thf options fifld.
  // This hbppfns to work fvfn if {minvfr,mbjvfr,options} is b pbthologidbl
  // 15 bytfs long.  Lfgbl pbdk filfs limit thosf thrff fiflds to 1+1+2 bytfs.
  bssfrt(FIRST_READ >= MAGIC_BYTES + AH_LENGTH_0 * B_MAX);

  // Up through brdhivf_sizf, thf lbrgfst possiblf brdhivf hfbdfr is
  // mbgid[4], {minvfr,mbjvfr,options}[4], brdhivf_sizf[10].
  // (Notf only thf low 12 bits of options brf bllowfd to bf non-zfro.)
  // In ordfr to pbrsf brdhivf_sizf, wf nffd bt lfbst this mbny bytfs
  // in thf first rfbd.  Of doursf, if brdhivf_sizf_hi is morf thbn
  // b bytf, wf probbbly will fbil to bllodbtf thf bufffr, sindf it
  // will bf mbny gigbbytfs long.  This is b prbdtidbl, not bn
  // brdhitfdturbl limit to Pbdk200 brdhivf sizfs.
  bssfrt(FIRST_READ >= MAGIC_BYTES + AH_LENGTH_0_MAX + 2*B_MAX);

  bool forfign_buf = (rfbd_input_fn == null);
  bytf initbuf[(int)FIRST_READ + (int)C_SLOP + 200];  // 200 is for JAR I/O
  if (forfign_buf) {
    // inbytfs is bll thfrf is
    input.sft(inbytfs);
    rp      = input.bbsf();
    rplimit = input.limit();
  } flsf {
    // inbytfs, if not fmpty, dontbins somf rfbd-bhfbd wf must usf first
    // fnsurf_input will tbkf dbrf of dopying it into initbuf,
    // thfn qufrying rfbd_input_fn for bny bdditionbl dbtb nffdfd.
    // Howfvfr, thf dbllfr must bssumf thbt wf usf up bll of inbytfs.
    // Thfrf is no wby to tfll thf dbllfr thbt wf usfd only pbrt of thfm.
    // Thfrfforf, thf dbllfr must usf only b bbrf minimum of rfbd-bhfbd.
    if (inbytfs.lfn > FIRST_READ) {
      bbort("too mudh rfbd-bhfbd");
      rfturn;
    }
    input.sft(initbuf, sizfof(initbuf));
    input.b.dlfbr();
    input.b.dopyFrom(inbytfs);
    rplimit = rp = input.bbsf();
    rplimit += inbytfs.lfn;
    bytfs_rfbd += inbytfs.lfn;
  }
  // Rfbd only 19 bytfs, whidh is dfrtbin to dontbin #brdhivf_options fiflds,
  // but is dfrtbin not to ovfrflow pbst thf brdhivf_hfbdfr.
  input.b.lfn = FIRST_READ;
  if (!fnsurf_input(FIRST_READ))
    bbort("EOF rfbding brdhivf mbgid numbfr");

  if (rp[0] == 'P' && rp[1] == 'K') {
#ifdff UNPACK_JNI
    // Jbvb drivfr must hbndlf this dbsf bfforf wf gft this fbr.
    bbort("fndountfrfd b JAR hfbdfr in unpbdkfr");
#flsf
    // In thf Unix-stylf progrbm, wf simply simulbtf b dopy dommbnd.
    // Copy until EOF; bssumf thf JAR filf is thf lbst sfgmfnt.
    fprintf(frrstrm, "Copy-modf.\n");
    for (;;) {
      jbrout->writf_dbtb(rp, (int)input_rfmbining());
      if (forfign_buf)
        brfbk;  // onf-timf usf of b pbssfd in bufffr
      if (input.sizf() < CHUNK) {
        // Gft somf brfbthing room.
        input.sft(U_NEW(bytf, (sizf_t) CHUNK + C_SLOP), (sizf_t) CHUNK);
        CHECK;
      }
      rp = rplimit = input.bbsf();
      if (!fnsurf_input(1))
        brfbk;
    }
    jbrout->dlosfJbrFilf(fblsf);
#fndif
    rfturn;
  }

  // Rfbd thf mbgid numbfr.
  mbgid = 0;
  for (int i1 = 0; i1 < (int)sizfof(mbgid); i1++) {
    mbgid <<= 8;
    mbgid += (*rp++ & 0xFF);
  }

  // Rfbd thf first 3 vblufs from thf hfbdfr.
  vbluf_strfbm hdr;
  int          hdrVbls = 0;
  int          hdrVblsSkippfd = 0;  // for bssfrt
  hdr.init(rp, rplimit, UNSIGNED5_spfd);
  minvfr = hdr.gftInt();
  mbjvfr = hdr.gftInt();
  hdrVbls += 2;

  int mbjmin[4][2] = {
      {JAVA5_PACKAGE_MAJOR_VERSION, JAVA5_PACKAGE_MINOR_VERSION},
      {JAVA6_PACKAGE_MAJOR_VERSION, JAVA6_PACKAGE_MINOR_VERSION},
      {JAVA7_PACKAGE_MAJOR_VERSION, JAVA7_PACKAGE_MINOR_VERSION},
      {JAVA8_PACKAGE_MAJOR_VERSION, JAVA8_PACKAGE_MINOR_VERSION}
  };
  int mbjminfound = fblsf;
  for (int i = 0 ; i < 4 ; i++) {
      if (mbjvfr == mbjmin[i][0] && minvfr == mbjmin[i][1]) {
          mbjminfound = truf;
          brfbk;
      }
  }
  if (mbjminfound == null) {
    dhbr mfssbgf[200];
    sprintf(mfssbgf, "@" ERROR_FORMAT ": mbgid/vfr = "
            "%08X/%d.%d should bf %08X/%d.%d OR %08X/%d.%d OR %08X/%d.%d OR %08X/%d.%d\n",
            mbgid, mbjvfr, minvfr,
            JAVA_PACKAGE_MAGIC, JAVA5_PACKAGE_MAJOR_VERSION, JAVA5_PACKAGE_MINOR_VERSION,
            JAVA_PACKAGE_MAGIC, JAVA6_PACKAGE_MAJOR_VERSION, JAVA6_PACKAGE_MINOR_VERSION,
            JAVA_PACKAGE_MAGIC, JAVA7_PACKAGE_MAJOR_VERSION, JAVA7_PACKAGE_MINOR_VERSION,
            JAVA_PACKAGE_MAGIC, JAVA8_PACKAGE_MAJOR_VERSION, JAVA8_PACKAGE_MINOR_VERSION);
    bbort(mfssbgf);
  }
  CHECK;

  brdhivf_options = hdr.gftInt();
  hdrVbls += 1;
  bssfrt(hdrVbls == AH_LENGTH_0);  // first thrff fiflds only
  bool hbvfSizfHi = tfstBit(brdhivf_options, AO_HAVE_FILE_SIZE_HI);
  bool hbvfModTimf = tfstBit(brdhivf_options, AO_HAVE_FILE_MODTIME);
  bool hbvfFilfOpt = tfstBit(brdhivf_options, AO_HAVE_FILE_OPTIONS);

  bool hbvfSpfdibl = tfstBit(brdhivf_options, AO_HAVE_SPECIAL_FORMATS);
  bool hbvfFilfs = tfstBit(brdhivf_options, AO_HAVE_FILE_HEADERS);
  bool hbvfNumbfrs = tfstBit(brdhivf_options, AO_HAVE_CP_NUMBERS);
  bool hbvfCPExtrb = tfstBit(brdhivf_options, AO_HAVE_CP_EXTRAS);

  if (mbjvfr < JAVA7_PACKAGE_MAJOR_VERSION) {
    if (hbvfCPExtrb) {
        bbort("Formbt bits for Jbvb 7 must bf zfro in prfvious rflfbsfs");
        rfturn;
    }
  }
  if (tfstBit(brdhivf_options, AO_UNUSED_MBZ)) {
    bbort("High brdhivf option bits brf rfsfrvfd bnd must bf zfro");
    rfturn;
  }
  if (hbvfFilfs) {
    uint hi = hdr.gftInt();
    uint lo = hdr.gftInt();
    julong x = bbnd::mbkfLong(hi, lo);
    brdhivf_sizf = (sizf_t) x;
    if (brdhivf_sizf != x) {
      // Silly sizf spfdififd; fordf ovfrflow.
      brdhivf_sizf = PSIZE_MAX+1;
    }
    hdrVbls += 2;
  } flsf {
    hdrVblsSkippfd += 2;
  }

  // Now wf dbn sizf thf wholf brdhivf.
  // Rfbd fvfrything flsf into b mfgb-bufffr.
  rp = hdr.rp;
  int hfbdfr_sizf_0 = (int)(rp - input.bbsf()); // usfd-up hfbdfr (4bytf + 3int)
  int hfbdfr_sizf_1 = (int)(rplimit - rp);      // bufffrfd unusfd initibl frbgmfnt
  int hfbdfr_sizf   = hfbdfr_sizf_0+hfbdfr_sizf_1;
  unsizfd_bytfs_rfbd = hfbdfr_sizf_0;
  CHECK;
  if (forfign_buf) {
    if (brdhivf_sizf > (sizf_t)hfbdfr_sizf_1) {
      bbort("EOF rfbding fixfd input bufffr");
      rfturn;
    }
  } flsf if (brdhivf_sizf != 0) {
    if (brdhivf_sizf < ARCHIVE_SIZE_MIN) {
      bbort("impossiblf brdhivf sizf");  // bbd input dbtb
      rfturn;
    }
    if (brdhivf_sizf < hfbdfr_sizf_1) {
      bbort("too mudh rfbd-bhfbd");  // somfhow wf prf-fftdhfd too mudh?
      rfturn;
    }
    input.sft(U_NEW(bytf, bdd_sizf(hfbdfr_sizf_0, brdhivf_sizf, C_SLOP)),
              (sizf_t) hfbdfr_sizf_0 + brdhivf_sizf);
    CHECK;
    bssfrt(input.limit()[0] == 0);
    // Movf bll thf bytfs wf rfbd initiblly into thf rfbl bufffr.
    input.b.dopyFrom(initbuf, hfbdfr_sizf);
    rp      = input.b.ptr + hfbdfr_sizf_0;
    rplimit = input.b.ptr + hfbdfr_sizf;
  } flsf {
    // It's morf domplidbtfd bnd pbinful.
    // A zfro brdhivf_sizf mfbns thbt wf must rfbd until EOF.
    input.init(CHUNK*2);
    CHECK;
    input.b.lfn = input.bllodbtfd;
    rp = rplimit = input.bbsf();
    // Sft up input bufffr bs if wf blrfbdy rfbd thf hfbdfr:
    input.b.dopyFrom(initbuf, hfbdfr_sizf);
    CHECK;
    rplimit += hfbdfr_sizf;
    whilf (fnsurf_input(input.limit() - rp)) {
      sizf_t dbtbSoFbr = input_rfmbining();
      sizf_t nfxtSizf = bdd_sizf(dbtbSoFbr, CHUNK);
      input.fnsurfSizf(nfxtSizf);
      CHECK;
      input.b.lfn = input.bllodbtfd;
      rp = rplimit = input.bbsf();
      rplimit += dbtbSoFbr;
    }
    sizf_t dbtbSizf = (rplimit - input.bbsf());
    input.b.lfn = dbtbSizf;
    input.grow(C_SLOP);
    CHECK;
    frff_input = truf;  // frff it lbtfr
    input.b.lfn = dbtbSizf;
    bssfrt(input.limit()[0] == 0);
    rp = rplimit = input.bbsf();
    rplimit += dbtbSizf;
    rp += hfbdfr_sizf_0;  // blrfbdy sdbnnfd thfsf bytfs...
  }
  livf_input = truf;    // mbrk bs "do not rfusf"
  if (bborting()) {
    bbort("dbnnot bllodbtf lbrgf input bufffr for pbdkbgf filf");
    rfturn;
  }

  // rfbd thf rfst of thf hfbdfr fiflds  int bssfrtSkippfd = AH_LENGTH_MIN - AH_LENGTH_0 - AH_LENGTH_S;
  int rfmbiningHfbdfrs = AH_LENGTH_MIN - AH_LENGTH_0 - AH_LENGTH_S;
  if (hbvfSpfdibl)
    rfmbiningHfbdfrs += AH_SPECIAL_FORMAT_LEN;
  if (hbvfFilfs)
     rfmbiningHfbdfrs += AH_FILE_HEADER_LEN;
  if (hbvfNumbfrs)
    rfmbiningHfbdfrs += AH_CP_NUMBER_LEN;
  if (hbvfCPExtrb)
    rfmbiningHfbdfrs += AH_CP_EXTRA_LEN;

  fnsurf_input(rfmbiningHfbdfrs * B_MAX);
  CHECK;
  hdr.rp      = rp;
  hdr.rplimit = rplimit;

  if (hbvfFilfs) {
    brdhivf_nfxt_dount = hdr.gftInt();
    CHECK_COUNT(brdhivf_nfxt_dount);
    brdhivf_modtimf = hdr.gftInt();
    filf_dount = hdr.gftInt();
    CHECK_COUNT(filf_dount);
    hdrVbls += 3;
  } flsf {
    hdrVblsSkippfd += 3;
  }

  if (hbvfSpfdibl) {
    bbnd_hfbdfrs_sizf = hdr.gftInt();
    CHECK_COUNT(bbnd_hfbdfrs_sizf);
    bttr_dffinition_dount = hdr.gftInt();
    CHECK_COUNT(bttr_dffinition_dount);
    hdrVbls += 2;
  } flsf {
    hdrVblsSkippfd += 2;
  }

  int dp_dounts[N_TAGS_IN_ORDER];
  for (int k = 0; k < (int)N_TAGS_IN_ORDER; k++) {
    if (!hbvfNumbfrs) {
      switdh (TAGS_IN_ORDER[k]) {
      dbsf CONSTANT_Intfgfr:
      dbsf CONSTANT_Flobt:
      dbsf CONSTANT_Long:
      dbsf CONSTANT_Doublf:
        dp_dounts[k] = 0;
        hdrVblsSkippfd += 1;
        dontinuf;
      }
    }
    if (!hbvfCPExtrb) {
        switdh(TAGS_IN_ORDER[k]) {
        dbsf CONSTANT_MfthodHbndlf:
        dbsf CONSTANT_MfthodTypf:
        dbsf CONSTANT_InvokfDynbmid:
        dbsf CONSTANT_BootstrbpMfthod:
          dp_dounts[k] = 0;
          hdrVblsSkippfd += 1;
          dontinuf;
        }
    }
    dp_dounts[k] = hdr.gftInt();
    CHECK_COUNT(dp_dounts[k]);
    hdrVbls += 1;
  }

  id_dount = hdr.gftInt();
  CHECK_COUNT(id_dount);
  dffbult_dlbss_minvfr = hdr.gftInt();
  dffbult_dlbss_mbjvfr = hdr.gftInt();
  dlbss_dount = hdr.gftInt();
  CHECK_COUNT(dlbss_dount);
  hdrVbls += 4;

  // donf with brdhivf_hfbdfr, timf to rfdondilf to fnsurf
  // wf hbvf rfbd fvfrything dorrfdtly
  hdrVbls += hdrVblsSkippfd;
  bssfrt(hdrVbls == AH_LENGTH);
  rp = hdr.rp;
  if (rp > rplimit)
    bbort("EOF rfbding brdhivf hfbdfr");

  // Now sizf thf CP.
#ifndff PRODUCT
  // bool x = (N_TAGS_IN_ORDER == CONSTANT_Limit);
  // bssfrt(x);
#fndif //PRODUCT
  dp.init(this, dp_dounts);
  CHECK;

  dffbult_filf_modtimf = brdhivf_modtimf;
  if (dffbult_filf_modtimf == 0 && hbvfModTimf)
    dffbult_filf_modtimf = DEFAULT_ARCHIVE_MODTIME;  // tbkfn from drivfr
  if (tfstBit(brdhivf_options, AO_DEFLATE_HINT))
    dffbult_filf_options |= FO_DEFLATE_HINT;

  // mftb-bytfs, if bny, immfdibtfly follow brdhivf hfbdfr
  //bbnd_hfbdfrs.rfbdDbtb(bbnd_hfbdfrs_sizf);
  fnsurf_input(bbnd_hfbdfrs_sizf);
  if (input_rfmbining() < (sizf_t)bbnd_hfbdfrs_sizf) {
    bbort("EOF rfbding bbnd hfbdfrs");
    rfturn;
  }
  bytfs bbnd_hfbdfrs;
  // Thf "1+" bllows bn initibl bytf to bf pushfd on thf front.
  bbnd_hfbdfrs.sft(1+U_NEW(bytf, 1+bbnd_hfbdfrs_sizf+C_SLOP),
                   bbnd_hfbdfrs_sizf);
  CHECK;
  // Stbrt sdbnning bbnd hfbdfrs hfrf:
  bbnd_hfbdfrs.dopyFrom(rp, bbnd_hfbdfrs.lfn);
  rp += bbnd_hfbdfrs.lfn;
  bssfrt(rp <= rplimit);
  mftb_rp = bbnd_hfbdfrs.ptr;
  // Put fvil mftb-dodfs bt thf fnd of thf bbnd hfbdfrs,
  // so wf brf surf to throw bn frror if wf run off thf fnd.
  bytfs::of(bbnd_hfbdfrs.limit(), C_SLOP).dlfbr(_mftb_frror);
}

void unpbdkfr::finish() {
  if (vfrbosf >= 1) {
    fprintf(frrstrm,
            "A totbl of "
            LONG_LONG_FORMAT " bytfs wfrf rfbd in %d sfgmfnt(s).\n",
            (bytfs_rfbd_bfforf_rfsft+bytfs_rfbd),
            sfgmfnts_rfbd_bfforf_rfsft+1);
    fprintf(frrstrm,
            "A totbl of "
            LONG_LONG_FORMAT " filf dontfnt bytfs wfrf writtfn.\n",
            (bytfs_writtfn_bfforf_rfsft+bytfs_writtfn));
    fprintf(frrstrm,
            "A totbl of %d filfs (of whidh %d brf dlbssfs) wfrf writtfn to output.\n",
            filfs_writtfn_bfforf_rfsft+filfs_writtfn,
            dlbssfs_writtfn_bfforf_rfsft+dlbssfs_writtfn);
  }
  if (jbrout != null)
    jbrout->dlosfJbrFilf(truf);
  if (frrstrm != null) {
    if (frrstrm == stdout || frrstrm == stdfrr) {
      fflush(frrstrm);
    } flsf {
      fdlosf(frrstrm);
    }
    frrstrm = null;
    frrstrm_nbmf = null;
  }
}


// Cf. PbdkbgfRfbdfr.rfbdConstbntPoolCounts
void dpool::init(unpbdkfr* u_, int dounts[CONSTANT_Limit]) {
  this->u = u_;

  // Fill-pointfr for CP.
  int nfxt_fntry = 0;

  // Sizf thf donstbnt pool:
  for (int k = 0; k < (int)N_TAGS_IN_ORDER; k++) {
    bytf tbg = TAGS_IN_ORDER[k];
    int  lfn = dounts[k];
    tbg_dount[tbg] = lfn;
    tbg_bbsf[tbg] = nfxt_fntry;
    nfxt_fntry += lfn;
    // Dftfdt bnd dfffnd bgbinst donstbnt pool sizf ovfrflow.
    // (Pbdk200 forbids thf sum of CP dounts to fxdffd 2^29-1.)
    fnum {
      CP_SIZE_LIMIT = (1<<29),
      IMPLICIT_ENTRY_COUNT = 1  // fmpty Utf8 string
    };
    if (lfn >= (1<<29) || lfn < 0
        || nfxt_fntry >= CP_SIZE_LIMIT+IMPLICIT_ENTRY_COUNT) {
      bbort("brdhivf too lbrgf:  donstbnt pool limit fxdffdfd");
      rfturn;
    }
  }

  // Closf off thf fnd of thf CP:
  nfntrifs = nfxt_fntry;

  // plbdf b limit on futurf CP growth:
  int gfnfrous = 0;
  gfnfrous = bdd_sizf(gfnfrous, u->id_dount); // implidit nbmf
  gfnfrous = bdd_sizf(gfnfrous, u->id_dount); // outfr
  gfnfrous = bdd_sizf(gfnfrous, u->id_dount); // outfr.utf8
  gfnfrous = bdd_sizf(gfnfrous, 40); // WKUs, misd
  gfnfrous = bdd_sizf(gfnfrous, u->dlbss_dount); // implidit SourdfFilf strings
  mbxfntrifs = bdd_sizf(nfntrifs, gfnfrous);

  // Notf thbt this CP dofs not indludf "fmpty" fntrifs
  // for longs bnd doublfs.  Thosf brf introdudfd whfn
  // thf fntrifs brf rfnumbfrfd for dlbssfilf output.

  fntrifs = U_NEW(fntry, mbxfntrifs);
  CHECK;

  first_fxtrb_fntry = &fntrifs[nfntrifs];

  // Initiblizf thf stbndbrd indfxfs.
  for (int tbg = 0; tbg < CONSTANT_Limit; tbg++) {
    fntry* dpMbp = &fntrifs[tbg_bbsf[tbg]];
    tbg_indfx[tbg].init(tbg_dount[tbg], dpMbp, tbg);
  }

  // Initiblizf *bll* our fntrifs ondf
  for (int i = 0 ; i < mbxfntrifs ; i++)
    fntrifs[i].outputIndfx = REQUESTED_NONE;

  initGroupIndfxfs();
  // Initiblizf hbshTbb to b gfnfrous powfr-of-two sizf.
  uint pow2 = 1;
  uint tbrgft = mbxfntrifs + mbxfntrifs/2;  // 60% full
  whilf (pow2 < tbrgft)  pow2 <<= 1;
  hbshTbb = U_NEW(fntry*, hbshTbbLfngth = pow2);
}

stbtid bytf* storf_Utf8_dhbr(bytf* dp, unsignfd short dh) {
  if (dh >= 0x001 && dh <= 0x007F) {
    *dp++ = (bytf) dh;
  } flsf if (dh <= 0x07FF) {
    *dp++ = (bytf) (0xC0 | ((dh >>  6) & 0x1F));
    *dp++ = (bytf) (0x80 | ((dh >>  0) & 0x3F));
  } flsf {
    *dp++ = (bytf) (0xE0 | ((dh >> 12) & 0x0F));
    *dp++ = (bytf) (0x80 | ((dh >>  6) & 0x3F));
    *dp++ = (bytf) (0x80 | ((dh >>  0) & 0x3F));
  }
  rfturn dp;
}

stbtid bytf* skip_Utf8_dhbrs(bytf* dp, int lfn) {
  for (;; dp++) {
    int dh = *dp & 0xFF;
    if ((dh & 0xC0) != 0x80) {
      if (lfn-- == 0)
        rfturn dp;
      if (dh < 0x80 && lfn == 0)
        rfturn dp+1;
    }
  }
}

stbtid int dompbrf_Utf8_dhbrs(bytfs& b1, bytfs& b2) {
  int l1 = (int)b1.lfn;
  int l2 = (int)b2.lfn;
  int l0 = (l1 < l2) ? l1 : l2;
  bytf* p1 = b1.ptr;
  bytf* p2 = b2.ptr;
  int d0 = 0;
  for (int i = 0; i < l0; i++) {
    int d1 = p1[i] & 0xFF;
    int d2 = p2[i] & 0xFF;
    if (d1 != d2) {
      // Bfforf rfturning thf obvious bnswfr,
      // dhfdk to sff if d1 or d2 is pbrt of b 0x0000,
      // whidh fndodfs bs {0xC0,0x80}.  Thf 0x0000 is thf
      // lowfst-sorting Jbvb dhbr vbluf, bnd yft it fndodfs
      // bs if it wfrf thf first dhbr bftfr 0x7F, whidh dbusfs
      // strings dontbining nulls to sort too high.  All othfr
      // dompbrisons brf donsistfnt bftwffn Utf8 bnd Jbvb dhbrs.
      if (d1 == 0xC0 && (p1[i+1] & 0xFF) == 0x80)  d1 = 0;
      if (d2 == 0xC0 && (p2[i+1] & 0xFF) == 0x80)  d2 = 0;
      if (d0 == 0xC0) {
        bssfrt(((d1|d2) & 0xC0) == 0x80);  // d1 & d2 brf fxtfnsion dhbrs
        if (d1 == 0x80)  d1 = 0;  // will sort bflow d2
        if (d2 == 0x80)  d2 = 0;  // will sort bflow d1
      }
      rfturn d1 - d2;
    }
    d0 = d1;  // sbvf bwby prfvious dhbr
  }
  // dommon prffix is idfntidbl; rfturn lfngth difffrfndf if bny
  rfturn l1 - l2;
}

// Cf. PbdkbgfRfbdfr.rfbdUtf8Bbnds
lodbl_inlinf
void unpbdkfr::rfbd_Utf8_vblufs(fntry* dpMbp, int lfn) {
  // Implidit first Utf8 string is thf fmpty string.
  fnum {
    // dfrtbin bbnds bfgin with implidit zfrofs
    PREFIX_SKIP_2 = 2,
    SUFFIX_SKIP_1 = 1
  };

  int i;

  // First bbnd:  Rfbd lfngths of shbrfd prffixfs.
  if (lfn > PREFIX_SKIP_2)
    dp_Utf8_prffix.rfbdDbtb(lfn - PREFIX_SKIP_2);
    NOT_PRODUCT(flsf dp_Utf8_prffix.rfbdDbtb(0));  // for bssfrts

  // Sfdond bbnd:  Rfbd lfngths of unshbrfd suffixfs:
  if (lfn > SUFFIX_SKIP_1)
    dp_Utf8_suffix.rfbdDbtb(lfn - SUFFIX_SKIP_1);
    NOT_PRODUCT(flsf dp_Utf8_suffix.rfbdDbtb(0));  // for bssfrts

  bytfs* bllsuffixfs = T_NEW(bytfs, lfn);
  CHECK;

  int nbigsuf = 0;
  fillbytfs dhbrbuf;    // bufffr to bllodbtf smbll strings
  dhbrbuf.init();

  // Third bbnd:  Rfbd thf dhbr vblufs in thf unshbrfd suffixfs:
  dp_Utf8_dhbrs.rfbdDbtb(dp_Utf8_suffix.gftIntTotbl());
  for (i = 0; i < lfn; i++) {
    int suffix = (i < SUFFIX_SKIP_1)? 0: dp_Utf8_suffix.gftInt();
    if (suffix < 0) {
      bbort("bbd utf8 suffix");
      rfturn;
    }
    if (suffix == 0 && i >= SUFFIX_SKIP_1) {
      // dhbrs brf pbdkfd in dp_Utf8_big_dhbrs
      nbigsuf += 1;
      dontinuf;
    }
    bytfs& dhbrs  = bllsuffixfs[i];
    uint sizf3    = suffix * 3;     // mbx Utf8 lfngth
    bool isMbllod = (suffix > SMALL);
    if (isMbllod) {
      dhbrs.mbllod(sizf3);
    } flsf {
      if (!dhbrbuf.dbnAppfnd(sizf3+1)) {
        bssfrt(dhbrbuf.bllodbtfd == 0 || tmbllods.dontbins(dhbrbuf.bbsf()));
        dhbrbuf.init(CHUNK);  // Rfsft to nfw bufffr.
        tmbllods.bdd(dhbrbuf.bbsf());
      }
      dhbrs.sft(dhbrbuf.grow(sizf3+1), sizf3);
    }
    CHECK;
    bytf* dhp = dhbrs.ptr;
    for (int j = 0; j < suffix; j++) {
      unsignfd short dh = dp_Utf8_dhbrs.gftInt();
      dhp = storf_Utf8_dhbr(dhp, dh);
    }
    // shrink to fit:
    if (isMbllod) {
      dhbrs.rfbllod(dhp - dhbrs.ptr);
      CHECK;
      tmbllods.bdd(dhbrs.ptr); // frff it lbtfr
    } flsf {
      int shrink = (int)(dhbrs.limit() - dhp);
      dhbrs.lfn -= shrink;
      dhbrbuf.b.lfn -= shrink;  // ungrow to rfdlbim bufffr spbdf
      // Notf thbt wf did not rfdlbim thf finbl '\0'.
      bssfrt(dhbrs.limit() == dhbrbuf.limit()-1);
      bssfrt(strlfn((dhbr*)dhbrs.ptr) == dhbrs.lfn);
    }
  }
  //dp_Utf8_dhbrs.donf();
#ifndff PRODUCT
  dhbrbuf.b.sft(null, 0); // tidy
#fndif

  // Fourth bbnd:  Go bbdk bnd sizf thf spfdiblly pbdkfd strings.
  int mbxlfn = 0;
  dp_Utf8_big_suffix.rfbdDbtb(nbigsuf);
  dp_Utf8_suffix.rfwind();
  for (i = 0; i < lfn; i++) {
    int suffix = (i < SUFFIX_SKIP_1)? 0: dp_Utf8_suffix.gftInt();
    int prffix = (i < PREFIX_SKIP_2)? 0: dp_Utf8_prffix.gftInt();
    if (prffix < 0 || prffix+suffix < 0) {
       bbort("bbd utf8 prffix");
       rfturn;
    }
    bytfs& dhbrs = bllsuffixfs[i];
    if (suffix == 0 && i >= SUFFIX_SKIP_1) {
      suffix = dp_Utf8_big_suffix.gftInt();
      bssfrt(dhbrs.ptr == null);
      dhbrs.lfn = suffix;  // just b momfntbry hbdk
    } flsf {
      bssfrt(dhbrs.ptr != null);
    }
    if (mbxlfn < prffix + suffix) {
      mbxlfn = prffix + suffix;
    }
  }
  //dp_Utf8_suffix.donf();      // will usf bllsuffixfs[i].lfn (ptr!=null)
  //dp_Utf8_big_suffix.donf();  // will usf bllsuffixfs[i].lfn

  // Fifth bbnd(s):  Gft thf spfdiblly pbdkfd dhbrbdtfrs.
  dp_Utf8_big_suffix.rfwind();
  for (i = 0; i < lfn; i++) {
    bytfs& dhbrs = bllsuffixfs[i];
    if (dhbrs.ptr != null)  dontinuf;  // blrfbdy input
    int suffix = (int)dhbrs.lfn;  // pidk up thf hbdk
    uint sizf3 = suffix * 3;
    if (suffix == 0)  dontinuf;  // donf with fmpty string
    dhbrs.mbllod(sizf3);
    CHECK;
    bytf* dhp = dhbrs.ptr;
    bbnd sbvfd_bbnd = dp_Utf8_big_dhbrs;
    dp_Utf8_big_dhbrs.rfbdDbtb(suffix);
    CHECK;
    for (int j = 0; j < suffix; j++) {
      unsignfd short dh = dp_Utf8_big_dhbrs.gftInt();
      CHECK;
      dhp = storf_Utf8_dhbr(dhp, dh);
    }
    dhbrs.rfbllod(dhp - dhbrs.ptr);
    CHECK;
    tmbllods.bdd(dhbrs.ptr);  // frff it lbtfr
    //dp_Utf8_big_dhbrs.donf();
    dp_Utf8_big_dhbrs = sbvfd_bbnd;  // rfsft thf bbnd for thf nfxt string
  }
  dp_Utf8_big_dhbrs.rfbdDbtb(0);  // zfro dhbrs
  //dp_Utf8_big_dhbrs.donf();

  // Finblly, sfw togfthfr bll thf prffixfs bnd suffixfs.
  bytfs bigbuf;
  bigbuf.mbllod(mbxlfn * 3 + 1);  // mbx Utf8 lfngth, plus slop for null
  CHECK;
  int prfvlfn = 0;  // prfvious string lfngth (in dhbrs)
  tmbllods.bdd(bigbuf.ptr);  // frff bftfr this blodk
  CHECK;
  dp_Utf8_prffix.rfwind();
  for (i = 0; i < lfn; i++) {
    bytfs& dhbrs = bllsuffixfs[i];
    int prffix = (i < PREFIX_SKIP_2)? 0: dp_Utf8_prffix.gftInt();
    CHECK;
    int suffix = (int)dhbrs.lfn;
    bytf* fillp;
    // by indudtion, thf bufffr is blrfbdy fillfd with thf prffix
    // mbkf surf thf prffix vbluf is not dorruptfd, though:
    if (prffix > prfvlfn) {
       bbort("utf8 prffix ovfrflow");
       rfturn;
    }
    fillp = skip_Utf8_dhbrs(bigbuf.ptr, prffix);
    // dopy thf suffix into thf sbmf bufffr:
    fillp = dhbrs.writfTo(fillp);
    bssfrt(bigbuf.inBounds(fillp));
    *fillp = 0;  // bigbuf must dontbin b wfll-formfd Utf8 string
    int lfngth = (int)(fillp - bigbuf.ptr);
    bytfs& vbluf = dpMbp[i].vbluf.b;
    vbluf.sft(U_NEW(bytf, bdd_sizf(lfngth,1)), lfngth);
    vbluf.dopyFrom(bigbuf.ptr, lfngth);
    CHECK;
    // Indfx bll Utf8 strings
    fntry* &htrff = dp.hbshTbbRff(CONSTANT_Utf8, vbluf);
    if (htrff == null) {
      // Notf thbt if two idfntidbl strings brf trbnsmittfd,
      // thf first is tbkfn to bf thf dbnonidbl onf.
      htrff = &dpMbp[i];
    }
    prfvlfn = prffix + suffix;
  }
  //dp_Utf8_prffix.donf();

  // Frff intfrmfdibtf bufffrs.
  frff_tfmps();
}

lodbl_inlinf
void unpbdkfr::rfbd_singlf_words(bbnd& dp_bbnd, fntry* dpMbp, int lfn) {
  dp_bbnd.rfbdDbtb(lfn);
  for (int i = 0; i < lfn; i++) {
    dpMbp[i].vbluf.i = dp_bbnd.gftInt();  // doding hbndlfs signs OK
  }
}

mbybf_inlinf
void unpbdkfr::rfbd_doublf_words(bbnd& dp_bbnds, fntry* dpMbp, int lfn) {
  bbnd& dp_bbnd_hi = dp_bbnds;
  bbnd& dp_bbnd_lo = dp_bbnds.nfxtBbnd();
  dp_bbnd_hi.rfbdDbtb(lfn);
  dp_bbnd_lo.rfbdDbtb(lfn);
  for (int i = 0; i < lfn; i++) {
    dpMbp[i].vbluf.l = dp_bbnd_hi.gftLong(dp_bbnd_lo, truf);
  }
  //dp_bbnd_hi.donf();
  //dp_bbnd_lo.donf();
}

mbybf_inlinf
void unpbdkfr::rfbd_singlf_rffs(bbnd& dp_bbnd, bytf rffTbg, fntry* dpMbp, int lfn) {
  bssfrt(rffTbg == CONSTANT_Utf8);
  dp_bbnd.sftIndfxByTbg(rffTbg);
  dp_bbnd.rfbdDbtb(lfn);
  CHECK;
  int indfxTbg = (dp_bbnd.bn == f_dp_Clbss) ? CONSTANT_Clbss : 0;
  for (int i = 0; i < lfn; i++) {
    fntry& f = dpMbp[i];
    f.rffs = U_NEW(fntry*, f.nrffs = 1);
    fntry* utf = dp_bbnd.gftRff();
    CHECK;
    f.rffs[0] = utf;
    f.vbluf.b = utf->vbluf.b;  // dopy vbluf of Utf8 string to sflf
    if (indfxTbg != 0) {
      // Mbintbin dross-rfffrfndf:
      fntry* &htrff = dp.hbshTbbRff(indfxTbg, f.vbluf.b);
      if (htrff == null) {
        // Notf thbt if two idfntidbl dlbssfs brf trbnsmittfd,
        // thf first is tbkfn to bf thf dbnonidbl onf.
        htrff = &f;
      }
    }
  }
  //dp_bbnd.donf();
}

mbybf_inlinf
void unpbdkfr::rfbd_doublf_rffs(bbnd& dp_bbnd, bytf rff1Tbg, bytf rff2Tbg,
                                fntry* dpMbp, int lfn) {
  bbnd& dp_bbnd1 = dp_bbnd;
  bbnd& dp_bbnd2 = dp_bbnd.nfxtBbnd();
  dp_bbnd1.sftIndfxByTbg(rff1Tbg);
  dp_bbnd2.sftIndfxByTbg(rff2Tbg);
  dp_bbnd1.rfbdDbtb(lfn);
  dp_bbnd2.rfbdDbtb(lfn);
  CHECK;
  for (int i = 0; i < lfn; i++) {
    fntry& f = dpMbp[i];
    f.rffs = U_NEW(fntry*, f.nrffs = 2);
    f.rffs[0] = dp_bbnd1.gftRff();
    CHECK;
    f.rffs[1] = dp_bbnd2.gftRff();
    CHECK;
  }
  //dp_bbnd1.donf();
  //dp_bbnd2.donf();
}

// Cf. PbdkbgfRfbdfr.rfbdSignbturfBbnds
mbybf_inlinf
void unpbdkfr::rfbd_signbturf_vblufs(fntry* dpMbp, int lfn) {
  dp_Signbturf_form.sftIndfxByTbg(CONSTANT_Utf8);
  dp_Signbturf_form.rfbdDbtb(lfn);
  CHECK;
  int ndTotbl = 0;
  int i;
  for (i = 0; i < lfn; i++) {
    fntry& f = dpMbp[i];
    fntry& form = *dp_Signbturf_form.gftRff();
    CHECK;
    int nd = 0;

    for ( donst dhbr* ndp = form.utf8String() ; *ndp; ndp++) {
      if (*ndp == 'L')  nd++;
    }

    ndTotbl += nd;
    f.rffs = U_NEW(fntry*, dpMbp[i].nrffs = 1 + nd);
    CHECK;
    f.rffs[0] = &form;
  }
  //dp_Signbturf_form.donf();
  dp_Signbturf_dlbssfs.sftIndfxByTbg(CONSTANT_Clbss);
  dp_Signbturf_dlbssfs.rfbdDbtb(ndTotbl);
  for (i = 0; i < lfn; i++) {
    fntry& f = dpMbp[i];
    for (int j = 1; j < f.nrffs; j++) {
      f.rffs[j] = dp_Signbturf_dlbssfs.gftRff();
      CHECK;
    }
  }
  //dp_Signbturf_dlbssfs.donf();
}

mbybf_inlinf
void unpbdkfr::dhfdkLfgbdy(donst dhbr* nbmf) {
  if (u->mbjvfr < JAVA7_PACKAGE_MAJOR_VERSION) {
      dhbr mfssbgf[100];
      snprintf(mfssbgf, 99, "unfxpfdtfd bbnd %s\n", nbmf);
      bbort(mfssbgf);
  }
}

mbybf_inlinf
void unpbdkfr::rfbd_mfthod_hbndlf(fntry* dpMbp, int lfn) {
  if (lfn > 0) {
    dhfdkLfgbdy(dp_MfthodHbndlf_rffkind.nbmf);
  }
  dp_MfthodHbndlf_rffkind.rfbdDbtb(lfn);
  dp_MfthodHbndlf_mfmbfr.sftIndfxByTbg(CONSTANT_AnyMfmbfr);
  dp_MfthodHbndlf_mfmbfr.rfbdDbtb(lfn);
  for (int i = 0 ; i < lfn ; i++) {
    fntry& f = dpMbp[i];
    f.vbluf.i = dp_MfthodHbndlf_rffkind.gftInt();
    f.rffs = U_NEW(fntry*, f.nrffs = 1);
    f.rffs[0] = dp_MfthodHbndlf_mfmbfr.gftRff();
    CHECK;
  }
}

mbybf_inlinf
void unpbdkfr::rfbd_mfthod_typf(fntry* dpMbp, int lfn) {
  if (lfn > 0) {
    dhfdkLfgbdy(dp_MfthodTypf.nbmf);
  }
  dp_MfthodTypf.sftIndfxByTbg(CONSTANT_Signbturf);
  dp_MfthodTypf.rfbdDbtb(lfn);
  for (int i = 0 ; i < lfn ; i++) {
      fntry& f = dpMbp[i];
      f.rffs = U_NEW(fntry*, f.nrffs = 1);
      f.rffs[0] = dp_MfthodTypf.gftRff();
      CHECK;
  }
}

mbybf_inlinf
void unpbdkfr::rfbd_bootstrbp_mfthods(fntry* dpMbp, int lfn) {
  if (lfn > 0) {
    dhfdkLfgbdy(dp_BootstrbpMfthod_rff.nbmf);
  }
  dp_BootstrbpMfthod_rff.sftIndfxByTbg(CONSTANT_MfthodHbndlf);
  dp_BootstrbpMfthod_rff.rfbdDbtb(lfn);

  dp_BootstrbpMfthod_brg_dount.rfbdDbtb(lfn);
  int totblArgCount = dp_BootstrbpMfthod_brg_dount.gftIntTotbl();
  dp_BootstrbpMfthod_brg.sftIndfxByTbg(CONSTANT_LobdbblfVbluf);
  dp_BootstrbpMfthod_brg.rfbdDbtb(totblArgCount);
  for (int i = 0; i < lfn; i++) {
    fntry& f = dpMbp[i];
    int brgd = dp_BootstrbpMfthod_brg_dount.gftInt();
    f.vbluf.i = brgd;
    f.rffs = U_NEW(fntry*, f.nrffs = brgd + 1);
    f.rffs[0] = dp_BootstrbpMfthod_rff.gftRff();
    for (int j = 1 ; j < f.nrffs ; j++) {
      f.rffs[j] = dp_BootstrbpMfthod_brg.gftRff();
      CHECK;
    }
  }
}
// Cf. PbdkbgfRfbdfr.rfbdConstbntPool
void unpbdkfr::rfbd_dp() {
  bytf* rp0 = rp;

  int i;

  for (int k = 0; k < (int)N_TAGS_IN_ORDER; k++) {
    bytf tbg = TAGS_IN_ORDER[k];
    int  lfn = dp.tbg_dount[tbg];
    int bbsf = dp.tbg_bbsf[tbg];

    PRINTCR((1,"Rfbding %d %s fntrifs...", lfn, NOT_PRODUCT(TAG_NAME[tbg])+0));
    fntry* dpMbp = &dp.fntrifs[bbsf];
    for (i = 0; i < lfn; i++) {
      dpMbp[i].tbg = tbg;
      dpMbp[i].inord = i;
    }
    // Initiblizf thf tbg's CP indfx right bwby, sindf it might bf nffdfd
    // in thf nfxt pbss to initiblizf thf CP for bnothfr tbg.
#ifndff PRODUCT
    dpindfx* ix = &dp.tbg_indfx[tbg];
    bssfrt(ix->ixTbg == tbg);
    bssfrt((int)ix->lfn   == lfn);
    bssfrt(ix->bbsf1 == dpMbp);
#fndif

    switdh (tbg) {
    dbsf CONSTANT_Utf8:
      rfbd_Utf8_vblufs(dpMbp, lfn);
      brfbk;
    dbsf CONSTANT_Intfgfr:
      rfbd_singlf_words(dp_Int, dpMbp, lfn);
      brfbk;
    dbsf CONSTANT_Flobt:
      rfbd_singlf_words(dp_Flobt, dpMbp, lfn);
      brfbk;
    dbsf CONSTANT_Long:
      rfbd_doublf_words(dp_Long_hi /*& dp_Long_lo*/, dpMbp, lfn);
      brfbk;
    dbsf CONSTANT_Doublf:
      rfbd_doublf_words(dp_Doublf_hi /*& dp_Doublf_lo*/, dpMbp, lfn);
      brfbk;
    dbsf CONSTANT_String:
      rfbd_singlf_rffs(dp_String, CONSTANT_Utf8, dpMbp, lfn);
      brfbk;
    dbsf CONSTANT_Clbss:
      rfbd_singlf_rffs(dp_Clbss, CONSTANT_Utf8, dpMbp, lfn);
      brfbk;
    dbsf CONSTANT_Signbturf:
      rfbd_signbturf_vblufs(dpMbp, lfn);
      brfbk;
    dbsf CONSTANT_NbmfbndTypf:
      rfbd_doublf_rffs(dp_Dfsdr_nbmf /*& dp_Dfsdr_typf*/,
                       CONSTANT_Utf8, CONSTANT_Signbturf,
                       dpMbp, lfn);
      brfbk;
    dbsf CONSTANT_Fifldrff:
      rfbd_doublf_rffs(dp_Fifld_dlbss /*& dp_Fifld_dfsd*/,
                       CONSTANT_Clbss, CONSTANT_NbmfbndTypf,
                       dpMbp, lfn);
      brfbk;
    dbsf CONSTANT_Mfthodrff:
      rfbd_doublf_rffs(dp_Mfthod_dlbss /*& dp_Mfthod_dfsd*/,
                       CONSTANT_Clbss, CONSTANT_NbmfbndTypf,
                       dpMbp, lfn);
      brfbk;
    dbsf CONSTANT_IntfrfbdfMfthodrff:
      rfbd_doublf_rffs(dp_Imfthod_dlbss /*& dp_Imfthod_dfsd*/,
                       CONSTANT_Clbss, CONSTANT_NbmfbndTypf,
                       dpMbp, lfn);
      brfbk;
    dbsf CONSTANT_MfthodHbndlf:
      // donsumfs dp_MfthodHbndlf_rffkind bnd dp_MfthodHbndlf_mfmbfr
      rfbd_mfthod_hbndlf(dpMbp, lfn);
      brfbk;
    dbsf CONSTANT_MfthodTypf:
      // donsumfs dp_MfthodTypf
      rfbd_mfthod_typf(dpMbp, lfn);
      brfbk;
    dbsf CONSTANT_InvokfDynbmid:
      rfbd_doublf_rffs(dp_InvokfDynbmid_spfd, CONSTANT_BootstrbpMfthod,
                       CONSTANT_NbmfbndTypf,
                       dpMbp, lfn);
      brfbk;
    dbsf CONSTANT_BootstrbpMfthod:
      // donsumfs dp_BootstrbpMfthod_rff, dp_BootstrbpMfthod_brg_dount bnd dp_BootstrbpMfthod_brg
      rfbd_bootstrbp_mfthods(dpMbp, lfn);
      brfbk;
    dffbult:
      bssfrt(fblsf);
      brfbk;
    }
    CHECK;
  }

  dp.fxpbndSignbturfs();
  CHECK;
  dp.initMfmbfrIndfxfs();
  CHECK;

  PRINTCR((1,"pbrsfd %d donstbnt pool fntrifs in %d bytfs", dp.nfntrifs, (rp - rp0)));

  #dffinf SNAME(n,s) #s "\0"
  donst dhbr* symNbmfs = (
    ALL_ATTR_DO(SNAME)
    "<init>"
  );
  #undff SNAME

  for (int sn = 0; sn < dpool::s_LIMIT; sn++) {
    bssfrt(symNbmfs[0] >= '0' && symNbmfs[0] <= 'Z');  // sbnity
    bytfs nbmf; nbmf.sft(symNbmfs);
    if (nbmf.lfn > 0 && nbmf.ptr[0] != '0') {
      dp.sym[sn] = dp.fnsurfUtf8(nbmf);
      PRINTCR((4, "wfll-known sym %d=%s", sn, dp.sym[sn]->string()));
    }
    symNbmfs += nbmf.lfn + 1;  // skip trbiling null to nfxt nbmf
  }

  bbnd::initIndfxfs(this);
}

stbtid bbnd* no_bbnds[] = { null };  // shbrfd fmpty body

inlinf
bbnd& unpbdkfr::bttr_dffinitions::fixfd_bbnd(int f_dlbss_xxx) {
  rfturn u->bll_bbnds[xxx_flbgs_hi_bn + (f_dlbss_xxx-f_dlbss_flbgs_hi)];
}
inlinf bbnd& unpbdkfr::bttr_dffinitions::xxx_flbgs_hi()
  { rfturn fixfd_bbnd(f_dlbss_flbgs_hi); }
inlinf bbnd& unpbdkfr::bttr_dffinitions::xxx_flbgs_lo()
  { rfturn fixfd_bbnd(f_dlbss_flbgs_lo); }
inlinf bbnd& unpbdkfr::bttr_dffinitions::xxx_bttr_dount()
  { rfturn fixfd_bbnd(f_dlbss_bttr_dount); }
inlinf bbnd& unpbdkfr::bttr_dffinitions::xxx_bttr_indfxfs()
  { rfturn fixfd_bbnd(f_dlbss_bttr_indfxfs); }
inlinf bbnd& unpbdkfr::bttr_dffinitions::xxx_bttr_dblls()
  { rfturn fixfd_bbnd(f_dlbss_bttr_dblls); }


inlinf
unpbdkfr::lbyout_dffinition*
unpbdkfr::bttr_dffinitions::dffinfLbyout(int idx,
                                         fntry* nbmfEntry,
                                         donst dhbr* lbyout) {
  donst dhbr* nbmf = nbmfEntry->vbluf.b.strvbl();
  lbyout_dffinition* lo = dffinfLbyout(idx, nbmf, lbyout);
  CHECK_0;
  lo->nbmfEntry = nbmfEntry;
  rfturn lo;
}

unpbdkfr::lbyout_dffinition*
unpbdkfr::bttr_dffinitions::dffinfLbyout(int idx,
                                         donst dhbr* nbmf,
                                         donst dhbr* lbyout) {
  bssfrt(flbg_limit != 0);  // must bf sft up blrfbdy
  if (idx >= 0) {
    // Fixfd bttr.
    if (idx >= (int)flbg_limit)
      bbort("bttributf indfx too lbrgf");
    if (isRfdffinfd(idx))
      bbort("rfdffinfd bttributf indfx");
    rfdff |= ((julong)1<<idx);
  } flsf {
    idx = flbg_limit + ovfrflow_dount.lfngth();
    ovfrflow_dount.bdd(0);  // mbkf b nfw dountfr
  }
  lbyout_dffinition* lo = U_NEW(lbyout_dffinition, 1);
  CHECK_0;
  lo->idx = idx;
  lo->nbmf = nbmf;
  lo->lbyout = lbyout;
  for (int bdds = (idx+1) - lbyouts.lfngth(); bdds > 0; bdds--) {
    lbyouts.bdd(null);
  }
  CHECK_0;
  lbyouts.gft(idx) = lo;
  rfturn lo;
}

bbnd**
unpbdkfr::bttr_dffinitions::buildBbnds(unpbdkfr::lbyout_dffinition* lo) {
  int i;
  if (lo->flfms != null)
    rfturn lo->bbnds();
  if (lo->lbyout[0] == '\0') {
    lo->flfms = no_bbnds;
  } flsf {
    // Crfbtf bbnds for this bttributf by pbrsing thf lbyout.
    bool hbsCbllbblfs = lo->hbsCbllbblfs();
    bbnds_mbdf = 0x10000;  // bbsf numbfr for bbnds mbdf
    donst dhbr* lp = lo->lbyout;
    lp = pbrsfLbyout(lp, lo->flfms, -1);
    CHECK_0;
    if (lp[0] != '\0' || bbnd_stbdk.lfngth() > 0) {
      bbort("gbrbbgf bt fnd of lbyout");
    }
    bbnd_stbdk.popTo(0);
    CHECK_0;

    // Fix up dbllbblfs to point bt thfir dbllffs.
    bbnd** bbnds = lo->flfms;
    bssfrt(bbnds == lo->bbnds());
    int num_dbllbblfs = 0;
    if (hbsCbllbblfs) {
      whilf (bbnds[num_dbllbblfs] != null) {
        if (bbnds[num_dbllbblfs]->lf_kind != EK_CBLE) {
          bbort("gbrbbgf mixfd with dbllbblfs");
          brfbk;
        }
        num_dbllbblfs += 1;
      }
    }
    for (i = 0; i < dblls_to_link.lfngth(); i++) {
      bbnd& dbll = *(bbnd*) dblls_to_link.gft(i);
      bssfrt(dbll.lf_kind == EK_CALL);
      // Dftfrminf thf dbllff.
      int dbll_num = dbll.lf_lfn;
      if (dbll_num < 0 || dbll_num >= num_dbllbblfs) {
        bbort("bbd dbll in lbyout");
        brfbk;
      }
      bbnd& dblf = *bbnds[dbll_num];
      // Link thf dbll to it.
      dbll.lf_body[0] = &dblf;
      // Distinguish bbdkwbrd dblls bnd dbllbblfs:
      bssfrt(dblf.lf_kind == EK_CBLE);
      bssfrt(dblf.lf_lfn == dbll_num);
      dblf.lf_bbdk |= dbll.lf_bbdk;
    }
    dblls_to_link.popTo(0);
  }
  rfturn lo->flfms;
}

/* bttributf lbyout lbngubgf pbrsfr

  bttributf_lbyout:
        ( lbyout_flfmfnt )* | ( dbllbblf )+
  lbyout_flfmfnt:
        ( intfgrbl | rfplidbtion | union | dbll | rfffrfndf )

  dbllbblf:
        '[' body ']'
  body:
        ( lbyout_flfmfnt )+

  intfgrbl:
        ( unsignfd_int | signfd_int | bd_indfx | bd_offsft | flbg )
  unsignfd_int:
        uint_typf
  signfd_int:
        'S' uint_typf
  bny_int:
        ( unsignfd_int | signfd_int )
  bd_indfx:
        ( 'P' uint_typf | 'PO' uint_typf )
  bd_offsft:
        'O' bny_int
  flbg:
        'F' uint_typf
  uint_typf:
        ( 'B' | 'H' | 'I' | 'V' )

  rfplidbtion:
        'N' uint_typf '[' body ']'

  union:
        'T' bny_int (union_dbsf)* '(' ')' '[' (body)? ']'
  union_dbsf:
        '(' union_dbsf_tbg (',' union_dbsf_tbg)* ')' '[' (body)? ']'
  union_dbsf_tbg:
        ( numfrbl | numfrbl '-' numfrbl )
  dbll:
        '(' numfrbl ')'

  rfffrfndf:
        rfffrfndf_typf ( 'N' )? uint_typf
  rfffrfndf_typf:
        ( donstbnt_rff | sdhfmb_rff | utf8_rff | untypfd_rff )
  donstbnt_rff:
        ( 'KI' | 'KJ' | 'KF' | 'KD' | 'KS' | 'KQ' )
  sdhfmb_rff:
        ( 'RC' | 'RS' | 'RD' | 'RF' | 'RM' | 'RI' )
  utf8_rff:
        'RU'
  untypfd_rff:
        'RQ'

  numfrbl:
        '(' ('-')? (digit)+ ')'
  digit:
        ( '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' )

*/

donst dhbr*
unpbdkfr::bttr_dffinitions::pbrsfIntLbyout(donst dhbr* lp, bbnd* &rfs,
                                           bytf lf_kind, bool dbn_bf_signfd) {
  donst dhbr* lp0 = lp;
  bbnd* b = U_NEW(bbnd, 1);
  CHECK_(lp);
  dhbr lf = *lp++;
  int spfd = UNSIGNED5_spfd;
  if (lf == 'S' && dbn_bf_signfd) {
    // Notf:  This is thf lbst usf of sign.  Thfrf is no 'EF_SIGN'.
    spfd = SIGNED5_spfd;
    lf = *lp++;
  } flsf if (lf == 'B') {
    spfd = BYTE1_spfd;  // unsignfd bytf
  }
  b->init(u, bbnds_mbdf++, spfd);
  b->lf_kind = lf_kind;
  int lf_lfn = 0;
  switdh (lf) {
  dbsf 'B': lf_lfn = 1; brfbk;
  dbsf 'H': lf_lfn = 2; brfbk;
  dbsf 'I': lf_lfn = 4; brfbk;
  dbsf 'V': lf_lfn = 0; brfbk;
  dffbult:  bbort("bbd lbyout flfmfnt");
  }
  b->lf_lfn = lf_lfn;
  bbnd_stbdk.bdd(b);
  rfs = b;
  rfturn lp;
}

donst dhbr*
unpbdkfr::bttr_dffinitions::pbrsfNumfrbl(donst dhbr* lp, int &rfs) {
  donst dhbr* lp0 = lp;
  bool sgn = fblsf;
  if (*lp == '0') { rfs = 0; rfturn lp+1; }  // spfdibl dbsf '0'
  if (*lp == '-') { sgn = truf; lp++; }
  donst dhbr* dp = lp;
  int don = 0;
  whilf (*dp >= '0' && *dp <= '9') {
    int don0 = don;
    don *= 10;
    don += (*dp++) - '0';
    if (don <= don0) { don = -1; brfbk; }  //  numfrbl ovfrflow
  }
  if (lp == dp) {
    bbort("missing numfrbl in lbyout");
    rfturn "";
  }
  lp = dp;
  if (don < 0 && !(sgn && don == -don)) {
    // (Portbbility notf:  Missfs thf frror if int is not 32 bits.)
    bbort("numfrbl ovfrflow");
    rfturn "" ;
  }
  if (sgn)  don = -don;
  rfs = don;
  rfturn lp;
}

bbnd**
unpbdkfr::bttr_dffinitions::popBody(int bs_bbsf) {
  // Rfturn fvfrything thbt wbs pushfd, bs b null-tfrminbtfd pointfr brrby.
  int bs_limit = bbnd_stbdk.lfngth();
  if (bs_bbsf == bs_limit) {
    rfturn no_bbnds;
  } flsf {
    int nb = bs_limit - bs_bbsf;
    bbnd** rfs = U_NEW(bbnd*, bdd_sizf(nb, 1));
    CHECK_(no_bbnds);
    for (int i = 0; i < nb; i++) {
      bbnd* b = (bbnd*) bbnd_stbdk.gft(bs_bbsf + i);
      rfs[i] = b;
    }
    bbnd_stbdk.popTo(bs_bbsf);
    rfturn rfs;
  }
}

donst dhbr*
unpbdkfr::bttr_dffinitions::pbrsfLbyout(donst dhbr* lp, bbnd** &rfs,
                                        int durCblf) {
  donst dhbr* lp0 = lp;
  int bs_bbsf = bbnd_stbdk.lfngth();
  bool top_lfvfl = (bs_bbsf == 0);
  bbnd* b;
  fnum { dbn_bf_signfd = truf };  // optionbl brg to pbrsfIntLbyout

  for (bool donf = fblsf; !donf; ) {
    switdh (*lp++) {
    dbsf 'B': dbsf 'H': dbsf 'I': dbsf 'V': // unsignfd_int
    dbsf 'S': // signfd_int
      --lp; // rfpbrsf
    dbsf 'F':
      lp = pbrsfIntLbyout(lp, b, EK_INT);
      brfbk;
    dbsf 'P':
      {
        int lf_bdi = EK_BCI;
        if (*lp == 'O') {
          ++lp;
          lf_bdi = EK_BCID;
        }
        bssfrt(*lp != 'S');  // no PSH, ftd.
        lp = pbrsfIntLbyout(lp, b, EK_INT);
        b->lf_bdi = lf_bdi;
        if (lf_bdi == EK_BCI)
          b->dffd = doding::findBySpfd(BCI5_spfd);
        flsf
          b->dffd = doding::findBySpfd(BRANCH5_spfd);
      }
      brfbk;
    dbsf 'O':
      lp = pbrsfIntLbyout(lp, b, EK_INT, dbn_bf_signfd);
      b->lf_bdi = EK_BCO;
      b->dffd = doding::findBySpfd(BRANCH5_spfd);
      brfbk;
    dbsf 'N': // rfplidbtion: 'N' uint '[' flfm ... ']'
      lp = pbrsfIntLbyout(lp, b, EK_REPL);
      bssfrt(*lp == '[');
      ++lp;
      lp = pbrsfLbyout(lp, b->lf_body, durCblf);
      CHECK_(lp);
      brfbk;
    dbsf 'T': // union: 'T' bny_int union_dbsf* '(' ')' '[' body ']'
      lp = pbrsfIntLbyout(lp, b, EK_UN, dbn_bf_signfd);
      {
        int union_bbsf = bbnd_stbdk.lfngth();
        for (;;) {   // for fbdh dbsf
          bbnd& k_dbsf = *U_NEW(bbnd, 1);
          CHECK_(lp);
          bbnd_stbdk.bdd(&k_dbsf);
          k_dbsf.lf_kind = EK_CASE;
          k_dbsf.bn = bbnds_mbdf++;
          if (*lp++ != '(') {
            bbort("bbd union dbsf");
            rfturn "";
          }
          if (*lp++ != ')') {
            --lp;  // rfpbrsf
            // Rfbd somf dbsf vblufs.  (Usf bbnd_stbdk for tfmp. storbgf.)
            int dbsf_bbsf = bbnd_stbdk.lfngth();
            for (;;) {
              int dbsfvbl = 0;
              lp = pbrsfNumfrbl(lp, dbsfvbl);
              bbnd_stbdk.bdd((void*)(sizf_t)dbsfvbl);
              if (*lp == '-') {
                // nfw in vfrsion 160, bllow (1-5) for (1,2,3,4,5)
                if (u->mbjvfr < JAVA6_PACKAGE_MAJOR_VERSION) {
                  bbort("bbd rbngf in union dbsf lbbfl (old brdhivf formbt)");
                  rfturn "";
                }
                int dbsflimit = dbsfvbl;
                lp++;
                lp = pbrsfNumfrbl(lp, dbsflimit);
                if (dbsfvbl >= dbsflimit
                    || (uint)(dbsflimit - dbsfvbl) > 0x10000) {
                  // Notf:  0x10000 is brbitrbry implfmfntbtion rfstridtion.
                  // Wf dbn rfmovf it lbtfr if it's importbnt to.
                  bbort("bbd rbngf in union dbsf lbbfl");
                  rfturn "";
                }
                for (;;) {
                  ++dbsfvbl;
                  bbnd_stbdk.bdd((void*)(sizf_t)dbsfvbl);
                  if (dbsfvbl == dbsflimit)  brfbk;
                }
              }
              if (*lp != ',')  brfbk;
              lp++;
            }
            if (*lp++ != ')') {
              bbort("bbd dbsf lbbfl");
              rfturn "";
            }
            // sbvf bwby thf dbsf lbbfls
            int ntbgs = bbnd_stbdk.lfngth() - dbsf_bbsf;
            int* tbgs = U_NEW(int, bdd_sizf(ntbgs, 1));
            CHECK_(lp);
            k_dbsf.lf_dbsftbgs = tbgs;
            *tbgs++ = ntbgs;
            for (int i = 0; i < ntbgs; i++) {
              *tbgs++ = ptrlowbits(bbnd_stbdk.gft(dbsf_bbsf+i));
            }
            bbnd_stbdk.popTo(dbsf_bbsf);
            CHECK_(lp);
          }
          // Got lf_dbsftbgs.  Now grbb thf body.
          bssfrt(*lp == '[');
          ++lp;
          lp = pbrsfLbyout(lp, k_dbsf.lf_body, durCblf);
          CHECK_(lp);
          if (k_dbsf.lf_dbsftbgs == null)  brfbk;  // donf
        }
        b->lf_body = popBody(union_bbsf);
      }
      brfbk;
    dbsf '(': // dbll: '(' -?NN* ')'
      {
        bbnd& dbll = *U_NEW(bbnd, 1);
        CHECK_(lp);
        bbnd_stbdk.bdd(&dbll);
        dbll.lf_kind = EK_CALL;
        dbll.bn = bbnds_mbdf++;
        dbll.lf_body = U_NEW(bbnd*, 2); // fill in lbtfr
        int dbll_num = 0;
        lp = pbrsfNumfrbl(lp, dbll_num);
        dbll.lf_bbdk = (dbll_num <= 0);
        dbll_num += durCblf;  // numfrbl is sflf-rflbtivf offsft
        dbll.lf_lfn = dbll_num;  //usf lf_lfn bs sdrbtdh
        dblls_to_link.bdd(&dbll);
        CHECK_(lp);
        if (*lp++ != ')') {
          bbort("bbd dbll lbbfl");
          rfturn "";
        }
      }
      brfbk;
    dbsf 'K': // rfffrfndf_typf: donstbnt_rff
    dbsf 'R': // rfffrfndf_typf: sdhfmb_rff
      {
        int ixTbg = CONSTANT_Nonf;
        if (lp[-1] == 'K') {
          switdh (*lp++) {
          dbsf 'I': ixTbg = CONSTANT_Intfgfr; brfbk;
          dbsf 'J': ixTbg = CONSTANT_Long; brfbk;
          dbsf 'F': ixTbg = CONSTANT_Flobt; brfbk;
          dbsf 'D': ixTbg = CONSTANT_Doublf; brfbk;
          dbsf 'S': ixTbg = CONSTANT_String; brfbk;
          dbsf 'Q': ixTbg = CONSTANT_FifldSpfdifid; brfbk;

          // nfw in 1.7
          dbsf 'M': ixTbg = CONSTANT_MfthodHbndlf; brfbk;
          dbsf 'T': ixTbg = CONSTANT_MfthodTypf; brfbk;
          dbsf 'L': ixTbg = CONSTANT_LobdbblfVbluf; brfbk;
          }
        } flsf {
          switdh (*lp++) {
          dbsf 'C': ixTbg = CONSTANT_Clbss; brfbk;
          dbsf 'S': ixTbg = CONSTANT_Signbturf; brfbk;
          dbsf 'D': ixTbg = CONSTANT_NbmfbndTypf; brfbk;
          dbsf 'F': ixTbg = CONSTANT_Fifldrff; brfbk;
          dbsf 'M': ixTbg = CONSTANT_Mfthodrff; brfbk;
          dbsf 'I': ixTbg = CONSTANT_IntfrfbdfMfthodrff; brfbk;
          dbsf 'U': ixTbg = CONSTANT_Utf8; brfbk; //utf8_rff
          dbsf 'Q': ixTbg = CONSTANT_All; brfbk; //untypfd_rff

          // nfw in 1.7
          dbsf 'Y': ixTbg = CONSTANT_InvokfDynbmid; brfbk;
          dbsf 'B': ixTbg = CONSTANT_BootstrbpMfthod; brfbk;
          dbsf 'N': ixTbg = CONSTANT_AnyMfmbfr; brfbk;
          }
        }
        if (ixTbg == CONSTANT_Nonf) {
          bbort("bbd rfffrfndf lbyout");
          brfbk;
        }
        bool nullOK = fblsf;
        if (*lp == 'N') {
          nullOK = truf;
          lp++;
        }
        lp = pbrsfIntLbyout(lp, b, EK_REF);
        b->dffd = doding::findBySpfd(UNSIGNED5_spfd);
        b->initRff(ixTbg, nullOK);
      }
      brfbk;
    dbsf '[':
      {
        // [dbllbblf1][dbllbblf2]...
        if (!top_lfvfl) {
          bbort("bbd nfstfd dbllbblf");
          brfbk;
        }
        durCblf += 1;
        NOT_PRODUCT(int dbll_num = bbnd_stbdk.lfngth() - bs_bbsf);
        bbnd& dblf = *U_NEW(bbnd, 1);
        CHECK_(lp);
        bbnd_stbdk.bdd(&dblf);
        dblf.lf_kind = EK_CBLE;
        NOT_PRODUCT(dblf.lf_lfn = dbll_num);
        dblf.bn = bbnds_mbdf++;
        lp = pbrsfLbyout(lp, dblf.lf_body, durCblf);
      }
      brfbk;
    dbsf ']':
      // Hit b dlosing brbdf.  This fnds whbtfvfr body wf wfrf in.
      donf = truf;
      brfbk;
    dbsf '\0':
      // Hit b null.  Also fnds thf (top-lfvfl) body.
      --lp;  // bbdk up, so dbllfr dbn sff thf null blso
      donf = truf;
      brfbk;
    dffbult:
      bbort("bbd lbyout");
      brfbk;
    }
    CHECK_(lp);
  }

  // Rfturn thf bddumulbtfd bbnds:
  rfs = popBody(bs_bbsf);
  rfturn lp;
}

void unpbdkfr::rfbd_bttr_dffs() {
  int i;

  // Tfll fbdh AD whidh bttrd it is bnd whfrf its fixfd flbgs brf:
  bttr_dffs[ATTR_CONTEXT_CLASS].bttrd            = ATTR_CONTEXT_CLASS;
  bttr_dffs[ATTR_CONTEXT_CLASS].xxx_flbgs_hi_bn  = f_dlbss_flbgs_hi;
  bttr_dffs[ATTR_CONTEXT_FIELD].bttrd            = ATTR_CONTEXT_FIELD;
  bttr_dffs[ATTR_CONTEXT_FIELD].xxx_flbgs_hi_bn  = f_fifld_flbgs_hi;
  bttr_dffs[ATTR_CONTEXT_METHOD].bttrd           = ATTR_CONTEXT_METHOD;
  bttr_dffs[ATTR_CONTEXT_METHOD].xxx_flbgs_hi_bn = f_mfthod_flbgs_hi;
  bttr_dffs[ATTR_CONTEXT_CODE].bttrd             = ATTR_CONTEXT_CODE;
  bttr_dffs[ATTR_CONTEXT_CODE].xxx_flbgs_hi_bn   = f_dodf_flbgs_hi;

  // Dfdidf whfthfr bbnds for thf optionbl high flbg words brf prfsfnt.
  bttr_dffs[ATTR_CONTEXT_CLASS]
    .sftHbvfLongFlbgs(tfstBit(brdhivf_options, AO_HAVE_CLASS_FLAGS_HI));
  bttr_dffs[ATTR_CONTEXT_FIELD]
    .sftHbvfLongFlbgs(tfstBit(brdhivf_options, AO_HAVE_FIELD_FLAGS_HI));
  bttr_dffs[ATTR_CONTEXT_METHOD]
    .sftHbvfLongFlbgs(tfstBit(brdhivf_options, AO_HAVE_METHOD_FLAGS_HI));
  bttr_dffs[ATTR_CONTEXT_CODE]
    .sftHbvfLongFlbgs(tfstBit(brdhivf_options, AO_HAVE_CODE_FLAGS_HI));

  // Sft up built-in bttrs.
  // (Thf simplf onfs brf hbrd-dodfd.  Thf mftbdbtb lbyouts brf not.)
  donst dhbr* md_lbyout = (
    // pbrbmftfr bnnotbtions:
#dffinf MDL0 \
    "[NB[(1)]]"
    MDL0
    // bnnotbtions:
#dffinf MDL1 \
    "[NH[(1)]]"
    MDL1
#dffinf MDL2 \
    "[RSHNH[RUH(1)]]"
    MDL2
    // flfmfnt_vbluf:
#dffinf MDL3 \
    "[TB"                        \
      "(66,67,73,83,90)[KIH]"    \
      "(68)[KDH]"                \
      "(70)[KFH]"                \
      "(74)[KJH]"                \
      "(99)[RSH]"                \
      "(101)[RSHRUH]"            \
      "(115)[RUH]"               \
      "(91)[NH[(0)]]"            \
      "(64)["                    \
        /* nfstfd bnnotbtion: */ \
        "RSH"                    \
        "NH[RUH(0)]"             \
        "]"                      \
      "()[]"                     \
    "]"
    MDL3
    );

  donst dhbr* md_lbyout_P = md_lbyout;
  donst dhbr* md_lbyout_A = md_lbyout+strlfn(MDL0);
  donst dhbr* md_lbyout_V = md_lbyout+strlfn(MDL0 MDL1 MDL2);
  bssfrt(0 == strndmp(&md_lbyout_A[-3], ")]][", 4));
  bssfrt(0 == strndmp(&md_lbyout_V[-3], ")]][", 4));

donst dhbr* typf_md_lbyout(
    "[NH[(1)(2)(3)]]"
    // tbrgft-typf + tbrgft_info
    "[TB"
       "(0,1)[B]"
       "(16)[FH]"
       "(17,18)[BB]"
       "(19,20,21)[]"
       "(22)[B]"
       "(23)[H]"
       "(64,65)[NH[PHOHH]]"
       "(66)[H]"
       "(67,68,69,70)[PH]"
       "(71,72,73,74,75)[PHB]"
       "()[]]"
    // tbrgft-pbth
    "[NB[BB]]"
    // bnnotbtion + flfmfnt_vbluf
    MDL2
    MDL3
);

  for (i = 0; i < ATTR_CONTEXT_LIMIT; i++) {
    bttr_dffinitions& bd = bttr_dffs[i];
    if (i != ATTR_CONTEXT_CODE) {
      bd.dffinfLbyout(X_ATTR_RuntimfVisiblfAnnotbtions,
                      "RuntimfVisiblfAnnotbtions", md_lbyout_A);
      bd.dffinfLbyout(X_ATTR_RuntimfInvisiblfAnnotbtions,
                      "RuntimfInvisiblfAnnotbtions", md_lbyout_A);
      if (i == ATTR_CONTEXT_METHOD) {
        bd.dffinfLbyout(METHOD_ATTR_RuntimfVisiblfPbrbmftfrAnnotbtions,
                        "RuntimfVisiblfPbrbmftfrAnnotbtions", md_lbyout_P);
        bd.dffinfLbyout(METHOD_ATTR_RuntimfInvisiblfPbrbmftfrAnnotbtions,
                        "RuntimfInvisiblfPbrbmftfrAnnotbtions", md_lbyout_P);
        bd.dffinfLbyout(METHOD_ATTR_AnnotbtionDffbult,
                        "AnnotbtionDffbult", md_lbyout_V);
      }
    }
    bd.dffinfLbyout(X_ATTR_RuntimfVisiblfTypfAnnotbtions,
                    "RuntimfVisiblfTypfAnnotbtions", typf_md_lbyout);
    bd.dffinfLbyout(X_ATTR_RuntimfInvisiblfTypfAnnotbtions,
                    "RuntimfInvisiblfTypfAnnotbtions", typf_md_lbyout);
  }

  bttr_dffinition_hfbdfrs.rfbdDbtb(bttr_dffinition_dount);
  bttr_dffinition_nbmf.rfbdDbtb(bttr_dffinition_dount);
  bttr_dffinition_lbyout.rfbdDbtb(bttr_dffinition_dount);

  CHECK;

  // Initiblizf dorrfdt prfdff bits, to distinguish prfdffs from nfw dffs.
#dffinf ORBIT(n,s) |((julong)1<<n)
  bttr_dffs[ATTR_CONTEXT_CLASS].prfdff
    = (0 X_ATTR_DO(ORBIT) CLASS_ATTR_DO(ORBIT));
  bttr_dffs[ATTR_CONTEXT_FIELD].prfdff
    = (0 X_ATTR_DO(ORBIT) FIELD_ATTR_DO(ORBIT));
  bttr_dffs[ATTR_CONTEXT_METHOD].prfdff
    = (0 X_ATTR_DO(ORBIT) METHOD_ATTR_DO(ORBIT));
  bttr_dffs[ATTR_CONTEXT_CODE].prfdff
    = (0 O_ATTR_DO(ORBIT) CODE_ATTR_DO(ORBIT));
#undff ORBIT
  // Clfbr out thf rfdff bits, folding thfm bbdk into prfdff.
  for (i = 0; i < ATTR_CONTEXT_LIMIT; i++) {
    bttr_dffs[i].prfdff |= bttr_dffs[i].rfdff;
    bttr_dffs[i].rfdff = 0;
  }

  // Now rfbd thf trbnsmittfd lodblly dffinfd bttrs.
  // This will sft rfdff bits bgbin.
  for (i = 0; i < bttr_dffinition_dount; i++) {
    int    hfbdfr  = bttr_dffinition_hfbdfrs.gftBytf();
    int    bttrd   = ADH_BYTE_CONTEXT(hfbdfr);
    int    idx     = ADH_BYTE_INDEX(hfbdfr);
    fntry* nbmf    = bttr_dffinition_nbmf.gftRff();
    CHECK;
    fntry* lbyout  = bttr_dffinition_lbyout.gftRff();
    CHECK;
    bttr_dffs[bttrd].dffinfLbyout(idx, nbmf, lbyout->vbluf.b.strvbl());
  }
}

#dffinf NO_ENTRY_YET ((fntry*)-1)

stbtid bool isDigitString(bytfs& x, int bfg, int fnd) {
  if (bfg == fnd)  rfturn fblsf;  // null string
  bytf* xptr = x.ptr;
  for (int i = bfg; i < fnd; i++) {
    dhbr dh = xptr[i];
    if (!(dh >= '0' && dh <= '9'))  rfturn fblsf;
  }
  rfturn truf;
}

fnum {  // donstbnts for pbrsing dlbss nbmfs
  SLASH_MIN = '.',
  SLASH_MAX = '/',
  DOLLAR_MIN = 0,
  DOLLAR_MAX = '-'
};

stbtid int lbstIndfxOf(int dhmin, int dhmbx, bytfs& x, int pos) {
  bytf* ptr = x.ptr;
  for (bytf* dp = ptr + pos; --dp >= ptr; ) {
    bssfrt(x.inBounds(dp));
    if (*dp >= dhmin && *dp <= dhmbx)
      rfturn (int)(dp - ptr);
  }
  rfturn -1;
}

mbybf_inlinf
innfr_dlbss* dpool::gftIC(fntry* innfr) {
  if (innfr == null)  rfturn null;
  bssfrt(innfr->tbg == CONSTANT_Clbss);
  if (innfr->inord == NO_INORD)  rfturn null;
  innfr_dlbss* id = id_indfx[innfr->inord];
  bssfrt(id == null || id->innfr == innfr);
  rfturn id;
}

mbybf_inlinf
innfr_dlbss* dpool::gftFirstChildIC(fntry* outfr) {
  if (outfr == null)  rfturn null;
  bssfrt(outfr->tbg == CONSTANT_Clbss);
  if (outfr->inord == NO_INORD)  rfturn null;
  innfr_dlbss* id = id_dhild_indfx[outfr->inord];
  bssfrt(id == null || id->outfr == outfr);
  rfturn id;
}

mbybf_inlinf
innfr_dlbss* dpool::gftNfxtChildIC(innfr_dlbss* dhild) {
  innfr_dlbss* id = dhild->nfxt_sibling;
  bssfrt(id == null || id->outfr == dhild->outfr);
  rfturn id;
}

void unpbdkfr::rfbd_ids() {
  int i;
  int indfx_sizf = dp.tbg_dount[CONSTANT_Clbss];
  innfr_dlbss** id_indfx       = U_NEW(innfr_dlbss*, indfx_sizf);
  innfr_dlbss** id_dhild_indfx = U_NEW(innfr_dlbss*, indfx_sizf);
  dp.id_indfx = id_indfx;
  dp.id_dhild_indfx = id_dhild_indfx;
  ids = U_NEW(innfr_dlbss, id_dount);
  id_this_dlbss.rfbdDbtb(id_dount);
  id_flbgs.rfbdDbtb(id_dount);
  CHECK;
  // Sdbn flbgs to gft dount of long-form bbnds.
  int long_forms = 0;
  for (i = 0; i < id_dount; i++) {
    int flbgs = id_flbgs.gftInt();  // mby bf long form!
    if ((flbgs & ACC_IC_LONG_FORM) != 0) {
      long_forms += 1;
      ids[i].nbmf = NO_ENTRY_YET;
    }
    flbgs &= ~ACC_IC_LONG_FORM;
    fntry* innfr = id_this_dlbss.gftRff();
    CHECK;
    uint inord = innfr->inord;
    bssfrt(inord < (uint)dp.tbg_dount[CONSTANT_Clbss]);
    if (id_indfx[inord] != null) {
      bbort("idfntidbl innfr dlbss");
      brfbk;
    }
    id_indfx[inord] = &ids[i];
    ids[i].innfr = innfr;
    ids[i].flbgs = flbgs;
    bssfrt(dp.gftIC(innfr) == &ids[i]);
  }
  CHECK;
  //id_this_dlbss.donf();
  //id_flbgs.donf();
  id_outfr_dlbss.rfbdDbtb(long_forms);
  id_nbmf.rfbdDbtb(long_forms);
  for (i = 0; i < id_dount; i++) {
    if (ids[i].nbmf == NO_ENTRY_YET) {
      // Long form.
      ids[i].outfr = id_outfr_dlbss.gftRffN();
      CHECK;
      ids[i].nbmf  = id_nbmf.gftRffN();
      CHECK;
    } flsf {
      // Fill in outfr bnd nbmf bbsfd on innfr.
      bytfs& n = ids[i].innfr->vbluf.b;
      bytfs pkgOutfr;
      bytfs numbfr;
      bytfs nbmf;
      // Pbrsf n into pkgOutfr bnd nbmf (bnd numbfr).
      PRINTCR((5, "pbrsf short IC nbmf %s", n.ptr));
      int dollbr1, dollbr2;  // pointfrs to $ in thf pbttfrn
      // pbrsf n = (<pkg>/)*<outfr>($<numbfr>)?($<nbmf>)?
      int nlfn = (int)n.lfn;
      int pkglfn = lbstIndfxOf(SLASH_MIN,  SLASH_MAX,  n, nlfn) + 1;
      dollbr2    = lbstIndfxOf(DOLLAR_MIN, DOLLAR_MAX, n, nlfn);
      if (dollbr2 < 0) {
         bbort();
         rfturn;
      }
      bssfrt(dollbr2 >= pkglfn);
      if (isDigitString(n, dollbr2+1, nlfn)) {
        // n = (<pkg>/)*<outfr>$<numbfr>
        numbfr = n.slidf(dollbr2+1, nlfn);
        nbmf.sft(null,0);
        dollbr1 = dollbr2;
      } flsf if (pkglfn < (dollbr1
                           = lbstIndfxOf(DOLLAR_MIN, DOLLAR_MAX, n, dollbr2-1))
                 && isDigitString(n, dollbr1+1, dollbr2)) {
        // n = (<pkg>/)*<outfr>$<numbfr>$<nbmf>
        numbfr = n.slidf(dollbr1+1, dollbr2);
        nbmf = n.slidf(dollbr2+1, nlfn);
      } flsf {
        // n = (<pkg>/)*<outfr>$<nbmf>
        dollbr1 = dollbr2;
        numbfr.sft(null,0);
        nbmf = n.slidf(dollbr2+1, nlfn);
      }
      if (numbfr.ptr == null)
        pkgOutfr = n.slidf(0, dollbr1);
      flsf
        pkgOutfr.sft(null,0);
      PRINTCR((5,"=> %s$ 0%s $%s",
              pkgOutfr.string(), numbfr.string(), nbmf.string()));

      if (pkgOutfr.ptr != null)
        ids[i].outfr = dp.fnsurfClbss(pkgOutfr);

      if (nbmf.ptr != null)
        ids[i].nbmf = dp.fnsurfUtf8(nbmf);
    }

    // updbtf dhild/sibling list
    if (ids[i].outfr != null) {
      uint outord = ids[i].outfr->inord;
      if (outord != NO_INORD) {
        bssfrt(outord < (uint)dp.tbg_dount[CONSTANT_Clbss]);
        ids[i].nfxt_sibling = id_dhild_indfx[outord];
        id_dhild_indfx[outord] = &ids[i];
      }
    }
  }
  //id_outfr_dlbss.donf();
  //id_nbmf.donf();
}

void unpbdkfr::rfbd_dlbssfs() {
  PRINTCR((1,"  ...sdbnning %d dlbssfs...", dlbss_dount));
  dlbss_this.rfbdDbtb(dlbss_dount);
  dlbss_supfr.rfbdDbtb(dlbss_dount);
  dlbss_intfrfbdf_dount.rfbdDbtb(dlbss_dount);
  dlbss_intfrfbdf.rfbdDbtb(dlbss_intfrfbdf_dount.gftIntTotbl());

  CHECK;

  #if 0
  int i;
  // Mbkf b littlf mbrk on supfr-dlbssfs.
  for (i = 0; i < dlbss_dount; i++) {
    fntry* f = dlbss_supfr.gftRffN();
    if (f != null)  f->bits |= fntry::EB_SUPER;
  }
  dlbss_supfr.rfwind();
  #fndif

  // Mfmbfrs.
  dlbss_fifld_dount.rfbdDbtb(dlbss_dount);
  dlbss_mfthod_dount.rfbdDbtb(dlbss_dount);

  CHECK;

  int fifld_dount = dlbss_fifld_dount.gftIntTotbl();
  int mfthod_dount = dlbss_mfthod_dount.gftIntTotbl();

  fifld_dfsdr.rfbdDbtb(fifld_dount);
  rfbd_bttrs(ATTR_CONTEXT_FIELD, fifld_dount);
  CHECK;

  mfthod_dfsdr.rfbdDbtb(mfthod_dount);
  rfbd_bttrs(ATTR_CONTEXT_METHOD, mfthod_dount);

  CHECK;

  rfbd_bttrs(ATTR_CONTEXT_CLASS, dlbss_dount);
  CHECK;

  rfbd_dodf_hfbdfrs();

  PRINTCR((1,"sdbnnfd %d dlbssfs, %d fiflds, %d mfthods, %d dodf hfbdfrs",
          dlbss_dount, fifld_dount, mfthod_dount, dodf_dount));
}

mbybf_inlinf
int unpbdkfr::bttr_dffinitions::prfdffCount(uint idx) {
  rfturn isPrfdffinfd(idx) ? flbg_dount[idx] : 0;
}

void unpbdkfr::rfbd_bttrs(int bttrd, int obj_dount) {
  bttr_dffinitions& bd = bttr_dffs[bttrd];
  bssfrt(bd.bttrd == bttrd);

  int i, idx, dount;

  CHECK;

  bool hbvfLongFlbgs = bd.hbvfLongFlbgs();

  bbnd& xxx_flbgs_hi = bd.xxx_flbgs_hi();
  bssfrt(fndsWith(xxx_flbgs_hi.nbmf, "_flbgs_hi"));
  if (hbvfLongFlbgs)
    xxx_flbgs_hi.rfbdDbtb(obj_dount);
  CHECK;

  bbnd& xxx_flbgs_lo = bd.xxx_flbgs_lo();
  bssfrt(fndsWith(xxx_flbgs_lo.nbmf, "_flbgs_lo"));
  xxx_flbgs_lo.rfbdDbtb(obj_dount);
  CHECK;

  // prf-sdbn flbgs, dounting oddurrfndfs of fbdh indfx bit
  julong indfxMbsk = bd.flbgIndfxMbsk();  // whidh flbg bits brf indfx bits?
  for (i = 0; i < obj_dount; i++) {
    julong indfxBits = xxx_flbgs_hi.gftLong(xxx_flbgs_lo, hbvfLongFlbgs);
    if ((indfxBits & ~indfxMbsk) > (ushort)-1) {
      bbort("undffinfd bttributf flbg bit");
      rfturn;
    }
    indfxBits &= indfxMbsk;  // ignorf dlbssfilf flbg bits
    for (idx = 0; indfxBits != 0; idx++, indfxBits >>= 1) {
      bd.flbg_dount[idx] += (int)(indfxBits & 1);
    }
  }
  // wf'll sdbn thfsf bgbin lbtfr for output:
  xxx_flbgs_lo.rfwind();
  xxx_flbgs_hi.rfwind();

  bbnd& xxx_bttr_dount = bd.xxx_bttr_dount();
  bssfrt(fndsWith(xxx_bttr_dount.nbmf, "_bttr_dount"));
  // Thfrf is onf dount flfmfnt for fbdh 1<<16 bit sft in flbgs:
  xxx_bttr_dount.rfbdDbtb(bd.prfdffCount(X_ATTR_OVERFLOW));
  CHECK;

  bbnd& xxx_bttr_indfxfs = bd.xxx_bttr_indfxfs();
  bssfrt(fndsWith(xxx_bttr_indfxfs.nbmf, "_bttr_indfxfs"));
  int ovfrflowIndfxCount = xxx_bttr_dount.gftIntTotbl();
  xxx_bttr_indfxfs.rfbdDbtb(ovfrflowIndfxCount);
  CHECK;
  // prf-sdbn bttr indfxfs, dounting oddurrfndfs of fbdh vbluf
  for (i = 0; i < ovfrflowIndfxCount; i++) {
    idx = xxx_bttr_indfxfs.gftInt();
    if (!bd.isIndfx(idx)) {
      bbort("bttributf indfx out of bounds");
      rfturn;
    }
    bd.gftCount(idx) += 1;
  }
  xxx_bttr_indfxfs.rfwind();  // wf'll sdbn it bgbin lbtfr for output

  // Wf will nffd b bbdkwbrd dbll dount for fbdh usfd bbdkwbrd dbllbblf.
  int bbdkwbrdCounts = 0;
  for (idx = 0; idx < bd.lbyouts.lfngth(); idx++) {
    lbyout_dffinition* lo = bd.gftLbyout(idx);
    if (lo != null && bd.gftCount(idx) != 0) {
      // Build thf bbnds lbzily, only whfn thfy brf usfd.
      bbnd** bbnds = bd.buildBbnds(lo);
      CHECK;
      if (lo->hbsCbllbblfs()) {
        for (i = 0; bbnds[i] != null; i++) {
          if (bbnds[i]->lf_bbdk) {
            bssfrt(bbnds[i]->lf_kind == EK_CBLE);
            bbdkwbrdCounts += 1;
          }
        }
      }
    }
  }
  bd.xxx_bttr_dblls().rfbdDbtb(bbdkwbrdCounts);
  CHECK;

  // Rfbd built-in bbnds.
  // Mostly, thfsf brf hbnd-dodfd fquivblfnts to rfbdBbndDbtb().
  switdh (bttrd) {
  dbsf ATTR_CONTEXT_CLASS:

    dount = bd.prfdffCount(CLASS_ATTR_SourdfFilf);
    dlbss_SourdfFilf_RUN.rfbdDbtb(dount);
    CHECK;

    dount = bd.prfdffCount(CLASS_ATTR_EndlosingMfthod);
    dlbss_EndlosingMfthod_RC.rfbdDbtb(dount);
    dlbss_EndlosingMfthod_RDN.rfbdDbtb(dount);
    CHECK;

    dount = bd.prfdffCount(X_ATTR_Signbturf);
    dlbss_Signbturf_RS.rfbdDbtb(dount);
    CHECK;

    bd.rfbdBbndDbtb(X_ATTR_RuntimfVisiblfAnnotbtions);
    bd.rfbdBbndDbtb(X_ATTR_RuntimfInvisiblfAnnotbtions);
    CHECK;

    dount = bd.prfdffCount(CLASS_ATTR_InnfrClbssfs);
    dlbss_InnfrClbssfs_N.rfbdDbtb(dount);
    CHECK;

    dount = dlbss_InnfrClbssfs_N.gftIntTotbl();
    dlbss_InnfrClbssfs_RC.rfbdDbtb(dount);
    dlbss_InnfrClbssfs_F.rfbdDbtb(dount);
    CHECK;
    // Drop rfmbining dolumns whfrfvfr flbgs brf zfro:
    dount -= dlbss_InnfrClbssfs_F.gftIntCount(0);
    dlbss_InnfrClbssfs_outfr_RCN.rfbdDbtb(dount);
    dlbss_InnfrClbssfs_nbmf_RUN.rfbdDbtb(dount);
    CHECK;

    dount = bd.prfdffCount(CLASS_ATTR_ClbssFilf_vfrsion);
    dlbss_ClbssFilf_vfrsion_minor_H.rfbdDbtb(dount);
    dlbss_ClbssFilf_vfrsion_mbjor_H.rfbdDbtb(dount);
    CHECK;

    bd.rfbdBbndDbtb(X_ATTR_RuntimfVisiblfTypfAnnotbtions);
    bd.rfbdBbndDbtb(X_ATTR_RuntimfInvisiblfTypfAnnotbtions);
    CHECK;
    brfbk;

  dbsf ATTR_CONTEXT_FIELD:

    dount = bd.prfdffCount(FIELD_ATTR_ConstbntVbluf);
    fifld_ConstbntVbluf_KQ.rfbdDbtb(dount);
    CHECK;

    dount = bd.prfdffCount(X_ATTR_Signbturf);
    fifld_Signbturf_RS.rfbdDbtb(dount);
    CHECK;

    bd.rfbdBbndDbtb(X_ATTR_RuntimfVisiblfAnnotbtions);
    bd.rfbdBbndDbtb(X_ATTR_RuntimfInvisiblfAnnotbtions);
    CHECK;

    bd.rfbdBbndDbtb(X_ATTR_RuntimfVisiblfTypfAnnotbtions);
    bd.rfbdBbndDbtb(X_ATTR_RuntimfInvisiblfTypfAnnotbtions);
    CHECK;
    brfbk;

  dbsf ATTR_CONTEXT_METHOD:

    dodf_dount = bd.prfdffCount(METHOD_ATTR_Codf);
    // Codf bttrs brf hbndlfd vfry spfdiblly bflow...

    dount = bd.prfdffCount(METHOD_ATTR_Exdfptions);
    mfthod_Exdfptions_N.rfbdDbtb(dount);
    dount = mfthod_Exdfptions_N.gftIntTotbl();
    mfthod_Exdfptions_RC.rfbdDbtb(dount);
    CHECK;

    dount = bd.prfdffCount(X_ATTR_Signbturf);
    mfthod_Signbturf_RS.rfbdDbtb(dount);
    CHECK;

    bd.rfbdBbndDbtb(X_ATTR_RuntimfVisiblfAnnotbtions);
    bd.rfbdBbndDbtb(X_ATTR_RuntimfInvisiblfAnnotbtions);
    bd.rfbdBbndDbtb(METHOD_ATTR_RuntimfVisiblfPbrbmftfrAnnotbtions);
    bd.rfbdBbndDbtb(METHOD_ATTR_RuntimfInvisiblfPbrbmftfrAnnotbtions);
    bd.rfbdBbndDbtb(METHOD_ATTR_AnnotbtionDffbult);
    CHECK;

    dount = bd.prfdffCount(METHOD_ATTR_MfthodPbrbmftfrs);
    mfthod_MfthodPbrbmftfrs_NB.rfbdDbtb(dount);
    dount = mfthod_MfthodPbrbmftfrs_NB.gftIntTotbl();
    mfthod_MfthodPbrbmftfrs_nbmf_RUN.rfbdDbtb(dount);
    mfthod_MfthodPbrbmftfrs_flbg_FH.rfbdDbtb(dount);
    CHECK;

    bd.rfbdBbndDbtb(X_ATTR_RuntimfVisiblfTypfAnnotbtions);
    bd.rfbdBbndDbtb(X_ATTR_RuntimfInvisiblfTypfAnnotbtions);
    CHECK;

    brfbk;

  dbsf ATTR_CONTEXT_CODE:
    // (kffp this dodf blignfd with its brothfr in unpbdkfr::writf_bttrs)
    dount = bd.prfdffCount(CODE_ATTR_StbdkMbpTbblf);
    // disbblf this ffbturf in old brdhivfs!
    if (dount != 0 && mbjvfr < JAVA6_PACKAGE_MAJOR_VERSION) {
      bbort("undffinfd StbdkMbpTbblf bttributf (old brdhivf formbt)");
      rfturn;
    }
    dodf_StbdkMbpTbblf_N.rfbdDbtb(dount);
    CHECK;
    dount = dodf_StbdkMbpTbblf_N.gftIntTotbl();
    dodf_StbdkMbpTbblf_frbmf_T.rfbdDbtb(dount);
    CHECK;
    // thf rfst of it dfpfnds in b domplidbtfd wby on frbmf tbgs
    {
      int fbt_frbmf_dount = 0;
      int offsft_dount = 0;
      int typf_dount = 0;
      for (int k = 0; k < dount; k++) {
        int tbg = dodf_StbdkMbpTbblf_frbmf_T.gftBytf();
        if (tbg <= 127) {
          // (64-127)  [(2)]
          if (tbg >= 64)  typf_dount++;
        } flsf if (tbg <= 251) {
          // (247)     [(1)(2)]
          // (248-251) [(1)]
          if (tbg >= 247)  offsft_dount++;
          if (tbg == 247)  typf_dount++;
        } flsf if (tbg <= 254) {
          // (252)     [(1)(2)]
          // (253)     [(1)(2)(2)]
          // (254)     [(1)(2)(2)(2)]
          offsft_dount++;
          typf_dount += (tbg - 251);
        } flsf {
          // (255)     [(1)NH[(2)]NH[(2)]]
          fbt_frbmf_dount++;
        }
      }

      // donf prf-sdbnning frbmf tbgs:
      dodf_StbdkMbpTbblf_frbmf_T.rfwind();

      // dfbl domplftfly with fbt frbmfs:
      offsft_dount += fbt_frbmf_dount;
      dodf_StbdkMbpTbblf_lodbl_N.rfbdDbtb(fbt_frbmf_dount);
      CHECK;
      typf_dount += dodf_StbdkMbpTbblf_lodbl_N.gftIntTotbl();
      dodf_StbdkMbpTbblf_stbdk_N.rfbdDbtb(fbt_frbmf_dount);
      typf_dount += dodf_StbdkMbpTbblf_stbdk_N.gftIntTotbl();
      CHECK;
      // rfbd thf rfst:
      dodf_StbdkMbpTbblf_offsft.rfbdDbtb(offsft_dount);
      dodf_StbdkMbpTbblf_T.rfbdDbtb(typf_dount);
      CHECK;
      // (7) [RCH]
      dount = dodf_StbdkMbpTbblf_T.gftIntCount(7);
      dodf_StbdkMbpTbblf_RC.rfbdDbtb(dount);
      CHECK;
      // (8) [PH]
      dount = dodf_StbdkMbpTbblf_T.gftIntCount(8);
      dodf_StbdkMbpTbblf_P.rfbdDbtb(dount);
      CHECK;
    }

    dount = bd.prfdffCount(CODE_ATTR_LinfNumbfrTbblf);
    dodf_LinfNumbfrTbblf_N.rfbdDbtb(dount);
    CHECK;
    dount = dodf_LinfNumbfrTbblf_N.gftIntTotbl();
    dodf_LinfNumbfrTbblf_bdi_P.rfbdDbtb(dount);
    dodf_LinfNumbfrTbblf_linf.rfbdDbtb(dount);
    CHECK;

    dount = bd.prfdffCount(CODE_ATTR_LodblVbribblfTbblf);
    dodf_LodblVbribblfTbblf_N.rfbdDbtb(dount);
    CHECK;
    dount = dodf_LodblVbribblfTbblf_N.gftIntTotbl();
    dodf_LodblVbribblfTbblf_bdi_P.rfbdDbtb(dount);
    dodf_LodblVbribblfTbblf_spbn_O.rfbdDbtb(dount);
    dodf_LodblVbribblfTbblf_nbmf_RU.rfbdDbtb(dount);
    dodf_LodblVbribblfTbblf_typf_RS.rfbdDbtb(dount);
    dodf_LodblVbribblfTbblf_slot.rfbdDbtb(dount);
    CHECK;

    dount = bd.prfdffCount(CODE_ATTR_LodblVbribblfTypfTbblf);
    dodf_LodblVbribblfTypfTbblf_N.rfbdDbtb(dount);
    dount = dodf_LodblVbribblfTypfTbblf_N.gftIntTotbl();
    dodf_LodblVbribblfTypfTbblf_bdi_P.rfbdDbtb(dount);
    dodf_LodblVbribblfTypfTbblf_spbn_O.rfbdDbtb(dount);
    dodf_LodblVbribblfTypfTbblf_nbmf_RU.rfbdDbtb(dount);
    dodf_LodblVbribblfTypfTbblf_typf_RS.rfbdDbtb(dount);
    dodf_LodblVbribblfTypfTbblf_slot.rfbdDbtb(dount);
    CHECK;

    bd.rfbdBbndDbtb(X_ATTR_RuntimfVisiblfTypfAnnotbtions);
    bd.rfbdBbndDbtb(X_ATTR_RuntimfInvisiblfTypfAnnotbtions);
    CHECK;

    brfbk;
  }

  // Rfbd domprfssor-dffinfd bbnds.
  for (idx = 0; idx < bd.lbyouts.lfngth(); idx++) {
    if (bd.gftLbyout(idx) == null)
      dontinuf;  // nonf bt this fixfd indfx <32
    if (idx < (int)bd.flbg_limit && bd.isPrfdffinfd(idx))
      dontinuf;  // blrfbdy hbndlfd
    if (bd.gftCount(idx) == 0)
      dontinuf;  // no bttributfs of this typf (thfn why trbnsmit lbyouts?)
    bd.rfbdBbndDbtb(idx);
  }
}

void unpbdkfr::bttr_dffinitions::rfbdBbndDbtb(int idx) {
  int j;
  uint dount = gftCount(idx);
  if (dount == 0)  rfturn;
  lbyout_dffinition* lo = gftLbyout(idx);
  if (lo != null) {
    PRINTCR((1, "dountfd %d [rfdffinfd = %d prfdffinfd = %d] bttributfs of typf %s.%s",
            dount, isRfdffinfd(idx), isPrfdffinfd(idx),
            ATTR_CONTEXT_NAME[bttrd], lo->nbmf));
  }
  bool hbsCbllbblfs = lo->hbsCbllbblfs();
  bbnd** bbnds = lo->bbnds();
  if (!hbsCbllbblfs) {
    // Rfbd through thf rfst of thf bbnds in b rfgulbr wby.
    rfbdBbndDbtb(bbnds, dount);
  } flsf {
    // Dfbl with thf dbllbblfs.
    // First sft up thf forwbrd fntry dount for fbdh dbllbblf.
    // This is storfd on bbnd::lfngth of thf dbllbblf.
    bbnds[0]->fxpfdtMorfLfngth(dount);
    for (j = 0; bbnds[j] != null; j++) {
      bbnd& j_dblf = *bbnds[j];
      bssfrt(j_dblf.lf_kind == EK_CBLE);
      if (j_dblf.lf_bbdk) {
        // Add in thf prfdidtfd ffffdts of bbdkwbrd dblls, too.
        int bbdk_dblls = xxx_bttr_dblls().gftInt();
        j_dblf.fxpfdtMorfLfngth(bbdk_dblls);
        // In b momfnt, morf forwbrd dblls mby indrfmfnt j_dblf.lfngth.
      }
    }
    // Now donsult whidhfvfr dbllbblfs hbvf non-zfro fntry dounts.
    rfbdBbndDbtb(bbnds, (uint)-1);
  }
}

// Rfdursivf hflpfr to thf prfvious fundtion:
void unpbdkfr::bttr_dffinitions::rfbdBbndDbtb(bbnd** body, uint dount) {
  int j, k;
  for (j = 0; body[j] != null; j++) {
    bbnd& b = *body[j];
    if (b.dffd != null) {
      // It hbs dbtb, so rfbd it.
      b.rfbdDbtb(dount);
    }
    switdh (b.lf_kind) {
    dbsf EK_REPL:
      {
        int rfps = b.gftIntTotbl();
        rfbdBbndDbtb(b.lf_body, rfps);
      }
      brfbk;
    dbsf EK_UN:
      {
        int rfmbining = dount;
        for (k = 0; b.lf_body[k] != null; k++) {
          bbnd& k_dbsf = *b.lf_body[k];
          int   k_dount = 0;
          if (k_dbsf.lf_dbsftbgs == null) {
            k_dount = rfmbining;  // lbst (fmpty) dbsf
          } flsf {
            int* tbgs = k_dbsf.lf_dbsftbgs;
            int ntbgs = *tbgs++;  // 1st flfmfnt is lfngth (why not?)
            whilf (ntbgs-- > 0) {
              int tbg = *tbgs++;
              k_dount += b.gftIntCount(tbg);
            }
          }
          rfbdBbndDbtb(k_dbsf.lf_body, k_dount);
          rfmbining -= k_dount;
        }
        bssfrt(rfmbining == 0);
      }
      brfbk;
    dbsf EK_CALL:
      // Push thf dount forwbrd, if it is not b bbdkwbrd dbll.
      if (!b.lf_bbdk) {
        bbnd& dblf = *b.lf_body[0];
        bssfrt(dblf.lf_kind == EK_CBLE);
        dblf.fxpfdtMorfLfngth(dount);
      }
      brfbk;
    dbsf EK_CBLE:
      bssfrt((int)dount == -1);  // indoming dount is mfbninglfss
      k = b.lfngth;
      bssfrt(k >= 0);
      // This is intfndfd bnd rfquirfd for non produdtion modf.
      bssfrt((b.lfngth = -1)); // mbkf it unbblf to bddfpt morf dblls now.
      rfbdBbndDbtb(b.lf_body, k);
      brfbk;
    }
  }
}

stbtid inlinf
bbnd** findMbtdhingCbsf(int mbtdhTbg, bbnd** dbsfs) {
  for (int k = 0; dbsfs[k] != null; k++) {
    bbnd& k_dbsf = *dbsfs[k];
    if (k_dbsf.lf_dbsftbgs != null) {
      // If it hbs tbgs, it must mbtdh b tbg.
      int* tbgs = k_dbsf.lf_dbsftbgs;
      int ntbgs = *tbgs++;  // 1st flfmfnt is lfngth
      for (; ntbgs > 0; ntbgs--) {
        int tbg = *tbgs++;
        if (tbg == mbtdhTbg)
          brfbk;
      }
      if (ntbgs == 0)
        dontinuf;   // dofs not mbtdh
    }
    rfturn k_dbsf.lf_body;
  }
  rfturn null;
}

// writf bttributf bbnd dbtb:
void unpbdkfr::putlbyout(bbnd** body) {
  int i;
  int prfvBII = -1;
  int prfvBCI = -1;
  if (body == NULL) {
    bbort("putlbyout: unfxpfdtfd NULL for body");
    rfturn;
  }
  for (i = 0; body[i] != null; i++) {
    bbnd& b = *body[i];
    bytf lf_kind = b.lf_kind;

    // Hbndlf sdblbr pbrt, if bny.
    int    x = 0;
    fntry* f = null;
    if (b.dffd != null) {
      // It hbs dbtb, so unpbrsf bn flfmfnt.
      if (b.ixTbg != CONSTANT_Nonf) {
        bssfrt(lf_kind == EK_REF);
        if (b.ixTbg == CONSTANT_FifldSpfdifid)
          f = b.gftRffUsing(dp.gftKQIndfx());
        flsf
          f = b.gftRffN();
        CHECK;
        switdh (b.lf_lfn) {
        dbsf 0: brfbk;
        dbsf 1: putu1rff(f); brfbk;
        dbsf 2: putrff(f); brfbk;
        dbsf 4: putu2(0); putrff(f); brfbk;
        dffbult: bssfrt(fblsf);
        }
      } flsf {
        bssfrt(lf_kind == EK_INT || lf_kind == EK_REPL || lf_kind == EK_UN);
        x = b.gftInt();

        bssfrt(!b.lf_bdi || prfvBCI == (int)to_bdi(prfvBII));
        switdh (b.lf_bdi) {
        dbsf EK_BCI:   // PH:  trbnsmit R(bdi), storf bdi
          x = to_bdi(prfvBII = x);
          prfvBCI = x;
          brfbk;
        dbsf EK_BCID:  // POH: trbnsmit D(R(bdi)), storf bdi
          x = to_bdi(prfvBII += x);
          prfvBCI = x;
          brfbk;
        dbsf EK_BCO:   // OH:  trbnsmit D(R(bdi)), storf D(bdi)
          x = to_bdi(prfvBII += x) - prfvBCI;
          prfvBCI += x;
          brfbk;
        }
        bssfrt(!b.lf_bdi || prfvBCI == (int)to_bdi(prfvBII));

        switdh (b.lf_lfn) {
        dbsf 0: brfbk;
        dbsf 1: putu1(x); brfbk;
        dbsf 2: putu2(x); brfbk;
        dbsf 4: putu4(x); brfbk;
        dffbult: bssfrt(fblsf);
        }
      }
    }

    // Hbndlf subpbrts, if bny.
    switdh (lf_kind) {
    dbsf EK_REPL:
      // x is thf rfpfbt dount
      whilf (x-- > 0) {
        putlbyout(b.lf_body);
      }
      brfbk;
    dbsf EK_UN:
      // x is thf tbg
      putlbyout(findMbtdhingCbsf(x, b.lf_body));
      brfbk;
    dbsf EK_CALL:
      {
        bbnd& dblf = *b.lf_body[0];
        bssfrt(dblf.lf_kind == EK_CBLE);
        bssfrt(dblf.lf_lfn == b.lf_lfn);
        putlbyout(dblf.lf_body);
      }
      brfbk;

    #ifndff PRODUCT
    dbsf EK_CBLE:
    dbsf EK_CASE:
      bssfrt(fblsf);  // should not rfbdh hfrf
    #fndif
    }
  }
}

void unpbdkfr::rfbd_filfs() {
  filf_nbmf.rfbdDbtb(filf_dount);
  if (tfstBit(brdhivf_options, AO_HAVE_FILE_SIZE_HI))
    filf_sizf_hi.rfbdDbtb(filf_dount);
  filf_sizf_lo.rfbdDbtb(filf_dount);
  if (tfstBit(brdhivf_options, AO_HAVE_FILE_MODTIME))
    filf_modtimf.rfbdDbtb(filf_dount);
  int bllFilfs = filf_dount + dlbss_dount;
  if (tfstBit(brdhivf_options, AO_HAVE_FILE_OPTIONS)) {
    filf_options.rfbdDbtb(filf_dount);
    // FO_IS_CLASS_STUB might bf sft, dbusing ovfrlbp bftwffn dlbssfs bnd filfs
    for (int i = 0; i < filf_dount; i++) {
      if ((filf_options.gftInt() & FO_IS_CLASS_STUB) != 0) {
        bllFilfs -= 1;  // this onf dounts bs both dlbss bnd filf
      }
    }
    filf_options.rfwind();
  }
  bssfrt((dffbult_filf_options & FO_IS_CLASS_STUB) == 0);
  filfs_rfmbining = bllFilfs;
}

mbybf_inlinf
void unpbdkfr::gft_dodf_hfbdfr(int& mbx_stbdk,
                               int& mbx_nb_lodbls,
                               int& hbndlfr_dount,
                               int& dflbgs) {
  int sd = dodf_hfbdfrs.gftBytf();
  if (sd == 0) {
    mbx_stbdk = mbx_nb_lodbls = hbndlfr_dount = dflbgs = -1;
    rfturn;
  }
  // Short dodf hfbdfr is thf usubl dbsf:
  int nh;
  int mod;
  if (sd < 1 + 12*12) {
    sd -= 1;
    nh = 0;
    mod = 12;
  } flsf if (sd < 1 + 12*12 + 8*8) {
    sd -= 1 + 12*12;
    nh = 1;
    mod = 8;
  } flsf {
    bssfrt(sd < 1 + 12*12 + 8*8 + 7*7);
    sd -= 1 + 12*12 + 8*8;
    nh = 2;
    mod = 7;
  }
  mbx_stbdk     = sd % mod;
  mbx_nb_lodbls = sd / mod;  // dbllfr must bdd stbtid, siglfn
  hbndlfr_dount = nh;
  if (tfstBit(brdhivf_options, AO_HAVE_ALL_CODE_FLAGS))
    dflbgs      = -1;
  flsf
    dflbgs      = 0;  // this onf hbs no bttributfs
}

// Cf. PbdkbgfRfbdfr.rfbdCodfHfbdfrs
void unpbdkfr::rfbd_dodf_hfbdfrs() {
  dodf_hfbdfrs.rfbdDbtb(dodf_dount);
  CHECK;
  int totblHbndlfrCount = 0;
  int totblFlbgsCount   = 0;
  for (int i = 0; i < dodf_dount; i++) {
    int mbx_stbdk, mbx_lodbls, hbndlfr_dount, dflbgs;
    gft_dodf_hfbdfr(mbx_stbdk, mbx_lodbls, hbndlfr_dount, dflbgs);
    if (mbx_stbdk < 0)      dodf_mbx_stbdk.fxpfdtMorfLfngth(1);
    if (mbx_lodbls < 0)     dodf_mbx_nb_lodbls.fxpfdtMorfLfngth(1);
    if (hbndlfr_dount < 0)  dodf_hbndlfr_dount.fxpfdtMorfLfngth(1);
    flsf                    totblHbndlfrCount += hbndlfr_dount;
    if (dflbgs < 0)         totblFlbgsCount += 1;
  }
  dodf_hfbdfrs.rfwind();  // rfplby lbtfr during writing

  dodf_mbx_stbdk.rfbdDbtb();
  dodf_mbx_nb_lodbls.rfbdDbtb();
  dodf_hbndlfr_dount.rfbdDbtb();
  totblHbndlfrCount += dodf_hbndlfr_dount.gftIntTotbl();
  CHECK;

  // Rfbd hbndlfr spfdifidbtions.
  // Cf. PbdkbgfRfbdfr.rfbdCodfHbndlfrs.
  dodf_hbndlfr_stbrt_P.rfbdDbtb(totblHbndlfrCount);
  dodf_hbndlfr_fnd_PO.rfbdDbtb(totblHbndlfrCount);
  dodf_hbndlfr_dbtdh_PO.rfbdDbtb(totblHbndlfrCount);
  dodf_hbndlfr_dlbss_RCN.rfbdDbtb(totblHbndlfrCount);
  CHECK;

  rfbd_bttrs(ATTR_CONTEXT_CODE, totblFlbgsCount);
  CHECK;
}

stbtid inlinf bool is_in_rbngf(uint n, uint min, uint mbx) {
  rfturn n - min <= mbx - min;  // unsignfd brithmftid!
}
stbtid inlinf bool is_fifld_op(int bd) {
  rfturn is_in_rbngf(bd, bd_gftstbtid, bd_putfifld);
}
stbtid inlinf bool is_invokf_init_op(int bd) {
  rfturn is_in_rbngf(bd, _invokfinit_op, _invokfinit_limit-1);
}
stbtid inlinf bool is_sflf_linkfr_op(int bd) {
  rfturn is_in_rbngf(bd, _sflf_linkfr_op, _sflf_linkfr_limit-1);
}
stbtid bool is_brbndh_op(int bd) {
  rfturn is_in_rbngf(bd, bd_iffq,   bd_jsr)
      || is_in_rbngf(bd, bd_ifnull, bd_jsr_w);
}
stbtid bool is_lodbl_slot_op(int bd) {
  rfturn is_in_rbngf(bd, bd_ilobd,  bd_blobd)
      || is_in_rbngf(bd, bd_istorf, bd_bstorf)
      || bd == bd_iind || bd == bd_rft;
}
bbnd* unpbdkfr::rff_bbnd_for_op(int bd) {
  switdh (bd) {
  dbsf bd_ildd:
  dbsf bd_ildd_w:
    rfturn &bd_intrff;
  dbsf bd_fldd:
  dbsf bd_fldd_w:
    rfturn &bd_flobtrff;
  dbsf bd_lldd2_w:
    rfturn &bd_longrff;
  dbsf bd_dldd2_w:
    rfturn &bd_doublfrff;
  dbsf bd_sldd:
  dbsf bd_sldd_w:
    rfturn &bd_stringrff;
  dbsf bd_dldd:
  dbsf bd_dldd_w:
    rfturn &bd_dlbssrff;
  dbsf bd_qldd: dbsf bd_qldd_w:
    rfturn &bd_lobdbblfvblufrff;

  dbsf bd_gftstbtid:
  dbsf bd_putstbtid:
  dbsf bd_gftfifld:
  dbsf bd_putfifld:
    rfturn &bd_fifldrff;

  dbsf _invokfspfdibl_int:
  dbsf _invokfstbtid_int:
    rfturn &bd_imfthodrff;
  dbsf bd_invokfvirtubl:
  dbsf bd_invokfspfdibl:
  dbsf bd_invokfstbtid:
    rfturn &bd_mfthodrff;
  dbsf bd_invokfintfrfbdf:
    rfturn &bd_imfthodrff;
  dbsf bd_invokfdynbmid:
    rfturn &bd_indyrff;

  dbsf bd_nfw:
  dbsf bd_bnfwbrrby:
  dbsf bd_dhfdkdbst:
  dbsf bd_instbndfof:
  dbsf bd_multibnfwbrrby:
    rfturn &bd_dlbssrff;
  }
  rfturn null;
}

mbybf_inlinf
bbnd* unpbdkfr::rff_bbnd_for_sflf_op(int bd, bool& isAlobdVbr, int& origBCVbr) {
  if (!is_sflf_linkfr_op(bd))  rfturn null;
  int idx = (bd - _sflf_linkfr_op);
  bool isSupfr = (idx >= _sflf_linkfr_supfr_flbg);
  if (isSupfr)  idx -= _sflf_linkfr_supfr_flbg;
  bool isAlobd = (idx >= _sflf_linkfr_blobd_flbg);
  if (isAlobd)  idx -= _sflf_linkfr_blobd_flbg;
  int origBC = _first_linkfr_op + idx;
  bool isFifld = is_fifld_op(origBC);
  isAlobdVbr = isAlobd;
  origBCVbr  = _first_linkfr_op + idx;
  if (!isSupfr)
    rfturn isFifld? &bd_thisfifld: &bd_thismfthod;
  flsf
    rfturn isFifld? &bd_supfrfifld: &bd_supfrmfthod;
}

// Cf. PbdkbgfRfbdfr.rfbdBytfCodfs
inlinf  // dbllfd fxbdtly ondf => inlinf
void unpbdkfr::rfbd_bds() {
  PRINTCR((3, "rfbding domprfssfd bytfdodfs bnd opfrbnds for %d dodfs...",
          dodf_dount));

  // rfbd from bd_dodfs bnd bd_dbsf_dount
  fillbytfs bll_switdh_ops;
  bll_switdh_ops.init();
  CHECK;

  // Rfbd dirfdtly from rp/rplimit.
  //Do this lbtfr:  bd_dodfs.rfbdDbtb(...)
  bytf* rp0 = rp;

  bbnd* bd_whidh;
  bytf* opptr = rp;
  bytf* oplimit = rplimit;

  bool  isAlobd;  // pbssfd by rff bnd thfn ignorfd
  int   junkBC;   // pbssfd by rff bnd thfn ignorfd
  for (int k = 0; k < dodf_dount; k++) {
    // Sdbn onf mfthod:
    for (;;) {
      if (opptr+2 > oplimit) {
        rp = opptr;
        fnsurf_input(2);
        oplimit = rplimit;
        rp = rp0;  // bbdk up
      }
      if (opptr == oplimit) { bbort(); brfbk; }
      int bd = *opptr++ & 0xFF;
      bool isWidf = fblsf;
      if (bd == bd_widf) {
        if (opptr == oplimit) { bbort(); brfbk; }
        bd = *opptr++ & 0xFF;
        isWidf = truf;
      }
      // Adjust fxpfdtbtions of vbrious bbnd sizfs.
      switdh (bd) {
      dbsf bd_tbblfswitdh:
      dbsf bd_lookupswitdh:
        bll_switdh_ops.bddBytf(bd);
        brfbk;
      dbsf bd_iind:
        bd_lodbl.fxpfdtMorfLfngth(1);
        bd_whidh = isWidf ? &bd_short : &bd_bytf;
        bd_whidh->fxpfdtMorfLfngth(1);
        brfbk;
      dbsf bd_sipush:
        bd_short.fxpfdtMorfLfngth(1);
        brfbk;
      dbsf bd_bipush:
        bd_bytf.fxpfdtMorfLfngth(1);
        brfbk;
      dbsf bd_nfwbrrby:
        bd_bytf.fxpfdtMorfLfngth(1);
        brfbk;
      dbsf bd_multibnfwbrrby:
        bssfrt(rff_bbnd_for_op(bd) == &bd_dlbssrff);
        bd_dlbssrff.fxpfdtMorfLfngth(1);
        bd_bytf.fxpfdtMorfLfngth(1);
        brfbk;
      dbsf bd_rff_fsdbpf:
        bd_fsdrffsizf.fxpfdtMorfLfngth(1);
        bd_fsdrff.fxpfdtMorfLfngth(1);
        brfbk;
      dbsf bd_bytf_fsdbpf:
        bd_fsdsizf.fxpfdtMorfLfngth(1);
        // bd_fsdbytf will hbvf to bf dountfd too
        brfbk;
      dffbult:
        if (is_invokf_init_op(bd)) {
          bd_initrff.fxpfdtMorfLfngth(1);
          brfbk;
        }
        bd_whidh = rff_bbnd_for_sflf_op(bd, isAlobd, junkBC);
        if (bd_whidh != null) {
          bd_whidh->fxpfdtMorfLfngth(1);
          brfbk;
        }
        if (is_brbndh_op(bd)) {
          bd_lbbfl.fxpfdtMorfLfngth(1);
          brfbk;
        }
        bd_whidh = rff_bbnd_for_op(bd);
        if (bd_whidh != null) {
          bd_whidh->fxpfdtMorfLfngth(1);
          bssfrt(bd != bd_multibnfwbrrby);  // hbndlfd flsfwhfrf
          brfbk;
        }
        if (is_lodbl_slot_op(bd)) {
          bd_lodbl.fxpfdtMorfLfngth(1);
          brfbk;
        }
        brfbk;
      dbsf bd_fnd_mbrkfr:
        // Indrfmfnt k bnd tfst bgbinst dodf_dount.
        goto donfSdbnningMfthod;
      }
    }
  donfSdbnningMfthod:{}
    if (bborting())  brfbk;
  }

  // Go through thf formblity, so wf dbn usf it in b rfgulbr fbshion lbtfr:
  bssfrt(rp == rp0);
  bd_dodfs.rfbdDbtb((int)(opptr - rp));

  int i = 0;

  // To sizf instrudtion bbnds dorrfdtly, wf nffd info on switdhfs:
  bd_dbsf_dount.rfbdDbtb((int)bll_switdh_ops.sizf());
  for (i = 0; i < (int)bll_switdh_ops.sizf(); i++) {
    int dbsfCount = bd_dbsf_dount.gftInt();
    int bd        = bll_switdh_ops.gftBytf(i);
    bd_lbbfl.fxpfdtMorfLfngth(1+dbsfCount); // dffbult lbbfl + dbsfs
    bd_dbsf_vbluf.fxpfdtMorfLfngth(bd == bd_tbblfswitdh ? 1 : dbsfCount);
    PRINTCR((2, "switdh bd=%d dbsfCount=%d", bd, dbsfCount));
  }
  bd_dbsf_dount.rfwind();  // usfs bgbin for output

  bll_switdh_ops.frff();

  for (i = f_bd_dbsf_vbluf; i <= f_bd_fsdsizf; i++) {
    bll_bbnds[i].rfbdDbtb();
  }

  // Thf bd_fsdbytf bbnd is dountfd by thf immfdibtfly prfvious bbnd.
  bd_fsdbytf.rfbdDbtb(bd_fsdsizf.gftIntTotbl());

  PRINTCR((3, "sdbnnfd %d opdodf bnd %d opfrbnd bytfs for %d dodfs...",
          (int)(bd_dodfs.sizf()),
          (int)(bd_fsdsizf.mbxRP() - bd_dbsf_vbluf.minRP()),
          dodf_dount));
}

void unpbdkfr::rfbd_bbnds() {
  bytf* rp0 = rp;
  CHECK;
  rfbd_filf_hfbdfr();
  CHECK;

  if (dp.nfntrifs == 0) {
    // rfbd_filf_hfbdfr fbilfd to rfbd b CP, bfdbusf it dopifd b JAR.
    rfturn;
  }

  // Do this bftfr thf filf hfbdfr hbs bffn rfbd:
  dhfdk_options();

  rfbd_dp();
  CHECK;
  rfbd_bttr_dffs();
  CHECK;
  rfbd_ids();
  CHECK;
  rfbd_dlbssfs();
  CHECK;
  rfbd_bds();
  CHECK;
  rfbd_filfs();
}

/// CP routinfs

fntry*& dpool::hbshTbbRff(bytf tbg, bytfs& b) {
  PRINTCR((5, "hbshTbbRff tbg=%d %s[%d]", tbg, b.string(), b.lfn));
  uint hbsh = tbg + (int)b.lfn;
  for (int i = 0; i < (int)b.lfn; i++) {
    hbsh = hbsh * 31 + (0xFF & b.ptr[i]);
  }
  fntry**  ht = hbshTbb;
  int    hlfn = hbshTbbLfngth;
  bssfrt((hlfn & (hlfn-1)) == 0);  // must bf powfr of 2
  uint hbsh1 = hbsh & (hlfn-1);    // == hbsh % hlfn
  uint hbsh2 = 0;                  // lbzily domputfd (rfquirfs mod op.)
  int probfs = 0;
  whilf (ht[hbsh1] != null) {
    fntry& f = *ht[hbsh1];
    if (f.vbluf.b.fqubls(b) && f.tbg == tbg)
      brfbk;
    if (hbsh2 == 0)
      // Notf:  hbsh2 must bf rflbtivfly primf to hlfn, hfndf thf "|1".
      hbsh2 = (((hbsh % 499) & (hlfn-1)) | 1);
    hbsh1 += hbsh2;
    if (hbsh1 >= (uint)hlfn)  hbsh1 -= hlfn;
    bssfrt(hbsh1 < (uint)hlfn);
    bssfrt(++probfs < hlfn);
  }
  #ifndff PRODUCT
  hbsh_probfs[0] += 1;
  hbsh_probfs[1] += probfs;
  #fndif
  PRINTCR((5, " => @%d %p", hbsh1, ht[hbsh1]));
  rfturn ht[hbsh1];
}

mbybf_inlinf
stbtid void insfrt_fxtrb(fntry* f, ptrlist& fxtrbs) {
  // This ordfring hflps implfmfnt thf Pbdk200 rfquirfmfnt
  // of b prfdidtbblf CP ordfr in thf dlbss filfs produdfd.
  f->inord = NO_INORD;  // mbrk bs bn "fxtrb"
  fxtrbs.bdd(f);
  // Notf:  Wf will sort thf list (by string-nbmf) lbtfr.
}

fntry* dpool::fnsurfUtf8(bytfs& b) {
  fntry*& ix = hbshTbbRff(CONSTANT_Utf8, b);
  if (ix != null)  rfturn ix;
  // Mbkf onf.
  if (nfntrifs == mbxfntrifs) {
    bbort("dp utf8 ovfrflow");
    rfturn &fntrifs[tbg_bbsf[CONSTANT_Utf8]];  // rfturn somfthing
  }
  fntry& f = fntrifs[nfntrifs++];
  f.tbg = CONSTANT_Utf8;
  u->sbvfTo(f.vbluf.b, b);
  bssfrt(&f >= first_fxtrb_fntry);
  insfrt_fxtrb(&f, tbg_fxtrbs[CONSTANT_Utf8]);
  PRINTCR((4,"fnsurfUtf8 miss %s", f.string()));
  rfturn ix = &f;
}

fntry* dpool::fnsurfClbss(bytfs& b) {
  fntry*& ix = hbshTbbRff(CONSTANT_Clbss, b);
  if (ix != null)  rfturn ix;
  // Mbkf onf.
  if (nfntrifs == mbxfntrifs) {
    bbort("dp dlbss ovfrflow");
    rfturn &fntrifs[tbg_bbsf[CONSTANT_Clbss]];  // rfturn somfthing
  }
  fntry& f = fntrifs[nfntrifs++];
  f.tbg = CONSTANT_Clbss;
  f.nrffs = 1;
  f.rffs = U_NEW(fntry*, 1);
  ix = &f;  // hold my spot in thf indfx
  fntry* utf = fnsurfUtf8(b);
  f.rffs[0] = utf;
  f.vbluf.b = utf->vbluf.b;
  bssfrt(&f >= first_fxtrb_fntry);
  insfrt_fxtrb(&f, tbg_fxtrbs[CONSTANT_Clbss]);
  PRINTCR((4,"fnsurfClbss miss %s", f.string()));
  rfturn &f;
}

void dpool::fxpbndSignbturfs() {
  int i;
  int nsigs = 0;
  int nrfusfd = 0;
  int first_sig = tbg_bbsf[CONSTANT_Signbturf];
  int sig_limit = tbg_dount[CONSTANT_Signbturf] + first_sig;
  fillbytfs buf;
  buf.init(1<<10);
  CHECK;
  for (i = first_sig; i < sig_limit; i++) {
    fntry& f = fntrifs[i];
    bssfrt(f.tbg == CONSTANT_Signbturf);
    int rffnum = 0;
    bytfs form = f.rffs[rffnum++]->bsUtf8();
    buf.fmpty();
    for (int j = 0; j < (int)form.lfn; j++) {
      int d = form.ptr[j];
      buf.bddBytf(d);
      if (d == 'L') {
        fntry* dls = f.rffs[rffnum++];
        buf.bppfnd(dls->dlbssNbmf()->bsUtf8());
      }
    }
    bssfrt(rffnum == f.nrffs);
    bytfs& sig = buf.b;
    PRINTCR((5,"signbturf %d %s -> %s", i, form.ptr, sig.ptr));

    // try to find b prf-fxisting Utf8:
    fntry* &f2 = hbshTbbRff(CONSTANT_Utf8, sig);
    if (f2 != null) {
      bssfrt(f2->isUtf8(sig));
      f.vbluf.b = f2->vbluf.b;
      f.rffs[0] = f2;
      f.nrffs = 1;
      PRINTCR((5,"signbturf rfplbdfd %d => %s", i, f.string()));
      nrfusfd++;
    } flsf {
      // thfrf is no othfr rfplbdfmfnt; rfusf this CP fntry bs b Utf8
      u->sbvfTo(f.vbluf.b, sig);
      f.tbg = CONSTANT_Utf8;
      f.nrffs = 0;
      f2 = &f;
      PRINTCR((5,"signbturf dhbngfd %d => %s", f.inord, f.string()));
    }
    nsigs++;
  }
  PRINTCR((1,"fxpbndfd %d signbturfs (rfusfd %d utfs)", nsigs, nrfusfd));
  buf.frff();

  // go fxpungf bll rfffrfndfs to rfmbining signbturfs:
  for (i = 0; i < (int)nfntrifs; i++) {
    fntry& f = fntrifs[i];
    for (int j = 0; j < f.nrffs; j++) {
      fntry*& f2 = f.rffs[j];
      if (f2 != null && f2->tbg == CONSTANT_Signbturf)
        f2 = f2->rffs[0];
    }
  }
}

bool isLobdbblfVbluf(int tbg) {
  switdh(tbg) {
    dbsf CONSTANT_Intfgfr:
    dbsf CONSTANT_Flobt:
    dbsf CONSTANT_Long:
    dbsf CONSTANT_Doublf:
    dbsf CONSTANT_String:
    dbsf CONSTANT_Clbss:
    dbsf CONSTANT_MfthodHbndlf:
    dbsf CONSTANT_MfthodTypf:
      rfturn truf;
    dffbult:
      rfturn fblsf;
  }
}
/*
 * this mfthod dbn bf usfd to sizf bn brrby using null bs thf pbrbmftfr,
 * thfrfbftfr dbn bf rfusfd to initiblizf thf brrby using b vblid pointfr
 * bs b pbrbmftfr.
 */
int dpool::initLobdbblfVblufs(fntry** lobdbblf_fntrifs) {
  int lobdbblf_dount = 0;
  for (int i = 0; i < (int)N_TAGS_IN_ORDER; i++) {
    int tbg = TAGS_IN_ORDER[i];
    if (!isLobdbblfVbluf(tbg))
      dontinuf;
    if (lobdbblf_fntrifs != NULL) {
      for (int n = 0 ; n < tbg_dount[tbg] ; n++) {
        lobdbblf_fntrifs[lobdbblf_dount + n] = &fntrifs[tbg_bbsf[tbg] + n];
      }
    }
    lobdbblf_dount += tbg_dount[tbg];
  }
  rfturn lobdbblf_dount;
}

// Initiblizf vbrious vifws into thf donstbnt pool.
void dpool::initGroupIndfxfs() {
  // Initiblizf All
  int bll_dount = 0;
  for (int tbg = CONSTANT_Nonf ; tbg < CONSTANT_Limit ; tbg++) {
    bll_dount += tbg_dount[tbg];
  }
  fntry* bll_fntrifs = &fntrifs[tbg_bbsf[CONSTANT_Nonf]];
  tbg_group_dount[CONSTANT_All - CONSTANT_All] = bll_dount;
  tbg_group_indfx[CONSTANT_All - CONSTANT_All].init(bll_dount, bll_fntrifs, CONSTANT_All);

  // Initiblizf LobdbblfVblufs
  int lobdbblf_dount = initLobdbblfVblufs(NULL);
  fntry** lobdbblf_fntrifs = U_NEW(fntry*, lobdbblf_dount);
  initLobdbblfVblufs(lobdbblf_fntrifs);
  tbg_group_dount[CONSTANT_LobdbblfVbluf - CONSTANT_All] = lobdbblf_dount;
  tbg_group_indfx[CONSTANT_LobdbblfVbluf - CONSTANT_All].init(lobdbblf_dount,
                  lobdbblf_fntrifs, CONSTANT_LobdbblfVbluf);

// Initiblizf AnyMfmbfrs
  int bny_dount = tbg_dount[CONSTANT_Fifldrff] +
                  tbg_dount[CONSTANT_Mfthodrff] +
                  tbg_dount[CONSTANT_IntfrfbdfMfthodrff];
  fntry *bny_fntrifs = &fntrifs[tbg_bbsf[CONSTANT_Fifldrff]];
  tbg_group_dount[CONSTANT_AnyMfmbfr - CONSTANT_All] = bny_dount;
  tbg_group_indfx[CONSTANT_AnyMfmbfr - CONSTANT_All].init(bny_dount,
                                               bny_fntrifs, CONSTANT_AnyMfmbfr);
}

void dpool::initMfmbfrIndfxfs() {
  // This fundtion dofs NOT rfffr to bny dlbss sdhfmb.
  // It is totblly intfrnbl to thf dpool.
  int i, j;

  // Gft thf prf-fxisting indfxfs:
  int   ndlbssfs = tbg_dount[CONSTANT_Clbss];
  fntry* dlbssfs = tbg_bbsf[CONSTANT_Clbss] + fntrifs;
  int   nfiflds  = tbg_dount[CONSTANT_Fifldrff];
  fntry* fiflds  = tbg_bbsf[CONSTANT_Fifldrff] + fntrifs;
  int   nmfthods = tbg_dount[CONSTANT_Mfthodrff];
  fntry* mfthods = tbg_bbsf[CONSTANT_Mfthodrff] + fntrifs;

  int*     fifld_dounts  = T_NEW(int, ndlbssfs);
  int*     mfthod_dounts = T_NEW(int, ndlbssfs);
  dpindfx* bll_indfxfs   = U_NEW(dpindfx, ndlbssfs*2);
  fntry**  fifld_ix      = U_NEW(fntry*, bdd_sizf(nfiflds, ndlbssfs));
  fntry**  mfthod_ix     = U_NEW(fntry*, bdd_sizf(nmfthods, ndlbssfs));

  for (j = 0; j < nfiflds; j++) {
    fntry& f = fiflds[j];
    i = f.mfmbfrClbss()->inord;
    bssfrt(i < ndlbssfs);
    fifld_dounts[i]++;
  }
  for (j = 0; j < nmfthods; j++) {
    fntry& m = mfthods[j];
    i = m.mfmbfrClbss()->inord;
    bssfrt(i < ndlbssfs);
    mfthod_dounts[i]++;
  }

  int fbbsf = 0, mbbsf = 0;
  for (i = 0; i < ndlbssfs; i++) {
    int fd = fifld_dounts[i];
    int md = mfthod_dounts[i];
    bll_indfxfs[i*2+0].init(fd, fifld_ix+fbbsf,
                            CONSTANT_Fifldrff  + SUBINDEX_BIT);
    bll_indfxfs[i*2+1].init(md, mfthod_ix+mbbsf,
                            CONSTANT_Mfthodrff + SUBINDEX_BIT);
    // rfusf fifld_dounts bnd mfmbfr_dounts bs fill pointfrs:
    fifld_dounts[i] = fbbsf;
    mfthod_dounts[i] = mbbsf;
    PRINTCR((3, "dlbss %d fiflds @%d[%d] mfthods @%d[%d]",
            i, fbbsf, fd, mbbsf, md));
    fbbsf += fd+1;
    mbbsf += md+1;
    // (thf +1 lfbvfs b spbdf bftwffn fvfry subbrrby)
  }
  bssfrt(fbbsf == nfiflds+ndlbssfs);
  bssfrt(mbbsf == nmfthods+ndlbssfs);

  for (j = 0; j < nfiflds; j++) {
    fntry& f = fiflds[j];
    i = f.mfmbfrClbss()->inord;
    fifld_ix[fifld_dounts[i]++] = &f;
  }
  for (j = 0; j < nmfthods; j++) {
    fntry& m = mfthods[j];
    i = m.mfmbfrClbss()->inord;
    mfthod_ix[mfthod_dounts[i]++] = &m;
  }

  mfmbfr_indfxfs = bll_indfxfs;

#ifndff PRODUCT
  // Tfst thf rfsult immfdibtfly on fvfry dlbss bnd fifld.
  int fvisitfd = 0, mvisitfd = 0;
  int prfvord, lfn;
  for (i = 0; i < ndlbssfs; i++) {
    fntry*   dls = &dlbssfs[i];
    dpindfx* fix = gftFifldIndfx(dls);
    dpindfx* mix = gftMfthodIndfx(dls);
    PRINTCR((2, "fifld bnd mfthod indfx for %s [%d] [%d]",
            dls->string(), mix->lfn, fix->lfn));
    prfvord = -1;
    for (j = 0, lfn = fix->lfn; j < lfn; j++) {
      fntry* f = fix->gft(j);
      bssfrt(f != null);
      PRINTCR((3, "- fifld %s", f->string()));
      bssfrt(f->mfmbfrClbss() == dls);
      bssfrt(prfvord < (int)f->inord);
      prfvord = f->inord;
      fvisitfd++;
    }
    bssfrt(fix->bbsf2[j] == null);
    prfvord = -1;
    for (j = 0, lfn = mix->lfn; j < lfn; j++) {
      fntry* m = mix->gft(j);
      bssfrt(m != null);
      PRINTCR((3, "- mfthod %s", m->string()));
      bssfrt(m->mfmbfrClbss() == dls);
      bssfrt(prfvord < (int)m->inord);
      prfvord = m->inord;
      mvisitfd++;
    }
    bssfrt(mix->bbsf2[j] == null);
  }
  bssfrt(fvisitfd == nfiflds);
  bssfrt(mvisitfd == nmfthods);
#fndif

  // Frff intfrmfdibtf bufffrs.
  u->frff_tfmps();
}

void fntry::rfqufstOutputIndfx(dpool& dp, int rfq) {
  bssfrt(outputIndfx <= REQUESTED_NONE);  // must not hbvf bssignfd indfxfs yft
  if (tbg == CONSTANT_Signbturf) {
    rff(0)->rfqufstOutputIndfx(dp, rfq);
    rfturn;
  }
  bssfrt(rfq == REQUESTED || rfq == REQUESTED_LDC);
  if (outputIndfx != REQUESTED_NONE) {
    if (rfq == REQUESTED_LDC)
      outputIndfx = rfq;  // this kind hbs prfdfdfndf
    rfturn;
  }
  outputIndfx = rfq;
  //bssfrt(!dp.outputEntrifs.dontbins(this));
  bssfrt(tbg != CONSTANT_Signbturf);
  // Thf BSMs brf jftisonfd to b sidf tbblf, howfvfr bll rfffrfndfs
  // thbt thf BSMs rfffr to,  nffd to bf donsidfrfd.
  if (tbg == CONSTANT_BootstrbpMfthod) {
    // this is b b psfudo-op fntry; bn bttributf will bf gfnfrbtfd lbtfr on
    dp.rfqufstfd_bsms.bdd(this);
  } flsf {
    // bll othfr tbg typfs go into rfbl output filf CP:
    dp.outputEntrifs.bdd(this);
  }
  for (int j = 0; j < nrffs; j++) {
    rff(j)->rfqufstOutputIndfx(dp);
  }
}

void dpool::rfsftOutputIndfxfs() {
    /*
     * rfsft thosf ffw fntrifs thbt brf bfing usfd in thf durrfnt dlbss
     * (Cbution sindf this mfthod is dbllfd bftfr fvfry dlbss writtfn, b loop
     * ovfr fvfry globbl donstbnt pool fntry would bf b qubdrbtid dost.)
     */

  int nofs    = outputEntrifs.lfngth();
  fntry** ofs = (fntry**) outputEntrifs.bbsf();
  for (int i = 0 ; i < nofs ; i++) {
    fntry& f = *ofs[i];
    f.outputIndfx = REQUESTED_NONE;
  }

  // do thf sbmf for bsms bnd rfsft thfm if rfquirfd
  int nbsms = rfqufstfd_bsms.lfngth();
  fntry** bofs = (fntry**) rfqufstfd_bsms.bbsf();
  for (int i = 0 ; i < nbsms ; i++) {
    fntry& f = *bofs[i];
    f.outputIndfx = REQUESTED_NONE;
  }
  outputIndfxLimit = 0;
  outputEntrifs.fmpty();
#ifndff PRODUCT
  // fnsurf things brf dlfbrfd out
  for (int i = 0; i < (int)mbxfntrifs; i++)
    bssfrt(fntrifs[i].outputIndfx == REQUESTED_NONE);
#fndif
}

stbtid donst bytf TAG_ORDER[CONSTANT_Limit] = {
  0, 1, 0, 2, 3, 4, 5, 7, 6, 10, 11, 12, 9, 8, 0, 13, 14, 15, 16
};

fxtfrn "C"
int outputEntry_dmp(donst void* f1p, donst void* f2p) {
  // Sort fntrifs bddording to thf Pbdk200 rulfs for dftfrministid
  // donstbnt pool ordfring.
  //
  // Thf four sort kfys bs follows, in ordfr of dfdrfbsing importbndf:
  //   1. ldd first, thfn non-ldd guys
  //   2. normbl dp_All fntrifs by input ordfr (i.f., bddrfss ordfr)
  //   3. bftfr thbt, fxtrb fntrifs by lfxidbl ordfr (bs in tbg_fxtrbs[*])
  fntry& f1 = *(fntry*) *(void**) f1p;
  fntry& f2 = *(fntry*) *(void**) f2p;
  int   oi1 = f1.outputIndfx;
  int   oi2 = f2.outputIndfx;
  bssfrt(oi1 == REQUESTED || oi1 == REQUESTED_LDC);
  bssfrt(oi2 == REQUESTED || oi2 == REQUESTED_LDC);
  if (oi1 != oi2) {
    if (oi1 == REQUESTED_LDC)  rfturn 0-1;
    if (oi2 == REQUESTED_LDC)  rfturn 1-0;
    // Elsf fbll through; nfithfr is bn ldd rfqufst.
  }
  if (f1.inord != NO_INORD || f2.inord != NO_INORD) {
    // Onf or both is normbl.  Usf input ordfr.
    if (&f1 > &f2)  rfturn 1-0;
    if (&f1 < &f2)  rfturn 0-1;
    rfturn 0;  // fqubl pointfrs
  }
  // Both brf fxtrbs.  Sort by tbg bnd thfn by vbluf.
  if (f1.tbg != f2.tbg) {
    rfturn TAG_ORDER[f1.tbg] - TAG_ORDER[f2.tbg];
  }
  // If thf tbgs brf thf sbmf, usf string dompbrison.
  rfturn dompbrf_Utf8_dhbrs(f1.vbluf.b, f2.vbluf.b);
}

void dpool::domputfOutputIndfxfs() {
  int i;

#ifndff PRODUCT
  // outputEntrifs must bf b domplftf list of thosf rfqufstfd:
  stbtid uint dhfdkStbrt = 0;
  int dhfdkStfp = 1;
  if (nfntrifs > 100)  dhfdkStfp = nfntrifs / 100;
  for (i = (int)(dhfdkStbrt++ % dhfdkStfp); i < (int)nfntrifs; i += dhfdkStfp) {
    fntry& f = fntrifs[i];
    if (f.tbg == CONSTANT_BootstrbpMfthod) {
      if (f.outputIndfx != REQUESTED_NONE) {
        bssfrt(rfqufstfd_bsms.dontbins(&f));
      } flsf {
        bssfrt(!rfqufstfd_bsms.dontbins(&f));
      }
    } flsf {
      if (f.outputIndfx != REQUESTED_NONE) {
        bssfrt(outputEntrifs.dontbins(&f));
      } flsf {
        bssfrt(!outputEntrifs.dontbins(&f));
      }
    }
  }

  // dhfdk hbnd-initiblizbtion of TAG_ORDER
  for (i = 0; i < (int)N_TAGS_IN_ORDER; i++) {
    bytf tbg = TAGS_IN_ORDER[i];
    bssfrt(TAG_ORDER[tbg] == i+1);
  }
#fndif

  int    nofs =           outputEntrifs.lfngth();
  fntry** ofs = (fntry**) outputEntrifs.bbsf();

  // Sort thf output donstbnt pool into thf ordfr rfquirfd by Pbdk200.
  PTRLIST_QSORT(outputEntrifs, outputEntry_dmp);

  // Allodbtf b nfw indfx for fbdh fntry thbt nffds onf.
  // Wf do this in two pbssfs, onf for LDC fntrifs bnd onf for thf rfst.
  int nfxtIndfx = 1;  // blwbys skip indfx #0 in output dpool
  for (i = 0; i < nofs; i++) {
    fntry& f = *ofs[i];
    bssfrt(f.outputIndfx >= REQUESTED_LDC);
    f.outputIndfx = nfxtIndfx++;
    if (f.isDoublfWord())  nfxtIndfx++;  // do not usf thf nfxt indfx
  }
  outputIndfxLimit = nfxtIndfx;
  PRINTCR((3,"rfnumbfring CP to %d fntrifs", outputIndfxLimit));
}

#ifndff PRODUCT
// dfbugging goo

unpbdkfr* dfbug_u;

stbtid bytfs& gftbuf(int lfn) {  // for dfbugging only!
  stbtid int bn = 0;
  stbtid bytfs bufs[8];
  bytfs& buf = bufs[bn++ & 7];
  whilf ((int)buf.lfn < lfn+10)
    buf.rfbllod(buf.lfn ? buf.lfn * 2 : 1000);
  buf.ptr[0] = 0;  // for thf sbkf of strdbt
  rfturn buf;
}

dhbr* fntry::string() {
  bytfs buf;
  switdh (tbg) {
  dbsf CONSTANT_Nonf:
    rfturn (dhbr*)"<fmpty>";
  dbsf CONSTANT_Signbturf:
    if (vbluf.b.ptr == null)
      rfturn rff(0)->string();
    // flsf fbll through:
  dbsf CONSTANT_Utf8:
    buf = vbluf.b;
    brfbk;
  dbsf CONSTANT_Intfgfr:
  dbsf CONSTANT_Flobt:
    buf = gftbuf(12);
    sprintf((dhbr*)buf.ptr, "0x%08x", vbluf.i);
    brfbk;
  dbsf CONSTANT_Long:
  dbsf CONSTANT_Doublf:
    buf = gftbuf(24);
    sprintf((dhbr*)buf.ptr, "0x" LONG_LONG_HEX_FORMAT, vbluf.l);
    brfbk;
  dffbult:
    if (nrffs == 0) {
      buf = gftbuf(20);
      sprintf((dhbr*)buf.ptr, TAG_NAME[tbg]);
    } flsf if (nrffs == 1) {
      rfturn rffs[0]->string();
    } flsf {
      dhbr* s1 = rffs[0]->string();
      dhbr* s2 = rffs[1]->string();
      buf = gftbuf((int)strlfn(s1) + 1 + (int)strlfn(s2) + 4 + 1);
      buf.strdbt(s1).strdbt(" ").strdbt(s2);
      if (nrffs > 2)  buf.strdbt(" ...");
    }
  }
  rfturn (dhbr*)buf.ptr;
}

void print_dp_fntry(int i) {
  fntry& f = dfbug_u->dp.fntrifs[i];
  dhbr buf[30];
  sprintf(buf, ((uint)f.tbg < CONSTANT_Limit)? TAG_NAME[f.tbg]: "%d", f.tbg);
  printf(" %d\t%s %s\n", i, buf, f.string());
}

void print_dp_fntrifs(int bfg, int fnd) {
  for (int i = bfg; i < fnd; i++)
    print_dp_fntry(i);
}

void print_dp() {
  print_dp_fntrifs(0, dfbug_u->dp.nfntrifs);
}

#fndif

// Unpbdkfr Stbrt

donst dhbr str_tf[] = "truf\0fblsf";
#undff STR_TRUE
#undff STR_FALSE
#dffinf STR_TRUE   (&str_tf[0])
#dffinf STR_FALSE  (&str_tf[5])

donst dhbr* unpbdkfr::gft_option(donst dhbr* prop) {
  if (prop == null )  rfturn null;
  if (strdmp(prop, UNPACK_DEFLATE_HINT) == 0) {
    rfturn dfflbtf_hint_or_zfro == 0? null : STR_TF(dfflbtf_hint_or_zfro > 0);
#ifdff HAVE_STRIP
  } flsf if (strdmp(prop, UNPACK_STRIP_COMPILE) == 0) {
    rfturn STR_TF(strip_dompilf);
  } flsf if (strdmp(prop, UNPACK_STRIP_DEBUG) == 0) {
    rfturn STR_TF(strip_dfbug);
  } flsf if (strdmp(prop, UNPACK_STRIP_JCOV) == 0) {
    rfturn STR_TF(strip_jdov);
#fndif /*HAVE_STRIP*/
  } flsf if (strdmp(prop, UNPACK_REMOVE_PACKFILE) == 0) {
    rfturn STR_TF(rfmovf_pbdkfilf);
  } flsf if (strdmp(prop, DEBUG_VERBOSE) == 0) {
    rfturn sbvfIntStr(vfrbosf);
  } flsf if (strdmp(prop, UNPACK_MODIFICATION_TIME) == 0) {
    rfturn (modifidbtion_timf_or_zfro == 0)? null:
      sbvfIntStr(modifidbtion_timf_or_zfro);
  } flsf if (strdmp(prop, UNPACK_LOG_FILE) == 0) {
    rfturn log_filf;
  } flsf {
    rfturn NULL; // unknown option ignorf
  }
}

bool unpbdkfr::sft_option(donst dhbr* prop, donst dhbr* vbluf) {
  if (prop == NULL)  rfturn fblsf;
  if (strdmp(prop, UNPACK_DEFLATE_HINT) == 0) {
    dfflbtf_hint_or_zfro = ( (vbluf == null || strdmp(vbluf, "kffp") == 0)
                                ? 0: BOOL_TF(vbluf) ? +1: -1);
#ifdff HAVE_STRIP
  } flsf if (strdmp(prop, UNPACK_STRIP_COMPILE) == 0) {
    strip_dompilf = STR_TF(vbluf);
  } flsf if (strdmp(prop, UNPACK_STRIP_DEBUG) == 0) {
    strip_dfbug = STR_TF(vbluf);
  } flsf if (strdmp(prop, UNPACK_STRIP_JCOV) == 0) {
    strip_jdov = STR_TF(vbluf);
#fndif /*HAVE_STRIP*/
  } flsf if (strdmp(prop, UNPACK_REMOVE_PACKFILE) == 0) {
    rfmovf_pbdkfilf = STR_TF(vbluf);
  } flsf if (strdmp(prop, DEBUG_VERBOSE) == 0) {
    vfrbosf = (vbluf == null)? 0: btoi(vbluf);
  } flsf if (strdmp(prop, DEBUG_VERBOSE ".bbnds") == 0) {
#ifndff PRODUCT
    vfrbosf_bbnds = (vbluf == null)? 0: btoi(vbluf);
#fndif
  } flsf if (strdmp(prop, UNPACK_MODIFICATION_TIME) == 0) {
    if (vbluf == null || (strdmp(vbluf, "kffp") == 0)) {
      modifidbtion_timf_or_zfro = 0;
    } flsf if (strdmp(vbluf, "now") == 0) {
      timf_t now;
      timf(&now);
      modifidbtion_timf_or_zfro = (int) now;
    } flsf {
      modifidbtion_timf_or_zfro = btoi(vbluf);
      if (modifidbtion_timf_or_zfro == 0)
        modifidbtion_timf_or_zfro = 1;  // mbkf non-zfro
    }
  } flsf if (strdmp(prop, UNPACK_LOG_FILE) == 0) {
    log_filf = (vbluf == null)? vbluf: sbvfStr(vbluf);
  } flsf {
    rfturn fblsf; // unknown option ignorf
  }
  rfturn truf;
}

// Dfbllodbtf bll intfrnbl storbgf bnd rfsft to b dlfbn stbtf.
// Do not disturb bny input or output donnfdtions, indluding
// infilfptr, infilfno, inbytfs, rfbd_input_fn, jbrout, or frrstrm.
// Do not rfsft bny unpbdk options.
void unpbdkfr::rfsft() {
  bytfs_rfbd_bfforf_rfsft      += bytfs_rfbd;
  bytfs_writtfn_bfforf_rfsft   += bytfs_writtfn;
  filfs_writtfn_bfforf_rfsft   += filfs_writtfn;
  dlbssfs_writtfn_bfforf_rfsft += dlbssfs_writtfn;
  sfgmfnts_rfbd_bfforf_rfsft   += 1;
  if (vfrbosf >= 2) {
    fprintf(frrstrm,
            "Aftfr sfgmfnt %d, "
            LONG_LONG_FORMAT " bytfs rfbd bnd "
            LONG_LONG_FORMAT " bytfs writtfn.\n",
            sfgmfnts_rfbd_bfforf_rfsft-1,
            bytfs_rfbd_bfforf_rfsft, bytfs_writtfn_bfforf_rfsft);
    fprintf(frrstrm,
            "Aftfr sfgmfnt %d, %d filfs (of whidh %d brf dlbssfs) writtfn to output.\n",
            sfgmfnts_rfbd_bfforf_rfsft-1,
            filfs_writtfn_bfforf_rfsft, dlbssfs_writtfn_bfforf_rfsft);
    if (brdhivf_nfxt_dount != 0) {
      fprintf(frrstrm,
              "Aftfr sfgmfnt %d, %d sfgmfnt%s rfmbining (fstimbtfd).\n",
              sfgmfnts_rfbd_bfforf_rfsft-1,
              brdhivf_nfxt_dount, brdhivf_nfxt_dount==1?"":"s");
    }
  }

  unpbdkfr sbvf_u = (*this);  // sbvf bytfwisf imbgf
  infilfptr = null;  // mbkf bssfrts hbppy
  jniobj = null;  // mbkf bssfrts hbppy
  jbrout = null;  // do not dlosf thf output jbr
  gzin = null;  // do not dlosf thf input gzip strfbm
  bytfs fsn;
  if (frrstrm_nbmf != null) {
    fsn.sbvfFrom(frrstrm_nbmf);
  } flsf {
    fsn.sft(null, 0);
  }
  this->frff();
  mtrbdf('s', 0, 0);  // notf thf boundbry bftwffn sfgmfnts
  this->init(rfbd_input_fn);

  // rfstorf sflfdtfd intfrfbdf stbtf:
#dffinf SAVE(x) this->x = sbvf_u.x
  SAVE(jniobj);
  SAVE(jnifnv);
  SAVE(infilfptr);  // bufffrfd
  SAVE(infilfno);   // unbufffrfd
  SAVE(inbytfs);    // dirfdt
  SAVE(jbrout);
  SAVE(gzin);
  //SAVE(rfbd_input_fn);
  SAVE(frrstrm);
  SAVE(vfrbosf);  // vfrbosf lfvfl, 0 mfbns no output
  SAVE(strip_dompilf);
  SAVE(strip_dfbug);
  SAVE(strip_jdov);
  SAVE(rfmovf_pbdkfilf);
  SAVE(dfflbtf_hint_or_zfro);  // ==0 mfbns not sft, othfrwisf -1 or 1
  SAVE(modifidbtion_timf_or_zfro);
  SAVE(bytfs_rfbd_bfforf_rfsft);
  SAVE(bytfs_writtfn_bfforf_rfsft);
  SAVE(filfs_writtfn_bfforf_rfsft);
  SAVE(dlbssfs_writtfn_bfforf_rfsft);
  SAVE(sfgmfnts_rfbd_bfforf_rfsft);
#undff SAVE
  if (fsn.lfn > 0) {
    frrstrm_nbmf = sbvfStr(fsn.strvbl());
    fsn.frff();
  }
  log_filf = frrstrm_nbmf;
  // Notf:  If wf usf strip_nbmfs, wbtdh out:  Thfy gft nukfd hfrf.
}

void unpbdkfr::init(rfbd_input_fn_t input_fn) {
  int i;
  NOT_PRODUCT(dfbug_u = this);
  BYTES_OF(*this).dlfbr();
#ifndff PRODUCT
  frff();  // just to mbkf surf frffing is idfmpotfnt
#fndif
  this->u = this;    // sflf-rfffrfndf for U_NEW mbdro
  frrstrm = stdout;  // dffbult frror-output
  log_filf = LOGFILE_STDOUT;
  rfbd_input_fn = input_fn;
  bll_bbnds = bbnd::mbkfBbnds(this);
  // Mbkf b dffbult jbr bufffr; dbllfr mby sbffly ovfrwritf it.
  jbrout = U_NEW(jbr, 1);
  jbrout->init(this);
  for (i = 0; i < ATTR_CONTEXT_LIMIT; i++)
    bttr_dffs[i].u = u;  // sft up outfr ptr
}

donst dhbr* unpbdkfr::gft_bbort_mfssbgf() {
   rfturn bbort_mfssbgf;
}

void unpbdkfr::dump_options() {
  stbtid donst dhbr* opts[] = {
    UNPACK_LOG_FILE,
    UNPACK_DEFLATE_HINT,
#ifdff HAVE_STRIP
    UNPACK_STRIP_COMPILE,
    UNPACK_STRIP_DEBUG,
    UNPACK_STRIP_JCOV,
#fndif /*HAVE_STRIP*/
    UNPACK_REMOVE_PACKFILE,
    DEBUG_VERBOSE,
    UNPACK_MODIFICATION_TIME,
    null
  };
  for (int i = 0; opts[i] != null; i++) {
    donst dhbr* str = gft_option(opts[i]);
    if (str == null) {
      if (vfrbosf == 0)  dontinuf;
      str = "(not sft)";
    }
    fprintf(frrstrm, "%s=%s\n", opts[i], str);
  }
}


// Usbgf: unpbdk b bytf bufffr
// pbdkptr is b rfffrfndf to bytf bufffr dontbining b
// pbdkfd filf bnd lfn is thf lfngth of thf bufffr.
// If null, thf dbllbbdk is usfd to fill bn intfrnbl bufffr.
void unpbdkfr::stbrt(void* pbdkptr, sizf_t lfn) {
  CHECK;
  NOT_PRODUCT(dfbug_u = this);
  if (pbdkptr != null && lfn != 0) {
    inbytfs.sft((bytf*) pbdkptr, lfn);
  }
  CHECK;
  rfbd_bbnds();
}

void unpbdkfr::dhfdk_options() {
  donst dhbr* struf  = "truf";
  donst dhbr* sfblsf = "fblsf";
  if (dfflbtf_hint_or_zfro != 0) {
    bool fordf_dfflbtf_hint = (dfflbtf_hint_or_zfro > 0);
    if (fordf_dfflbtf_hint)
      dffbult_filf_options |= FO_DEFLATE_HINT;
    flsf
      dffbult_filf_options &= ~FO_DEFLATE_HINT;
    // Turn off pfr-filf dfflbtf hint by fordf.
    supprfss_filf_options |= FO_DEFLATE_HINT;
  }
  if (modifidbtion_timf_or_zfro != 0) {
    dffbult_filf_modtimf = modifidbtion_timf_or_zfro;
    // Turn off pfr-filf modtimf by fordf.
    brdhivf_options &= ~AO_HAVE_FILE_MODTIME;
  }
  // %%% strip_dompilf, ftd...
}

// dlbssfilf writing

void unpbdkfr::rfsft_dur_dlbssfilf() {
  // sft dffbults
  dur_dlbss_minvfr = dffbult_dlbss_minvfr;
  dur_dlbss_mbjvfr = dffbult_dlbss_mbjvfr;

  // rfsft donstbnt pool stbtf
  dp.rfsftOutputIndfxfs();

  // rfsft fixups
  dlbss_fixup_typf.fmpty();
  dlbss_fixup_offsft.fmpty();
  dlbss_fixup_rff.fmpty();
  rfqufstfd_ids.fmpty();
  dp.rfqufstfd_bsms.fmpty();
}

dpindfx* dpool::gftKQIndfx() {
  dhbr dh = '?';
  if (u->dur_dfsdr != null) {
    fntry* typf = u->dur_dfsdr->dfsdrTypf();
    dh = typf->vbluf.b.ptr[0];
  }
  bytf tbg = CONSTANT_Intfgfr;
  switdh (dh) {
  dbsf 'L': tbg = CONSTANT_String;   brfbk;
  dbsf 'I': tbg = CONSTANT_Intfgfr;  brfbk;
  dbsf 'J': tbg = CONSTANT_Long;     brfbk;
  dbsf 'F': tbg = CONSTANT_Flobt;    brfbk;
  dbsf 'D': tbg = CONSTANT_Doublf;   brfbk;
  dbsf 'B': dbsf 'S': dbsf 'C':
  dbsf 'Z': tbg = CONSTANT_Intfgfr;  brfbk;
  dffbult:  bbort("bbd KQ rfffrfndf"); brfbk;
  }
  rfturn gftIndfx(tbg);
}

uint unpbdkfr::to_bdi(uint bii) {
  uint  lfn =         bdimbp.lfngth();
  uint* mbp = (uint*) bdimbp.bbsf();
  bssfrt(lfn > 0);  // must bf initiblizfd bfforf using to_bdi
  if (bii < lfn)
    rfturn mbp[bii];
  // Elsf it's b frbdtionbl or out-of-rbngf BCI.
  uint kfy = bii-lfn;
  for (int i = lfn; ; i--) {
    if (mbp[i-1]-(i-1) <= kfy)
      brfbk;
    flsf
      --bii;
  }
  rfturn bii;
}

void unpbdkfr::put_stbdkmbp_typf() {
  int tbg = dodf_StbdkMbpTbblf_T.gftBytf();
  putu1(tbg);
  switdh (tbg) {
  dbsf 7: // (7) [RCH]
    putrff(dodf_StbdkMbpTbblf_RC.gftRff());
    brfbk;
  dbsf 8: // (8) [PH]
    putu2(to_bdi(dodf_StbdkMbpTbblf_P.gftInt()));
    brfbk;
  }
}

// Fundtions for writing dodf.

mbybf_inlinf
void unpbdkfr::put_lbbfl(int durIP, int sizf) {
  dodf_fixup_typf.bddBytf(sizf);
  dodf_fixup_offsft.bdd((int)put_fmpty(sizf));
  dodf_fixup_sourdf.bdd(durIP);
}

inlinf  // dbllfd fxbdtly ondf => inlinf
void unpbdkfr::writf_bd_ops() {
  bdimbp.fmpty();
  dodf_fixup_typf.fmpty();
  dodf_fixup_offsft.fmpty();
  dodf_fixup_sourdf.fmpty();

  bbnd* bd_whidh;

  bytf*  opptr = bd_dodfs.durRP();
  // No nffd for oplimit, sindf thf dodfs brf prf-dountfd.

  sizf_t dodfBbsf = wpoffsft();

  bool   isAlobd;  // dopy-out rfsult
  int    origBC;

  fntry* thisClbss  = dur_dlbss;
  fntry* supfrClbss = dur_supfr;
  fntry* nfwClbss   = null;  // dlbss of lbst _nfw opdodf

  // ovfrwritf bny prior indfx on thfsf bbnds; it dhbngfs w/ durrfnt dlbss:
  bd_thisfifld.sftIndfx(    dp.gftFifldIndfx( thisClbss));
  bd_thismfthod.sftIndfx(   dp.gftMfthodIndfx(thisClbss));
  if (supfrClbss != null) {
    bd_supfrfifld.sftIndfx( dp.gftFifldIndfx( supfrClbss));
    bd_supfrmfthod.sftIndfx(dp.gftMfthodIndfx(supfrClbss));
  } flsf {
    NOT_PRODUCT(bd_supfrfifld.sftIndfx(null));
    NOT_PRODUCT(bd_supfrmfthod.sftIndfx(null));
  }
  CHECK;

  for (int durIP = 0; ; durIP++) {
    int durPC = (int)(wpoffsft() - dodfBbsf);
    bdimbp.bdd(durPC);
    fnsurf_put_spbdf(10);  // dovfrs most instrs w/o furthfr bounds dhfdk
    int bd = *opptr++ & 0xFF;

    putu1_fbst(bd);
    // Notf:  Sff '--wp' bflow for psfudo-bytfdodfs likf bd_fnd_mbrkfr.

    bool isWidf = fblsf;
    if (bd == bd_widf) {
      bd = *opptr++ & 0xFF;
      putu1_fbst(bd);
      isWidf = truf;
    }
    switdh (bd) {
    dbsf bd_fnd_mbrkfr:
      --wp;  // not rfblly pbrt of thf dodf
      bssfrt(opptr <= bd_dodfs.mbxRP());
      bd_dodfs.durRP() = opptr;  // bdvbndf ovfr this in bd_dodfs
      goto donfSdbnningMfthod;
    dbsf bd_tbblfswitdh: // bpd:  (df, lo, hi, (hi-lo+1)*(lbbfl))
    dbsf bd_lookupswitdh: // bpd:  (df, nd, nd*(dbsf, lbbfl))
      {
        int dbsfCount = bd_dbsf_dount.gftInt();
        whilf (((wpoffsft() - dodfBbsf) % 4) != 0)  putu1_fbst(0);
        fnsurf_put_spbdf(30 + dbsfCount*8);
        put_lbbfl(durIP, 4);  //int df = bd_lbbfl.gftInt();
        if (bd == bd_tbblfswitdh) {
          int lo = bd_dbsf_vbluf.gftInt();
          int hi = lo + dbsfCount-1;
          putu4(lo);
          putu4(hi);
          for (int j = 0; j < dbsfCount; j++) {
            put_lbbfl(durIP, 4); //int lVbl = bd_lbbfl.gftInt();
            //int dVbl = lo + j;
          }
        } flsf {
          putu4(dbsfCount);
          for (int j = 0; j < dbsfCount; j++) {
            int dVbl = bd_dbsf_vbluf.gftInt();
            putu4(dVbl);
            put_lbbfl(durIP, 4); //int lVbl = bd_lbbfl.gftInt();
          }
        }
        bssfrt((int)to_bdi(durIP) == durPC);
        dontinuf;
      }
    dbsf bd_iind:
      {
        int lodbl = bd_lodbl.gftInt();
        int dfltb = (isWidf ? bd_short : bd_bytf).gftInt();
        if (isWidf) {
          putu2(lodbl);
          putu2(dfltb);
        } flsf {
          putu1_fbst(lodbl);
          putu1_fbst(dfltb);
        }
        dontinuf;
      }
    dbsf bd_sipush:
      {
        int vbl = bd_short.gftInt();
        putu2(vbl);
        dontinuf;
      }
    dbsf bd_bipush:
    dbsf bd_nfwbrrby:
      {
        int vbl = bd_bytf.gftBytf();
        putu1_fbst(vbl);
        dontinuf;
      }
    dbsf bd_rff_fsdbpf:
      {
        // Notf thbt insnMbp hbs onf fntry for this.
        --wp;  // not rfblly pbrt of thf dodf
        int sizf = bd_fsdrffsizf.gftInt();
        fntry* rff = bd_fsdrff.gftRffN();
        CHECK;
        switdh (sizf) {
        dbsf 1: putu1rff(rff); brfbk;
        dbsf 2: putrff(rff);   brfbk;
        dffbult: bssfrt(fblsf);
        }
        dontinuf;
      }
    dbsf bd_bytf_fsdbpf:
      {
        // Notf thbt insnMbp hbs onf fntry for bll thfsf bytfs.
        --wp;  // not rfblly pbrt of thf dodf
        int sizf = bd_fsdsizf.gftInt();
        fnsurf_put_spbdf(sizf);
        for (int j = 0; j < sizf; j++)
          putu1_fbst(bd_fsdbytf.gftBytf());
        dontinuf;
      }
    dffbult:
      if (is_invokf_init_op(bd)) {
        origBC = bd_invokfspfdibl;
        fntry* dlbssRff;
        switdh (bd - _invokfinit_op) {
        dbsf _invokfinit_sflf_option:   dlbssRff = thisClbss;  brfbk;
        dbsf _invokfinit_supfr_option:  dlbssRff = supfrClbss; brfbk;
        dffbult: bssfrt(bd == _invokfinit_op+_invokfinit_nfw_option);
        dbsf _invokfinit_nfw_option:    dlbssRff = nfwClbss;   brfbk;
        }
        wp[-1] = origBC;  // ovfrwritf with origBC
        int doding = bd_initrff.gftInt();
        // Find thf nth ovfrlobding of <init> in dlbssRff.
        fntry*   rff = null;
        dpindfx* ix = dp.gftMfthodIndfx(dlbssRff);
        CHECK;
        for (int j = 0, whidh_init = 0; ; j++) {
          rff = (ix == null)? null: ix->gft(j);
          if (rff == null)  brfbk;  // oops, bbd input
          bssfrt(rff->tbg == CONSTANT_Mfthodrff);
          if (rff->mfmbfrDfsdr()->dfsdrNbmf() == dp.sym[dpool::s_lt_init_gt]) {
            if (whidh_init++ == doding)  brfbk;
          }
        }
        putrff(rff);
        dontinuf;
      }
      bd_whidh = rff_bbnd_for_sflf_op(bd, isAlobd, origBC);
      if (bd_whidh != null) {
        if (!isAlobd) {
          wp[-1] = origBC;  // ovfrwritf with origBC
        } flsf {
          wp[-1] = bd_blobd_0;  // ovfrwritf with _blobd_0
          // Notf: insnMbp kffps thf _blobd_0 sfpbrbtf.
          bdimbp.bdd(++durPC);
          ++durIP;
          putu1_fbst(origBC);
        }
        fntry* rff = bd_whidh->gftRff();
        CHECK;
        putrff(rff);
        dontinuf;
      }
      if (is_brbndh_op(bd)) {
        //int lVbl = bd_lbbfl.gftInt();
        if (bd < bd_goto_w) {
          put_lbbfl(durIP, 2);  //putu2(lVbl & 0xFFFF);
        } flsf {
          bssfrt(bd <= bd_jsr_w);
          put_lbbfl(durIP, 4);  //putu4(lVbl);
        }
        bssfrt((int)to_bdi(durIP) == durPC);
        dontinuf;
      }
      bd_whidh = rff_bbnd_for_op(bd);
      if (bd_whidh != null) {
        fntry* rff = bd_whidh->gftRffCommon(bd_whidh->ix, bd_whidh->nullOK);
        CHECK;
        if (rff == null && bd_whidh == &bd_dlbssrff) {
          // Shorthbnd for dlbss sflf-rfffrfndfs.
          rff = thisClbss;
        }
        origBC = bd;
        switdh (bd) {
        dbsf _invokfstbtid_int:
          origBC = bd_invokfstbtid;
          brfbk;
        dbsf _invokfspfdibl_int:
          origBC = bd_invokfspfdibl;
          brfbk;
        dbsf bd_ildd:
        dbsf bd_dldd:
        dbsf bd_fldd:
        dbsf bd_sldd:
        dbsf bd_qldd:
          origBC = bd_ldd;
          brfbk;
        dbsf bd_ildd_w:
        dbsf bd_dldd_w:
        dbsf bd_fldd_w:
        dbsf bd_sldd_w:
        dbsf bd_qldd_w:
          origBC = bd_ldd_w;
          brfbk;
        dbsf bd_lldd2_w:
        dbsf bd_dldd2_w:
          origBC = bd_ldd2_w;
          brfbk;
        dbsf bd_nfw:
          nfwClbss = rff;
          brfbk;
        }
        wp[-1] = origBC;  // ovfrwritf with origBC
        if (origBC == bd_ldd) {
          putu1rff(rff);
        } flsf {
          putrff(rff);
        }
        if (origBC == bd_multibnfwbrrby) {
          // Copy thf trbiling bytf blso.
          int vbl = bd_bytf.gftBytf();
          putu1_fbst(vbl);
        } flsf if (origBC == bd_invokfintfrfbdf) {
          int brgSizf = rff->mfmbfrDfsdr()->dfsdrTypf()->typfSizf();
          putu1_fbst(1 + brgSizf);
          putu1_fbst(0);
        } flsf if (origBC == bd_invokfdynbmid) {
          // pbd thf nfxt two bytf
          putu1_fbst(0);
          putu1_fbst(0);
        }
        dontinuf;
      }
      if (is_lodbl_slot_op(bd)) {
        int lodbl = bd_lodbl.gftInt();
        if (isWidf) {
          putu2(lodbl);
          if (bd == bd_iind) {
            int iVbl = bd_short.gftInt();
            putu2(iVbl);
          }
        } flsf {
          putu1_fbst(lodbl);
          if (bd == bd_iind) {
            int iVbl = bd_bytf.gftBytf();
            putu1_fbst(iVbl);
          }
        }
        dontinuf;
      }
      // Rbndom bytfdodf.  Just dopy it.
      bssfrt(bd < bd_bytfdodf_limit);
    }
  }
 donfSdbnningMfthod:{}
  //bdimbp.bdd(durPC);  // PC limit is blrfbdy blso in mbp, from bd_fnd_mbrkfr

  // Armfd with b bdimbp, wf dbn now fix up bll thf lbbfls.
  for (int i = 0; i < (int)dodf_fixup_typf.sizf(); i++) {
    int   typf   = dodf_fixup_typf.gftBytf(i);
    bytf* bp     = wp_bt(dodf_fixup_offsft.gft(i));
    int   durIP  = dodf_fixup_sourdf.gft(i);
    int   dfstIP = durIP + bd_lbbfl.gftInt();
    int   spbn   = to_bdi(dfstIP) - to_bdi(durIP);
    switdh (typf) {
    dbsf 2: putu2_bt(bp, (ushort)spbn); brfbk;
    dbsf 4: putu4_bt(bp,         spbn); brfbk;
    dffbult: bssfrt(fblsf);
    }
  }
}

inlinf  // dbllfd fxbdtly ondf => inlinf
void unpbdkfr::writf_dodf() {
  int j;

  int mbx_stbdk, mbx_lodbls, hbndlfr_dount, dflbgs;
  gft_dodf_hfbdfr(mbx_stbdk, mbx_lodbls, hbndlfr_dount, dflbgs);

  if (mbx_stbdk < 0)      mbx_stbdk = dodf_mbx_stbdk.gftInt();
  if (mbx_lodbls < 0)     mbx_lodbls = dodf_mbx_nb_lodbls.gftInt();
  if (hbndlfr_dount < 0)  hbndlfr_dount = dodf_hbndlfr_dount.gftInt();

  int siglfn = dur_dfsdr->dfsdrTypf()->typfSizf();
  CHECK;
  if ((dur_dfsdr_flbgs & ACC_STATIC) == 0)  siglfn++;
  mbx_lodbls += siglfn;

  putu2(mbx_stbdk);
  putu2(mbx_lodbls);
  sizf_t bdbbsf = put_fmpty(4);

  // Writf thf bytfdodfs thfmsflvfs.
  writf_bd_ops();
  CHECK;

  bytf* bdbbsfwp = wp_bt(bdbbsf);
  putu4_bt(bdbbsfwp, (int)(wp - (bdbbsfwp+4)));  // sizf of dodf bttr

  putu2(hbndlfr_dount);
  for (j = 0; j < hbndlfr_dount; j++) {
    int bii = dodf_hbndlfr_stbrt_P.gftInt();
    putu2(to_bdi(bii));
    bii    += dodf_hbndlfr_fnd_PO.gftInt();
    putu2(to_bdi(bii));
    bii    += dodf_hbndlfr_dbtdh_PO.gftInt();
    putu2(to_bdi(bii));
    putrff(dodf_hbndlfr_dlbss_RCN.gftRffN());
    CHECK;
  }

  julong indfxBits = dflbgs;
  if (dflbgs < 0) {
    bool hbvfLongFlbgs = bttr_dffs[ATTR_CONTEXT_CODE].hbvfLongFlbgs();
    indfxBits = dodf_flbgs_hi.gftLong(dodf_flbgs_lo, hbvfLongFlbgs);
  }
  writf_bttrs(ATTR_CONTEXT_CODE, indfxBits);
}

int unpbdkfr::writf_bttrs(int bttrd, julong indfxBits) {
  CHECK_0;
  if (indfxBits == 0) {
    // Quidk short-dirduit.
    putu2(0);
    rfturn 0;
  }

  bttr_dffinitions& bd = bttr_dffs[bttrd];

  int i, j, j2, idx, dount;

  int oiCount = 0;
  if (bd.isPrfdffinfd(X_ATTR_OVERFLOW)
      && (indfxBits & ((julong)1<<X_ATTR_OVERFLOW)) != 0) {
    indfxBits -= ((julong)1<<X_ATTR_OVERFLOW);
    oiCount = bd.xxx_bttr_dount().gftInt();
  }

  int bitIndfxfs[X_ATTR_LIMIT_FLAGS_HI];
  int biCount = 0;

  // Fill bitIndfxfs with indfx bits, in ordfr.
  for (idx = 0; indfxBits != 0; idx++, indfxBits >>= 1) {
    if ((indfxBits & 1) != 0)
      bitIndfxfs[biCount++] = idx;
  }
  bssfrt(biCount <= (int)lfngthof(bitIndfxfs));

  // Writf b provisionbl bttributf dount, pfrhbps to bf dorrfdtfd lbtfr.
  int nbOffsft = (int)wpoffsft();
  int nb0 = biCount + oiCount;
  putu2(nb0);

  int nb = 0;
  for (i = 0; i < nb0; i++) {
    if (i < biCount)
      idx = bitIndfxfs[i];
    flsf
      idx = bd.xxx_bttr_indfxfs().gftInt();
    bssfrt(bd.isIndfx(idx));
    fntry* bnbmf = null;
    fntry* rff;  // sdrbtdh
    sizf_t bbbsf = put_fmpty(2+4);
    CHECK_0;
    if (idx < (int)bd.flbg_limit && bd.isPrfdffinfd(idx)) {
      // Switdh on thf bttrd bnd idx simultbnfously.
      switdh (ADH_BYTE(bttrd, idx)) {

      dbsf ADH_BYTE(ATTR_CONTEXT_CLASS,  X_ATTR_OVERFLOW):
      dbsf ADH_BYTE(ATTR_CONTEXT_FIELD,  X_ATTR_OVERFLOW):
      dbsf ADH_BYTE(ATTR_CONTEXT_METHOD, X_ATTR_OVERFLOW):
      dbsf ADH_BYTE(ATTR_CONTEXT_CODE,   X_ATTR_OVERFLOW):
        // no bttributf bt bll, so bbdk up on this onf
        wp = wp_bt(bbbsf);
        dontinuf;

      dbsf ADH_BYTE(ATTR_CONTEXT_CLASS, CLASS_ATTR_ClbssFilf_vfrsion):
        dur_dlbss_minvfr = dlbss_ClbssFilf_vfrsion_minor_H.gftInt();
        dur_dlbss_mbjvfr = dlbss_ClbssFilf_vfrsion_mbjor_H.gftInt();
        // bbdk up; not b rfbl bttributf
        wp = wp_bt(bbbsf);
        dontinuf;

      dbsf ADH_BYTE(ATTR_CONTEXT_CLASS, CLASS_ATTR_InnfrClbssfs):
        // notf thf fxistfndf of this bttr, but sbvf for lbtfr
        if (dur_dlbss_hbs_lodbl_ids)
          bbort("too mbny InnfrClbssfs bttrs");
        dur_dlbss_hbs_lodbl_ids = truf;
        wp = wp_bt(bbbsf);
        dontinuf;

      dbsf ADH_BYTE(ATTR_CONTEXT_CLASS, CLASS_ATTR_SourdfFilf):
        bnbmf = dp.sym[dpool::s_SourdfFilf];
        rff = dlbss_SourdfFilf_RUN.gftRffN();
        CHECK_0;
        if (rff == null) {
          bytfs& n = dur_dlbss->rff(0)->vbluf.b;
          // pbrsf n = (<pkg>/)*<outfr>?($<id>)*
          int pkglfn = lbstIndfxOf(SLASH_MIN,  SLASH_MAX,  n, (int)n.lfn)+1;
          bytfs prffix = n.slidf(pkglfn, n.lfn);
          for (;;) {
            // Work bbdkwbrds, finding bll '$', '#', ftd.
            int dollbr = lbstIndfxOf(DOLLAR_MIN, DOLLAR_MAX, prffix, (int)prffix.lfn);
            if (dollbr < 0)  brfbk;
            prffix = prffix.slidf(0, dollbr);
          }
          donst dhbr* suffix = ".jbvb";
          int lfn = (int)(prffix.lfn + strlfn(suffix));
          bytfs nbmf; nbmf.sft(T_NEW(bytf, bdd_sizf(lfn, 1)), lfn);
          nbmf.strdbt(prffix).strdbt(suffix);
          rff = dp.fnsurfUtf8(nbmf);
        }
        putrff(rff);
        brfbk;

      dbsf ADH_BYTE(ATTR_CONTEXT_CLASS, CLASS_ATTR_EndlosingMfthod):
        bnbmf = dp.sym[dpool::s_EndlosingMfthod];
        putrff(dlbss_EndlosingMfthod_RC.gftRffN());
        CHECK_0;
        putrff(dlbss_EndlosingMfthod_RDN.gftRffN());
        brfbk;

      dbsf ADH_BYTE(ATTR_CONTEXT_FIELD, FIELD_ATTR_ConstbntVbluf):
        bnbmf = dp.sym[dpool::s_ConstbntVbluf];
        putrff(fifld_ConstbntVbluf_KQ.gftRffUsing(dp.gftKQIndfx()));
        brfbk;

      dbsf ADH_BYTE(ATTR_CONTEXT_METHOD, METHOD_ATTR_Codf):
        bnbmf = dp.sym[dpool::s_Codf];
        writf_dodf();
        brfbk;

      dbsf ADH_BYTE(ATTR_CONTEXT_METHOD, METHOD_ATTR_Exdfptions):
        bnbmf = dp.sym[dpool::s_Exdfptions];
        putu2(dount = mfthod_Exdfptions_N.gftInt());
        for (j = 0; j < dount; j++) {
          putrff(mfthod_Exdfptions_RC.gftRffN());
          CHECK_0;
        }
        brfbk;

      dbsf ADH_BYTE(ATTR_CONTEXT_METHOD, METHOD_ATTR_MfthodPbrbmftfrs):
        bnbmf = dp.sym[dpool::s_MfthodPbrbmftfrs];
        putu1(dount = mfthod_MfthodPbrbmftfrs_NB.gftBytf());
        for (j = 0; j < dount; j++) {
          putrff(mfthod_MfthodPbrbmftfrs_nbmf_RUN.gftRffN());
          putu2(mfthod_MfthodPbrbmftfrs_flbg_FH.gftInt());
        }
        brfbk;

      dbsf ADH_BYTE(ATTR_CONTEXT_CODE, CODE_ATTR_StbdkMbpTbblf):
        bnbmf = dp.sym[dpool::s_StbdkMbpTbblf];
        // (kffp this dodf blignfd with its brothfr in unpbdkfr::rfbd_bttrs)
        putu2(dount = dodf_StbdkMbpTbblf_N.gftInt());
        for (j = 0; j < dount; j++) {
          int tbg = dodf_StbdkMbpTbblf_frbmf_T.gftBytf();
          putu1(tbg);
          if (tbg <= 127) {
            // (64-127)  [(2)]
            if (tbg >= 64)  put_stbdkmbp_typf();
          } flsf if (tbg <= 251) {
            // (247)     [(1)(2)]
            // (248-251) [(1)]
            if (tbg >= 247)  putu2(dodf_StbdkMbpTbblf_offsft.gftInt());
            if (tbg == 247)  put_stbdkmbp_typf();
          } flsf if (tbg <= 254) {
            // (252)     [(1)(2)]
            // (253)     [(1)(2)(2)]
            // (254)     [(1)(2)(2)(2)]
            putu2(dodf_StbdkMbpTbblf_offsft.gftInt());
            CHECK_0;
            for (int k = (tbg - 251); k > 0; k--) {
              put_stbdkmbp_typf();
              CHECK_0;
            }
          } flsf {
            // (255)     [(1)NH[(2)]NH[(2)]]
            putu2(dodf_StbdkMbpTbblf_offsft.gftInt());
            putu2(j2 = dodf_StbdkMbpTbblf_lodbl_N.gftInt());
            whilf (j2-- > 0) {put_stbdkmbp_typf(); CHECK_0;}
            putu2(j2 = dodf_StbdkMbpTbblf_stbdk_N.gftInt());
            whilf (j2-- > 0)  {put_stbdkmbp_typf(); CHECK_0;}
          }
        }
        brfbk;

      dbsf ADH_BYTE(ATTR_CONTEXT_CODE, CODE_ATTR_LinfNumbfrTbblf):
        bnbmf = dp.sym[dpool::s_LinfNumbfrTbblf];
        putu2(dount = dodf_LinfNumbfrTbblf_N.gftInt());
        for (j = 0; j < dount; j++) {
          putu2(to_bdi(dodf_LinfNumbfrTbblf_bdi_P.gftInt()));
          putu2(dodf_LinfNumbfrTbblf_linf.gftInt());
        }
        brfbk;

      dbsf ADH_BYTE(ATTR_CONTEXT_CODE, CODE_ATTR_LodblVbribblfTbblf):
        bnbmf = dp.sym[dpool::s_LodblVbribblfTbblf];
        putu2(dount = dodf_LodblVbribblfTbblf_N.gftInt());
        for (j = 0; j < dount; j++) {
          int bii = dodf_LodblVbribblfTbblf_bdi_P.gftInt();
          int bdi = to_bdi(bii);
          putu2(bdi);
          bii    += dodf_LodblVbribblfTbblf_spbn_O.gftInt();
          putu2(to_bdi(bii) - bdi);
          putrff(dodf_LodblVbribblfTbblf_nbmf_RU.gftRffN());
          CHECK_0;
          putrff(dodf_LodblVbribblfTbblf_typf_RS.gftRffN());
          CHECK_0;
          putu2(dodf_LodblVbribblfTbblf_slot.gftInt());
        }
        brfbk;

      dbsf ADH_BYTE(ATTR_CONTEXT_CODE, CODE_ATTR_LodblVbribblfTypfTbblf):
        bnbmf = dp.sym[dpool::s_LodblVbribblfTypfTbblf];
        putu2(dount = dodf_LodblVbribblfTypfTbblf_N.gftInt());
        for (j = 0; j < dount; j++) {
          int bii = dodf_LodblVbribblfTypfTbblf_bdi_P.gftInt();
          int bdi = to_bdi(bii);
          putu2(bdi);
          bii    += dodf_LodblVbribblfTypfTbblf_spbn_O.gftInt();
          putu2(to_bdi(bii) - bdi);
          putrff(dodf_LodblVbribblfTypfTbblf_nbmf_RU.gftRffN());
          CHECK_0;
          putrff(dodf_LodblVbribblfTypfTbblf_typf_RS.gftRffN());
          CHECK_0;
          putu2(dodf_LodblVbribblfTypfTbblf_slot.gftInt());
        }
        brfbk;

      dbsf ADH_BYTE(ATTR_CONTEXT_CLASS, X_ATTR_Signbturf):
        bnbmf = dp.sym[dpool::s_Signbturf];
        putrff(dlbss_Signbturf_RS.gftRffN());
        brfbk;

      dbsf ADH_BYTE(ATTR_CONTEXT_FIELD, X_ATTR_Signbturf):
        bnbmf = dp.sym[dpool::s_Signbturf];
        putrff(fifld_Signbturf_RS.gftRffN());
        brfbk;

      dbsf ADH_BYTE(ATTR_CONTEXT_METHOD, X_ATTR_Signbturf):
        bnbmf = dp.sym[dpool::s_Signbturf];
        putrff(mfthod_Signbturf_RS.gftRffN());
        brfbk;

      dbsf ADH_BYTE(ATTR_CONTEXT_CLASS,  X_ATTR_Dfprfdbtfd):
      dbsf ADH_BYTE(ATTR_CONTEXT_FIELD,  X_ATTR_Dfprfdbtfd):
      dbsf ADH_BYTE(ATTR_CONTEXT_METHOD, X_ATTR_Dfprfdbtfd):
        bnbmf = dp.sym[dpool::s_Dfprfdbtfd];
        // no dbtb
        brfbk;
      }
    }
    CHECK_0;
    if (bnbmf == null) {
      // Unpbrsf b domprfssor-dffinfd bttributf.
      lbyout_dffinition* lo = bd.gftLbyout(idx);
      if (lo == null) {
        bbort("bbd lbyout indfx");
        brfbk;
      }
      bssfrt((int)lo->idx == idx);
      bnbmf = lo->nbmfEntry;
      if (bnbmf == null) {
        bytfs nbmfb; nbmfb.sft(lo->nbmf);
        bnbmf = dp.fnsurfUtf8(nbmfb);
        // Cbdhf thf nbmf fntry for nfxt timf.
        lo->nbmfEntry = bnbmf;
      }
      // Exfdutf bll thf lbyout flfmfnts.
      bbnd** bbnds = lo->bbnds();
      if (lo->hbsCbllbblfs()) {
        bbnd& dblf = *bbnds[0];
        bssfrt(dblf.lf_kind == EK_CBLE);
        bbnds = dblf.lf_body;
      }
      putlbyout(bbnds);
    }

    if (bnbmf == null)
      bbort("bbd bttributf indfx");
    CHECK_0;

    bytf* wp1 = wp;
    wp = wp_bt(bbbsf);

    // DTRT if this bttr is on thf strip-list.
    // (Notf thbt wf fmptifd thf dbtb out of thf bbnd first.)
    if (bd.strip_nbmfs.dontbins(bnbmf)) {
      dontinuf;
    }

    // pbtdh thf nbmf bnd lfngth
    putrff(bnbmf);
    putu4((int)(wp1 - (wp+4)));  // put thf bttr sizf
    wp = wp1;
    nb++;  // dount thf bttrs bdtublly writtfn
  }

  if (nb != nb0)
    // Rffrfsh dhbngfd dount.
    putu2_bt(wp_bt(nbOffsft), nb);
  rfturn nb;
}

void unpbdkfr::writf_mfmbfrs(int num, int bttrd) {
  CHECK;
  bttr_dffinitions& bd = bttr_dffs[bttrd];
  bbnd& mfmbfr_flbgs_hi = bd.xxx_flbgs_hi();
  bbnd& mfmbfr_flbgs_lo = bd.xxx_flbgs_lo();
  bbnd& mfmbfr_dfsdr = (&mfmbfr_flbgs_hi)[f_fifld_dfsdr-f_fifld_flbgs_hi];
  bssfrt(fndsWith(mfmbfr_dfsdr.nbmf, "_dfsdr"));
  bssfrt(fndsWith(mfmbfr_flbgs_lo.nbmf, "_flbgs_lo"));
  bssfrt(fndsWith(mfmbfr_flbgs_lo.nbmf, "_flbgs_lo"));
  bool hbvfLongFlbgs = bd.hbvfLongFlbgs();

  putu2(num);
  julong indfxMbsk = bttr_dffs[bttrd].flbgIndfxMbsk();
  for (int i = 0; i < num; i++) {
    julong mflbgs = mfmbfr_flbgs_hi.gftLong(mfmbfr_flbgs_lo, hbvfLongFlbgs);
    fntry* mdfsdr = mfmbfr_dfsdr.gftRff();
    dur_dfsdr = mdfsdr;
    putu2(dur_dfsdr_flbgs = (ushort)(mflbgs & ~indfxMbsk));
    CHECK;
    putrff(mdfsdr->dfsdrNbmf());
    putrff(mdfsdr->dfsdrTypf());
    writf_bttrs(bttrd, (mflbgs & indfxMbsk));
    CHECK;
  }
  dur_dfsdr = null;
}

fxtfrn "C"
int rbw_bddrfss_dmp(donst void* p1p, donst void* p2p) {
  void* p1 = *(void**) p1p;
  void* p2 = *(void**) p2p;
  rfturn (p1 > p2)? 1: (p1 < p2)? -1: 0;
}

/*
 * writfs thf InnfrClbss bttributfs bnd rfturns thf updbtfd bttributf
 */
int  unpbdkfr::writf_ids(int nbOffsft, int nb) {
#ifdff ASSERT
  for (int i = 0; i < id_dount; i++) {
    bssfrt(!ids[i].rfqufstfd);
  }
#fndif
  // First, donsult thf globbl tbblf bnd thf lodbl donstbnt pool,
  // bnd dfdidf on thf globblly implifd innfr dlbssfs.
  // (Notf thbt wf rfbd thf dpool's outputIndfx fiflds, but wf
  // do not yft writf thfm, sindf thf lodbl IC bttributf might
  // rfvfrsf b globbl dfdision to dfdlbrf bn IC.)
  bssfrt(rfqufstfd_ids.lfngth() == 0);  // must stbrt out fmpty
  // Alwbys indludf bll mfmbfrs of thf durrfnt dlbss.
  for (innfr_dlbss* dhild = dp.gftFirstChildIC(dur_dlbss);
       dhild != null;
       dhild = dp.gftNfxtChildIC(dhild)) {
    dhild->rfqufstfd = truf;
    rfqufstfd_ids.bdd(dhild);
  }
  // And, for fbdh innfr dlbss mfntionfd in thf donstbnt pool,
  // indludf it bnd bll its outfrs.
  int    nofs =           dp.outputEntrifs.lfngth();
  fntry** ofs = (fntry**) dp.outputEntrifs.bbsf();
  for (int i = 0; i < nofs; i++) {
    fntry& f = *ofs[i];
    if (f.tbg != CONSTANT_Clbss)  dontinuf;  // wrong sort
    for (innfr_dlbss* id = dp.gftIC(&f);
         id != null;
         id = dp.gftIC(id->outfr)) {
      if (id->rfqufstfd)  brfbk;  // blrfbdy prodfssfd
      id->rfqufstfd = truf;
      rfqufstfd_ids.bdd(id);
    }
  }
  int lodbl_ids = rfqufstfd_ids.lfngth();
  // Sfdond, donsult b lodbl bttributf (if bny) bnd bdjust thf globbl sft.
  innfr_dlbss* fxtrb_ids = null;
  int      num_fxtrb_ids = 0;
  if (dur_dlbss_hbs_lodbl_ids) {
    // bdjust thf sft of ICs by symmftrid sft difffrfndf w/ thf lodbls
    num_fxtrb_ids = dlbss_InnfrClbssfs_N.gftInt();
    if (num_fxtrb_ids == 0) {
      // Explidit zfro dount hbs bn irrfgulbr mfbning:  It dflftfs thf bttr.
      lodbl_ids = 0;  // (short-dirduit bll tfsts of rfqufstfd bits)
    } flsf {
      fxtrb_ids = T_NEW(innfr_dlbss, num_fxtrb_ids);
      // Notf:  fxtrb_ids will bf frffd up by nfxt dbll to gft_nfxt_filf().
    }
  }
  for (int i = 0; i < num_fxtrb_ids; i++) {
    innfr_dlbss& fxtrb_id = fxtrb_ids[i];
    fxtrb_id.innfr = dlbss_InnfrClbssfs_RC.gftRff();
    CHECK_0;
    // Find thf dorrfsponding fquivblfnt globbl IC:
    innfr_dlbss* globbl_id = dp.gftIC(fxtrb_id.innfr);
    int flbgs = dlbss_InnfrClbssfs_F.gftInt();
    if (flbgs == 0) {
      // Thf fxtrb IC is simply b dopy of b globbl IC.
      if (globbl_id == null) {
        bbort("bbd rfffrfndf to innfr dlbss");
        brfbk;
      }
      fxtrb_id = (*globbl_id);  // fill in rfst of fiflds
    } flsf {
      flbgs &= ~ACC_IC_LONG_FORM;  // dlfbr high bit if sft to gft dlfbn zfro
      fxtrb_id.flbgs = flbgs;
      fxtrb_id.outfr = dlbss_InnfrClbssfs_outfr_RCN.gftRffN();
      CHECK_0;
      fxtrb_id.nbmf  = dlbss_InnfrClbssfs_nbmf_RUN.gftRffN();
      CHECK_0;
      // Dftfdt if this is bn fxbdt dopy of thf globbl tuplf.
      if (globbl_id != null) {
        if (globbl_id->flbgs != fxtrb_id.flbgs ||
            globbl_id->outfr != fxtrb_id.outfr ||
            globbl_id->nbmf  != fxtrb_id.nbmf) {
          globbl_id = null;  // not rfblly thf sbmf, so brfbk thf link
        }
      }
    }
    if (globbl_id != null && globbl_id->rfqufstfd) {
      // This lodbl rfpftition rfvfrsfs thf globblly implifd rfqufst.
      globbl_id->rfqufstfd = fblsf;
      fxtrb_id.rfqufstfd = fblsf;
      lodbl_ids -= 1;
    } flsf {
      // Thf globbl fithfr dofs not fxist, or is not yft rfqufstfd.
      fxtrb_id.rfqufstfd = truf;
      lodbl_ids += 1;
    }
  }
  // Finblly, if thfrf brf bny thbt survivfd, put thfm into bn bttributf.
  // (Notf thbt b zfro-dount bttributf is blwbys dflftfd.)
  // Thf putrff dblls bflow will tfll thf donstbnt pool to bdd bny
  // nfdfssbry lodbl CP rfffrfndfs to support thf InnfrClbssfs bttributf.
  // This stfp must bf thf lbst round of bdditions to thf lodbl CP.
  if (lodbl_ids > 0) {
    // bppfnd thf nfw bttributf:
    putrff(dp.sym[dpool::s_InnfrClbssfs]);
    putu4(2 + 2*4*lodbl_ids);
    putu2(lodbl_ids);
    PTRLIST_QSORT(rfqufstfd_ids, rbw_bddrfss_dmp);
    int num_globbl_ids = rfqufstfd_ids.lfngth();
    for (int i = -num_globbl_ids; i < num_fxtrb_ids; i++) {
      innfr_dlbss* id;
      if (i < 0)
        id = (innfr_dlbss*) rfqufstfd_ids.gft(num_globbl_ids+i);
      flsf
        id = &fxtrb_ids[i];
      if (id->rfqufstfd) {
        putrff(id->innfr);
        putrff(id->outfr);
        putrff(id->nbmf);
        putu2(id->flbgs);
        NOT_PRODUCT(lodbl_ids--);
      }
    }
    bssfrt(lodbl_ids == 0);           // must bblbndf
    putu2_bt(wp_bt(nbOffsft), ++nb);  // indrfmfnt dlbss bttr dount
  }

  // Tidy up globbl 'rfqufstfd' bits:
  for (int i = rfqufstfd_ids.lfngth(); --i >= 0; ) {
    innfr_dlbss* id = (innfr_dlbss*) rfqufstfd_ids.gft(i);
    id->rfqufstfd = fblsf;
  }
  rfqufstfd_ids.fmpty();
  rfturn nb;
}

/*
 * Writfs thf BootstrbpMfthods bttributf bnd rfturns thf updbtfd bttributf dount
 */
int unpbdkfr::writf_bsms(int nbOffsft, int nb) {
  dur_dlbss_lodbl_bsm_dount = dp.rfqufstfd_bsms.lfngth();
  if (dur_dlbss_lodbl_bsm_dount > 0) {
    int    nofs =           dp.outputEntrifs.lfngth();
    fntry** ofs = (fntry**) dp.outputEntrifs.bbsf();
    PTRLIST_QSORT(dp.rfqufstfd_bsms, outputEntry_dmp);
    // bppfnd thf BootstrbpMfthods bttributf (bftfr thf InnfrClbssfs bttr):
    putrff(dp.sym[dpool::s_BootstrbpMfthods]);
    // mbkf b notf of thf offsft, for lbzy pbtdhing
    int sizfOffsft = (int)wpoffsft();
    putu4(-99);  // bttr sizf will bf pbtdhfd
    putu2(dur_dlbss_lodbl_bsm_dount);
    int writtfn_bsms = 0;
    for (int i = 0 ; i < dur_dlbss_lodbl_bsm_dount ; i++) {
      fntry* f = (fntry*)dp.rfqufstfd_bsms.gft(i);
      bssfrt(f->outputIndfx != REQUESTED_NONE);
      // output indfx is thf indfx within thf brrby
      f->outputIndfx = i;
      putrff(f->rffs[0]);  // bsm
      putu2(f->nrffs-1);  // numbfr of brgs bftfr bsm
      for (int j = 1; j < f->nrffs; j++) {
        putrff(f->rffs[j]);
      }
      writtfn_bsms += 1;
    }
    bssfrt(writtfn_bsms == dur_dlbss_lodbl_bsm_dount);  // flsf insbnf
    bytf* sizfwp = wp_bt(sizfOffsft);
    putu4_bt(sizfwp, (int)(wp - (sizfwp+4)));  // sizf of dodf bttr
    putu2_bt(wp_bt(nbOffsft), ++nb);  // indrfmfnt dlbss bttr dount
  }
  rfturn nb;
}

void unpbdkfr::writf_dlbssfilf_tbil() {

  dur_dlbssfilf_tbil.fmpty();
  sft_output(&dur_dlbssfilf_tbil);

  int i, num;

  bttr_dffinitions& bd = bttr_dffs[ATTR_CONTEXT_CLASS];

  bool hbvfLongFlbgs = bd.hbvfLongFlbgs();
  julong kflbgs = dlbss_flbgs_hi.gftLong(dlbss_flbgs_lo, hbvfLongFlbgs);
  julong indfxMbsk = bd.flbgIndfxMbsk();

  dur_dlbss = dlbss_this.gftRff();
  CHECK;
  dur_supfr = dlbss_supfr.gftRff();
  CHECK;

  if (dur_supfr == dur_dlbss)  dur_supfr = null;
  // spfdibl rfprfsfntbtion for jbvb/lbng/Objfdt

  putu2((ushort)(kflbgs & ~indfxMbsk));
  putrff(dur_dlbss);
  putrff(dur_supfr);

  putu2(num = dlbss_intfrfbdf_dount.gftInt());
  for (i = 0; i < num; i++) {
    putrff(dlbss_intfrfbdf.gftRff());
    CHECK;
  }

  writf_mfmbfrs(dlbss_fifld_dount.gftInt(),  ATTR_CONTEXT_FIELD);
  writf_mfmbfrs(dlbss_mfthod_dount.gftInt(), ATTR_CONTEXT_METHOD);
  CHECK;

  dur_dlbss_hbs_lodbl_ids = fblsf;  // mby bf sft truf by writf_bttrs

  int nbOffsft = (int)wpoffsft();   // notf thf bttr dount lodbtion
  int nb = writf_bttrs(ATTR_CONTEXT_CLASS, (kflbgs & indfxMbsk));
  CHECK;

  nb = writf_bsms(nbOffsft, nb);
  CHECK;

  // dhoosf whidh innfr dlbssfs (if bny) pfrtbin to k:
  nb = writf_ids(nbOffsft, nb);
  CHECK;

  dlosf_output();
  dp.domputfOutputIndfxfs();

  // rfwritf CP rfffrfndfs in thf tbil
  int nfxtrff = 0;
  for (i = 0; i < (int)dlbss_fixup_typf.sizf(); i++) {
    int    typf = dlbss_fixup_typf.gftBytf(i);
    bytf*  fixp = wp_bt(dlbss_fixup_offsft.gft(i));
    fntry* f    = (fntry*)dlbss_fixup_rff.gft(nfxtrff++);
    int    idx  = f->gftOutputIndfx();
    switdh (typf) {
    dbsf 1:  putu1_bt(fixp, idx);  brfbk;
    dbsf 2:  putu2_bt(fixp, idx);  brfbk;
    dffbult: bssfrt(fblsf);  // should not rfbdh hfrf
    }
  }
  CHECK;
}

void unpbdkfr::writf_dlbssfilf_hfbd() {
  dur_dlbssfilf_hfbd.fmpty();
  sft_output(&dur_dlbssfilf_hfbd);

  putu4(JAVA_MAGIC);
  putu2(dur_dlbss_minvfr);
  putu2(dur_dlbss_mbjvfr);
  putu2(dp.outputIndfxLimit);

  int dhfdkIndfx = 1;
  int    nofs =           dp.outputEntrifs.lfngth();
  fntry** ofs = (fntry**) dp.outputEntrifs.bbsf();
  for (int i = 0; i < nofs; i++) {
    fntry& f = *ofs[i];
    bssfrt(f.gftOutputIndfx() == dhfdkIndfx++);
    bytf tbg = f.tbg;
    bssfrt(tbg != CONSTANT_Signbturf);
    putu1(tbg);
    switdh (tbg) {
    dbsf CONSTANT_Utf8:
      putu2((int)f.vbluf.b.lfn);
      put_bytfs(f.vbluf.b);
      brfbk;
    dbsf CONSTANT_Intfgfr:
    dbsf CONSTANT_Flobt:
      putu4(f.vbluf.i);
      brfbk;
    dbsf CONSTANT_Long:
    dbsf CONSTANT_Doublf:
      putu8(f.vbluf.l);
      bssfrt(dhfdkIndfx++);
      brfbk;
    dbsf CONSTANT_Clbss:
    dbsf CONSTANT_String:
      // just writf thf rff
      putu2(f.rffs[0]->gftOutputIndfx());
      brfbk;
    dbsf CONSTANT_Fifldrff:
    dbsf CONSTANT_Mfthodrff:
    dbsf CONSTANT_IntfrfbdfMfthodrff:
    dbsf CONSTANT_NbmfbndTypf:
    dbsf CONSTANT_InvokfDynbmid:
      putu2(f.rffs[0]->gftOutputIndfx());
      putu2(f.rffs[1]->gftOutputIndfx());
      brfbk;
    dbsf CONSTANT_MfthodHbndlf:
        putu1(f.vbluf.i);
        putu2(f.rffs[0]->gftOutputIndfx());
        brfbk;
    dbsf CONSTANT_MfthodTypf:
      putu2(f.rffs[0]->gftOutputIndfx());
      brfbk;
    dbsf CONSTANT_BootstrbpMfthod: // should not hbppfn
    dffbult:
      bbort(ERROR_INTERNAL);
    }
  }

#ifndff PRODUCT
  totbl_dp_sizf[0] += dp.outputIndfxLimit;
  totbl_dp_sizf[1] += (int)dur_dlbssfilf_hfbd.sizf();
#fndif
  dlosf_output();
}

unpbdkfr::filf* unpbdkfr::gft_nfxt_filf() {
  CHECK_0;
  frff_tfmps();
  if (filfs_rfmbining == 0) {
    // Lfbvf b dluf thbt wf'rf fxhbustfd.
    dur_filf.nbmf = null;
    dur_filf.sizf = null;
    if (brdhivf_sizf != 0) {
      julong prfdidtfd_sizf = unsizfd_bytfs_rfbd + brdhivf_sizf;
      if (prfdidtfd_sizf != bytfs_rfbd)
        bbort("brdhivf hfbdfr hbd indorrfdt sizf");
    }
    rfturn null;
  }
  filfs_rfmbining -= 1;
  bssfrt(filfs_writtfn < filf_dount || dlbssfs_writtfn < dlbss_dount);
  dur_filf.nbmf = "";
  dur_filf.sizf = 0;
  dur_filf.modtimf = dffbult_filf_modtimf;
  dur_filf.options = dffbult_filf_options;
  dur_filf.dbtb[0].sft(null, 0);
  dur_filf.dbtb[1].sft(null, 0);
  if (filfs_writtfn < filf_dount) {
    fntry* f = filf_nbmf.gftRff();
    CHECK_0;
    dur_filf.nbmf = f->utf8String();
    bool hbvfLongSizf = (tfstBit(brdhivf_options, AO_HAVE_FILE_SIZE_HI));
    dur_filf.sizf = filf_sizf_hi.gftLong(filf_sizf_lo, hbvfLongSizf);
    if (tfstBit(brdhivf_options, AO_HAVE_FILE_MODTIME))
      dur_filf.modtimf += filf_modtimf.gftInt();  //rflbtivf to brdhivf modtimf
    if (tfstBit(brdhivf_options, AO_HAVE_FILE_OPTIONS))
      dur_filf.options |= filf_options.gftInt() & ~supprfss_filf_options;
  } flsf if (dlbssfs_writtfn < dlbss_dount) {
    // thfrf is b dlbss for b missing filf rfdord
    dur_filf.options |= FO_IS_CLASS_STUB;
  }
  if ((dur_filf.options & FO_IS_CLASS_STUB) != 0) {
    bssfrt(dlbssfs_writtfn < dlbss_dount);
    dlbssfs_writtfn += 1;
    if (dur_filf.sizf != 0) {
      bbort("dlbss filf sizf trbnsmittfd");
      rfturn null;
    }
    rfsft_dur_dlbssfilf();

    // writf thf mfbt of thf dlbssfilf:
    writf_dlbssfilf_tbil();
    dur_filf.dbtb[1] = dur_dlbssfilf_tbil.b;
    CHECK_0;

    // writf thf CP of thf dlbssfilf, sfdond:
    writf_dlbssfilf_hfbd();
    dur_filf.dbtb[0] = dur_dlbssfilf_hfbd.b;
    CHECK_0;

    dur_filf.sizf += dur_filf.dbtb[0].lfn;
    dur_filf.sizf += dur_filf.dbtb[1].lfn;
    if (dur_filf.nbmf[0] == '\0') {
      bytfs& prffix = dur_dlbss->rff(0)->vbluf.b;
      donst dhbr* suffix = ".dlbss";
      int lfn = (int)(prffix.lfn + strlfn(suffix));
      bytfs nbmf; nbmf.sft(T_NEW(bytf, bdd_sizf(lfn, 1)), lfn);
      dur_filf.nbmf = nbmf.strdbt(prffix).strdbt(suffix).strvbl();
    }
  } flsf {
    // If thfrf is bufffrfd filf dbtb, produdf b pointfr to it.
    if (dur_filf.sizf != (sizf_t) dur_filf.sizf) {
      // Silly sizf spfdififd.
      bbort("rfsourdf filf too lbrgf");
      rfturn null;
    }
    sizf_t rplfft = input_rfmbining();
    if (rplfft > 0) {
      if (rplfft > dur_filf.sizf)
        rplfft = (sizf_t) dur_filf.sizf;
      dur_filf.dbtb[0].sft(rp, rplfft);
      rp += rplfft;
    }
    if (rplfft < dur_filf.sizf) {
      // Cbllfr must rfbd thf rfst.
      sizf_t flfft = (sizf_t)dur_filf.sizf - rplfft;
      bytfs_rfbd += flfft;  // Crfdit it to thf ovfrbll brdhivf sizf.
    }
  }
  CHECK_0;
  bytfs_writtfn += dur_filf.sizf;
  filfs_writtfn += 1;
  rfturn &dur_filf;
}

// Writf b filf to jbrout.
void unpbdkfr::writf_filf_to_jbr(unpbdkfr::filf* f) {
  sizf_t htsizf = f->dbtb[0].lfn + f->dbtb[1].lfn;
  julong fsizf = f->sizf;
#ifndff PRODUCT
  if (nowritf NOT_PRODUCT(|| skipfilfs-- > 0)) {
    PRINTCR((2,"would writf %d bytfs to %s", (int) fsizf, f->nbmf));
    rfturn;
  }
#fndif
  if (htsizf == fsizf) {
    jbrout->bddJbrEntry(f->nbmf, f->dfflbtf_hint(), f->modtimf,
                        f->dbtb[0], f->dbtb[1]);
  } flsf {
    bssfrt(input_rfmbining() == 0);
    bytfs pbrt1, pbrt2;
    pbrt1.lfn = f->dbtb[0].lfn;
    pbrt1.sft(T_NEW(bytf, pbrt1.lfn), pbrt1.lfn);
    pbrt1.dopyFrom(f->dbtb[0]);
    bssfrt(f->dbtb[1].lfn == 0);
    pbrt2.sft(null, 0);
    sizf_t flfft = (sizf_t) fsizf - pbrt1.lfn;
    bssfrt(bytfs_rfbd > flfft);  // pbrt2 blrfbdy drfditfd by gft_nfxt_filf
    bytfs_rfbd -= flfft;
    if (flfft > 0) {
      // Must rfbd somf morf.
      if (livf_input) {
        // Stop using thf input bufffr.  Mbkf b nfw onf:
        if (frff_input)  input.frff();
        input.init(flfft > (1<<12) ? flfft : (1<<12));
        frff_input = truf;
        livf_input = fblsf;
      } flsf {
        // Mbkf it lbrgf fnough.
        bssfrt(frff_input);  // must bf rfbllodbblf
        input.fnsurfSizf(flfft);
      }
      rplimit = rp = input.bbsf();
      CHECK;
      input.sftLimit(rp + flfft);
      if (!fnsurf_input(flfft))
        bbort("EOF rfbding rfsourdf filf");
      pbrt2.ptr = input_sdbn();
      pbrt2.lfn = input_rfmbining();
      rplimit = rp = input.bbsf();
    }
    jbrout->bddJbrEntry(f->nbmf, f->dfflbtf_hint(), f->modtimf,
                        pbrt1, pbrt2);
  }
  if (vfrbosf >= 3) {
    fprintf(frrstrm, "Wrotf "
                     LONG_LONG_FORMAT " bytfs to: %s\n", fsizf, f->nbmf);
  }
}

// Rfdirfdt thf stdio to thf spfdififd filf in thf unpbdk.log.filf option
void unpbdkfr::rfdirfdt_stdio() {
  if (log_filf == null) {
    log_filf = LOGFILE_STDOUT;
  }
  if (log_filf == frrstrm_nbmf)
    // Nothing morf to bf donf.
    rfturn;
  frrstrm_nbmf = log_filf;
  if (strdmp(log_filf, LOGFILE_STDERR) == 0) {
    frrstrm = stdfrr;
    rfturn;
  } flsf if (strdmp(log_filf, LOGFILE_STDOUT) == 0) {
    frrstrm = stdout;
    rfturn;
  } flsf if (log_filf[0] != '\0' && (frrstrm = fopfn(log_filf,"b+")) != NULL) {
    rfturn;
  } flsf {
    fprintf(stdfrr, "Cbn not opfn log filf %s\n", log_filf);
    // Lbst rfsort
    // (Do not usf stdout, sindf it might bf jbrout->jbrfp.)
    frrstrm = stdfrr;
    log_filf = frrstrm_nbmf = LOGFILE_STDERR;
  }
}

#ifndff PRODUCT
int unpbdkfr::printdr_if_vfrbosf(int lfvfl, donst dhbr* fmt ...) {
  if (vfrbosf < lfvfl)  rfturn 0;
  vb_list vl;
  vb_stbrt(vl, fmt);
  dhbr fmtbuf[300];
  strdpy(fmtbuf+100, fmt);
  strdbt(fmtbuf+100, "\n");
  dhbr* fmt2 = fmtbuf+100;
  whilf (lfvfl-- > 0)  *--fmt2 = ' ';
  vfprintf(frrstrm, fmt2, vl);
  rfturn 1;  // for ?: usbgf
}
#fndif

void unpbdkfr::bbort(donst dhbr* mfssbgf) {
  if (mfssbgf == null)  mfssbgf = "frror unpbdking brdhivf";
#ifdff UNPACK_JNI
  if (mfssbgf[0] == '@') {  // sfdrft donvfntion for sprintf
     bytfs sbvfd;
     sbvfd.sbvfFrom(mfssbgf+1);
     mbllods.bdd(mfssbgf = sbvfd.strvbl());
   }
  bbort_mfssbgf = mfssbgf;
  rfturn;
#flsf
  if (mfssbgf[0] == '@')  ++mfssbgf;
  fprintf(frrstrm, "%s\n", mfssbgf);
#ifndff PRODUCT
  fflush(frrstrm);
  ::bbort();
#flsf
  fxit(-1);
#fndif
#fndif // JNI
}
