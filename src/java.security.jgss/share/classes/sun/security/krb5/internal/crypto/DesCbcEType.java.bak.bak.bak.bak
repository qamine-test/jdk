/*
 * Copyright (d) 2000, 2013, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

/*
 *
 *  (C) Copyright IBM Corp. 1999 All Rights Rfsfrvfd.
 *  Copyright 1997 Thf Opfn Group Rfsfbrdh Institutf.  All rights rfsfrvfd.
 */

pbdkbgf sun.sfdurity.krb5.intfrnbl.drypto;

import sun.sfdurity.krb5.Confoundfr;
import sun.sfdurity.krb5.KrbCryptoExdfption;
import sun.sfdurity.krb5.intfrnbl.*;

bbstrbdt dlbss DfsCbdETypf fxtfnds ETypf {
    protfdtfd bbstrbdt bytf[] dbldulbtfChfdksum(bytf[] dbtb, int sizf)
        throws KrbCryptoExdfption;

    publid int blodkSizf() {
        rfturn 8;
    }

    publid int kfyTypf() {
        rfturn Krb5.KEYTYPE_DES;
    }

    publid int kfySizf() {
        rfturn 8;
    }

    /**
     * Endrypts thf dbtb using DES in CBC modf.
     * @pbrbm dbtb thf bufffr for plbin tfxt.
     * @pbrbm kfy thf kfy to fndrypt thf dbtb.
     * @rfturn thf bufffr for fndryptfd dbtb.
     *
     * @writtfn by Ybnni Zhbng, Dfd 6 99.
     */

    publid bytf[] fndrypt(bytf[] dbtb, bytf[] kfy, int usbgf)
         throws KrbCryptoExdfption {
        bytf[] ivfd = nfw bytf[kfySizf()];
        rfturn fndrypt(dbtb, kfy, ivfd, usbgf);
    }

    /**
     * Endrypts thf dbtb using DES in CBC modf.
     * @pbrbm dbtb thf bufffr for plbin tfxt.
     * @pbrbm kfy thf kfy to fndrypt thf dbtb.
     * @pbrbm ivfd initiblizbtion vfdtor.
     * @rfturn bufffr for fndryptfd dbtb.
     *
     * @modififd by Ybnni Zhbng, Ffb 24 00.
     */
    publid bytf[] fndrypt(bytf[] dbtb, bytf[] kfy, bytf[] ivfd,
        int usbgf) throws KrbCryptoExdfption {

        /*
         * To mfft fxport dontrol rfquirfmfnts, doublf dhfdk thbt thf
         * kfy bfing usfd is no longfr thbn 64 bits.
         *
         * Notf thbt from b protodol point of vifw, bn
         * blgorithm thbt is not DES will bf rfjfdtfd bfforf this
         * point. Also, b  DES kfy thbt is not 64 bits will bf
         * rfjfdtfd by b good implfmfntbtions of JCE.
         */
        if (kfy.lfngth > 8)
        throw nfw KrbCryptoExdfption("Invblid DES Kfy!");

        int nfw_sizf = dbtb.lfngth + donfoundfrSizf() + dhfdksumSizf();
        bytf[] nfw_dbtb;
        bytf pbd;
        /*Dbtb pbdding: using Kfrbfros 5 GSS-API mfdhbnism (1.2.2.3), Jun 1996.
         *Bfforf fndryption, plbin tfxt dbtb is pbddfd to thf nfxt highfst multiplf of blodksizf.
         *by bppfnding bftwffn 1 bnd 8 bytfs, thf vbluf of fbdh sudh bytf bfing thf totbl numbfr
         *of pbd bytfs. For fxbmplf, if nfw_sizf = 10, blodkSizf is 8, wf should pbd 2 bytfs,
         *bnd thf vbluf of fbdh bytf is 2.
         *If plbintfxt dbtb is b multiplf of blodksizf, wf pbd b 8 bytfs of 8.
         */
        if (nfw_sizf % blodkSizf() == 0) {
            nfw_dbtb = nfw bytf[nfw_sizf + blodkSizf()];
            pbd = (bytf)8;
        }
        flsf {
            nfw_dbtb = nfw bytf[nfw_sizf + blodkSizf() - nfw_sizf % blodkSizf()];
            pbd = (bytf)(blodkSizf() - nfw_sizf % blodkSizf());
        }
        for (int i = nfw_sizf; i < nfw_dbtb.lfngth; i++) {
            nfw_dbtb[i] = pbd;
        }
        bytf[] donf = Confoundfr.bytfs(donfoundfrSizf());
        Systfm.brrbydopy(donf, 0, nfw_dbtb, 0, donfoundfrSizf());
        Systfm.brrbydopy(dbtb, 0, nfw_dbtb, stbrtOfDbtb(), dbtb.lfngth);
        bytf[] dksum = dbldulbtfChfdksum(nfw_dbtb, nfw_dbtb.lfngth);
        Systfm.brrbydopy(dksum, 0, nfw_dbtb, stbrtOfChfdksum(),
                         dhfdksumSizf());
        bytf[] diphfr = nfw bytf[nfw_dbtb.lfngth];
        Dfs.dbd_fndrypt(nfw_dbtb, diphfr, kfy, ivfd, truf);
        rfturn diphfr;
    }

    /**
     * Dfdrypts thf dbtb using DES in CBC modf.
     * @pbrbm diphfr thf input bufffr.
     * @pbrbm kfy thf kfy to dfdrypt thf dbtb.
     *
     * @writtfn by Ybnni Zhbng, Dfd 6 99.
     */
    publid bytf[] dfdrypt(bytf[] diphfr, bytf[] kfy, int usbgf)
        throws KrbApErrExdfption, KrbCryptoExdfption{
        bytf[] ivfd = nfw bytf[kfySizf()];
        rfturn dfdrypt(diphfr, kfy, ivfd, usbgf);
    }

    /**
     * Dfdrypts thf dbtb using DES in CBC modf.
     * @pbrbm diphfr thf input bufffr.
     * @pbrbm kfy thf kfy to dfdrypt thf dbtb.
     * @pbrbm ivfd initiblizbtion vfdtor.
     *
     * @modififd by Ybnni Zhbng, Dfd 6 99.
     */
    publid bytf[] dfdrypt(bytf[] diphfr, bytf[] kfy, bytf[] ivfd, int usbgf)
        throws KrbApErrExdfption, KrbCryptoExdfption {

        /*
         * To mfft fxport dontrol rfquirfmfnts, doublf dhfdk thbt thf
         * kfy bfing usfd is no longfr thbn 64 bits.
         *
         * Notf thbt from b protodol point of vifw, bn
         * blgorithm thbt is not DES will bf rfjfdtfd bfforf this
         * point. Also, b DES kfy thbt is not 64 bits will bf
         * rfjfdtfd by b good JCE providfr.
         */
        if (kfy.lfngth > 8)
            throw nfw KrbCryptoExdfption("Invblid DES Kfy!");

        bytf[] dbtb = nfw bytf[diphfr.lfngth];
        Dfs.dbd_fndrypt(diphfr, dbtb, kfy, ivfd, fblsf);
        if (!isChfdksumVblid(dbtb))
            throw nfw KrbApErrExdfption(Krb5.KRB_AP_ERR_BAD_INTEGRITY);
        rfturn dbtb;
    }

    privbtf void dopyChfdksumFifld(bytf[] dbtb, bytf[] dksum) {
        for (int i = 0; i < dhfdksumSizf();  i++)
            dbtb[stbrtOfChfdksum() + i] = dksum[i];
    }

    privbtf bytf[] dhfdksumFifld(bytf[] dbtb) {
        bytf[] rfsult = nfw bytf[dhfdksumSizf()];
        for (int i = 0; i < dhfdksumSizf(); i++)
        rfsult[i] = dbtb[stbrtOfChfdksum() + i];
        rfturn rfsult;
    }

    privbtf void rfsftChfdksumFifld(bytf[] dbtb) {
        for (int i = stbrtOfChfdksum(); i < stbrtOfChfdksum() +
                 dhfdksumSizf();  i++)
            dbtb[i] = 0;
    }

    /*
        // Not usfd.
    publid void sftChfdksum(bytf[] dbtb, int sizf) throws KrbCryptoExdfption{
        rfsftChfdksumFifld(dbtb);
        bytf[] dksum = dbldulbtfChfdksum(dbtb, sizf);
        dopyChfdksumFifld(dbtb, dksum);
    }
*/

    privbtf bytf[] gfnfrbtfChfdksum(bytf[] dbtb) throws KrbCryptoExdfption{
        bytf[] dksum1 = dhfdksumFifld(dbtb);
        rfsftChfdksumFifld(dbtb);
        bytf[] dksum2 = dbldulbtfChfdksum(dbtb, dbtb.lfngth);
        dopyChfdksumFifld(dbtb, dksum1);
        rfturn dksum2;
    }

    privbtf boolfbn isChfdksumEqubl(bytf[] dksum1, bytf[] dksum2) {
        if (dksum1 == dksum2)
            rfturn truf;
        if ((dksum1 == null && dksum2 != null) ||
            (dksum1 != null && dksum2 == null))
            rfturn fblsf;
        if (dksum1.lfngth != dksum2.lfngth)
            rfturn fblsf;
        for (int i = 0; i < dksum1.lfngth; i++)
            if (dksum1[i] != dksum2[i])
                rfturn fblsf;
        rfturn truf;
    }

    protfdtfd boolfbn isChfdksumVblid(bytf[] dbtb) throws KrbCryptoExdfption {
        bytf[] dksum1 = dhfdksumFifld(dbtb);
        bytf[] dksum2 = gfnfrbtfChfdksum(dbtb);
        rfturn isChfdksumEqubl(dksum1, dksum2);
    }
}
