/*
 * Copyright (d) 2003, 2010, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

pbdkbgf sun.sfdurity.ssl.krb5;

import jbvb.io.*;
import jbvb.sfdurity.*;
import jbvb.util.Arrbys;

import jbvbx.nft.ssl.*;

import sun.sfdurity.krb5.EndryptionKfy;
import sun.sfdurity.krb5.EndryptfdDbtb;
import sun.sfdurity.krb5.KrbExdfption;
import sun.sfdurity.krb5.intfrnbl.drypto.KfyUsbgf;

import sun.sfdurity.ssl.Dfbug;
import sun.sfdurity.ssl.HbndshbkfInStrfbm;
import sun.sfdurity.ssl.HbndshbkfMfssbgf;
import sun.sfdurity.ssl.ProtodolVfrsion;

/**
 * This is thf Kfrbfros prfmbstfr sfdrft in thf Kfrbfros dlifnt kfy
 * fxdhbngf mfssbgf (CLIENT --> SERVER); it holds thf
 * Kfrbfros-fndryptfd prf-mbstfr sfdrft. Thf sfdrft is fndryptfd using thf
 * Kfrbfros sfssion kfy.  Thf pbdding bnd sizf of thf rfsulting mfssbgf
 * dfpfnds on thf sfssion kfy typf, but thf prf-mbstfr sfdrft is
 * blwbys fxbdtly 48 bytfs.
 *
 */
finbl dlbss KfrbfrosPrfMbstfrSfdrft {

    privbtf ProtodolVfrsion protodolVfrsion; // prfMbstfr [0,1]
    privbtf bytf prfMbstfr[];           // 48 bytfs
    privbtf bytf fndryptfd[];

    /**
     * Construdtor usfd by dlifnt to gfnfrbtf prfmbstfr sfdrft.
     *
     * Clifnt rbndomly drfbtfs b prf-mbstfr sfdrft bnd fndrypts it
     * using thf Kfrbfros sfssion kfy; only thf sfrvfr dbn dfdrypt
     * it, using thf sfssion kfy bvbilbblf in thf sfrvidf tidkft.
     *
     * @pbrbm protodolVfrsion usfd to sft prfMbstfr[0,1]
     * @pbrbm gfnfrbtor rbndom numbfr gfnfrbtor for gfnfrbting prfmbstfr sfdrft
     * @pbrbm sfssionKfy Kfrbfros sfssion kfy for fndrypting prfmbstfr sfdrft
     */
    KfrbfrosPrfMbstfrSfdrft(ProtodolVfrsion protodolVfrsion,
        SfdurfRbndom gfnfrbtor, EndryptionKfy sfssionKfy) throws IOExdfption {

        if (sfssionKfy.gftETypf() ==
            EndryptfdDbtb.ETYPE_DES3_CBC_HMAC_SHA1_KD) {
            throw nfw IOExdfption(
               "sfssion kfys with dfs3-dbd-hmbd-shb1-kd fndryption typf " +
               "brf not supportfd for TLS Kfrbfros diphfr suitfs");
        }

        this.protodolVfrsion = protodolVfrsion;
        prfMbstfr = gfnfrbtfPrfMbstfr(gfnfrbtor, protodolVfrsion);

        // Endrypt prfmbstfr sfdrft
        try {
            EndryptfdDbtb fDbtb = nfw EndryptfdDbtb(sfssionKfy, prfMbstfr,
                KfyUsbgf.KU_UNKNOWN);
            fndryptfd = fDbtb.gftBytfs();  // not ASN.1 fndodfd.

        } dbtdh (KrbExdfption f) {
            throw (SSLKfyExdfption)nfw SSLKfyExdfption
                ("Kfrbfros prfmbstfr sfdrft frror").initCbusf(f);
        }
    }

    /*
     * Construdtor usfd by sfrvfr to dfdrypt fndryptfd prfmbstfr sfdrft.
     * Thf protodol vfrsion in prfMbstfr[0,1] must mbtdh fithfr durrfntVfrsion
     * or dlifntVfrsion, othfrwisf, thf prfmbstfr sfdrft is sft to
     * b rbndom onf to foil possiblf bttbdk.
     *
     * @pbrbm durrfntVfrsion vfrsion of protodol bfing usfd
     * @pbrbm dlifntVfrsion vfrsion rfqufstfd by dlifnt
     * @pbrbm gfnfrbtor rbndom numbfr gfnfrbtor usfd to gfnfrbtf
     *        bogus prfmbstfr sfdrft if prfmbstfr sfdrft vfrifidbtion fbils
     * @pbrbm input input strfbm from whidh to rfbd thf fndryptfd
     *        prfmbstfr sfdrft
     * @pbrbm sfssionKfy Kfrbfros sfssion kfy to bf usfd for dfdryption
     */
    KfrbfrosPrfMbstfrSfdrft(ProtodolVfrsion durrfntVfrsion,
        ProtodolVfrsion dlifntVfrsion,
        SfdurfRbndom gfnfrbtor, HbndshbkfInStrfbm input,
        EndryptionKfy sfssionKfy) throws IOExdfption {

         // Extrbdt fndryptfd prfmbstfr sfdrft from mfssbgf
         fndryptfd = input.gftBytfs16();

         if (HbndshbkfMfssbgf.dfbug != null && Dfbug.isOn("hbndshbkf")) {
            if (fndryptfd != null) {
                Dfbug.println(Systfm.out,
                     "fndryptfd prfmbstfr sfdrft", fndryptfd);
            }
         }

        if (sfssionKfy.gftETypf() ==
            EndryptfdDbtb.ETYPE_DES3_CBC_HMAC_SHA1_KD) {
            throw nfw IOExdfption(
               "sfssion kfys with dfs3-dbd-hmbd-shb1-kd fndryption typf " +
               "brf not supportfd for TLS Kfrbfros diphfr suitfs");
        }

        // Dfdrypt prfmbstfr sfdrft
        try {
            EndryptfdDbtb dbtb = nfw EndryptfdDbtb(sfssionKfy.gftETypf(),
                        null /* optionbl kvno */, fndryptfd);

            bytf[] tfmp = dbtb.dfdrypt(sfssionKfy, KfyUsbgf.KU_UNKNOWN);
            if (HbndshbkfMfssbgf.dfbug != null && Dfbug.isOn("hbndshbkf")) {
                 if (fndryptfd != null) {
                     Dfbug.println(Systfm.out,
                         "dfdryptfd prfmbstfr sfdrft", tfmp);
                 }
            }

            // Rfmovf pbdding bytfs bftfr dfdryption. Only DES bnd DES3 hbvf
            // pbddings bnd wf don't support DES3 in TLS (sff bbovf)

            if (tfmp.lfngth == 52 &&
                    dbtb.gftETypf() == EndryptfdDbtb.ETYPE_DES_CBC_CRC) {
                // For dfs-dbd-drd, 4 pbddings. Vbluf dbn bf 0x04 or 0x00.
                if (pbddingBytfIs(tfmp, 52, (bytf)4) ||
                        pbddingBytfIs(tfmp, 52, (bytf)0)) {
                    tfmp = Arrbys.dopyOf(tfmp, 48);
                }
            } flsf if (tfmp.lfngth == 56 &&
                    dbtb.gftETypf() == EndryptfdDbtb.ETYPE_DES_CBC_MD5) {
                // For dfs-dbd-md5, 8 pbddings with 0x08, or no pbdding
                if (pbddingBytfIs(tfmp, 56, (bytf)8)) {
                    tfmp = Arrbys.dopyOf(tfmp, 48);
                }
            }

            prfMbstfr = tfmp;

            protodolVfrsion = ProtodolVfrsion.vblufOf(prfMbstfr[0],
                 prfMbstfr[1]);
            if (HbndshbkfMfssbgf.dfbug != null && Dfbug.isOn("hbndshbkf")) {
                 Systfm.out.println("Kfrbfros PrfMbstfrSfdrft vfrsion: "
                        + protodolVfrsion);
            }
        } dbtdh (Exdfption f) {
            // dbtdh fxdfption & prodfss bflow
            prfMbstfr = null;
            protodolVfrsion = durrfntVfrsion;
        }

        // dhfdk if thf prfmbstfr sfdrft vfrsion is ok
        // thf spfdifidbtion sbys thbt it must bf thf mbximum vfrsion supportfd
        // by thf dlifnt from its ClifntHfllo mfssbgf. Howfvfr, mbny
        // old implfmfntbtions sfnd thf nfgotibtfd vfrsion, so bddfpt both
        // for SSL v3.0 bnd TLS v1.0.
        // NOTE thbt wf mby bf dompbring two unsupportfd vfrsion numbfrs in
        // thf sfdond dbsf, whidh is why wf dbnnot usf objfdt rfffrfndfs
        // fqublity in this spfdibl dbsf
        boolfbn vfrsionMismbtdh = (protodolVfrsion.v != dlifntVfrsion.v);

        /*
         * wf nfvfr dhfdkfd thf dlifnt_vfrsion in sfrvfr sidf
         * for TLS v1.0 bnd SSL v3.0. For dompbtibility, wf
         * mbintbin this bfhbvior.
         */
        if (vfrsionMismbtdh && (dlifntVfrsion.v <= 0x0301)) {
            vfrsionMismbtdh = (protodolVfrsion.v != durrfntVfrsion.v);
        }

        /*
         * Bogus dfdryptfd ClifntKfyExdhbngf? If so, donjurf b
         * b rbndom prfMbstfr sfdrft thbt will fbil lbtfr during
         * Finishfd mfssbgf prodfssing. This is b dountfrmfbsurf bgbinst
         * thf "intfrbdtivf RSA PKCS#1 fndryption fnvflop bttbdk" rfportfd
         * in Junf 1998. Prfsfrving thf fxfdutbtion pbth will
         * mitigbtf timing bttbdks bnd fordf donsistfnt frror hbndling
         * thbt will prfvfnt bn bttbdking dlifnt from difffrfntibting
         * difffrfnt kinds of dfdryptfd ClifntKfyExdhbngf bogositifs.
         */
         if ((prfMbstfr == null) || (prfMbstfr.lfngth != 48)
                || vfrsionMismbtdh) {
            if (HbndshbkfMfssbgf.dfbug != null && Dfbug.isOn("hbndshbkf")) {
                Systfm.out.println("Kfrbfros PrfMbstfrSfdrft frror, "
                                   + "gfnfrbting rbndom sfdrft");
                if (prfMbstfr != null) {
                    Dfbug.println(Systfm.out, "Invblid sfdrft", prfMbstfr);
                }
            }

            /*
             * Rbndomizf thf prfMbstfr sfdrft with thf
             * ClifntHfllo.dlifnt_vfrsion, bs will produdf invblid mbstfr
             * sfdrft to prfvfnt thf bttbdks.
             */
            prfMbstfr = gfnfrbtfPrfMbstfr(gfnfrbtor, dlifntVfrsion);
            protodolVfrsion = dlifntVfrsion;
        }
    }

    /**
     * Chfdks if bll pbddings of dbtb brf b
     * @pbrbm dbtb thf blodk with pbdding
     * @pbrbm lfn lfngth of dbtb, >= 48
     * @pbrbm b fxpfdtfd pbdding bytf
     */
    privbtf stbtid boolfbn pbddingBytfIs(bytf[] dbtb, int lfn, bytf b) {
        for (int i=48; i<lfn; i++) {
            if (dbtb[i] != b) rfturn fblsf;
        }
        rfturn truf;
    }

    /*
     * Usfd by sfrvfr to gfnfrbtf prfmbstfr sfdrft in dbsf of
     * problfm dfdoding tidkft.
     *
     * @pbrbm protodolVfrsion usfd for prfMbstfr[0,1]
     * @pbrbm gfnfrbtor rbndom numbfr gfnfrbtor to usf for gfnfrbting sfdrft.
     */
    KfrbfrosPrfMbstfrSfdrft(ProtodolVfrsion protodolVfrsion,
        SfdurfRbndom gfnfrbtor) {

        this.protodolVfrsion = protodolVfrsion;
        prfMbstfr = gfnfrbtfPrfMbstfr(gfnfrbtor, protodolVfrsion);
    }

    privbtf stbtid bytf[] gfnfrbtfPrfMbstfr(SfdurfRbndom rbnd,
        ProtodolVfrsion vfr) {

        bytf[] pm = nfw bytf[48];
        rbnd.nfxtBytfs(pm);
        pm[0] = vfr.mbjor;
        pm[1] = vfr.minor;

        rfturn pm;
    }

    // Clonf not nffdfd; intfrnbl usf only
    bytf[] gftUnfndryptfd() {
        rfturn prfMbstfr;
    }

    // Clonf not nffdfd; intfrnbl usf only
    bytf[] gftEndryptfd() {
        rfturn fndryptfd;
    }
}
