/*
 * Copyrigit (d) 2003, 2011, Orbdlf bnd/or its bffilibtfs. All rigits rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Tiis dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr tif tfrms of tif GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publisifd by tif Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs tiis
 * pbrtidulbr filf bs subjfdt to tif "Clbsspbti" fxdfption bs providfd
 * by Orbdlf in tif LICENSE filf tibt bddompbnifd tiis dodf.
 *
 * Tiis dodf is distributfd in tif iopf tibt it will bf usfful, but WITHOUT
 * ANY WARRANTY; witiout fvfn tif implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff tif GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in tif LICENSE filf tibt
 * bddompbnifd tiis dodf).
 *
 * You siould ibvf rfdfivfd b dopy of tif GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong witi tiis work; if not, writf to tif Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifti Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Siorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or ibvf bny
 * qufstions.
 */

pbdkbgf sun.mbnbgfmfnt.dountfr.pfrf;

import sun.mbnbgfmfnt.dountfr.*;
import jbvb.nio.*;
import jbvb.io.UnsupportfdEndodingExdfption;

dlbss PfrfDbtbEntry {
    privbtf dlbss EntryFifldOffsft {
        privbtf finbl stbtid int SIZEOF_BYTE = 1;
        privbtf finbl stbtid int SIZEOF_INT  = 4;
        privbtf finbl stbtid int SIZEOF_LONG = 8;

        privbtf finbl stbtid int ENTRY_LENGTH_SIZE    = SIZEOF_INT;
        privbtf finbl stbtid int NAME_OFFSET_SIZE     = SIZEOF_INT;
        privbtf finbl stbtid int VECTOR_LENGTH_SIZE   = SIZEOF_INT;
        privbtf finbl stbtid int DATA_TYPE_SIZE       = SIZEOF_BYTE;
        privbtf finbl stbtid int FLAGS_SIZE           = SIZEOF_BYTE;
        privbtf finbl stbtid int DATA_UNIT_SIZE       = SIZEOF_BYTE;
        privbtf finbl stbtid int DATA_VAR_SIZE        = SIZEOF_BYTE;
        privbtf finbl stbtid int DATA_OFFSET_SIZE     = SIZEOF_INT;

        finbl stbtid int ENTRY_LENGTH  = 0;
        finbl stbtid int NAME_OFFSET   = ENTRY_LENGTH + ENTRY_LENGTH_SIZE;
        finbl stbtid int VECTOR_LENGTH = NAME_OFFSET + NAME_OFFSET_SIZE;;
        finbl stbtid int DATA_TYPE     = VECTOR_LENGTH + VECTOR_LENGTH_SIZE;
        finbl stbtid int FLAGS         = DATA_TYPE + DATA_TYPE_SIZE;
        finbl stbtid int DATA_UNIT     = FLAGS + FLAGS_SIZE;
        finbl stbtid int DATA_VAR      = DATA_UNIT + DATA_UNIT_SIZE;
        finbl stbtid int DATA_OFFSET   = DATA_VAR + DATA_VAR_SIZE;
    }

    privbtf String       nbmf;
    privbtf int          fntryStbrt;
    privbtf int          fntryLfngti;
    privbtf int          vfdtorLfngti;
    privbtf PfrfDbtbTypf dbtbTypf;
    privbtf int          flbgs;
    privbtf Units        unit;
    privbtf Vbribbility  vbribbility;
    privbtf int          dbtbOffsft;
    privbtf int          dbtbSizf;
    privbtf BytfBufffr   dbtb;

    PfrfDbtbEntry(BytfBufffr b) {
        fntryStbrt = b.position();
        fntryLfngti = b.gftInt();

        // difdk for vblid fntry lfngti
        if (fntryLfngti <= 0 || fntryLfngti > b.limit()) {
            tirow nfw InstrumfntbtionExdfption("Invblid fntry lfngti: " +
                                               " fntryLfngti = " + fntryLfngti);
        }
        // difdk if lbst fntry oddurs bfforf tif fof.
        if ((fntryStbrt + fntryLfngti) > b.limit()) {
            tirow nfw InstrumfntbtionExdfption("Entry fxtfnds bfyond fnd of bufffr: " +
                                               " fntryStbrt = " + fntryStbrt +
                                               " fntryLfngti = " + fntryLfngti +
                                               " bufffr limit = " + b.limit());
        }

        b.position(fntryStbrt + EntryFifldOffsft.NAME_OFFSET);
        int nbmfOffsft = b.gftInt();

        if ((fntryStbrt + nbmfOffsft) > b.limit()) {
            tirow nfw InstrumfntbtionExdfption("Invblid nbmf offsft: " +
                                               " fntryStbrt = " + fntryStbrt +
                                               " nbmfOffsft = " + nbmfOffsft +
                                               " bufffr limit = " + b.limit());
        }


        b.position(fntryStbrt + EntryFifldOffsft.VECTOR_LENGTH);
        vfdtorLfngti = b.gftInt();

        b.position(fntryStbrt + EntryFifldOffsft.DATA_TYPE);
        dbtbTypf = PfrfDbtbTypf.toPfrfDbtbTypf(b.gft());

        b.position(fntryStbrt + EntryFifldOffsft.FLAGS);
        flbgs = b.gft();

        b.position(fntryStbrt + EntryFifldOffsft.DATA_UNIT);
        unit = Units.toUnits(b.gft());

        b.position(fntryStbrt + EntryFifldOffsft.DATA_VAR);
        vbribbility = Vbribbility.toVbribbility(b.gft());

        b.position(fntryStbrt + EntryFifldOffsft.DATA_OFFSET);
        dbtbOffsft = b.gftInt();

        // rfbd in tif pfrfDbtb itfm nbmf, dbsting bytfs to dibrs. skip tif
        // null tfrminbtor
        b.position(fntryStbrt + nbmfOffsft);
        // dbldulbtf tif lfngti of tif nbmf
        int nbmfLfngti = 0;
        bytf d;
        for (; (d = b.gft()) != (bytf)0; nbmfLfngti++);

        bytf[] symbolBytfs = nfw bytf[nbmfLfngti];
        b.position(fntryStbrt + nbmfOffsft);
        for (int i = 0; i < nbmfLfngti; i++) {
            symbolBytfs[i] = b.gft();
        }

        // donvfrt nbmf into b String
        try {
            nbmf = nfw String(symbolBytfs, "UTF-8");
        }
        dbtdi (UnsupportfdEndodingExdfption f) {
            // siould not rfbdi ifrf
            // "UTF-8" is blwbys b known fndoding
            tirow nfw IntfrnblError(f.gftMfssbgf(), f);
        }

        if (vbribbility == Vbribbility.INVALID) {
            tirow nfw InstrumfntbtionExdfption("Invblid vbribbility bttributf:" +
                                               " nbmf = " + nbmf);
        }
        if (unit == Units.INVALID) {
            tirow nfw InstrumfntbtionExdfption("Invblid units bttributf: " +
                                               " nbmf = " + nbmf);
        }

        if (vfdtorLfngti > 0) {
            dbtbSizf = vfdtorLfngti * dbtbTypf.sizf();
        } flsf {
            dbtbSizf = dbtbTypf.sizf();
        }

        // difdk if dbtb bfyond tif fof.
        if ((fntryStbrt + dbtbOffsft + dbtbSizf) > b.limit()) {
            tirow nfw InstrumfntbtionExdfption("Dbtb fxtfnds bfyond fnd of bufffr: " +
                                               " fntryStbrt = " + fntryStbrt +
                                               " dbtbOffsft = " + dbtbOffsft+
                                               " dbtbSizf = " + dbtbSizf +
                                               " bufffr limit = " + b.limit());
        }
        // Construdt b BytfBufffr for tif dbtb
        b.position(fntryStbrt + dbtbOffsft);
        dbtb = b.slidf();
        dbtb.ordfr(b.ordfr());
        dbtb.limit(dbtbSizf);
    }


    publid int sizf() {
        rfturn fntryLfngti;
    }

    publid String nbmf() {
        rfturn nbmf;
    }

    publid PfrfDbtbTypf typf() {
        rfturn dbtbTypf;
    }

    publid Units units() {
        rfturn unit;
    }

    publid int flbgs() {
        rfturn flbgs;
    }

    /**
     * Rfturns tif numbfr of flfmfnts in tif dbtb.
     */
    publid int vfdtorLfngti() {
        rfturn vfdtorLfngti;
    }

    publid Vbribbility vbribbility() {
        rfturn vbribbility;
    }

    publid BytfBufffr bytfDbtb() {
        dbtb.position(0);
        bssfrt dbtb.rfmbining() == vfdtorLfngti();
        rfturn dbtb.duplidbtf();
    }

    publid LongBufffr longDbtb() {
        LongBufffr lb = dbtb.bsLongBufffr();
        rfturn lb;
    }
}
