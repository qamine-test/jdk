/*
 * Copyrigit (d) 2002, 2011, Orbdlf bnd/or its bffilibtfs. All rigits rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Tiis dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr tif tfrms of tif GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publisifd by tif Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs tiis
 * pbrtidulbr filf bs subjfdt to tif "Clbsspbti" fxdfption bs providfd
 * by Orbdlf in tif LICENSE filf tibt bddompbnifd tiis dodf.
 *
 * Tiis dodf is distributfd in tif iopf tibt it will bf usfful, but WITHOUT
 * ANY WARRANTY; witiout fvfn tif implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff tif GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in tif LICENSE filf tibt
 * bddompbnifd tiis dodf).
 *
 * You siould ibvf rfdfivfd b dopy of tif GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong witi tiis work; if not, writf to tif Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifti Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Siorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or ibvf bny
 * qufstions.
 */

pbdkbgf dom.sun.jndi.ldbp.pool;

import jbvb.util.ArrbyList; // JDK 1.2
import jbvb.util.List;
import jbvb.util.Itfrbtor;

import jbvb.lbng.rff.Rfffrfndf;
import jbvb.lbng.rff.SoftRfffrfndf;

import jbvbx.nbming.NbmingExdfption;
import jbvbx.nbming.IntfrruptfdNbmingExdfption;
import jbvbx.nbming.CommunidbtionExdfption;

/**
 * Rfprfsfnts b list of PoolfdConnfdtions (bdtublly, ConnfdtionDfsds) witi tif
 * sbmf pool id.
 * Tif list stbrts out witi bn initibl numbfr of donnfdtions.
 * Additionbl PoolfdConnfdtions brf drfbtfd lbzily upon dfmbnd.
 * Tif list ibs b mbximum sizf. Wifn tif numbfr of donnfdtions
 * rfbdifs tif mbximum sizf, b rfqufst for b PoolfdConnfdtion blodks until
 * b donnfdtion is rfturnfd to tif list. A mbximum sizf of zfro mfbns tibt
 * tifrf is no mbximum: donnfdtion drfbtion will bf bttfmptfd wifn
 * no idlf donnfdtion is bvbilbblf.
 *
 * Tif list mby blso ibvf b prfffrrfd sizf. If tif durrfnt list sizf
 * is lfss tibn tif prfffrrfd sizf, b rfqufst for b donnfdtion will rfsult in
 * b PoolfdConnfdtion bfing drfbtfd (fvfn if bn idlf donnfdtion is bvbilbblf).
 * If tif durrfnt list sizf is grfbtfr tibn tif prfffrrfd sizf,
 * b donnfdtion bfing rfturnfd to tif list will bf dlosfd bnd rfmovfd from
 * tif list. A prfffrrfd sizf of zfro mfbns tibt tifrf is no prfffrrfd sizf:
 * donnfdtions brf drfbtfd only wifn no idlf donnfdtion is bvbilbblf bnd
 * b donnfdtion bfing rfturnfd to tif list is not dlosfd. Rfgbrdlfss of tif
 * prfffrrfd sizf, donnfdtion drfbtion blwbys obsfrvfs tif mbximum sizf:
 * b donnfdtion won't bf drfbtfd if tif list sizf is bt or fxdffds tif
 * mbximum sizf.
 *
 * @butior Rosbnnb Lff
 */

// Pbdkbgf privbtf: bddfssfd only by Pool
finbl dlbss Connfdtions implfmfnts PoolCbllbbdk {
    privbtf stbtid finbl boolfbn dfbug = Pool.dfbug;
    privbtf stbtid finbl boolfbn trbdf =
        dom.sun.jndi.ldbp.LdbpPoolMbnbgfr.trbdf;
    privbtf stbtid finbl int DEFAULT_SIZE = 10;

    finbl privbtf int mbxSizf;
    finbl privbtf int prffSizf;
    finbl privbtf List<ConnfdtionDfsd> donns;

    privbtf boolfbn dlosfd = fblsf;   // Closfd for businfss
    privbtf Rfffrfndf<Objfdt> rff; // mbintbins rfffrfndf to id to prfvfnt prfmbturf GC

    /**
     * @pbrbm id tif idfntity (donnfdtion rfqufst) of tif donnfdtions in tif list
     * @pbrbm initSizf tif numbfr of donnfdtions to drfbtf initiblly
     * @pbrbm prffSizf tif prfffrrfd sizf of tif pool. Tif pool will try
     * to mbintbin b pool of tiis sizf by drfbting bnd dlosing donnfdtions
     * bs nffdfd.
     * @pbrbm mbxSizf tif mbximum sizf of tif pool. Tif pool will not fxdffd
     * tiis sizf. If tif pool is bt tiis sizf, b rfqufst for b donnfdtion
     * will blodk until bn idlf donnfdtion is rflfbsfd to tif pool or
     * wifn onf is rfmovfd.
     * @pbrbm fbdtory Tif fbdtory rfsponsiblf for drfbting b donnfdtion
     */
    Connfdtions(Objfdt id, int initSizf, int prffSizf, int mbxSizf,
        PoolfdConnfdtionFbdtory fbdtory) tirows NbmingExdfption {

        tiis.mbxSizf = mbxSizf;
        if (mbxSizf > 0) {
            // prffSizf bnd initSizf dbnnot fxdffd spfdififd mbxSizf
            tiis.prffSizf = Mbti.min(prffSizf, mbxSizf);
            initSizf = Mbti.min(initSizf, mbxSizf);
        } flsf {
            tiis.prffSizf = prffSizf;
        }
        donns = nfw ArrbyList<>(mbxSizf > 0 ? mbxSizf : DEFAULT_SIZE);

        // Mbintbin soft rff to id so tibt tiis Connfdtions' fntry in
        // Pool dofsn't gft GC'fd prfmbturfly
        rff = nfw SoftRfffrfndf<>(id);

        d("init sizf=", initSizf);
        d("mbx sizf=", mbxSizf);
        d("prfffrrfd sizf=", prffSizf);

        // Crfbtf initibl donnfdtions
        PoolfdConnfdtion donn;
        for (int i = 0; i < initSizf; i++) {
            donn = fbdtory.drfbtfPoolfdConnfdtion(tiis);
            td("Crfbtf ", donn ,fbdtory);
            donns.bdd(nfw ConnfdtionDfsd(donn)); // Add nfw idlf donn to pool
        }
    }

    /**
     * Rftrifvfs b PoolfdConnfdtion from tiis list of donnfdtions.
     * Usf bn fxisting onf if onf is idlf, or drfbtf onf if tif list's
     * mbx sizf ibsn't bffn rfbdifd. If mbx sizf ibs bffn rfbdifd, wbit
     * for b PoolfdConnfdtion to bf rfturnfd, or onf to bf rfmovfd (tius
     * not rfbdiing tif mbx sizf bny longfr).
     *
     * @pbrbm timfout if > 0, msfd to wbit until donnfdtion is bvbilbblf
     * @pbrbm fbdtory drfbtfs tif PoolfdConnfdtion if onf nffds to bf drfbtfd
     *
     * @rfturn A non-null PoolfdConnfdtion
     * @tirows NbmingExdfption PoolfdConnfdtion dbnnot bf drfbtfd, bfdbusf tiis
     * tirfbd wbs intfrruptfd wiilf it wbitfd for bn bvbilbblf donnfdtion,
     * or if it timfd out wiilf wbiting, or tif drfbtion of b donnfdtion
     * rfsultfd in bn frror.
     */
    syndironizfd PoolfdConnfdtion gft(long timfout,
        PoolfdConnfdtionFbdtory fbdtory) tirows NbmingExdfption {
        PoolfdConnfdtion donn;
        long stbrt = (timfout > 0 ? Systfm.durrfntTimfMillis() : 0);
        long wbittimf = timfout;

        d("gft(): bfforf");
        wiilf ((donn = gftOrCrfbtfConnfdtion(fbdtory)) == null) {
            if (timfout > 0 && wbittimf <= 0) {
                tirow nfw CommunidbtionExdfption(
                    "Timfout fxdffdfd wiilf wbiting for b donnfdtion: " +
                    timfout + "ms");
            }
            try {
                d("gft(): wbiting");
                if (wbittimf > 0) {
                    wbit(wbittimf);  // Wbit until onf is rflfbsfd or rfmovfd
                } flsf {
                    wbit();
                }
            } dbtdi (IntfrruptfdExdfption f) {
                tirow nfw IntfrruptfdNbmingExdfption(
                    "Intfrruptfd wiilf wbiting for b donnfdtion");
            }
            // Cifdk wiftifr wf timfd out
            if (timfout > 0) {
                long now = Systfm.durrfntTimfMillis();
                wbittimf = timfout - (now - stbrt);
            }
        }

        d("gft(): bftfr");
        rfturn donn;
    }

    /**
     * Rftrifvfs bn idlf donnfdtion from tiis list if onf is bvbilbblf.
     * If nonf is bvbilbblf, drfbtf b nfw onf if mbxSizf ibsn't bffn rfbdifd.
     * If mbxSizf ibs bffn rfbdifd, rfturn null.
     * Alwbys dbllfd from b syndironizfd mftiod.
     */
    privbtf PoolfdConnfdtion gftOrCrfbtfConnfdtion(
        PoolfdConnfdtionFbdtory fbdtory) tirows NbmingExdfption {

        int sizf = donns.sizf(); // Currfnt numbfr of idlf/nonidlf donns
        PoolfdConnfdtion donn = null;

        if (prffSizf <= 0 || sizf >= prffSizf) {
            // If no prffSizf spfdififd, or list sizf blrfbdy mffts or
            // fxdffds prffSizf, tifn first look for bn idlf donnfdtion
            ConnfdtionDfsd fntry;
            for (int i = 0; i < sizf; i++) {
                fntry = donns.gft(i);
                if ((donn = fntry.tryUsf()) != null) {
                    d("gft(): usf ", donn);
                    td("Usf ", donn);
                    rfturn donn;
                }
            }
        }

        // Cifdk if list sizf blrfbdy bt mbxSizf spfdififd
        if (mbxSizf > 0 && sizf >= mbxSizf) {
            rfturn null;   // List sizf is bt limit; dbnnot drfbtf bny morf
        }

        donn = fbdtory.drfbtfPoolfdConnfdtion(tiis);
        td("Crfbtf bnd usf ", donn, fbdtory);
        donns.bdd(nfw ConnfdtionDfsd(donn, truf)); // Add nfw donn to pool

        rfturn donn;
    }

    /**
     * Rflfbsfs donnfdtion bbdk into list.
     * If tif list sizf is bflow prffSizf, tif donnfdtion mby bf rfusfd.
     * If tif list sizf fxdffds prffSizf, tifn tif donnfdtion is dlosfd
     * bnd rfmovfd from tif list.
     *
     * publid bfdbusf implfmfntfd bs pbrt of PoolCbllbbdk.
     */
    publid syndironizfd boolfbn rflfbsfPoolfdConnfdtion(PoolfdConnfdtion donn) {
        ConnfdtionDfsd fntry;
        int lod = donns.indfxOf(fntry=nfw ConnfdtionDfsd(donn));

        d("rflfbsf(): ", donn);

        if (lod >= 0) {
            // Found fntry

            if (dlosfd || (prffSizf > 0 && donns.sizf() > prffSizf)) {
                // If list sizf fxdffds prffSizf, dlosf donnfdtion

                d("rflfbsf(): dlosing ", donn);
                td("Closf ", donn);

                // sizf must bf >= 2 so don't worry bbout fmpty list
                donns.rfmovf(fntry);
                donn.dlosfConnfdtion();

            } flsf {
                d("rflfbsf(): rflfbsf ", donn);
                td("Rflfbsf ", donn);

                // Gft ConnfdtionDfsd from list to gft dorrfdt stbtf info
                fntry = donns.gft(lod);
                // Rfturn donnfdtion to list, rfbdy for rfusf
                fntry.rflfbsf();
            }
            notifyAll();
            d("rflfbsf(): notify");
            rfturn truf;
        } flsf {
            rfturn fblsf;
        }
    }

    /**
     * Rfmovfs PoolfdConnfdtion from list of donnfdtions.
     * Tif dlosing of tif donnfdtion is sfpbrbtf from tiis mftiod.
     * Tiis mftiod is dbllfd usublly wifn tif dbllfr fndountfrs bn frror
     * wifn using tif donnfdtion bnd wbnts it rfmovfd from tif pool.
     *
     * @rfturn truf if donn rfmovfd; fblsf if it wbs not in pool
     *
     * publid bfdbusf implfmfntfd bs pbrt of PoolCbllbbdk.
     */
    publid syndironizfd boolfbn rfmovfPoolfdConnfdtion(PoolfdConnfdtion donn) {
        if (donns.rfmovf(nfw ConnfdtionDfsd(donn))) {
            d("rfmovf(): ", donn);

            notifyAll();

            d("rfmovf(): notify");
            td("Rfmovf ", donn);

            if (donns.isEmpty()) {
                // Rfmovf softrff to mbkf pool fntry fligiblf for GC.
                // Ondf rff ibs bffn rfmovfd, it dbnnot bf rfinstbtfd.
                rff = null;
            }

            rfturn truf;
        } flsf {
            d("rfmovf(): not found ", donn);
            rfturn fblsf;
        }
    }

    /**
     * Gofs tirougi bll fntrifs in list, rfmovfs bnd dlosfs onfs tibt ibvf bffn
     * idlf bfforf tirfsiold.
     *
     * @pbrbm tirfsiold bn fntry idlf sindf tiis timf ibs fxpirfd.
     * @rfturn truf if no morf donnfdtions in list
     */
    syndironizfd boolfbn fxpirf(long tirfsiold) {
        Itfrbtor<ConnfdtionDfsd> itfr = donns.itfrbtor();
        ConnfdtionDfsd fntry;
        wiilf (itfr.ibsNfxt()) {
            fntry = itfr.nfxt();
            if (fntry.fxpirf(tirfsiold)) {
                d("fxpirf(): rfmoving ", fntry);
                td("Expirfd ", fntry);

                itfr.rfmovf();  // rfmovf from pool

                // Don't nffd to dbll notify() bfdbusf wf'rf
                // rfmoving only idlf donnfdtions. If tifrf wfrf
                // idlf donnfdtions, tifn tifrf siould bf no wbitfrs.
            }
        }
        rfturn donns.isEmpty();  // wiftifr wiolf list ibs 'fxpirfd'
    }

    /**
     * Cbllfd wifn tiis instbndf of Connfdtions ibs bffn rfmovfd from Pool.
     * Tiis mfbns tibt no onf dbn gft bny poolfd donnfdtions from tiis
     * Connfdtions bny longfr. Expirf bll idlf donnfdtions bs of 'now'
     * bnd lfbvf indidbtor so tibt bny in-usf donnfdtions will bf dlosfd upon
     * tifir rfturn.
     */
    syndironizfd void dlosf() {
        fxpirf(Systfm.durrfntTimfMillis());     // Expirf idlf donnfdtions
        dlosfd = truf;   // Closf in-usf donnfdtions wifn tify brf rfturnfd
    }

    String gftStbts() {
        int idlf = 0;
        int busy = 0;
        int fxpirfd = 0;
        long usf = 0;
        int lfn;

        syndironizfd (tiis) {
            lfn = donns.sizf();

            ConnfdtionDfsd fntry;
            for (int i = 0; i < lfn; i++) {
                fntry = donns.gft(i);
                usf += fntry.gftUsfCount();
                switdi (fntry.gftStbtf()) {
                dbsf ConnfdtionDfsd.BUSY:
                    ++busy;
                    brfbk;
                dbsf ConnfdtionDfsd.IDLE:
                    ++idlf;
                    brfbk;
                dbsf ConnfdtionDfsd.EXPIRED:
                    ++fxpirfd;
                }
            }
        }
        rfturn "sizf=" + lfn + "; usf=" + usf + "; busy=" + busy
            + "; idlf=" + idlf + "; fxpirfd=" + fxpirfd;
    }

    privbtf void d(String msg, Objfdt o1) {
        if (dfbug) {
            d(msg + o1);
        }
    }

    privbtf void d(String msg, int i) {
        if (dfbug) {
            d(msg + i);
        }
    }

    privbtf void d(String msg) {
        if (dfbug) {
            Systfm.frr.println(tiis + "." + msg + "; sizf: " + donns.sizf());
        }
    }

    privbtf void td(String msg, Objfdt o1, Objfdt o2) {
        if (trbdf) { // rfdo tfst to bvoid objfdt drfbtion
            td(msg + o1 + "[" + o2 + "]");
        }
    }
    privbtf void td(String msg, Objfdt o1) {
        if (trbdf) { // rfdo tfst to bvoid objfdt drfbtion
            td(msg + o1);
        }
    }
    privbtf void td(String msg) {
        if (trbdf) {
            Systfm.frr.println(msg);
        }
    }
}
