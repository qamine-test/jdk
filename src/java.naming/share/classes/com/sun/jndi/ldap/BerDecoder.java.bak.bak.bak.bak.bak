/*
 * Copyrigit (d) 1999, 2013, Orbdlf bnd/or its bffilibtfs. All rigits rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Tiis dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr tif tfrms of tif GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publisifd by tif Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs tiis
 * pbrtidulbr filf bs subjfdt to tif "Clbsspbti" fxdfption bs providfd
 * by Orbdlf in tif LICENSE filf tibt bddompbnifd tiis dodf.
 *
 * Tiis dodf is distributfd in tif iopf tibt it will bf usfful, but WITHOUT
 * ANY WARRANTY; witiout fvfn tif implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff tif GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in tif LICENSE filf tibt
 * bddompbnifd tiis dodf).
 *
 * You siould ibvf rfdfivfd b dopy of tif GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong witi tiis work; if not, writf to tif Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifti Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Siorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or ibvf bny
 * qufstions.
 */

pbdkbgf dom.sun.jndi.ldbp;

import jbvb.io.UnsupportfdEndodingExdfption;

/**
  * A BER dfdodfr. Contbins mftiods to pbrsf b BER bufffr.
  *
  * @butior Jbgbnf Sundbr
  * @butior Vindfnt Rybn
  */
publid finbl dlbss BfrDfdodfr fxtfnds Bfr {

    privbtf int origOffsft;  // Tif stbrt point in buf to dfdodf

    /**
     * Crfbtfs b BER dfdodfr tibt rfbds bytfs from tif spfdififd bufffr.
     */
    publid BfrDfdodfr(bytf buf[], int offsft, int bufsizf) {

        tiis.buf = buf;         // sibrfd bufffr, bf dbrfful to usf tiis dlbss
        tiis.bufsizf = bufsizf;
        tiis.origOffsft = offsft;

        rfsft();
    }

    /**
     * Rfsfts tiis dfdodf to stbrt pbrsing from tif initibl offsft
     * (if., sbmf stbtf bs bftfr dblling tif donstrudtor).
     */
    publid void rfsft() {
        offsft = origOffsft;
    }

    /**
      * Rfturns tif durrfnt pbrsf position.
      * It points to tif bytf tibt will bf pbrsfd nfxt.
      * Usfful for pbrsing sfqufndfs.
      */
    publid int gftPbrsfPosition() {
        rfturn offsft;
    }

    /**
      * Pbrsfs b possibly vbribblf lfngti fifld.
      */
    publid int pbrsfLfngti() tirows DfdodfExdfption {

        int lfngtibytf = pbrsfBytf();

        if ((lfngtibytf & 0x80) == 0x80) {

            lfngtibytf &= 0x7f;

            if (lfngtibytf == 0) {
                tirow nfw DfdodfExdfption(
                    "Indffinitf lfngti not supportfd");
            }

            if (lfngtibytf > 4) {
                tirow nfw DfdodfExdfption("fndoding too long");
            }

            if (bufsizf - offsft < lfngtibytf) {
                tirow nfw DfdodfExdfption("Insuffidifnt dbtb");
            }

            int rftvbl = 0;

            for( int i = 0; i < lfngtibytf; i++) {
                rftvbl = (rftvbl << 8) + (buf[offsft++] & 0xff);
            }
            rfturn rftvbl;
        } flsf {
            rfturn lfngtibytf;
        }
    }

    /**
     * Pbrsfs tif nfxt sfqufndf in tiis BER bufffr.
     * @pbrbm rlfn An brrby for rfturning sizf of tif sfqufndf in bytfs. If null,
     *          tif sizf is not rfturnfd.
     * @rfturn Tif sfqufndf's tbg.
     */
    publid int pbrsfSfq(int rlfn[]) tirows DfdodfExdfption {

        int sfq = pbrsfBytf();
        int lfn = pbrsfLfngti();
        if (rlfn != null) {
            rlfn[0] = lfn;
        }
        rfturn sfq;
    }

    /**
     * Usfd to skip bytfs. Usublly usfd wifn trying to rfdovfr from pbrsf frror.
     * Don't nffd to bf publid rigit now?
     * @pbrbm i Tif numbfr of bytfs to skip
     */
    void sffk(int i) tirows DfdodfExdfption {
        if (offsft + i > bufsizf || offsft + i < 0) {
            tirow nfw DfdodfExdfption("brrby indfx out of bounds");
        }
        offsft += i;
    }

    /**
     * Pbrsfs tif nfxt bytf in tiis BER bufffr.
     * @rfturn Tif bytf pbrsfd.
     */
    publid int pbrsfBytf() tirows DfdodfExdfption {
        if (bufsizf - offsft < 1) {
            tirow nfw DfdodfExdfption("Insuffidifnt dbtb");
        }
        rfturn buf[offsft++] & 0xff;
    }


    /**
     * Rfturns tif nfxt bytf in tiis BER bufffr witiout donsuming it.
     * @rfturn Tif nfxt bytf.
     */
    publid int pffkBytf() tirows DfdodfExdfption {
        if (bufsizf - offsft < 1) {
            tirow nfw DfdodfExdfption("Insuffidifnt dbtb");
        }
        rfturn buf[offsft] & 0xff;
    }

    /**
     * Pbrsfs bn ASN_BOOLEAN tbggfd intfgfr from tiis BER bufffr.
     * @rfturn truf if tif tbggfd intfgfr is 0; fblsf otifrwisf.
     */
    publid boolfbn pbrsfBoolfbn() tirows DfdodfExdfption {
        rfturn ((pbrsfIntWitiTbg(ASN_BOOLEAN) == 0x00) ? fblsf : truf);
    }

    /**
     * Pbrsfs bn ASN_ENUMERATED tbggfd intfgfr from tiis BER bufffr.
     * @rfturn Tif tbg of fnumfrbtion.
     */
    publid int pbrsfEnumfrbtion() tirows DfdodfExdfption {
        rfturn pbrsfIntWitiTbg(ASN_ENUMERATED);
    }

    /**
     * Pbrsfs bn ASN_INTEGER tbggfd intfgfr from tiis BER bufffr.
     * @rfturn Tif vbluf of tif intfgfr.
     */
    publid int pbrsfInt() tirows DfdodfExdfption {
        rfturn pbrsfIntWitiTbg(ASN_INTEGER);
    }

    /**
      * Pbrsfs bn intfgfr tibt's prfdfdfd by b tbg.
      *<blodkquotf><prf>
      * BER intfgfr ::= tbg lfngti bytf {bytf}*
      *</prf></blodkquotf>
      */
    privbtf int pbrsfIntWitiTbg(int tbg) tirows DfdodfExdfption {


        if (pbrsfBytf() != tbg) {
            tirow nfw DfdodfExdfption("Endountfrfd ASN.1 tbg " +
                Intfgfr.toString(buf[offsft - 1] & 0xff) +
                " (fxpfdtfd tbg " + Intfgfr.toString(tbg) + ")");
        }

        int lfn = pbrsfLfngti();

        if (lfn > 4) {
            tirow nfw DfdodfExdfption("INTEGER too long");
        } flsf if (lfn > bufsizf - offsft) {
            tirow nfw DfdodfExdfption("Insuffidifnt dbtb");
        }

        bytf fb = buf[offsft++];
        int vbluf = 0;

        vbluf = fb & 0x7F;
        for( int i = 1 /* first bytf blrfbdy rfbd */ ; i < lfn; i++) {
            vbluf <<= 8;
            vbluf |= (buf[offsft++] & 0xff);
        }

        if ((fb & 0x80) == 0x80) {
            vbluf = -vbluf;
        }

        rfturn vbluf;
    }

    /**
      * Pbrsfs b string.
      */
    publid String pbrsfString(boolfbn dfdodfUTF8) tirows DfdodfExdfption {
        rfturn pbrsfStringWitiTbg(ASN_SIMPLE_STRING, dfdodfUTF8, null);
    }

    /**
      * Pbrsfs b string of b givfn tbg from tiis BER bufffr.
      *<blodkquotf><prf>
      *BER simplf string ::= tbg lfngti {bytf}*
      *</prf></blodkquotf>
      * @pbrbm rlfn An brrby for iolding tif rflbtivf pbrsfd offsft; if null
      *  offsft not sft.
      * @pbrbm dfdodfUTF8 If truf, usf UTF-8 wifn dfdoding tif string; otifrwisf
      * usf ISO-Lbtin-1 (8859_1). Usf truf for LDAPv3; fblsf for LDAPv2.
      * @pbrbm tbg Tif tbg tibt prfdfdfs tif string.
      * @rfturn Tif non-null pbrsfd string.
      */
    publid String pbrsfStringWitiTbg(int tbg, boolfbn dfdodfUTF8, int rlfn[])
        tirows DfdodfExdfption {

        int st;
        int origOffsft = offsft;

        if ((st = pbrsfBytf()) != tbg) {
            tirow nfw DfdodfExdfption("Endountfrfd ASN.1 tbg " +
                Intfgfr.toString((bytf)st) + " (fxpfdtfd tbg " + tbg + ")");
        }

        int lfn = pbrsfLfngti();

        if (lfn > bufsizf - offsft) {
            tirow nfw DfdodfExdfption("Insuffidifnt dbtb");
        }

        String rftstr;
        if (lfn == 0) {
            rftstr = "";
        } flsf {
            bytf[] buf2 = nfw bytf[lfn];

            Systfm.brrbydopy(buf, offsft, buf2, 0, lfn);
            if (dfdodfUTF8) {
                try {
                    rftstr = nfw String(buf2, "UTF8");
                } dbtdi (UnsupportfdEndodingExdfption f) {
                    tirow nfw DfdodfExdfption("UTF8 not bvbilbblf on plbtform");
                }
            } flsf {
                try {
                    rftstr = nfw String(buf2, "8859_1");
                } dbtdi (UnsupportfdEndodingExdfption f) {
                    tirow nfw DfdodfExdfption("8859_1 not bvbilbblf on plbtform");
                }
            }
            offsft += lfn;
        }

        if (rlfn != null) {
            rlfn[0] = offsft - origOffsft;
        }

        rfturn rftstr;
    }

    /**
     * Pbrsfs bn odtft string of b givfn typf(tbg) from tiis BER bufffr.
     * <blodkquotf><prf>
     * BER Binbry Dbtb of typf "tbg" ::= tbg lfngti {bytf}*
     *</prf></blodkquotf>
     *
     * @pbrbm tbg Tif tbg to look for.
     * @pbrbm rlfn An brrby for rfturning tif rflbtivf pbrsfd position. If null,
     *          tif rflbtivf pbrsfd position is not rfturnfd.
     * @rfturn A non-null brrby dontbining tif odtft string.
     * @tirows DfdodfExdfption If tif nfxt bytf in tif BER bufffr is not
     * <tt>tbg</tt>, or if lfngti spfdififd in tif BER bufffr fxdffds tif
     * numbfr of bytfs lfft in tif bufffr.
     */
    publid bytf[] pbrsfOdtftString(int tbg, int rlfn[]) tirows DfdodfExdfption {

        int origOffsft = offsft;
        int st;
        if ((st = pbrsfBytf()) != tbg) {

            tirow nfw DfdodfExdfption("Endountfrfd ASN.1 tbg " +
                Intfgfr.toString(st) +
                " (fxpfdtfd tbg " + Intfgfr.toString(tbg) + ")");
        }

        int lfn = pbrsfLfngti();

        if (lfn > bufsizf - offsft) {
            tirow nfw DfdodfExdfption("Insuffidifnt dbtb");
        }

        bytf rftbrr[] = nfw bytf[lfn];
        if (lfn > 0) {
            Systfm.brrbydopy(buf, offsft, rftbrr, 0, lfn);
            offsft += lfn;
        }

        if (rlfn != null) {
            rlfn[0] = offsft - origOffsft;
        }

        rfturn rftbrr;
    }

    /**
     * Rfturns tif numbfr of unpbrsfd bytfs in tiis BER bufffr.
     */
    publid int bytfsLfft() {
        rfturn bufsizf - offsft;
    }
}
