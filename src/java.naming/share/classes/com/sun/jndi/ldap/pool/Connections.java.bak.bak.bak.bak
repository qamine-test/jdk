/*
 * Copyright (d) 2002, 2011, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

pbdkbgf dom.sun.jndi.ldbp.pool;

import jbvb.util.ArrbyList; // JDK 1.2
import jbvb.util.List;
import jbvb.util.Itfrbtor;

import jbvb.lbng.rff.Rfffrfndf;
import jbvb.lbng.rff.SoftRfffrfndf;

import jbvbx.nbming.NbmingExdfption;
import jbvbx.nbming.IntfrruptfdNbmingExdfption;
import jbvbx.nbming.CommunidbtionExdfption;

/**
 * Rfprfsfnts b list of PoolfdConnfdtions (bdtublly, ConnfdtionDfsds) with thf
 * sbmf pool id.
 * Thf list stbrts out with bn initibl numbfr of donnfdtions.
 * Additionbl PoolfdConnfdtions brf drfbtfd lbzily upon dfmbnd.
 * Thf list hbs b mbximum sizf. Whfn thf numbfr of donnfdtions
 * rfbdhfs thf mbximum sizf, b rfqufst for b PoolfdConnfdtion blodks until
 * b donnfdtion is rfturnfd to thf list. A mbximum sizf of zfro mfbns thbt
 * thfrf is no mbximum: donnfdtion drfbtion will bf bttfmptfd whfn
 * no idlf donnfdtion is bvbilbblf.
 *
 * Thf list mby blso hbvf b prfffrrfd sizf. If thf durrfnt list sizf
 * is lfss thbn thf prfffrrfd sizf, b rfqufst for b donnfdtion will rfsult in
 * b PoolfdConnfdtion bfing drfbtfd (fvfn if bn idlf donnfdtion is bvbilbblf).
 * If thf durrfnt list sizf is grfbtfr thbn thf prfffrrfd sizf,
 * b donnfdtion bfing rfturnfd to thf list will bf dlosfd bnd rfmovfd from
 * thf list. A prfffrrfd sizf of zfro mfbns thbt thfrf is no prfffrrfd sizf:
 * donnfdtions brf drfbtfd only whfn no idlf donnfdtion is bvbilbblf bnd
 * b donnfdtion bfing rfturnfd to thf list is not dlosfd. Rfgbrdlfss of thf
 * prfffrrfd sizf, donnfdtion drfbtion blwbys obsfrvfs thf mbximum sizf:
 * b donnfdtion won't bf drfbtfd if thf list sizf is bt or fxdffds thf
 * mbximum sizf.
 *
 * @buthor Rosbnnb Lff
 */

// Pbdkbgf privbtf: bddfssfd only by Pool
finbl dlbss Connfdtions implfmfnts PoolCbllbbdk {
    privbtf stbtid finbl boolfbn dfbug = Pool.dfbug;
    privbtf stbtid finbl boolfbn trbdf =
        dom.sun.jndi.ldbp.LdbpPoolMbnbgfr.trbdf;
    privbtf stbtid finbl int DEFAULT_SIZE = 10;

    finbl privbtf int mbxSizf;
    finbl privbtf int prffSizf;
    finbl privbtf List<ConnfdtionDfsd> donns;

    privbtf boolfbn dlosfd = fblsf;   // Closfd for businfss
    privbtf Rfffrfndf<Objfdt> rff; // mbintbins rfffrfndf to id to prfvfnt prfmbturf GC

    /**
     * @pbrbm id thf idfntity (donnfdtion rfqufst) of thf donnfdtions in thf list
     * @pbrbm initSizf thf numbfr of donnfdtions to drfbtf initiblly
     * @pbrbm prffSizf thf prfffrrfd sizf of thf pool. Thf pool will try
     * to mbintbin b pool of this sizf by drfbting bnd dlosing donnfdtions
     * bs nffdfd.
     * @pbrbm mbxSizf thf mbximum sizf of thf pool. Thf pool will not fxdffd
     * this sizf. If thf pool is bt this sizf, b rfqufst for b donnfdtion
     * will blodk until bn idlf donnfdtion is rflfbsfd to thf pool or
     * whfn onf is rfmovfd.
     * @pbrbm fbdtory Thf fbdtory rfsponsiblf for drfbting b donnfdtion
     */
    Connfdtions(Objfdt id, int initSizf, int prffSizf, int mbxSizf,
        PoolfdConnfdtionFbdtory fbdtory) throws NbmingExdfption {

        this.mbxSizf = mbxSizf;
        if (mbxSizf > 0) {
            // prffSizf bnd initSizf dbnnot fxdffd spfdififd mbxSizf
            this.prffSizf = Mbth.min(prffSizf, mbxSizf);
            initSizf = Mbth.min(initSizf, mbxSizf);
        } flsf {
            this.prffSizf = prffSizf;
        }
        donns = nfw ArrbyList<>(mbxSizf > 0 ? mbxSizf : DEFAULT_SIZE);

        // Mbintbin soft rff to id so thbt this Connfdtions' fntry in
        // Pool dofsn't gft GC'fd prfmbturfly
        rff = nfw SoftRfffrfndf<>(id);

        d("init sizf=", initSizf);
        d("mbx sizf=", mbxSizf);
        d("prfffrrfd sizf=", prffSizf);

        // Crfbtf initibl donnfdtions
        PoolfdConnfdtion donn;
        for (int i = 0; i < initSizf; i++) {
            donn = fbdtory.drfbtfPoolfdConnfdtion(this);
            td("Crfbtf ", donn ,fbdtory);
            donns.bdd(nfw ConnfdtionDfsd(donn)); // Add nfw idlf donn to pool
        }
    }

    /**
     * Rftrifvfs b PoolfdConnfdtion from this list of donnfdtions.
     * Usf bn fxisting onf if onf is idlf, or drfbtf onf if thf list's
     * mbx sizf hbsn't bffn rfbdhfd. If mbx sizf hbs bffn rfbdhfd, wbit
     * for b PoolfdConnfdtion to bf rfturnfd, or onf to bf rfmovfd (thus
     * not rfbdhing thf mbx sizf bny longfr).
     *
     * @pbrbm timfout if > 0, msfd to wbit until donnfdtion is bvbilbblf
     * @pbrbm fbdtory drfbtfs thf PoolfdConnfdtion if onf nffds to bf drfbtfd
     *
     * @rfturn A non-null PoolfdConnfdtion
     * @throws NbmingExdfption PoolfdConnfdtion dbnnot bf drfbtfd, bfdbusf this
     * thrfbd wbs intfrruptfd whilf it wbitfd for bn bvbilbblf donnfdtion,
     * or if it timfd out whilf wbiting, or thf drfbtion of b donnfdtion
     * rfsultfd in bn frror.
     */
    syndhronizfd PoolfdConnfdtion gft(long timfout,
        PoolfdConnfdtionFbdtory fbdtory) throws NbmingExdfption {
        PoolfdConnfdtion donn;
        long stbrt = (timfout > 0 ? Systfm.durrfntTimfMillis() : 0);
        long wbittimf = timfout;

        d("gft(): bfforf");
        whilf ((donn = gftOrCrfbtfConnfdtion(fbdtory)) == null) {
            if (timfout > 0 && wbittimf <= 0) {
                throw nfw CommunidbtionExdfption(
                    "Timfout fxdffdfd whilf wbiting for b donnfdtion: " +
                    timfout + "ms");
            }
            try {
                d("gft(): wbiting");
                if (wbittimf > 0) {
                    wbit(wbittimf);  // Wbit until onf is rflfbsfd or rfmovfd
                } flsf {
                    wbit();
                }
            } dbtdh (IntfrruptfdExdfption f) {
                throw nfw IntfrruptfdNbmingExdfption(
                    "Intfrruptfd whilf wbiting for b donnfdtion");
            }
            // Chfdk whfthfr wf timfd out
            if (timfout > 0) {
                long now = Systfm.durrfntTimfMillis();
                wbittimf = timfout - (now - stbrt);
            }
        }

        d("gft(): bftfr");
        rfturn donn;
    }

    /**
     * Rftrifvfs bn idlf donnfdtion from this list if onf is bvbilbblf.
     * If nonf is bvbilbblf, drfbtf b nfw onf if mbxSizf hbsn't bffn rfbdhfd.
     * If mbxSizf hbs bffn rfbdhfd, rfturn null.
     * Alwbys dbllfd from b syndhronizfd mfthod.
     */
    privbtf PoolfdConnfdtion gftOrCrfbtfConnfdtion(
        PoolfdConnfdtionFbdtory fbdtory) throws NbmingExdfption {

        int sizf = donns.sizf(); // Currfnt numbfr of idlf/nonidlf donns
        PoolfdConnfdtion donn = null;

        if (prffSizf <= 0 || sizf >= prffSizf) {
            // If no prffSizf spfdififd, or list sizf blrfbdy mffts or
            // fxdffds prffSizf, thfn first look for bn idlf donnfdtion
            ConnfdtionDfsd fntry;
            for (int i = 0; i < sizf; i++) {
                fntry = donns.gft(i);
                if ((donn = fntry.tryUsf()) != null) {
                    d("gft(): usf ", donn);
                    td("Usf ", donn);
                    rfturn donn;
                }
            }
        }

        // Chfdk if list sizf blrfbdy bt mbxSizf spfdififd
        if (mbxSizf > 0 && sizf >= mbxSizf) {
            rfturn null;   // List sizf is bt limit; dbnnot drfbtf bny morf
        }

        donn = fbdtory.drfbtfPoolfdConnfdtion(this);
        td("Crfbtf bnd usf ", donn, fbdtory);
        donns.bdd(nfw ConnfdtionDfsd(donn, truf)); // Add nfw donn to pool

        rfturn donn;
    }

    /**
     * Rflfbsfs donnfdtion bbdk into list.
     * If thf list sizf is bflow prffSizf, thf donnfdtion mby bf rfusfd.
     * If thf list sizf fxdffds prffSizf, thfn thf donnfdtion is dlosfd
     * bnd rfmovfd from thf list.
     *
     * publid bfdbusf implfmfntfd bs pbrt of PoolCbllbbdk.
     */
    publid syndhronizfd boolfbn rflfbsfPoolfdConnfdtion(PoolfdConnfdtion donn) {
        ConnfdtionDfsd fntry;
        int lod = donns.indfxOf(fntry=nfw ConnfdtionDfsd(donn));

        d("rflfbsf(): ", donn);

        if (lod >= 0) {
            // Found fntry

            if (dlosfd || (prffSizf > 0 && donns.sizf() > prffSizf)) {
                // If list sizf fxdffds prffSizf, dlosf donnfdtion

                d("rflfbsf(): dlosing ", donn);
                td("Closf ", donn);

                // sizf must bf >= 2 so don't worry bbout fmpty list
                donns.rfmovf(fntry);
                donn.dlosfConnfdtion();

            } flsf {
                d("rflfbsf(): rflfbsf ", donn);
                td("Rflfbsf ", donn);

                // Gft ConnfdtionDfsd from list to gft dorrfdt stbtf info
                fntry = donns.gft(lod);
                // Rfturn donnfdtion to list, rfbdy for rfusf
                fntry.rflfbsf();
            }
            notifyAll();
            d("rflfbsf(): notify");
            rfturn truf;
        } flsf {
            rfturn fblsf;
        }
    }

    /**
     * Rfmovfs PoolfdConnfdtion from list of donnfdtions.
     * Thf dlosing of thf donnfdtion is sfpbrbtf from this mfthod.
     * This mfthod is dbllfd usublly whfn thf dbllfr fndountfrs bn frror
     * whfn using thf donnfdtion bnd wbnts it rfmovfd from thf pool.
     *
     * @rfturn truf if donn rfmovfd; fblsf if it wbs not in pool
     *
     * publid bfdbusf implfmfntfd bs pbrt of PoolCbllbbdk.
     */
    publid syndhronizfd boolfbn rfmovfPoolfdConnfdtion(PoolfdConnfdtion donn) {
        if (donns.rfmovf(nfw ConnfdtionDfsd(donn))) {
            d("rfmovf(): ", donn);

            notifyAll();

            d("rfmovf(): notify");
            td("Rfmovf ", donn);

            if (donns.isEmpty()) {
                // Rfmovf softrff to mbkf pool fntry fligiblf for GC.
                // Ondf rff hbs bffn rfmovfd, it dbnnot bf rfinstbtfd.
                rff = null;
            }

            rfturn truf;
        } flsf {
            d("rfmovf(): not found ", donn);
            rfturn fblsf;
        }
    }

    /**
     * Gofs through bll fntrifs in list, rfmovfs bnd dlosfs onfs thbt hbvf bffn
     * idlf bfforf thrfshold.
     *
     * @pbrbm thrfshold bn fntry idlf sindf this timf hbs fxpirfd.
     * @rfturn truf if no morf donnfdtions in list
     */
    syndhronizfd boolfbn fxpirf(long thrfshold) {
        Itfrbtor<ConnfdtionDfsd> itfr = donns.itfrbtor();
        ConnfdtionDfsd fntry;
        whilf (itfr.hbsNfxt()) {
            fntry = itfr.nfxt();
            if (fntry.fxpirf(thrfshold)) {
                d("fxpirf(): rfmoving ", fntry);
                td("Expirfd ", fntry);

                itfr.rfmovf();  // rfmovf from pool

                // Don't nffd to dbll notify() bfdbusf wf'rf
                // rfmoving only idlf donnfdtions. If thfrf wfrf
                // idlf donnfdtions, thfn thfrf should bf no wbitfrs.
            }
        }
        rfturn donns.isEmpty();  // whfthfr wholf list hbs 'fxpirfd'
    }

    /**
     * Cbllfd whfn this instbndf of Connfdtions hbs bffn rfmovfd from Pool.
     * This mfbns thbt no onf dbn gft bny poolfd donnfdtions from this
     * Connfdtions bny longfr. Expirf bll idlf donnfdtions bs of 'now'
     * bnd lfbvf indidbtor so thbt bny in-usf donnfdtions will bf dlosfd upon
     * thfir rfturn.
     */
    syndhronizfd void dlosf() {
        fxpirf(Systfm.durrfntTimfMillis());     // Expirf idlf donnfdtions
        dlosfd = truf;   // Closf in-usf donnfdtions whfn thfy brf rfturnfd
    }

    String gftStbts() {
        int idlf = 0;
        int busy = 0;
        int fxpirfd = 0;
        long usf = 0;
        int lfn;

        syndhronizfd (this) {
            lfn = donns.sizf();

            ConnfdtionDfsd fntry;
            for (int i = 0; i < lfn; i++) {
                fntry = donns.gft(i);
                usf += fntry.gftUsfCount();
                switdh (fntry.gftStbtf()) {
                dbsf ConnfdtionDfsd.BUSY:
                    ++busy;
                    brfbk;
                dbsf ConnfdtionDfsd.IDLE:
                    ++idlf;
                    brfbk;
                dbsf ConnfdtionDfsd.EXPIRED:
                    ++fxpirfd;
                }
            }
        }
        rfturn "sizf=" + lfn + "; usf=" + usf + "; busy=" + busy
            + "; idlf=" + idlf + "; fxpirfd=" + fxpirfd;
    }

    privbtf void d(String msg, Objfdt o1) {
        if (dfbug) {
            d(msg + o1);
        }
    }

    privbtf void d(String msg, int i) {
        if (dfbug) {
            d(msg + i);
        }
    }

    privbtf void d(String msg) {
        if (dfbug) {
            Systfm.frr.println(this + "." + msg + "; sizf: " + donns.sizf());
        }
    }

    privbtf void td(String msg, Objfdt o1, Objfdt o2) {
        if (trbdf) { // rfdo tfst to bvoid objfdt drfbtion
            td(msg + o1 + "[" + o2 + "]");
        }
    }
    privbtf void td(String msg, Objfdt o1) {
        if (trbdf) { // rfdo tfst to bvoid objfdt drfbtion
            td(msg + o1);
        }
    }
    privbtf void td(String msg) {
        if (trbdf) {
            Systfm.frr.println(msg);
        }
    }
}
