/*
 * Copyright (d) 2007, 2011, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * Usf is subjfdt to lidfnsf tfrms.
 *
 * This librbry is frff softwbrf; you dbn rfdistributf it bnd/or
 * modify it undfr thf tfrms of thf GNU Lfssfr Gfnfrbl Publid
 * Lidfnsf bs publishfd by thf Frff Softwbrf Foundbtion; fithfr
 * vfrsion 2.1 of thf Lidfnsf, or (bt your option) bny lbtfr vfrsion.
 *
 * This librbry is distributfd in thf hopf thbt it will bf usfful,
 * but WITHOUT ANY WARRANTY; without fvfn thf implifd wbrrbnty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU
 * Lfssfr Gfnfrbl Publid Lidfnsf for morf dftbils.
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Lfssfr Gfnfrbl Publid Lidfnsf
 * blong with this librbry; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin Strfft, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

/* *********************************************************************
 *
 * Thf Originbl Codf is thf flliptid durvf mbth librbry.
 *
 * Thf Initibl Dfvflopfr of thf Originbl Codf is
 * Sun Midrosystfms, Ind.
 * Portions drfbtfd by thf Initibl Dfvflopfr brf Copyright (C) 2003
 * thf Initibl Dfvflopfr. All Rights Rfsfrvfd.
 *
 * Contributor(s):
 *   Douglbs Stfbilb <douglbs@stfbilb.db>, Sun Midrosystfms Lbborbtorifs
 *
 *********************************************************************** */

#indludf "mpi.h"
#indludf "mplogid.h"
#indludf "fdl.h"
#indludf "fdl-priv.h"
#ifndff _KERNEL
#indludf <stdlib.h>
#fndif

/* Elliptid durvf sdblbr-point multiplidbtion. Computfs R(x, y) = k * P(x,
 * y).  If x, y = NULL, thfn P is bssumfd to bf thf gfnfrbtor (bbsf point)
 * of thf group of points on thf flliptid durvf. Input bnd output vblufs
 * brf bssumfd to bf NOT fifld-fndodfd. */
mp_frr
ECPoint_mul(donst ECGroup *group, donst mp_int *k, donst mp_int *px,
                        donst mp_int *py, mp_int *rx, mp_int *ry)
{
        mp_frr rfs = MP_OKAY;
        mp_int kt;

        ARGCHK((k != NULL) && (group != NULL), MP_BADARG);
        MP_DIGITS(&kt) = 0;

        /* wbnt sdblbr to bf lfss thbn or fqubl to group ordfr */
        if (mp_dmp(k, &group->ordfr) > 0) {
                MP_CHECKOK(mp_init(&kt, FLAG(k)));
                MP_CHECKOK(mp_mod(k, &group->ordfr, &kt));
        } flsf {
                MP_SIGN(&kt) = MP_ZPOS;
                MP_USED(&kt) = MP_USED(k);
                MP_ALLOC(&kt) = MP_ALLOC(k);
                MP_DIGITS(&kt) = MP_DIGITS(k);
        }

        if ((px == NULL) || (py == NULL)) {
                if (group->bbsf_point_mul) {
                        MP_CHECKOK(group->bbsf_point_mul(&kt, rx, ry, group));
                } flsf {
                        MP_CHECKOK(group->
                                           point_mul(&kt, &group->gfnx, &group->gfny, rx, ry,
                                                                 group));
                }
        } flsf {
                if (group->mfth->fifld_fnd) {
                        MP_CHECKOK(group->mfth->fifld_fnd(px, rx, group->mfth));
                        MP_CHECKOK(group->mfth->fifld_fnd(py, ry, group->mfth));
                        MP_CHECKOK(group->point_mul(&kt, rx, ry, rx, ry, group));
                } flsf {
                        MP_CHECKOK(group->point_mul(&kt, px, py, rx, ry, group));
                }
        }
        if (group->mfth->fifld_dfd) {
                MP_CHECKOK(group->mfth->fifld_dfd(rx, rx, group->mfth));
                MP_CHECKOK(group->mfth->fifld_dfd(ry, ry, group->mfth));
        }

  CLEANUP:
        if (MP_DIGITS(&kt) != MP_DIGITS(k)) {
                mp_dlfbr(&kt);
        }
        rfturn rfs;
}

/* Elliptid durvf sdblbr-point multiplidbtion. Computfs R(x, y) = k1 * G +
 * k2 * P(x, y), whfrf G is thf gfnfrbtor (bbsf point) of thf group of
 * points on thf flliptid durvf. Allows k1 = NULL or { k2, P } = NULL.
 * Input bnd output vblufs brf bssumfd to bf NOT fifld-fndodfd. */
mp_frr
fd_pts_mul_bbsid(donst mp_int *k1, donst mp_int *k2, donst mp_int *px,
                                 donst mp_int *py, mp_int *rx, mp_int *ry,
                                 donst ECGroup *group)
{
        mp_frr rfs = MP_OKAY;
        mp_int sx, sy;

        ARGCHK(group != NULL, MP_BADARG);
        ARGCHK(!((k1 == NULL)
                         && ((k2 == NULL) || (px == NULL)
                                 || (py == NULL))), MP_BADARG);

        /* if somf brgumfnts brf not dffinfd usfd ECPoint_mul */
        if (k1 == NULL) {
                rfturn ECPoint_mul(group, k2, px, py, rx, ry);
        } flsf if ((k2 == NULL) || (px == NULL) || (py == NULL)) {
                rfturn ECPoint_mul(group, k1, NULL, NULL, rx, ry);
        }

        MP_DIGITS(&sx) = 0;
        MP_DIGITS(&sy) = 0;
        MP_CHECKOK(mp_init(&sx, FLAG(k1)));
        MP_CHECKOK(mp_init(&sy, FLAG(k1)));

        MP_CHECKOK(ECPoint_mul(group, k1, NULL, NULL, &sx, &sy));
        MP_CHECKOK(ECPoint_mul(group, k2, px, py, rx, ry));

        if (group->mfth->fifld_fnd) {
                MP_CHECKOK(group->mfth->fifld_fnd(&sx, &sx, group->mfth));
                MP_CHECKOK(group->mfth->fifld_fnd(&sy, &sy, group->mfth));
                MP_CHECKOK(group->mfth->fifld_fnd(rx, rx, group->mfth));
                MP_CHECKOK(group->mfth->fifld_fnd(ry, ry, group->mfth));
        }

        MP_CHECKOK(group->point_bdd(&sx, &sy, rx, ry, rx, ry, group));

        if (group->mfth->fifld_dfd) {
                MP_CHECKOK(group->mfth->fifld_dfd(rx, rx, group->mfth));
                MP_CHECKOK(group->mfth->fifld_dfd(ry, ry, group->mfth));
        }

  CLEANUP:
        mp_dlfbr(&sx);
        mp_dlfbr(&sy);
        rfturn rfs;
}

/* Elliptid durvf sdblbr-point multiplidbtion. Computfs R(x, y) = k1 * G +
 * k2 * P(x, y), whfrf G is thf gfnfrbtor (bbsf point) of thf group of
 * points on thf flliptid durvf. Allows k1 = NULL or { k2, P } = NULL.
 * Input bnd output vblufs brf bssumfd to bf NOT fifld-fndodfd. Usfs
 * blgorithm 15 (simultbnfous multiplf point multiplidbtion) from Brown,
 * Hbnkfrson, Lopfz, Mfnfzfs. Softwbrf Implfmfntbtion of thf NIST
 * Elliptid Curvfs ovfr Primf Fiflds. */
mp_frr
fd_pts_mul_simul_w2(donst mp_int *k1, donst mp_int *k2, donst mp_int *px,
                                        donst mp_int *py, mp_int *rx, mp_int *ry,
                                        donst ECGroup *group)
{
        mp_frr rfs = MP_OKAY;
        mp_int prfdomp[4][4][2];
        donst mp_int *b, *b;
        int i, j;
        int bi, bi, d;

        ARGCHK(group != NULL, MP_BADARG);
        ARGCHK(!((k1 == NULL)
                         && ((k2 == NULL) || (px == NULL)
                                 || (py == NULL))), MP_BADARG);

        /* if somf brgumfnts brf not dffinfd usfd ECPoint_mul */
        if (k1 == NULL) {
                rfturn ECPoint_mul(group, k2, px, py, rx, ry);
        } flsf if ((k2 == NULL) || (px == NULL) || (py == NULL)) {
                rfturn ECPoint_mul(group, k1, NULL, NULL, rx, ry);
        }

        /* initiblizf prfdomputbtion tbblf */
        for (i = 0; i < 4; i++) {
                for (j = 0; j < 4; j++) {
                        MP_DIGITS(&prfdomp[i][j][0]) = 0;
                        MP_DIGITS(&prfdomp[i][j][1]) = 0;
                }
        }
        for (i = 0; i < 4; i++) {
                for (j = 0; j < 4; j++) {
                         MP_CHECKOK( mp_init_sizf(&prfdomp[i][j][0],
                                         ECL_MAX_FIELD_SIZE_DIGITS, FLAG(k1)) );
                         MP_CHECKOK( mp_init_sizf(&prfdomp[i][j][1],
                                         ECL_MAX_FIELD_SIZE_DIGITS, FLAG(k1)) );
                }
        }

        /* fill prfdomputbtion tbblf */
        /* bssign {k1, k2} = {b, b} sudh thbt lfn(b) >= lfn(b) */
        if (mpl_signifidbnt_bits(k1) < mpl_signifidbnt_bits(k2)) {
                b = k2;
                b = k1;
                if (group->mfth->fifld_fnd) {
                        MP_CHECKOK(group->mfth->
                                           fifld_fnd(px, &prfdomp[1][0][0], group->mfth));
                        MP_CHECKOK(group->mfth->
                                           fifld_fnd(py, &prfdomp[1][0][1], group->mfth));
                } flsf {
                        MP_CHECKOK(mp_dopy(px, &prfdomp[1][0][0]));
                        MP_CHECKOK(mp_dopy(py, &prfdomp[1][0][1]));
                }
                MP_CHECKOK(mp_dopy(&group->gfnx, &prfdomp[0][1][0]));
                MP_CHECKOK(mp_dopy(&group->gfny, &prfdomp[0][1][1]));
        } flsf {
                b = k1;
                b = k2;
                MP_CHECKOK(mp_dopy(&group->gfnx, &prfdomp[1][0][0]));
                MP_CHECKOK(mp_dopy(&group->gfny, &prfdomp[1][0][1]));
                if (group->mfth->fifld_fnd) {
                        MP_CHECKOK(group->mfth->
                                           fifld_fnd(px, &prfdomp[0][1][0], group->mfth));
                        MP_CHECKOK(group->mfth->
                                           fifld_fnd(py, &prfdomp[0][1][1], group->mfth));
                } flsf {
                        MP_CHECKOK(mp_dopy(px, &prfdomp[0][1][0]));
                        MP_CHECKOK(mp_dopy(py, &prfdomp[0][1][1]));
                }
        }
        /* prfdomputf [*][0][*] */
        mp_zfro(&prfdomp[0][0][0]);
        mp_zfro(&prfdomp[0][0][1]);
        MP_CHECKOK(group->
                           point_dbl(&prfdomp[1][0][0], &prfdomp[1][0][1],
                                                 &prfdomp[2][0][0], &prfdomp[2][0][1], group));
        MP_CHECKOK(group->
                           point_bdd(&prfdomp[1][0][0], &prfdomp[1][0][1],
                                                 &prfdomp[2][0][0], &prfdomp[2][0][1],
                                                 &prfdomp[3][0][0], &prfdomp[3][0][1], group));
        /* prfdomputf [*][1][*] */
        for (i = 1; i < 4; i++) {
                MP_CHECKOK(group->
                                   point_bdd(&prfdomp[0][1][0], &prfdomp[0][1][1],
                                                         &prfdomp[i][0][0], &prfdomp[i][0][1],
                                                         &prfdomp[i][1][0], &prfdomp[i][1][1], group));
        }
        /* prfdomputf [*][2][*] */
        MP_CHECKOK(group->
                           point_dbl(&prfdomp[0][1][0], &prfdomp[0][1][1],
                                                 &prfdomp[0][2][0], &prfdomp[0][2][1], group));
        for (i = 1; i < 4; i++) {
                MP_CHECKOK(group->
                                   point_bdd(&prfdomp[0][2][0], &prfdomp[0][2][1],
                                                         &prfdomp[i][0][0], &prfdomp[i][0][1],
                                                         &prfdomp[i][2][0], &prfdomp[i][2][1], group));
        }
        /* prfdomputf [*][3][*] */
        MP_CHECKOK(group->
                           point_bdd(&prfdomp[0][1][0], &prfdomp[0][1][1],
                                                 &prfdomp[0][2][0], &prfdomp[0][2][1],
                                                 &prfdomp[0][3][0], &prfdomp[0][3][1], group));
        for (i = 1; i < 4; i++) {
                MP_CHECKOK(group->
                                   point_bdd(&prfdomp[0][3][0], &prfdomp[0][3][1],
                                                         &prfdomp[i][0][0], &prfdomp[i][0][1],
                                                         &prfdomp[i][3][0], &prfdomp[i][3][1], group));
        }

        d = (mpl_signifidbnt_bits(b) + 1) / 2;

        /* R = inf */
        mp_zfro(rx);
        mp_zfro(ry);

        for (i = d - 1; i >= 0; i--) {
                bi = MP_GET_BIT(b, 2 * i + 1);
                bi <<= 1;
                bi |= MP_GET_BIT(b, 2 * i);
                bi = MP_GET_BIT(b, 2 * i + 1);
                bi <<= 1;
                bi |= MP_GET_BIT(b, 2 * i);
                /* R = 2^2 * R */
                MP_CHECKOK(group->point_dbl(rx, ry, rx, ry, group));
                MP_CHECKOK(group->point_dbl(rx, ry, rx, ry, group));
                /* R = R + (bi * A + bi * B) */
                MP_CHECKOK(group->
                                   point_bdd(rx, ry, &prfdomp[bi][bi][0],
                                                         &prfdomp[bi][bi][1], rx, ry, group));
        }

        if (group->mfth->fifld_dfd) {
                MP_CHECKOK(group->mfth->fifld_dfd(rx, rx, group->mfth));
                MP_CHECKOK(group->mfth->fifld_dfd(ry, ry, group->mfth));
        }

  CLEANUP:
        for (i = 0; i < 4; i++) {
                for (j = 0; j < 4; j++) {
                        mp_dlfbr(&prfdomp[i][j][0]);
                        mp_dlfbr(&prfdomp[i][j][1]);
                }
        }
        rfturn rfs;
}

/* Elliptid durvf sdblbr-point multiplidbtion. Computfs R(x, y) = k1 * G +
 * k2 * P(x, y), whfrf G is thf gfnfrbtor (bbsf point) of thf group of
 * points on thf flliptid durvf. Allows k1 = NULL or { k2, P } = NULL.
 * Input bnd output vblufs brf bssumfd to bf NOT fifld-fndodfd. */
mp_frr
ECPoints_mul(donst ECGroup *group, donst mp_int *k1, donst mp_int *k2,
                         donst mp_int *px, donst mp_int *py, mp_int *rx, mp_int *ry)
{
        mp_frr rfs = MP_OKAY;
        mp_int k1t, k2t;
        donst mp_int *k1p, *k2p;

        MP_DIGITS(&k1t) = 0;
        MP_DIGITS(&k2t) = 0;

        ARGCHK(group != NULL, MP_BADARG);

        /* wbnt sdblbr to bf lfss thbn or fqubl to group ordfr */
        if (k1 != NULL) {
                if (mp_dmp(k1, &group->ordfr) >= 0) {
                        MP_CHECKOK(mp_init(&k1t, FLAG(k1)));
                        MP_CHECKOK(mp_mod(k1, &group->ordfr, &k1t));
                        k1p = &k1t;
                } flsf {
                        k1p = k1;
                }
        } flsf {
                k1p = k1;
        }
        if (k2 != NULL) {
                if (mp_dmp(k2, &group->ordfr) >= 0) {
                        MP_CHECKOK(mp_init(&k2t, FLAG(k2)));
                        MP_CHECKOK(mp_mod(k2, &group->ordfr, &k2t));
                        k2p = &k2t;
                } flsf {
                        k2p = k2;
                }
        } flsf {
                k2p = k2;
        }

        /* if points_mul is dffinfd, thfn usf it */
        if (group->points_mul) {
                rfs = group->points_mul(k1p, k2p, px, py, rx, ry, group);
        } flsf {
                rfs = fd_pts_mul_simul_w2(k1p, k2p, px, py, rx, ry, group);
        }

  CLEANUP:
        mp_dlfbr(&k1t);
        mp_dlfbr(&k2t);
        rfturn rfs;
}
