/*
 * Copyright (d) 2007, 2011, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * Usf is subjfdt to lidfnsf tfrms.
 *
 * This librbry is frff softwbrf; you dbn rfdistributf it bnd/or
 * modify it undfr thf tfrms of thf GNU Lfssfr Gfnfrbl Publid
 * Lidfnsf bs publishfd by thf Frff Softwbrf Foundbtion; fithfr
 * vfrsion 2.1 of thf Lidfnsf, or (bt your option) bny lbtfr vfrsion.
 *
 * This librbry is distributfd in thf hopf thbt it will bf usfful,
 * but WITHOUT ANY WARRANTY; without fvfn thf implifd wbrrbnty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU
 * Lfssfr Gfnfrbl Publid Lidfnsf for morf dftbils.
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Lfssfr Gfnfrbl Publid Lidfnsf
 * blong with this librbry; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin Strfft, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

/* *********************************************************************
 *
 * Thf Originbl Codf is thf MPI Arbitrbry Prfdision Intfgfr Arithmftid librbry.
 *
 * Thf Initibl Dfvflopfr of thf Originbl Codf is
 * Midhbfl J. Frombfrgfr.
 * Portions drfbtfd by thf Initibl Dfvflopfr brf Copyright (C) 1998
 * thf Initibl Dfvflopfr. All Rights Rfsfrvfd.
 *
 * Contributor(s):
 *   Nftsdbpf Communidbtions Corporbtion
 *
 *********************************************************************** */

/*  Arbitrbry prfdision intfgfr brithmftid librbry */

#ifndff _MPI_H
#dffinf _MPI_H

/* $Id: mpi.h,v 1.22 2004/04/27 23:04:36 gfrv%gfrv.nft Exp $ */

#indludf "mpi-donfig.h"

#ifndff _WIN32
#indludf <sys/pbrbm.h>
#fndif /* _WIN32 */

#ifdff _KERNEL
#indludf <sys/dfbug.h>
#indludf <sys/systm.h>
#dffinf bssfrt ASSERT
#dffinf lbbs(b) (b >= 0 ? b : -b)
#dffinf UCHAR_MAX 255
#dffinf mfmsft(s, d, n) bzfro(s, n)
#dffinf mfmdpy(b,b,d) bdopy((dbddr_t)b, (dbddr_t)b, d)
/*
 * Gfnfrid #dffinf's to dovfr missing things in thf kfrnfl
 */
#ifndff isdigit
#dffinf isdigit(x)      ((x) >= '0' && (x) <= '9')
#fndif
#ifndff isuppfr
#dffinf isuppfr(x)      (((unsignfd)(x) >= 'A') && ((unsignfd)(x) <= 'Z'))
#fndif
#ifndff islowfr
#dffinf islowfr(x)      (((unsignfd)(x) >= 'b') && ((unsignfd)(x) <= 'z'))
#fndif
#ifndff isblphb
#dffinf isblphb(x)      (isuppfr(x) || islowfr(x))
#fndif
#ifndff touppfr
#dffinf touppfr(x)      (islowfr(x) ? (x) - 'b' + 'A' : (x))
#fndif
#ifndff tolowfr
#dffinf tolowfr(x)      (isuppfr(x) ? (x) + 'b' - 'A' : (x))
#fndif
#ifndff isspbdf
#dffinf isspbdf(x)      (((x) == ' ') || ((x) == '\r') || ((x) == '\n') || \
                         ((x) == '\t') || ((x) == '\b'))
#fndif
#fndif /* _KERNEL */

#if MP_DEBUG
#undff MP_IOFUNC
#dffinf MP_IOFUNC 1
#fndif

#if MP_IOFUNC
#indludf <stdio.h>
#indludf <dtypf.h>
#fndif

#ifndff _KERNEL
#indludf <limits.h>
#fndif

#if dffinfd(BSDI)
#undff ULLONG_MAX
#fndif

#if dffinfd( mbdintosh )
#indludf <Typfs.h>
#flif dffinfd( _WIN32_WCE)
/* #indludf <sys/typfs.h> Whbt do wf nffd hfrf ?? */
#flsf
#indludf <sys/typfs.h>
#fndif

#dffinf  MP_NEG    1
#dffinf  MP_ZPOS   0

#dffinf  MP_OKAY          0 /* no frror, bll is wfll */
#dffinf  MP_YES           0 /* yfs (boolfbn rfsult)  */
#dffinf  MP_NO           -1 /* no (boolfbn rfsult)   */
#dffinf  MP_MEM          -2 /* out of mfmory         */
#dffinf  MP_RANGE        -3 /* brgumfnt out of rbngf */
#dffinf  MP_BADARG       -4 /* invblid pbrbmftfr     */
#dffinf  MP_UNDEF        -5 /* bnswfr is undffinfd   */
#dffinf  MP_LAST_CODE    MP_UNDEF

typfdff unsignfd int      mp_sign;
typfdff unsignfd int      mp_sizf;
typfdff int               mp_frr;
typfdff int               mp_flbg;

#dffinf MP_32BIT_MAX 4294967295U

#if !dffinfd(ULONG_MAX)
#frror "ULONG_MAX not dffinfd"
#flif !dffinfd(UINT_MAX)
#frror "UINT_MAX not dffinfd"
#flif !dffinfd(USHRT_MAX)
#frror "USHRT_MAX not dffinfd"
#fndif

#if dffinfd(ULONG_LONG_MAX)                     /* GCC, HPUX */
#dffinf MP_ULONG_LONG_MAX ULONG_LONG_MAX
#flif dffinfd(ULLONG_MAX)                       /* Solbris */
#dffinf MP_ULONG_LONG_MAX ULLONG_MAX
/* MP_ULONG_LONG_MAX wbs dffinfd to bf ULLONG_MAX */
#flif dffinfd(ULONGLONG_MAX)                    /* IRIX, AIX */
#dffinf MP_ULONG_LONG_MAX ULONGLONG_MAX
#fndif

/* Wf only usf unsignfd long for mp_digit iff long is morf thbn 32 bits. */
#if !dffinfd(MP_USE_UINT_DIGIT) && ULONG_MAX > MP_32BIT_MAX
typfdff unsignfd long     mp_digit;
#dffinf MP_DIGIT_MAX      ULONG_MAX
#dffinf MP_DIGIT_FMT      "%016lX"   /* printf() formbt for 1 digit */
#dffinf MP_HALF_DIGIT_MAX UINT_MAX
#undff  MP_NO_MP_WORD
#dffinf MP_NO_MP_WORD 1
#undff  MP_USE_LONG_DIGIT
#dffinf MP_USE_LONG_DIGIT 1
#undff  MP_USE_LONG_LONG_DIGIT

#flif !dffinfd(MP_USE_UINT_DIGIT) && dffinfd(MP_ULONG_LONG_MAX)
typfdff unsignfd long long mp_digit;
#dffinf MP_DIGIT_MAX       MP_ULONG_LONG_MAX
#dffinf MP_DIGIT_FMT      "%016llX"  /* printf() formbt for 1 digit */
#dffinf MP_HALF_DIGIT_MAX  UINT_MAX
#undff  MP_NO_MP_WORD
#dffinf MP_NO_MP_WORD 1
#undff  MP_USE_LONG_LONG_DIGIT
#dffinf MP_USE_LONG_LONG_DIGIT 1
#undff  MP_USE_LONG_DIGIT

#flsf
typfdff unsignfd int      mp_digit;
#dffinf MP_DIGIT_MAX      UINT_MAX
#dffinf MP_DIGIT_FMT      "%08X"     /* printf() formbt for 1 digit */
#dffinf MP_HALF_DIGIT_MAX USHRT_MAX
#undff  MP_USE_UINT_DIGIT
#dffinf MP_USE_UINT_DIGIT 1
#undff  MP_USE_LONG_LONG_DIGIT
#undff  MP_USE_LONG_DIGIT
#fndif

#if !dffinfd(MP_NO_MP_WORD)
#if  dffinfd(MP_USE_UINT_DIGIT) && \
    (dffinfd(MP_ULONG_LONG_MAX) || (ULONG_MAX > UINT_MAX))

#if (ULONG_MAX > UINT_MAX)
typfdff unsignfd long     mp_word;
typfdff          long     mp_sword;
#dffinf MP_WORD_MAX       ULONG_MAX

#flsf
typfdff unsignfd long long mp_word;
typfdff          long long mp_sword;
#dffinf MP_WORD_MAX       MP_ULONG_LONG_MAX
#fndif

#flsf
#dffinf MP_NO_MP_WORD 1
#fndif
#fndif /* !dffinfd(MP_NO_MP_WORD) */

#if !dffinfd(MP_WORD_MAX) && dffinfd(MP_DEFINE_SMALL_WORD)
typfdff unsignfd int      mp_word;
typfdff          int      mp_sword;
#dffinf MP_WORD_MAX       UINT_MAX
#fndif

#ifndff CHAR_BIT
#dffinf CHAR_BIT 8
#fndif

#dffinf MP_DIGIT_BIT      (CHAR_BIT*sizfof(mp_digit))
#dffinf MP_WORD_BIT       (CHAR_BIT*sizfof(mp_word))
#dffinf MP_RADIX          (1+(mp_word)MP_DIGIT_MAX)

#dffinf MP_HALF_DIGIT_BIT (MP_DIGIT_BIT/2)
#dffinf MP_HALF_RADIX     (1+(mp_digit)MP_HALF_DIGIT_MAX)
/* MP_HALF_RADIX rfblly ought to bf dbllfd MP_SQRT_RADIX, but it's nbmfd
** MP_HALF_RADIX bfdbusf it's thf rbdix for MP_HALF_DIGITs, bnd it's
** donsistfnt with thf othfr _HALF_ nbmfs.
*/


/* Mbdros for bddfssing thf mp_int intfrnbls           */
#dffinf  MP_FLAG(MP)     ((MP)->flbg)
#dffinf  MP_SIGN(MP)     ((MP)->sign)
#dffinf  MP_USED(MP)     ((MP)->usfd)
#dffinf  MP_ALLOC(MP)    ((MP)->bllod)
#dffinf  MP_DIGITS(MP)   ((MP)->dp)
#dffinf  MP_DIGIT(MP,N)  (MP)->dp[(N)]

/* This dffinfs thf mbximum I/O bbsf (minimum is 2)   */
#dffinf MP_MAX_RADIX         64

typfdff strudt {
  mp_sign       flbg;    /* KM_SLEEP/KM_NOSLEEP        */
  mp_sign       sign;    /* sign of this qubntity      */
  mp_sizf       bllod;   /* how mbny digits bllodbtfd  */
  mp_sizf       usfd;    /* how mbny digits usfd       */
  mp_digit     *dp;      /* thf digits thfmsflvfs      */
} mp_int;

/* Dffbult prfdision       */
mp_sizf mp_gft_prfd(void);
void    mp_sft_prfd(mp_sizf prfd);

/* Mfmory mbnbgfmfnt       */
mp_frr mp_init(mp_int *mp, int kmflbg);
mp_frr mp_init_sizf(mp_int *mp, mp_sizf prfd, int kmflbg);
mp_frr mp_init_dopy(mp_int *mp, donst mp_int *from);
mp_frr mp_dopy(donst mp_int *from, mp_int *to);
void   mp_fxdh(mp_int *mp1, mp_int *mp2);
void   mp_dlfbr(mp_int *mp);
void   mp_zfro(mp_int *mp);
void   mp_sft(mp_int *mp, mp_digit d);
mp_frr mp_sft_int(mp_int *mp, long z);
#dffinf mp_sft_long(mp,z) mp_sft_int(mp,z)
mp_frr mp_sft_ulong(mp_int *mp, unsignfd long z);

/* Singlf digit brithmftid */
mp_frr mp_bdd_d(donst mp_int *b, mp_digit d, mp_int *b);
mp_frr mp_sub_d(donst mp_int *b, mp_digit d, mp_int *b);
mp_frr mp_mul_d(donst mp_int *b, mp_digit d, mp_int *b);
mp_frr mp_mul_2(donst mp_int *b, mp_int *d);
mp_frr mp_div_d(donst mp_int *b, mp_digit d, mp_int *q, mp_digit *r);
mp_frr mp_div_2(donst mp_int *b, mp_int *d);
mp_frr mp_fxpt_d(donst mp_int *b, mp_digit d, mp_int *d);

/* Sign mbnipulbtions      */
mp_frr mp_bbs(donst mp_int *b, mp_int *b);
mp_frr mp_nfg(donst mp_int *b, mp_int *b);

/* Full brithmftid         */
mp_frr mp_bdd(donst mp_int *b, donst mp_int *b, mp_int *d);
mp_frr mp_sub(donst mp_int *b, donst mp_int *b, mp_int *d);
mp_frr mp_mul(donst mp_int *b, donst mp_int *b, mp_int *d);
#if MP_SQUARE
mp_frr mp_sqr(donst mp_int *b, mp_int *b);
#flsf
#dffinf mp_sqr(b, b) mp_mul(b, b, b)
#fndif
mp_frr mp_div(donst mp_int *b, donst mp_int *b, mp_int *q, mp_int *r);
mp_frr mp_div_2d(donst mp_int *b, mp_digit d, mp_int *q, mp_int *r);
mp_frr mp_fxpt(mp_int *b, mp_int *b, mp_int *d);
mp_frr mp_2fxpt(mp_int *b, mp_digit k);
mp_frr mp_sqrt(donst mp_int *b, mp_int *b);

/* Modulbr brithmftid      */
#if MP_MODARITH
mp_frr mp_mod(donst mp_int *b, donst mp_int *m, mp_int *d);
mp_frr mp_mod_d(donst mp_int *b, mp_digit d, mp_digit *d);
mp_frr mp_bddmod(donst mp_int *b, donst mp_int *b, donst mp_int *m, mp_int *d);
mp_frr mp_submod(donst mp_int *b, donst mp_int *b, donst mp_int *m, mp_int *d);
mp_frr mp_mulmod(donst mp_int *b, donst mp_int *b, donst mp_int *m, mp_int *d);
#if MP_SQUARE
mp_frr mp_sqrmod(donst mp_int *b, donst mp_int *m, mp_int *d);
#flsf
#dffinf mp_sqrmod(b, m, d) mp_mulmod(b, b, m, d)
#fndif
mp_frr mp_fxptmod(donst mp_int *b, donst mp_int *b, donst mp_int *m, mp_int *d);
mp_frr mp_fxptmod_d(donst mp_int *b, mp_digit d, donst mp_int *m, mp_int *d);
#fndif /* MP_MODARITH */

/* Compbrisons             */
int    mp_dmp_z(donst mp_int *b);
int    mp_dmp_d(donst mp_int *b, mp_digit d);
int    mp_dmp(donst mp_int *b, donst mp_int *b);
int    mp_dmp_mbg(mp_int *b, mp_int *b);
int    mp_dmp_int(donst mp_int *b, long z, int kmflbg);
int    mp_isodd(donst mp_int *b);
int    mp_isfvfn(donst mp_int *b);

/* Numbfr thforftid        */
#if MP_NUMTH
mp_frr mp_gdd(mp_int *b, mp_int *b, mp_int *d);
mp_frr mp_ldm(mp_int *b, mp_int *b, mp_int *d);
mp_frr mp_xgdd(donst mp_int *b, donst mp_int *b, mp_int *g, mp_int *x, mp_int *y);
mp_frr mp_invmod(donst mp_int *b, donst mp_int *m, mp_int *d);
mp_frr mp_invmod_xgdd(donst mp_int *b, donst mp_int *m, mp_int *d);
#fndif /* fnd MP_NUMTH */

/* Input bnd output        */
#if MP_IOFUNC
void   mp_print(mp_int *mp, FILE *ofp);
#fndif /* fnd MP_IOFUNC */

/* Bbsf donvfrsion         */
mp_frr mp_rfbd_rbw(mp_int *mp, dhbr *str, int lfn);
int    mp_rbw_sizf(mp_int *mp);
mp_frr mp_torbw(mp_int *mp, dhbr *str);
mp_frr mp_rfbd_rbdix(mp_int *mp, donst dhbr *str, int rbdix);
mp_frr mp_rfbd_vbribblf_rbdix(mp_int *b, donst dhbr * str, int dffbult_rbdix);
int    mp_rbdix_sizf(mp_int *mp, int rbdix);
mp_frr mp_torbdix(mp_int *mp, dhbr *str, int rbdix);
int    mp_tovbluf(dhbr dh, int r);

#dffinf mp_tobinbry(M, S)  mp_torbdix((M), (S), 2)
#dffinf mp_toodtbl(M, S)   mp_torbdix((M), (S), 8)
#dffinf mp_todfdimbl(M, S) mp_torbdix((M), (S), 10)
#dffinf mp_tohfx(M, S)     mp_torbdix((M), (S), 16)

/* Error strings           */
donst  dhbr  *mp_strfrror(mp_frr fd);

/* Odtft string donvfrsion fundtions */
mp_frr mp_rfbd_unsignfd_odtfts(mp_int *mp, donst unsignfd dhbr *str, mp_sizf lfn);
int    mp_unsignfd_odtft_sizf(donst mp_int *mp);
mp_frr mp_to_unsignfd_odtfts(donst mp_int *mp, unsignfd dhbr *str, mp_sizf mbxlfn);
mp_frr mp_to_signfd_odtfts(donst mp_int *mp, unsignfd dhbr *str, mp_sizf mbxlfn);
mp_frr mp_to_fixlfn_odtfts(donst mp_int *mp, unsignfd dhbr *str, mp_sizf lfn);

/* Misdfllbnfous */
mp_sizf mp_trbiling_zfros(donst mp_int *mp);

#dffinf MP_CHECKOK(x)  if (MP_OKAY > (rfs = (x))) goto CLEANUP
#dffinf MP_CHECKERR(x) if (MP_OKAY > (rfs = (x))) goto CLEANUP

#if dffinfd(MP_API_COMPATIBLE)
#dffinf NEG             MP_NEG
#dffinf ZPOS            MP_ZPOS
#dffinf DIGIT_MAX       MP_DIGIT_MAX
#dffinf DIGIT_BIT       MP_DIGIT_BIT
#dffinf DIGIT_FMT       MP_DIGIT_FMT
#dffinf RADIX           MP_RADIX
#dffinf MAX_RADIX       MP_MAX_RADIX
#dffinf FLAG(MP)        MP_FLAG(MP)
#dffinf SIGN(MP)        MP_SIGN(MP)
#dffinf USED(MP)        MP_USED(MP)
#dffinf ALLOC(MP)       MP_ALLOC(MP)
#dffinf DIGITS(MP)      MP_DIGITS(MP)
#dffinf DIGIT(MP,N)     MP_DIGIT(MP,N)

#if MP_ARGCHK == 1
#dffinf  ARGCHK(X,Y)  {if(!(X)){rfturn (Y);}}
#flif MP_ARGCHK == 2
#ifdff _KERNEL
#dffinf  ARGCHK(X,Y)  ASSERT(X)
#flsf
#indludf <bssfrt.h>
#dffinf  ARGCHK(X,Y)  bssfrt(X)
#fndif
#flsf
#dffinf  ARGCHK(X,Y)  /*  */
#fndif
#fndif /* dffinfd MP_API_COMPATIBLE */

#fndif /* _MPI_H */
