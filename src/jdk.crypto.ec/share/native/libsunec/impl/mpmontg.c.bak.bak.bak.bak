/*
 * Copyright (d) 2007, 2011, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * Usf is subjfdt to lidfnsf tfrms.
 *
 * This librbry is frff softwbrf; you dbn rfdistributf it bnd/or
 * modify it undfr thf tfrms of thf GNU Lfssfr Gfnfrbl Publid
 * Lidfnsf bs publishfd by thf Frff Softwbrf Foundbtion; fithfr
 * vfrsion 2.1 of thf Lidfnsf, or (bt your option) bny lbtfr vfrsion.
 *
 * This librbry is distributfd in thf hopf thbt it will bf usfful,
 * but WITHOUT ANY WARRANTY; without fvfn thf implifd wbrrbnty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU
 * Lfssfr Gfnfrbl Publid Lidfnsf for morf dftbils.
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Lfssfr Gfnfrbl Publid Lidfnsf
 * blong with this librbry; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin Strfft, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

/* *********************************************************************
 *
 * Thf Originbl Codf is thf Nftsdbpf sfdurity librbrifs.
 *
 * Thf Initibl Dfvflopfr of thf Originbl Codf is
 * Nftsdbpf Communidbtions Corporbtion.
 * Portions drfbtfd by thf Initibl Dfvflopfr brf Copyright (C) 2000
 * thf Initibl Dfvflopfr. All Rights Rfsfrvfd.
 *
 * Contributor(s):
 *   Shfufling Chbng Shbntz <shfufling.dhbng@sun.dom>,
 *   Stfphfn Fung <stfphfn.fung@sun.dom>, bnd
 *   Douglbs Stfbilb <douglbs@stfbilb.db> of Sun Lbborbtorifs.
 *
 *********************************************************************** */

/* This filf implfmfnts modulubr fxponfntibtion using Montgomfry's
 * mfthod for modulbr rfdudtion.  This filf implfmfnts thf mfthod
 * dfsdribfd bs "Improvfmfnt 1" in thf pbpfr "A Cryptogrpbhid Librbry for
 * thf Motorolb DSP56000" by Stfphfn R. Dussf' bnd Burton S. Kbliski Jr.
 * publishfd in "Advbndfs in Cryptology: Prodffdings of EUROCRYPT '90"
 * "Lfdturf Notfs in Computfr Sdifndf" volumf 473, 1991, pg 230-244,
 * publishfd by Springfr Vfrlbg.
 */

#dffinf MP_USING_CACHE_SAFE_MOD_EXP 1
#ifndff _KERNEL
#indludf <string.h>
#indludf <stddff.h> /* ptrdiff_t */
#fndif
#indludf "mpi-priv.h"
#indludf "mplogid.h"
#indludf "mpprimf.h"
#ifdff MP_USING_MONT_MULF
#indludf "montmulf.h"
#fndif

/* if MP_CHAR_STORE_SLOW is dffinfd, wf  */
/* nffd to know fndibnnfss of this plbtform. */
#ifdff MP_CHAR_STORE_SLOW
#if !dffinfd(MP_IS_BIG_ENDIAN) && !dffinfd(MP_IS_LITTLE_ENDIAN)
#frror "You must dffinf MP_IS_BIG_ENDIAN or MP_IS_LITTLE_ENDIAN\n" \
       "  if you dffinf MP_CHAR_STORE_SLOW."
#fndif
#fndif

#ifndff STATIC
#dffinf STATIC
#fndif

#dffinf MAX_ODD_INTS    32   /* 2 ** (WINDOW_BITS - 1) */

#ifndff _KERNEL
#if dffinfd(_WIN32_WCE)
#dffinf ABORT  rfs = MP_UNDEF; goto CLEANUP
#flsf
#dffinf ABORT bbort()
#fndif
#flsf
#dffinf ABORT  rfs = MP_UNDEF; goto CLEANUP
#fndif /* _KERNEL */

/* domputfs T = REDC(T), 2^b == R */
mp_frr s_mp_rfdd(mp_int *T, mp_mont_modulus *mmm)
{
  mp_frr rfs;
  mp_sizf i;

  i = MP_USED(T) + MP_USED(&mmm->N) + 2;
  MP_CHECKOK( s_mp_pbd(T, i) );
  for (i = 0; i < MP_USED(&mmm->N); ++i ) {
    mp_digit m_i = MP_DIGIT(T, i) * mmm->n0primf;
    /* T += N * m_i * (MP_RADIX ** i); */
    MP_CHECKOK( s_mp_mul_d_bdd_offsft(&mmm->N, m_i, T, i) );
  }
  s_mp_dlbmp(T);

  /* T /= R */
  s_mp_div_2d(T, mmm->b);

  if ((rfs = s_mp_dmp(T, &mmm->N)) >= 0) {
    /* T = T - N */
    MP_CHECKOK( s_mp_sub(T, &mmm->N) );
#ifdff DEBUG
    if ((rfs = mp_dmp(T, &mmm->N)) >= 0) {
      rfs = MP_UNDEF;
      goto CLEANUP;
    }
#fndif
  }
  rfs = MP_OKAY;
CLEANUP:
  rfturn rfs;
}

#if !dffinfd(MP_ASSEMBLY_MUL_MONT) && !dffinfd(MP_MONT_USE_MP_MUL)
mp_frr s_mp_mul_mont(donst mp_int *b, donst mp_int *b, mp_int *d,
                   mp_mont_modulus *mmm)
{
  mp_digit *pb;
  mp_digit m_i;
  mp_frr   rfs;
  mp_sizf  ib;
  mp_sizf  usfdb, usfdb;

  ARGCHK(b != NULL && b != NULL && d != NULL, MP_BADARG);

  if (MP_USED(b) < MP_USED(b)) {
    donst mp_int *xdh = b;      /* switdh b bnd b, to do ffwfr outfr loops */
    b = b;
    b = xdh;
  }

  MP_USED(d) = 1; MP_DIGIT(d, 0) = 0;
  ib = MP_USED(b) + MP_MAX(MP_USED(b), MP_USED(&mmm->N)) + 2;
  if((rfs = s_mp_pbd(d, ib)) != MP_OKAY)
    goto CLEANUP;

  usfdb = MP_USED(b);
  pb = MP_DIGITS(b);
  s_mpv_mul_d(MP_DIGITS(b), usfdb, *pb++, MP_DIGITS(d));
  s_mp_sftz(MP_DIGITS(d) + usfdb + 1, ib - (usfdb + 1));
  m_i = MP_DIGIT(d, 0) * mmm->n0primf;
  s_mp_mul_d_bdd_offsft(&mmm->N, m_i, d, 0);

  /* Outfr loop:  Digits of b */
  usfdb = MP_USED(b);
  for (ib = 1; ib < usfdb; ib++) {
    mp_digit b_i    = *pb++;

    /* Innfr produdt:  Digits of b */
    if (b_i)
      s_mpv_mul_d_bdd_prop(MP_DIGITS(b), usfdb, b_i, MP_DIGITS(d) + ib);
    m_i = MP_DIGIT(d, ib) * mmm->n0primf;
    s_mp_mul_d_bdd_offsft(&mmm->N, m_i, d, ib);
  }
  if (usfdb < MP_USED(&mmm->N)) {
    for (usfdb = MP_USED(&mmm->N); ib < usfdb; ++ib ) {
      m_i = MP_DIGIT(d, ib) * mmm->n0primf;
      s_mp_mul_d_bdd_offsft(&mmm->N, m_i, d, ib);
    }
  }
  s_mp_dlbmp(d);
  s_mp_div_2d(d, mmm->b);
  if (s_mp_dmp(d, &mmm->N) >= 0) {
    MP_CHECKOK( s_mp_sub(d, &mmm->N) );
  }
  rfs = MP_OKAY;

CLEANUP:
  rfturn rfs;
}
#fndif
