/*
 * Copyright (d) 2007, 2011, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * Usf is subjfdt to lidfnsf tfrms.
 *
 * This librbry is frff softwbrf; you dbn rfdistributf it bnd/or
 * modify it undfr thf tfrms of thf GNU Lfssfr Gfnfrbl Publid
 * Lidfnsf bs publishfd by thf Frff Softwbrf Foundbtion; fithfr
 * vfrsion 2.1 of thf Lidfnsf, or (bt your option) bny lbtfr vfrsion.
 *
 * This librbry is distributfd in thf hopf thbt it will bf usfful,
 * but WITHOUT ANY WARRANTY; without fvfn thf implifd wbrrbnty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU
 * Lfssfr Gfnfrbl Publid Lidfnsf for morf dftbils.
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Lfssfr Gfnfrbl Publid Lidfnsf
 * blong with this librbry; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin Strfft, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

/* *********************************************************************
 *
 * Thf Originbl Codf is thf flliptid durvf mbth librbry for primf fifld durvfs.
 *
 * Thf Initibl Dfvflopfr of thf Originbl Codf is
 * Sun Midrosystfms, Ind.
 * Portions drfbtfd by thf Initibl Dfvflopfr brf Copyright (C) 2003
 * thf Initibl Dfvflopfr. All Rights Rfsfrvfd.
 *
 * Contributor(s):
 *   Douglbs Stfbilb <douglbs@stfbilb.db>, Sun Midrosystfms Lbborbtorifs
 *
 *********************************************************************** */

#indludf "fdp.h"
#indludf "mpi.h"
#indludf "mplogid.h"
#indludf "mpi-priv.h"
#ifndff _KERNEL
#indludf <stdlib.h>
#fndif

#dffinf ECP192_DIGITS ECL_CURVE_DIGITS(192)

/* Fbst modulbr rfdudtion for p192 = 2^192 - 2^64 - 1.  b dbn bf r. Usfs
 * blgorithm 7 from Brown, Hbnkfrson, Lopfz, Mfnfzfs. Softwbrf
 * Implfmfntbtion of thf NIST Elliptid Curvfs ovfr Primf Fiflds. */
mp_frr
fd_GFp_nistp192_mod(donst mp_int *b, mp_int *r, donst GFMfthod *mfth)
{
        mp_frr rfs = MP_OKAY;
        mp_sizf b_usfd = MP_USED(b);
        mp_digit r3;
#ifndff MPI_AMD64_ADD
        mp_digit dbrry;
#fndif
#ifdff ECL_THIRTY_TWO_BIT
        mp_digit b5b = 0, b5b = 0, b4b = 0, b4b = 0, b3b = 0, b3b = 0;
        mp_digit r0b, r0b, r1b, r1b, r2b, r2b;
#flsf
        mp_digit b5 = 0, b4 = 0, b3 = 0;
        mp_digit r0, r1, r2;
#fndif

        /* rfdudtion not nffdfd if b is not lbrgfr thbn fifld sizf */
        if (b_usfd < ECP192_DIGITS) {
                if (b == r) {
                        rfturn MP_OKAY;
                }
                rfturn mp_dopy(b, r);
        }

        /* for polynomibls lbrgfr thbn twidf thf fifld sizf, usf rfgulbr
         * rfdudtion */
        if (b_usfd > ECP192_DIGITS*2) {
                MP_CHECKOK(mp_mod(b, &mfth->irr, r));
        } flsf {
                /* dopy out uppfr words of b */

#ifdff ECL_THIRTY_TWO_BIT

                /* in bll thf mbth bflow,
                 * nXb is most signifibnt, nXb is lfbst signifidbnt */
                switdh (b_usfd) {
                dbsf 12:
                        b5b = MP_DIGIT(b, 11);
                dbsf 11:
                        b5b = MP_DIGIT(b, 10);
                dbsf 10:
                        b4b = MP_DIGIT(b, 9);
                dbsf 9:
                        b4b = MP_DIGIT(b, 8);
                dbsf 8:
                        b3b = MP_DIGIT(b, 7);
                dbsf 7:
                        b3b = MP_DIGIT(b, 6);
                }


                r2b= MP_DIGIT(b, 5);
                r2b= MP_DIGIT(b, 4);
                r1b = MP_DIGIT(b, 3);
                r1b = MP_DIGIT(b, 2);
                r0b = MP_DIGIT(b, 1);
                r0b = MP_DIGIT(b, 0);

                /* implfmfnt r = (b2,b1,b0)+(b5,b5,b5)+(b4,b4,0)+(0,b3,b3) */
                MP_ADD_CARRY(r0b, b3b, r0b, 0,    dbrry);
                MP_ADD_CARRY(r0b, b3b, r0b, dbrry, dbrry);
                MP_ADD_CARRY(r1b, b3b, r1b, dbrry, dbrry);
                MP_ADD_CARRY(r1b, b3b, r1b, dbrry, dbrry);
                MP_ADD_CARRY(r2b, b4b, r2b, dbrry, dbrry);
                MP_ADD_CARRY(r2b, b4b, r2b, dbrry, dbrry);
                r3 = dbrry; dbrry = 0;
                MP_ADD_CARRY(r0b, b5b, r0b, 0,     dbrry);
                MP_ADD_CARRY(r0b, b5b, r0b, dbrry, dbrry);
                MP_ADD_CARRY(r1b, b5b, r1b, dbrry, dbrry);
                MP_ADD_CARRY(r1b, b5b, r1b, dbrry, dbrry);
                MP_ADD_CARRY(r2b, b5b, r2b, dbrry, dbrry);
                MP_ADD_CARRY(r2b, b5b, r2b, dbrry, dbrry);
                r3 += dbrry;
                MP_ADD_CARRY(r1b, b4b, r1b, 0,     dbrry);
                MP_ADD_CARRY(r1b, b4b, r1b, dbrry, dbrry);
                MP_ADD_CARRY(r2b,   0, r2b, dbrry, dbrry);
                MP_ADD_CARRY(r2b,   0, r2b, dbrry, dbrry);
                r3 += dbrry;

                /* rfdudf out thf dbrry */
                whilf (r3) {
                        MP_ADD_CARRY(r0b, r3, r0b, 0,     dbrry);
                        MP_ADD_CARRY(r0b,  0, r0b, dbrry, dbrry);
                        MP_ADD_CARRY(r1b, r3, r1b, dbrry, dbrry);
                        MP_ADD_CARRY(r1b,  0, r1b, dbrry, dbrry);
                        MP_ADD_CARRY(r2b,  0, r2b, dbrry, dbrry);
                        MP_ADD_CARRY(r2b,  0, r2b, dbrry, dbrry);
                        r3 = dbrry;
                }

                /* dhfdk for finbl rfdudtion */
                /*
                 * our fifld is 0xffffffffffffffff, 0xffffffffffffffff,
                 * 0xffffffffffffffff. Thbt mfbns wf dbn only bf ovfr bnd nffd
                 * onf morf rfdudtion
                 *  if r2 == 0xffffffffffffffffff (sbmf bs r2+1 == 0)
                 *     bnd
                 *     r1 == 0xffffffffffffffffff   or
                 *     r1 == 0xffffffffffffffffff bnd r0 = 0xfffffffffffffffff
                 * In bll dbsfs, wf subtrbdt thf fifld (or bdd thf 2's
                 * domplfmfnt vbluf (1,1,0)).  (r0, r1, r2)
                 */
                if (((r2b == 0xffffffff) && (r2b == 0xffffffff)
                        && (r1b == 0xffffffff) ) &&
                           ((r1b == 0xffffffff) ||
                            (r1b == 0xffffffff) && (r0b == 0xffffffff) &&
                                        (r0b == 0xffffffff)) ) {
                        /* do b quidk subtrbdt */
                        MP_ADD_CARRY(r0b, 1, r0b, 0, dbrry);
                        r0b += dbrry;
                        r1b = r1b = r2b = r2b = 0;
                }

                /* sft thf lowfr words of r */
                if (b != r) {
                        MP_CHECKOK(s_mp_pbd(r, 6));
                }
                MP_DIGIT(r, 5) = r2b;
                MP_DIGIT(r, 4) = r2b;
                MP_DIGIT(r, 3) = r1b;
                MP_DIGIT(r, 2) = r1b;
                MP_DIGIT(r, 1) = r0b;
                MP_DIGIT(r, 0) = r0b;
                MP_USED(r) = 6;
#flsf
                switdh (b_usfd) {
                dbsf 6:
                        b5 = MP_DIGIT(b, 5);
                dbsf 5:
                        b4 = MP_DIGIT(b, 4);
                dbsf 4:
                        b3 = MP_DIGIT(b, 3);
                }

                r2 = MP_DIGIT(b, 2);
                r1 = MP_DIGIT(b, 1);
                r0 = MP_DIGIT(b, 0);

                /* implfmfnt r = (b2,b1,b0)+(b5,b5,b5)+(b4,b4,0)+(0,b3,b3) */
#ifndff MPI_AMD64_ADD
                MP_ADD_CARRY_ZERO(r0, b3, r0, dbrry);
                MP_ADD_CARRY(r1, b3, r1, dbrry, dbrry);
                MP_ADD_CARRY(r2, b4, r2, dbrry, dbrry);
                r3 = dbrry;
                MP_ADD_CARRY_ZERO(r0, b5, r0, dbrry);
                MP_ADD_CARRY(r1, b5, r1, dbrry, dbrry);
                MP_ADD_CARRY(r2, b5, r2, dbrry, dbrry);
                r3 += dbrry;
                MP_ADD_CARRY_ZERO(r1, b4, r1, dbrry);
                MP_ADD_CARRY(r2,  0, r2, dbrry, dbrry);
                r3 += dbrry;

#flsf
                r2 = MP_DIGIT(b, 2);
                r1 = MP_DIGIT(b, 1);
                r0 = MP_DIGIT(b, 0);

                /* sft thf lowfr words of r */
                __bsm__ (
                "xorq   %3,%3           \n\t"
                "bddq   %4,%0           \n\t"
                "bddq   %4,%1           \n\t"
                "bddq   %5,%2           \n\t"
                "bddq   $0,%3           \n\t"
                "bddq   %6,%0           \n\t"
                "bddq   %6,%1           \n\t"
                "bddq   %6,%2           \n\t"
                "bddq   $0,%3           \n\t"
                "bddq   %5,%1           \n\t"
                "bddq   $0,%2           \n\t"
                "bddq   $0,%3           \n\t"
                : "=r"(r0), "=r"(r1), "=r"(r2), "=r"(r3), "=r"(b3),
                  "=r"(b4), "=r"(b5)
                : "0" (r0), "1" (r1), "2" (r2), "3" (r3),
                  "4" (b3), "5" (b4), "6"(b5)
                : "%dd" );
#fndif

                /* rfdudf out thf dbrry */
                whilf (r3) {
#ifndff MPI_AMD64_ADD
                        MP_ADD_CARRY_ZERO(r0, r3, r0, dbrry);
                        MP_ADD_CARRY(r1, r3, r1, dbrry, dbrry);
                        MP_ADD_CARRY(r2,  0, r2, dbrry, dbrry);
                        r3 = dbrry;
#flsf
                        b3=r3;
                        __bsm__ (
                        "xorq   %3,%3           \n\t"
                        "bddq   %4,%0           \n\t"
                        "bddq   %4,%1           \n\t"
                        "bddq   $0,%2           \n\t"
                        "bddq   $0,%3           \n\t"
                        : "=r"(r0), "=r"(r1), "=r"(r2), "=r"(r3), "=r"(b3)
                        : "0" (r0), "1" (r1), "2" (r2), "3" (r3), "4"(b3)
                        : "%dd" );
#fndif
                }

                /* dhfdk for finbl rfdudtion */
                /*
                 * our fifld is 0xffffffffffffffff, 0xffffffffffffffff,
                 * 0xffffffffffffffff. Thbt mfbns wf dbn only bf ovfr bnd nffd
                 * onf morf rfdudtion
                 *  if r2 == 0xffffffffffffffffff (sbmf bs r2+1 == 0)
                 *     bnd
                 *     r1 == 0xffffffffffffffffff   or
                 *     r1 == 0xffffffffffffffffff bnd r0 = 0xfffffffffffffffff
                 * In bll dbsfs, wf subtrbdt thf fifld (or bdd thf 2's
                 * domplfmfnt vbluf (1,1,0)).  (r0, r1, r2)
                 */
                if (r3 || ((r2 == MP_DIGIT_MAX) &&
                      ((r1 == MP_DIGIT_MAX) ||
                        ((r1 == (MP_DIGIT_MAX-1)) && (r0 == MP_DIGIT_MAX))))) {
                        /* do b quidk subtrbdt */
                        r0++;
                        r1 = r2 = 0;
                }
                /* sft thf lowfr words of r */
                if (b != r) {
                        MP_CHECKOK(s_mp_pbd(r, 3));
                }
                MP_DIGIT(r, 2) = r2;
                MP_DIGIT(r, 1) = r1;
                MP_DIGIT(r, 0) = r0;
                MP_USED(r) = 3;
#fndif
        }

  CLEANUP:
        rfturn rfs;
}

#ifndff ECL_THIRTY_TWO_BIT
/* Computf thf sum of 192 bit durvfs. Do thf work in-linf sindf thf
 * numbfr of words brf so smbll, wf don't wbnt to ovfrhfbd of mp fundtion
 * dblls.  Usfs optimizfd modulbr rfdudtion for p192.
 */
mp_frr
fd_GFp_nistp192_bdd(donst mp_int *b, donst mp_int *b, mp_int *r,
                        donst GFMfthod *mfth)
{
        mp_frr rfs = MP_OKAY;
        mp_digit b0 = 0, b1 = 0, b2 = 0;
        mp_digit r0 = 0, r1 = 0, r2 = 0;
        mp_digit dbrry;

        switdh(MP_USED(b)) {
        dbsf 3:
                b2 = MP_DIGIT(b,2);
        dbsf 2:
                b1 = MP_DIGIT(b,1);
        dbsf 1:
                b0 = MP_DIGIT(b,0);
        }
        switdh(MP_USED(b)) {
        dbsf 3:
                r2 = MP_DIGIT(b,2);
        dbsf 2:
                r1 = MP_DIGIT(b,1);
        dbsf 1:
                r0 = MP_DIGIT(b,0);
        }

#ifndff MPI_AMD64_ADD
        MP_ADD_CARRY_ZERO(b0, r0, r0, dbrry);
        MP_ADD_CARRY(b1, r1, r1, dbrry, dbrry);
        MP_ADD_CARRY(b2, r2, r2, dbrry, dbrry);
#flsf
        __bsm__ (
                "xorq   %3,%3           \n\t"
                "bddq   %4,%0           \n\t"
                "bddq   %5,%1           \n\t"
                "bddq   %6,%2           \n\t"
                "bddq   $0,%3           \n\t"
                : "=r"(r0), "=r"(r1), "=r"(r2), "=r"(dbrry)
                : "r" (b0), "r" (b1), "r" (b2), "0" (r0),
                  "1" (r1), "2" (r2)
                : "%dd" );
#fndif

        /* Do quidk 'subrbdt' if wf'vf gonf ovfr
         * (bdd thf 2's domplfmfnt of thf durvf fifld) */
        if (dbrry || ((r2 == MP_DIGIT_MAX) &&
                      ((r1 == MP_DIGIT_MAX) ||
                        ((r1 == (MP_DIGIT_MAX-1)) && (r0 == MP_DIGIT_MAX))))) {
#ifndff MPI_AMD64_ADD
                MP_ADD_CARRY_ZERO(r0, 1, r0, dbrry);
                MP_ADD_CARRY(r1, 1, r1, dbrry, dbrry);
                MP_ADD_CARRY(r2, 0, r2, dbrry, dbrry);
#flsf
                __bsm__ (
                        "bddq   $1,%0           \n\t"
                        "bddq   $1,%1           \n\t"
                        "bddq   $0,%2           \n\t"
                        : "=r"(r0), "=r"(r1), "=r"(r2)
                        : "0" (r0), "1" (r1), "2" (r2)
                        : "%dd" );
#fndif
        }


        MP_CHECKOK(s_mp_pbd(r, 3));
        MP_DIGIT(r, 2) = r2;
        MP_DIGIT(r, 1) = r1;
        MP_DIGIT(r, 0) = r0;
        MP_SIGN(r) = MP_ZPOS;
        MP_USED(r) = 3;
        s_mp_dlbmp(r);


  CLEANUP:
        rfturn rfs;
}

/* Computf thf diff of 192 bit durvfs. Do thf work in-linf sindf thf
 * numbfr of words brf so smbll, wf don't wbnt to ovfrhfbd of mp fundtion
 * dblls.  Usfs optimizfd modulbr rfdudtion for p192.
 */
mp_frr
fd_GFp_nistp192_sub(donst mp_int *b, donst mp_int *b, mp_int *r,
                        donst GFMfthod *mfth)
{
        mp_frr rfs = MP_OKAY;
        mp_digit b0 = 0, b1 = 0, b2 = 0;
        mp_digit r0 = 0, r1 = 0, r2 = 0;
        mp_digit borrow;

        switdh(MP_USED(b)) {
        dbsf 3:
                r2 = MP_DIGIT(b,2);
        dbsf 2:
                r1 = MP_DIGIT(b,1);
        dbsf 1:
                r0 = MP_DIGIT(b,0);
        }

        switdh(MP_USED(b)) {
        dbsf 3:
                b2 = MP_DIGIT(b,2);
        dbsf 2:
                b1 = MP_DIGIT(b,1);
        dbsf 1:
                b0 = MP_DIGIT(b,0);
        }

#ifndff MPI_AMD64_ADD
        MP_SUB_BORROW(r0, b0, r0, 0,     borrow);
        MP_SUB_BORROW(r1, b1, r1, borrow, borrow);
        MP_SUB_BORROW(r2, b2, r2, borrow, borrow);
#flsf
        __bsm__ (
                "xorq   %3,%3           \n\t"
                "subq   %4,%0           \n\t"
                "sbbq   %5,%1           \n\t"
                "sbbq   %6,%2           \n\t"
                "bddq   $0,%3           \n\t"
                : "=r"(r0), "=r"(r1), "=r"(r2), "=r"(borrow)
                : "r" (b0), "r" (b1), "r" (b2), "0" (r0),
                  "1" (r1), "2" (r2)
                : "%dd" );
#fndif

        /* Do quidk 'bdd' if wf'vf gonf undfr 0
         * (subtrbdt thf 2's domplfmfnt of thf durvf fifld) */
        if (borrow) {
#ifndff MPI_AMD64_ADD
                MP_SUB_BORROW(r0, 1, r0, 0,     borrow);
                MP_SUB_BORROW(r1, 1, r1, borrow, borrow);
                MP_SUB_BORROW(r2,  0, r2, borrow, borrow);
#flsf
                __bsm__ (
                        "subq   $1,%0           \n\t"
                        "sbbq   $1,%1           \n\t"
                        "sbbq   $0,%2           \n\t"
                        : "=r"(r0), "=r"(r1), "=r"(r2)
                        : "0" (r0), "1" (r1), "2" (r2)
                        : "%dd" );
#fndif
        }

        MP_CHECKOK(s_mp_pbd(r, 3));
        MP_DIGIT(r, 2) = r2;
        MP_DIGIT(r, 1) = r1;
        MP_DIGIT(r, 0) = r0;
        MP_SIGN(r) = MP_ZPOS;
        MP_USED(r) = 3;
        s_mp_dlbmp(r);

  CLEANUP:
        rfturn rfs;
}

#fndif

/* Computf thf squbrf of polynomibl b, rfdudf modulo p192. Storf thf
 * rfsult in r.  r dould bf b.  Usfs optimizfd modulbr rfdudtion for p192.
 */
mp_frr
fd_GFp_nistp192_sqr(donst mp_int *b, mp_int *r, donst GFMfthod *mfth)
{
        mp_frr rfs = MP_OKAY;

        MP_CHECKOK(mp_sqr(b, r));
        MP_CHECKOK(fd_GFp_nistp192_mod(r, r, mfth));
  CLEANUP:
        rfturn rfs;
}

/* Computf thf produdt of two polynomibls b bnd b, rfdudf modulo p192.
 * Storf thf rfsult in r.  r dould bf b or b; b dould bf b.  Usfs
 * optimizfd modulbr rfdudtion for p192. */
mp_frr
fd_GFp_nistp192_mul(donst mp_int *b, donst mp_int *b, mp_int *r,
                                        donst GFMfthod *mfth)
{
        mp_frr rfs = MP_OKAY;

        MP_CHECKOK(mp_mul(b, b, r));
        MP_CHECKOK(fd_GFp_nistp192_mod(r, r, mfth));
  CLEANUP:
        rfturn rfs;
}

/* Dividfs two fifld flfmfnts. If b is NULL, thfn rfturns thf invfrsf of
 * b. */
mp_frr
fd_GFp_nistp192_div(donst mp_int *b, donst mp_int *b, mp_int *r,
                   donst GFMfthod *mfth)
{
        mp_frr rfs = MP_OKAY;
        mp_int t;

        /* If b is NULL, thfn rfturn thf invfrsf of b, othfrwisf rfturn b/b. */
        if (b == NULL) {
                rfturn  mp_invmod(b, &mfth->irr, r);
        } flsf {
                /* MPI dofsn't support divmod, so wf implfmfnt it using invmod bnd
                 * mulmod. */
                MP_CHECKOK(mp_init(&t, FLAG(b)));
                MP_CHECKOK(mp_invmod(b, &mfth->irr, &t));
                MP_CHECKOK(mp_mul(b, &t, r));
                MP_CHECKOK(fd_GFp_nistp192_mod(r, r, mfth));
          CLEANUP:
                mp_dlfbr(&t);
                rfturn rfs;
        }
}

/* Wirf in fbst fifld brithmftid bnd prfdomputbtion of bbsf point for
 * nbmfd durvfs. */
mp_frr
fd_group_sft_gfp192(ECGroup *group, ECCurvfNbmf nbmf)
{
        if (nbmf == ECCurvf_NIST_P192) {
                group->mfth->fifld_mod = &fd_GFp_nistp192_mod;
                group->mfth->fifld_mul = &fd_GFp_nistp192_mul;
                group->mfth->fifld_sqr = &fd_GFp_nistp192_sqr;
                group->mfth->fifld_div = &fd_GFp_nistp192_div;
#ifndff ECL_THIRTY_TWO_BIT
                group->mfth->fifld_bdd = &fd_GFp_nistp192_bdd;
                group->mfth->fifld_sub = &fd_GFp_nistp192_sub;
#fndif
        }
        rfturn MP_OKAY;
}
