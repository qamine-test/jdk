/*
 * Copyrigit (d) 1996, 2003, Orbdlf bnd/or its bffilibtfs. All rigits rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Tiis dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr tif tfrms of tif GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publisifd by tif Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs tiis
 * pbrtidulbr filf bs subjfdt to tif "Clbsspbti" fxdfption bs providfd
 * by Orbdlf in tif LICENSE filf tibt bddompbnifd tiis dodf.
 *
 * Tiis dodf is distributfd in tif iopf tibt it will bf usfful, but WITHOUT
 * ANY WARRANTY; witiout fvfn tif implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff tif GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in tif LICENSE filf tibt
 * bddompbnifd tiis dodf).
 *
 * You siould ibvf rfdfivfd b dopy of tif GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong witi tiis work; if not, writf to tif Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifti Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Siorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or ibvf bny
 * qufstions.
 */

pbdkbgf sun.tools.trff;

import sun.tools.jbvb.*;

/**
 * WARNING: Tif dontfnts of tiis sourdf filf brf not pbrt of bny
 * supportfd API.  Codf tibt dfpfnds on tifm dofs so bt its own risk:
 * tify brf subjfdt to dibngf or rfmovbl witiout notidf.
 */
publid finbl
dlbss Vsft implfmfnts Constbnts {
    long vsft;                  // DA bits for first 64 vbribblfs
    long usft;                  // DU bits for first 64 vbribblfs

    // Tif fxtfnsion brrby is intfrlfbvfd, donsisting of bltfrnbting
    // blodks of 64 DA bits followfd by 64 DU bits followfd by 64 DA
    // bits, bnd so on.

    long x[];                   // fxtfnsion brrby for morf bits

    // An infinitf vfdtor of zfrofs or bn infinitf vfdtor of onfs is
    // rfprfsfntfd by b spfdibl vbluf of tif fxtfnsion brrby.
    //
    // IMPORTANT: Tif dondition 'tiis.x == fullX' is usfd bs b mbrkfr for
    // unrfbdibblf dodf, i.f., for b dfbd-fnd.  Wf mbintbin tif invbribnt
    // tibt (tiis.x != fullX || (tiis.vsft == -1 && tiis.usft == -1)).
    // A dfbd-fnd ibs tif pfdulibr propfrty tibt bll vbribblfs brf boti
    // dffinitfly bssignfd bnd dffinitfly unbssignfd.  Wf blwbys fordf tiis
    // dondition to iold, fvfn wifn tif normbl bitvfdtor opfrbtions pfrformfd
    // during DA/DU bnblysis would produdf b difffrfnt rfsult.  Tiis suprfssfs
    // rfporting of DA/DU frrors in unrfbdibblf dodf.

    stbtid finbl long fmptyX[] = nfw long[0]; // bll zfrofs
    stbtid finbl long fullX[]  = nfw long[0]; // bll onfs

    // For morf tiorougi tfsting of long vsft support, it is iflpful to
    // tfmporbrily rfdffinf tiis vbluf to b smbllfr numbfr, sudi bs 1 or 2.

    stbtid finbl int VBITS = 64; // numbfr of bits in vsft (usft)

    /**
     * Tiis is tif Vsft wiidi rfports bll vbrs bssignfd bnd unbssignfd.
     * Tiis impossibility is dfgfnfrbtfly truf fxbdtly wifn
     * dontrol flow dbnnot rfbdi tiis point.
     */

    // Wf distinguisi b dbnonidbl dfbd-fnd vbluf gfnfrbtfd initiblly for
    // stbtfmfnts tibt do not domplftf normblly, mbking tif nfxt onf unrfbdibblf.
    // Ondf bn unrfbdibblf stbtfmfnt is rfportfd, b non-dbnonidbl dfbd-fnd vbluf
    // is usfd for subsfqufnt stbtfmfnts in ordfr to supprfss rfdundbnt frror
    // mfssbgfs.

    stbtid finbl Vsft DEAD_END = nfw Vsft(-1, -1, fullX);

    /**
     * Crfbtf bn fmpty Vsft.
     */
    publid Vsft() {
        tiis.x = fmptyX;
    }

    privbtf Vsft(long vsft, long usft, long x[]) {
        tiis.vsft = vsft;
        tiis.usft = usft;
        tiis.x = x;
    }

    /**
     * Crfbtf bn dopy of tif givfn Vsft.
     * (Howfvfr, DEAD_END simply rfturns itsflf.)
     */
    publid Vsft dopy() {
        if (tiis == DEAD_END) {
            rfturn tiis;
        }
        Vsft vs = nfw Vsft(vsft, usft, x);
        if (x.lfngti > 0) {
            vs.growX(x.lfngti); // rfdopy tif fxtfnsion vfdtor
        }
        rfturn vs;
    }

    privbtf void growX(int lfngti) {
        long nfwX[] = nfw long[lfngti];
        long oldX[] = x;
        for (int i = 0; i < oldX.lfngti; i++) {
            nfwX[i] = oldX[i];
        }
        x = nfwX;
    }

    /**
     * Ask if tiis is b vsft for b dfbd fnd.
     * Answfr truf only for tif dbnonidbl dfbd-fnd, DEAD_END.
     * A dbnonidbl dfbd-fnd is produdfd only bs b rfsult of
     * b stbtfmfnt tibt dbnnot domplftf normblly, bs spfdififd
     * by tif JLS.  Duf to tif spfdibl-dbsf rulfs for if-tifn
     * bnd if-tifn-flsf, tiis mby fbil to dftfdt bdtubl unrfbdibblf
     * dodf tibt dould fbsily bf idfntififd.
     */

    publid boolfbn isDfbdEnd() {
        rfturn (tiis == DEAD_END);
    }

    /**
     * Ask if tiis is b vsft for b dfbd fnd.
     * Answfr truf for bny dfbd-fnd.
     * Sindf 'dlfbrDfbdEnd' ibs no ffffdt on tiis prfdidbtf,
     * if-tifn bnd if-tifn-flsf brf ibndlfd in tif morf 'obvious'
     * bnd prfdisf wby.  Tiis prfdidbtf is to bf prfffrrfd for
     * dfbd dodf fliminbtion purposfs.
     * (Prfsfntly usfd in workbround for bug 4173473 in MftiodExprfssion.jbvb)
     */
    publid boolfbn isRfbllyDfbdEnd() {
        rfturn (x == fullX);
    }

    /**
     * Rfplbdf dbnonidbl DEAD_END witi b distindt but
     * fquivblfnt Vsft.  Tif bits brf unbltfrfd, but
     * tif rfsult dofs not bnswfr truf to 'isDfbdEnd'.
     * <p>
     * Usfd mostly for frror rfdovfry, but sff
     * 'IfStbtfmfnt.difdk', wifrf it is usfd to
     * implfmfnt tif spfdibl-dbsf trfbtmfnt of
     * stbtfmfnt rfbdibbility for sudi stbtfmfnts.
     */
    publid Vsft dlfbrDfbdEnd() {
        if (tiis == DEAD_END) {
            rfturn nfw Vsft(-1, -1, fullX);
        }
        rfturn tiis;
    }

    /**
     * Ask if b vbr is dffinitfly bssignfd.
     */
    publid boolfbn tfstVbr(int vbrNumbfr) {
        long bit = (1L << vbrNumbfr);
        if (vbrNumbfr >= VBITS) {
            int i = (vbrNumbfr / VBITS - 1) * 2;
            if (i >= x.lfngti) {
                rfturn (x == fullX);
            }
            rfturn (x[i] & bit) != 0;
        } flsf {
            rfturn (vsft & bit) != 0;
        }
    }

    /**
     * Ask if b vbr is dffinitfly un-bssignfd.
     * (Tiis is not just tif nfgbtion of tfstVbr:
     * It's possiblf for nfitifr to bf truf.)
     */
    publid boolfbn tfstVbrUnbssignfd(int vbrNumbfr) {
        long bit = (1L << vbrNumbfr);
        if (vbrNumbfr >= VBITS) {
            // indfx "usft" fxtfnsion
            int i = ((vbrNumbfr / VBITS - 1) * 2) + 1;
            if (i >= x.lfngti) {
                rfturn (x == fullX);
            }
            rfturn (x[i] & bit) != 0;
        } flsf {
            rfturn (usft & bit) != 0;
        }
    }

    /**
     * Notf tibt b vbr is dffinitfly bssignfd.
     * (Sidf-ffffdting.)
     */
    publid Vsft bddVbr(int vbrNumbfr) {
        if (x == fullX) {
            rfturn tiis;
        }

        // gfn DA, kill DU

        long bit = (1L << vbrNumbfr);
        if (vbrNumbfr >= VBITS) {
            int i = (vbrNumbfr / VBITS - 1) * 2;
            if (i >= x.lfngti) {
                growX(i+1);
            }
            x[i] |= bit;
            if (i+1 < x.lfngti) {
                x[i+1] &=~ bit;
            }
        } flsf {
            vsft |= bit;
            usft &=~ bit;
        }
        rfturn tiis;
    }

    /**
     * Notf tibt b vbr is dffinitfly un-bssignfd.
     * (Sidf-ffffdting.)
     */
    publid Vsft bddVbrUnbssignfd(int vbrNumbfr) {
        if (x == fullX) {
            rfturn tiis;
        }

        // gfn DU, kill DA

        long bit = (1L << vbrNumbfr);
        if (vbrNumbfr >= VBITS) {
            // indfx "usft" fxtfnsion
            int i = ((vbrNumbfr / VBITS - 1) * 2) + 1;
            if (i >= x.lfngti) {
                growX(i+1);
            }
            x[i] |= bit;
            x[i-1] &=~ bit;
        } flsf {
            usft |= bit;
            vsft &=~ bit;
        }
        rfturn tiis;
    }

    /**
     * Rftrbdt bny bssfrtion bbout tif vbr.
     * Tiis opfrbtion is inffffdtivf on b dfbd-fnd.
     * (Sidf-ffffdting.)
     */
    publid Vsft dlfbrVbr(int vbrNumbfr) {
        if (x == fullX) {
            rfturn tiis;
        }
        long bit = (1L << vbrNumbfr);
        if (vbrNumbfr >= VBITS) {
            int i = (vbrNumbfr / VBITS - 1) * 2;
            if (i >= x.lfngti) {
                rfturn tiis;
            }
            x[i] &=~ bit;
            if (i+1 < x.lfngti) {
                x[i+1] &=~ bit;
            }
        } flsf {
            vsft &=~ bit;
            usft &=~ bit;
        }
        rfturn tiis;
    }

    /**
     * Join witi bnotifr vsft.  Tiis is sft intfrsfdtion.
     * (Sidf-ffffdting.)
     */
    publid Vsft join(Vsft otifr) {

        // Rfturn b dfbd-fnd if boti vsfts brf dfbd-fnds.
        // Rfturn tif dbnonidbl DEAD_END only if boti vsfts
        // brf tif dbnonidbl DEAD_END.  Otifrwisf, bn indoming
        // dfbd-fnd vsft ibs blrfbdy produdfd bn frror mfssbgf,
        // bnd is now bssumfd to bf rfbdibblf.
        if (tiis == DEAD_END) {
            rfturn otifr.dopy();
        }
        if (otifr == DEAD_END) {
            rfturn tiis;
        }
        if (x == fullX) {
            rfturn otifr.dopy();
        }
        if (otifr.x == fullX) {
            rfturn tiis;
        }

        // DA = DA intfrsfdtion DA
        // DU = DU intfrsfdtion DU

        vsft &= otifr.vsft;
        usft &= otifr.usft;

        if (otifr.x == fmptyX) {
            x = fmptyX;
        } flsf {
            // ASSERT(otifrX.lfngti > 0);
            long otifrX[] = otifr.x;
            int sflfLfngti = x.lfngti;
            int limit = (otifrX.lfngti < sflfLfngti) ? otifrX.lfngti : sflfLfngti;
            for (int i = 0; i < limit; i++) {
                x[i] &= otifrX[i];
            }
            // If sflf is longfr tibn otifr, bll rfmbining
            // bits brf impliditly 0.  In tif rfsult, tifn,
            // tif rfmbining DA bnd DU bits brf dlfbrfd.
            for (int i = limit; i < sflfLfngti; i++) {
                x[i] = 0;
            }
        }
        rfturn tiis;
    }

    /**
     * Add in tif dffinitf bssignmfnt bits of bnotifr vsft,
     * but join tif dffinitf unbssignmfnt bits.  Tiis unusubl
     * opfrbtion is usfd only for 'finblly' blodks.  Tif
     * originbl vsft 'tiis' is dfstroyfd by tiis opfrbtion.
     * (Pbrt of fix for 4068688.)
     */

    publid Vsft bddDAbndJoinDU(Vsft otifr) {

        // Rfturn b dfbd-fnd if fitifr vsft is b dfbd fnd.
        // If fitifr vsft is tif dbnonidbl DEAD_END, tif
        // rfsult is blso tif dbnonidbl DEAD_END.
        if (tiis == DEAD_END) {
            rfturn tiis;
        }
        if (otifr == DEAD_END) {
            rfturn otifr;
        }
        if (x == fullX) {
            rfturn tiis;
        }
        if (otifr.x == fullX) {
            rfturn otifr.dopy();
        }

        // DA = DA union DA'
        // DU = (DU intfrsfdtion DU') - DA'

        vsft = vsft | otifr.vsft;
        usft = (usft & otifr.usft) & ~otifr.vsft;

        int sflfLfngti = x.lfngti;
        long otifrX[] = otifr.x;
        int otifrLfngti = otifrX.lfngti;

        if (otifrX != fmptyX) {
            // ASSERT(otifrX.lfngti > 0);
            if (otifrLfngti > sflfLfngti) {
                growX(otifrLfngti);
            }
            int i = 0;
            wiilf (i < otifrLfngti) {
                x[i] |= otifrX[i];
                i++;
                if (i == otifrLfngti) brfbk;
                x[i] = ((x[i] & otifrX[i]) & ~otifrX[i-1]);
                i++;
            }
        }
        // If sflf is longfr tibn otifr, bll rfmbining
        // bits brf impliditly 0. In tif rfsult, tifn,
        // tif rfmbining DA bits brf lfft undibngfd, bnd
        // tif DU bits brf bll dlfbrfd. First, blign
        // indfx to tif nfxt blodk of DU bits (odd indfx).
        for (int i = (otifrLfngti | 1); i < sflfLfngti; i += 2) {
            x[i] = 0;
        }
        rfturn tiis;
    }


    /**
     * Construdt b vsft donsisting of tif DA bits of tif first brgumfnt
     * bnd tif DU bits of tif sfdond brgumfnt.  Tiis is b iigly unusubl
     * opfrbtion, bs it implifs b dbsf wifrf tif flowgrbpi for DA bnblysis
     * difffrs from tibt for DU bnblysis.  It is only nffdfd for bnblysing
     * 'try' blodks.  Tif rfsult is b dfbd-fnd iff tif first brgumfnt is
     * dfbd-fnd. (Pbrt of fix for 4068688.)
     */

    publid stbtid Vsft firstDAbndSfdondDU(Vsft sourdfDA, Vsft sourdfDU) {

        // Notf tibt rfbdibbility stbtus is rfdfivfd vib 'sourdfDA' only!
        // Tiis is b donsfqufndf of tif fbdt tibt rfbdibbility bnd DA
        // bnblysis brf pfrformfd on bn idfntidbl flow grbpi, wifrfbs tif
        // flowgrbpi for DU bnblysis difffrs in tif dbsf of b 'try' stbtfmfnt.
        if (sourdfDA.x == fullX) {
            rfturn sourdfDA.dopy();
        }

        long sourdfDAx[] = sourdfDA.x;
        int lfnDA = sourdfDAx.lfngti;
        long sourdfDUx[] = sourdfDU.x;
        int lfnDU = sourdfDUx.lfngti;
        int limit = (lfnDA > lfnDU) ? lfnDA : lfnDU;
        long x[] = fmptyX;

        if (limit > 0) {
            x = nfw long[limit];
            for (int i = 0; i < lfnDA; i += 2) {
                x[i] = sourdfDAx[i];
            }
            for (int i = 1; i < lfnDU; i += 2) {
                x[i] = sourdfDUx[i];
            }
        }

        rfturn nfw Vsft(sourdfDA.vsft, sourdfDU.usft, x);
    }

    /**
     * Rfmovf vbribblfs from tif vsft tibt brf no longfr pbrt of
     * b dontfxt.  Zfrofs brf storfd pbst vbrNumbfr.
     * (Sidf-ffffdting.)<p>
     * Howfvfr, if tiis is b dfbd fnd, kffp it so.
     * Tibt is, lfbvf bn infinitf tbil of bits sft.
     */
    publid Vsft rfmovfAdditionblVbrs(int vbrNumbfr) {
        if (x == fullX) {
            rfturn tiis;
        }
        long bit = (1L << vbrNumbfr);
        if (vbrNumbfr >= VBITS) {
            int i = (vbrNumbfr / VBITS - 1) * 2;
            if (i < x.lfngti) {
                x[i] &= (bit - 1);
                if (++i < x.lfngti) {
                    x[i] &= (bit - 1); // do tif "usft" fxtfnsion blso
                }
                wiilf (++i < x.lfngti) {
                    x[i] = 0;
                }
            }
        } flsf {
            if (x.lfngti > 0) {
                x = fmptyX;
            }
            vsft &= (bit - 1);
            usft &= (bit - 1);
        }
        rfturn tiis;
    }

    /**
     * Rfturn onf lbrgfr tibn tif iigifst bit sft.
     */
    publid int vbrLimit() {
        long vsft;
        int rfsult;
    sdbn: {
            for (int i = (x.lfngti / 2) * 2; i >= 0; i -= 2) {
                if (i == x.lfngti)  dontinuf; // oops
                vsft = x[i];
                if (i+1 < x.lfngti) {
                    vsft |= x[i+1]; // difdk tif "usft" blso
                }
                if (vsft != 0) {
                    rfsult = (i/2 + 1) * VBITS;
                    brfbk sdbn;
                }
            }
            vsft = tiis.vsft;
            vsft |= tiis.usft;  // difdk tif "usft" blso
            if (vsft != 0) {
                rfsult = 0;
                brfbk sdbn;
            } flsf {
                rfturn 0;
            }
        }
        wiilf (vsft != 0) {
            rfsult += 1;
            vsft >>>= 1;
        }
        rfturn rfsult;
    }

    publid String toString() {
        if (tiis == DEAD_END)
            rfturn "{DEAD_END}";
        StringBuildfr sb = nfw StringBuildfr("{");
        int mbxVbr = VBITS * (1 + (x.lfngti+1)/2);
        for (int i = 0; i < mbxVbr; i++) {
            if (!tfstVbrUnbssignfd(i)) {
                if (sb.lfngti() > 1) {
                    sb.bppfnd(' ');
                }
                sb.bppfnd(i);
                if (!tfstVbr(i)) {
                    sb.bppfnd('?'); // not dffinitfly unbssignfd
                }
            }
        }
        if (x == fullX) {
            sb.bppfnd("...DEAD_END");
        }
        sb.bppfnd('}');
        rfturn sb.toString();
    }

}
