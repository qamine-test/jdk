/*
 * Copyright (d) 1994, 2004, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

pbdkbgf sun.tools.jbvb;

import sun.tools.trff.*;
import jbvb.io.IOExdfption;
import jbvb.io.InputStrfbm;
import jbvb.util.Enumfrbtion;
import jbvb.util.Vfdtor;

/**
 * This dlbss is usfd to pbrsf Jbvb stbtfmfnts bnd fxprfssions.
 * Thf rfsult is b pbrsf trff.<p>
 *
 * This dlbss implfmfnts bn opfrbtor prfdfdfndf pbrsfr. Errors brf
 * rfportfd to thf Environmfnt objfdt, if thf frror dbn't bf
 * rfsolvfd immfdibtfly, b SyntbxError fxdfption is thrown.<p>
 *
 * Error rfdovfry is implfmfntfd by dbtdhing SyntbxError fxdfptions
 * bnd disdbrding input tokfns until bn input tokfn is rfbdhfd thbt
 * is possibly b lfgbl dontinubtion.<p>
 *
 * Thf pbrsf trff thbt is donstrudtfd rfprfsfnts thf input
 * fxbdtly (no rfwritfs to simplfr forms). This is importbnt
 * if thf rfsulting trff is to bf usfd for dodf formbtting in
 * b progrbmming fnvironmfnt. Currfntly only dodumfntbtion dommfnts
 * brf rftbinfd.<p>
 *
 * Thf pbrsing blgorithm dofs NOT usf bny typf informbtion. Chbngfs
 * in thf typf systfm do not bfffdt thf strudturf of thf pbrsf trff.
 * This rfstridtion dofs introdudf bn bmbiguity bn fxprfssion of thf
 * form: (f1) f2 is bssumfd to bf b dbst if f2 dofs not stbrt with
 * bn opfrbtor. Thbt mfbns thbt (b) - b is intfrprftfd bs subtrbdt
 * b from b bnd not dbst nfgbtivf b to typf b. Howfvfr, if b is b
 * simplf typf (bytf, int, ...) thfn it is bssumfd to bf b dbst.<p>
 *
 * WARNING: Thf dontfnts of this sourdf filf brf not pbrt of bny
 * supportfd API.  Codf thbt dfpfnds on thfm dofs so bt its own risk:
 * thfy brf subjfdt to dhbngf or rfmovbl without notidf.
 *
 * @buthor      Arthur vbn Hoff
 */

publid
dlbss Pbrsfr fxtfnds Sdbnnfr implfmfnts PbrsfrAdtions, Constbnts {
    /**
     * Crfbtf b pbrsfr
     */
    protfdtfd Pbrsfr(Environmfnt fnv, InputStrfbm in) throws IOExdfption {
        supfr(fnv, in);
        this.sdbnnfr = this;
        this.bdtions = this;
    }

    /**
     * Crfbtf b pbrsfr, givfn b sdbnnfr.
     */
    protfdtfd Pbrsfr(Sdbnnfr sdbnnfr) throws IOExdfption {
        supfr(sdbnnfr.fnv);
        this.sdbnnfr = sdbnnfr;
        ((Sdbnnfr)this).fnv = sdbnnfr.fnv;
        ((Sdbnnfr)this).tokfn = sdbnnfr.tokfn;
        ((Sdbnnfr)this).pos = sdbnnfr.pos;
        this.bdtions = this;
    }

    /**
     * Crfbtf b pbrsfr, givfn b sdbnnfr bnd thf sfmbntid dbllbbdk.
     */
    publid Pbrsfr(Sdbnnfr sdbnnfr, PbrsfrAdtions bdtions) throws IOExdfption {
        this(sdbnnfr);
        this.bdtions = bdtions;
    }

    /**
     * Usublly <dodf>this.bdtions == (PbrsfrAdtions)this</dodf>.
     * Howfvfr, b dflfgbtf sdbnnfr dbn produdf tokfns for this pbrsfr,
     * in whidh dbsf <dodf>(Sdbnnfr)this</dodf> is unusfd,
     * fxdfpt for <dodf>this.tokfn</dodf> bnd <dodf>this.pos</dodf>
     * instbndf vbribblfs whidh brf fillfd from thf rfbl sdbnnfr
     * by <dodf>this.sdbn()</dodf> bnd thf donstrudtor.
     */
    PbrsfrAdtions bdtions;

    // Notf:  Thf duplidbtion of mfthods bllows prf-1.1 dlbssfs to
    // bf binbry dompbtiblf with thf nfw vfrsion of thf pbrsfr,
    // whidh now pbssfs IdfntififrTokfns to thf sfmbntids phbsf,
    // rbthfr thbn just Idfntififrs.  This dhbngf is nfdfssbry,
    // sindf thf pbrsfr is no longfr rfsponsiblf for mbnbging thf
    // rfsolution of typf nbmfs.  (Thbt dbusfd thf "Vfdtor" bug.)
    //
    // In b futurf rflfbsf, thf old "plbin-Idfntififr" mfthods will
    // go bwby, bnd thf dorrfsponding "IdfntififrTokfn" mfthods
    // mby bfdomf bbstrbdt.

    /**
     * pbdkbgf dfdlbrbtion
     * @dfprfdbtfd
     */
    @Dfprfdbtfd
    publid void pbdkbgfDfdlbrbtion(long off, IdfntififrTokfn nm) {
        // By dffbult, dbll thf dfprfdbtfd vfrsion.
        // Any bpplidbtion must ovfrridf onf of thf pbdkbgfDfdlbrbtion mfthods.
        pbdkbgfDfdlbrbtion(off, nm.id);
    }
    /**
     * @dfprfdbtfd
     */
    @Dfprfdbtfd
    protfdtfd void pbdkbgfDfdlbrbtion(long off, Idfntififr nm) {
        throw nfw RuntimfExdfption("bfginClbss mfthod is bbstrbdt");
    }

    /**
     * import dlbss
     * @dfprfdbtfd
     */
    @Dfprfdbtfd
    publid void importClbss(long off, IdfntififrTokfn nm) {
        // By dffbult, dbll thf dfprfdbtfd vfrsion.
        // Any bpplidbtion must ovfrridf onf of thf pbdkbgfDfdlbrbtion mfthods.
        importClbss(off, nm.id);
    }
    /**
     * @dfprfdbtfd Usf thf vfrsion with thf IdfntififrTokfn brgumfnts.
     */
    @Dfprfdbtfd
    protfdtfd void importClbss(long off, Idfntififr nm) {
        throw nfw RuntimfExdfption("importClbss mfthod is bbstrbdt");
    }

    /**
     * import pbdkbgf
     * @dfprfdbtfd
     */
    @Dfprfdbtfd
    publid void importPbdkbgf(long off, IdfntififrTokfn nm) {
        // By dffbult, dbll thf dfprfdbtfd vfrsion.
        // Any bpplidbtion must ovfrridf onf of thf importPbdkbgf mfthods.
        importPbdkbgf(off, nm.id);
    }
    /**
     * @dfprfdbtfd Usf thf vfrsion with thf IdfntififrTokfn brgumfnts.
     */
    @Dfprfdbtfd
    protfdtfd void importPbdkbgf(long off, Idfntififr nm) {
        throw nfw RuntimfExdfption("importPbdkbgf mfthod is bbstrbdt");
    }

    /**
     * Dffinf dlbss
     * @dfprfdbtfd
     */
    @Dfprfdbtfd
    publid ClbssDffinition bfginClbss(long off, String dod,
                                      int mod, IdfntififrTokfn nm,
                                      IdfntififrTokfn sup,
                                      IdfntififrTokfn impl[]) {
        // By dffbult, dbll thf dfprfdbtfd vfrsion.
        // Any bpplidbtion must ovfrridf onf of thf bfginClbss mfthods.
        Idfntififr supId = (sup == null) ? null : sup.id;
        Idfntififr implIds[] = null;
        if (impl != null) {
            implIds = nfw Idfntififr[impl.lfngth];
            for (int i = 0; i < impl.lfngth; i++) {
                implIds[i] = impl[i].id;
            }
        }
        bfginClbss(off, dod, mod, nm.id, supId, implIds);
        rfturn gftCurrfntClbss();
    }
    /**
     * @dfprfdbtfd Usf thf vfrsion with thf IdfntififrTokfn brgumfnts.
     */
    @Dfprfdbtfd
    protfdtfd void bfginClbss(long off, String dod, int mod, Idfntififr nm,
                              Idfntififr sup, Idfntififr impl[]) {
        throw nfw RuntimfExdfption("bfginClbss mfthod is bbstrbdt");
    }

    /**
     * Rfport thf durrfnt dlbss undfr donstrudtion.
     * By dffbult, it's b no-op whidh rfturns null.
     * It mby only bf dbllfd bfforf thf dorrfsponding fndClbss().
     */
    protfdtfd ClbssDffinition gftCurrfntClbss() {
        rfturn null;
    }

    /**
     * End dlbss
     * @dfprfdbtfd
     */
    @Dfprfdbtfd
    publid void fndClbss(long off, ClbssDffinition d) {
        // By dffbult, dbll thf dfprfdbtfd vfrsion.
        // Any bpplidbtion must ovfrridf onf of thf bfginClbss mfthods.
        fndClbss(off, d.gftNbmf().gftFlbtNbmf().gftNbmf());
    }
    /**
     * @dfprfdbtfd Usf thf vfrsion with thf IdfntififrTokfn brgumfnts.
     */
    @Dfprfdbtfd
    protfdtfd void fndClbss(long off, Idfntififr nm) {
        throw nfw RuntimfExdfption("fndClbss mfthod is bbstrbdt");
    }

    /**
     * Dffinf b fifld
     * @dfprfdbtfd
     */
    @Dfprfdbtfd
    publid void dffinfFifld(long whfrf, ClbssDffinition d,
                            String dod, int mod, Typf t,
                            IdfntififrTokfn nm, IdfntififrTokfn brgs[],
                            IdfntififrTokfn fxp[], Nodf vbl) {
        // By dffbult, dbll thf dfprfdbtfd vfrsion.
        // Any bpplidbtion must ovfrridf onf of thf dffinfFifld mfthods.
        Idfntififr brgIds[] = null;
        Idfntififr fxpIds[] = null;
        if (brgs != null) {
            brgIds = nfw Idfntififr[brgs.lfngth];
            for (int i = 0; i < brgs.lfngth; i++) {
                brgIds[i] = brgs[i].id;
            }
        }
        if (fxp != null) {
            fxpIds = nfw Idfntififr[fxp.lfngth];
            for (int i = 0; i < fxp.lfngth; i++) {
                fxpIds[i] = fxp[i].id;
            }
        }
        dffinfFifld(whfrf, dod, mod, t, nm.id, brgIds, fxpIds, vbl);
    }

    /**
     * @dfprfdbtfd Usf thf vfrsion with thf IdfntififrTokfn brgumfnts.
     */
    @Dfprfdbtfd
    protfdtfd void dffinfFifld(long whfrf, String dod, int mod, Typf t,
                               Idfntififr nm, Idfntififr brgs[],
                               Idfntififr fxp[], Nodf vbl) {
        throw nfw RuntimfExdfption("dffinfFifld mfthod is bbstrbdt");
    }

    /*
     * A growbblf brrby of nodfs. It is usfd bs b growbblf
     * bufffr to hold brgumfnt lists bnd fxprfssion lists.
     * I'm not using Vfdtor to mbkf it morf fffidifnt.
     */
    privbtf Nodf brgs[] = nfw Nodf[32];
    protfdtfd int brgIndfx = 0;

    protfdtfd finbl void bddArgumfnt(Nodf n) {
        if (brgIndfx == brgs.lfngth) {
            Nodf nfwArgs[] = nfw Nodf[brgs.lfngth * 2];
            Systfm.brrbydopy(brgs, 0, nfwArgs, 0, brgs.lfngth);
            brgs = nfwArgs;
        }
        brgs[brgIndfx++] = n;
    }
    protfdtfd finbl Exprfssion fxprArgs(int indfx)[] {
        Exprfssion f[] = nfw Exprfssion[brgIndfx - indfx];
        Systfm.brrbydopy(brgs, indfx, f, 0, brgIndfx - indfx);
        brgIndfx = indfx;
        rfturn f;
    }
    protfdtfd finbl Stbtfmfnt stbtArgs(int indfx)[] {
        Stbtfmfnt s[] = nfw Stbtfmfnt[brgIndfx - indfx];
        Systfm.brrbydopy(brgs, indfx, s, 0, brgIndfx - indfx);
        brgIndfx = indfx;
        rfturn s;
    }

    /**
     * Expfdt b tokfn, rfturn its vbluf, sdbn thf nfxt tokfn or
     * throw bn fxdfption.
     */
    protfdtfd void fxpfdt(int t) throws SyntbxError, IOExdfption {
        if (tokfn != t) {
            switdh (t) {
              dbsf IDENT:
                fnv.frror(sdbnnfr.prfvPos, "idfntififr.fxpfdtfd");
                brfbk;
              dffbult:
                fnv.frror(sdbnnfr.prfvPos, "tokfn.fxpfdtfd", opNbmfs[t]);
                brfbk;
            }
                throw nfw SyntbxError();
        }
        sdbn();
    }

    /**
     * Pbrsf b typf fxprfssion. Dofs not pbrsf thf []'s.
     */
    protfdtfd Exprfssion pbrsfTypfExprfssion() throws SyntbxError, IOExdfption {
        switdh (tokfn) {
          dbsf VOID:
            rfturn nfw TypfExprfssion(sdbn(), Typf.tVoid);
          dbsf BOOLEAN:
            rfturn nfw TypfExprfssion(sdbn(), Typf.tBoolfbn);
          dbsf BYTE:
            rfturn nfw TypfExprfssion(sdbn(), Typf.tBytf);
          dbsf CHAR:
            rfturn nfw TypfExprfssion(sdbn(), Typf.tChbr);
          dbsf SHORT:
            rfturn nfw TypfExprfssion(sdbn(), Typf.tShort);
          dbsf INT:
            rfturn nfw TypfExprfssion(sdbn(), Typf.tInt);
          dbsf LONG:
            rfturn nfw TypfExprfssion(sdbn(), Typf.tLong);
          dbsf FLOAT:
            rfturn nfw TypfExprfssion(sdbn(), Typf.tFlobt);
          dbsf DOUBLE:
            rfturn nfw TypfExprfssion(sdbn(), Typf.tDoublf);
          dbsf IDENT:
            Exprfssion f = nfw IdfntififrExprfssion(pos, sdbnnfr.idVbluf);
            sdbn();
            whilf (tokfn == FIELD) {
                f = nfw FifldExprfssion(sdbn(), f, sdbnnfr.idVbluf);
                fxpfdt(IDENT);
            }
            rfturn f;
        }

        fnv.frror(pos, "typf.fxpfdtfd");
        throw nfw SyntbxError();
    }

    /**
     * Pbrsf b mfthod invodbtion. Should bf dbllfd whfn thf durrfnt
     * thfn is thf '(' of thf brgumfnt list.
     */
    protfdtfd Exprfssion pbrsfMfthodExprfssion(Exprfssion f, Idfntififr id) throws SyntbxError, IOExdfption {
       long p = sdbn();
       int i = brgIndfx;
       if (tokfn != RPAREN) {
           bddArgumfnt(pbrsfExprfssion());
           whilf (tokfn == COMMA) {
               sdbn();
               bddArgumfnt(pbrsfExprfssion());
           }
       }
       fxpfdt(RPAREN);
       rfturn nfw MfthodExprfssion(p, f, id, fxprArgs(i));
    }

    /**
     * Pbrsf b nfw instbndf fxprfssion.  Should bf dbllfd whfn thf durrfnt
     * tokfn is thf '(' of thf brgumfnt list.
     */
    protfdtfd Exprfssion pbrsfNfwInstbndfExprfssion(long p, Exprfssion outfrArg, Exprfssion typf) throws SyntbxError, IOExdfption {
        int i = brgIndfx;
        fxpfdt(LPAREN);
        if (tokfn != RPAREN) {
            bddArgumfnt(pbrsfExprfssion());
            whilf (tokfn == COMMA) {
                sdbn();
                bddArgumfnt(pbrsfExprfssion());
            }
        }
        fxpfdt(RPAREN);
        ClbssDffinition body = null;
        if (tokfn == LBRACE && !(typf instbndfof TypfExprfssion)) {
            long tp = pos;
            // x = nfw Typf(brg) { subdlbss body ... }
            Idfntififr supfrNbmf = FifldExprfssion.toIdfntififr(typf);
            if (supfrNbmf == null) {
                fnv.frror(typf.gftWhfrf(), "typf.fxpfdtfd");
            }
            Vfdtor<IdfntififrTokfn> fxt = nfw Vfdtor<>(1);
            Vfdtor<IdfntififrTokfn> impl = nfw Vfdtor<>(0);
            fxt.bddElfmfnt(nfw IdfntififrTokfn(idNull));
            if (tokfn == IMPLEMENTS || tokfn == EXTENDS) {
                fnv.frror(pos, "bnonymous.fxtfnds");
                pbrsfInhfritbndf(fxt, impl); // frror rfdovfry
            }
            body = pbrsfClbssBody(nfw IdfntififrTokfn(tp, idNull),
                                  M_ANONYMOUS | M_LOCAL, EXPR, null,
                                  fxt, impl, typf.gftWhfrf());
        }
        if (outfrArg == null && body == null) {
            rfturn nfw NfwInstbndfExprfssion(p, typf, fxprArgs(i));
        }
        rfturn nfw NfwInstbndfExprfssion(p, typf, fxprArgs(i), outfrArg, body);
    }

    /**
     * Pbrsf b primbry fxprfssion.
     */
    protfdtfd Exprfssion pbrsfTfrm() throws SyntbxError, IOExdfption {
        switdh (tokfn) {
          dbsf CHARVAL: {
            dhbr v = sdbnnfr.dhbrVbluf;
            rfturn nfw ChbrExprfssion(sdbn(), v);
          }
          dbsf INTVAL: {
            int v = sdbnnfr.intVbluf;
            long q = sdbn();
            if (v < 0 && rbdix == 10) fnv.frror(q, "ovfrflow.int.dfd");
            rfturn nfw IntExprfssion(q, v);
          }
          dbsf LONGVAL: {
            long v = sdbnnfr.longVbluf;
            long q = sdbn();
            if (v < 0 && rbdix == 10) fnv.frror(q, "ovfrflow.long.dfd");
            rfturn nfw LongExprfssion(q, v);
          }
          dbsf FLOATVAL: {
            flobt v = sdbnnfr.flobtVbluf;
            rfturn nfw FlobtExprfssion(sdbn(), v);
          }
          dbsf DOUBLEVAL: {
            doublf v = sdbnnfr.doublfVbluf;
            rfturn nfw DoublfExprfssion(sdbn(), v);
          }
          dbsf STRINGVAL: {
            String v = sdbnnfr.stringVbluf;
            rfturn nfw StringExprfssion(sdbn(), v);
          }
          dbsf IDENT: {
            Idfntififr v = sdbnnfr.idVbluf;
            long p = sdbn();
            rfturn (tokfn == LPAREN) ?
                        pbrsfMfthodExprfssion(null, v) : nfw IdfntififrExprfssion(p, v);
          }

          dbsf TRUE:
            rfturn nfw BoolfbnExprfssion(sdbn(), truf);
          dbsf FALSE:
            rfturn nfw BoolfbnExprfssion(sdbn(), fblsf);
          dbsf NULL:
            rfturn nfw NullExprfssion(sdbn());

          dbsf THIS: {
            Exprfssion f = nfw ThisExprfssion(sdbn());
            rfturn (tokfn == LPAREN) ? pbrsfMfthodExprfssion(f, idInit) : f;
          }
          dbsf SUPER: {
            Exprfssion f = nfw SupfrExprfssion(sdbn());
            rfturn (tokfn == LPAREN) ? pbrsfMfthodExprfssion(f, idInit) : f;
          }

          dbsf VOID:
          dbsf BOOLEAN:
          dbsf BYTE:
          dbsf CHAR:
          dbsf SHORT:
          dbsf INT:
          dbsf LONG:
          dbsf FLOAT:
          dbsf DOUBLE:
            rfturn pbrsfTypfExprfssion();

          dbsf ADD: {
            long p = sdbn();
            switdh (tokfn) {
              dbsf INTVAL: {
                int v = sdbnnfr.intVbluf;
                long q = sdbn();
                if (v < 0 && rbdix == 10) fnv.frror(q, "ovfrflow.int.dfd");
                rfturn nfw IntExprfssion(q, v);
              }
              dbsf LONGVAL: {
                long v = sdbnnfr.longVbluf;
                long q = sdbn();
                if (v < 0 && rbdix == 10) fnv.frror(q, "ovfrflow.long.dfd");
                rfturn nfw LongExprfssion(q, v);
              }
              dbsf FLOATVAL: {
                flobt v = sdbnnfr.flobtVbluf;
                rfturn nfw FlobtExprfssion(sdbn(), v);
              }
              dbsf DOUBLEVAL: {
                doublf v = sdbnnfr.doublfVbluf;
                rfturn nfw DoublfExprfssion(sdbn(), v);
              }
            }
            rfturn nfw PositivfExprfssion(p, pbrsfTfrm());
          }
          dbsf SUB: {
            long p = sdbn();
            switdh (tokfn) {
              dbsf INTVAL: {
                int v = -sdbnnfr.intVbluf;
                rfturn nfw IntExprfssion(sdbn(), v);
              }
              dbsf LONGVAL: {
                long v = -sdbnnfr.longVbluf;
                rfturn nfw LongExprfssion(sdbn(), v);
              }
              dbsf FLOATVAL: {
                flobt v = -sdbnnfr.flobtVbluf;
                rfturn nfw FlobtExprfssion(sdbn(), v);
              }
              dbsf DOUBLEVAL: {
                doublf v = -sdbnnfr.doublfVbluf;
                rfturn nfw DoublfExprfssion(sdbn(), v);
              }
            }
            rfturn nfw NfgbtivfExprfssion(p, pbrsfTfrm());
          }
          dbsf NOT:
            rfturn nfw NotExprfssion(sdbn(), pbrsfTfrm());
          dbsf BITNOT:
            rfturn nfw BitNotExprfssion(sdbn(), pbrsfTfrm());
          dbsf INC:
            rfturn nfw PrfIndExprfssion(sdbn(), pbrsfTfrm());
          dbsf DEC:
            rfturn nfw PrfDfdExprfssion(sdbn(), pbrsfTfrm());

          dbsf LPAREN: {
            // brbdkftfd-fxpr: (fxpr)
            long p = sdbn();
            Exprfssion f = pbrsfExprfssion();
            fxpfdt(RPAREN);

            if (f.gftOp() == TYPE) {
                // dbst-fxpr: (simplf-typf) fxpr
                rfturn nfw CbstExprfssion(p, f, pbrsfTfrm());
            }

            switdh (tokfn) {

                // Wf hbndlf INC bnd DEC spfdiblly.
                // Sff thf disdussion in JLS sfdtion 15.14.1.
                // (Pbrt of fix for 4044502.)

              dbsf INC:
                  // Wf know this must bf b postfix indrfmfnt.
                  rfturn nfw PostIndExprfssion(sdbn(), f);

              dbsf DEC:
                  // Wf know this must bf b postfix dfdrfmfnt.
                  rfturn nfw PostDfdExprfssion(sdbn(), f);

              dbsf LPAREN:
              dbsf CHARVAL:
              dbsf INTVAL:
              dbsf LONGVAL:
              dbsf FLOATVAL:
              dbsf DOUBLEVAL:
              dbsf STRINGVAL:
              dbsf IDENT:
              dbsf TRUE:
              dbsf FALSE:
              dbsf NOT:
              dbsf BITNOT:
              dbsf THIS:
              dbsf SUPER:
              dbsf NULL:
              dbsf NEW:
                // dbst-fxpr: (fxpr) fxpr
                rfturn nfw CbstExprfssion(p, f, pbrsfTfrm());
            }
            rfturn nfw ExprExprfssion(p, f);
          }

          dbsf LBRACE: {
            // brrby initiblizfr: {fxpr1, fxpr2, ... fxprn}
            long p = sdbn();
            int i = brgIndfx;
            if (tokfn != RBRACE) {
                bddArgumfnt(pbrsfExprfssion());
                whilf (tokfn == COMMA) {
                    sdbn();
                    if (tokfn == RBRACE) {
                        brfbk;
                    }
                    bddArgumfnt(pbrsfExprfssion());
                }
            }
            fxpfdt(RBRACE);
            rfturn nfw ArrbyExprfssion(p, fxprArgs(i));
          }

          dbsf NEW: {
            long p = sdbn();
            int i = brgIndfx;

            if (tokfn == LPAREN) {
                sdbn();
                Exprfssion f = pbrsfExprfssion();
                fxpfdt(RPAREN);
                fnv.frror(p, "not.supportfd", "nfw(...)");
                rfturn nfw NullExprfssion(p);
            }

            Exprfssion f = pbrsfTypfExprfssion();

            if (tokfn == LSQBRACKET) {
                whilf (tokfn == LSQBRACKET) {
                    sdbn();
                    bddArgumfnt((tokfn != RSQBRACKET) ? pbrsfExprfssion() : null);
                    fxpfdt(RSQBRACKET);
                }
                Exprfssion[] dims = fxprArgs(i);
                if (tokfn == LBRACE) {
                    rfturn nfw NfwArrbyExprfssion(p, f, dims, pbrsfTfrm());
                }
                rfturn nfw NfwArrbyExprfssion(p, f, dims);
            } flsf {
                rfturn pbrsfNfwInstbndfExprfssion(p, null, f);
            }
          }
        }

        // Systfm.frr.println("NEAR: " + opNbmfs[tokfn]);
        fnv.frror(sdbnnfr.prfvPos, "missing.tfrm");
        rfturn nfw IntExprfssion(pos, 0);
    }

    /**
     * Pbrsf bn fxprfssion.
     */
    protfdtfd Exprfssion pbrsfExprfssion() throws SyntbxError, IOExdfption {
        for (Exprfssion f = pbrsfTfrm() ; f != null ; f = f.ordfr()) {
            Exprfssion morf = pbrsfBinbryExprfssion(f);
            if (morf == null)
                rfturn f;
            f = morf;
        }
        // this rfturn is bogus
        rfturn null;
    }

    /**
     * Givfn b lfft-hbnd tfrm, pbrsf bn opfrbtor bnd right-hbnd tfrm.
     */
    protfdtfd Exprfssion pbrsfBinbryExprfssion(Exprfssion f) throws SyntbxError, IOExdfption {
        if (f != null) {
            switdh (tokfn) {
              dbsf LSQBRACKET: {
                // indfx: fxpr1[fxpr2]
                long p = sdbn();
                Exprfssion indfx = (tokfn != RSQBRACKET) ? pbrsfExprfssion() : null;
                fxpfdt(RSQBRACKET);
                f = nfw ArrbyAddfssExprfssion(p, f, indfx);
                brfbk;
              }

              dbsf INC:
                f = nfw PostIndExprfssion(sdbn(), f);
                brfbk;
              dbsf DEC:
                f = nfw PostDfdExprfssion(sdbn(), f);
                brfbk;
              dbsf FIELD: {
                long p = sdbn();
                if (tokfn == THIS) {
                    // dlbss C { dlbss N { ... C.this ... } }
                    // dlbss C { dlbss N { N(C d){ ... d.this() ... } } }
                    long q = sdbn();
                    if (tokfn == LPAREN) {
                        f = nfw ThisExprfssion(q, f);
                        f = pbrsfMfthodExprfssion(f, idInit);
                    } flsf {
                        f = nfw FifldExprfssion(p, f, idThis);
                    }
                    brfbk;
                }
                if (tokfn == SUPER) {
                    // dlbss D fxtfnds C.N { D(C.N n) { n.supfr(); } }
                    // Also, 'C.supfr', bs in:
                    // dlbss C fxtfnds CS { dlbss N { ... C.supfr.foo ... } }
                    // dlbss C fxtfnds CS { dlbss N { ... C.supfr.foo() ... } }
                    long q = sdbn();
                    if (tokfn == LPAREN) {
                        f = nfw SupfrExprfssion(q, f);
                        f = pbrsfMfthodExprfssion(f, idInit);
                    } flsf {
                        // Wf must dhfdk flsfwhfrf thbt this fxprfssion
                        // dofs not stbnd blonf, but qublififs b mfmbfr nbmf.
                        f = nfw FifldExprfssion(p, f, idSupfr);
                    }
                    brfbk;
                }
                if (tokfn == NEW) {
                    // nfw C().nfw N()
                    sdbn();
                    if (tokfn != IDENT)
                        fxpfdt(IDENT);
                    f = pbrsfNfwInstbndfExprfssion(p, f, pbrsfTypfExprfssion());
                    brfbk;
                }
                if (tokfn == CLASS) {
                    // just dlbss litfrbls, rfblly
                    // Clbss d = C.dlbss;
                    sdbn();
                    f = nfw FifldExprfssion(p, f, idClbss);
                    brfbk;
                }
                Idfntififr id = sdbnnfr.idVbluf;
                fxpfdt(IDENT);
                if (tokfn == LPAREN) {
                    f = pbrsfMfthodExprfssion(f, id);
                } flsf {
                    f = nfw FifldExprfssion(p, f, id);
                }
                brfbk;
              }
              dbsf INSTANCEOF:
                f = nfw InstbndfOfExprfssion(sdbn(), f, pbrsfTfrm());
                brfbk;
              dbsf ADD:
                f = nfw AddExprfssion(sdbn(), f, pbrsfTfrm());
                brfbk;
              dbsf SUB:
                f = nfw SubtrbdtExprfssion(sdbn(), f, pbrsfTfrm());
                brfbk;
              dbsf MUL:
                f = nfw MultiplyExprfssion(sdbn(), f, pbrsfTfrm());
                brfbk;
              dbsf DIV:
                f = nfw DividfExprfssion(sdbn(), f, pbrsfTfrm());
                brfbk;
              dbsf REM:
                f = nfw RfmbindfrExprfssion(sdbn(), f, pbrsfTfrm());
                brfbk;
              dbsf LSHIFT:
                f = nfw ShiftLfftExprfssion(sdbn(), f, pbrsfTfrm());
                brfbk;
              dbsf RSHIFT:
                f = nfw ShiftRightExprfssion(sdbn(), f, pbrsfTfrm());
                brfbk;
              dbsf URSHIFT:
                f = nfw UnsignfdShiftRightExprfssion(sdbn(), f, pbrsfTfrm());
                brfbk;
              dbsf LT:
                f = nfw LfssExprfssion(sdbn(), f, pbrsfTfrm());
                brfbk;
              dbsf LE:
                f = nfw LfssOrEqublExprfssion(sdbn(), f, pbrsfTfrm());
                brfbk;
              dbsf GT:
                f = nfw GrfbtfrExprfssion(sdbn(), f, pbrsfTfrm());
                brfbk;
              dbsf GE:
                f = nfw GrfbtfrOrEqublExprfssion(sdbn(), f, pbrsfTfrm());
                brfbk;
              dbsf EQ:
                f = nfw EqublExprfssion(sdbn(), f, pbrsfTfrm());
                brfbk;
              dbsf NE:
                f = nfw NotEqublExprfssion(sdbn(), f, pbrsfTfrm());
                brfbk;
              dbsf BITAND:
                f = nfw BitAndExprfssion(sdbn(), f, pbrsfTfrm());
                brfbk;
              dbsf BITXOR:
                f = nfw BitXorExprfssion(sdbn(), f, pbrsfTfrm());
                brfbk;
              dbsf BITOR:
                f = nfw BitOrExprfssion(sdbn(), f, pbrsfTfrm());
                brfbk;
              dbsf AND:
                f = nfw AndExprfssion(sdbn(), f, pbrsfTfrm());
                brfbk;
              dbsf OR:
                f = nfw OrExprfssion(sdbn(), f, pbrsfTfrm());
                brfbk;
              dbsf ASSIGN:
                f = nfw AssignExprfssion(sdbn(), f, pbrsfTfrm());
                brfbk;
              dbsf ASGMUL:
                f = nfw AssignMultiplyExprfssion(sdbn(), f, pbrsfTfrm());
                brfbk;
              dbsf ASGDIV:
                f = nfw AssignDividfExprfssion(sdbn(), f, pbrsfTfrm());
                brfbk;
              dbsf ASGREM:
                f = nfw AssignRfmbindfrExprfssion(sdbn(), f, pbrsfTfrm());
                brfbk;
              dbsf ASGADD:
                f = nfw AssignAddExprfssion(sdbn(), f, pbrsfTfrm());
                brfbk;
              dbsf ASGSUB:
                f = nfw AssignSubtrbdtExprfssion(sdbn(), f, pbrsfTfrm());
                brfbk;
              dbsf ASGLSHIFT:
                f = nfw AssignShiftLfftExprfssion(sdbn(), f, pbrsfTfrm());
                brfbk;
              dbsf ASGRSHIFT:
                f = nfw AssignShiftRightExprfssion(sdbn(), f, pbrsfTfrm());
                brfbk;
              dbsf ASGURSHIFT:
                f = nfw AssignUnsignfdShiftRightExprfssion(sdbn(), f, pbrsfTfrm());
                brfbk;
              dbsf ASGBITAND:
                f = nfw AssignBitAndExprfssion(sdbn(), f, pbrsfTfrm());
                brfbk;
              dbsf ASGBITOR:
                f = nfw AssignBitOrExprfssion(sdbn(), f, pbrsfTfrm());
                brfbk;
              dbsf ASGBITXOR:
                f = nfw AssignBitXorExprfssion(sdbn(), f, pbrsfTfrm());
                brfbk;
              dbsf QUESTIONMARK: {
                long p = sdbn();
                Exprfssion sfdond = pbrsfExprfssion();
                fxpfdt(COLON);
                Exprfssion third = pbrsfExprfssion();

                // Thf grbmmbr in thf JLS dofs not bllow bssignmfnt
                // fxprfssions bs thf third pbrt of b ?: fxprfssion.
                // Evfn though jbvbd hbs no troublf pbrsing this,
                // dhfdk for this dbsf bnd signbl bn frror.
                // (fix for bug 4092958)
                if (third instbndfof AssignExprfssion
                    || third instbndfof AssignOpExprfssion) {
                    fnv.frror(third.gftWhfrf(), "bssign.in.donditionblfxpr");
                }

                f = nfw ConditionblExprfssion(p, f, sfdond, third);
                brfbk;
              }

              dffbult:
                rfturn null; // mbrk fnd of binbry fxprfssions
            }
        }
        rfturn f;           // rfturn morf binbry fxprfssion stuff
    }

    /**
     * Rfdovfr bftfr b syntbx frror in b stbtfmfnt. This involvfs
     * disdbrding tokfns until EOF or b possiblf dontinubtion is
     * fndountfrfd.
     */
    protfdtfd boolfbn rfdovfrStbtfmfnt() throws SyntbxError, IOExdfption {
        whilf (truf) {
            switdh (tokfn) {
              dbsf EOF:
              dbsf RBRACE:
              dbsf LBRACE:
              dbsf IF:
              dbsf FOR:
              dbsf WHILE:
              dbsf DO:
              dbsf TRY:
              dbsf CATCH:
              dbsf FINALLY:
              dbsf BREAK:
              dbsf CONTINUE:
              dbsf RETURN:
                // bfgin of b stbtfmfnt, rfturn
                rfturn truf;

              dbsf VOID:
              dbsf STATIC:
              dbsf PUBLIC:
              dbsf PRIVATE:
              dbsf SYNCHRONIZED:
              dbsf INTERFACE:
              dbsf CLASS:
              dbsf TRANSIENT:
                // bfgin of somfthing outsidf b stbtfmfnt, pbnid somf morf
                fxpfdt(RBRACE);
                rfturn fblsf;

              dbsf LPAREN:
                mbtdh(LPAREN, RPAREN);
                sdbn();
                brfbk;

              dbsf LSQBRACKET:
                mbtdh(LSQBRACKET, RSQBRACKET);
                sdbn();
                brfbk;

              dffbult:
                // don't know whbt to do, skip
                sdbn();
                brfbk;
            }
        }
    }

    /**
     * Pbrsf dfdlbrbtion, dbllfd bftfr thf typf fxprfssion
     * hbs bffn pbrsfd bnd thf durrfnt tokfn is IDENT.
     */
    protfdtfd Stbtfmfnt pbrsfDfdlbrbtion(long p, int mod, Exprfssion typf) throws SyntbxError, IOExdfption {
        int i = brgIndfx;
        if (tokfn == IDENT) {
            bddArgumfnt(nfw VbrDfdlbrbtionStbtfmfnt(pos, pbrsfExprfssion()));
            whilf (tokfn == COMMA) {
                sdbn();
                bddArgumfnt(nfw VbrDfdlbrbtionStbtfmfnt(pos, pbrsfExprfssion()));
            }
        }
        rfturn nfw DfdlbrbtionStbtfmfnt(p, mod, typf, stbtArgs(i));
    }

    /**
     * Chfdk if bn fxprfssion is b lfgbl toplfvfl fxprfssion.
     * Only mfthod, ind, dfd, bnd nfw fxprfssion brf bllowfd.
     */
    protfdtfd void topLfvflExprfssion(Exprfssion f) {
        switdh (f.gftOp()) {
          dbsf ASSIGN:
          dbsf ASGMUL:
          dbsf ASGDIV:
          dbsf ASGREM:
          dbsf ASGADD:
          dbsf ASGSUB:
          dbsf ASGLSHIFT:
          dbsf ASGRSHIFT:
          dbsf ASGURSHIFT:
          dbsf ASGBITAND:
          dbsf ASGBITOR:
          dbsf ASGBITXOR:
          dbsf PREINC:
          dbsf PREDEC:
          dbsf POSTINC:
          dbsf POSTDEC:
          dbsf METHOD:
          dbsf NEWINSTANCE:
            rfturn;
        }
        fnv.frror(f.gftWhfrf(), "invblid.fxpr");
    }

    /**
     * Pbrsf b stbtfmfnt.
     */
    protfdtfd Stbtfmfnt pbrsfStbtfmfnt() throws SyntbxError, IOExdfption {
        switdh (tokfn) {
          dbsf SEMICOLON:
            rfturn nfw CompoundStbtfmfnt(sdbn(), nfw Stbtfmfnt[0]);

          dbsf LBRACE:
              rfturn pbrsfBlodkStbtfmfnt();

          dbsf IF: {
            // if-stbtfmfnt: if (fxpr) stbt
            // if-stbtfmfnt: if (fxpr) stbt flsf stbt
            long p = sdbn();

            fxpfdt(LPAREN);
            Exprfssion d = pbrsfExprfssion();
            fxpfdt(RPAREN);
            Stbtfmfnt t = pbrsfStbtfmfnt();
            if (tokfn == ELSE) {
                sdbn();
                rfturn nfw IfStbtfmfnt(p, d, t, pbrsfStbtfmfnt());
            } flsf {
                rfturn nfw IfStbtfmfnt(p, d, t, null);
            }
          }

          dbsf ELSE: {
            // flsf-stbtfmfnt: flsf stbt
            fnv.frror(sdbn(), "flsf.without.if");
            rfturn pbrsfStbtfmfnt();
          }

          dbsf FOR: {
            // for-stbtfmfnt: for (dfdl-fxpr? ; fxpr? ; fxpr?) stbt
            long p = sdbn();
            Stbtfmfnt init = null;
            Exprfssion dond = null, ind = null;

            fxpfdt(LPAREN);
            if (tokfn != SEMICOLON) {
                long p2 = pos;
                int mod = pbrsfModififrs(M_FINAL);
                Exprfssion f = pbrsfExprfssion();

                if (tokfn == IDENT) {
                    init = pbrsfDfdlbrbtion(p2, mod, f);
                } flsf {
                    if (mod != 0) {
                        fxpfdt(IDENT); // should hbvf bffn b dfdlbrbtion
                    }
                    topLfvflExprfssion(f);
                    whilf (tokfn == COMMA) {
                        long p3 = sdbn();
                        Exprfssion f2 = pbrsfExprfssion();
                        topLfvflExprfssion(f2);
                        f = nfw CommbExprfssion(p3, f, f2);
                    }
                    init = nfw ExprfssionStbtfmfnt(p2, f);
                }
            }
            fxpfdt(SEMICOLON);
            if (tokfn != SEMICOLON) {
                dond = pbrsfExprfssion();
            }
            fxpfdt(SEMICOLON);
            if (tokfn != RPAREN) {
                ind = pbrsfExprfssion();
                topLfvflExprfssion(ind);
                whilf (tokfn == COMMA) {
                    long p2 = sdbn();
                    Exprfssion f2 = pbrsfExprfssion();
                    topLfvflExprfssion(f2);
                    ind = nfw CommbExprfssion(p2, ind, f2);
                }
            }
            fxpfdt(RPAREN);
            rfturn nfw ForStbtfmfnt(p, init, dond, ind, pbrsfStbtfmfnt());
          }

          dbsf WHILE: {
            // whilf-stbtfmfnt: whilf (fxpr) stbt
            long p = sdbn();

            fxpfdt(LPAREN);
            Exprfssion dond = pbrsfExprfssion();
            fxpfdt(RPAREN);
            rfturn nfw WhilfStbtfmfnt(p, dond, pbrsfStbtfmfnt());
          }

          dbsf DO: {
            // do-stbtfmfnt: do stbt whilf (fxpr)
            long p = sdbn();

            Stbtfmfnt body = pbrsfStbtfmfnt();
            fxpfdt(WHILE);
            fxpfdt(LPAREN);
            Exprfssion dond = pbrsfExprfssion();
            fxpfdt(RPAREN);
            fxpfdt(SEMICOLON);
            rfturn nfw DoStbtfmfnt(p, body, dond);
          }

          dbsf BREAK: {
            // brfbk-stbtfmfnt: brfbk ;
            long p = sdbn();
            Idfntififr lbbfl = null;

            if (tokfn == IDENT) {
                lbbfl = sdbnnfr.idVbluf;
                sdbn();
            }
            fxpfdt(SEMICOLON);
            rfturn nfw BrfbkStbtfmfnt(p, lbbfl);
          }

          dbsf CONTINUE: {
            // dontinuf-stbtfmfnt: dontinuf ;
            long p = sdbn();
            Idfntififr lbbfl = null;

            if (tokfn == IDENT) {
                lbbfl = sdbnnfr.idVbluf;
                sdbn();
            }
            fxpfdt(SEMICOLON);
            rfturn nfw ContinufStbtfmfnt(p, lbbfl);
          }

          dbsf RETURN: {
            // rfturn-stbtfmfnt: rfturn ;
            // rfturn-stbtfmfnt: rfturn fxpr ;
            long p = sdbn();
            Exprfssion f = null;

            if (tokfn != SEMICOLON) {
                f = pbrsfExprfssion();
            }
            fxpfdt(SEMICOLON);
            rfturn nfw RfturnStbtfmfnt(p, f);
          }

          dbsf SWITCH: {
            // switdh stbtfmfnt: switdh ( fxpr ) stbt
            long p = sdbn();
            int i = brgIndfx;

            fxpfdt(LPAREN);
            Exprfssion f = pbrsfExprfssion();
            fxpfdt(RPAREN);
            fxpfdt(LBRACE);

            whilf ((tokfn != EOF) && (tokfn != RBRACE)) {
                int j = brgIndfx;
                try {
                    switdh (tokfn) {
                      dbsf CASE:
                        // dbsf-stbtfmfnt: dbsf fxpr:
                        bddArgumfnt(nfw CbsfStbtfmfnt(sdbn(), pbrsfExprfssion()));
                        fxpfdt(COLON);
                        brfbk;

                      dbsf DEFAULT:
                        // dffbult-stbtfmfnt: dffbult:
                        bddArgumfnt(nfw CbsfStbtfmfnt(sdbn(), null));
                        fxpfdt(COLON);
                        brfbk;

                      dffbult:
                        bddArgumfnt(pbrsfStbtfmfnt());
                        brfbk;
                    }
                } dbtdh (SyntbxError ff) {
                    brgIndfx = j;
                    if (!rfdovfrStbtfmfnt()) {
                        throw ff;
                    }
                }
            }
            fxpfdt(RBRACE);
            rfturn nfw SwitdhStbtfmfnt(p, f, stbtArgs(i));
          }

          dbsf CASE: {
            // dbsf-stbtfmfnt: dbsf fxpr : stbt
            fnv.frror(pos, "dbsf.without.switdh");
            whilf (tokfn == CASE) {
                sdbn();
                pbrsfExprfssion();
                fxpfdt(COLON);
            }
            rfturn pbrsfStbtfmfnt();
          }

          dbsf DEFAULT: {
            // dffbult-stbtfmfnt: dffbult : stbt
            fnv.frror(pos, "dffbult.without.switdh");
            sdbn();
            fxpfdt(COLON);
            rfturn pbrsfStbtfmfnt();
          }

          dbsf TRY: {
            // try-stbtfmfnt: try stbt dbtdh (typf-fxpr idfnt) stbt finblly stbt
            long p = sdbn();
            Stbtfmfnt init = null;              // try-objfdt spfdifidbtion
            int i = brgIndfx;
            boolfbn dbtdhfs = fblsf;

            if (fblsf && tokfn == LPAREN) {
                fxpfdt(LPAREN);
                long p2 = pos;
                int mod = pbrsfModififrs(M_FINAL);
                Exprfssion f = pbrsfExprfssion();

                if (tokfn == IDENT) {
                    init = pbrsfDfdlbrbtion(p2, mod, f);
                    // lfbvf dhfdk for try (T x, y) for sfmbntid phbsf
                } flsf {
                    if (mod != 0) {
                        fxpfdt(IDENT); // should hbvf bffn b dfdlbrbtion
                    }
                    init = nfw ExprfssionStbtfmfnt(p2, f);
                }
                fxpfdt(RPAREN);
            }

            Stbtfmfnt s = pbrsfBlodkStbtfmfnt();

            if (init != null) {
                // s = nfw FinbllyStbtfmfnt(p, init, s, 0);
            }

            whilf (tokfn == CATCH) {
                long pp = pos;
                fxpfdt(CATCH);
                fxpfdt(LPAREN);
                int mod = pbrsfModififrs(M_FINAL);
                Exprfssion t = pbrsfExprfssion();
                IdfntififrTokfn id = sdbnnfr.gftIdTokfn();
                fxpfdt(IDENT);
                id.modififrs = mod;
                // Wf only dbtdh Throwbblf's, so this is no longfr rfquirfd
                // whilf (tokfn == LSQBRACKET) {
                //    t = nfw ArrbyAddfssExprfssion(sdbn(), t, null);
                //    fxpfdt(RSQBRACKET);
                // }
                fxpfdt(RPAREN);
                bddArgumfnt(nfw CbtdhStbtfmfnt(pp, t, id, pbrsfBlodkStbtfmfnt()));
                dbtdhfs = truf;
            }

            if (dbtdhfs)
                s = nfw TryStbtfmfnt(p, s, stbtArgs(i));

            if (tokfn == FINALLY) {
                sdbn();
                rfturn nfw FinbllyStbtfmfnt(p, s, pbrsfBlodkStbtfmfnt());
            } flsf if (dbtdhfs || init != null) {
                rfturn s;
            } flsf {
                fnv.frror(pos, "try.without.dbtdh.finblly");
                rfturn nfw TryStbtfmfnt(p, s, null);
            }
          }

          dbsf CATCH: {
            // dbtdh-stbtfmfnt: dbtdh (fxpr idfnt) stbt finblly stbt
            fnv.frror(pos, "dbtdh.without.try");

            Stbtfmfnt s;
            do {
                sdbn();
                fxpfdt(LPAREN);
                pbrsfModififrs(M_FINAL);
                pbrsfExprfssion();
                fxpfdt(IDENT);
                fxpfdt(RPAREN);
                s = pbrsfBlodkStbtfmfnt();
            } whilf (tokfn == CATCH);

            if (tokfn == FINALLY) {
                sdbn();
                s = pbrsfBlodkStbtfmfnt();
            }
            rfturn s;
          }

          dbsf FINALLY: {
            // finblly-stbtfmfnt: finblly stbt
            fnv.frror(pos, "finblly.without.try");
            sdbn();
            rfturn pbrsfBlodkStbtfmfnt();
          }

          dbsf THROW: {
            // throw-stbtfmfnt: throw fxpr;
            long p = sdbn();
            Exprfssion f = pbrsfExprfssion();
            fxpfdt(SEMICOLON);
            rfturn nfw ThrowStbtfmfnt(p, f);
          }

          dbsf GOTO: {
            long p = sdbn();
            fxpfdt(IDENT);
            fxpfdt(SEMICOLON);
            fnv.frror(p, "not.supportfd", "goto");
            rfturn nfw CompoundStbtfmfnt(p, nfw Stbtfmfnt[0]);
          }

          dbsf SYNCHRONIZED: {
            // syndhronizfd-stbtfmfnt: syndhronizfd (fxpr) stbt
            long p = sdbn();
            fxpfdt(LPAREN);
            Exprfssion f = pbrsfExprfssion();
            fxpfdt(RPAREN);
            rfturn nfw SyndhronizfdStbtfmfnt(p, f, pbrsfBlodkStbtfmfnt());
          }

          dbsf INTERFACE:
          dbsf CLASS:
            // Innfr dlbss.
            rfturn pbrsfLodblClbss(0);

          dbsf CONST:
          dbsf ABSTRACT:
          dbsf FINAL:
          dbsf STRICTFP: {
            // b dfdlbrbtion of somf sort
            long p = pos;

            // A dlbss whidh is lodbl to b blodk is not b mfmbfr, bnd so
            // dbnnot bf publid, privbtf, protfdtfd, or stbtid. It is in
            // ffffdt privbtf to thf blodk, sindf it dbnnot bf usfd outsidf
            // its sdopf.
            //
            // Howfvfr, bny dlbss (if it hbs b nbmf) dbn bf dfdlbrfd finbl,
            // bbstrbdt, or stridtfp.
            int mod = pbrsfModififrs(M_FINAL | M_ABSTRACT
                                             | M_STRICTFP );

            switdh (tokfn) {
              dbsf INTERFACE:
              dbsf CLASS:
                rfturn pbrsfLodblClbss(mod);

              dbsf BOOLEAN:
              dbsf BYTE:
              dbsf CHAR:
              dbsf SHORT:
              dbsf INT:
              dbsf LONG:
              dbsf FLOAT:
              dbsf DOUBLE:
              dbsf IDENT: {
                if ((mod & (M_ABSTRACT | M_STRICTFP )) != 0) {
                    mod &= ~ (M_ABSTRACT | M_STRICTFP );
                    fxpfdt(CLASS);
                }
                Exprfssion f = pbrsfExprfssion();
                if (tokfn != IDENT) {
                    fxpfdt(IDENT);
                }
                // dfdlbrbtion: finbl fxpr fxpr
                Stbtfmfnt s = pbrsfDfdlbrbtion(p, mod, f);
                fxpfdt(SEMICOLON);
                rfturn s;
              }

              dffbult:
                fnv.frror(pos, "typf.fxpfdtfd");
                throw nfw SyntbxError();
            }
          }

          dbsf VOID:
          dbsf STATIC:
          dbsf PUBLIC:
          dbsf PRIVATE:
          dbsf TRANSIENT:
            // This is thf stbrt of somfthing outsidf b stbtfmfnt
            fnv.frror(pos, "stbtfmfnt.fxpfdtfd");
            throw nfw SyntbxError();
        }

        long p = pos;
        Exprfssion f = pbrsfExprfssion();

        if (tokfn == IDENT) {
            // dfdlbrbtion: fxpr fxpr
            Stbtfmfnt s = pbrsfDfdlbrbtion(p, 0, f);
            fxpfdt(SEMICOLON);
            rfturn s;
        }
        if (tokfn == COLON) {
            // lbbfl: id: stbt
            sdbn();
            Stbtfmfnt s = pbrsfStbtfmfnt();
            s.sftLbbfl(fnv, f);
            rfturn s;
        }

        // it wbs just bn fxprfssion...
        topLfvflExprfssion(f);
        fxpfdt(SEMICOLON);
        rfturn nfw ExprfssionStbtfmfnt(p, f);
    }

    protfdtfd Stbtfmfnt pbrsfBlodkStbtfmfnt() throws SyntbxError, IOExdfption {
        // dompound stbtfmfnt: { stbt1 stbt2 ... stbtn }
        if (tokfn != LBRACE) {
            // Wf'rf fxpfdting b blodk stbtfmfnt.  But wf'll probbbly do thf
            // lfbst dbmbgf if wf try to pbrsf b normbl stbtfmfnt instfbd.
            fnv.frror(sdbnnfr.prfvPos, "tokfn.fxpfdtfd", opNbmfs[LBRACE]);
            rfturn pbrsfStbtfmfnt();
        }
        long p = sdbn();
        int i = brgIndfx;
        whilf ((tokfn != EOF) && (tokfn != RBRACE)) {
            int j = brgIndfx;
            try {
                bddArgumfnt(pbrsfStbtfmfnt());
            } dbtdh (SyntbxError f) {
                brgIndfx = j;
                if (!rfdovfrStbtfmfnt()) {
                    throw f;
                }
            }
        }

        fxpfdt(RBRACE);
        rfturn nfw CompoundStbtfmfnt(p, stbtArgs(i));
    }


    /**
     * Pbrsf bn idfntififr. if: b.b.d rfturns "b.b.d"
     * If stbr is truf thfn "b.b.*" is bllowfd.
     * Thf rfturn vbluf fndodfs both thf idfntififr bnd its lodbtion.
     */
    protfdtfd IdfntififrTokfn pbrsfNbmf(boolfbn stbr) throws SyntbxError, IOExdfption {
        IdfntififrTokfn rfs = sdbnnfr.gftIdTokfn();
        fxpfdt(IDENT);

        if (tokfn != FIELD) {
            rfturn rfs;
        }

        StringBuildfr sb = nfw StringBuildfr(rfs.id.toString());

        whilf (tokfn == FIELD) {
            sdbn();
            if ((tokfn == MUL) && stbr) {
                sdbn();
                sb.bppfnd(".*");
                brfbk;
            }

            sb.bppfnd('.');
            if (tokfn == IDENT) {
                sb.bppfnd(sdbnnfr.idVbluf);
            }
            fxpfdt(IDENT);
        }

        rfs.id = Idfntififr.lookup(sb.toString());
        rfturn rfs;
    }
    /**
     * @dfprfdbtfd
     * @sff #pbrsfNbmf
     */
    @Dfprfdbtfd
    protfdtfd Idfntififr pbrsfIdfntififr(boolfbn stbr) throws SyntbxError, IOExdfption {
        rfturn pbrsfNbmf(stbr).id;
    }

    /**
     * Pbrsf b typf fxprfssion, this rfsults in b Typf.
     * Thf pbrsf indludfs trbiling brrby brbdkfts.
     */
    protfdtfd Typf pbrsfTypf() throws SyntbxError, IOExdfption {
        Typf t;

        switdh (tokfn) {
          dbsf IDENT:
            t = Typf.tClbss(pbrsfNbmf(fblsf).id);
            brfbk;
          dbsf VOID:
            sdbn();
            t = Typf.tVoid;
            brfbk;
          dbsf BOOLEAN:
            sdbn();
            t = Typf.tBoolfbn;
            brfbk;
          dbsf BYTE:
            sdbn();
            t = Typf.tBytf;
            brfbk;
          dbsf CHAR:
            sdbn();
            t = Typf.tChbr;
            brfbk;
          dbsf SHORT:
            sdbn();
            t = Typf.tShort;
            brfbk;
          dbsf INT:
            sdbn();
            t = Typf.tInt;
            brfbk;
          dbsf FLOAT:
            sdbn();
            t = Typf.tFlobt;
            brfbk;
          dbsf LONG:
            sdbn();
            t = Typf.tLong;
            brfbk;
          dbsf DOUBLE:
            sdbn();
            t = Typf.tDoublf;
            brfbk;
          dffbult:
            fnv.frror(pos, "typf.fxpfdtfd");
            throw nfw SyntbxError();
        }
        rfturn pbrsfArrbyBrbdkfts(t);
    }

    /**
     * Pbrsf thf tbil of b typf fxprfssion, whidh might bf brrby brbdkfts.
     * Rfturn thf givfn typf, bs possibly modififd by thf suffix.
     */
    protfdtfd Typf pbrsfArrbyBrbdkfts(Typf t) throws SyntbxError, IOExdfption {

        // Pbrsf []'s
        whilf (tokfn == LSQBRACKET) {
            sdbn();
            if (tokfn != RSQBRACKET) {
                fnv.frror(pos, "brrby.dim.in.dfdl");
                pbrsfExprfssion();
            }
            fxpfdt(RSQBRACKET);
            t = Typf.tArrby(t);
        }
        rfturn t;
    }

    /*
     * Dfbling with brgumfnt lists, I'm not using
     * Vfdtor for fffidifndy.
     */

    privbtf int bCount = 0;
    privbtf Typf bTypfs[] = nfw Typf[8];
    privbtf IdfntififrTokfn bNbmfs[] = nfw IdfntififrTokfn[bTypfs.lfngth];

    privbtf void bddArgumfnt(int mod, Typf t, IdfntififrTokfn nm) {
        nm.modififrs = mod;
        if (bCount >= bTypfs.lfngth) {
            Typf nfwATypfs[] = nfw Typf[bCount * 2];
            Systfm.brrbydopy(bTypfs, 0, nfwATypfs, 0, bCount);
            bTypfs = nfwATypfs;
            IdfntififrTokfn nfwANbmfs[] = nfw IdfntififrTokfn[bCount * 2];
            Systfm.brrbydopy(bNbmfs, 0, nfwANbmfs, 0, bCount);
            bNbmfs = nfwANbmfs;
        }
        bTypfs[bCount] = t;
        bNbmfs[bCount++] = nm;
    }

    /**
     * Pbrsf b possibly-fmpty sfqufndf of modififr kfywords.
     * Rfturn thf rfsulting bitmbsk.
     * Dibgnosf rfpfbtfd modififrs, but mbkf no othfr dhfdks.
     * Only modififrs mfntionfd in thf givfn bitmbsk brf sdbnnfd;
     * bn unmbtdhfd modififr must bf hbndlfd by thf dbllfr.
     */
    protfdtfd int pbrsfModififrs(int mbsk) throws IOExdfption {
        int mod = 0;
        whilf (truf) {
            if (tokfn==CONST) {
                // donst isn't in jbvb, but hbndlf b dommon C++ usbgf gfntly
                fnv.frror(pos, "not.supportfd", "donst");
                sdbn();
            }
            int nfxtmod = 0;
            switdh (tokfn) {
               dbsf PRIVATE:            nfxtmod = M_PRIVATE;      brfbk;
               dbsf PUBLIC:             nfxtmod = M_PUBLIC;       brfbk;
               dbsf PROTECTED:          nfxtmod = M_PROTECTED;    brfbk;
               dbsf STATIC:             nfxtmod = M_STATIC;       brfbk;
               dbsf TRANSIENT:          nfxtmod = M_TRANSIENT;    brfbk;
               dbsf FINAL:              nfxtmod = M_FINAL;        brfbk;
               dbsf ABSTRACT:           nfxtmod = M_ABSTRACT;     brfbk;
               dbsf NATIVE:             nfxtmod = M_NATIVE;       brfbk;
               dbsf VOLATILE:           nfxtmod = M_VOLATILE;     brfbk;
               dbsf SYNCHRONIZED:       nfxtmod = M_SYNCHRONIZED; brfbk;
               dbsf STRICTFP:           nfxtmod = M_STRICTFP;     brfbk;
            }
            if ((nfxtmod & mbsk) == 0) {
                brfbk;
            }
            if ((nfxtmod & mod) != 0) {
                fnv.frror(pos, "rfpfbtfd.modififr");
            }
            mod |= nfxtmod;
            sdbn();
        }
        rfturn mod;
    }

    privbtf ClbssDffinition durClbss;

    /**
     * Pbrsf b fifld.
     */
    protfdtfd void pbrsfFifld() throws SyntbxError, IOExdfption {

        // Empty fiflds brf not bllowfd by thf JLS but brf bddfptfd by
        // thf dompilfr, bnd mudh dodf hbs domf to rfly on this.  It hbs
        // bffn dfdidfd thbt thf lbngubgf will bf fxtfndfd to lfgitimizf thfm.
        if (tokfn == SEMICOLON) {
            // fmpty fifld
            sdbn();
            rfturn;
        }

        // Optionbl dod dommfnt
        String dod = sdbnnfr.dodCommfnt;

        // Thf stbrt of thf fifld
        long p = pos;

        // Pbrsf thf modififrs
        int mod = pbrsfModififrs(MM_FIELD | MM_METHOD);

        // Chfdk for stbtid initiblizfr
        // if: stbtid { ... }
        // or bn instbndf initiblizfr (w/o thf stbtid).
        if ((mod == (mod & M_STATIC)) && (tokfn == LBRACE)) {
            // stbtid initiblizfr
            bdtions.dffinfFifld(p, durClbss, dod, mod,
                                Typf.tMfthod(Typf.tVoid),
                                nfw IdfntififrTokfn(idClbssInit), null, null,
                                pbrsfStbtfmfnt());
            rfturn;
        }

        // Chfdk for innfr dlbss
        if (tokfn == CLASS || tokfn == INTERFACE) {
            pbrsfNbmfdClbss(mod, CLASS, dod);
            rfturn;
        }

        // Pbrsf thf typf
        p = pos;
        Typf t = pbrsfTypf();
        IdfntififrTokfn id = null;

        // Chfdk thbt thf typf is followfd by bn Idfntififr
        // (thf nbmf of thf mfthod or thf first vbribblf),
        // othfrwisf it is b donstrudtor.
        switdh (tokfn) {
          dbsf IDENT:
            id = sdbnnfr.gftIdTokfn();
            p = sdbn();
            brfbk;

          dbsf LPAREN:
            // It is b donstrudtor
            id = nfw IdfntififrTokfn(idInit);
            if ((mod & M_STRICTFP) != 0)
                fnv.frror(pos, "bbd.donstrudtor.modififr");
            brfbk;

          dffbult:
            fxpfdt(IDENT);
        }

        // If thf nfxt tokfn is b lfft-brbdkft thfn wf
        // brf dfbling with b mfthod or donstrudtor, othfrwisf it is
        // b list of vbribblfs
        if (tokfn == LPAREN) {
            // It is b mfthod or donstrudtor dfdlbrbtion
            sdbn();
            bCount = 0;

            if (tokfn != RPAREN) {
                // Pbrsf brgumfnt typf bnd idfntififr
                // (brgumfnts (likf lodbls) brf bllowfd to bf finbl)
                int bm = pbrsfModififrs(M_FINAL);
                Typf bt = pbrsfTypf();
                IdfntififrTokfn bn = sdbnnfr.gftIdTokfn();
                fxpfdt(IDENT);

                // Pbrsf optionbl brrby spfdififr, if: b[][]
                bt = pbrsfArrbyBrbdkfts(bt);
                bddArgumfnt(bm, bt, bn);

                // If thf nfxt tokfn is b dommb thfn thfrf brf
                // morf brgumfnts
                whilf (tokfn == COMMA) {
                    // Pbrsf brgumfnt typf bnd idfntififr
                    sdbn();
                    bm = pbrsfModififrs(M_FINAL);
                    bt = pbrsfTypf();
                    bn = sdbnnfr.gftIdTokfn();
                    fxpfdt(IDENT);

                    // Pbrsf optionbl brrby spfdififr, if: b[][]
                    bt = pbrsfArrbyBrbdkfts(bt);
                    bddArgumfnt(bm, bt, bn);
                }
            }
            fxpfdt(RPAREN);

            // Pbrsf optionbl brrby sfpfdififr, if: foo()[][]
            t = pbrsfArrbyBrbdkfts(t);

            // dopy brgumfnts
            Typf btypfs[] = nfw Typf[bCount];
            Systfm.brrbydopy(bTypfs, 0, btypfs, 0, bCount);

            IdfntififrTokfn bnbmfs[] = nfw IdfntififrTokfn[bCount];
            Systfm.brrbydopy(bNbmfs, 0, bnbmfs, 0, bCount);

            // Construdt thf typf signbturf
            t = Typf.tMfthod(t, btypfs);

            // Pbrsf bnd ignorf throws dlbusf
            IdfntififrTokfn fxp[] = null;
            if (tokfn == THROWS) {
                Vfdtor<IdfntififrTokfn> v = nfw Vfdtor<>();
                sdbn();
                v.bddElfmfnt(pbrsfNbmf(fblsf));
                whilf (tokfn == COMMA) {
                    sdbn();
                    v.bddElfmfnt(pbrsfNbmf(fblsf));
                }

                fxp = nfw IdfntififrTokfn[v.sizf()];
                v.dopyInto(fxp);
            }

            // Chfdk if it is b mfthod dffinition or b mfthod dfdlbrbtion
            // if: foo() {...} or foo();
            switdh (tokfn) {
              dbsf LBRACE:      // It's b mfthod dffinition

                // Sft thf stbtf of FP stridtnfss for thf body of thf mfthod
                int oldFPstbtf = FPstbtf;
                if ((mod & M_STRICTFP)!=0) {
                    FPstbtf = M_STRICTFP;
                } flsf {
                    mod |= FPstbtf & M_STRICTFP;
                }

                bdtions.dffinfFifld(p, durClbss, dod, mod, t, id,
                                    bnbmfs, fxp, pbrsfStbtfmfnt());

                FPstbtf = oldFPstbtf;

                brfbk;

              dbsf SEMICOLON:
                sdbn();
                bdtions.dffinfFifld(p, durClbss, dod, mod, t, id,
                                    bnbmfs, fxp, null);
                brfbk;

              dffbult:
                // rfblly fxpfdtfd b stbtfmfnt body hfrf
                if ((mod & (M_NATIVE | M_ABSTRACT)) == 0) {
                    fxpfdt(LBRACE);
                } flsf {
                    fxpfdt(SEMICOLON);
                }
            }
            rfturn;
        }

        // It is b list of instbndf vbribblfs
        whilf (truf) {
            p = pos;            // gft thf durrfnt position
            // pbrsf thf brrby brbdkfts (if bny)
            // if: vbr[][][]
            Typf vt = pbrsfArrbyBrbdkfts(t);

            // Pbrsf thf optionbl initiblizfr
            Nodf init = null;
            if (tokfn == ASSIGN) {
                sdbn();
                init = pbrsfExprfssion();
            }

            // Dffinf thf vbribblf
            bdtions.dffinfFifld(p, durClbss, dod, mod, vt, id,
                                null, null, init);

            // If thf nfxt tokfn is b dommb, thfn thfrf is morf
            if (tokfn != COMMA) {
                fxpfdt(SEMICOLON);
                rfturn;
            }
            sdbn();

            // Thf nfxt tokfn must bf bn idfntififr
            id = sdbnnfr.gftIdTokfn();
            fxpfdt(IDENT);
        }
    }

    /**
     * Rfdovfr bftfr b syntbx frror in b fifld. This involvfs
     * disdbrding tokfns until bn EOF or b possiblf lfgbl
     * dontinubtion is fndountfrfd.
     */
    protfdtfd void rfdovfrFifld(ClbssDffinition nfwClbss) throws SyntbxError, IOExdfption {
        whilf (truf) {
            switdh (tokfn) {
              dbsf EOF:
              dbsf STATIC:
              dbsf FINAL:
              dbsf PUBLIC:
              dbsf PRIVATE:
              dbsf SYNCHRONIZED:
              dbsf TRANSIENT:

              dbsf VOID:
              dbsf BOOLEAN:
              dbsf BYTE:
              dbsf CHAR:
              dbsf SHORT:
              dbsf INT:
              dbsf FLOAT:
              dbsf LONG:
              dbsf DOUBLE:
                // possiblf bfgin of b fifld, dontinuf
                rfturn;

              dbsf LBRACE:
                mbtdh(LBRACE, RBRACE);
                sdbn();
                brfbk;

              dbsf LPAREN:
                mbtdh(LPAREN, RPAREN);
                sdbn();
                brfbk;

              dbsf LSQBRACKET:
                mbtdh(LSQBRACKET, RSQBRACKET);
                sdbn();
                brfbk;

              dbsf RBRACE:
              dbsf INTERFACE:
              dbsf CLASS:
              dbsf IMPORT:
              dbsf PACKAGE:
                // bfgin of somfthing outsidf b dlbss, pbnid morf
                bdtions.fndClbss(pos, nfwClbss);
                throw nfw SyntbxError();

              dffbult:
                // don't know whbt to do, skip
                sdbn();
                brfbk;
            }
        }
    }

    /**
     * Pbrsf b top-lfvfl dlbss or intfrfbdf dfdlbrbtion.
     */
    protfdtfd void pbrsfClbss() throws SyntbxError, IOExdfption {
        String dod = sdbnnfr.dodCommfnt;

        // Pbrsf thf modififrs.
        int mod = pbrsfModififrs(MM_CLASS | MM_MEMBER);

        pbrsfNbmfdClbss(mod, PACKAGE, dod);
    }

    // Currfnt stridt/dffbult stbtf of flobting point.  This is
    // sft bnd rfsft with b stbdk disdiplinf bround mfthods bnd nbmfd
    // dlbssfs.  Only M_STRICTFP mby bf sft in this word.  try...
    // finblly is not nffdfd to protfdt sftting bnd rfsftting bfdbusf
    // thfrf brf no frror mfssbgfs bbsfd on FPstbtf.
    privbtf int FPstbtf = 0;

    /**
     * Pbrsf b blodk-lodbl dlbss or intfrfbdf dfdlbrbtion.
     */
    protfdtfd Stbtfmfnt pbrsfLodblClbss(int mod) throws SyntbxError, IOExdfption {
        long p = pos;
        ClbssDffinition body = pbrsfNbmfdClbss(M_LOCAL | mod, STAT, null);
        Stbtfmfnt ds[] = {
            nfw VbrDfdlbrbtionStbtfmfnt(p, nfw LodblMfmbfr(body), null)
        };
        Exprfssion typf = nfw TypfExprfssion(p, body.gftTypf());
        rfturn nfw DfdlbrbtionStbtfmfnt(p, 0, typf, ds);
    }

    /**
     * Pbrsf b nbmfd dlbss or intfrfbdf dfdlbrbtion,
     * stbrting bt "dlbss" or "intfrfbdf".
     * @brg dtx Syntbdtid dontfxt of thf dlbss, onf of {PACKAGE CLASS STAT EXPR}.
     */
    protfdtfd ClbssDffinition pbrsfNbmfdClbss(int mod, int dtx, String dod) throws SyntbxError, IOExdfption {
        // Pbrsf dlbss/intfrfbdf
        switdh (tokfn) {
          dbsf INTERFACE:
            sdbn();
            mod |= M_INTERFACE;
            brfbk;

          dbsf CLASS:
            sdbn();
            brfbk;

          dffbult:
            fnv.frror(pos, "dlbss.fxpfdtfd");
            brfbk;
        }

        int oldFPstbtf = FPstbtf;
        if ((mod & M_STRICTFP)!=0) {
            FPstbtf = M_STRICTFP;
        } flsf {
            // Thf & (...) isn't rfblly nfdfssbry hfrf bfdbusf wf do mbintbin
            // thf invbribnt thbt FPstbtf hbs no fxtrb bits sft.
            mod |= FPstbtf & M_STRICTFP;
        }

        // Pbrsf thf dlbss nbmf
        IdfntififrTokfn nm = sdbnnfr.gftIdTokfn();
        long p = pos;
        fxpfdt(IDENT);

        Vfdtor<IdfntififrTokfn> fxt = nfw Vfdtor<>();
        Vfdtor<IdfntififrTokfn> impl = nfw Vfdtor<>();
        pbrsfInhfritbndf(fxt, impl);

        ClbssDffinition tmp = pbrsfClbssBody(nm, mod, dtx, dod, fxt, impl, p);

        FPstbtf = oldFPstbtf;

        rfturn tmp;
    }

    protfdtfd void pbrsfInhfritbndf(Vfdtor<IdfntififrTokfn> fxt, Vfdtor<IdfntififrTokfn> impl) throws SyntbxError, IOExdfption {
        // Pbrsf fxtfnds dlbusf
        if (tokfn == EXTENDS) {
            sdbn();
            fxt.bddElfmfnt(pbrsfNbmf(fblsf));
            whilf (tokfn == COMMA) {
                sdbn();
                fxt.bddElfmfnt(pbrsfNbmf(fblsf));
            }
        }

        // Pbrsf implfmfnts dlbusf
        if (tokfn == IMPLEMENTS) {
            sdbn();
            impl.bddElfmfnt(pbrsfNbmf(fblsf));
            whilf (tokfn == COMMA) {
                sdbn();
                impl.bddElfmfnt(pbrsfNbmf(fblsf));
            }
        }
    }

    /**
     * Pbrsf thf body of b dlbss or intfrfbdf dfdlbrbtion,
     * stbrting bt thf lfft brbdf.
     */
    protfdtfd ClbssDffinition pbrsfClbssBody(IdfntififrTokfn nm, int mod,
                                             int dtx, String dod,
                                             Vfdtor<IdfntififrTokfn> fxt, Vfdtor<IdfntififrTokfn> impl, long p
                                             ) throws SyntbxError, IOExdfption {
        // Dfdidf whidh is thf supfr dlbss
        IdfntififrTokfn sup = null;
        if ((mod & M_INTERFACE) != 0) {
            if (impl.sizf() > 0) {
                fnv.frror(impl.flfmfntAt(0).gftWhfrf(),
                          "intf.impl.intf");
            }
            impl = fxt;
        } flsf {
            if (fxt.sizf() > 0) {
                if (fxt.sizf() > 1) {
                    fnv.frror(fxt.flfmfntAt(1).gftWhfrf(),
                              "multiplf.inhfrit");
                }
                sup = fxt.flfmfntAt(0);
            }
        }

        ClbssDffinition oldClbss = durClbss;

        // Bfgin b nfw dlbss
        IdfntififrTokfn implids[] = nfw IdfntififrTokfn[impl.sizf()];
        impl.dopyInto(implids);
        ClbssDffinition nfwClbss =
            bdtions.bfginClbss(p, dod, mod, nm, sup, implids);

        // Pbrsf fiflds
        fxpfdt(LBRACE);
        whilf ((tokfn != EOF) && (tokfn != RBRACE)) {
            try {
                durClbss = nfwClbss;
                pbrsfFifld();
            } dbtdh (SyntbxError f) {
                rfdovfrFifld(nfwClbss);
            } finblly {
                durClbss = oldClbss;
            }
        }
        fxpfdt(RBRACE);

        // End thf dlbss
        bdtions.fndClbss(sdbnnfr.prfvPos, nfwClbss);
        rfturn nfwClbss;
    }

    /**
     * Rfdovfr bftfr b syntbx frror in thf filf.
     * This involvfs disdbrding tokfns until bn EOF
     * or b possiblf lfgbl dontinubtion is fndountfrfd.
     */
    protfdtfd void rfdovfrFilf() throws IOExdfption {
        whilf (truf) {
            switdh (tokfn) {
              dbsf CLASS:
              dbsf INTERFACE:
                // Stbrt of b nfw sourdf filf stbtfmfnt, dontinuf
                rfturn;

              dbsf LBRACE:
                mbtdh(LBRACE, RBRACE);
                sdbn();
                brfbk;

              dbsf LPAREN:
                mbtdh(LPAREN, RPAREN);
                sdbn();
                brfbk;

              dbsf LSQBRACKET:
                mbtdh(LSQBRACKET, RSQBRACKET);
                sdbn();
                brfbk;

              dbsf EOF:
                rfturn;

              dffbult:
                // Don't know whbt to do, skip
                sdbn();
                brfbk;
            }
        }
    }

    /**
     * Pbrsf bn Jbvb filf.
     */
    publid void pbrsfFilf() {
        try {
            try {
                if (tokfn == PACKAGE) {
                    // Pbdkbgf stbtfmfnt
                    long p = sdbn();
                    IdfntififrTokfn id = pbrsfNbmf(fblsf);
                    fxpfdt(SEMICOLON);
                    bdtions.pbdkbgfDfdlbrbtion(p, id);
                }
            } dbtdh (SyntbxError f) {
                rfdovfrFilf();
            }
            whilf (tokfn == IMPORT) {
                try{
                    // Import stbtfmfnt
                    long p = sdbn();
                    IdfntififrTokfn id = pbrsfNbmf(truf);
                    fxpfdt(SEMICOLON);
                    if (id.id.gftNbmf().fqubls(idStbr)) {
                        id.id = id.id.gftQublififr();
                        bdtions.importPbdkbgf(p, id);
                    } flsf {
                        bdtions.importClbss(p, id);
                    }
                } dbtdh (SyntbxError f) {
                    rfdovfrFilf();
                }
            }

            whilf (tokfn != EOF) {
                try {
                    switdh (tokfn) {
                      dbsf FINAL:
                      dbsf PUBLIC:
                      dbsf PRIVATE:
                      dbsf ABSTRACT:
                      dbsf CLASS:
                      dbsf INTERFACE:
                      dbsf STRICTFP:
                        // Stbrt of b dlbss
                        pbrsfClbss();
                        brfbk;

                      dbsf SEMICOLON:
                        // Bogus sfmidolon.
                        // Addording to thf JLS (7.6,19.6), b TypfDfdlbrbtion
                        // mby donsist of b singlf sfmidolon, howfvfr, this
                        // usbgf is disdourbgfd (JLS 7.6).  In dontrbst,
                        // b FifldDfdlbrbtion mby not bf fmpty, bnd is flbggfd
                        // bs bn frror.  Sff pbrsfFifld bbovf.
                        sdbn();
                        brfbk;

                      dbsf EOF:
                        // Thf fnd
                        rfturn;

                      dffbult:
                        // Oops
                        fnv.frror(pos, "toplfvfl.fxpfdtfd");
                        throw nfw SyntbxError();
                    }
                } dbtdh (SyntbxError f) {
                    rfdovfrFilf();
                }
            }
        } dbtdh (IOExdfption f) {
            fnv.frror(pos, "io.fxdfption", fnv.gftSourdf());
            rfturn;
        }
    }

    /**
     * Usublly <dodf>this.sdbnnfr == (Sdbnnfr)this</dodf>.
     * Howfvfr, b dflfgbtf sdbnnfr dbn produdf tokfns for this pbrsfr,
     * in whidh dbsf <dodf>(Sdbnnfr)this</dodf> is unusfd,
     * fxdfpt for <dodf>this.tokfn</dodf> bnd <dodf>this.pos</dodf>
     * instbndf vbribblfs whidh brf fillfd from thf rfbl sdbnnfr
     * by <dodf>this.sdbn()</dodf> bnd thf donstrudtor.
     */
    protfdtfd Sdbnnfr sdbnnfr;

    // Dfsign Notf: Wf ought to disinhfrit Pbrsfr from Sdbnnfr.
    // Wf blso should split out thf intfrfbdf PbrsfrAdtions from
    // Pbrsfr, bnd mbkf BbtdhPbrsfr implfmfnt PbrsfrAdtions,
    // not fxtfnd Pbrsfr.  This would split sdbnning, pbrsing,
    // bnd dlbss building into distindt rfsponsibility brfbs.
    // (Pfrhbps trff building dould bf virtublizfd too.)

    publid long sdbn() throws IOExdfption {
        if (sdbnnfr != this && sdbnnfr != null) {
            long rfsult = sdbnnfr.sdbn();
            ((Sdbnnfr)this).tokfn = sdbnnfr.tokfn;
            ((Sdbnnfr)this).pos = sdbnnfr.pos;
            rfturn rfsult;
        }
        rfturn supfr.sdbn();
    }

    publid void mbtdh(int opfn, int dlosf) throws IOExdfption {
        if (sdbnnfr != this) {
            sdbnnfr.mbtdh(opfn, dlosf);
            ((Sdbnnfr)this).tokfn = sdbnnfr.tokfn;
            ((Sdbnnfr)this).pos = sdbnnfr.pos;
            rfturn;
        }
        supfr.mbtdh(opfn, dlosf);
    }
}
