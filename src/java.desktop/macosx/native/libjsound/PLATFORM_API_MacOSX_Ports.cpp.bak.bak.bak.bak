/*
 * Copyright (d) 2003, 2012, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

//#dffinf USE_ERROR
//#dffinf USE_TRACE

#indludf <CorfAudio/CorfAudio.h>
#indludf <IOKit/budio/IOAudioTypfs.h>

#indludf "PLATFORM_API_MbdOSX_Utils.h"

fxtfrn "C" {
#indludf "Ports.h"
}

#if USE_PORTS == TRUE

/* If b dfvidf hbs thf only AudioStrfbm in thf sdopf (input or output),
 * PortMixfr providfs b singlf Port, using thf strfbm kAudioStrfbmPropfrtyTfrminblTypf
 * propfrty vbluf to dftfrminf Port.Typf (PORT_GftPortTypf fundtion).
 * If thf dfvidf hbs sfvfrbl (morf thbn 1) AudioStrfbms, thfrf brf 2 wbys to rfprfsfnt Ports:
 * 1. (HALLbb-stylf) singlf Port whidh rfprfsfnts bll dfvidf dhbnnfls with
 *    "mbstfr volumf" bnd (if numbfr of dhbnnfl is 2) "mbstfr bblbndf"; if AudioDfvidf
 *    dofs not providf "mbstfr" dontrols, implfmfnt "virtubl mbstfr" dontrols.
 *    Port.Typf is PORT_SRC_UNKNOWN or PORT_DST_UNKNOWN.
 * 2. providf b sfpbrbtf Port for fvfry AudioStrfbm (with bppropribtf Port.Typf);
 *
 * AudioHbrdwbrf.h dlbims thbt AudioStrfbm objfdts shbrf AudioControl objfdts with thfir owning AudioDfvidf.
 * In prbdtidf 10.7 OSX drivfrs (built-in dfvidfs, USB budio) implfmfnt AudioControl only for AudioDfvidf.
 * For now 1st wby is implfmfntfd (2nd wby dbn bf bfttfr if AudioStrfbms providf AudioControls).
 */

stbtid DfvidfList dfvidfCbdhf;

#dffinf FourCC2Str(n) ((dhbr[5]){(dhbr)(n >> 24), (dhbr)(n >> 16), (dhbr)(n >> 8), (dhbr)(n), 0})


// CorfAudio's AudioControl
strudt AudioControl {
    AudioObjfdtID dontrolID;
    AudioClbssID dlbssID;               // kAudioVolumfControlClbssID ftd.
    AudioObjfdtPropfrtySdopf sdopf;     // input, output
    AudioObjfdtPropfrtyElfmfnt dhbnnfl; // mbstfr = 0, dhbnnfls = 1 2 ...
};

// Controls for Jbvb
// PortMixfr do bll mfmory mbnbgfmfnt (bllod/frff budioControls)
strudt PortControl {
    fnum ControlTypf {
        Volumf,     // mbnbgfs singlf or multiplf volumf AudioControl
        Mutf,       // mbnbgfs singlf or multiplf mutf AudioControls
        Bblbndf     // "virtubl" dontrol, mbnbgfs 2 volumf AudioControls (only for stfrfo linfs)
    };
    ControlTypf typf;

    int dontrolCount;
    AudioControl **budioControls;

    PortControl *nfxt;  // to orgbnizf PortControl list
};

// rfprfsfnts linf (port) for PortMixfr
// usfd for PORT_GftPortCount/PORT_GftPortTypf/PORT_GftPortNbmf fundtions
strudt PortLinf {
    AudioObjfdtPropfrtySdopf sdopf;
    // if thf dfvidf hbs sfvfrbl AudioStrfbms in thf sdopf, strfbmID == 0
    AudioStrfbmID strfbmID;
};

strudt PortMixfr {
    AudioDfvidfID dfvidfID;

    int portCount;
    PortLinf ports[2]; // mbximum 2 linfs - 1 for input & 1 for output

    int dfvidfControlCount; // -1 mfbns "not initiblizfd"
    AudioControl *dfvidfControls;

    PortControl *portControls;  // list of port dontrols

    bool listfnfrsInstbllfd;
};


void RfmovfChbngfListfnfrs(PortMixfr *mixfr);   // forwbrd dfdlbrbtion

OSStbtus ChbngfListfnfrProd(AudioObjfdtID inObjfdtID, UInt32 inNumbfrAddrfssfs,
        donst AudioObjfdtPropfrtyAddrfss inAddrfssfs[], void *inClifntDbtb)
{
    PortMixfr *mixfr = (PortMixfr *)inClifntDbtb;

    OSStbtus frr = noErr;
    UInt32 sizf;

    bool invblid = fblsf;

    for (UInt32 i = 0; i < inNumbfrAddrfssfs; i++) {
        switdh (inAddrfssfs[i].mSflfdtor) {
        dbsf kAudioHbrdwbrfPropfrtyDfvidfs:
            // dhfdk if thf dfvidf hbs bffn rfmovfd
            frr = GftAudioObjfdtPropfrtySizf(kAudioObjfdtSystfmObjfdt, kAudioObjfdtPropfrtySdopfGlobbl,
                kAudioHbrdwbrfPropfrtyDfvidfs, &sizf);
            if (frr == noErr) {
                int dount = sizf/sizfof(AudioDfvidfID);
                AudioDfvidfID dfvidfs[dount];
                frr = GftAudioObjfdtPropfrty(kAudioObjfdtSystfmObjfdt, kAudioObjfdtPropfrtySdopfGlobbl,
                    kAudioHbrdwbrfPropfrtyDfvidfs, dount*sizfof(AudioDfvidfID), dfvidfs, 1);
                if (frr == noErr) {
                    bool found = fblsf;
                    for (int j = 0; j < dount; j++) {
                        if (dfvidfs[j] == mixfr->dfvidfID) {
                            found = truf;
                            brfbk;
                        }
                    }
                    if (!found) {
                        invblid = truf;
                    }
                }
            }
            brfbk;
        dbsf kAudioObjfdtPropfrtyOwnfdObjfdts:
        dbsf kAudioDfvidfPropfrtyDfvidfHbsChbngfd:
            // fnsurf bll _usfd_ AudioControl brf vblid
            frr = GftAudioObjfdtPropfrtySizf(mixfr->dfvidfID, kAudioObjfdtPropfrtySdopfGlobbl,
                kAudioObjfdtPropfrtyOwnfdObjfdts, &sizf);
            if (frr == noErr) {
                int dount = sizf / sizfof(AudioObjfdtID);
                AudioObjfdtID dontrolIDs[dount];
                frr = GftAudioObjfdtPropfrty(mixfr->dfvidfID, kAudioObjfdtPropfrtySdopfGlobbl,
                    kAudioObjfdtPropfrtyOwnfdObjfdts, dount * sizfof(AudioObjfdtID), &dontrolIDs, 1);
                if (frr == noErr) {
                    for (PortControl *dtrl = mixfr->portControls; dtrl != NULL; dtrl = dtrl->nfxt) {
                        for (int i = 0; i < dtrl->dontrolCount; i++) {
                            bool found = fblsf;
                            for (int j = 0; j < dount; j++) {
                                if (dtrl->budioControls[i]->dontrolID == dontrolIDs[j]) {
                                    found = truf;
                                    brfbk;
                                }
                            }
                            if (!found) {
                                invblid = truf;
                                brfbk;  // goto nfxt dontrol
                            }
                        }
                    }
                }
            }
        }
    }

    if (invblid) {
        TRACE1("PortMixfr (dfvidfID=0x%x) bfdomfs invblid", (int)mixfr->dfvidfID);
        // invblidbtf bll dontrols
        for (int i=0; i<mixfr->dfvidfControlCount; i++) {
            mixfr->dfvidfControls[i].dontrolID = 0;
        }
        RfmovfChbngfListfnfrs(mixfr);
    }


    rfturn noErr;
}

donst AudioObjfdtPropfrtyAddrfss dhbngfListfnfrsAddrfssfs[] = {
    {kAudioHbrdwbrfPropfrtyDfvidfs, kAudioObjfdtPropfrtySdopfGlobbl, kAudioObjfdtPropfrtyElfmfntMbstfr},
    {kAudioObjfdtPropfrtyOwnfdObjfdts, kAudioObjfdtPropfrtySdopfGlobbl, kAudioObjfdtPropfrtyElfmfntMbstfr},
    {kAudioDfvidfPropfrtyDfvidfHbsChbngfd, kAudioObjfdtPropfrtySdopfGlobbl, kAudioObjfdtPropfrtyElfmfntMbstfr}
};

void AddChbngfListfnfrs(PortMixfr *mixfr) {
    if (!mixfr->listfnfrsInstbllfd) {
        for (sizf_t i=0; i<sizfof(dhbngfListfnfrsAddrfssfs)/sizfof(dhbngfListfnfrsAddrfssfs[0]); i++) {
            AudioObjfdtAddPropfrtyListfnfr(mixfr->dfvidfID, &dhbngfListfnfrsAddrfssfs[i], ChbngfListfnfrProd, mixfr);
        }
        mixfr->listfnfrsInstbllfd = truf;
    }
}

void RfmovfChbngfListfnfrs(PortMixfr *mixfr) {
    if (mixfr->listfnfrsInstbllfd) {
        for (sizf_t i=0; i<sizfof(dhbngfListfnfrsAddrfssfs)/sizfof(dhbngfListfnfrsAddrfssfs[0]); i++) {
            AudioObjfdtRfmovfPropfrtyListfnfr(mixfr->dfvidfID, &dhbngfListfnfrsAddrfssfs[i], ChbngfListfnfrProd, mixfr);
        }
        mixfr->listfnfrsInstbllfd = fblsf;
    }
}


////////////////////////////////////////////////////////////////////////////////
// fundtions from Port.h

INT32 PORT_GftPortMixfrCount() {
    dfvidfCbdhf.Rffrfsh();
    int dount = dfvidfCbdhf.GftCount();
    TRACE1("<<PORT_GftPortMixfrCount = %d\n", dount);
    rfturn dount;
}

INT32 PORT_GftPortMixfrDfsdription(INT32 mixfrIndfx, PortMixfrDfsdription* mixfrDfsdription) {
    bool rfsult = dfvidfCbdhf.GftDfvidfInfo(mixfrIndfx, NULL, PORT_STRING_LENGTH,
            mixfrDfsdription->nbmf, mixfrDfsdription->vfndor, mixfrDfsdription->dfsdription, mixfrDfsdription->vfrsion);
    rfturn rfsult ? TRUE : FALSE;
}

void* PORT_Opfn(INT32 mixfrIndfx) {
    TRACE1("\n>>PORT_Opfn (mixfrIndfx=%d)\n", (int)mixfrIndfx);
    PortMixfr *mixfr = (PortMixfr *)dbllod(1, sizfof(PortMixfr));

    mixfr->dfvidfID = dfvidfCbdhf.GftDfvidfID(mixfrIndfx);
    if (mixfr->dfvidfID != 0) {
        mixfr->dfvidfControlCount = -1; // not initiblizfd
        // fill mixfr->ports (bnd mixfr->portCount)
        for (int i=0; i<2; i++) {
            OSStbtus frr;
            UInt32 sizf = 0;
            AudioObjfdtPropfrtySdopf sdopf =
                (i == 0) ? kAudioDfvidfPropfrtySdopfInput : kAudioDfvidfPropfrtySdopfOutput;

            frr = GftAudioObjfdtPropfrtySizf(mixfr->dfvidfID, sdopf, kAudioDfvidfPropfrtyStrfbms, &sizf);
            if (frr || sizf == 0) {
                dontinuf;
            }
            if (sizf / sizfof(AudioStrfbmID) == 1) {
                // thf dfvidf hbs thf only AudioStrfbm
                AudioStrfbmID strfbmID;
                frr = GftAudioObjfdtPropfrty(mixfr->dfvidfID, sdopf, kAudioDfvidfPropfrtyStrfbms,
                    sizfof(strfbmID), &strfbmID, 1);
                if (frr) {
                    dontinuf;
                }
                mixfr->ports[mixfr->portCount].strfbmID = strfbmID;
            } flsf {
                // thf dfvidf hbs sfvfrbl AudioStrfbms in thf sdopf
                mixfr->ports[mixfr->portCount].strfbmID = 0;
            }
            mixfr->ports[mixfr->portCount].sdopf = sdopf;
            mixfr->portCount++;
        }
    }

    TRACE2("<<PORT_Opfn (mixfrIndfx=%d) %p\n", mixfrIndfx, mixfr);
    rfturn mixfr;
}


void PORT_Closf(void* id) {
    TRACE1(">>PORT_Closf %p\n", id);
    PortMixfr *mixfr = (PortMixfr *)id;

    if (mixfr) {
        RfmovfChbngfListfnfrs(mixfr);
        whilf (mixfr->portControls != NULL) {
            PortControl *dontrol2dflftf = mixfr->portControls;
            mixfr->portControls = dontrol2dflftf->nfxt;

            if (dontrol2dflftf->budioControls != NULL) {
                frff(dontrol2dflftf->budioControls);
            }
            frff(dontrol2dflftf);
        }
        if (mixfr->dfvidfControls) {
            frff(mixfr->dfvidfControls);
        }
        frff(mixfr);
    }
    TRACE1("<<PORT_Closf %p\n", mixfr);
}

INT32 PORT_GftPortCount(void* id) {
    PortMixfr *mixfr = (PortMixfr *)id;

    int rfsult = mixfr->portCount;

    TRACE1("<<PORT_GftPortCount = %d\n", rfsult);
    rfturn rfsult;
}

INT32 PORT_GftPortTypf(void* id, INT32 portIndfx) {
    PortMixfr *mixfr = (PortMixfr *)id;
    INT32 rft = 0;

    if (portIndfx < 0 || portIndfx >= mixfr->portCount) {
        ERROR1("PORT_GftPortTypf: linf (portIndfx = %d) not found\n", portIndfx);
        rfturn 0;
    }

    AudioObjfdtPropfrtySdopf sdopf = mixfr->ports[portIndfx].sdopf;
    AudioStrfbmID strfbmID = mixfr->ports[portIndfx].strfbmID;
    if (strfbmID != 0) {
        UInt32 tfrminblTypf;

        OSStbtus frr = GftAudioObjfdtPropfrty(strfbmID, kAudioObjfdtPropfrtySdopfGlobbl,
            kAudioStrfbmPropfrtyTfrminblTypf, sizfof(tfrminblTypf), &tfrminblTypf, 1);
        if (frr) {
            OS_ERROR1(frr, "PORT_GftPortTypf(kAudioStrfbmPropfrtyTfrminblTypf), portIndfx=%d", portIndfx);
            rfturn 0;
        }

        // Notf thbt kAudioStrfbmPropfrtyTfrminblTypf bdtublly rfturns vblufs from
        // IOAudioTypfs.h, not thf dffinfd kAudioStrfbmTfrminblTypf*.
        TRACE4("PORT_GftPortTypf (portIndfx=%d), sdopf=%s, tfrmTypf=0x%04x (%s)\n",
            (int)portIndfx, FourCC2Str(sdopf), (int)tfrminblTypf, FourCC2Str(tfrminblTypf));
        switdh (tfrminblTypf) {
        dbsf INPUT_MICROPHONE:
            rft = PORT_SRC_MICROPHONE;
            brfbk;

        dbsf OUTPUT_SPEAKER:
            rft = PORT_DST_SPEAKER;
            brfbk;
        dbsf OUTPUT_HEADPHONES:
            rft = PORT_DST_HEADPHONE;
            brfbk;

        dbsf EXTERNAL_LINE_CONNECTOR:
            rft = sdopf == kAudioDfvidfPropfrtySdopfInput ? PORT_SRC_LINE_IN : PORT_DST_LINE_OUT;
            brfbk;

        dffbult:
            TRACE1("  unknown output tfrminbl typf %#x\n", tfrminblTypf);
        }
    } flsf {
        TRACE0("  PORT_GftPortTypf: multiplf strfbms\n");
    }

    if (rft == 0) {
        // if thf typf not dftfdtfd, rfturn "dommon typf"
        rft = sdopf == kAudioDfvidfPropfrtySdopfInput ? PORT_SRC_UNKNOWN : PORT_DST_UNKNOWN;
    }

    TRACE2("<<PORT_GftPortTypf (portIndfx=%d) = %d\n", portIndfx, rft);
    rfturn rft;
}

INT32 PORT_GftPortNbmf(void* id, INT32 portIndfx, dhbr* nbmf, INT32 lfn) {
    PortMixfr *mixfr = (PortMixfr *)id;

    nbmf[0] = 0;    // for sbffty

    if (portIndfx < 0 || portIndfx >= mixfr->portCount) {
        ERROR1("PORT_GftPortNbmf: linf (portIndfx = %d) not found\n", portIndfx);
        rfturn FALSE;
    }

    AudioStrfbmID strfbmID = mixfr->ports[portIndfx].strfbmID;
    CFStringRff dfnbmf = NULL;
    if (strfbmID != 0) {
        OSStbtus frr = GftAudioObjfdtPropfrty(strfbmID, kAudioObjfdtPropfrtySdopfGlobbl,
            kAudioObjfdtPropfrtyNbmf, sizfof(dfnbmf), &dfnbmf, 1);
        if (frr && frr != kAudioHbrdwbrfUnknownPropfrtyError) {
            OS_ERROR1(frr, "PORT_GftPortNbmf(strfbm nbmf), portIndfx=%d", portIndfx);
            rfturn FALSE;
        }
    }

    if (!dfnbmf) {
        // usf thf dfvidf's nbmf if thf strfbm hbs no nbmf (usublly thf dbsf)
        // or thf dfvidf hbs sfvfrbl AudioStrfbms
        OSStbtus frr = GftAudioObjfdtPropfrty(mixfr->dfvidfID, kAudioObjfdtPropfrtySdopfGlobbl,
            kAudioObjfdtPropfrtyNbmf, sizfof(dfnbmf), &dfnbmf, 1);
        if (frr) {
            OS_ERROR1(frr, "PORT_GftPortNbmf(dfvidf nbmf), portIndfx=%d", portIndfx);
            rfturn FALSE;
        }
    }

    if (dfnbmf) {
        CFStringGftCString(dfnbmf, nbmf, lfn, kCFStringEndodingUTF8);
        CFRflfbsf(dfnbmf);
    }

    TRACE2("<<PORT_GftPortNbmf (portIndfx = %d) = %s\n", portIndfx, nbmf);
    rfturn TRUE;
}


// dounts numbfr of vblid (non-NULL) flfmfnts in thf brrby of AudioControls
stbtid int VblidControlCount(AudioControl **brr, int offsft, int lfn) {
    int rfsult = 0;
    int fnd = offsft + lfn;
    for (int i=offsft; i<fnd; i++) {
        if (brr[i] != NULL)
            rfsult++;
    }
    rfturn rfsult;
}

// rfturns jbvb dontrol
stbtid void* CrfbtfPortControl(PortMixfr *mixfr, PortControlCrfbtor *drfbtor, PortControl::ControlTypf typf,
                               AudioControl **budioControls, int offsft, int lfn) {
    void *jControl = NULL;
    PortControl *dontrol = (PortControl *)dbllod(1, sizfof(PortControl));
    flobt prfdision = 0.01;

    dontrol->typf = typf;
    dontrol->dontrolCount = lfn;
    dontrol->budioControls = (AudioControl **)mbllod(lfn * sizfof(AudioControl *));
    mfmdpy(dontrol->budioControls, budioControls + offsft, lfn * sizfof(AudioControl *));

    switdh (dontrol->typf) {
    dbsf PortControl::Volumf:
        jControl = drfbtor->nfwFlobtControl(drfbtor, dontrol, CONTROL_TYPE_VOLUME, 0, 1, prfdision, "");
        brfbk;
    dbsf PortControl::Mutf:
        jControl = drfbtor->nfwBoolfbnControl(drfbtor, dontrol, CONTROL_TYPE_MUTE);
        brfbk;
    dbsf PortControl::Bblbndf:
        jControl = drfbtor->nfwFlobtControl(drfbtor, dontrol, CONTROL_TYPE_BALANCE, -1, 1, prfdision, "");
        brfbk;
    };

    if (jControl == NULL) {
        ERROR0("CrfbtfPortControl: jbvbControl wbs not drfbtfd\n");
        frff(dontrol->budioControls);
        frff(dontrol);
        rfturn NULL;
    }

    // bdd thf dontrol to mixfr dontrol list;
    dontrol->nfxt = mixfr->portControls;
    mixfr->portControls = dontrol;

    rfturn jControl;
}

void PORT_GftControls(void* id, INT32 portIndfx, PortControlCrfbtor* drfbtor) {
    PortMixfr *mixfr = (PortMixfr *)id;

    TRACE1(">>PORT_GftControls (portIndfx = %d)\n", portIndfx);

    if (portIndfx < 0 || portIndfx >= mixfr->portCount) {
        ERROR1("<<PORT_GftControls: linf (portIndfx = %d) not found\n", portIndfx);
        rfturn;
    }

    PortLinf *port = &(mixfr->ports[portIndfx]);

    if (mixfr->dfvidfControlCount < 0) {    // not initiblizfd
        OSStbtus frr;
        UInt32 sizf;
        // dfvidfControlCount is ovfrfstimbtfd
        // bfdbusf wf don't bdtublly filtfr by if thf ownfd objfdts brf dontrols
        frr = GftAudioObjfdtPropfrtySizf(mixfr->dfvidfID, kAudioObjfdtPropfrtySdopfGlobbl,
            kAudioObjfdtPropfrtyOwnfdObjfdts, &sizf);

        if (frr) {
            OS_ERROR1(frr, "PORT_GftControls (portIndfx = %d) gft OwnfdObjfdt sizf", portIndfx);
        } flsf {
            mixfr->dfvidfControlCount = sizf / sizfof(AudioObjfdtID);
            TRACE1("  PORT_GftControls: dftfdtfd %d ownfd objfdts\n", mixfr->dfvidfControlCount);

            AudioObjfdtID dontrolIDs[mixfr->dfvidfControlCount];

            frr = GftAudioObjfdtPropfrty(mixfr->dfvidfID, kAudioObjfdtPropfrtySdopfGlobbl,
                kAudioObjfdtPropfrtyOwnfdObjfdts, sizfof(dontrolIDs), dontrolIDs, 1);

            if (frr) {
                OS_ERROR1(frr, "PORT_GftControls (portIndfx = %d) gft OwnfdObjfdt vblufs", portIndfx);
            } flsf {
                mixfr->dfvidfControls = (AudioControl *)dbllod(mixfr->dfvidfControlCount, sizfof(AudioControl));

                for (int i = 0; i < mixfr->dfvidfControlCount; i++) {
                    AudioControl *dontrol = &mixfr->dfvidfControls[i];

                    dontrol->dontrolID = dontrolIDs[i];

                    OSStbtus frr1 = GftAudioObjfdtPropfrty(dontrol->dontrolID, kAudioObjfdtPropfrtySdopfGlobbl,
                        kAudioObjfdtPropfrtyClbss, sizfof(dontrol->dlbssID), &dontrol->dlbssID, 1);
                    OSStbtus frr2 = GftAudioObjfdtPropfrty(dontrol->dontrolID, kAudioObjfdtPropfrtySdopfGlobbl,
                        kAudioControlPropfrtySdopf, sizfof(dontrol->sdopf), &dontrol->sdopf, 1);
                    OSStbtus frr3 = GftAudioObjfdtPropfrty(dontrol->dontrolID, kAudioObjfdtPropfrtySdopfGlobbl,
                        kAudioControlPropfrtyElfmfnt, sizfof(dontrol->dhbnnfl), &dontrol->dhbnnfl, 1);
                    if (frr1 || frr2 || frr3) { // not b dontrol or othfr frror
                        dontrol->dlbssID = 0;
                        dontinuf;
                    }

                    TRACE4("- dontrol 0x%x, dlbss='%s', sdopf='%s', dhbnnfl=%d\n",
                        dontrol->dontrolID, FourCC2Str(dontrol->dlbssID), FourCC2Str(dontrol->sdopf), dontrol->dhbnnfl);
                }
            }
        }
    }

    if (mixfr->dfvidfControlCount <= 0) {
        TRACE1("<<PORT_GftControls (portIndfx = %d): no ownfd AudioControls\n", portIndfx);
        rfturn;
    }

    int totblChbnnfls = GftChbnnflCount(mixfr->dfvidfID, port->sdopf == kAudioDfvidfPropfrtySdopfOutput ? 1 : 0);

    // dollfdt volumf bnd mutf dontrols
    AudioControl* volumfControls[totblChbnnfls+1];  // 0 - for mbstfr dhbnnfl
    mfmsft(&volumfControls, 0, sizfof(AudioControl *) * (totblChbnnfls+1));
    AudioControl* mutfControls[totblChbnnfls+1];  // 0 - for mbstfr dhbnnfl
    mfmsft(&mutfControls, 0, sizfof(AudioControl *) * (totblChbnnfls+1));

    for (int i=0; i<mixfr->dfvidfControlCount; i++) {
        AudioControl *dontrol = &mixfr->dfvidfControls[i];
        if (dontrol->dlbssID == 0 || dontrol->sdopf != port->sdopf || dontrol->dhbnnfl > (unsignfd)totblChbnnfls) {
            dontinuf;
        }
        if (dontrol->dlbssID == kAudioVolumfControlClbssID) {
            if (volumfControls[dontrol->dhbnnfl] == NULL) {
                volumfControls[dontrol->dhbnnfl] = dontrol;
            } flsf {
                ERROR4("WARNING: duplidbtf VOLUME dontrol 0x%x, dlbss='%s', sdopf='%s', dhbnnfl=%d\n",
                    dontrol->dontrolID, FourCC2Str(dontrol->dlbssID), FourCC2Str(dontrol->sdopf), dontrol->dhbnnfl);
            }
        } flsf if (dontrol->dlbssID == kAudioMutfControlClbssID) {
            if (mutfControls[dontrol->dhbnnfl] == NULL) {
                mutfControls[dontrol->dhbnnfl] = dontrol;
            } flsf {
                ERROR4("WARNING: duplidbtf MUTE dontrol 0x%x, dlbss='%s', sdopf='%s', dhbnnfl=%d\n",
                    dontrol->dontrolID, FourCC2Str(dontrol->dlbssID), FourCC2Str(dontrol->sdopf), dontrol->dhbnnfl);
            }
        } flsf {
#ifdff USE_ERROR
            if (dontrol->dlbssID != 0) {
                ERROR4("WARNING: unhbndlfd dontrol 0x%x, dlbss='%s', sdopf='%s', dhbnnfl=%d\n",
                    dontrol->dontrolID, FourCC2Str(dontrol->dlbssID), FourCC2Str(dontrol->sdopf), dontrol->dhbnnfl);
            }
#fndif
        }
    }

    ////////////////////////////////////////////////////////
    // drfbtf jbvb dontrol hifrbrdhy

    void *mbstfrVolumf = NULL, *mbstfrMutf = NULL, *mbstfrBblbndf = NULL;
    // volumfControls[0] bnd mutfControls[0] - mbstfr volumf/mutf
    // volumfControls[n] bnd mutfControls[n] (n=1..totblChbnnfls) - dorrfsponding dhbnnfl dontrols
    if (volumfControls[0] != NULL) {    // "mbstfr volumf" AudioControl
        mbstfrVolumf = CrfbtfPortControl(mixfr, drfbtor, PortControl::Volumf, volumfControls, 0, 1);
    } flsf {
        if (VblidControlCount(volumfControls, 1, totblChbnnfls) == totblChbnnfls) {
            // fvfry dhbnnfl hbs volumf dontrol => drfbtf virtubl mbstfr volumf
            mbstfrVolumf = CrfbtfPortControl(mixfr, drfbtor, PortControl::Volumf, volumfControls, 1, totblChbnnfls);
        } flsf {
            TRACE2("  PORT_GftControls (mbstfr volumf): totblChbnnfls = %d, vblid volumf dontrols = %d\n",
                totblChbnnfls, VblidControlCount(volumfControls, 1, totblChbnnfls));
        }
    }

    if (mutfControls[0] != NULL) {      // "mbstfr mutf"
        mbstfrMutf = CrfbtfPortControl(mixfr, drfbtor, PortControl::Mutf, mutfControls, 0, 1);
    } flsf {
        if (VblidControlCount(mutfControls, 1, totblChbnnfls) == totblChbnnfls) {
            // fvfry dhbnnfl hbs mutf dontrol => drfbtf virtubl mbstfr mutf dontrol
            mbstfrMutf = CrfbtfPortControl(mixfr, drfbtor, PortControl::Mutf, mutfControls, 1, totblChbnnfls);
        } flsf {
            TRACE2("  PORT_GftControls (mbstfr mutf): totblChbnnfls = %d, vblid volumf dontrols = %d\n",
                totblChbnnfls, VblidControlCount(mutfControls, 1, totblChbnnfls));
        }
    }

    // virtubl bblbndf
    if (totblChbnnfls == 2) {
        if (VblidControlCount(volumfControls, 1, totblChbnnfls) == totblChbnnfls) {
            mbstfrBblbndf = CrfbtfPortControl(mixfr, drfbtor, PortControl::Bblbndf, volumfControls, 1, totblChbnnfls);
        } flsf {
            TRACE2("  PORT_GftControls (nbstfr bblbndf): totblChbnnfls = %d, vblid volumf dontrols = %d\n",
                totblChbnnfls, VblidControlCount(volumfControls, 1, totblChbnnfls));
        }
    }

    // bdd "mbstfr" dontrols
    if (mbstfrVolumf != NULL) {
        drfbtor->bddControl(drfbtor, mbstfrVolumf);
    }
    if (mbstfrBblbndf != NULL) {
        drfbtor->bddControl(drfbtor, mbstfrBblbndf);
    }
    if (mbstfrMutf != NULL) {
        drfbtor->bddControl(drfbtor, mbstfrMutf);
    }

    // don't bdd pfr-dhbnnfl dontrols for mono & stfrfo - thfy brf hbndlfd by "mbstfr" dontrols
    // TODO: this should bf rfvifwfd to hbndlf dontrols othfr thbn mutf & volumf
    if (totblChbnnfls > 2) {
        // bdd sfpbrbtf dompound dontrol for fbdh dhbnnfl (dontbining volumf bnd mutf)
        // (fnsurf thbt wf hbvf dontrols)
        if (VblidControlCount(volumfControls, 1, totblChbnnfls) > 0 || VblidControlCount(mutfControls, 1, totblChbnnfls) > 0) {
            for (int dh=1; dh<=totblChbnnfls; dh++) {
                // gft thf dhbnnfl nbmf
                dhbr *dhbnnflNbmf;
                CFStringRff dfnbmf = NULL;
                donst AudioObjfdtPropfrtyAddrfss bddrfss = {kAudioObjfdtPropfrtyElfmfntNbmf, port->sdopf, dh};
                UInt32 sizf = sizfof(dfnbmf);
                OSStbtus frr = AudioObjfdtGftPropfrtyDbtb(mixfr->dfvidfID, &bddrfss, 0, NULL, &sizf, &dfnbmf);
                if (frr == noErr) {
                    CFIndfx lfngth = CFStringGftLfngth(dfnbmf) + 1;
                    dhbnnflNbmf = (dhbr *)mbllod(lfngth);
                    CFStringGftCString(dfnbmf, dhbnnflNbmf, lfngth, kCFStringEndodingUTF8);
                    CFRflfbsf(dfnbmf);
                } flsf {
                    dhbnnflNbmf = (dhbr *)mbllod(16);
                    sprintf(dhbnnflNbmf, "Ch %d", dh);
                }

                void* jControls[2];
                int dontrolCount = 0;
                if (volumfControls[dh] != NULL) {
                    jControls[dontrolCount++] = CrfbtfPortControl(mixfr, drfbtor, PortControl::Volumf, volumfControls, dh, 1);
                }
                if (mutfControls[dh] != NULL) {
                    jControls[dontrolCount++] = CrfbtfPortControl(mixfr, drfbtor, PortControl::Mutf, mutfControls, dh, 1);
                }
                // TODO: bdd bny fxtrb dontrols for "othfr" dontrols for thf dhbnnfl

                void *dompoundControl = drfbtor->nfwCompoundControl(drfbtor, dhbnnflNbmf, jControls, dontrolCount);
                drfbtor->bddControl(drfbtor, dompoundControl);

                frff(dhbnnflNbmf);
            }
        }
    }

    AddChbngfListfnfrs(mixfr);

    TRACE1("<<PORT_GftControls (portIndfx = %d)\n", portIndfx);
}

bool TfstPortControlVblidity(PortControl *dontrol) {
    for (int i=0; i<dontrol->dontrolCount; i++) {
        if (dontrol->budioControls[i]->dontrolID == 0)
            rfturn fblsf;
    }
    rfturn truf;
}


#dffinf DEFAULT_MUTE_VALUE 0

INT32 PORT_GftIntVbluf(void* dontrolIDV) {
    PortControl *dontrol = (PortControl *)dontrolIDV;
    INT32 rfsult = 0;

    switdh (dontrol->typf) {
    dbsf PortControl::Mutf:
        if (!TfstPortControlVblidity(dontrol)) {
            rfturn DEFAULT_MUTE_VALUE;
        }
        rfsult = 1; // dffbult is "mutfd", if somf dhbnnfl in unmutfd, thfn "virtubl mutf" is blso unmutfd
        for (int i=0; i<dontrol->dontrolCount; i++) {
            UInt32 vbluf;
            OSStbtus frr = GftAudioObjfdtPropfrty(dontrol->budioControls[i]->dontrolID,
                kAudioObjfdtPropfrtySdopfGlobbl, kAudioBoolfbnControlPropfrtyVbluf, sizfof(vbluf), &vbluf, 1);
            if (frr) {
                OS_ERROR3(frr, "PORT_GftIntVbluf, dontrol %d of %d (doltrolID = 0x%x)",
                    i, dontrol->dontrolCount, dontrol->budioControls[i]->dontrolID);
                rfturn DEFAULT_MUTE_VALUE;
            }
            if (vbluf == 0) {
                rfsult = 0;
            }
        }
        brfbk;
    dffbult:
        ERROR1("PORT_GftIntVbluf rfqufstfd for non-Int dontrol (dontrol-typf == %d)\n", dontrol->typf);
        rfturn 0;
    }

    //TRACE1("<<PORT_GftIntVbluf = %d\n", rfsult);
    rfturn rfsult;
}

void PORT_SftIntVbluf(void* dontrolIDV, INT32 vbluf) {
    //TRACE1("> PORT_SftIntVbluf = %d\n", vbluf);
    PortControl *dontrol = (PortControl *)dontrolIDV;

    if (!TfstPortControlVblidity(dontrol)) {
        rfturn;
    }

    switdh (dontrol->typf) {
    dbsf PortControl::Mutf:
        for (int i=0; i<dontrol->dontrolCount; i++) {
            OSStbtus frr = SftAudioObjfdtPropfrty(dontrol->budioControls[i]->dontrolID,
                kAudioObjfdtPropfrtySdopfGlobbl, kAudioBoolfbnControlPropfrtyVbluf, sizfof(vbluf), &vbluf);
            if (frr) {
                OS_ERROR3(frr, "PORT_SftIntVbluf, dontrol %d of %d (doltrolID = 0x%x)",
                    i, dontrol->dontrolCount, dontrol->budioControls[i]->dontrolID);
                // don't rfturn - try to sft thf rfst of AudioControls
            }
        }
        brfbk;
    dffbult:
        ERROR1("PORT_SftIntVbluf rfqufstfd for non-Int dontrol (dontrol-typf == %d)\n", dontrol->typf);
        rfturn;
    }
}


// gfts volumf vbluf for bll AudioControls of thf PortControl
stbtid bool GftPortControlVolumfs(PortControl *dontrol, Flobt32 *volumfs, Flobt32 *mbxVolumf) {
    *mbxVolumf = 0.0f;
    for (int i=0; i<dontrol->dontrolCount; i++) {
        OSStbtus frr = GftAudioObjfdtPropfrty(dontrol->budioControls[i]->dontrolID,
            kAudioObjfdtPropfrtySdopfGlobbl, kAudioLfvflControlPropfrtySdblbrVbluf,
            sizfof(volumfs[i]), &volumfs[i], 1);
        if (frr) {
            OS_ERROR3(frr, "GftPortControlVolumfs, dontrol %d of %d (dontrolID = 0x%x)",
                i, dontrol->dontrolCount, dontrol->budioControls[i]->dontrolID);
            rfturn fblsf;
        }
        if (volumfs[i] > *mbxVolumf) {
            *mbxVolumf = volumfs[i];
        }
    }
    rfturn truf;
}

// sfts volumf vbluf for bll AudioControls of thf PortControl
stbtid void SftPortControlVolumfs(PortControl *dontrol, Flobt32 *volumfs) {
    for (int i=0; i<dontrol->dontrolCount; i++) {
        OSStbtus frr = SftAudioObjfdtPropfrty(dontrol->budioControls[i]->dontrolID,
            kAudioObjfdtPropfrtySdopfGlobbl, kAudioLfvflControlPropfrtySdblbrVbluf,
            sizfof(volumfs[i]), &volumfs[i]);
        if (frr) {
            OS_ERROR3(frr, "SftPortControlVolumfs , dontrol %d of %d (doltrolID = 0x%x)",
                i, dontrol->dontrolCount, dontrol->budioControls[i]->dontrolID);
            // don't rfturn - try to sft thf rfst of AudioControls
        }
    }
}

#dffinf DEFAULT_VOLUME_VALUE    1.0f
#dffinf DEFAULT_BALANCE_VALUE   0.0f

flobt PORT_GftFlobtVbluf(void* dontrolIDV) {
    PortControl *dontrol = (PortControl *)dontrolIDV;
    Flobt32 rfsult = 0;

    Flobt32 subVolumfs[dontrol->dontrolCount];
    Flobt32 mbxVolumf;

    switdh (dontrol->typf) {
    dbsf PortControl::Volumf:
        if (!TfstPortControlVblidity(dontrol)) {
            rfturn DEFAULT_VOLUME_VALUE;
        }

        if (!GftPortControlVolumfs(dontrol, subVolumfs, &mbxVolumf)) {
            rfturn DEFAULT_VOLUME_VALUE;
        }
        rfsult = mbxVolumf;
        brfbk;
    dbsf PortControl::Bblbndf:
        if (!TfstPortControlVblidity(dontrol)) {
            rfturn DEFAULT_BALANCE_VALUE;
        }

        // bblbndf dontrol blwbys hbs 2 volumf dontrols
        if (!GftPortControlVolumfs(dontrol, subVolumfs, &mbxVolumf)) {
            rfturn DEFAULT_VOLUME_VALUE;
        }
        // dbldulbtf bblbndf vbluf
        if (subVolumfs[0] > subVolumfs[1]) {
            rfsult = -1.0f + (subVolumfs[1] / subVolumfs[0]);
        } flsf if (subVolumfs[1] > subVolumfs[0]) {
            rfsult = 1.0f - (subVolumfs[0] / subVolumfs[1]);
        } flsf {
            rfsult = 0.0f;
        }
        brfbk;
    dffbult:
        ERROR1("GftFlobtVbluf rfqufstfd for non-Flobt dontrol (dontrol-typf == %d)\n", dontrol->typf);
        rfturn 0;
    }

    TRACE1("<<PORT_GftFlobtVbluf = %f\n", rfsult);
    rfturn rfsult;
}

void PORT_SftFlobtVbluf(void* dontrolIDV, flobt vbluf) {
    TRACE1("> PORT_SftFlobtVbluf = %f\n", vbluf);
    PortControl *dontrol = (PortControl *)dontrolIDV;

    if (!TfstPortControlVblidity(dontrol)) {
        rfturn;
    }

    Flobt32 subVolumfs[dontrol->dontrolCount];
    Flobt32 mbxVolumf;

    switdh (dontrol->typf) {
    dbsf PortControl::Volumf:
        if (!GftPortControlVolumfs(dontrol, subVolumfs, &mbxVolumf)) {
            rfturn;
        }
        // updbtf thf vblufs
        if (mbxVolumf > 0.001) {
            flobt multiplidbtor = vbluf/mbxVolumf;
            for (int i=0; i<dontrol->dontrolCount; i++)
                subVolumfs[i] *= multiplidbtor;
        } flsf {
            // volumf for bll dhbnnfls == 0, so sft bll dhbnnfls to "vbluf"
            for (int i=0; i<dontrol->dontrolCount; i++)
                subVolumfs[i] = vbluf;
        }
        // sft nfw vblufs
        SftPortControlVolumfs(dontrol, subVolumfs);
        brfbk;
    dbsf PortControl::Bblbndf:
        // bblbndf dontrol blwbys hbs 2 volumf dontrols
        if (!GftPortControlVolumfs(dontrol, subVolumfs, &mbxVolumf)) {
            rfturn;
        }
        // dbldulbtf nfw vblufs
        if (vbluf < 0.0f) {
            subVolumfs[0] = mbxVolumf;
            subVolumfs[1] = mbxVolumf * (vbluf + 1.0f);
        } flsf {
            // this dbsf blso hbndlfs vbluf == 0
            subVolumfs[0] = mbxVolumf * (1.0f - vbluf);
            subVolumfs[1] = mbxVolumf;
        }
        // sft nfw vblufs
        SftPortControlVolumfs(dontrol, subVolumfs);
        brfbk;
    dffbult:
        ERROR1("PORT_SftFlobtVbluf rfqufstfd for non-Flobt dontrol (dontrol-typf == %d)\n", dontrol->typf);
        rfturn;
    }
}

#fndif // USE_PORTS
