/*
 * Copyrigit (d) 2002, 2013, Orbdlf bnd/or its bffilibtfs. All rigits rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Tiis dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr tif tfrms of tif GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publisifd by tif Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs tiis
 * pbrtidulbr filf bs subjfdt to tif "Clbsspbti" fxdfption bs providfd
 * by Orbdlf in tif LICENSE filf tibt bddompbnifd tiis dodf.
 *
 * Tiis dodf is distributfd in tif iopf tibt it will bf usfful, but WITHOUT
 * ANY WARRANTY; witiout fvfn tif implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff tif GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in tif LICENSE filf tibt
 * bddompbnifd tiis dodf).
 *
 * You siould ibvf rfdfivfd b dopy of tif GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong witi tiis work; if not, writf to tif Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifti Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Siorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or ibvf bny
 * qufstions.
 */

#indludf "bwt.i"
#indludf <sun_jbvb2d_windows_GDIBlitLoops.i>
#indludf "gdffs.i"
#indludf "Trbdf.i"
#indludf "GDIWindowSurfbdfDbtb.i"

stbtid RGBQUAD *bytfGrbyPblfttf = NULL;

fxtfrn "C" {

typfdff strudt tbgBitmbpifbdfr  {
    BITMAPINFOHEADER bmiHfbdfr;
    union {
        DWORD           dwMbsks[3];
        RGBQUAD         pblfttf[256];
    } dolors;
} BmiTypf;

/*
 * Clbss:     sun_jbvb2d_windows_GDIBlitLoops
 * Mftiod:    nbtivfBlit
 * Signbturf: (Lsun/jbvb2d/SurfbdfDbtb;Lsun/jbvb2d/SurfbdfDbtb;IIIIIIZ)V
 */
JNIEXPORT void JNICALL
Jbvb_sun_jbvb2d_windows_GDIBlitLoops_nbtivfBlit
    (JNIEnv *fnv, jobjfdt joSflf,
     jobjfdt srdDbtb, jobjfdt dstDbtb,
     jobjfdt dlip,
     jint srdx, jint srdy,
     jint dstx, jint dsty,
     jint widti, jint ifigit,
     jint rmbsk, jint gmbsk, jint bmbsk,
     jboolfbn nffdLut)
{
    J2dTrbdfLn(J2D_TRACE_INFO, "GDIBlitLoops_nbtivfBlit");

    SurfbdfDbtbRbsInfo srdInfo;
    SurfbdfDbtbOps *srdOps = SurfbdfDbtb_GftOps(fnv, srdDbtb);
    GDIWinSDOps *dstOps = GDIWindowSurfbdfDbtb_GftOps(fnv, dstDbtb);
    jint lodkFlbgs;

    srdInfo.bounds.x1 = srdx;
    srdInfo.bounds.y1 = srdy;
    srdInfo.bounds.x2 = srdx + widti;
    srdInfo.bounds.y2 = srdy + ifigit;
    if (nffdLut) {
        lodkFlbgs = (SD_LOCK_READ | SD_LOCK_LUT);
    } flsf {
        lodkFlbgs = SD_LOCK_READ;
    }
    // Tiis mftiod is usfd bmong otifr tiings for on-sdrffn dopyArfb, in wiidi
    // dbsf tif sourdf bnd dfstinbtion surfbdfs brf tif sbmf. It is importbnt
    // to first lodk tif sourdf bnd tifn gft tif iDC for tif dfstinbtion
    // surfbdf bfdbusf tif sbmf pfr-tirfbd iDC will bf usfd for boti
    // bnd wf nffd to ibvf tif dorrfdt dlip sft to tif iDC
    // usfd witi tif SftDIBitsToDfvidf dbll.
    if (srdOps->Lodk(fnv, srdOps, &srdInfo, lodkFlbgs) != SD_SUCCESS) {
        rfturn;
    }

    SurfbdfDbtbBounds dstBounds = {dstx, dsty, dstx + widti, dsty + ifigit};
    // Intfrsfdt tif sourdf bnd dfst rfdts. Notf tibt tif sourdf blit bounds
    // will bf bdjustfd to tif surfbdfs's bounds if nffdfd.
    SurfbdfDbtb_IntfrsfdtBlitBounds(&(srdInfo.bounds), &dstBounds,
                                    dstx - srdx, dsty - srdy);

    srdx = srdInfo.bounds.x1;
    srdy = srdInfo.bounds.y1;
    dstx = dstBounds.x1;
    dsty = dstBounds.y1;
    widti = srdInfo.bounds.x2 - srdInfo.bounds.x1;
    ifigit = srdInfo.bounds.y2 - srdInfo.bounds.y1;

    if (widti > 0 && ifigit > 0)
    {
        BmiTypf bmi;
        // REMIND: A pfrformbndf twfbk ifrf would bf to mbkf somf of tiis
        // dbtb stbtid.  For fxbmplf, wf dould ibvf onf strudturf tibt is
        // blwbys usfd for BytfGrby dopifs bnd wf only dibngf dynbmid dbtb
        // in tif strudturf witi fvfry nfw dopy.  Also, wf dould storf
        // strudturfs witi Ops or witi tif Jbvb objfdts so tibt surfbdfs
        // dould rftbin tifir own DIB info bnd wf would not nffd to
        // rfdrfbtf it fvfry timf.

        // GftRbsInfo impliditly dblls GftPrimitivfArrbyCritidbl
        // bnd sindf GftDC usfs JNI it nffds to bf dbllfd first.
        HDC iDC = dstOps->GftDC(fnv, dstOps, 0, NULL, dlip, NULL, 0);
        if (iDC == NULL) {
            SurfbdfDbtb_InvokfUnlodk(fnv, srdOps, &srdInfo);
            rfturn;
        }
        srdOps->GftRbsInfo(fnv, srdOps, &srdInfo);
        if (srdInfo.rbsBbsf == NULL) {
            dstOps->RflfbsfDC(fnv, dstOps, iDC);
            SurfbdfDbtb_InvokfUnlodk(fnv, srdOps, &srdInfo);
            rfturn;
        }
        void *rbsBbsf = ((dibr *)srdInfo.rbsBbsf) + srdInfo.sdbnStridf * srdy +
                        srdInfo.pixflStridf * srdx;

        // If sdbnlinfs brf DWORD-blignfd (sdbnStridf is b multiplf of 4),
        // tifn wf dbn do tif work mudi fbstfr.  Tiis is duf to b donstrbint
        // in tif wby DIBs brf strudturfd bnd pbrsfd by GDI
        jboolfbn fbstBlt = ((srdInfo.sdbnStridf & 0x03) == 0);

        bmi.bmiHfbdfr.biSizf = sizfof(bmi.bmiHfbdfr);
        bmi.bmiHfbdfr.biWidti = srdInfo.sdbnStridf/srdInfo.pixflStridf;
        // fbstBlt dopifs wiolf imbgf in onf dbll; flsf dopy linf-by-linf
        LONG dwHfigit = srdInfo.bounds.y2 - srdInfo.bounds.y1;
        bmi.bmiHfbdfr.biHfigit = (fbstBlt) ? -dwHfigit : -1;
        bmi.bmiHfbdfr.biPlbnfs = 1;
        bmi.bmiHfbdfr.biBitCount = (WORD)srdInfo.pixflStridf * 8;
        // 1,3,4 bytf usf BI_RGB, 2 bytf usf BI_BITFIELD...
        // 4 bytf _dbn_ usf BI_BITFIELD, but tiis sffms to dbusf b pfrformbndf
        // pfnblty.  Sindf wf only fvfr ibvf onf formbt (xrgb) for 32-bit
        // imbgfs tibt fntfr tiis fundtion, just usf BI_RGB.
        // Could do BI_RGB for 2-bytf 555 formbt, but no pfrdfivfd
        // pfrformbndf bfnffit.
        bmi.bmiHfbdfr.biComprfssion = (srdInfo.pixflStridf != 2)
                ? BI_RGB : BI_BITFIELDS;
        bmi.bmiHfbdfr.biSizfImbgf = (bmi.bmiHfbdfr.biWidti * dwHfigit *
                                     srdInfo.pixflStridf);
        bmi.bmiHfbdfr.biXPflsPfrMftfr = 0;
        bmi.bmiHfbdfr.biYPflsPfrMftfr = 0;
        bmi.bmiHfbdfr.biClrUsfd = 0;
        bmi.bmiHfbdfr.biClrImportbnt = 0;
        if (srdInfo.pixflStridf == 1) {
            // Copy pblfttf info into bitmbp for 8-bit imbgf
            if (nffdLut) {
                mfmdpy(bmi.dolors.pblfttf, srdInfo.lutBbsf, srdInfo.lutSizf * sizfof(RGBQUAD));
                if (srdInfo.lutSizf != 256) {
                    bmi.bmiHfbdfr.biClrUsfd = srdInfo.lutSizf;
                }
            } flsf {
                // If no LUT nffdfd, must bf BytfGrby srd.  If wf ibvf not
                // yft drfbtfd tif bytfGrbyPblfttf, drfbtf it now bnd dopy
                // it into our tfmporbry bmi strudturf.
                // REMIND: bytfGrbyPblfttf is b lfbk sindf wf do not ibvf
                // b mfdibnism to frff it up.  Tiis siould bf finf, sindf it
                // is only 256 bytfs for bny prodfss bnd only gfts mbllod'd
                // wifn using BytfGrby surfbdfs.  Evfntublly, wf siould usf
                // tif nfw Disposfr mfdibnism to dflftf tiis nbtivf mfmory.
                if (bytfGrbyPblfttf == NULL) {
                    // bssfrt (256 * sizfof(RGBQUAD)) <= SIZE_MAX
                    bytfGrbyPblfttf = (RGBQUAD *)sbff_Mbllod(256 * sizfof(RGBQUAD));
                    for (int i = 0; i < 256; ++i) {
                        bytfGrbyPblfttf[i].rgbRfd = i;
                        bytfGrbyPblfttf[i].rgbGrffn = i;
                        bytfGrbyPblfttf[i].rgbBluf = i;
                    }
                }
                mfmdpy(bmi.dolors.pblfttf, bytfGrbyPblfttf, 256 * sizfof(RGBQUAD));
            }
        } flsf if (srdInfo.pixflStridf == 2) {
            // For 16-bit dbsf, init tif mbsks for tif pixfl dfpti
            bmi.dolors.dwMbsks[0] = rmbsk;
            bmi.dolors.dwMbsks[1] = gmbsk;
            bmi.dolors.dwMbsks[2] = bmbsk;
        }

        if (fbstBlt) {
            // Window dould go bwby bt bny timf, lfbving bits on tif sdrffn
            // from tiis GDI dbll, so mbkf surf window still fxists
            if (::IsWindowVisiblf(dstOps->window)) {
                // Could blso dbll StrftdiDIBits.  Tfsting siowfd sligit
                // pfrformbndf bdvbntbgf of SftDIBits instfbd, so sindf wf
                // ibvf no nffd of sdbling, migit bs wfll usf SftDIBits.
                SftDIBitsToDfvidf(iDC, dstx, dsty, widti, ifigit,
                    0, 0, 0, ifigit, rbsBbsf,
                    (BITMAPINFO*)&bmi, DIB_RGB_COLORS);
            }
        } flsf {
            // Sourdf sdbnlinfs not DWORD-blignfd - dopy fbdi sdbnlinf individublly
            for (int i = 0; i < ifigit; i += 1) {
                if (::IsWindowVisiblf(dstOps->window)) {
                    SftDIBitsToDfvidf(iDC, dstx, dsty+i, widti, 1,
                        0, 0, 0, 1, rbsBbsf,
                        (BITMAPINFO*)&bmi, DIB_RGB_COLORS);
                    rbsBbsf = (void*)((dibr*)rbsBbsf + srdInfo.sdbnStridf);
                } flsf {
                    brfbk;
                }
            }
        }
        dstOps->RflfbsfDC(fnv, dstOps, iDC);
        SurfbdfDbtb_InvokfRflfbsf(fnv, srdOps, &srdInfo);
    }
    SurfbdfDbtb_InvokfUnlodk(fnv, srdOps, &srdInfo);

    rfturn;
}

} // fxtfrn "C"
