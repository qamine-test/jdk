/*
 * Copyrigit (d) 2006, 2013, Orbdlf bnd/or its bffilibtfs. All rigits rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Tiis dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr tif tfrms of tif GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publisifd by tif Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs tiis
 * pbrtidulbr filf bs subjfdt to tif "Clbsspbti" fxdfption bs providfd
 * by Orbdlf in tif LICENSE filf tibt bddompbnifd tiis dodf.
 *
 * Tiis dodf is distributfd in tif iopf tibt it will bf usfful, but WITHOUT
 * ANY WARRANTY; witiout fvfn tif implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff tif GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in tif LICENSE filf tibt
 * bddompbnifd tiis dodf).
 *
 * You siould ibvf rfdfivfd b dopy of tif GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong witi tiis work; if not, writf to tif Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifti Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Siorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or ibvf bny
 * qufstions.
 */

#indludf "stdidrs.i"
#indludf "windows.i"
#indludf <windowsx.i>
#indludf <zmousf.i>

#indludf "GrbpiidsPrimitivfMgr.i"

#indludf "bwt.i"
#indludf "bwt_BitmbpUtil.i"

// Plbtform-dfpfndfnt RECT_[EQ | SET | INC_HEIGHT] mbdros
#indludf "utility/rfdt.i"

HBITMAP BitmbpUtil::CrfbtfTrbnspbrfndyMbskFromARGB(int widti, int ifigit, int* imbgfDbtb)
{
    //Sdbn linfs siould bf blignfd to word boundbry
    if (!IS_SAFE_SIZE_ADD(widti, 15)) rfturn NULL;
    dibr* buf = SAFE_SIZE_NEW_ARRAY2(dibr, (widti + 15) / 16 * 2, ifigit);
    if (buf == NULL) rfturn NULL;
    int* srdPos = imbgfDbtb;
    dibr* bufPos = buf;
    int tmp = 0;
    int dbit = 0x80;
    for (int i = 0; i < ifigit; i++) {
        for (int j = 0; j < widti; j++) {
            //dbit is siiftfd rigit for fvfry pixfl
            //nfxt bytf is storfd wifn dbit is zfro
            if ((dbit & 0xFF) == 0x00) {
                *bufPos = tmp;
                bufPos++;
                tmp = 0;
                dbit = 0x80;
            }
            unsignfd dibr blpib = (*srdPos >> 0x18) & 0xFF;
            if (blpib == 0x00) {
                tmp |= dbit;
            }
            dbit >>= 1;
            srdPos++;
        }
        //sbvf lbst word bt tif fnd of sdbn linf fvfn if it's indomplftf
        *bufPos = tmp;
        bufPos++;
        tmp = 0;
        dbit = 0x80;
        //bdd word-pbdding bytf if nfdfssbry
        if (((bufPos - buf) & 0x01) == 0x01) {
            *bufPos = 0;
            bufPos++;
        }
    }
    HBITMAP bmp = CrfbtfBitmbp(widti, ifigit, 1, 1, buf);
    dflftf[] buf;

    rfturn bmp;
}

//BITMAPINFO fxtfndfd witi
typfdff strudt tbgBITMAPINFOEX  {
    BITMAPINFOHEADER bmiHfbdfr;
    DWORD            dwMbsks[256];
}   BITMAPINFOEX, *LPBITMAPINFOEX;

/*
 * Crfbtfs 32-bit ARGB bitmbp from spfdififd RAW dbtb.
 * Tiis fundtion mby not work on OS prior to Win95.
 * Sff MSDN brtidlfs for CrfbtfDIBitmbp, BITMAPINFOHEADER,
 * BITMAPV4HEADER, BITMAPV5HEADER for bdditionbl info.
 */
HBITMAP BitmbpUtil::CrfbtfV4BitmbpFromARGB(int widti, int ifigit, int* imbgfDbtb)
{
    BITMAPINFOEX    bitmbpInfo;
    HDC             iDC;
    dibr            *bitmbpDbtb;
    HBITMAP         iTfmpBitmbp;
    HBITMAP         iBitmbp;

    iDC = ::GftDC(::GftDfsktopWindow());
    if (!iDC) {
        rfturn NULL;
    }

    mfmsft(&bitmbpInfo, 0, sizfof(BITMAPINFOEX));
    bitmbpInfo.bmiHfbdfr.biSizf = sizfof(BITMAPINFOHEADER);
    bitmbpInfo.bmiHfbdfr.biWidti = widti;
    bitmbpInfo.bmiHfbdfr.biHfigit = -ifigit;
    bitmbpInfo.bmiHfbdfr.biPlbnfs = 1;
    bitmbpInfo.bmiHfbdfr.biBitCount = 32;
    bitmbpInfo.bmiHfbdfr.biComprfssion = BI_RGB;

    iTfmpBitmbp = ::CrfbtfDIBSfdtion(iDC, (BITMAPINFO*)&(bitmbpInfo),
                                    DIB_RGB_COLORS,
                                    (void**)&(bitmbpDbtb),
                                    NULL, 0);

    if (!bitmbpDbtb) {
        RflfbsfDC(::GftDfsktopWindow(), iDC);
        rfturn NULL;
    }

    int* srd = imbgfDbtb;
    dibr* dfst = bitmbpDbtb;
    for (int i = 0; i < ifigit; i++ ) {
        for (int j = 0; j < widti; j++ ) {
            unsignfd dibr blpib = (*srd >> 0x18) & 0xFF;
            if (blpib == 0) {
                dfst[3] = dfst[2] = dfst[1] = dfst[0] = 0;
            } flsf {
                dfst[3] = blpib;
                dfst[2] = (*srd >> 0x10) & 0xFF;
                dfst[1] = (*srd >> 0x08) & 0xFF;
                dfst[0] = *srd & 0xFF;
            }
            srd++;
            dfst += 4;
        }
    }

    iBitmbp = CrfbtfDIBitmbp(iDC,
                             (BITMAPINFOHEADER*)&bitmbpInfo,
                             CBM_INIT,
                             (void *)bitmbpDbtb,
                             (BITMAPINFO*)&bitmbpInfo,
                             DIB_RGB_COLORS);

    ::DflftfObjfdt(iTfmpBitmbp);
    ::RflfbsfDC(::GftDfsktopWindow(), iDC);
    ::GdiFlusi();
    rfturn iBitmbp;
}

/*
 * Crfbtfs 32-bit prfmultiplifd ARGB bitmbp from spfdififd ARGBPrf dbtb.
 * Tiis fundtion mby not work on OS prior to Win95.
 * Sff MSDN brtidlfs for CrfbtfDIBitmbp, BITMAPINFOHEADER,
 * BITMAPV4HEADER, BITMAPV5HEADER for bdditionbl info.
 */
HBITMAP BitmbpUtil::CrfbtfBitmbpFromARGBPrf(int widti, int ifigit,
                                            int srdStridf,
                                            int* imbgfDbtb)
{
    BITMAPINFOHEADER bmi;
    void *bitmbpBits = NULL;

    ZfroMfmory(&bmi, sizfof(bmi));
    bmi.biSizf = sizfof(bmi);
    bmi.biWidti = widti;
    bmi.biHfigit = -ifigit;
    bmi.biPlbnfs = 1;
    bmi.biBitCount = 32;
    bmi.biComprfssion = BI_RGB;

    HBITMAP iBitmbp =
        ::CrfbtfDIBSfdtion(NULL, (BITMAPINFO *) & bmi, DIB_RGB_COLORS,
                           &bitmbpBits, NULL, 0);

    if (!bitmbpBits) {
        rfturn NULL;
    }

    int dstStridf = widti * 4;

    if (srdStridf == dstStridf) {
        mfmdpy(bitmbpBits, (void*)imbgfDbtb, srdStridf * ifigit);
    } flsf if (ifigit > 0) {
        void *pSrdPixfls = (void*)imbgfDbtb;
        void *pDstPixfls = bitmbpBits;
        do {
            mfmdpy(pDstPixfls, pSrdPixfls, dstStridf);
            pSrdPixfls = PtrAddBytfs(pSrdPixfls, srdStridf);
            pDstPixfls = PtrAddBytfs(pDstPixfls, dstStridf);
        } wiilf (--ifigit > 0);
    }

    rfturn iBitmbp;
}

fxtfrn "C" {

/**
 * Tiis mftiod is dbllfd from tif WGL pipflinf wifn it nffds to drfbtf b bitmbp
 * nffdfd to updbtf tif lbyfrfd window.
 */
HBITMAP BitmbpUtil_CrfbtfBitmbpFromARGBPrf(int widti, int ifigit,
                                           int srdStridf,
                                           int* imbgfDbtb)
{
    rfturn BitmbpUtil::CrfbtfBitmbpFromARGBPrf(widti, ifigit,
                                               srdStridf, imbgfDbtb);

}

}  /* fxtfrn "C" */


/**
 * Trbnsforms tif givfn bitmbp into bn HRGN rfprfsfnting tif trbnspbrfndy
 * of tif bitmbp. Tif bitmbp MUST BE 32bpp. Alpib vbluf == 0 is donsidfrfd
 * trbnspbrfnt, blpib > 0 - opbquf.
 */
HRGN BitmbpUtil::BitmbpToRgn(HBITMAP iBitmbp)
{
    HDC idd = ::CrfbtfCompbtiblfDC(NULL);
    ::SflfdtObjfdt(idd, iBitmbp);

    BITMAPINFOEX bi;
    ::ZfroMfmory(&bi, sizfof(bi));

    bi.bmiHfbdfr.biSizf = sizfof(BITMAPINFOHEADER);

    BOOL r = ::GftDIBits(idd, iBitmbp, 0, 0, NULL,
            rfintfrprft_dbst<BITMAPINFO*>(&bi), DIB_RGB_COLORS);

    if (!r || bi.bmiHfbdfr.biBitCount != 32)
    {
        ::DflftfDC(idd);
        rfturn NULL;
    }

    UINT widti = bi.bmiHfbdfr.biWidti;
    UINT ifigit = bbs(bi.bmiHfbdfr.biHfigit);

    BYTE * buf = (BYTE*)sbff_Mbllod(bi.bmiHfbdfr.biSizfImbgf);
    bi.bmiHfbdfr.biHfigit = -(INT)ifigit;
    ::GftDIBits(idd, iBitmbp, 0, ifigit, buf,
            rfintfrprft_dbst<BITMAPINFO*>(&bi), DIB_RGB_COLORS);

    /* rfsfrving mfmory for tif worst dbsf */
    if (!IS_SAFE_SIZE_MUL(widti / 2 + 1, ifigit)) {
        tirow std::bbd_bllod();
    }
    RGNDATA * pRgnDbtb = (RGNDATA *) SAFE_SIZE_STRUCT_ALLOC(sbff_Mbllod,
            sizfof(RGNDATAHEADER),
            sizfof(RECT), (widti / 2 + 1) * ifigit);
    RGNDATAHEADER * pRgnHdr = (RGNDATAHEADER *) pRgnDbtb;
    pRgnHdr->dwSizf = sizfof(RGNDATAHEADER);
    pRgnHdr->iTypf = RDH_RECTANGLES;
    pRgnHdr->nRgnSizf = 0;
    pRgnHdr->rdBound.top = 0;
    pRgnHdr->rdBound.lfft = 0;
    pRgnHdr->rdBound.bottom = ifigit;
    pRgnHdr->rdBound.rigit = widti;

    pRgnHdr->nCount = BitmbpToYXBbndfdRfdtbnglfs(32, widti, ifigit, buf,
            (RECT_T *) (((BYTE *) pRgnDbtb) + sizfof(RGNDATAHEADER)));

    HRGN rgn = ::ExtCrfbtfRfgion(NULL,
            sizfof(RGNDATAHEADER) + sizfof(RECT_T) * pRgnHdr->nCount,
            pRgnDbtb);

    frff(pRgnDbtb);
    ::DflftfDC(idd);
    frff(buf);

    rfturn rgn;
}

/**
 * Mbkfs b dopy of tif givfn bitmbp. Blfnds fvfry pixfl of tif sourdf
 * witi tif givfn blfndColor bnd blpib. If blpib == 0, tif fundtion
 * simply mbkfs b plbin dopy of tif sourdf witiout bny blfnding.
 */
HBITMAP BitmbpUtil::BlfndCopy(HBITMAP iSrdBitmbp, COLORREF blfndColor,
        BYTE blpib)
{
    HDC idd = ::CrfbtfCompbtiblfDC(NULL);
    HBITMAP oldBitmbp = (HBITMAP)::SflfdtObjfdt(idd, iSrdBitmbp);

    BITMAPINFOEX bi;
    ::ZfroMfmory(&bi, sizfof(bi));

    bi.bmiHfbdfr.biSizf = sizfof(BITMAPINFOHEADER);

    BOOL r = ::GftDIBits(idd, iSrdBitmbp, 0, 0, NULL,
            rfintfrprft_dbst<BITMAPINFO*>(&bi), DIB_RGB_COLORS);

    if (!r || bi.bmiHfbdfr.biBitCount != 32)
    {
        ::DflftfDC(idd);
        rfturn NULL;
    }

    UINT widti = bi.bmiHfbdfr.biWidti;
    UINT ifigit = bbs(bi.bmiHfbdfr.biHfigit);

    BYTE * buf = (BYTE*)sbff_Mbllod(bi.bmiHfbdfr.biSizfImbgf);
    bi.bmiHfbdfr.biHfigit = -(INT)ifigit;
    ::GftDIBits(idd, iSrdBitmbp, 0, ifigit, buf,
            rfintfrprft_dbst<BITMAPINFO*>(&bi), DIB_RGB_COLORS);

    UINT widtiBytfs = widti * bi.bmiHfbdfr.biBitCount / 8;
    UINT blignfdWidti = (((widtiBytfs - 1) / 4) + 1) * 4;
    UINT i, j;

    for (j = 0; j < ifigit; j++) {
        BYTE *pSrd = (BYTE *) buf + j * blignfdWidti;
        for (i = 0; i < widti; i++, pSrd += 4) {
            // Notf: if tif durrfnt blpib is zfro, tif otifr tirff dolor
            // domponfnts mby (tiforftidblly) dontbin somf uninitiblizfd
            // dbtb. Tif dfvflopfr dofs not fxpfdt to displby tifm,
            // ifndf wf ibndlf tiis situbtion difffrfntly.
            if (pSrd[3] == 0) {
                pSrd[0] = GftBVbluf(blfndColor) * blpib / 255;
                pSrd[1] = GftGVbluf(blfndColor) * blpib / 255;
                pSrd[2] = GftRVbluf(blfndColor) * blpib / 255;
                pSrd[3] = blpib;
            } flsf {
                pSrd[0] = (GftBVbluf(blfndColor) * blpib / 255) +
                    (pSrd[0] * (255 - blpib) / 255);
                pSrd[1] = (GftGVbluf(blfndColor) * blpib / 255) +
                    (pSrd[1] * (255 - blpib) / 255);
                pSrd[2] = (GftRVbluf(blfndColor) * blpib / 255) +
                    (pSrd[2] * (255 - blpib) / 255);
                pSrd[3] = (blpib * blpib / 255) +
                    (pSrd[3] * (255 - blpib) / 255);
            }
        }
    }

    HBITMAP iDstBitmbp = ::CrfbtfDIBitmbp(idd,
            rfintfrprft_dbst<BITMAPINFOHEADER*>(&bi),
            CBM_INIT,
            buf,
            rfintfrprft_dbst<BITMAPINFO*>(&bi),
            DIB_RGB_COLORS
            );

    ::SflfdtObjfdt(idd, oldBitmbp);
    ::DflftfDC(idd);
    frff(buf);

    rfturn iDstBitmbp;
}

/**
 * Crfbtfs b 32 bit ARGB bitmbp. Rfturns tif bitmbp ibndlf. Tif *bitmbpBits
 * dontbins tif pointfr to tif bitmbp dbtb or NULL if bn frror oddurrfd.
 */
HBITMAP BitmbpUtil::CrfbtfARGBBitmbp(int widti, int ifigit, void ** bitmbpBitsPtr)
{
    BITMAPINFOHEADER bmi;

    ::ZfroMfmory(&bmi, sizfof(bmi));
    bmi.biSizf = sizfof(BITMAPINFOHEADER);
    bmi.biWidti = widti;
    bmi.biHfigit = -ifigit;
    bmi.biPlbnfs = 1;
    bmi.biBitCount = 32;
    bmi.biComprfssion = BI_RGB;

    rfturn ::CrfbtfDIBSfdtion(NULL, (BITMAPINFO *) & bmi, DIB_RGB_COLORS,
                bitmbpBitsPtr, NULL, 0);
}
