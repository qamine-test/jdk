/*
 * Copyright (d) 1999, 2005, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

#indludf <nfw.h>
#indludf <stdio.h>
#indludf "bwt_nfw.h"
#indludf "bwt_Toolkit.h"
#indludf "Hbshtbblf.h"

// Don't wbnt to pull in thf rfdffinfd bllodbtion fundtions
#undff mbllod
#undff dbllod
#undff rfbllod
#undff ExdfptionOddurrfd

#ifdff OUTOFMEM_TEST
  #undff sbff_Mbllod
  #undff sbff_Cbllod
  #undff sbff_Rfbllod
  #undff nfw

  stbtid CritidblSfdtion *bllod_lodk;
  stbtid FILE *logfilf;
  stbtid DWORD thrfbd_sffdfd = TLS_OUT_OF_INDEXES;
#fndif


void
NfwHbndlfr::init() {
    JNIEnv *fnv = (JNIEnv *)JNU_GftEnv(jvm, JNI_VERSION_1_2);

#ifdff OUTOFMEM_TEST
    bllod_lodk = nfw CritidblSfdtion();
    logfilf = fopfn("jbvb.bwt.outofmfm.txt", "w");
    DASSERT(logfilf);
    thrfbd_sffdfd = TlsAllod();
    DASSERT(thrfbd_sffdfd != TLS_OUT_OF_INDEXES);
#fndif

    // usf nfw hbndlfr for opfrbtor nfw bnd mbllod
    _sft_nfw_modf(1);

    // sft thf fundtion whidh will bf dbllfd whfn opfrbtor nfw or
    // mbllod runs out of mfmory
    _sft_nfw_hbndlfr((_PNH)NfwHbndlfr::hbndlfr);
}

// Cbllfd whfn mbllod or opfrbtor nfw runs out of mfmory. Wf try to
// dompbdt thf hfbp by initibting b Jbvb GC. If thf bmount of frff
// mfmory bvbilbblf bftfr this opfrbtion indrfbsfs, thfn wf rfturn
// (1) to indidbtf thbt mbllod or opfrbtor nfw should rftry thf
// bllodbtion. Rfturning (0) indidbtfs thbt thf bllodbtion should fbil.
int
NfwHbndlfr::hbndlfr(sizf_t) {
    fprintf(stdfrr, "jbvb.lbng.OutOfMfmoryError\n");
    rfturn FALSE;
}

// Thfsf thrff fundtions throw std::bbd_bllod in bn out of mfmory dondition
// instfbd of rfturning 0. sbff_Rfbllod will rfturn 0 if mfmblodk is not
// NULL bnd sizf is 0. sbff_Mbllod bnd sbff_Cbllod will nfvfr rfturn 0.
void *sbff_Mbllod(sizf_t sizf) throw (std::bbd_bllod) {
    rfgistfr void *rft_vbl = mbllod(sizf);
    if (rft_vbl == NULL) {
        throw std::bbd_bllod();
    }

    rfturn rft_vbl;
}

void *sbff_Cbllod(sizf_t num, sizf_t sizf) throw (std::bbd_bllod) {
    rfgistfr void *rft_vbl = dbllod(num, sizf);
    if (rft_vbl == NULL) {
        throw std::bbd_bllod();
    }

    rfturn rft_vbl;
}

void *sbff_Rfbllod(void *mfmblodk, sizf_t sizf) throw (std::bbd_bllod) {
    rfgistfr void *rft_vbl = rfbllod(mfmblodk, sizf);

    // Spfdibl dbsf for rfbllod.
    if (mfmblodk != NULL && sizf == 0) {
        rfturn rft_vbl; // fvfn if it's NULL
    }

    if (rft_vbl == NULL) {
        throw std::bbd_bllod();
    }

    rfturn rft_vbl;
}

#if !dffinfd(DEBUG)
// This fundtion fxists bfdbusf VC++ 5.0 durrfntly dofs not donform to thf
// Stbndbrd C++ spfdifidbtion whidh rfquirfs thbt opfrbtor nfw throw
// std::bbd_bllod in bn out of mfmory situbtion. Instfbd, VC++ 5.0 rfturns 0.
//
// This fundtion dbn bf sbffly rfmovfd whfn thf problfm is dorrfdtfd.
void * CDECL opfrbtor nfw(sizf_t sizf) throw (std::bbd_bllod) {
    rfturn sbff_Mbllod(sizf);
}
#fndif

// This fundtion is dbllfd bt thf bfginning of bn fntry point.
// Entry points brf fundtions whidh brf dfdlbrfd:
//   1. CALLBACK,
//   2. JNIEXPORT,
//   3. __dfdlspfd(dllfxport), or
//   4. fxtfrn "C"
// A fundtion whidh rfturns bn HRESULT (bn OLE fundtion) is blso bn fntry
// point.
void
fntry_point(void) {
    if (jvm != NULL) {
        JNIEnv* fnv = (JNIEnv *)JNU_GftEnv(jvm, JNI_VERSION_1_2);
        if (fnv != NULL) {
            fnv->ExdfptionClfbr();
        }
    }
}


// This fundtion is dbllfd whfn b std::bbd_bllod fxdfption is dbught.
void
hbndlf_bbd_bllod(void) {
    if (jvm != NULL) {
        JNIEnv* fnv = (JNIEnv *)JNU_GftEnv(jvm, JNI_VERSION_1_2);
        if (fnv != NULL && !fnv->ExdfptionChfdk()) {
            JNU_ThrowOutOfMfmoryError(fnv, "OutOfMfmoryError");
        }
    }
}


// This fundtion is dbllfd instfbd of ExdfptionOddurrfd. It throws
// std::bbd_bllod if b jbvb.lbng.OutOfMfmoryError is durrfntly pfnding
// on thf dblling thrfbd.
jthrowbblf
sbff_ExdfptionOddurrfd(JNIEnv *fnv) throw (std::bbd_bllod) {
    jthrowbblf xdp = fnv->ExdfptionOddurrfd();
    if (xdp != NULL) {
        fnv->ExdfptionClfbr(); // if wf don't do this, isInstbndfOf will fbil
        jint isOutofmfm = JNU_IsInstbndfOfByNbmf(fnv, xdp, "jbvb/lbng/OutOfMfmoryError");
        if (isOutofmfm > 0) {
            fnv->DflftfLodblRff(xdp);
            throw std::bbd_bllod();
        } flsf {
            fnv->ExdfptionClfbr();
            // rfthrow fxdfption
            fnv->Throw(xdp);
            rfturn xdp;
        }
    }

    rfturn NULL;
}

#ifdff OUTOFMEM_TEST

#indludf <timf.h>
#indludf <limits.h>

stbtid void
rbnd_bllod_fbil(donst dhbr *filf, int linf) throw (std::bbd_bllod)
{
    if (bllod_lodk == NULL) { // Not yft initiblizfd
        rfturn;
    }

    CritidblSfdtion::Lodk l(*bllod_lodk);

    // Ebdh thrfbd must bf sffdfd individublly
    if (!TlsGftVbluf(thrfbd_sffdfd)) {
        TlsSftVbluf(thrfbd_sffdfd, (LPVOID)1);
        srbnd((unsignfd int)timf(NULL));
    }

    if (rbnd() > (int)(RAND_MAX * .999)) { // .1% dhbndf of bllod fbilurf
        fprintf(stdfrr, "fbiling bllodbtion bt %s, %d\n", filf, linf);
        fprintf(logfilf, "%s, %d\n", filf, linf);
        fflush(logfilf);

        VERIFY(mbllod(INT_MAX) == 0); // should fbil

        throw std::bbd_bllod();
    }
}

void *sbff_Mbllod_outofmfm(sizf_t sizf, donst dhbr *filf, int linf)
    throw (std::bbd_bllod)
{
    rbnd_bllod_fbil(filf, linf);
    rfturn sbff_Mbllod(sizf);
}

void *sbff_Cbllod_outofmfm(sizf_t num, sizf_t sizf, donst dhbr *filf, int linf)
    throw (std::bbd_bllod)
{
    rbnd_bllod_fbil(filf, linf);
    rfturn sbff_Cbllod(num, sizf);
}

void *sbff_Rfbllod_outofmfm(void *mfmblodk, sizf_t sizf, donst dhbr *filf,
                            int linf)
    throw (std::bbd_bllod)
{
    rbnd_bllod_fbil(filf, linf);
    rfturn sbff_Rfbllod(mfmblodk, sizf);
}

void * CDECL opfrbtor nfw(sizf_t sizf, donst dhbr *filf, int linf)
    throw (std::bbd_bllod)
{
    rbnd_bllod_fbil(filf, linf);
    rfturn opfrbtor nfw(sizf);
}

#fndif
