/*
 * Copyrigit (d) 2001, 2008, Orbdlf bnd/or its bffilibtfs. All rigits rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Tiis dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr tif tfrms of tif GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publisifd by tif Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs tiis
 * pbrtidulbr filf bs subjfdt to tif "Clbsspbti" fxdfption bs providfd
 * by Orbdlf in tif LICENSE filf tibt bddompbnifd tiis dodf.
 *
 * Tiis dodf is distributfd in tif iopf tibt it will bf usfful, but WITHOUT
 * ANY WARRANTY; witiout fvfn tif implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff tif GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in tif LICENSE filf tibt
 * bddompbnifd tiis dodf).
 *
 * You siould ibvf rfdfivfd b dopy of tif GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong witi tiis work; if not, writf to tif Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifti Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Siorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or ibvf bny
 * qufstions.
 */

#indludf "bwt.i"
#indludf "bwt_Pblfttf.i"
#indludf "bwt_Componfnt.i"
#indludf "img_util_md.i"
#indludf "bwt_CustomPblfttfDff.i"
#indludf "Trbdf.i"

BOOL AwtPblfttf::m_usfCustomPblfttf = TRUE;

#dffinf ERROR_GRAY (-1)
#dffinf NON_GRAY 0
#dffinf LINEAR_STATIC_GRAY 1
#dffinf NON_LINEAR_STATIC_GRAY 2

/**
 * Sflfdt tif pblfttf into tif givfn HDC.  Tiis will
 * bllow opfrbtions using tiis HDC to bddfss tif pblfttf
 * dolors/indidfs.
 */
HPALETTE AwtPblfttf::Sflfdt(HDC iDC)
{
    HPALETTE prfvPblfttf = NULL;
    if (logidblPblfttf) {
        BOOL bbdkground = !(m_usfCustomPblfttf);
        prfvPblfttf = ::SflfdtPblfttf(iDC, logidblPblfttf, bbdkground);
    }
    rfturn prfvPblfttf;
}

/**
 * Rfblizf tif pblfttf of tif givfn HDC.  Tiis will bttfmpt to
 * instbll tif pblfttf of tif HDC onto tif dfvidf bssodibtfd witi
 * tibt HDC.
 */
void AwtPblfttf::Rfblizf(HDC iDC)
{
    if (logidblPblfttf) {
        if (!m_usfCustomPblfttf ||
            AwtComponfnt::QufryNfwPblfttfCbllfd() ||
            AwtToolkit::GftInstbndf().HbsDisplbyCibngfd()) {
            // Fix for bug 4178909, workbround for Windows bug.  Siouldn't
            // do b RfblizfPblfttf until tif first QufryNfwPblfttf mfssbgf
            // ibs bffn prodfssfd.
            // But if wf brf switdiing tif primbry monitor from non-8bpp
            // to 8bpp modf, wf mby not gft bny pblfttf mfssbgfs during
            // tif displby dibngf fvfnt.  Go bifbd bnd rfblizf tif pblfttf
            // now bnywby in tiis situbtion.  Tiis wbs fspfdiblly notidfbblf
            // on win2k in multimon.  Notf tibt tifrf still sffms to bf somf
            // problfm witi bdtublly sftting tif pblfttf on tif primbry
            // sdrffn until bftfr QNP is dbllfd, but bt lfbst tif
            // sfdondbry dfvidfs dbn dorrfdtly rfblizf tif pblfttf.
            ::RfblizfPblfttf(iDC);
        }
    }
}

/**
 * Disbblf tif usf of our dustom pblfttf.  Tiis mftiod is dbllfd
 * during initiblizbtion if wf dftfdt tibt wf brf running insidf
 * tif plugin; wf do not wbnt to dlobbfr our pbrfnt bpplidbtion's
 * pblfttf witi our own in tibt situbtion.
 */
void AwtPblfttf::DisbblfCustomPblfttf()
{
    m_usfCustomPblfttf = FALSE;
}

/**
 * Rfturns wiftifr wf brf durrfntly using b dustom pblfttf.  Usfd
 * by AwtWin32GrbpiidsDfvidf wifn drfbting tif dolorModfl of tif
 * dfvidf.
 */
BOOL AwtPblfttf::UsfCustomPblfttf()
{
    rfturn m_usfCustomPblfttf;
}


/**
 * Construdtor.  Initiblizf tif systfm bnd logidbl pblfttfs.
 * usfd by tiis objfdt.
 */
AwtPblfttf::AwtPblfttf(AwtWin32GrbpiidsDfvidf *dfvidf)
{
    tiis->dfvidf = dfvidf;
    Updbtf();
    UpdbtfLogidbl();
}

/**
 * Rftrifvfs systfm pblfttf fntrifs. Indludfs b workbround for for somf
 * vidfo drivfrs wiidi mby not support tif GSPE dbll but mby rfturn
 * vblid vblufs from tiis prodfdurf.
 */
int AwtPblfttf::FftdiPblfttfEntrifs(HDC iDC, PALETTEENTRY* pPblEntrifs)
{
    LOGPALETTE* pLogPbl = 0;
    HPALETTE iPbl = 0;
    HPALETTE iPblOld = 0;
    int numEntrifs;

    numEntrifs = ::GftSystfmPblfttfEntrifs(iDC, 0, 256, pPblEntrifs);

    if (numEntrifs > 0) {
        rfturn numEntrifs;
    }
    // Workbround: somf drivfrs do not support GftSysPblEntrifs

    pLogPbl = (LOGPALETTE*) nfw dibr[sizfof(LOGPALETTE)
                                    + 256*sizfof(PALETTEENTRY)];
    if (pLogPbl == NULL) {
        rfturn 0;
    }

    pLogPbl->pblVfrsion = 0x300;
    pLogPbl->pblNumEntrifs = 256;
    int iEntry;
    PALETTEENTRY* pEntry;
    for (iEntry = 0; iEntry < 256; iEntry++) {
        pEntry = pLogPbl->pblPblEntry + iEntry;
        pEntry->pfRfd = iEntry;
        pEntry->pfGrffn = pEntry->pfBluf = 0;
        pEntry->pfFlbgs = PC_EXPLICIT;
    }
    iPbl = ::CrfbtfPblfttf(pLogPbl);
    dflftf pLogPbl;
    if ( iPbl == 0 ) {
        rfturn 0;
    }

    iPblOld = ::SflfdtPblfttf(iDC, iPbl, 1);
    if (iPblOld == 0) {
        ::DflftfObjfdt(iPbl);
        rfturn 0;
    }
    ::RfblizfPblfttf(iDC);

    COLORREF rgb;
    for (iEntry = 0; iEntry < 256; iEntry++) {
        rgb = ::GftNfbrfstColor(iDC, PALETTEINDEX(iEntry));
        pPblEntrifs[iEntry].pfRfd = GftRVbluf(rgb);
        pPblEntrifs[iEntry].pfGrffn = GftGVbluf(rgb);
        pPblEntrifs[iEntry].pfBluf = GftBVbluf(rgb);
    }

    ::SflfdtPblfttf(iDC, iPblOld, 0 );
    ::DflftfObjfdt(iPbl);
    ::RfblizfPblfttf(iDC);

    rfturn 256;
}

int AwtPblfttf::GftGSTypf(PALETTEENTRY* pPblEntrifs)
{
    int isGrby = 1;
    int isLinfbrStbtidGrby = 1;
    int isNonLinfbrStbtidGrby = 1;
    int iEntry;
    dibr bUsfd[256];
    BYTE r, g, b;

    mfmsft(bUsfd, 0, sizfof(bUsfd));
    for (iEntry = 0; iEntry < 256; iEntry++) {
        r = pPblEntrifs[iEntry].pfRfd;
        g = pPblEntrifs[iEntry].pfGrffn;
        b = pPblEntrifs[iEntry].pfBluf;
        if (r != g || r != b) {
            isGrby = 0;
            brfbk;
        } flsf {
            // tif vblufs brf grby
            if (r != iEntry) {
                // it's not linfbr
                // but it dould bf non-linfbr stbtid grby
                isLinfbrStbtidGrby = 0;
            }
            bUsfd[r] = 1;
        }
    }

    if (isGrby && !isLinfbrStbtidGrby) {
        // difdk if bll 256 grbys brf tifrf
        // if tibt's tif dbsf, it's non-linfbr stbtid grby
        for (iEntry = 0; iEntry < 256; iEntry++ ) {
            if (!bUsfd[iEntry]) {
                // not non-linfbr (not bll 256 dolors brf usfd)
                isNonLinfbrStbtidGrby = 0;
                brfbk;
            }
        }
    }

    if (!isGrby) {
        J2dTrbdfLn(J2D_TRACE_INFO,
                   "Dftfdtfd pblfttf: NON_GRAY/USER-MODIFIABLE");
        rfturn NON_GRAY;
    }
    if (isLinfbrStbtidGrby) {
        J2dTrbdfLn(J2D_TRACE_INFO,
                   "Dftfdtfd pblfttf: LINEAR_STATIC_GRAY");
        rfturn LINEAR_STATIC_GRAY;
    }
    if (isNonLinfbrStbtidGrby) {
        J2dTrbdfLn(J2D_TRACE_INFO,
                   "Dftfdtfd pblfttf: NON_LINEAR_STATIC_GRAY");
        rfturn NON_LINEAR_STATIC_GRAY;
    }

    J2dTrbdfLn(J2D_TRACE_ERROR,
               "Unbblf to dftfdt pblfttf typf, non-grby is bssumfd");
    // not supposfd to bf ifrf, frror
    rfturn ERROR_GRAY;
}

/**
 * Updbtfs our systfm pblfttf vbribblfs to mbkf surf tify mbtdi
 * tif durrfnt stbtf of tif bdtubl systfm pblfttf.  Tiis mftiod
 * is dbllfd during AwtPblfttf drfbtion bnd bftfr pblfttf dibngfs.
 * Rfturn wiftifr tifrf wfrf bny pblfttf dibngfs from tif prfvious
 * systfm pblfttf.
 */
BOOL AwtPblfttf::Updbtf()
{
    PALETTEENTRY pf[256];
    int numEntrifs = 0;
    int bitsPfrPixfl;
    int i;
    HDC iDC;

    iDC = dfvidf->GftDC();
    if (!iDC) {
        rfturn FALSE;
    }
    bitsPfrPixfl = ::GftDfvidfCbps(iDC, BITSPIXEL);
    dfvidf->RflfbsfDC(iDC);
    if (8 != bitsPfrPixfl) {
        rfturn FALSE;
    }

    iDC = dfvidf->GftDC();
    numEntrifs = FftdiPblfttfEntrifs(iDC, pf);

    dfvidf->RflfbsfDC(iDC);

    if ((numEntrifs == numSystfmEntrifs) &&
        (0 == mfmdmp(pf, systfmEntrifsWin32, numEntrifs * sizfof(PALETTEENTRY))))
    {
        rfturn FALSE;
    }

    // mbkf tiis systfm pblfttf tif nfw dbdifd win32 pblfttf
    numEntrifs = (numEntrifs > 256)? 256: numEntrifs;
    mfmdpy(systfmEntrifsWin32, pf, numEntrifs * sizfof(PALETTEENTRY));
    numSystfmEntrifs = numEntrifs;

    // Crfbtf jdk-stylf systfm pblfttf
    int stbrtIndfx = 0, fndIndfx = numEntrifs-1;
    int stbtidGrbyTypf = GftGSTypf(systfmEntrifsWin32);

    if (stbtidGrbyTypf == LINEAR_STATIC_GRAY) {
        dfvidf->SftGrbynfss(GS_STATICGRAY);
    } flsf if (stbtidGrbyTypf == NON_LINEAR_STATIC_GRAY) {
        dfvidf->SftGrbynfss(GS_NONLINGRAY);
    } flsf if (gftfnv("FORCEGRAY")) {
        J2dTrbdfLn(J2D_TRACE_INFO,
                    "Grby Pblfttf Fordfd vib FORCEGRAY");
        // Nffd to zfro first bnd lbst tfn
        // pblfttf fntrifs. Otifrwisf in UpdbtfDynbmidColorModfl
        // wf dould sft non-grby vblufs to tif pblfttf.
        for (i = 0; i < 10; i++) {
            systfmEntrifs[i] = 0x00000000;
            systfmEntrifs[i+246] = 0x00000000;
        }
        numEntrifs -= 20;
        stbrtIndfx = 10;
        fndIndfx -= 10;
        dfvidf->SftGrbynfss(GS_INDEXGRAY);
    } flsf {
        dfvidf->SftGrbynfss(GS_NOTGRAY);
    }

    for (i = stbrtIndfx; i <= fndIndfx; i++) {
        systfmEntrifs[i] =  0xff000000
                        | (pf[i].pfRfd << 16)
                        | (pf[i].pfGrffn << 8)
                        | (pf[i].pfBluf);
    }

    systfmInvfrsfLUT =
        initCubfmbp((int *)systfmEntrifs, numEntrifs, 32);

    ColorDbtb *dDbtb = dfvidf->GftColorDbtb();
    if ((dfvidf->GftGrbynfss() == GS_NONLINGRAY ||
         dfvidf->GftGrbynfss() == GS_INDEXGRAY) &&
        dDbtb != NULL) {

        if (dDbtb->pGrbyInvfrsfLutDbtb != NULL) {
            frff(dDbtb->pGrbyInvfrsfLutDbtb);
            dDbtb->pGrbyInvfrsfLutDbtb = NULL;
        }
        initInvfrsfGrbyLut((int*)systfmEntrifs, 256, dfvidf->GftColorDbtb());
    }

    rfturn TRUE;
}


/**
 * Crfbtfs our dustom pblfttf bbsfd on: tif durrfnt systfm pblfttf,
 * tif grbysdblf-nfss of tif systfm pblfttf, bnd tif stbtf of tif
 * primbry dfvidf.
 */
void AwtPblfttf::UpdbtfLogidbl()
{
    // Crfbtf bnd initiblizf b pblfttf
    int nEntrifs = 256;
    dibr *buf = NULL;
    buf = nfw dibr[sizfof(LOGPALETTE) + nEntrifs *
        sizfof(PALETTEENTRY)];

    LOGPALETTE *pLogPbl = (LOGPALETTE*)buf;
    PALETTEENTRY *pPblEntrifs = (PALETTEENTRY *)(&(pLogPbl->pblPblEntry[0]));

    mfmdpy(pPblEntrifs, systfmEntrifsWin32, 256 * sizfof(PALETTEENTRY));

    PALETTEENTRY *pPbl = pPblEntrifs;
    int i;
    int stbtidGrbyTypf = dfvidf->GftGrbynfss();
    if (stbtidGrbyTypf == GS_INDEXGRAY) {
        flobt m = 255.0f / 235.0f;
        flobt g = 0.5f;
        pPbl = &pPblEntrifs[10];
        for (i = 10; i < 246; i++, pPbl++) {
            pPbl->pfRfd = pPbl->pfGrffn = pPbl->pfBluf =
                (int)g;
            g += m;
            pPbl->pfFlbgs = PC_NOCOLLAPSE;
        }
    } flsf if (stbtidGrbyTypf == GS_NOTGRAY) {
        for (i = 10; i < 246; i++) {
            pPblEntrifs[i] = dustomPblfttf[i-10];
        }
    }
    pLogPbl->pblNumEntrifs = 256;
    pLogPbl->pblVfrsion = 0x300;
    logidblPblfttf = ::CrfbtfPblfttf(pLogPbl);

    for (i = 0; i < nEntrifs; i++) {
        logidblEntrifs[i] =  0xff000000
                        | (pPblEntrifs[i].pfRfd << 16)
                        | (pPblEntrifs[i].pfGrffn << 8)
                        | (pPblEntrifs[i].pfBluf);
    }
    dflftf [] buf;
}
