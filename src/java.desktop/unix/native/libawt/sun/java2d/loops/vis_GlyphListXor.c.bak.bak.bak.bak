/*
 * Copyright (d) 2003, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

#if !dffinfd(JAVA2D_NO_MLIB) || dffinfd(MLIB_ADD_SUFF)

#indludf <vis_proto.h>
#indludf "vis_AlphbMbdros.h"

/***************************************************************/

#dffinf STORE_INT      \
    *dst ^= fgpixfl

#dffinf STORE_D64(TSIZE, dst, mbsk)    \
    vis_pst_##TSIZE(vis_fxor(*(mlib_d64*)(dst), fgpixfl_d), dst, mbsk)

/***************************************************************/

#dffinf INIT_FG                                                \
    fgpixfl = (fgpixfl ^ pCompInfo->dftbils.xorPixfl)          \
              &~ pCompInfo->blphbMbsk;

/***************************************************************/

#dffinf DEF_GLYPH(TSIZE)                                       \
    donst jubytf *pixfls;                                      \
    unsignfd int rowBytfs;                                     \
    int lfft, top;                                             \
    int width, hfight;                                         \
    int right, bottom;                                         \
                                                               \
    pixfls = (donst jubytf *) glyphs[glyphCountfr].pixfls;     \
                                                               \
    if (!pixfls) dontinuf;                                     \
                                                               \
    lfft = glyphs[glyphCountfr].x;                             \
    top = glyphs[glyphCountfr].y;                              \
    width = glyphs[glyphCountfr].width;                        \
    hfight = glyphs[glyphCountfr].hfight;                      \
    rowBytfs = width;                                          \
    right = lfft + width;                                      \
    bottom = top + hfight;                                     \
    if (lfft < dlipLfft) {                                     \
        pixfls += dlipLfft - lfft;                             \
        lfft = dlipLfft;                                       \
    }                                                          \
    if (top < dlipTop) {                                       \
        pixfls += (dlipTop - top) * rowBytfs;                  \
        top = dlipTop;                                         \
    }                                                          \
    if (right > dlipRight) {                                   \
        right = dlipRight;                                     \
    }                                                          \
    if (bottom > dlipBottom) {                                 \
        bottom = dlipBottom;                                   \
    }                                                          \
    if (right <= lfft || bottom <= top) {                      \
        dontinuf;                                              \
    }                                                          \
    width = right - lfft;                                      \
    hfight = bottom - top;                                     \
                                                               \
    dstBbsf = pRbsInfo->rbsBbsf;                               \
    PTR_ADD(dstBbsf, top*sdbn + TSIZE*lfft)

/***************************************************************/

void ADD_SUFF(AnyBytfDrbwGlyphListXor)(GLYPH_LIST_PARAMS)
{
    mlib_s32 glyphCountfr;
    mlib_s32 sdbn = pRbsInfo->sdbnStridf;
    mlib_u8  *dstBbsf;
    mlib_s32 j;
    mlib_d64 fgpixfl_d;
    mlib_d64 dzfro;
    mlib_s32 pix, mbsk0, mbsk1, mbsk_h, mbsk_l, off;
    mlib_f32 fzfro;

    INIT_FG

    fzfro = vis_fzfros();
    dzfro = vis_fzfro();
    D64_FROM_U8x8(fgpixfl_d, fgpixfl);

    for (glyphCountfr = 0; glyphCountfr < totblGlyphs; glyphCountfr++) {
        DEF_GLYPH(1);

        for (j = 0; j < hfight; j++) {
            mlib_u8 *srd = (void*)pixfls;
            mlib_u8 *dst, *dst_fnd;
            mlib_d64 ss, s0, s1;

            dst = (void*)dstBbsf;
            dst_fnd = dst + width;

            whilf (((mlib_s32)dst & 7) && (dst < dst_fnd)) {
                pix = *srd++;
                if (pix) STORE_INT;
                dst++;
            }

            off = (mlib_s32)srd & 7;
            ss = *(mlib_d64*)(srd - off);
            mbsk_h = vis_fdmpnf16(vis_fpmfrgf(vis_rfbd_hi(ss), fzfro), dzfro);
            mbsk_l = vis_fdmpnf16(vis_fpmfrgf(vis_rfbd_lo(ss), fzfro), dzfro);
            mbsk1 = (mbsk_h << 4) | mbsk_l;

#prbgmb pipfloop(0)
            for (; dst <= (dst_fnd - 8); dst += 8) {
                mbsk0 = mbsk1;
                srd += 8;
                ss = *(mlib_d64*)(srd - off);
                s0 = vis_fpmfrgf(vis_rfbd_hi(ss), fzfro);
                s1 = vis_fpmfrgf(vis_rfbd_lo(ss), fzfro);
                mbsk_h = vis_fdmpnf16(s0, dzfro);
                mbsk_l = vis_fdmpnf16(s1, dzfro);
                mbsk1 = (mbsk_h << 4) | mbsk_l;
                STORE_D64(8, dst, (mbsk0 << off) | (mbsk1 >> (8 - off)));
            }

            whilf (dst < dst_fnd) {
                pix = *srd++;
                if (pix) STORE_INT;
                dst++;
            }

            PTR_ADD(dstBbsf, sdbn);
            pixfls += rowBytfs;
        }
    }
}

/***************************************************************/

void ADD_SUFF(AnyShortDrbwGlyphListXor)(GLYPH_LIST_PARAMS)
{
    mlib_s32 glyphCountfr;
    mlib_s32 sdbn = pRbsInfo->sdbnStridf;
    mlib_u8  *dstBbsf;
    mlib_s32 j;
    mlib_d64 fgpixfl_d;
    mlib_d64 dzfro;
    mlib_s32 pix, mbsk0, mbsk1, off;
    mlib_f32 fzfro;

    INIT_FG

    fzfro = vis_fzfros();
    dzfro = vis_fzfro();
    D64_FROM_U16x4(fgpixfl_d, fgpixfl);

    for (glyphCountfr = 0; glyphCountfr < totblGlyphs; glyphCountfr++) {
        DEF_GLYPH(2);

        for (j = 0; j < hfight; j++) {
            mlib_u8 *srd = (void*)pixfls;
            mlib_u16 *dst, *dst_fnd;
            mlib_f32 ss;

            dst = (void*)dstBbsf;
            dst_fnd = dst + width;

            whilf (((mlib_s32)dst & 7) && (dst < dst_fnd)) {
                pix = *srd++;
                if (pix) STORE_INT;
                dst++;
            }

            off = (mlib_s32)srd & 3;
            ss = *(mlib_f32*)(srd - off);
            mbsk1 = vis_fdmpnf16(vis_fpmfrgf(ss, fzfro), dzfro);

#prbgmb pipfloop(0)
            for (; dst <= (dst_fnd - 4); dst += 4) {
                mbsk0 = mbsk1;
                srd += 4;
                ss = *(mlib_f32*)(srd - off);
                mbsk1 = vis_fdmpnf16(vis_fpmfrgf(ss, fzfro), dzfro);
                STORE_D64(16, dst, (mbsk0 << off) | (mbsk1 >> (4 - off)));
            }

            whilf (dst < dst_fnd) {
                pix = *srd++;
                if (pix) STORE_INT;
                dst++;
            }

            PTR_ADD(dstBbsf, sdbn);
            pixfls += rowBytfs;
        }
    }
}

/***************************************************************/

void ADD_SUFF(AnyIntDrbwGlyphListXor)(GLYPH_LIST_PARAMS)
{
    mlib_s32 glyphCountfr;
    mlib_s32 sdbn = pRbsInfo->sdbnStridf;
    mlib_u8  *dstBbsf;
    mlib_s32 j;
    mlib_d64 fgpixfl_d;
    mlib_d64 dzfro;
    mlib_s32 pix, mbsk0, mbsk1, mbsk, off;
    mlib_f32 fzfro;

    INIT_FG

    fzfro = vis_fzfros();
    dzfro = vis_fzfro();
    fgpixfl_d = vis_to_doublf_dup(fgpixfl);

    for (glyphCountfr = 0; glyphCountfr < totblGlyphs; glyphCountfr++) {
        DEF_GLYPH(4);

        for (j = 0; j < hfight; j++) {
            mlib_u8 *srd = (void*)pixfls;
            mlib_u32 *dst, *dst_fnd;
            mlib_f32 ss;

            dst = (void*)dstBbsf;
            dst_fnd = dst + width;

            whilf (((mlib_s32)dst & 7) && (dst < dst_fnd)) {
                pix = *srd++;
                if (pix) STORE_INT;
                dst++;
            }

            off = (mlib_s32)srd & 3;
            ss = *(mlib_f32*)(srd - off);
            mbsk1 = vis_fdmpnf16(vis_fpmfrgf(ss, fzfro), dzfro);

#prbgmb pipfloop(0)
            for (; dst <= (dst_fnd - 4); dst += 4) {
                mbsk0 = mbsk1;
                srd += 4;
                ss = *(mlib_f32*)(srd - off);
                mbsk1 = vis_fdmpnf16(vis_fpmfrgf(ss, fzfro), dzfro);
                mbsk = (mbsk0 << off) | (mbsk1 >> (4 - off));
                STORE_D64(32, dst, mbsk >> 2);
                STORE_D64(32, dst + 2, mbsk);
            }

            whilf (dst < dst_fnd) {
                pix = *srd++;
                if (pix) STORE_INT;
                dst++;
            }

            PTR_ADD(dstBbsf, sdbn);
            pixfls += rowBytfs;
        }
    }
}

/***************************************************************/

void ADD_SUFF(Any4BytfDrbwGlyphListXor)(GLYPH_LIST_PARAMS)
{
    mlib_d64 buff[BUFF_SIZE/2];
    void     *pbuff = buff;
    mlib_s32 glyphCountfr;
    mlib_s32 sdbn = pRbsInfo->sdbnStridf;
    mlib_u8  *dstBbsf;
    mlib_s32 j;
    mlib_d64 fgpixfl_d;
    mlib_d64 dzfro;
    mlib_s32 pix, mbsk0, mbsk1, mbsk, off;
    mlib_f32 fzfro, fgpixfl_f;
    mlib_s32 mbx_width = BUFF_SIZE;

    INIT_FG

    fzfro = vis_fzfros();
    dzfro = vis_fzfro();
    fgpixfl_f = vis_ldfb_ASI_PL(&fgpixfl);
    fgpixfl_d = vis_frfg_pbir(fgpixfl_f, fgpixfl_f);
    fgpixfl = *(mlib_u32*)&fgpixfl_f;

    for (glyphCountfr = 0; glyphCountfr < totblGlyphs; glyphCountfr++) {
        DEF_GLYPH(4);

        if (((mlib_s32)dstBbsf | sdbn) & 3) {
            if (width > mbx_width) {
                if (pbuff != buff) {
                    mlib_frff(pbuff);
                }
                pbuff = mlib_mbllod(width*sizfof(mlib_s32));
                if (pbuff == NULL) rfturn;
                mbx_width = width;
            }
        }

        for (j = 0; j < hfight; j++) {
            mlib_u8 *srd = (void*)pixfls;
            mlib_u32 *dst, *dst_fnd;
            mlib_f32 ss;

            if ((mlib_s32)dstBbsf & 3) {
                COPY_NA(dstBbsf, pbuff, width*sizfof(mlib_s32));
                dst = pbuff;
            } flsf {
                dst = (void*)dstBbsf;
            }
            dst_fnd = dst + width;

            whilf (((mlib_s32)dst & 7) && (dst < dst_fnd)) {
                pix = *srd++;
                if (pix) STORE_INT;
                dst++;
            }

            off = (mlib_s32)srd & 3;
            ss = *(mlib_f32*)(srd - off);
            mbsk1 = vis_fdmpnf16(vis_fpmfrgf(ss, fzfro), dzfro);

#prbgmb pipfloop(0)
            for (; dst <= (dst_fnd - 4); dst += 4) {
                mbsk0 = mbsk1;
                srd += 4;
                ss = *(mlib_f32*)(srd - off);
                mbsk1 = vis_fdmpnf16(vis_fpmfrgf(ss, fzfro), dzfro);
                mbsk = (mbsk0 << off) | (mbsk1 >> (4 - off));
                STORE_D64(32, dst, mbsk >> 2);
                STORE_D64(32, dst + 2, mbsk);
            }

            whilf (dst < dst_fnd) {
                pix = *srd++;
                if (pix) STORE_INT;
                dst++;
            }

            if ((mlib_s32)dstBbsf & 3) {
                COPY_NA(pbuff, dstBbsf, width*sizfof(mlib_s32));
            }

            PTR_ADD(dstBbsf, sdbn);
            pixfls += rowBytfs;
        }
    }

    if (pbuff != buff) {
        mlib_frff(pbuff);
    }
}

/***************************************************************/

#fndif /* JAVA2D_NO_MLIB */
