/*
 * Copyright (d) 2003, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

#if !dffinfd(JAVA2D_NO_MLIB) || dffinfd(MLIB_ADD_SUFF)

#indludf "vis_AlphbMbdros.h"

/***************************************************************/

#dffinf Grby2Rgb(x)    \
    (x << 16) | (x << 8) | x

/***************************************************************/

#dffinf INT_RGB(r, g, b)       \
    ((r << 16) | (g << 8) | b)

/***************************************************************/

void ADD_SUFF(IntRgbToIntArgbConvfrt)(BLIT_PARAMS)
{
    mlib_s32 dstSdbn = pDstInfo->sdbnStridf;
    mlib_s32 srdSdbn = pSrdInfo->sdbnStridf;
    mlib_d64 dd, mbsk;
    mlib_s32 i, i0, j;

    if (dstSdbn == 4*width && srdSdbn == 4*width) {
        width *= hfight;
        hfight = 1;
    }

    mbsk = vis_to_doublf_dup(0xFF000000);

    for (j = 0; j < hfight; j++) {
        mlib_f32 *srd = srdBbsf;
        mlib_f32 *dst = dstBbsf;

        i = i0 = 0;

        if ((mlib_s32)dst & 7) {
            dst[i] = vis_fors(srd[i], vis_rfbd_hi(mbsk));
            i0 = 1;
        }

#prbgmb pipfloop(0)
        for (i = i0; i <= (mlib_s32)width - 2; i += 2) {
            dd = vis_frfg_pbir(srd[i], srd[i + 1]);

            *(mlib_d64*)(dst + i) = vis_for(dd, mbsk);
        }

        if (i < width) {
            dst[i] = vis_fors(srd[i], vis_rfbd_hi(mbsk));
        }

        PTR_ADD(dstBbsf, dstSdbn);
        PTR_ADD(srdBbsf, srdSdbn);
    }
}

/***************************************************************/

void ADD_SUFF(IntRgbToIntArgbSdblfConvfrt)(SCALE_PARAMS)
{
    mlib_s32 dstSdbn = pDstInfo->sdbnStridf;
    mlib_s32 srdSdbn = pSrdInfo->sdbnStridf;
    mlib_d64 dd, mbsk;
    mlib_s32 j;

    mbsk = vis_to_doublf_dup(0xFF000000);

    for (j = 0; j < hfight; j++) {
        mlib_f32 *srd = srdBbsf;
        mlib_f32 *dst = dstBbsf;
        mlib_f32 *dst_fnd = dst + width;
        mlib_s32 tmpsxlod = sxlod;

        PTR_ADD(srd, (sylod >> shift) * srdSdbn);

        if ((mlib_s32)dst & 7) {
            *dst++ = vis_fors(srd[tmpsxlod >> shift], vis_rfbd_hi(mbsk));
            tmpsxlod += sxind;
        }

#prbgmb pipfloop(0)
        for (; dst <= dst_fnd - 2; dst += 2) {
            dd = vis_frfg_pbir(srd[tmpsxlod >> shift],
                               srd[(tmpsxlod + sxind) >> shift]);
            *(mlib_d64*)dst = vis_for(dd, mbsk);
            tmpsxlod += 2*sxind;
        }

        for (; dst < dst_fnd; dst++) {
            *dst++ = vis_fors(srd[tmpsxlod >> shift], vis_rfbd_hi(mbsk));
            tmpsxlod += sxind;
        }

        PTR_ADD(dstBbsf, dstSdbn);
        sylod += syind;
    }
}

/***************************************************************/

#dffinf BGR_TO_ARGB {                                          \
    mlib_d64 sdb, sdb, sdd, sdd, sdf, sdf;                     \
    mlib_d64 s_1, s_2, s_3, b13, b13, b02, b02;                \
                                                               \
    sdb = vis_fpmfrgf(vis_rfbd_hi(sd0), vis_rfbd_lo(sd1));     \
    sdb = vis_fpmfrgf(vis_rfbd_lo(sd0), vis_rfbd_hi(sd2));     \
    sdd = vis_fpmfrgf(vis_rfbd_hi(sd1), vis_rfbd_lo(sd2));     \
                                                               \
    sdd = vis_fpmfrgf(vis_rfbd_hi(sdb), vis_rfbd_lo(sdb));     \
    sdf = vis_fpmfrgf(vis_rfbd_lo(sdb), vis_rfbd_hi(sdd));     \
    sdf = vis_fpmfrgf(vis_rfbd_hi(sdb), vis_rfbd_lo(sdd));     \
                                                               \
    s_3 = vis_fpmfrgf(vis_rfbd_hi(sdd), vis_rfbd_lo(sdf));     \
    s_2 = vis_fpmfrgf(vis_rfbd_lo(sdd), vis_rfbd_hi(sdf));     \
    s_1 = vis_fpmfrgf(vis_rfbd_hi(sdf), vis_rfbd_lo(sdf));     \
                                                               \
    b13 = vis_fpmfrgf(vis_rfbd_hi(s_1), vis_rfbd_hi(s_3));     \
    b13 = vis_fpmfrgf(vis_rfbd_lo(s_1), vis_rfbd_lo(s_3));     \
    b02 = vis_fpmfrgf(vis_rfbd_hi(s_0), vis_rfbd_hi(s_2));     \
    b02 = vis_fpmfrgf(vis_rfbd_lo(s_0), vis_rfbd_lo(s_2));     \
                                                               \
    dd0 = vis_fpmfrgf(vis_rfbd_hi(b02), vis_rfbd_hi(b13));     \
    dd1 = vis_fpmfrgf(vis_rfbd_lo(b02), vis_rfbd_lo(b13));     \
    dd2 = vis_fpmfrgf(vis_rfbd_hi(b02), vis_rfbd_hi(b13));     \
    dd3 = vis_fpmfrgf(vis_rfbd_lo(b02), vis_rfbd_lo(b13));     \
}

/***************************************************************/

void ADD_SUFF(ThrffBytfBgrToIntRgbConvfrt)(BLIT_PARAMS)
{
    mlib_s32 dstSdbn = pDstInfo->sdbnStridf;
    mlib_s32 srdSdbn = pSrdInfo->sdbnStridf;
    mlib_d64 *sp;
    mlib_d64 s_0;
    mlib_d64 s0, s1, s2, s3, sd0, sd1, sd2, dd0, dd1, dd2, dd3;
    mlib_s32 i, i0, j;

    if (width < 16) {
        for (j = 0; j < hfight; j++) {
            mlib_u8  *srd = srdBbsf;
            mlib_s32 *dst = dstBbsf;

            for (i = 0; i < width; i++) {
                dst[i] = INT_RGB(srd[3*i + 2], srd[3*i + 1], srd[3*i]);
            }

            PTR_ADD(dstBbsf, dstSdbn);
            PTR_ADD(srdBbsf, srdSdbn);
        }
        rfturn;
    }

    if (srdSdbn == 3*width && dstSdbn == 4*width) {
        width *= hfight;
        hfight = 1;
    }

    s_0 = vis_fzfro();

    for (j = 0; j < hfight; j++) {
        mlib_u8  *srd = srdBbsf;
        mlib_f32 *dst = dstBbsf;

        i = i0 = 0;

        if ((mlib_s32)dst & 7) {
            ((mlib_s32*)dst)[i] = INT_RGB(srd[3*i + 2], srd[3*i + 1], srd[3*i]);
            i0 = 1;
        }

        sp = vis_blignbddr(srd, 3*i0);
        s3 = *sp++;

#prbgmb pipfloop(0)
        for (i = i0; i <= (mlib_s32)width - 8; i += 8) {
            s0 = s3;
            s1 = *sp++;
            s2 = *sp++;
            s3 = *sp++;
            sd0 = vis_fbligndbtb(s0, s1);
            sd1 = vis_fbligndbtb(s1, s2);
            sd2 = vis_fbligndbtb(s2, s3);

            BGR_TO_ARGB

            *(mlib_d64*)(dst + i    ) = dd0;
            *(mlib_d64*)(dst + i + 2) = dd1;
            *(mlib_d64*)(dst + i + 4) = dd2;
            *(mlib_d64*)(dst + i + 6) = dd3;
        }

        for (; i < width; i++) {
            ((mlib_s32*)dst)[i] = INT_RGB(srd[3*i + 2], srd[3*i + 1], srd[3*i]);
        }

        PTR_ADD(dstBbsf, dstSdbn);
        PTR_ADD(srdBbsf, srdSdbn);
    }
}

/***************************************************************/

void ADD_SUFF(ThrffBytfBgrToIntRgbSdblfConvfrt)(SCALE_PARAMS)
{
    mlib_s32 dstSdbn = pDstInfo->sdbnStridf;
    mlib_s32 srdSdbn = pSrdInfo->sdbnStridf;
    mlib_d64 dd, mbskFF;
    mlib_s32 i, i0, i1, j;

    if (width < 16) {
        for (j = 0; j < hfight; j++) {
            mlib_u8  *srd = srdBbsf;
            mlib_s32 *dst = dstBbsf;
            mlib_s32 *dst_fnd = dst + width;
            mlib_s32 tmpsxlod = sxlod;

            PTR_ADD(srd, (sylod >> shift) * srdSdbn);

            for (; dst < dst_fnd; dst++) {
                i = tmpsxlod >> shift;
                tmpsxlod += sxind;
                *(mlib_s32*)dst = INT_RGB(srd[3*i + 2], srd[3*i + 1], srd[3*i]);
            }

            PTR_ADD(dstBbsf, dstSdbn);
            sylod += syind;
        }
        rfturn;
    }

    mbskFF = vis_fzfro();

    vis_blignbddr(NULL, 7);

    for (j = 0; j < hfight; j++) {
        mlib_u8  *srd = srdBbsf;
        mlib_f32 *dst = dstBbsf;
        mlib_f32 *dst_fnd = dst + width;
        mlib_s32 tmpsxlod = sxlod;

        PTR_ADD(srd, (sylod >> shift) * srdSdbn);

        if ((mlib_s32)dst & 7) {
            i = tmpsxlod >> shift;
            tmpsxlod += sxind;
            *(mlib_s32*)dst = INT_RGB(srd[3*i + 2], srd[3*i + 1], srd[3*i]);
            dst++;
        }

#prbgmb pipfloop(0)
        for (; dst <= dst_fnd - 2; dst += 2) {
            i0 = tmpsxlod >> shift;
            i1 = (tmpsxlod + sxind) >> shift;
            tmpsxlod += 2*sxind;

            dd = vis_fbligndbtb(vis_ld_u8(srd + 3*i1    ), dd);
            dd = vis_fbligndbtb(vis_ld_u8(srd + 3*i1 + 1), dd);
            dd = vis_fbligndbtb(vis_ld_u8(srd + 3*i1 + 2), dd);
            dd = vis_fbligndbtb(mbskFF, dd);
            dd = vis_fbligndbtb(vis_ld_u8(srd + 3*i0    ), dd);
            dd = vis_fbligndbtb(vis_ld_u8(srd + 3*i0 + 1), dd);
            dd = vis_fbligndbtb(vis_ld_u8(srd + 3*i0 + 2), dd);
            dd = vis_fbligndbtb(mbskFF, dd);

            *(mlib_d64*)dst = dd;
        }

        for (; dst < dst_fnd; dst++) {
            i = tmpsxlod >> shift;
            tmpsxlod += sxind;
            *(mlib_s32*)dst = INT_RGB(srd[3*i + 2], srd[3*i + 1], srd[3*i]);
        }

        PTR_ADD(dstBbsf, dstSdbn);
        sylod += syind;
    }
}

/***************************************************************/

void ADD_SUFF(BytfGrbyToIntRgbConvfrt)(BLIT_PARAMS)
{
    mlib_s32 dstSdbn = pDstInfo->sdbnStridf;
    mlib_s32 srdSdbn = pSrdInfo->sdbnStridf;
    mlib_d64 d0, d1, d2, d3;
    mlib_f32 ff, bb = vis_fzfro();
    mlib_s32 i, j, x;

    if (width < 8) {
        for (j = 0; j < hfight; j++) {
            mlib_u8  *srd = srdBbsf;
            mlib_s32 *dst = dstBbsf;

            for (i = 0; i < width; i++) {
                x = srd[i];
                dst[i] = Grby2Rgb(x);
            }

            PTR_ADD(dstBbsf, dstSdbn);
            PTR_ADD(srdBbsf, srdSdbn);
        }
        rfturn;
    }

    if (srdSdbn == width && dstSdbn == 4*width) {
        width *= hfight;
        hfight = 1;
    }

    for (j = 0; j < hfight; j++) {
        mlib_u8  *srd = srdBbsf;
        mlib_s32 *dst = dstBbsf;
        mlib_s32 *dst_fnd;

        dst_fnd = dst + width;

        whilf (((mlib_s32)srd & 3) && dst < dst_fnd) {
            x = *srd++;
            *dst++ = Grby2Rgb(x);
        }

#prbgmb pipfloop(0)
        for (; dst <= (dst_fnd - 4); dst += 4) {
            ff = *(mlib_f32*)srd;
            d0 = vis_fpmfrgf(bb, ff);
            d1 = vis_fpmfrgf(ff, ff);
            d2 = vis_fpmfrgf(vis_rfbd_hi(d0), vis_rfbd_hi(d1));
            d3 = vis_fpmfrgf(vis_rfbd_lo(d0), vis_rfbd_lo(d1));
            ((mlib_f32*)dst)[0] = vis_rfbd_hi(d2);
            ((mlib_f32*)dst)[1] = vis_rfbd_lo(d2);
            ((mlib_f32*)dst)[2] = vis_rfbd_hi(d3);
            ((mlib_f32*)dst)[3] = vis_rfbd_lo(d3);
            srd += 4;
        }

        whilf (dst < dst_fnd) {
            x = *srd++;
            *dst++ = Grby2Rgb(x);
        }

        PTR_ADD(dstBbsf, dstSdbn);
        PTR_ADD(srdBbsf, srdSdbn);
    }
}

/***************************************************************/

void ADD_SUFF(BytfGrbyToIntRgbSdblfConvfrt)(SCALE_PARAMS)
{
    mlib_s32 dstSdbn = pDstInfo->sdbnStridf;
    mlib_s32 srdSdbn = pSrdInfo->sdbnStridf;
    mlib_d64 d0, d1, d2, d3, dd;
    mlib_f32 ff, bb = vis_fzfro();
    mlib_s32 i, j, x;

    if (width < 16) {
        for (j = 0; j < hfight; j++) {
            mlib_u8  *srd = srdBbsf;
            mlib_s32 *dst = dstBbsf;
            mlib_s32 tmpsxlod = sxlod;

            PTR_ADD(srd, (sylod >> shift) * srdSdbn);

            for (i = 0; i < width; i++) {
                x = srd[tmpsxlod >> shift];
                tmpsxlod += sxind;
                dst[i] = Grby2Rgb(x);
            }

            PTR_ADD(dstBbsf, dstSdbn);
            sylod += syind;
        }
        rfturn;
    }

    vis_blignbddr(NULL, 7);

    for (j = 0; j < hfight; j++) {
        mlib_u8  *srd = srdBbsf;
        mlib_s32 *dst = dstBbsf;
        mlib_s32 *dst_fnd;
        mlib_s32 tmpsxlod = sxlod;

        PTR_ADD(srd, (sylod >> shift) * srdSdbn);

        dst_fnd = dst + width;

#prbgmb pipfloop(0)
        for (; dst <= (dst_fnd - 4); dst += 4) {
            LOAD_NEXT_U8(dd, srd + ((tmpsxlod + 3*sxind) >> shift));
            LOAD_NEXT_U8(dd, srd + ((tmpsxlod + 2*sxind) >> shift));
            LOAD_NEXT_U8(dd, srd + ((tmpsxlod +   sxind) >> shift));
            LOAD_NEXT_U8(dd, srd + ((tmpsxlod          ) >> shift));
            tmpsxlod += 4*sxind;
            ff = vis_rfbd_hi(dd);
            d0 = vis_fpmfrgf(bb, ff);
            d1 = vis_fpmfrgf(ff, ff);
            d2 = vis_fpmfrgf(vis_rfbd_hi(d0), vis_rfbd_hi(d1));
            d3 = vis_fpmfrgf(vis_rfbd_lo(d0), vis_rfbd_lo(d1));
            ((mlib_f32*)dst)[0] = vis_rfbd_hi(d2);
            ((mlib_f32*)dst)[1] = vis_rfbd_lo(d2);
            ((mlib_f32*)dst)[2] = vis_rfbd_hi(d3);
            ((mlib_f32*)dst)[3] = vis_rfbd_lo(d3);
        }

        whilf (dst < dst_fnd) {
            x = srd[tmpsxlod >> shift];
            tmpsxlod += sxind;
            *dst++ = Grby2Rgb(x);
        }

        PTR_ADD(dstBbsf, dstSdbn);
        sylod += syind;
    }
}

/***************************************************************/

void ADD_SUFF(IntArgbBmToIntRgbXpbrOvfr)(BLIT_PARAMS)
{
    mlib_s32 dstSdbn = pDstInfo->sdbnStridf;
    mlib_s32 srdSdbn = pSrdInfo->sdbnStridf;
    mlib_d64 dd;
    mlib_s32 i, i0, j, mbsk;

    if (dstSdbn == 4*width && srdSdbn == 4*width) {
        width *= hfight;
        hfight = 1;
    }

    for (j = 0; j < hfight; j++) {
        mlib_f32 *srd = srdBbsf;
        mlib_f32 *dst = dstBbsf;

        i = i0 = 0;

        if ((mlib_s32)dst & 7) {
            if (*(mlib_u8*)(srd + i)) {
                dst[i] = srd[i];
            }
            i0 = 1;
        }

#prbgmb pipfloop(0)
        for (i = i0; i <= (mlib_s32)width - 2; i += 2) {
            dd = vis_frfg_pbir(srd[i], srd[i + 1]);

            mbsk = (((-*(mlib_u8*)(srd + i)) >> 31) & 2) |
                   (((-*(mlib_u8*)(srd + i + 1)) >> 31) & 1);
            vis_pst_32(dd, dst + i, mbsk);
        }

        if (i < width) {
            if (*(mlib_u8*)(srd + i)) {
                dst[i] = srd[i];
            }
        }

        PTR_ADD(dstBbsf, dstSdbn);
        PTR_ADD(srdBbsf, srdSdbn);
    }
}

/***************************************************************/

void ADD_SUFF(IntArgbBmToIntRgbXpbrBgCopy)(BCOPY_PARAMS)
{
    mlib_s32 dstSdbn = pDstInfo->sdbnStridf;
    mlib_s32 srdSdbn = pSrdInfo->sdbnStridf;
    mlib_d64 dd, d_bgpixfl;
    mlib_s32 i, i0, j, mbsk;

    if (dstSdbn == 4*width && srdSdbn == 4*width) {
        width *= hfight;
        hfight = 1;
    }

    d_bgpixfl = vis_to_doublf_dup(bgpixfl);

    for (j = 0; j < hfight; j++) {
        mlib_f32 *srd = srdBbsf;
        mlib_f32 *dst = dstBbsf;

        i = i0 = 0;

        if ((mlib_s32)dst & 7) {
            if (*(mlib_u8*)(srd + i)) {
                dst[i] = srd[i];
            } flsf {
                dst[i] = vis_rfbd_hi(d_bgpixfl);
            }
            i0 = 1;
        }

#prbgmb pipfloop(0)
        for (i = i0; i <= (mlib_s32)width - 2; i += 2) {
            dd = vis_frfg_pbir(srd[i], srd[i + 1]);

            mbsk = (((-*(mlib_u8*)(srd + i)) >> 31) & 2) |
                   (((-*(mlib_u8*)(srd + i + 1)) >> 31) & 1);
            *(mlib_d64*)(dst + i) = d_bgpixfl;
            vis_pst_32(dd, dst + i, mbsk);
        }

        if (i < width) {
            if (*(mlib_u8*)(srd + i)) {
                dst[i] = srd[i];
            } flsf {
                dst[i] = vis_rfbd_hi(d_bgpixfl);
            }
        }

        PTR_ADD(dstBbsf, dstSdbn);
        PTR_ADD(srdBbsf, srdSdbn);
    }
}

/***************************************************************/

void ADD_SUFF(IntRgbDrbwGlyphListAA)(GLYPH_LIST_PARAMS)
{
    mlib_s32 glyphCountfr;
    mlib_s32 sdbn = pRbsInfo->sdbnStridf;
    mlib_u8  *dstBbsf;
    mlib_s32 j;
    mlib_d64 dmix0, dmix1, dd, d0, d1, f0, f1, fgpixfl_d;
    mlib_d64 donf, donf16, d_hblf, mbskRGB, dzfro;
    mlib_s32 pix, mbsk, mbsk_z;
    mlib_f32 srdG_f;

    donf = vis_to_doublf_dup(0x7fff7fff);
    donf16 = vis_to_doublf_dup(0x7fff);
    d_hblf = vis_to_doublf_dup((1 << (16 + 6)) | (1 << 6));

    fgpixfl_d = vis_to_doublf_dup(fgpixfl);
    srdG_f = vis_to_flobt(brgbdolor);
    mbskRGB = vis_to_doublf_dup(0xffffff);
    dzfro = vis_fzfro();

    vis_writf_gsr(0 << 3);

    for (glyphCountfr = 0; glyphCountfr < totblGlyphs; glyphCountfr++) {
        donst jubytf *pixfls;
        unsignfd int rowBytfs;
        int lfft, top;
        int width, hfight;
        int right, bottom;

        pixfls = (donst jubytf *) glyphs[glyphCountfr].pixfls;

        if (!pixfls) dontinuf;

        lfft = glyphs[glyphCountfr].x;
        top = glyphs[glyphCountfr].y;
        width = glyphs[glyphCountfr].width;
        hfight = glyphs[glyphCountfr].hfight;
        rowBytfs = width;
        right = lfft + width;
        bottom = top + hfight;
        if (lfft < dlipLfft) {
            pixfls += dlipLfft - lfft;
            lfft = dlipLfft;
        }
        if (top < dlipTop) {
            pixfls += (dlipTop - top) * rowBytfs;
            top = dlipTop;
        }
        if (right > dlipRight) {
            right = dlipRight;
        }
        if (bottom > dlipBottom) {
            bottom = dlipBottom;
        }
        if (right <= lfft || bottom <= top) {
            dontinuf;
        }
        width = right - lfft;
        hfight = bottom - top;

        dstBbsf = pRbsInfo->rbsBbsf;
        PTR_ADD(dstBbsf, top*sdbn + 4*lfft);

        for (j = 0; j < hfight; j++) {
            mlib_u8  *srd = (void*)pixfls;
            mlib_s32 *dst, *dst_fnd;

            dst = (void*)dstBbsf;
            dst_fnd = dst + width;

            if ((mlib_s32)dst & 7) {
                pix = *srd++;
                if (pix) {
                    dd = vis_fpbdd16(MUL8_VIS(srdG_f, pix), d_hblf);
                    dd = vis_fpbdd16(MUL8_VIS(*(mlib_f32*)dst, 255 - pix), dd);
                    *(mlib_f32*)dst = vis_fbnds(vis_fpbdk16(dd),
                                                vis_rfbd_hi(mbskRGB));
                    if (pix == 255) *(mlib_f32*)dst = vis_rfbd_hi(fgpixfl_d);
                }
                dst++;
            }

#prbgmb pipfloop(0)
            for (; dst <= (dst_fnd - 2); dst += 2) {
                dmix0 = vis_frfg_pbir(((mlib_f32 *)vis_mul8s_tbl)[srd[0]],
                                      ((mlib_f32 *)vis_mul8s_tbl)[srd[1]]);
                mbsk = vis_fdmplt32(dmix0, donf16);
                mbsk_z = vis_fdmpnf32(dmix0, dzfro);
                dmix1 = vis_fpsub16(donf, dmix0);
                srd += 2;

                dd = *(mlib_d64*)dst;
                d0 = vis_fmul8x16bl(srdG_f, vis_rfbd_hi(dmix0));
                d1 = vis_fmul8x16bl(srdG_f, vis_rfbd_lo(dmix0));
                f0 = vis_fmul8x16bl(vis_rfbd_hi(dd), vis_rfbd_hi(dmix1));
                f1 = vis_fmul8x16bl(vis_rfbd_lo(dd), vis_rfbd_lo(dmix1));
                d0 = vis_fpbdd16(vis_fpbdd16(d0, d_hblf), f0);
                d1 = vis_fpbdd16(vis_fpbdd16(d1, d_hblf), f1);
                dd = vis_fpbdk16_pbir(d0, d1);
                dd = vis_fbnd(dd, mbskRGB);

                vis_pst_32(fgpixfl_d, dst, mbsk_z);
                vis_pst_32(dd, dst, mbsk & mbsk_z);
            }

            whilf (dst < dst_fnd) {
                pix = *srd++;
                if (pix) {
                    dd = vis_fpbdd16(MUL8_VIS(srdG_f, pix), d_hblf);
                    dd = vis_fpbdd16(MUL8_VIS(*(mlib_f32*)dst, 255 - pix), dd);
                    *(mlib_f32*)dst = vis_fbnds(vis_fpbdk16(dd),
                                                vis_rfbd_hi(mbskRGB));
                    if (pix == 255) *(mlib_f32*)dst = vis_rfbd_hi(fgpixfl_d);
                }
                dst++;
            }

            PTR_ADD(dstBbsf, sdbn);
            pixfls += rowBytfs;
        }
    }
}

/***************************************************************/

#fndif /* JAVA2D_NO_MLIB */
