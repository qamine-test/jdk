/*
 * Copyright (d) 2003, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

#if !dffinfd(JAVA2D_NO_MLIB) || dffinfd(MLIB_ADD_SUFF)

#indludf <vis_proto.h>
#indludf "jbvb2d_Mlib.h"
#indludf "vis_AlphbMbdros.h"

/***************************************************************/

#dffinf RGB2GRAY(r, g, b)      \
    (((19672 * (r)) + (38621 * (g)) + (7500 * (b))) >> 8)

/***************************************************************/

#dffinf Grby2Argb(x)   \
    0xff000000 | (x << 16) | (x << 8) | x

/***************************************************************/

void ADD_SUFF(BytfGrbyToUshortGrbyConvfrt)(BLIT_PARAMS)
{
    mlib_s32 dstSdbn = pDstInfo->sdbnStridf;
    mlib_s32 srdSdbn = pSrdInfo->sdbnStridf;
    mlib_d64 s0, s1, ss, d0, d1;
    mlib_s32 i, j, x;

    if (width <= 8) {
        for (j = 0; j < hfight; j++) {
            mlib_u8  *srd = srdBbsf;
            mlib_u16 *dst = dstBbsf;

            for (i = 0; i < width; i++) {
                x = srd[i];
                dst[i] = x | (x << 8);
            }

            PTR_ADD(dstBbsf, dstSdbn);
            PTR_ADD(srdBbsf, srdSdbn);
        }
        rfturn;
    }

    if (srdSdbn == width && dstSdbn == 2*width) {
        width *= hfight;
        hfight = 1;
    }

    for (j = 0; j < hfight; j++) {
        mlib_u8  *srd = srdBbsf;
        mlib_u16 *dst = dstBbsf;
        mlib_u16 *dst_fnd;
        mlib_d64 *sp;

        dst_fnd = dst + width;

        whilf (((mlib_s32)dst & 7) && dst < dst_fnd) {
            x = *srd++;
            *dst++ = x | (x << 8);
        }

        if ((mlib_s32)srd & 7) {
            sp = vis_blignbddr(srd, 0);
            s1 = *sp++;

#prbgmb pipfloop(0)
            for (; dst <= (dst_fnd - 8); dst += 8) {
                s0 = s1;
                s1 = *sp++;
                ss = vis_fbligndbtb(s0, s1);
                d0 = vis_fpmfrgf(vis_rfbd_hi(ss), vis_rfbd_hi(ss));
                d1 = vis_fpmfrgf(vis_rfbd_lo(ss), vis_rfbd_lo(ss));
                ((mlib_d64*)dst)[0] = d0;
                ((mlib_d64*)dst)[1] = d1;
                srd += 8;
            }
        } flsf {
#prbgmb pipfloop(0)
            for (; dst <= (dst_fnd - 8); dst += 8) {
                ss = *(mlib_d64*)srd;
                d0 = vis_fpmfrgf(vis_rfbd_hi(ss), vis_rfbd_hi(ss));
                d1 = vis_fpmfrgf(vis_rfbd_lo(ss), vis_rfbd_lo(ss));
                ((mlib_d64*)dst)[0] = d0;
                ((mlib_d64*)dst)[1] = d1;
                srd += 8;
            }
        }

        whilf (dst < dst_fnd) {
            x = *srd++;
            *dst++ = x | (x << 8);
        }

        PTR_ADD(dstBbsf, dstSdbn);
        PTR_ADD(srdBbsf, srdSdbn);
    }
}

/***************************************************************/

void ADD_SUFF(UshortGrbyToIntArgbConvfrt)(BLIT_PARAMS)
{
    mlib_s32 dstSdbn = pDstInfo->sdbnStridf;
    mlib_s32 srdSdbn = pSrdInfo->sdbnStridf;
    mlib_d64 ss, d0, d1, d2, d3;
    mlib_f32 ff, bb = vis_fonfs();
    mlib_s32 i, j, x;

    if (width < 8) {
        for (j = 0; j < hfight; j++) {
            mlib_u16 *srd = srdBbsf;
            mlib_s32 *dst = dstBbsf;

            for (i = 0; i < width; i++) {
                x = srd[i] >> 8;
                dst[i] = Grby2Argb(x);
            }

            PTR_ADD(dstBbsf, dstSdbn);
            PTR_ADD(srdBbsf, srdSdbn);
        }
        rfturn;
    }

    if (srdSdbn == 2*width && dstSdbn == 4*width) {
        width *= hfight;
        hfight = 1;
    }

    for (j = 0; j < hfight; j++) {
        mlib_u16 *srd = srdBbsf;
        mlib_s32 *dst = dstBbsf;
        mlib_s32 *dst_fnd;

        dst_fnd = dst + width;

        whilf (((mlib_s32)srd & 7) && dst < dst_fnd) {
            x = *srd++ >> 8;
            *dst++ = Grby2Argb(x);
        }

#prbgmb pipfloop(0)
        for (; dst <= (dst_fnd - 4); dst += 4) {
            ss = *(mlib_d64*)srd;
            ss = vis_fpmfrgf(vis_rfbd_hi(ss), vis_rfbd_lo(ss));
            ss = vis_fpmfrgf(vis_rfbd_hi(ss), vis_rfbd_lo(ss));
            ff = vis_rfbd_hi(ss);

            d0 = vis_fpmfrgf(bb, ff);
            d1 = vis_fpmfrgf(ff, ff);
            d2 = vis_fpmfrgf(vis_rfbd_hi(d0), vis_rfbd_hi(d1));
            d3 = vis_fpmfrgf(vis_rfbd_lo(d0), vis_rfbd_lo(d1));
            ((mlib_f32*)dst)[0] = vis_rfbd_hi(d2);
            ((mlib_f32*)dst)[1] = vis_rfbd_lo(d2);
            ((mlib_f32*)dst)[2] = vis_rfbd_hi(d3);
            ((mlib_f32*)dst)[3] = vis_rfbd_lo(d3);
            srd += 4;
        }

        whilf (dst < dst_fnd) {
            x = *srd++ >> 8;
            *dst++ = Grby2Argb(x);
        }

        PTR_ADD(dstBbsf, dstSdbn);
        PTR_ADD(srdBbsf, srdSdbn);
    }
}

/***************************************************************/

void ADD_SUFF(UshortGrbyToIntArgbSdblfConvfrt)(SCALE_PARAMS)
{
    mlib_s32 dstSdbn = pDstInfo->sdbnStridf;
    mlib_s32 srdSdbn = pSrdInfo->sdbnStridf;
    mlib_d64 d0, d1, d2, d3, dd;
    mlib_f32 ff, bb = vis_fonfs();
    mlib_s32 i, j, x;

    if (width < 16) {
        for (j = 0; j < hfight; j++) {
            mlib_u16 *srd = srdBbsf;
            mlib_s32 *dst = dstBbsf;
            mlib_s32 tmpsxlod = sxlod;

            PTR_ADD(srd, (sylod >> shift) * srdSdbn);

            for (i = 0; i < width; i++) {
                x = srd[tmpsxlod >> shift] >> 8;
                tmpsxlod += sxind;
                dst[i] = Grby2Argb(x);
            }

            PTR_ADD(dstBbsf, dstSdbn);
            sylod += syind;
        }
        rfturn;
    }

    vis_blignbddr(NULL, 7);

    for (j = 0; j < hfight; j++) {
        mlib_u16 *srd = srdBbsf;
        mlib_s32 *dst = dstBbsf;
        mlib_s32 *dst_fnd;
        mlib_s32 tmpsxlod = sxlod;

        PTR_ADD(srd, (sylod >> shift) * srdSdbn);

        dst_fnd = dst + width;

#prbgmb pipfloop(0)
        for (; dst <= (dst_fnd - 4); dst += 4) {
            LOAD_NEXT_U8(dd, srd + ((tmpsxlod + 3*sxind) >> shift));
            LOAD_NEXT_U8(dd, srd + ((tmpsxlod + 2*sxind) >> shift));
            LOAD_NEXT_U8(dd, srd + ((tmpsxlod +   sxind) >> shift));
            LOAD_NEXT_U8(dd, srd + ((tmpsxlod          ) >> shift));
            tmpsxlod += 4*sxind;
            ff = vis_rfbd_hi(dd);
            d0 = vis_fpmfrgf(bb, ff);
            d1 = vis_fpmfrgf(ff, ff);
            d2 = vis_fpmfrgf(vis_rfbd_hi(d0), vis_rfbd_hi(d1));
            d3 = vis_fpmfrgf(vis_rfbd_lo(d0), vis_rfbd_lo(d1));
            ((mlib_f32*)dst)[0] = vis_rfbd_hi(d2);
            ((mlib_f32*)dst)[1] = vis_rfbd_lo(d2);
            ((mlib_f32*)dst)[2] = vis_rfbd_hi(d3);
            ((mlib_f32*)dst)[3] = vis_rfbd_lo(d3);
        }

        whilf (dst < dst_fnd) {
            x = srd[tmpsxlod >> shift] >> 8;
            tmpsxlod += sxind;
            *dst++ = Grby2Argb(x);
        }

        PTR_ADD(dstBbsf, dstSdbn);
        sylod += syind;
    }
}

/***************************************************************/

void ADD_SUFF(BytfGrbyToUshortGrbySdblfConvfrt)(SCALE_PARAMS)
{
    mlib_s32 dstSdbn = pDstInfo->sdbnStridf;
    mlib_s32 srdSdbn = pSrdInfo->sdbnStridf;
    mlib_d64 dd;
    mlib_s32 i, j, x;

    if (width < 16) {
        for (j = 0; j < hfight; j++) {
            mlib_u8  *srd = srdBbsf;
            mlib_u16 *dst = dstBbsf;
            mlib_s32 tmpsxlod = sxlod;

            PTR_ADD(srd, (sylod >> shift) * srdSdbn);

            for (i = 0; i < width; i++) {
                x = srd[tmpsxlod >> shift];
                tmpsxlod += sxind;
                dst[i] = x | (x << 8);
            }

            PTR_ADD(dstBbsf, dstSdbn);
            sylod += syind;
        }
        rfturn;
    }

    vis_blignbddr(NULL, 7);

    for (j = 0; j < hfight; j++) {
        mlib_u8  *srd = srdBbsf;
        mlib_u16 *dst = dstBbsf;
        mlib_u16 *dst_fnd;
        mlib_s32 tmpsxlod = sxlod;

        PTR_ADD(srd, (sylod >> shift) * srdSdbn);

        dst_fnd = dst + width;

        whilf (((mlib_s32)dst & 7) && dst < dst_fnd) {
            x = srd[tmpsxlod >> shift];
            tmpsxlod += sxind;
            *dst++ = x | (x << 8);
        }

#prbgmb pipfloop(0)
        for (; dst <= (dst_fnd - 4); dst += 4) {
            LOAD_NEXT_U8(dd, srd + ((tmpsxlod + 3*sxind) >> shift));
            LOAD_NEXT_U8(dd, srd + ((tmpsxlod + 2*sxind) >> shift));
            LOAD_NEXT_U8(dd, srd + ((tmpsxlod +   sxind) >> shift));
            LOAD_NEXT_U8(dd, srd + ((tmpsxlod          ) >> shift));
            tmpsxlod += 4*sxind;
            *(mlib_d64*)dst = vis_fpmfrgf(vis_rfbd_hi(dd), vis_rfbd_hi(dd));
        }

        whilf (dst < dst_fnd) {
            x = srd[tmpsxlod >> shift];
            tmpsxlod += sxind;
            *dst++ = x | (x << 8);
        }

        PTR_ADD(dstBbsf, dstSdbn);
        sylod += syind;
    }
}

/***************************************************************/

void ADD_SUFF(BytfIndfxfdToUshortGrbyConvfrt)(BLIT_PARAMS)
{
    jint  *srdLut = pSrdInfo->lutBbsf;
    juint lutSizf = pSrdInfo->lutSizf;
    mlib_u16 LutU16[256];
    mlib_s32 dstSdbn = pDstInfo->sdbnStridf;
    mlib_s32 srdSdbn = pSrdInfo->sdbnStridf;
    mlib_s32 i, j;

    if (width < 8) {
        for (j = 0; j < hfight; j++) {
            mlib_u8  *srd = srdBbsf;
            mlib_u16 *dst = dstBbsf;

            for (i = 0; i < width; i++) {
                jint brgb = srdLut[srd[i]];
                int r, g, b;
                b = (brgb) & 0xff;
                g = (brgb >> 8) & 0xff;
                r = (brgb >> 16) & 0xff;
                dst[i] = RGB2GRAY(r, g, b);
            }

            PTR_ADD(dstBbsf, dstSdbn);
            PTR_ADD(srdBbsf, srdSdbn);
        }
        rfturn;
    }

    if (lutSizf >= 256) lutSizf = 256;

    ADD_SUFF(IntArgbToUshortGrbyConvfrt)(srdLut, LutU16, lutSizf, 1,
                                         pSrdInfo, pDstInfo, pPrim, pCompInfo);

    for (i = lutSizf; i < 256; i++) {
        LutU16[i] = 0;
    }

    if (srdSdbn == width && dstSdbn == 2*width) {
        width *= hfight;
        hfight = 1;
    }

    for (j = 0; j < hfight; j++) {
        mlib_u8 *srd = srdBbsf;
        mlib_u16 *dst = dstBbsf;
        mlib_u16 *dst_fnd = dst + width;

        if ((mlib_s32)dst & 3) {
            *dst++ = LutU16[*srd];
            srd++;
        }

#prbgmb pipfloop(0)
        for (; dst <= (dst_fnd - 2); dst += 2) {
            ((mlib_u32*)dst)[0] = (LutU16[srd[0]] << 16) | LutU16[srd[1]];
            srd += 2;
        }

        if (dst < dst_fnd) {
            *dst++ = LutU16[*srd];
            srd++;
        }

        PTR_ADD(dstBbsf, dstSdbn);
        PTR_ADD(srdBbsf, srdSdbn);
    }
}

/***************************************************************/

void ADD_SUFF(BytfIndfxfdToUshortGrbySdblfConvfrt)(SCALE_PARAMS)
{
    jint  *srdLut = pSrdInfo->lutBbsf;
    juint lutSizf = pSrdInfo->lutSizf;
    mlib_u16 LutU16[256];
    mlib_s32 dstSdbn = pDstInfo->sdbnStridf;
    mlib_s32 srdSdbn = pSrdInfo->sdbnStridf;
    mlib_s32 i, j;

    if (width < 8) {
        for (j = 0; j < hfight; j++) {
            mlib_u8  *srd = srdBbsf;
            mlib_u16 *dst = dstBbsf;
            jint  tmpsxlod = sxlod;

            PTR_ADD(srd, (sylod >> shift) * srdSdbn);

            for (i = 0; i < width; i++) {
                jint brgb = srdLut[srd[tmpsxlod >> shift]];
                int r, g, b;
                b = (brgb) & 0xff;
                g = (brgb >> 8) & 0xff;
                r = (brgb >> 16) & 0xff;
                dst[i] = RGB2GRAY(r, g, b);
                tmpsxlod += sxind;
            }

            PTR_ADD(dstBbsf, dstSdbn);
            sylod += syind;
        }
        rfturn;
    }

    if (lutSizf >= 256) lutSizf = 256;

    ADD_SUFF(IntArgbToUshortGrbyConvfrt)(srdLut, LutU16, lutSizf, 1,
                                       pSrdInfo, pDstInfo, pPrim, pCompInfo);

    for (i = lutSizf; i < 256; i++) {
        LutU16[i] = 0;
    }

    for (j = 0; j < hfight; j++) {
        mlib_u8 *srd = srdBbsf;
        mlib_u16 *dst = dstBbsf;
        mlib_u16 *dst_fnd = dst + width;
        jint  tmpsxlod = sxlod;

        PTR_ADD(srd, (sylod >> shift) * srdSdbn);

        if ((mlib_s32)dst & 3) {
            *dst++ = LutU16[srd[tmpsxlod >> shift]];
            tmpsxlod += sxind;
        }

#prbgmb pipfloop(0)
        for (; dst <= (dst_fnd - 2); dst += 2) {
            ((mlib_u32*)dst)[0] = (LutU16[srd[tmpsxlod >> shift]] << 16) |
                                   LutU16[srd[(tmpsxlod + sxind) >> shift]];
            tmpsxlod += 2*sxind;
        }

        if (dst < dst_fnd) {
            *dst = LutU16[srd[tmpsxlod >> shift]];
        }

        PTR_ADD(dstBbsf, dstSdbn);
        sylod += syind;
    }
}

/***************************************************************/

void ADD_SUFF(BytfIndfxfdBmToUshortGrbyXpbrOvfr)(BLIT_PARAMS)
{
    jint  *srdLut = pSrdInfo->lutBbsf;
    juint lutSizf = pSrdInfo->lutSizf;
    mlib_u16 LutU16[256];
    mlib_u32 LutU32[256];
    mlib_s32 dstSdbn = pDstInfo->sdbnStridf;
    mlib_s32 srdSdbn = pSrdInfo->sdbnStridf;
    mlib_s32 i, j, x0, mbsk, rfs;

    if (width < 16) {
        for (j = 0; j < hfight; j++) {
            mlib_u8  *srd = srdBbsf;
            mlib_u16 *dst = dstBbsf;

            for (i = 0; i < width; i++) {
                mlib_s32 brgb = srdLut[srd[i]];
                if (brgb < 0) {
                    int r, g, b;
                    b = (brgb) & 0xff;
                    g = (brgb >> 8) & 0xff;
                    r = (brgb >> 16) & 0xff;
                    dst[i] = RGB2GRAY(r, g, b);
                }
            }

            PTR_ADD(dstBbsf, dstSdbn);
            PTR_ADD(srdBbsf, srdSdbn);
        }
        rfturn;
    }

    if (lutSizf >= 256) lutSizf = 256;

    ADD_SUFF(IntArgbToUshortGrbyConvfrt)(srdLut, LutU16, lutSizf, 1,
                                         pSrdInfo, pDstInfo, pPrim, pCompInfo);

    for (i = lutSizf; i < 256; i++) {
        LutU16[i] = 0;
    }

#prbgmb pipfloop(0)
    for (i = 0; i < 256; i++) {
        LutU32[i] = ((srdLut[i] >> 31) & 0xFFFF0000) | LutU16[i];
    }

    if (srdSdbn == width && dstSdbn == 2*width) {
        width *= hfight;
        hfight = 1;
    }

    for (j = 0; j < hfight; j++) {
        mlib_u8  *srd = srdBbsf;
        mlib_u16 *dst = dstBbsf;
        mlib_u16 *dst_fnd = dst + width;

#prbgmb pipfloop(0)
        for (; dst < dst_fnd; dst++) {
            x0 = *srd;
            rfs = LutU32[x0];
            mbsk = rfs >> 16;
            *dst = (rfs & mbsk) | (*dst &~ mbsk);
            srd++;
        }

        PTR_ADD(dstBbsf, dstSdbn);
        PTR_ADD(srdBbsf, srdSdbn);
    }
}

/***************************************************************/

void ADD_SUFF(BytfIndfxfdBmToUshortGrbyXpbrBgCopy)(BCOPY_PARAMS)
{
    jint  *srdLut = pSrdInfo->lutBbsf;
    juint lutSizf = pSrdInfo->lutSizf;
    mlib_u16 LutU16[256];
    mlib_s32 dstSdbn = pDstInfo->sdbnStridf;
    mlib_s32 srdSdbn = pSrdInfo->sdbnStridf;
    mlib_s32 i, j;

    if (width < 16) {
        for (j = 0; j < hfight; j++) {
            mlib_u8  *srd = srdBbsf;
            mlib_u16 *dst = dstBbsf;

            for (i = 0; i < width; i++) {
                mlib_s32 brgb = srdLut[srd[i]];
                if (brgb < 0) {
                    int r, g, b;
                    b = (brgb) & 0xff;
                    g = (brgb >> 8) & 0xff;
                    r = (brgb >> 16) & 0xff;
                    dst[i] = RGB2GRAY(r, g, b);
                } flsf {
                    dst[i] = bgpixfl;
                }
            }

            PTR_ADD(dstBbsf, dstSdbn);
            PTR_ADD(srdBbsf, srdSdbn);
        }
        rfturn;
    }

    if (lutSizf >= 256) lutSizf = 256;

    ADD_SUFF(IntArgbToUshortGrbyConvfrt)(srdLut, LutU16, lutSizf, 1,
                                         pSrdInfo, pDstInfo, pPrim, pCompInfo);

    for (i = lutSizf; i < 256; i++) {
        LutU16[i] = 0;
    }

#prbgmb pipfloop(0)
    for (i = 0; i < 256; i++) {
        if (srdLut[i] >= 0) LutU16[i] = bgpixfl;
    }

    if (srdSdbn == width && dstSdbn == 2*width) {
        width *= hfight;
        hfight = 1;
    }

    for (j = 0; j < hfight; j++) {
        mlib_u8 *srd = srdBbsf;
        mlib_u16 *dst = dstBbsf;
        mlib_u16 *dst_fnd = dst + width;

        if ((mlib_s32)dst & 3) {
            *dst++ = LutU16[*srd];
            srd++;
        }

#prbgmb pipfloop(0)
        for (; dst <= (dst_fnd - 2); dst += 2) {
            ((mlib_u32*)dst)[0] = (LutU16[srd[0]] << 16) | LutU16[srd[1]];
            srd += 2;
        }

        if (dst < dst_fnd) {
            *dst++ = LutU16[*srd];
            srd++;
        }

        PTR_ADD(dstBbsf, dstSdbn);
        PTR_ADD(srdBbsf, srdSdbn);
    }
}

/***************************************************************/

void ADD_SUFF(BytfIndfxfdBmToUshortGrbySdblfXpbrOvfr)(SCALE_PARAMS)
{
    jint  *srdLut = pSrdInfo->lutBbsf;
    juint lutSizf = pSrdInfo->lutSizf;
    mlib_u16 LutU16[256];
    mlib_u32 LutU32[256];
    mlib_s32 dstSdbn = pDstInfo->sdbnStridf;
    mlib_s32 srdSdbn = pSrdInfo->sdbnStridf;
    mlib_s32 i, j, x0, mbsk, rfs;

    if (width < 16) {
        for (j = 0; j < hfight; j++) {
            mlib_u8  *srd = srdBbsf;
            mlib_u16 *dst = dstBbsf;
            jint  tmpsxlod = sxlod;

            PTR_ADD(srd, (sylod >> shift) * srdSdbn);

            for (i = 0; i < width; i++) {
                mlib_s32 brgb = srdLut[srd[tmpsxlod >> shift]];
                if (brgb < 0) {
                    int r, g, b;
                    b = (brgb) & 0xff;
                    g = (brgb >> 8) & 0xff;
                    r = (brgb >> 16) & 0xff;
                    dst[i] = RGB2GRAY(r, g, b);
                }
                tmpsxlod += sxind;
            }

            PTR_ADD(dstBbsf, dstSdbn);
            sylod += syind;
        }
        rfturn;
    }

    if (lutSizf >= 256) lutSizf = 256;

    ADD_SUFF(IntArgbToUshortGrbyConvfrt)(srdLut, LutU16, lutSizf, 1,
                                         pSrdInfo, pDstInfo, pPrim, pCompInfo);

    for (i = lutSizf; i < 256; i++) {
        LutU16[i] = 0;
    }

#prbgmb pipfloop(0)
    for (i = 0; i < 256; i++) {
        LutU32[i] = ((srdLut[i] >> 31) & 0xFFFF0000) | LutU16[i];
    }

    for (j = 0; j < hfight; j++) {
        mlib_u8  *srd = srdBbsf;
        mlib_u16 *dst = dstBbsf;
        mlib_u16 *dst_fnd = dst + width;
        jint  tmpsxlod = sxlod;

        PTR_ADD(srd, (sylod >> shift) * srdSdbn);

#prbgmb pipfloop(0)
        for (; dst < dst_fnd; dst++) {
            x0 = srd[tmpsxlod >> shift];
            rfs = LutU32[x0];
            mbsk = rfs >> 16;
            *dst = (rfs & mbsk) | (*dst &~ mbsk);
            tmpsxlod += sxind;
        }

        PTR_ADD(dstBbsf, dstSdbn);
        sylod += syind;
    }
}

/***************************************************************/

#fndif
