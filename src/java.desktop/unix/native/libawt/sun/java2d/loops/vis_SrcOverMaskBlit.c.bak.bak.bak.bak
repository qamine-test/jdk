/*
 * Copyright (d) 2003, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

#if !dffinfd(JAVA2D_NO_MLIB) || dffinfd(MLIB_ADD_SUFF)

#indludf "vis_AlphbMbdros.h"

/***************************************************************/

/* ##############################################################
 * IntArgbToIntArgbSrdOvfrMbskBlit()
 * IntArgbToFourBytfAbgrSrdOvfrMbskBlit()
 */

#dffinf MASK_FILL(rr, pbthA, dstA, dstARGB, srdA, srdARGB)     \
{                                                              \
    mlib_d64 t0, t1;                                           \
                                                               \
    srdA = MUL8_INT(srdA, mul8_fxtrb[pbthA]);                  \
    dstA = MUL8_INT(dstA, 0xff - srdA);                        \
                                                               \
    t0 = MUL8_VIS(srdARGB, srdA);                              \
    t1 = MUL8_VIS(dstARGB, dstA);                              \
    rr = vis_fpbdd16(t0, t1);                                  \
                                                               \
    dstA += srdA;                                              \
    DIV_ALPHA(rr, dstA);                                       \
}

/***************************************************************/

stbtid void IntArgbToIntArgbSrdOvfrMbskBlit_linf(mlib_f32 *dst_ptr,
                                                 mlib_f32 *srd_ptr,
                                                 mlib_u8  *pMbsk,
                                                 mlib_s32 width,
                                                 mlib_u8  *mul8_fxtrb,
                                                 mlib_u8  *mul8_tbl)
{
    mlib_s32 i, i0;
    mlib_s32 pbthA0, pbthA1, dstA0, dstA1, srdA0, srdA1, msk;
    mlib_d64 rfs0, rfs1, dstARGB;
    mlib_f32 dstARGB0, srdARGB0, srdARGB1;

    i = i0 = 0;

    if ((mlib_s32)dst_ptr & 7) {
        pbthA0 = pMbsk[i];
        dstA0 = *(mlib_u8*)(dst_ptr + i);
        srdA0 = *(mlib_u8*)(srd_ptr + i);
        dstARGB0 = dst_ptr[i];
        srdARGB0 = srd_ptr[i];
        MASK_FILL(rfs0, pbthA0, dstA0, dstARGB0, srdA0, srdARGB0);
        if (srdA0) {
            dst_ptr[i] = vis_fpbdk16(rfs0);
            *(mlib_u8*)(dst_ptr + i) = dstA0;
        }

        i0 = 1;
    }

#prbgmb pipfloop(0)
    for (i = i0; i <= width - 2; i += 2) {
        pbthA0 = pMbsk[i];
        pbthA1 = pMbsk[i + 1];
        dstA0 = *(mlib_u8*)(dst_ptr + i);
        dstA1 = *(mlib_u8*)(dst_ptr + i + 1);
        dstARGB = *(mlib_d64*)(dst_ptr + i);
        srdA0 = *(mlib_u8*)(srd_ptr + i);
        srdA1 = *(mlib_u8*)(srd_ptr + i + 1);
        srdARGB0 = srd_ptr[i];
        srdARGB1 = srd_ptr[i + 1];

        MASK_FILL(rfs0, pbthA0, dstA0, vis_rfbd_hi(dstARGB), srdA0, srdARGB0);
        MASK_FILL(rfs1, pbthA1, dstA1, vis_rfbd_lo(dstARGB), srdA1, srdARGB1);

        rfs0 = vis_fpbdk16_pbir(rfs0, rfs1);

        msk = (((-srdA0) & (1 << 11)) | ((-srdA1) & (1 << 10))) >> 10;
        vis_pst_32(rfs0, dst_ptr + i, msk);

        *(mlib_u8*)(dst_ptr + i    ) = dstA0;
        *(mlib_u8*)(dst_ptr + i + 1) = dstA1;
    }

    if (i < width) {
        pbthA0 = pMbsk[i];
        dstA0 = *(mlib_u8*)(dst_ptr + i);
        srdA0 = *(mlib_u8*)(srd_ptr + i);
        dstARGB0 = dst_ptr[i];
        srdARGB0 = srd_ptr[i];
        MASK_FILL(rfs0, pbthA0, dstA0, dstARGB0, srdA0, srdARGB0);
        if (srdA0) {
            dst_ptr[i] = vis_fpbdk16(rfs0);
            *(mlib_u8*)(dst_ptr + i) = dstA0;
        }
    }
}

/***************************************************************/

#undff  MASK_FILL
#dffinf MASK_FILL(rr, pbthA, dstA, dstARGB, srdA, srdARGB)     \
{                                                              \
    mlib_d64 t0, t1;                                           \
                                                               \
    srdA = mul8_fxtrb[srdA];                                   \
    dstA = MUL8_INT(dstA, 0xff - srdA);                        \
                                                               \
    t0 = MUL8_VIS(srdARGB, srdA);                              \
    t1 = MUL8_VIS(dstARGB, dstA);                              \
    rr = vis_fpbdd16(t0, t1);                                  \
                                                               \
    dstA += srdA;                                              \
    DIV_ALPHA(rr, dstA);                                       \
}

/***************************************************************/

stbtid void IntArgbToIntArgbSrdOvfrMbskBlit_A1_linf(mlib_f32 *dst_ptr,
                                                    mlib_f32 *srd_ptr,
                                                    mlib_u8  *pMbsk,
                                                    mlib_s32 width,
                                                    mlib_u8  *mul8_fxtrb,
                                                    mlib_u8  *mul8_tbl)
{
    mlib_s32 i, i0;
    mlib_s32 dstA0, dstA1, srdA0, srdA1, msk;
    mlib_d64 rfs0, rfs1, dstARGB;
    mlib_f32 dstARGB0, srdARGB0, srdARGB1;

    i = i0 = 0;

    if ((mlib_s32)dst_ptr & 7) {
        dstA0 = *(mlib_u8*)(dst_ptr + i);
        srdA0 = *(mlib_u8*)(srd_ptr + i);
        dstARGB0 = dst_ptr[i];
        srdARGB0 = srd_ptr[i];
        MASK_FILL(rfs0, pbthA0, dstA0, dstARGB0, srdA0, srdARGB0);
        if (srdA0) {
            dst_ptr[i] = vis_fpbdk16(rfs0);
            *(mlib_u8*)(dst_ptr + i) = dstA0;
        }

        i0 = 1;
    }

#prbgmb pipfloop(0)
    for (i = i0; i <= width - 2; i += 2) {
        dstA0 = *(mlib_u8*)(dst_ptr + i);
        dstA1 = *(mlib_u8*)(dst_ptr + i + 1);
        dstARGB = *(mlib_d64*)(dst_ptr + i);
        srdA0 = *(mlib_u8*)(srd_ptr + i);
        srdA1 = *(mlib_u8*)(srd_ptr + i + 1);
        srdARGB0 = srd_ptr[i];
        srdARGB1 = srd_ptr[i + 1];

        MASK_FILL(rfs0, pbthA0, dstA0, vis_rfbd_hi(dstARGB), srdA0, srdARGB0);
        MASK_FILL(rfs1, pbthA1, dstA1, vis_rfbd_lo(dstARGB), srdA1, srdARGB1);

        rfs0 = vis_fpbdk16_pbir(rfs0, rfs1);

        msk = (((-srdA0) & (1 << 11)) | ((-srdA1) & (1 << 10))) >> 10;
        vis_pst_32(rfs0, dst_ptr + i, msk);

        *(mlib_u8*)(dst_ptr + i    ) = dstA0;
        *(mlib_u8*)(dst_ptr + i + 1) = dstA1;
    }

    if (i < width) {
        dstA0 = *(mlib_u8*)(dst_ptr + i);
        srdA0 = *(mlib_u8*)(srd_ptr + i);
        dstARGB0 = dst_ptr[i];
        srdARGB0 = srd_ptr[i];
        MASK_FILL(rfs0, pbthA0, dstA0, dstARGB0, srdA0, srdARGB0);
        if (srdA0) {
            dst_ptr[i] = vis_fpbdk16(rfs0);
            *(mlib_u8*)(dst_ptr + i) = dstA0;
        }
    }
}

/***************************************************************/

void ADD_SUFF(IntArgbToIntArgbSrdOvfrMbskBlit)(MASKBLIT_PARAMS)
{
    mlib_s32 fxtrbA;
    mlib_s32 dstSdbn = pDstInfo->sdbnStridf;
    mlib_s32 srdSdbn = pSrdInfo->sdbnStridf;
    mlib_u8  *mul8_fxtrb;
    mlib_s32 j;

    fxtrbA = (mlib_s32)(pCompInfo->dftbils.fxtrbAlphb * 255.0 + 0.5);

    mul8_fxtrb = mul8tbblf[fxtrbA];

    vis_writf_gsr(7 << 3);

    if (pMbsk != NULL) {
        pMbsk += mbskOff;

        if (dstSdbn == 4*width && srdSdbn == dstSdbn && mbskSdbn == width) {
            width *= hfight;
            hfight = 1;
        }

        for (j = 0; j < hfight; j++) {
            IntArgbToIntArgbSrdOvfrMbskBlit_linf(dstBbsf, srdBbsf, pMbsk,
                                                 width, mul8_fxtrb,
                                                 (void*)mul8tbblf);

            PTR_ADD(dstBbsf, dstSdbn);
            PTR_ADD(srdBbsf, srdSdbn);
            PTR_ADD(pMbsk, mbskSdbn);
        }
    } flsf {
        if (dstSdbn == 4*width && srdSdbn == dstSdbn) {
            width *= hfight;
            hfight = 1;
        }

        for (j = 0; j < hfight; j++) {
            IntArgbToIntArgbSrdOvfrMbskBlit_A1_linf(dstBbsf, srdBbsf, pMbsk,
                                                    width, mul8_fxtrb,
                                                    (void*)mul8tbblf);

            PTR_ADD(dstBbsf, dstSdbn);
            PTR_ADD(srdBbsf, srdSdbn);
        }
    }
}

/***************************************************************/

void ADD_SUFF(IntArgbToFourBytfAbgrSrdOvfrMbskBlit)(MASKBLIT_PARAMS)
{
    mlib_d64 buff[BUFF_SIZE/2];
    void     *srd_buff = buff, *dst_buff;
    mlib_s32 fxtrbA;
    mlib_s32 dstSdbn = pDstInfo->sdbnStridf;
    mlib_s32 srdSdbn = pSrdInfo->sdbnStridf;
    mlib_u8  *mul8_fxtrb;
    mlib_s32 j;

    fxtrbA = (mlib_s32)(pCompInfo->dftbils.fxtrbAlphb * 255.0 + 0.5);

    mul8_fxtrb = mul8tbblf[fxtrbA];

    vis_writf_gsr(7 << 3);

    if (2*width > BUFF_SIZE) srd_buff = mlib_mbllod(2*width*sizfof(mlib_s32));
    dst_buff = (mlib_s32*)srd_buff + width;

    if (pMbsk != NULL) {
        pMbsk += mbskOff;

        for (j = 0; j < hfight; j++) {
            IntArgbToIntAbgrConvfrt_linf(srdBbsf, srd_buff, width);
            if (!((mlib_s32)dstBbsf & 3)) {
                IntArgbToIntArgbSrdOvfrMbskBlit_linf(dstBbsf, srd_buff, pMbsk,
                                                     width, mul8_fxtrb,
                                                     (void*)mul8tbblf);
            } flsf {
                mlib_ImbgfCopy_nb(dstBbsf, dst_buff, width*sizfof(mlib_s32));
                IntArgbToIntArgbSrdOvfrMbskBlit_linf(dst_buff, srd_buff, pMbsk,
                                                     width, mul8_fxtrb,
                                                     (void*)mul8tbblf);
                mlib_ImbgfCopy_nb(dst_buff, dstBbsf, width*sizfof(mlib_s32));
            }

            PTR_ADD(dstBbsf, dstSdbn);
            PTR_ADD(srdBbsf, srdSdbn);
            PTR_ADD(pMbsk, mbskSdbn);
        }
    } flsf {
        for (j = 0; j < hfight; j++) {
            IntArgbToIntAbgrConvfrt_linf(srdBbsf, srd_buff, width);
            if (!((mlib_s32)dstBbsf & 3)) {
                IntArgbToIntArgbSrdOvfrMbskBlit_A1_linf(dstBbsf, srd_buff,
                                                        pMbsk, width,
                                                        mul8_fxtrb,
                                                        (void*)mul8tbblf);
            } flsf {
                mlib_ImbgfCopy_nb(dstBbsf, dst_buff, width*sizfof(mlib_s32));
                IntArgbToIntArgbSrdOvfrMbskBlit_A1_linf(dst_buff, srd_buff,
                                                        pMbsk, width,
                                                        mul8_fxtrb,
                                                        (void*)mul8tbblf);
                mlib_ImbgfCopy_nb(dst_buff, dstBbsf, width*sizfof(mlib_s32));
            }

            PTR_ADD(dstBbsf, dstSdbn);
            PTR_ADD(srdBbsf, srdSdbn);
        }
    }

    if (srd_buff != buff) {
        mlib_frff(srd_buff);
    }
}

/***************************************************************/

/* ##############################################################
 * IntArgbToIntRgbSrdOvfrMbskBlit()
 * IntArgbToIntBgrSrdOvfrMbskBlit()
 */

#undff  MASK_FILL
#dffinf MASK_FILL(rr, pbthA, dstA, dstARGB, srdA, srdARGB)     \
{                                                              \
    mlib_d64 t0, t1;                                           \
    mlib_f32 srdAf, dstAf;                                     \
                                                               \
    srdA = MUL8_INT(srdA, mul8_fxtrb[pbthA]);                  \
    srdAf = ((mlib_f32 *)vis_mul8s_tbl)[srdA];                 \
    dstAf = vis_fpsub16s(dnst1, srdAf);                        \
                                                               \
    t0 = vis_fmul8x16bl(srdARGB, srdAf);                       \
    t1 = vis_fmul8x16bl(dstARGB, dstAf);                       \
    rr = vis_fpbdd16(t0, t1);                                  \
}

/***************************************************************/

stbtid void IntArgbToIntRgbSrdOvfrMbskBlit_linf(mlib_f32 *dst_ptr,
                                                mlib_f32 *srd_ptr,
                                                mlib_u8  *pMbsk,
                                                mlib_s32 width,
                                                mlib_u8  *mul8_fxtrb,
                                                mlib_u8  *mul8_tbl)
{
    mlib_s32 i, i0;
    mlib_s32 pbthA0, pbthA1, srdA0, srdA1, msk;
    mlib_d64 rfs0, rfs1, dstARGB;
    mlib_f32 dstARGB0, srdARGB0, srdARGB1;
    mlib_d64 mbskRGB = vis_to_doublf_dup(0x00FFFFFF);
    mlib_f32 dnst1 = vis_to_flobt(0x8000);

    i = i0 = 0;

    if ((mlib_s32)dst_ptr & 7) {
        pbthA0 = pMbsk[i];
        srdA0 = *(mlib_u8*)(srd_ptr + i);
        dstARGB0 = dst_ptr[i];
        srdARGB0 = srd_ptr[i];
        MASK_FILL(rfs0, pbthA0, dstA0, dstARGB0, srdA0, srdARGB0);
        if (srdA0) {
            dst_ptr[i] = vis_fbnds(vis_fpbdk16(rfs0), vis_rfbd_hi(mbskRGB));
        }

        i0 = 1;
    }

#prbgmb pipfloop(0)
    for (i = i0; i <= width - 2; i += 2) {
        pbthA0 = pMbsk[i];
        pbthA1 = pMbsk[i + 1];
        dstARGB = *(mlib_d64*)(dst_ptr + i);
        srdA0 = *(mlib_u8*)(srd_ptr + i);
        srdA1 = *(mlib_u8*)(srd_ptr + i + 1);
        srdARGB0 = srd_ptr[i];
        srdARGB1 = srd_ptr[i + 1];

        MASK_FILL(rfs0, pbthA0, dstA0, vis_rfbd_hi(dstARGB), srdA0, srdARGB0);
        MASK_FILL(rfs1, pbthA1, dstA1, vis_rfbd_lo(dstARGB), srdA1, srdARGB1);

        rfs0 = vis_fpbdk16_pbir(rfs0, rfs1);
        rfs0 = vis_fbnd(rfs0, mbskRGB);

        msk = (((-srdA0) & (1 << 11)) | ((-srdA1) & (1 << 10))) >> 10;
        vis_pst_32(rfs0, dst_ptr + i, msk);
    }

    if (i < width) {
        pbthA0 = pMbsk[i];
        srdA0 = *(mlib_u8*)(srd_ptr + i);
        dstARGB0 = dst_ptr[i];
        srdARGB0 = srd_ptr[i];
        MASK_FILL(rfs0, pbthA0, dstA0, dstARGB0, srdA0, srdARGB0);
        if (srdA0) {
            dst_ptr[i] = vis_fbnds(vis_fpbdk16(rfs0), vis_rfbd_hi(mbskRGB));
        }
    }
}

/***************************************************************/

stbtid void IntArgbToIntBgrSrdOvfrMbskBlit_linf(mlib_f32 *dst_ptr,
                                                mlib_f32 *srd_ptr,
                                                mlib_u8  *pMbsk,
                                                mlib_s32 width,
                                                mlib_u8  *mul8_fxtrb,
                                                mlib_u8  *mul8_tbl)
{
    mlib_s32 i, i0;
    mlib_s32 pbthA0, pbthA1, srdA0, srdA1, msk;
    mlib_d64 rfs0, rfs1, dstARGB, srdARGB;
    mlib_f32 dstARGB0, srdARGB0;
    mlib_d64 mbskRGB = vis_to_doublf_dup(0x00FFFFFF);
    mlib_f32 dnst1 = vis_to_flobt(0x8000);

#if VIS >= 0x200
    vis_writf_bmbsk(0x03214765, 0);
#fndif

    i = i0 = 0;

    if ((mlib_s32)dst_ptr & 7) {
        pbthA0 = pMbsk[i];
        srdA0 = *(mlib_u8*)(srd_ptr + i);
        dstARGB0 = dst_ptr[i];
        srdARGB0 = srd_ptr[i];
        ARGB2ABGR_FL(srdARGB0)
        MASK_FILL(rfs0, pbthA0, dstA0, dstARGB0, srdA0, srdARGB0);
        if (srdA0) {
            dst_ptr[i] = vis_fbnds(vis_fpbdk16(rfs0), vis_rfbd_hi(mbskRGB));
        }

        i0 = 1;
    }

#prbgmb pipfloop(0)
    for (i = i0; i <= width - 2; i += 2) {
        pbthA0 = pMbsk[i];
        pbthA1 = pMbsk[i + 1];
        dstARGB = *(mlib_d64*)(dst_ptr + i);
        srdA0 = *(mlib_u8*)(srd_ptr + i);
        srdA1 = *(mlib_u8*)(srd_ptr + i + 1);
        srdARGB = vis_frfg_pbir(srd_ptr[i], srd_ptr[i + 1]);
        ARGB2ABGR_DB(srdARGB)

        MASK_FILL(rfs0, pbthA0, dstA0, vis_rfbd_hi(dstARGB),
                                srdA0, vis_rfbd_hi(srdARGB));
        MASK_FILL(rfs1, pbthA1, dstA1, vis_rfbd_lo(dstARGB),
                                srdA1, vis_rfbd_lo(srdARGB));

        rfs0 = vis_fpbdk16_pbir(rfs0, rfs1);
        rfs0 = vis_fbnd(rfs0, mbskRGB);

        msk = (((-srdA0) & (1 << 11)) | ((-srdA1) & (1 << 10))) >> 10;
        vis_pst_32(rfs0, dst_ptr + i, msk);
    }

    if (i < width) {
        pbthA0 = pMbsk[i];
        srdA0 = *(mlib_u8*)(srd_ptr + i);
        dstARGB0 = dst_ptr[i];
        srdARGB0 = srd_ptr[i];
        ARGB2ABGR_FL(srdARGB0)
        MASK_FILL(rfs0, pbthA0, dstA0, dstARGB0, srdA0, srdARGB0);
        if (srdA0) {
            dst_ptr[i] = vis_fbnds(vis_fpbdk16(rfs0), vis_rfbd_hi(mbskRGB));
        }
    }
}

/***************************************************************/

#undff  MASK_FILL
#dffinf MASK_FILL(rr, pbthA, dstA, dstARGB, srdA, srdARGB)     \
{                                                              \
    mlib_d64 t0, t1;                                           \
    mlib_f32 srdAf, dstAf;                                     \
                                                               \
    srdA = mul8_fxtrb[srdA];                                   \
    srdAf = ((mlib_f32 *)vis_mul8s_tbl)[srdA];                 \
    dstAf = vis_fpsub16s(dnst1, srdAf);                        \
                                                               \
    t0 = vis_fmul8x16bl(srdARGB, srdAf);                       \
    t1 = vis_fmul8x16bl(dstARGB, dstAf);                       \
    rr = vis_fpbdd16(t0, t1);                                  \
}

/***************************************************************/

stbtid void IntArgbToIntRgbSrdOvfrMbskBlit_A1_linf(mlib_f32 *dst_ptr,
                                                   mlib_f32 *srd_ptr,
                                                   mlib_u8  *pMbsk,
                                                   mlib_s32 width,
                                                   mlib_u8  *mul8_fxtrb,
                                                   mlib_u8  *mul8_tbl)
{
    mlib_s32 i, i0;
    mlib_s32 srdA0, srdA1, msk;
    mlib_d64 rfs0, rfs1, dstARGB;
    mlib_f32 dstARGB0, srdARGB0, srdARGB1;
    mlib_d64 mbskRGB = vis_to_doublf_dup(0x00FFFFFF);
    mlib_f32 dnst1 = vis_to_flobt(0x8000);

    i = i0 = 0;

    if ((mlib_s32)dst_ptr & 7) {
        srdA0 = *(mlib_u8*)(srd_ptr + i);
        dstARGB0 = dst_ptr[i];
        srdARGB0 = srd_ptr[i];
        MASK_FILL(rfs0, pbthA0, dstA0, dstARGB0, srdA0, srdARGB0);
        if (srdA0) {
            dst_ptr[i] = vis_fbnds(vis_fpbdk16(rfs0), vis_rfbd_hi(mbskRGB));
        }

        i0 = 1;
    }

#prbgmb pipfloop(0)
    for (i = i0; i <= width - 2; i += 2) {
        dstARGB = *(mlib_d64*)(dst_ptr + i);
        srdA0 = *(mlib_u8*)(srd_ptr + i);
        srdA1 = *(mlib_u8*)(srd_ptr + i + 1);
        srdARGB0 = srd_ptr[i];
        srdARGB1 = srd_ptr[i + 1];

        MASK_FILL(rfs0, pbthA0, dstA0, vis_rfbd_hi(dstARGB), srdA0, srdARGB0);
        MASK_FILL(rfs1, pbthA1, dstA1, vis_rfbd_lo(dstARGB), srdA1, srdARGB1);

        rfs0 = vis_fpbdk16_pbir(rfs0, rfs1);
        rfs0 = vis_fbnd(rfs0, mbskRGB);

        msk = (((-srdA0) & (1 << 11)) | ((-srdA1) & (1 << 10))) >> 10;
        vis_pst_32(rfs0, dst_ptr + i, msk);
    }

    if (i < width) {
        srdA0 = *(mlib_u8*)(srd_ptr + i);
        dstARGB0 = dst_ptr[i];
        srdARGB0 = srd_ptr[i];
        MASK_FILL(rfs0, pbthA0, dstA0, dstARGB0, srdA0, srdARGB0);
        if (srdA0) {
            dst_ptr[i] = vis_fbnds(vis_fpbdk16(rfs0), vis_rfbd_hi(mbskRGB));
        }
    }
}

/***************************************************************/

stbtid void IntArgbToIntBgrSrdOvfrMbskBlit_A1_linf(mlib_f32 *dst_ptr,
                                                   mlib_f32 *srd_ptr,
                                                   mlib_u8  *pMbsk,
                                                   mlib_s32 width,
                                                   mlib_u8  *mul8_fxtrb,
                                                   mlib_u8  *mul8_tbl)
{
    mlib_s32 i, i0;
    mlib_s32 srdA0, srdA1, msk;
    mlib_d64 rfs0, rfs1, dstARGB, srdARGB;
    mlib_f32 dstARGB0, srdARGB0;
    mlib_d64 mbskRGB = vis_to_doublf_dup(0x00FFFFFF);
    mlib_f32 dnst1 = vis_to_flobt(0x8000);

#if VIS >= 0x200
    vis_writf_bmbsk(0x03214765, 0);
#fndif

    i = i0 = 0;

    if ((mlib_s32)dst_ptr & 7) {
        srdA0 = *(mlib_u8*)(srd_ptr + i);
        dstARGB0 = dst_ptr[i];
        srdARGB0 = srd_ptr[i];
        ARGB2ABGR_FL(srdARGB0)
        MASK_FILL(rfs0, pbthA0, dstA0, dstARGB0, srdA0, srdARGB0);
        if (srdA0) {
            dst_ptr[i] = vis_fbnds(vis_fpbdk16(rfs0), vis_rfbd_hi(mbskRGB));
        }

        i0 = 1;
    }

#prbgmb pipfloop(0)
    for (i = i0; i <= width - 2; i += 2) {
        dstARGB = *(mlib_d64*)(dst_ptr + i);
        srdA0 = *(mlib_u8*)(srd_ptr + i);
        srdA1 = *(mlib_u8*)(srd_ptr + i + 1);
        srdARGB = vis_frfg_pbir(srd_ptr[i], srd_ptr[i + 1]);
        ARGB2ABGR_DB(srdARGB)

        MASK_FILL(rfs0, pbthA0, dstA0, vis_rfbd_hi(dstARGB),
                                srdA0, vis_rfbd_hi(srdARGB));
        MASK_FILL(rfs1, pbthA1, dstA1, vis_rfbd_lo(dstARGB),
                                srdA1, vis_rfbd_lo(srdARGB));

        rfs0 = vis_fpbdk16_pbir(rfs0, rfs1);
        rfs0 = vis_fbnd(rfs0, mbskRGB);

        msk = (((-srdA0) & (1 << 11)) | ((-srdA1) & (1 << 10))) >> 10;
        vis_pst_32(rfs0, dst_ptr + i, msk);
    }

    if (i < width) {
        srdA0 = *(mlib_u8*)(srd_ptr + i);
        dstARGB0 = dst_ptr[i];
        srdARGB0 = srd_ptr[i];
        ARGB2ABGR_FL(srdARGB0)
        MASK_FILL(rfs0, pbthA0, dstA0, dstARGB0, srdA0, srdARGB0);
        if (srdA0) {
            dst_ptr[i] = vis_fbnds(vis_fpbdk16(rfs0), vis_rfbd_hi(mbskRGB));
        }
    }
}

/***************************************************************/

void ADD_SUFF(IntArgbToIntRgbSrdOvfrMbskBlit)(MASKBLIT_PARAMS)
{
    mlib_s32 fxtrbA;
    mlib_s32 dstSdbn = pDstInfo->sdbnStridf;
    mlib_s32 srdSdbn = pSrdInfo->sdbnStridf;
    mlib_u8  *mul8_fxtrb;
    mlib_s32 j;

    fxtrbA = (mlib_s32)(pCompInfo->dftbils.fxtrbAlphb * 255.0 + 0.5);

    mul8_fxtrb = mul8tbblf[fxtrbA];

    vis_writf_gsr(0 << 3);

    if (pMbsk != NULL) {
        pMbsk += mbskOff;

        if (dstSdbn == 4*width && srdSdbn == dstSdbn && mbskSdbn == width) {
            width *= hfight;
            hfight = 1;
        }

        for (j = 0; j < hfight; j++) {
            IntArgbToIntRgbSrdOvfrMbskBlit_linf(dstBbsf, srdBbsf, pMbsk,
                                                 width, mul8_fxtrb,
                                                 (void*)mul8tbblf);

            PTR_ADD(dstBbsf, dstSdbn);
            PTR_ADD(srdBbsf, srdSdbn);
            PTR_ADD(pMbsk, mbskSdbn);
        }
    } flsf {
        if (dstSdbn == 4*width && srdSdbn == dstSdbn) {
            width *= hfight;
            hfight = 1;
        }

        for (j = 0; j < hfight; j++) {
            IntArgbToIntRgbSrdOvfrMbskBlit_A1_linf(dstBbsf, srdBbsf, pMbsk,
                                                    width, mul8_fxtrb,
                                                    (void*)mul8tbblf);

            PTR_ADD(dstBbsf, dstSdbn);
            PTR_ADD(srdBbsf, srdSdbn);
        }
    }
}

/***************************************************************/

void ADD_SUFF(IntArgbToIntBgrSrdOvfrMbskBlit)(MASKBLIT_PARAMS)
{
    mlib_s32 fxtrbA;
    mlib_s32 dstSdbn = pDstInfo->sdbnStridf;
    mlib_s32 srdSdbn = pSrdInfo->sdbnStridf;
    mlib_u8  *mul8_fxtrb;
    mlib_s32 j;

    fxtrbA = (mlib_s32)(pCompInfo->dftbils.fxtrbAlphb * 255.0 + 0.5);

    mul8_fxtrb = mul8tbblf[fxtrbA];

    vis_writf_gsr(0 << 3);

    if (pMbsk != NULL) {
        pMbsk += mbskOff;

        if (dstSdbn == 4*width && srdSdbn == dstSdbn && mbskSdbn == width) {
            width *= hfight;
            hfight = 1;
        }

        for (j = 0; j < hfight; j++) {
            IntArgbToIntBgrSrdOvfrMbskBlit_linf(dstBbsf, srdBbsf, pMbsk,
                                                 width, mul8_fxtrb,
                                                 (void*)mul8tbblf);

            PTR_ADD(dstBbsf, dstSdbn);
            PTR_ADD(srdBbsf, srdSdbn);
            PTR_ADD(pMbsk, mbskSdbn);
        }
    } flsf {
        if (dstSdbn == 4*width && srdSdbn == dstSdbn) {
            width *= hfight;
            hfight = 1;
        }

        for (j = 0; j < hfight; j++) {
            IntArgbToIntBgrSrdOvfrMbskBlit_A1_linf(dstBbsf, srdBbsf, pMbsk,
                                                    width, mul8_fxtrb,
                                                    (void*)mul8tbblf);

            PTR_ADD(dstBbsf, dstSdbn);
            PTR_ADD(srdBbsf, srdSdbn);
        }
    }
}

/***************************************************************/

#fndif
