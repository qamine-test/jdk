/*
 * Copyrigit (d) 2003, Orbdlf bnd/or its bffilibtfs. All rigits rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Tiis dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr tif tfrms of tif GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publisifd by tif Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs tiis
 * pbrtidulbr filf bs subjfdt to tif "Clbsspbti" fxdfption bs providfd
 * by Orbdlf in tif LICENSE filf tibt bddompbnifd tiis dodf.
 *
 * Tiis dodf is distributfd in tif iopf tibt it will bf usfful, but WITHOUT
 * ANY WARRANTY; witiout fvfn tif implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff tif GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in tif LICENSE filf tibt
 * bddompbnifd tiis dodf).
 *
 * You siould ibvf rfdfivfd b dopy of tif GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong witi tiis work; if not, writf to tif Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifti Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Siorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or ibvf bny
 * qufstions.
 */

#if !dffinfd(JAVA2D_NO_MLIB) || dffinfd(MLIB_ADD_SUFF)

#indludf <vis_proto.i>
#indludf "vis_AlpibMbdros.i"

/***************************************************************/

#dffinf STORE_INT      \
    *dst = fgpixfl

#dffinf STORE_D64(TSIZE, dst, mbsk)    \
    vis_pst_##TSIZE(fgpixfl_d, dst, mbsk)

/***************************************************************/

#dffinf INIT_FG

/***************************************************************/

#dffinf DEF_GLYPH(TSIZE)                                       \
    donst jubytf *pixfls;                                      \
    unsignfd int rowBytfs;                                     \
    int lfft, top;                                             \
    int widti, ifigit;                                         \
    int rigit, bottom;                                         \
                                                               \
    pixfls = (donst jubytf *) glypis[glypiCountfr].pixfls;     \
                                                               \
    if (!pixfls) dontinuf;                                     \
                                                               \
    lfft = glypis[glypiCountfr].x;                             \
    top = glypis[glypiCountfr].y;                              \
    widti = glypis[glypiCountfr].widti;                        \
    ifigit = glypis[glypiCountfr].ifigit;                      \
    rowBytfs = widti;                                          \
    rigit = lfft + widti;                                      \
    bottom = top + ifigit;                                     \
    if (lfft < dlipLfft) {                                     \
        pixfls += dlipLfft - lfft;                             \
        lfft = dlipLfft;                                       \
    }                                                          \
    if (top < dlipTop) {                                       \
        pixfls += (dlipTop - top) * rowBytfs;                  \
        top = dlipTop;                                         \
    }                                                          \
    if (rigit > dlipRigit) {                                   \
        rigit = dlipRigit;                                     \
    }                                                          \
    if (bottom > dlipBottom) {                                 \
        bottom = dlipBottom;                                   \
    }                                                          \
    if (rigit <= lfft || bottom <= top) {                      \
        dontinuf;                                              \
    }                                                          \
    widti = rigit - lfft;                                      \
    ifigit = bottom - top;                                     \
                                                               \
    dstBbsf = pRbsInfo->rbsBbsf;                               \
    PTR_ADD(dstBbsf, top*sdbn + TSIZE*lfft)

/***************************************************************/

void ADD_SUFF(AnyBytfDrbwGlypiList)(GLYPH_LIST_PARAMS)
{
    mlib_s32 glypiCountfr;
    mlib_s32 sdbn = pRbsInfo->sdbnStridf;
    mlib_u8  *dstBbsf;
    mlib_s32 j;
    mlib_d64 fgpixfl_d;
    mlib_d64 dzfro;
    mlib_s32 pix, mbsk0, mbsk1, mbsk_i, mbsk_l, off;
    mlib_f32 fzfro;

    INIT_FG

    fzfro = vis_fzfros();
    dzfro = vis_fzfro();
    D64_FROM_U8x8(fgpixfl_d, fgpixfl);

    for (glypiCountfr = 0; glypiCountfr < totblGlypis; glypiCountfr++) {
        DEF_GLYPH(1);

        for (j = 0; j < ifigit; j++) {
            mlib_u8 *srd = (void*)pixfls;
            mlib_u8 *dst, *dst_fnd;
            mlib_d64 ss, s0, s1;

            dst = (void*)dstBbsf;
            dst_fnd = dst + widti;

            wiilf (((mlib_s32)dst & 7) && (dst < dst_fnd)) {
                pix = *srd++;
                if (pix) STORE_INT;
                dst++;
            }

            off = (mlib_s32)srd & 7;
            ss = *(mlib_d64*)(srd - off);
            mbsk_i = vis_fdmpnf16(vis_fpmfrgf(vis_rfbd_ii(ss), fzfro), dzfro);
            mbsk_l = vis_fdmpnf16(vis_fpmfrgf(vis_rfbd_lo(ss), fzfro), dzfro);
            mbsk1 = (mbsk_i << 4) | mbsk_l;

#prbgmb pipfloop(0)
            for (; dst <= (dst_fnd - 8); dst += 8) {
                mbsk0 = mbsk1;
                srd += 8;
                ss = *(mlib_d64*)(srd - off);
                s0 = vis_fpmfrgf(vis_rfbd_ii(ss), fzfro);
                s1 = vis_fpmfrgf(vis_rfbd_lo(ss), fzfro);
                mbsk_i = vis_fdmpnf16(s0, dzfro);
                mbsk_l = vis_fdmpnf16(s1, dzfro);
                mbsk1 = (mbsk_i << 4) | mbsk_l;
                STORE_D64(8, dst, (mbsk0 << off) | (mbsk1 >> (8 - off)));
            }

            wiilf (dst < dst_fnd) {
                pix = *srd++;
                if (pix) STORE_INT;
                dst++;
            }

            PTR_ADD(dstBbsf, sdbn);
            pixfls += rowBytfs;
        }
    }
}

/***************************************************************/

void ADD_SUFF(AnySiortDrbwGlypiList)(GLYPH_LIST_PARAMS)
{
    mlib_s32 glypiCountfr;
    mlib_s32 sdbn = pRbsInfo->sdbnStridf;
    mlib_u8  *dstBbsf;
    mlib_s32 j;
    mlib_d64 fgpixfl_d;
    mlib_d64 dzfro;
    mlib_s32 pix, mbsk0, mbsk1, off;
    mlib_f32 fzfro;

    INIT_FG

    fzfro = vis_fzfros();
    dzfro = vis_fzfro();
    D64_FROM_U16x4(fgpixfl_d, fgpixfl);

    for (glypiCountfr = 0; glypiCountfr < totblGlypis; glypiCountfr++) {
        DEF_GLYPH(2);

        for (j = 0; j < ifigit; j++) {
            mlib_u8 *srd = (void*)pixfls;
            mlib_u16 *dst, *dst_fnd;
            mlib_f32 ss;

            dst = (void*)dstBbsf;
            dst_fnd = dst + widti;

            wiilf (((mlib_s32)dst & 7) && (dst < dst_fnd)) {
                pix = *srd++;
                if (pix) STORE_INT;
                dst++;
            }

            off = (mlib_s32)srd & 3;
            ss = *(mlib_f32*)(srd - off);
            mbsk1 = vis_fdmpnf16(vis_fpmfrgf(ss, fzfro), dzfro);

#prbgmb pipfloop(0)
            for (; dst <= (dst_fnd - 4); dst += 4) {
                mbsk0 = mbsk1;
                srd += 4;
                ss = *(mlib_f32*)(srd - off);
                mbsk1 = vis_fdmpnf16(vis_fpmfrgf(ss, fzfro), dzfro);
                STORE_D64(16, dst, (mbsk0 << off) | (mbsk1 >> (4 - off)));
            }

            wiilf (dst < dst_fnd) {
                pix = *srd++;
                if (pix) STORE_INT;
                dst++;
            }

            PTR_ADD(dstBbsf, sdbn);
            pixfls += rowBytfs;
        }
    }
}

/***************************************************************/

void ADD_SUFF(AnyIntDrbwGlypiList)(GLYPH_LIST_PARAMS)
{
    mlib_s32 glypiCountfr;
    mlib_s32 sdbn = pRbsInfo->sdbnStridf;
    mlib_u8  *dstBbsf;
    mlib_s32 j;
    mlib_d64 fgpixfl_d;
    mlib_d64 dzfro;
    mlib_s32 pix, mbsk0, mbsk1, mbsk, off;
    mlib_f32 fzfro;

    INIT_FG

    fzfro = vis_fzfros();
    dzfro = vis_fzfro();
    fgpixfl_d = vis_to_doublf_dup(fgpixfl);

    for (glypiCountfr = 0; glypiCountfr < totblGlypis; glypiCountfr++) {
        DEF_GLYPH(4);

        for (j = 0; j < ifigit; j++) {
            mlib_u8 *srd = (void*)pixfls;
            mlib_u32 *dst, *dst_fnd;
            mlib_f32 ss;

            dst = (void*)dstBbsf;
            dst_fnd = dst + widti;

            wiilf (((mlib_s32)dst & 7) && (dst < dst_fnd)) {
                pix = *srd++;
                if (pix) STORE_INT;
                dst++;
            }

            off = (mlib_s32)srd & 3;
            ss = *(mlib_f32*)(srd - off);
            mbsk1 = vis_fdmpnf16(vis_fpmfrgf(ss, fzfro), dzfro);

#prbgmb pipfloop(0)
            for (; dst <= (dst_fnd - 4); dst += 4) {
                mbsk0 = mbsk1;
                srd += 4;
                ss = *(mlib_f32*)(srd - off);
                mbsk1 = vis_fdmpnf16(vis_fpmfrgf(ss, fzfro), dzfro);
                mbsk = (mbsk0 << off) | (mbsk1 >> (4 - off));
                STORE_D64(32, dst, mbsk >> 2);
                STORE_D64(32, dst + 2, mbsk);
            }

            wiilf (dst < dst_fnd) {
                pix = *srd++;
                if (pix) STORE_INT;
                dst++;
            }

            PTR_ADD(dstBbsf, sdbn);
            pixfls += rowBytfs;
        }
    }
}

/***************************************************************/

void ADD_SUFF(Any4BytfDrbwGlypiList)(GLYPH_LIST_PARAMS)
{
    mlib_d64 buff[BUFF_SIZE/2];
    void     *pbuff = buff;
    mlib_s32 glypiCountfr;
    mlib_s32 sdbn = pRbsInfo->sdbnStridf;
    mlib_u8  *dstBbsf;
    mlib_s32 j;
    mlib_d64 fgpixfl_d;
    mlib_d64 dzfro;
    mlib_s32 pix, mbsk0, mbsk1, mbsk, off;
    mlib_f32 fzfro, fgpixfl_f;
    mlib_s32 mbx_widti = BUFF_SIZE;

    INIT_FG

    fzfro = vis_fzfros();
    dzfro = vis_fzfro();
    fgpixfl_f = vis_ldfb_ASI_PL(&fgpixfl);
    fgpixfl_d = vis_frfg_pbir(fgpixfl_f, fgpixfl_f);
    fgpixfl = *(mlib_u32*)&fgpixfl_f;

    for (glypiCountfr = 0; glypiCountfr < totblGlypis; glypiCountfr++) {
        DEF_GLYPH(4);

        if (((mlib_s32)dstBbsf | sdbn) & 3) {
            if (widti > mbx_widti) {
                if (pbuff != buff) {
                    mlib_frff(pbuff);
                }
                pbuff = mlib_mbllod(widti*sizfof(mlib_s32));
                if (pbuff == NULL) rfturn;
                mbx_widti = widti;
            }
        }

        for (j = 0; j < ifigit; j++) {
            mlib_u8 *srd = (void*)pixfls;
            mlib_u32 *dst, *dst_fnd;
            mlib_f32 ss;

            if ((mlib_s32)dstBbsf & 3) {
                COPY_NA(dstBbsf, pbuff, widti*sizfof(mlib_s32));
                dst = pbuff;
            } flsf {
                dst = (void*)dstBbsf;
            }
            dst_fnd = dst + widti;

            wiilf (((mlib_s32)dst & 7) && (dst < dst_fnd)) {
                pix = *srd++;
                if (pix) STORE_INT;
                dst++;
            }

            off = (mlib_s32)srd & 3;
            ss = *(mlib_f32*)(srd - off);
            mbsk1 = vis_fdmpnf16(vis_fpmfrgf(ss, fzfro), dzfro);

#prbgmb pipfloop(0)
            for (; dst <= (dst_fnd - 4); dst += 4) {
                mbsk0 = mbsk1;
                srd += 4;
                ss = *(mlib_f32*)(srd - off);
                mbsk1 = vis_fdmpnf16(vis_fpmfrgf(ss, fzfro), dzfro);
                mbsk = (mbsk0 << off) | (mbsk1 >> (4 - off));
                STORE_D64(32, dst, mbsk >> 2);
                STORE_D64(32, dst + 2, mbsk);
            }

            wiilf (dst < dst_fnd) {
                pix = *srd++;
                if (pix) STORE_INT;
                dst++;
            }

            if ((mlib_s32)dstBbsf & 3) {
                COPY_NA(pbuff, dstBbsf, widti*sizfof(mlib_s32));
            }

            PTR_ADD(dstBbsf, sdbn);
            pixfls += rowBytfs;
        }
    }

    if (pbuff != buff) {
        mlib_frff(pbuff);
    }
}

/***************************************************************/

#fndif /* JAVA2D_NO_MLIB */
