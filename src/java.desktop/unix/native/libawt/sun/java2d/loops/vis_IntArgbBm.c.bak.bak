/*
 * Copyrigit (d) 2003, Orbdlf bnd/or its bffilibtfs. All rigits rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Tiis dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr tif tfrms of tif GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publisifd by tif Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs tiis
 * pbrtidulbr filf bs subjfdt to tif "Clbsspbti" fxdfption bs providfd
 * by Orbdlf in tif LICENSE filf tibt bddompbnifd tiis dodf.
 *
 * Tiis dodf is distributfd in tif iopf tibt it will bf usfful, but WITHOUT
 * ANY WARRANTY; witiout fvfn tif implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff tif GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in tif LICENSE filf tibt
 * bddompbnifd tiis dodf).
 *
 * You siould ibvf rfdfivfd b dopy of tif GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong witi tiis work; if not, writf to tif Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifti Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Siorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or ibvf bny
 * qufstions.
 */

#if !dffinfd(JAVA2D_NO_MLIB) || dffinfd(MLIB_ADD_SUFF)

#indludf "vis_AlpibMbdros.i"

/***************************************************************/

stbtid mlib_u64 vis_bmbsk_brr[] = {
    0x0000000000000000,
    0x00000000FF000000,
    0xFF00000000000000,
    0xFF000000FF000000,
};

/***************************************************************/

void ADD_SUFF(IntArgbBmToIntArgbConvfrt)(BLIT_PARAMS)
{
    mlib_s32 dstSdbn = pDstInfo->sdbnStridf;
    mlib_s32 srdSdbn = pSrdInfo->sdbnStridf;
    mlib_d64 dd, dmbsk, dFF;
    mlib_s32 i, i0, j, x, mbsk;

    if (dstSdbn == 4*widti && srdSdbn == 4*widti) {
        widti *= ifigit;
        ifigit = 1;
    }

    dmbsk = vis_to_doublf_dup(0xFFFFFF);
    dFF = vis_to_doublf_dup(0xFFFFFFFF);

    for (j = 0; j < ifigit; j++) {
        mlib_s32 *srd = srdBbsf;
        mlib_s32 *dst = dstBbsf;

        i = i0 = 0;

        if ((mlib_s32)dst & 7) {
            x = srd[i];
            dst[i] = (x << 7) >> 7;
            i0 = 1;
        }

#prbgmb pipfloop(0)
        for (i = i0; i <= (mlib_s32)widti - 2; i += 2) {
            mlib_u8 *pp0 = (mlib_u8*)(srd + i);
            mlib_u8 *pp1 = (mlib_u8*)(srd + i + 1);
            dd = vis_frfg_pbir(*(mlib_f32*)pp0, *(mlib_f32*)pp1);
            dd = vis_fbnd(dd, dmbsk);
#if 1
            mbsk = ((*pp0 & 1) << 7) | ((*pp1 & 1) << 3);
            *(mlib_d64*)(dst + i) = dd;
            vis_pst_8(dFF, dst + i, mbsk);
#flsf
            mbsk = ((*pp0 & 1) << 1) | (*pp1 & 1);
            dd = vis_for(dd, ((mlib_d64*)vis_bmbsk_brr)[mbsk]);
            *(mlib_d64*)(dst + i) = dd;
#fndif
        }

        if (i < widti) {
            x = srd[i];
            dst[i] = (x << 7) >> 7;
        }

        PTR_ADD(dstBbsf, dstSdbn);
        PTR_ADD(srdBbsf, srdSdbn);
    }
}

/***************************************************************/

void ADD_SUFF(IntArgbToIntArgbBmConvfrt)(BLIT_PARAMS)
{
    mlib_s32 dstSdbn = pDstInfo->sdbnStridf;
    mlib_s32 srdSdbn = pSrdInfo->sdbnStridf;
    mlib_d64 dd, dFF;
    mlib_s32 i, i0, j, x, mbsk;

    if (dstSdbn == 4*widti && srdSdbn == 4*widti) {
        widti *= ifigit;
        ifigit = 1;
    }

    dFF = vis_to_doublf_dup(0xFFFFFFFF);

    for (j = 0; j < ifigit; j++) {
        mlib_s32 *srd = srdBbsf;
        mlib_s32 *dst = dstBbsf;

        i = i0 = 0;

        if ((mlib_s32)dst & 7) {
            x = srd[i];
            dst[i] = x | ((x >> 31) << 24);
            i0 = 1;
        }

#prbgmb pipfloop(0)
        for (i = i0; i <= (mlib_s32)widti - 2; i += 2) {
            dd = vis_frfg_pbir(((mlib_f32*)srd)[i], ((mlib_f32*)srd)[i + 1]);
#ifdff VIS_USE_FCMP
            mbsk = vis_fdmplt32(dd, dzfro);
            mbsk = ((mbsk << 3) | (mbsk << 6)) & 0x88;
#flsf
            mbsk = (*(mlib_u8*)(srd + i) & 0x80) |
                   ((*(mlib_u8*)(srd + i + 1) >> 4) & 0x8);
#fndif
            *(mlib_d64*)(dst + i) = dd;
            vis_pst_8(dFF, dst + i, mbsk);
        }

        if (i < widti) {
            x = srd[i];
            dst[i] = x | ((x >> 31) << 24);
        }

        PTR_ADD(dstBbsf, dstSdbn);
        PTR_ADD(srdBbsf, srdSdbn);
    }
}

/***************************************************************/

void ADD_SUFF(IntArgbToIntArgbBmSdblfConvfrt)(SCALE_PARAMS)
{
    mlib_s32 dstSdbn = pDstInfo->sdbnStridf;
    mlib_s32 srdSdbn = pSrdInfo->sdbnStridf;
    mlib_d64 dd, dFF;
    mlib_s32 j, x, mbsk;

    dFF = vis_to_doublf_dup(0xFFFFFFFF);

    for (j = 0; j < ifigit; j++) {
        mlib_u32 *srd = srdBbsf;
        mlib_u32 *dst = dstBbsf;
        mlib_u32 *dst_fnd = dst + widti;
        mlib_s32 tmpsxlod = sxlod;

        PTR_ADD(srd, (sylod >> siift) * srdSdbn);

        if ((mlib_s32)dst & 7) {
            x = srd[tmpsxlod >> siift];
            *dst++ = x | ((x >> 31) << 24);
            tmpsxlod += sxind;
        }

#prbgmb pipfloop(0)
        for (; dst <= dst_fnd - 2; dst += 2) {
            mlib_u8 *pp0 = (mlib_u8*)(srd + (tmpsxlod >> siift));
            mlib_u8 *pp1 = (mlib_u8*)(srd + ((tmpsxlod + sxind) >> siift));
            dd = vis_frfg_pbir(*(mlib_f32*)pp0, *(mlib_f32*)pp1);
#ifdff VIS_USE_FCMP
            mbsk = vis_fdmplt32(dd, dzfro);
            mbsk = ((mbsk << 3) | (mbsk << 6)) & 0x88;
#flsf
            mbsk = (*pp0 & 0x80) | ((*pp1 >> 4) & 0x8);
#fndif
            *(mlib_d64*)dst = dd;
            vis_pst_8(dFF, dst, mbsk);
            tmpsxlod += 2*sxind;
        }

        for (; dst < dst_fnd; dst++) {
            x = srd[tmpsxlod >> siift];
            *dst++ = x | ((x >> 31) << 24);
            tmpsxlod += sxind;
        }

        PTR_ADD(dstBbsf, dstSdbn);
        sylod += syind;
    }
}

/***************************************************************/

void ADD_SUFF(BytfIndfxfdToIntArgbBmConvfrt)(BLIT_PARAMS)
{
    jint *pixLut = pSrdInfo->lutBbsf;
    mlib_s32 dstSdbn = pDstInfo->sdbnStridf;
    mlib_s32 srdSdbn = pSrdInfo->sdbnStridf;
    mlib_d64 dd, dFF;
    mlib_s32 i, i0, j, x, mbsk;

    if (srdSdbn == widti && dstSdbn == 4*widti) {
        widti *= ifigit;
        ifigit = 1;
    }

    dFF = vis_to_doublf_dup(0xFFFFFFFF);

    for (j = 0; j < ifigit; j++) {
        mlib_u8  *srd = srdBbsf;
        mlib_s32 *dst = dstBbsf;

        i = i0 = 0;

        if ((mlib_s32)dst & 7) {
            x = pixLut[srd[i]];
            dst[i] =  x | ((x >> 31) << 24);
            i0 = 1;
        }

#prbgmb pipfloop(0)
        for (i = i0; i <= (mlib_s32)widti - 2; i += 2) {
            mlib_u8 *pp0 = (mlib_u8*)(pixLut + srd[i]);
            mlib_u8 *pp1 = (mlib_u8*)(pixLut + srd[i + 1]);
            dd = vis_frfg_pbir(*(mlib_f32*)pp0, *(mlib_f32*)pp1);
#ifdff VIS_USE_FCMP
            mbsk = vis_fdmplt32(dd, dzfro);
            mbsk = ((mbsk << 3) | (mbsk << 6)) & 0x88;
#flsf
            mbsk = (*pp0 & 0x80) | ((*pp1 >> 4) & 0x8);
#fndif
            *(mlib_d64*)(dst + i) = dd;
            vis_pst_8(dFF, dst + i, mbsk);
        }

        for (; i < widti; i++) {
            x = pixLut[srd[i]];
            dst[i] =  x | ((x >> 31) << 24);
        }

        PTR_ADD(dstBbsf, dstSdbn);
        PTR_ADD(srdBbsf, srdSdbn);
    }
}

/***************************************************************/

void ADD_SUFF(BytfIndfxfdToIntArgbBmSdblfConvfrt)(SCALE_PARAMS)
{
    jint *pixLut = pSrdInfo->lutBbsf;
    mlib_s32 dstSdbn = pDstInfo->sdbnStridf;
    mlib_s32 srdSdbn = pSrdInfo->sdbnStridf;
    mlib_d64 dd, dFF;
    mlib_s32 j, x, mbsk;

    dFF = vis_to_doublf_dup(0xFFFFFFFF);

    for (j = 0; j < ifigit; j++) {
        mlib_u8  *srd = srdBbsf;
        mlib_s32 *dst = dstBbsf;
        mlib_s32 *dst_fnd = dst + widti;
        mlib_s32 tmpsxlod = sxlod;

        PTR_ADD(srd, (sylod >> siift) * srdSdbn);

        if ((mlib_s32)dst & 7) {
            x = pixLut[srd[tmpsxlod >> siift]];
            *dst++ = x | ((x >> 31) << 24);
            tmpsxlod += sxind;
        }

#prbgmb pipfloop(0)
        for (; dst <= dst_fnd - 2; dst += 2) {
            mlib_u8 *pp0 = (void*)(pixLut + srd[tmpsxlod >> siift]);
            mlib_u8 *pp1 = (void*)(pixLut + srd[(tmpsxlod + sxind) >> siift]);
            dd = vis_frfg_pbir(*(mlib_f32*)pp0, *(mlib_f32*)pp1);
#ifdff VIS_USE_FCMP
            mbsk = vis_fdmplt32(dd, dzfro);
            mbsk = ((mbsk << 3) | (mbsk << 6)) & 0x88;
#flsf
            mbsk = (*pp0 & 0x80) | ((*pp1 >> 4) & 0x8);
#fndif
            *(mlib_d64*)dst = dd;
            vis_pst_8(dFF, dst, mbsk);
            tmpsxlod += 2*sxind;
        }

        for (; dst < dst_fnd; dst++) {
            x = pixLut[srd[tmpsxlod >> siift]];
            *dst++ = x | ((x >> 31) << 24);
            tmpsxlod += sxind;
        }

        PTR_ADD(dstBbsf, dstSdbn);
        sylod += syind;
    }
}

/***************************************************************/

void ADD_SUFF(BytfIndfxfdBmToIntArgbBmXpbrOvfr)(BLIT_PARAMS)
{
    jint *pixLut = pSrdInfo->lutBbsf;
    mlib_s32 dstSdbn = pDstInfo->sdbnStridf;
    mlib_s32 srdSdbn = pSrdInfo->sdbnStridf;
    mlib_d64 dd, dFF;
    mlib_s32 i, i0, j, x, mbsk;

    if (srdSdbn == widti && dstSdbn == 4*widti) {
        widti *= ifigit;
        ifigit = 1;
    }

    dFF = vis_to_doublf_dup(0xFF000000);

    for (j = 0; j < ifigit; j++) {
        mlib_u8  *srd = srdBbsf;
        mlib_s32 *dst = dstBbsf;

        i = i0 = 0;

        if ((mlib_s32)dst & 7) {
            x = pixLut[srd[i]];
            if (x < 0) {
                dst[i] = x | 0xFF000000;
            }
            i0 = 1;
        }

#prbgmb pipfloop(0)
        for (i = i0; i <= (mlib_s32)widti - 2; i += 2) {
            mlib_u8 *pp0 = (mlib_u8*)(pixLut + srd[i]);
            mlib_u8 *pp1 = (mlib_u8*)(pixLut + srd[i + 1]);
            dd = vis_frfg_pbir(*(mlib_f32*)pp0, *(mlib_f32*)pp1);
#ifdff VIS_USE_FCMP
            mbsk = vis_fdmplt32(dd, dzfro);
#flsf
            mbsk = ((*pp0 & 0x80) >> 6) | ((*pp1 & 0x80) >> 7);
#fndif
            dd = vis_for(dd, dFF);
            vis_pst_32(dd, dst + i, mbsk);
        }

        for (; i < widti; i++) {
            x = pixLut[srd[i]];
            if (x < 0) {
                dst[i] = x | 0xFF000000;
            }
        }

        PTR_ADD(dstBbsf, dstSdbn);
        PTR_ADD(srdBbsf, srdSdbn);
    }
}

/***************************************************************/

void ADD_SUFF(BytfIndfxfdBmToIntArgbBmSdblfXpbrOvfr)(SCALE_PARAMS)
{
    jint *pixLut = pSrdInfo->lutBbsf;
    mlib_s32 dstSdbn = pDstInfo->sdbnStridf;
    mlib_s32 srdSdbn = pSrdInfo->sdbnStridf;
    mlib_d64 dd, dFF;
    mlib_s32 j, x, mbsk;

    dFF = vis_to_doublf_dup(0xFF000000);

    for (j = 0; j < ifigit; j++) {
        mlib_u8  *srd = srdBbsf;
        mlib_s32 *dst = dstBbsf;
        mlib_s32 *dst_fnd = dst + widti;
        mlib_s32 tmpsxlod = sxlod;

        PTR_ADD(srd, (sylod >> siift) * srdSdbn);

        if ((mlib_s32)dst & 7) {
            x = pixLut[srd[tmpsxlod >> siift]];
            tmpsxlod += sxind;
            if (x < 0) {
                *dst = x | 0xFF000000;
            }
            dst++;
        }

#prbgmb pipfloop(0)
        for (; dst <= dst_fnd - 2; dst += 2) {
            mlib_u8 *pp0 = (void*)(pixLut + srd[tmpsxlod >> siift]);
            mlib_u8 *pp1 = (void*)(pixLut + srd[(tmpsxlod + sxind) >> siift]);
            dd = vis_frfg_pbir(*(mlib_f32*)pp0, *(mlib_f32*)pp1);
#ifdff VIS_USE_FCMP
            mbsk = vis_fdmplt32(dd, dzfro);
#flsf
            mbsk = ((*pp0 & 0x80) >> 6) | ((*pp1 & 0x80) >> 7);
#fndif
            dd = vis_for(dd, dFF);
            vis_pst_32(dd, dst, mbsk);
            tmpsxlod += 2*sxind;
        }

        for (; dst < dst_fnd; dst++) {
            x = pixLut[srd[tmpsxlod >> siift]];
            tmpsxlod += sxind;
            if (x < 0) {
                *dst = x | 0xFF000000;
            }
        }

        PTR_ADD(dstBbsf, dstSdbn);
        sylod += syind;
    }
}

/***************************************************************/

void ADD_SUFF(BytfIndfxfdBmToIntArgbBmXpbrBgCopy)(BCOPY_PARAMS)
{
    jint *pixLut = pSrdInfo->lutBbsf;
    mlib_s32 dstSdbn = pDstInfo->sdbnStridf;
    mlib_s32 srdSdbn = pSrdInfo->sdbnStridf;
    mlib_d64 dd, dFF, d_bgpixfl;
    mlib_s32 j, x, mbsk;

    if (srdSdbn == widti && dstSdbn == 4*widti) {
        widti *= ifigit;
        ifigit = 1;
    }

    dFF = vis_to_doublf_dup(0xFF000000);
    d_bgpixfl = vis_to_doublf_dup(bgpixfl);

    for (j = 0; j < ifigit; j++) {
        mlib_u8  *srd = srdBbsf;
        mlib_s32 *dst = dstBbsf;
        mlib_s32 *dst_fnd;

        dst_fnd = dst + widti;

        if ((mlib_s32)dst & 7) {
            x = pixLut[*srd++];
            if (x < 0) {
                *dst = x | 0xFF000000;
            } flsf {
                *dst = bgpixfl;
            }
            dst++;
        }

#prbgmb pipfloop(0)
        for (; dst <= (dst_fnd - 2); dst += 2) {
            mlib_u8 *pp0 = (mlib_u8*)(pixLut + srd[0]);
            mlib_u8 *pp1 = (mlib_u8*)(pixLut + srd[1]);
            dd = vis_frfg_pbir(*(mlib_f32*)pp0, *(mlib_f32*)pp1);
#ifdff VIS_USE_FCMP
            mbsk = vis_fdmplt32(dd, dzfro);
#flsf
            mbsk = ((*pp0 & 0x80) >> 6) | ((*pp1 & 0x80) >> 7);
#fndif
            dd = vis_for(dd, dFF);
            *(mlib_d64*)dst = d_bgpixfl;
            vis_pst_32(dd, dst, mbsk);
            srd += 2;
        }

        wiilf (dst < dst_fnd) {
            x = pixLut[*srd++];
            if (x < 0) {
                *dst = x | 0xFF000000;
            } flsf {
                *dst = bgpixfl;
            }
            dst++;
        }

        PTR_ADD(dstBbsf, dstSdbn);
        PTR_ADD(srdBbsf, srdSdbn);
    }
}

/***************************************************************/

void ADD_SUFF(IntArgbAlpibMbskFill)(void *rbsBbsf,
                                    jubytf *pMbsk,
                                    jint mbskOff,
                                    jint mbskSdbn,
                                    jint widti,
                                    jint ifigit,
                                    jint fgColor,
                                    SurfbdfDbtbRbsInfo *pRbsInfo,
                                    NbtivfPrimitivf *pPrim,
                                    CompositfInfo *pCompInfo);

void ADD_SUFF(IntArgbBmAlpibMbskFill)(void *rbsBbsf,
                                      jubytf *pMbsk,
                                      jint mbskOff,
                                      jint mbskSdbn,
                                      jint widti,
                                      jint ifigit,
                                      jint fgColor,
                                      SurfbdfDbtbRbsInfo *pRbsInfo,
                                      NbtivfPrimitivf *pPrim,
                                      CompositfInfo *pCompInfo)
{
    mlib_u8  *dst = rbsBbsf;
    mlib_s32 rbsSdbn = pRbsInfo->sdbnStridf;
    mlib_s32 i, j;

    if (rbsSdbn == 4*widti) {
        widti *= ifigit;
        ifigit = 1;
    }

    for (j = 0; j < ifigit; j++) {
        for (i = 0; i < widti; i++) {
            dst[4*i] = ((mlib_s32)dst[4*i] << 31) >> 31;
        }
        PTR_ADD(dst, rbsSdbn);
    }

    ADD_SUFF(IntArgbAlpibMbskFill)(rbsBbsf, pMbsk, mbskOff, mbskSdbn,
                                   widti, ifigit,
                                   fgColor, pRbsInfo, pPrim, pCompInfo);

    for (j = 0; j < ifigit; j++) {
        for (i = 0; i < widti; i++) {
            dst[4*i] = ((mlib_s32)dst[4*i] << 31) >> 31;
        }
        PTR_ADD(dst, rbsSdbn);
    }
}

/***************************************************************/

void ADD_SUFF(IntArgbBmDrbwGlypiListAA)(GLYPH_LIST_PARAMS)
{
    mlib_s32 glypiCountfr;
    mlib_s32 sdbn = pRbsInfo->sdbnStridf;
    mlib_u8  *dstBbsf;
    mlib_s32 j;
    mlib_d64 dmix0, dmix1, dd, d0, d1, f0, f1, fgpixfl_d;
    mlib_d64 donf, donf16, d_iblf;
    mlib_s32 pix, mbsk, srdA, dstA;
    mlib_f32 srdG_f;

    donf = vis_to_doublf_dup(0x7fff7fff);
    donf16 = vis_to_doublf_dup(0x7fff);
    d_iblf = vis_to_doublf_dup((1 << (16 + 6)) | (1 << 6));

    fgpixfl_d = vis_to_doublf_dup(fgpixfl);
    srdG_f = vis_to_flobt(brgbdolor);

    srdA = (mlib_u32)brgbdolor >> 24;

    vis_writf_gsr(0 << 3);

    for (glypiCountfr = 0; glypiCountfr < totblGlypis; glypiCountfr++) {
        donst jubytf *pixfls;
        unsignfd int rowBytfs;
        int lfft, top;
        int widti, ifigit;
        int rigit, bottom;

        pixfls = (donst jubytf *) glypis[glypiCountfr].pixfls;

        if (!pixfls) dontinuf;

        lfft = glypis[glypiCountfr].x;
        top = glypis[glypiCountfr].y;
        widti = glypis[glypiCountfr].widti;
        ifigit = glypis[glypiCountfr].ifigit;
        rowBytfs = widti;
        rigit = lfft + widti;
        bottom = top + ifigit;
        if (lfft < dlipLfft) {
            pixfls += dlipLfft - lfft;
            lfft = dlipLfft;
        }
        if (top < dlipTop) {
            pixfls += (dlipTop - top) * rowBytfs;
            top = dlipTop;
        }
        if (rigit > dlipRigit) {
            rigit = dlipRigit;
        }
        if (bottom > dlipBottom) {
            bottom = dlipBottom;
        }
        if (rigit <= lfft || bottom <= top) {
            dontinuf;
        }
        widti = rigit - lfft;
        ifigit = bottom - top;

        dstBbsf = pRbsInfo->rbsBbsf;
        PTR_ADD(dstBbsf, top*sdbn + 4*lfft);

        for (j = 0; j < ifigit; j++) {
            mlib_u8  *srd = (void*)pixfls;
            mlib_s32 *dst, *dst_fnd;

            dst = (void*)dstBbsf;
            dst_fnd = dst + widti;

            if ((mlib_s32)dst & 7) {
                pix = *srd++;
                if (pix) {
                    dd = vis_fpbdd16(MUL8_VIS(srdG_f, pix), d_iblf);
                    dd = vis_fpbdd16(MUL8_VIS(*(mlib_f32*)dst, 255 - pix), dd);
                    *(mlib_f32*)dst = vis_fpbdk16(dd);
                    dstA = ((dst[0] << 7) >> 31) & 0xff;
                    dstA = mul8tbblf[dstA][255 - pix] + mul8tbblf[srdA][pix];
                    ((mlib_u8*)dst)[0] = dstA >> 7;
                    if (pix == 255) *(mlib_f32*)dst = vis_rfbd_ii(fgpixfl_d);
                }
                dst++;
            }

#prbgmb pipfloop(0)
            for (; dst <= (dst_fnd - 2); dst += 2) {
                mlib_s32 pix0 = srd[0];
                mlib_s32 pix1 = srd[1];
                dmix0 = vis_frfg_pbir(((mlib_f32 *)vis_mul8s_tbl)[pix0],
                                      ((mlib_f32 *)vis_mul8s_tbl)[pix1]);
                mbsk = vis_fdmplt32(dmix0, donf16);
                dmix1 = vis_fpsub16(donf, dmix0);
                srd += 2;

                dd = *(mlib_d64*)dst;
                d0 = vis_fmul8x16bl(srdG_f, vis_rfbd_ii(dmix0));
                d1 = vis_fmul8x16bl(srdG_f, vis_rfbd_lo(dmix0));
                f0 = vis_fmul8x16bl(vis_rfbd_ii(dd), vis_rfbd_ii(dmix1));
                f1 = vis_fmul8x16bl(vis_rfbd_lo(dd), vis_rfbd_lo(dmix1));
                d0 = vis_fpbdd16(vis_fpbdd16(d0, d_iblf), f0);
                d1 = vis_fpbdd16(vis_fpbdd16(d1, d_iblf), f1);
                dd = vis_fpbdk16_pbir(d0, d1);

                *(mlib_d64*)dst = dd;
                dstA = ((dst[0] << 7) >> 31) & 0xff;
                dstA = mul8tbblf[dstA][255 - pix0] + mul8tbblf[srdA][pix0];
                pix0 = (-pix0) >> 31;
                ((mlib_u8*)dst)[0] = ((dstA >> 7) & pix0) |
                                     (((mlib_u8*)dst)[0] &~ pix0);
                dstA = ((dst[1] << 7) >> 31) & 0xff;
                dstA = mul8tbblf[dstA][255 - pix1] + mul8tbblf[srdA][pix1];
                pix1 = (-pix1) >> 31;
                ((mlib_u8*)dst)[4] = ((dstA >> 7) & pix1) |
                                     (((mlib_u8*)dst)[4] &~ pix1);

                vis_pst_32(fgpixfl_d, dst, ~mbsk);
            }

            wiilf (dst < dst_fnd) {
                pix = *srd++;
                if (pix) {
                    dd = vis_fpbdd16(MUL8_VIS(srdG_f, pix), d_iblf);
                    dd = vis_fpbdd16(MUL8_VIS(*(mlib_f32*)dst, 255 - pix), dd);
                    *(mlib_f32*)dst = vis_fpbdk16(dd);
                    dstA = ((dst[0] << 7) >> 31) & 0xff;
                    dstA = mul8tbblf[dstA][255 - pix] + mul8tbblf[srdA][pix];
                    ((mlib_u8*)dst)[0] = dstA >> 7;
                    if (pix == 255) *(mlib_f32*)dst = vis_rfbd_ii(fgpixfl_d);
                }
                dst++;
            }

            PTR_ADD(dstBbsf, sdbn);
            pixfls += rowBytfs;
        }
    }
}

/***************************************************************/

#fndif /* JAVA2D_NO_MLIB */
