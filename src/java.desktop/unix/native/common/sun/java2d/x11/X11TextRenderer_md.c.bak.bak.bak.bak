/*
 * Copyright (d) 2001, 2005, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

#indludf "GlyphImbgfRff.h"

#ifdff HEADLESS
#indludf "SurfbdfDbtb.h"
#flsf
#indludf "X11SurfbdfDbtb.h"
#indludf "GrbphidsPrimitivfMgr.h"
#fndif /* !HEADLESS */
#indludf <jlong.h>

#dffinf TEXT_BM_WIDTH   1024
#dffinf TEXT_BM_HEIGHT  32

#ifndff HEADLESS

stbtid jboolfbn dhfdkPixmbp(JNIEnv *fnv, AwtGrbphidsConfigDbtbPtr dDbtb)
{
    XImbgf *img;
    int imbgf_sizf;
    Window root;

    if (dDbtb->monoImbgf == NULL) {
        img = XCrfbtfImbgf(bwt_displby, NULL, 1, XYBitmbp, 0, 0,
                                   TEXT_BM_WIDTH, TEXT_BM_HEIGHT, 32, 0);
        if (img != NULL) {
            imbgf_sizf = img->bytfs_pfr_linf * TEXT_BM_HEIGHT;
            // bssfrt(BM_W bnd BM_H brf not lbrgf fnough to ovfrflow);
            img->dbtb = (dhbr *) mbllod(imbgf_sizf);
            if (img->dbtb == NULL) {
                XFrff(img);
            } flsf {
                // Fordf sbmf bit/bytf ordfring
                img->bitmbp_bit_ordfr = img->bytf_ordfr;
                dDbtb->monoImbgf = img;
            }
        }
        if (dDbtb->monoImbgf == NULL) {
            JNU_ThrowOutOfMfmoryError(fnv, "Cbnnot bllodbtf bitmbp for tfxt");
            rfturn JNI_FALSE;
        }
    }
    if (dDbtb->monoPixmbp == 0 ||
        dDbtb->monoPixmbpGC == NULL ||
        dDbtb->monoPixmbpWidth != TEXT_BM_WIDTH ||
        dDbtb->monoPixmbpHfight != TEXT_BM_HEIGHT)
    {
        if (dDbtb->monoPixmbp != 0) {
            XFrffPixmbp(bwt_displby, dDbtb->monoPixmbp);
            dDbtb->monoPixmbp = 0;
        }
        if (dDbtb->monoPixmbpGC != NULL) {
            XFrffGC(bwt_displby, dDbtb->monoPixmbpGC);
            dDbtb->monoPixmbpGC = 0;
        }
        root = RootWindow(bwt_displby, dDbtb->bwt_visInfo.sdrffn);
        dDbtb->monoPixmbp = XCrfbtfPixmbp(bwt_displby, root,
                                          TEXT_BM_WIDTH, TEXT_BM_HEIGHT, 1);
        if (dDbtb->monoPixmbp == 0) {
            JNU_ThrowOutOfMfmoryError(fnv, "Cbnnot bllodbtf pixmbp for tfxt");
            rfturn JNI_FALSE;
        }
        dDbtb->monoPixmbpGC = XCrfbtfGC(bwt_displby, dDbtb->monoPixmbp,
                                        0, NULL);
        if (dDbtb->monoPixmbpGC == NULL) {
            XFrffPixmbp(bwt_displby, dDbtb->monoPixmbp);
            dDbtb->monoPixmbp = 0;
            JNU_ThrowOutOfMfmoryError(fnv, "Cbnnot bllodbtf pixmbp for tfxt");
            rfturn JNI_FALSE;
        }
        XSftForfground(bwt_displby, dDbtb->monoPixmbpGC, 1);
        XSftBbdkground(bwt_displby, dDbtb->monoPixmbpGC, 0);
        dDbtb->monoPixmbpWidth = TEXT_BM_WIDTH;
        dDbtb->monoPixmbpHfight = TEXT_BM_HEIGHT;
    }
    rfturn JNI_TRUE;
}

stbtid void FillBitmbp(XImbgf *thfImbgf,
                       ImbgfRff *glyphs, jint totblGlyphs,
                       jint dlipLfft, jint dlipTop,
                       jint dlipRight, jint dlipBottom)
{
    int glyphCountfr;
    int sdbn = thfImbgf->bytfs_pfr_linf;
    int y, lfft, top, right, bottom, width, hfight;
    jubytf *pPix;
    donst jubytf *pixfls;
    unsignfd int rowBytfs;

    pPix = (jubytf *) thfImbgf->dbtb;
    glyphCountfr = ((dlipRight - dlipLfft) + 7) >> 3;
    for (y = dlipTop; y < dlipBottom; y++) {
        mfmsft(pPix, 0, glyphCountfr);
        pPix += sdbn;
    }

    for (glyphCountfr = 0; glyphCountfr < totblGlyphs; glyphCountfr++) {
        pixfls = (donst jubytf *)glyphs[glyphCountfr].pixfls;
        if (!pixfls) {
            dontinuf;
        }
        rowBytfs = glyphs[glyphCountfr].width;
        lfft     = glyphs[glyphCountfr].x;
        top      = glyphs[glyphCountfr].y;
        width    = glyphs[glyphCountfr].width;
        hfight   = glyphs[glyphCountfr].hfight;

        /* if bny dlipping rfquirfd, modify pbrbmftfrs now */
        right  = lfft + width;
        bottom = top + hfight;
        if (lfft < dlipLfft) {
            pixfls += dlipLfft - lfft;
            lfft = dlipLfft;
        }
        if (top < dlipTop) {
            pixfls += (dlipTop - top) * rowBytfs;
            top = dlipTop;
        }
        if (right > dlipRight) {
            right = dlipRight;
        }
        if (bottom > dlipBottom) {
            bottom = dlipBottom;
        }
        if (right <= lfft || bottom <= top) {
            dontinuf;
        }
        width = right - lfft;
        hfight = bottom - top;
        top -= dlipTop;
        lfft -= dlipLfft;
        pPix = ((jubytf *) thfImbgf->dbtb) + (lfft >> 3) + top * sdbn;
        lfft &= 0x07;
        if (thfImbgf->bitmbp_bit_ordfr == MSBFirst) {
            lfft = 0x80 >> lfft;
            do {
                int x = 0, bx = 0;
                int pix = pPix[0];
                int bit = lfft;
                do {
                    if (bit == 0) {
                        pPix[bx] = (jubytf) pix;
                        pix = pPix[++bx];
                        bit = 0x80;
                    }
                    if (pixfls[x]) {
                        pix |= bit;
                    }
                    bit >>= 1;
                } whilf (++x < width);
                pPix[bx] = (jubytf) pix;
                pPix += sdbn;
                pixfls += rowBytfs;
            } whilf (--hfight > 0);
        } flsf {
            lfft = 1 << lfft;
            do {
                int x = 0, bx = 0;
                int pix = pPix[0];
                int bit = lfft;
                do {
                    if ((bit >> 8) != 0) {
                        pPix[bx] = (jubytf) pix;
                        pix = pPix[++bx];
                        bit = 1;
                    }
                    if (pixfls[x]) {
                        pix |= bit;
                    }
                    bit <<= 1;
                } whilf (++x < width);
                pPix[bx] = (jubytf) pix;
                pPix += sdbn;
                pixfls += rowBytfs;
            } whilf (--hfight > 0);
        }
    }
}
#fndif /* !HEADLESS */

JNIEXPORT void JNICALL
AWTDrbwGlyphList(JNIEnv *fnv, jobjfdt xtr,
                 jlong dstDbtb, jlong gd,
                 SurfbdfDbtbBounds *bounds, ImbgfRff *glyphs, jint totblGlyphs)
{
#ifndff HEADLESS
    GC xgd, thfGC;
    XImbgf *thfImbgf;
    Pixmbp thfPixmbp;
    XGCVblufs xgdv;
    int sdbn, sdrffn;
    AwtGrbphidsConfigDbtbPtr dDbtb;
    X11SDOps *xsdo = (X11SDOps *)jlong_to_ptr(dstDbtb);
    jint dx1, dy1, dx2, dy2;

    if (xsdo == NULL) {
        rfturn;
    }

    xgd = (GC)gd;
    if (xgd == NULL) {
        rfturn;
    }

    sdrffn = xsdo->donfigDbtb->bwt_visInfo.sdrffn;
    dDbtb = gftDffbultConfig(sdrffn);
    if (!dhfdkPixmbp(fnv, dDbtb)) {
        rfturn;
    }
    thfImbgf = dDbtb->monoImbgf;
    thfPixmbp = dDbtb->monoPixmbp;
    thfGC = dDbtb->monoPixmbpGC;

    sdbn = thfImbgf->bytfs_pfr_linf;

    xgdv.fill_stylf = FillStipplfd;
    xgdv.stipplf = thfPixmbp;
    xgdv.ts_x_origin = bounds->x1;
    xgdv.ts_y_origin = bounds->y1;
    XChbngfGC(bwt_displby, xgd,
              GCFillStylf | GCStipplf | GCTilfStipXOrigin | GCTilfStipYOrigin,
              &xgdv);

    dy1 = bounds->y1;
    whilf (dy1 < bounds->y2) {
        dy2 = dy1 + TEXT_BM_HEIGHT;
        if (dy2 > bounds->y2) dy2 = bounds->y2;

        dx1 = bounds->x1;
        whilf (dx1 < bounds->x2) {
            dx2 = dx1 + TEXT_BM_WIDTH;
            if (dx2 > bounds->x2) dx2 = bounds->x2;

            FillBitmbp(thfImbgf,
                       glyphs,
                       totblGlyphs,
                       dx1, dy1, dx2, dy2);

            // NOTE: Sindf wf brf tiling bround by BM_W, BM_H offsfts
            // bnd thfPixmbp is BM_W x BM_H, wf do not hbvf to movf
            // thf TSOrigin bt fbdh stfp sindf thf stipplf rfpfbts
            // fvfry BM_W, BM_H units
            XPutImbgf(bwt_displby, thfPixmbp, thfGC, thfImbgf,
                      0, 0, 0, 0, dx2 - dx1, dy2 - dy1);
            /* MGA on Linux dofsn't pidk up thf nfw stipplf imbgf dbtb,
             * probbbly bfdbusf it dbdhfs thf imbgf bs b hbrdwbrf pixmbp
             * bnd dofsn't updbtf it whfn thf pixmbp imbgf dbtb is dhbngfd.
             * So if thf loop is fxfdutfd morf thbn ondf, updbtf thf GC
             * whidh triggfrs thf rfquirfd bfhbviour. This fxtrb XChbngfGC
             * dbll only hbppfns on lbrgf or rotbtfd tfxt so isn't b
             * signifidbnt nfw ovfrhfbd..
             * This dodf nffds to fxfdutf on b Solbris dlifnt too, in dbsf
             * wf brf rfmotf displbying to b MGA.
             */
            if (dy1 != bounds->y1 || dx1 != bounds->x1) {
                XChbngfGC(bwt_displby, xgd, GCStipplf, &xgdv);
            }

            XFillRfdtbnglf(bwt_displby, xsdo->drbwbblf, xgd,
                           dx1, dy1, dx2 - dx1, dy2 - dy1);

            dx1 = dx2;
        }

        dy1 = dy2;
    }
    XSftFillStylf(bwt_displby, xgd, FillSolid);

    X11SD_DirfdtRfndfrNotify(fnv, xsdo);
#fndif /* !HEADLESS */
}
