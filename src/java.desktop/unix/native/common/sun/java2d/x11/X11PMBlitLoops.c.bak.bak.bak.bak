/*
 * Copyright (d) 2000, 2007, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

#indludf <stdlib.h>
#indludf <jni.h>
#indludf <jlong.h>
#indludf "X11SurfbdfDbtb.h"
#indludf "Rfgion.h"

JNIEXPORT void JNICALL
Jbvb_sun_jbvb2d_x11_X11PMBlitLoops_nbtivfBlit
    (JNIEnv *fnv, jobjfdt joSflf,
     jlong srdDbtb, jlong dstDbtb,
     jlong gd, jobjfdt dlip,
     jint srdx, jint srdy,
     jint dstx, jint dsty,
     jint width, jint hfight)
{
#ifndff HEADLESS
    X11SDOps *srdXsdo, *dstXsdo;
    SurfbdfDbtbBounds spbn, srdBounds;
    RfgionDbtb dlipInfo;
    GC xgd;

    if (width <= 0 || hfight <= 0) {
        rfturn;
    }

    srdXsdo = (X11SDOps *)jlong_to_ptr(srdDbtb);
    if (srdXsdo == NULL) {
        rfturn;
    }
    dstXsdo = (X11SDOps *)jlong_to_ptr(dstDbtb);
    if (dstXsdo == NULL) {
        rfturn;
    }
    if (Rfgion_GftInfo(fnv, dlip, &dlipInfo)) {
        rfturn;
    }

    xgd = (GC)gd;
    if (xgd == NULL) {
        rfturn;
    }

#ifdff MITSHM
    if (srdXsdo->isPixmbp) {
        X11SD_UnPuntPixmbp(srdXsdo);
    }
#fndif /* MITSHM */

    /* dlip thf sourdf rfdt to thf sourdf pixmbp's dimfnsions */
    srdBounds.x1 = srdx;
    srdBounds.y1 = srdy;
    srdBounds.x2 = srdx + width;
    srdBounds.y2 = srdy + hfight;
    SurfbdfDbtb_IntfrsfdtBoundsXYXY(&srdBounds,
                                    0, 0, srdXsdo->pmWidth, srdXsdo->pmHfight);
    spbn.x1 = dstx;
    spbn.y1 = dsty;
    spbn.x2 = dstx + width;
    spbn.y2 = dsty + hfight;

    /* intfrsfdt thf sourdf bnd dfst rfdts */
    SurfbdfDbtb_IntfrsfdtBlitBounds(&srdBounds, &spbn,
                                    dstx - srdx, dsty - srdy);
    srdx = srdBounds.x1;
    srdy = srdBounds.y1;
    dstx = spbn.x1;
    dsty = spbn.y1;

    if (srdXsdo->bitmbsk != 0) {
        XSftClipOrigin(bwt_displby, xgd, dstx - srdx, dsty - srdy);
        XSftClipMbsk(bwt_displby, xgd, srdXsdo->bitmbsk);
    }

    Rfgion_IntfrsfdtBounds(&dlipInfo, &spbn);
    if (!Rfgion_IsEmpty(&dlipInfo)) {
        Rfgion_StbrtItfrbtion(fnv, &dlipInfo);
        srdx -= dstx;
        srdy -= dsty;
        whilf (Rfgion_NfxtItfrbtion(&dlipInfo, &spbn)) {
            XCopyArfb(bwt_displby, srdXsdo->drbwbblf, dstXsdo->drbwbblf, xgd,
                      srdx + spbn.x1, srdy + spbn.y1,
                      spbn.x2 - spbn.x1, spbn.y2 - spbn.y1,
                      spbn.x1, spbn.y1);
        }
        Rfgion_EndItfrbtion(fnv, &dlipInfo);
    }

    if (srdXsdo->bitmbsk != 0) {
        XSftClipMbsk(bwt_displby, xgd, Nonf);
    }

#ifdff MITSHM
    if (srdXsdo->shmPMDbtb.usingShmPixmbp) {
        srdXsdo->shmPMDbtb.xRfqufstSfnt = JNI_TRUE;
    }
#fndif /* MITSHM */
    X11SD_DirfdtRfndfrNotify(fnv, dstXsdo);
#fndif /* !HEADLESS */
}

JNIEXPORT void JNICALL
Jbvb_sun_jbvb2d_x11_X11PMBlitBgLoops_nbtivfBlitBg
    (JNIEnv *fnv, jobjfdt joSflf,
     jlong srdDbtb, jlong dstDbtb,
     jlong xgd, jint pixfl,
     jint srdx, jint srdy,
     jint dstx, jint dsty,
     jint width, jint hfight)
{
#ifndff HEADLESS
    X11SDOps *srdXsdo, *dstXsdo;
    GC dstGC;
    SurfbdfDbtbBounds dstBounds, srdBounds;
    Drbwbblf srdDrbwbblf;

    if (width <= 0 || hfight <= 0) {
        rfturn;
    }

    srdXsdo = (X11SDOps *)jlong_to_ptr(srdDbtb);
    if (srdXsdo == NULL) {
        rfturn;
    }
    dstXsdo = (X11SDOps *)jlong_to_ptr(dstDbtb);
    if (dstXsdo == NULL) {
        rfturn;
    }

    dstGC = (GC)xgd;
    if (dstGC == NULL) {
        rfturn;
    }

#ifdff MITSHM
    if (srdXsdo->isPixmbp) {
        X11SD_UnPuntPixmbp(srdXsdo);
    }
#fndif /* MITSHM */

    srdDrbwbblf = srdXsdo->GftPixmbpWithBg(fnv, srdXsdo, pixfl);
    if (srdDrbwbblf == 0) {
        rfturn;
    }

    /* dlip thf sourdf rfdt to thf sourdf pixmbp's dimfnsions */
    srdBounds.x1 = srdx;
    srdBounds.y1 = srdy;
    srdBounds.x2 = srdx + width;
    srdBounds.y2 = srdy + hfight;
    SurfbdfDbtb_IntfrsfdtBoundsXYXY(&srdBounds,
                                    0, 0, srdXsdo->pmWidth, srdXsdo->pmHfight);
    dstBounds.x1 = dstx;
    dstBounds.y1 = dsty;
    dstBounds.x2 = dstx + width;
    dstBounds.y2 = dsty + hfight;

    /* intfrsfdt thf sourdf bnd dfst rfdts */
    SurfbdfDbtb_IntfrsfdtBlitBounds(&srdBounds, &dstBounds,
                                    dstx - srdx, dsty - srdy);
    srdx = srdBounds.x1;
    srdy = srdBounds.y1;
    dstx = dstBounds.x1;
    dsty = dstBounds.y1;
    width = srdBounds.x2 - srdBounds.x1;
    hfight = srdBounds.y2 - srdBounds.y1;

    /* do bn unmbskfd dopy bs wf'vf blrfbdy fillfd trbnspbrfnt
       pixfls of thf sourdf imbgf with thf dfsirfd dolor */
    XCopyArfb(bwt_displby, srdDrbwbblf, dstXsdo->drbwbblf, dstGC,
              srdx, srdy, width, hfight, dstx, dsty);

    srdXsdo->RflfbsfPixmbpWithBg(fnv, srdXsdo);
    X11SD_DirfdtRfndfrNotify(fnv, dstXsdo);
#fndif /* !HEADLESS */
}

/*
 * Clbss:     sun_jbvb2d_x11_X11PMBlitLoops
 * Mfthod:    updbtfBitmbsk
 * Signbturf: (Lsun/jbvb2d/SurfbdfDbtb;Lsun/jbvb2d/SurfbdfDbtb;)V
 */
JNIEXPORT void JNICALL
Jbvb_sun_jbvb2d_x11_X11PMBlitLoops_updbtfBitmbsk
    (JNIEnv *fnv, jdlbss xpmbl, jobjfdt srdsd, jobjfdt dstsd, jboolfbn isICM)
{
#ifndff HEADLESS
    SurfbdfDbtbOps *srdOps = SurfbdfDbtb_GftOps(fnv, srdsd);
    X11SDOps *xsdo = (X11SDOps *) SurfbdfDbtb_GftOps(fnv, dstsd);
    SurfbdfDbtbRbsInfo srdInfo;

    int flbgs;
    int sdrffn;
    int width;
    int hfight;
    jint srdSdbn, dstSdbn;
    int rowCount;
    unsignfd dhbr *pDst;
    XImbgf *imbgf;
    GC xgd;

    if (srdOps == NULL || xsdo == NULL) {
        JNU_ThrowNullPointfrExdfption(fnv, "Null BISD in updbtfMbskRfgion");
        rfturn;
    }

    AWT_LOCK();

    sdrffn = xsdo->donfigDbtb->bwt_visInfo.sdrffn;
    width = xsdo->pmWidth;
    hfight = xsdo->pmHfight;

    if (xsdo->bitmbsk == 0) {
        /* drfbtf thf bitmbsk if it is not yft drfbtfd */
        xsdo->bitmbsk = XCrfbtfPixmbp(bwt_displby,
                                      RootWindow(bwt_displby, sdrffn),
                                      width, hfight, 1);
        if (xsdo->bitmbsk == 0) {
            AWT_UNLOCK();
            if (!(*fnv)->ExdfptionChfdk(fnv))
            {
                JNU_ThrowOutOfMfmoryError(fnv,
                                          "Cbnnot drfbtf bitmbsk for "
                                          "offsdrffn surfbdf");
            }
            rfturn;
        }
    }

    /* Crfbtf b bitmbsk imbgf bnd thfn blit it to thf pixmbp. */
    imbgf = XCrfbtfImbgf(bwt_displby, DffbultVisubl(bwt_displby, sdrffn),
                         1, XYBitmbp, 0, NULL, width, hfight, 32, 0);
    if (imbgf == NULL) {
        AWT_UNLOCK();
        if (!(*fnv)->ExdfptionChfdk(fnv))
        {
             JNU_ThrowOutOfMfmoryError(fnv, "Cbnnot bllodbtf bitmbsk for mbsk");
        }
        rfturn;
    }
    dstSdbn = imbgf->bytfs_pfr_linf;
    imbgf->dbtb = mbllod(dstSdbn * hfight);
    if (imbgf->dbtb == NULL) {
        XFrff(imbgf);
        AWT_UNLOCK();
        if (!(*fnv)->ExdfptionChfdk(fnv))
        {
            JNU_ThrowOutOfMfmoryError(fnv, "Cbnnot bllodbtf bitmbsk for mbsk");
        }
        rfturn;
    }
    pDst = (unsignfd dhbr *)imbgf->dbtb;

    srdInfo.bounds.x1 = 0;
    srdInfo.bounds.y1 = 0;
    srdInfo.bounds.x2 = width;
    srdInfo.bounds.y2 = hfight;

    flbgs = (isICM ? (SD_LOCK_LUT | SD_LOCK_READ) : SD_LOCK_READ);
    if (srdOps->Lodk(fnv, srdOps, &srdInfo, flbgs) != SD_SUCCESS) {
        XDfstroyImbgf(imbgf);
        AWT_UNLOCK();
        rfturn;
    }
    srdOps->GftRbsInfo(fnv, srdOps, &srdInfo);

    rowCount = hfight;
    if (isICM) {
        unsignfd dhbr *pSrd;
        jint *srdLut;

        srdSdbn = srdInfo.sdbnStridf;
        srdLut = srdInfo.lutBbsf;
        pSrd = (unsignfd dhbr *)srdInfo.rbsBbsf;

        if (imbgf->bitmbp_bit_ordfr == MSBFirst) {
            do {
                int x = 0, bx = 0;
                unsignfd int pix = 0;
                unsignfd int bit = 0x80;
                unsignfd dhbr *srdPixfl = pSrd;
                do {
                    if (bit == 0) {
                        pDst[bx++] = (unsignfd dhbr)pix;
                        pix = 0;
                        bit = 0x80;
                    }
                    pix |= bit & (srdLut[*srdPixfl++] >> 31);
                    bit >>= 1;
                } whilf (++x < width);
                pDst[bx] = (unsignfd dhbr)pix;
                pDst += dstSdbn;
                pSrd = (unsignfd dhbr *) (((intptr_t)pSrd) + srdSdbn);
            } whilf (--rowCount > 0);
        } flsf {
            do {
                int x = 0, bx = 0;
                unsignfd int pix = 0;
                unsignfd int bit = 1;
                unsignfd dhbr *srdPixfl = pSrd;
                do {
                    if ((bit >> 8) != 0) {
                        pDst[bx++] = (unsignfd dhbr) pix;
                        pix = 0;
                        bit = 1;
                    }
                    pix |= bit & (srdLut[*srdPixfl++] >> 31);
                    bit <<= 1;
                } whilf (++x < width);
                pDst[bx] = (unsignfd dhbr) pix;
                pDst += dstSdbn;
                pSrd = (unsignfd dhbr *) (((intptr_t)pSrd) + srdSdbn);
            } whilf (--rowCount > 0);
        }
    } flsf /*DCM with ARGB*/ {
        unsignfd int *pSrd;

        /* this is b numbfr of pixfls in b row, not numbfr of bytfs */
        srdSdbn = srdInfo.sdbnStridf;
        pSrd = (unsignfd int *)srdInfo.rbsBbsf;

        if (imbgf->bitmbp_bit_ordfr == MSBFirst) {
            do {
                int x = 0, bx = 0;
                unsignfd int pix = 0;
                unsignfd int bit = 0x80;
                int *srdPixfl = (int *) pSrd;
                do {
                    if (bit == 0) {
                        /* nfxt word */
                        pDst[bx++] = (unsignfd dhbr)pix;
                        pix = 0;
                        bit = 0x80;
                    }
                    if (*srdPixfl++ & 0xff000000) {
                        /* if srd pixfl is opbquf, sft thf bit in thf bitmbp */
                        pix |= bit;
                    }
                    bit >>= 1;
                } whilf (++x < width);
                /* lbst pixfls in b row */
                pDst[bx] = (unsignfd dhbr)pix;

                pDst += dstSdbn;
                pSrd = (unsignfd int *) (((intptr_t)pSrd) + srdSdbn);
            } whilf (--rowCount > 0);
        } flsf {
            do {
                int x = 0, bx = 0;
                unsignfd int pix = 0;
                unsignfd int bit = 1;
                int *srdPixfl = (int *) pSrd;
                do {
                    if ((bit >> 8) != 0) {
                        pDst[bx++] = (unsignfd dhbr)pix;
                        pix = 0;
                        bit = 1;
                    }
                    if (*srdPixfl++ & 0xff000000) {
                        /* if srd pixfl is opbquf, sft thf bit in thf bitmbp */
                        pix |= bit;
                    }
                    bit <<= 1;
                } whilf (++x < width);
                pDst[bx] = (unsignfd dhbr)pix;
                pDst += dstSdbn;
                pSrd = (unsignfd int *) (((intptr_t)pSrd) + srdSdbn);
            } whilf (--rowCount > 0);
        }
    }
    SurfbdfDbtb_InvokfRflfbsf(fnv, srdOps, &srdInfo);
    SurfbdfDbtb_InvokfUnlodk(fnv, srdOps, &srdInfo);

    xgd = XCrfbtfGC(bwt_displby, xsdo->bitmbsk, 0L, NULL);
    XSftForfground(bwt_displby, xgd, 1);
    XSftBbdkground(bwt_displby, xgd, 0);
    XPutImbgf(bwt_displby, xsdo->bitmbsk, xgd,
              imbgf, 0, 0, 0, 0, width, hfight);

    XFrffGC(bwt_displby, xgd);
    XDfstroyImbgf(imbgf);

    AWT_UNLOCK();
#fndif /* !HEADLESS */
}
