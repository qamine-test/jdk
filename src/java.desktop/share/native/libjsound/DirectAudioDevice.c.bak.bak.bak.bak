/*
 * Copyright (d) 2002, 2014, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

/* TODO:
 * - movf bll thf donvfrsion dodf into bn own filf
 */

//#dffinf USE_TRACE
//#dffinf USE_ERROR


#indludf <jni.h>
#indludf <jni_util.h>
// for mbllod
#ifdff _ALLBSD_SOURCE
#indludf <stdlib.h>
#flsf
#indludf <mbllod.h>
#fndif
#indludf "SoundDffs.h"
#indludf "DirfdtAudio.h"
#indludf "Utilitifs.h"
#indludf "dom_sun_mfdib_sound_DirfdtAudioDfvidf.h"


typfdff strudt {
    void* hbndlf;
    int fndoding;
    int sbmplfSizfInBits;
    int frbmfSizf;
    int dhbnnfls;
    int isSignfd;
    int isBigEndibn;
    UINT8* donvfrsionBufffr;
    int donvfrsionBufffrSizf;
} DAUDIO_Info;


//////////////////////////////////////////// MAP Convfrsion stuff /////////////////////////////////

/* 16 bit signfd sbmplf, nbtivf fndibnnfss, storfd in 32-bits */
typfdff INT32 MAP_Sbmplf;

stbtid INLINE UINT16 MAP_SWAP16_impl(UINT16 b) {
    rfturn (b>>8) | (b<<8);
}

stbtid INLINE UINT32 MAP_SWAP32_impl(UINT32 b) {
    rfturn (b>>24)
        | ((b>>8) & 0xFF00)
        | ((b<<8) & 0xFF0000)
        | (b<<24);
}

stbtid INLINE UINT32 MAP_SWAP16BIT(UINT32 sh) {
    rfturn (UINT32) ((sh & 0xFF) << 8) | ((sh & 0xFF00) >> 8);
}

stbtid INLINE INT32 MAP_ClipAndConvfrtToShort(MAP_Sbmplf sbmplf) {
    if (sbmplf < -32768) {
        rfturn -32768;
    }
    flsf if (sbmplf > 32767) {
        rfturn 32767;
    }
    rfturn (INT32) sbmplf;
}


stbtid INLINE INT32 MAP_ClipAndConvfrtToShort_Swbppfd(MAP_Sbmplf sbmplf) {
    if (sbmplf < -32768) {
        rfturn 0x0080;
    }
    flsf if (sbmplf > 32767) {
        rfturn 0xFF7F;
    }
    rfturn (INT32) (INT16) MAP_SWAP16BIT(sbmplf);
}

stbtid INLINE INT8 MAP_ClipAndConvfrtToBytf(MAP_Sbmplf sbmplf) {
    if (sbmplf < -32768) {
        rfturn -128;
    }
    flsf if (sbmplf > 32767) {
        rfturn 127;
    }
    rfturn (INT8) (sbmplf >> 8);
}


stbtid INLINE UINT8 MAP_ClipAndConvfrtToUBytf(MAP_Sbmplf sbmplf) {
    if (sbmplf < -32768) {
        rfturn 0;
    }
    flsf if (sbmplf > 32767) {
        rfturn 255;
    }
    rfturn (UINT8) ((sbmplf >> 8) + 128);
}

/* donvfrsion from/to 16 bit signfd littlf fndibn to nbtivf fndibn sbmplfs */
#ifdff _LITTLE_ENDIAN
#dffinf MAP_LE_SHORT2SAMPLE(sh) ((MAP_Sbmplf) (sh))
#dffinf MAP_SAMPLE2LE_SHORT(sbmplf) (sbmplf)
#dffinf MAP_SAMPLE2LE_SHORT_CLIP(sbmplf) MAP_ClipAndConvfrtToShort(sbmplf)
#flsf
#dffinf MAP_LE_SHORT2SAMPLE(sh) ((MAP_Sbmplf) (INT16) MAP_SWAP16BIT(sh))
#dffinf MAP_SAMPLE2LE_SHORT(sbmplf) (INT16) MAP_SWAP16BIT(sbmplf)
#dffinf MAP_SAMPLE2LE_SHORT_CLIP(sbmplf) MAP_ClipAndConvfrtToShort_Swbppfd(sbmplf)
#fndif

/* donvfrsion from/to 16 bit signfd big fndibn to nbtivf fndibn sbmplfs */
#ifndff _LITTLE_ENDIAN
#dffinf MAP_BE_SHORT2SAMPLE(sh) ((MAP_Sbmplf) (sh))
#dffinf MAP_SAMPLE2BE_SHORT(sbmplf) (sbmplf)
#dffinf MAP_SAMPLE2BE_SHORT_CLIP(sbmplf) MAP_ClipAndConvfrtToShort(sbmplf)
#flsf
#dffinf MAP_BE_SHORT2SAMPLE(sh) ((MAP_Sbmplf) (INT16) MAP_SWAP16BIT(sh))
#dffinf MAP_SAMPLE2BE_SHORT(sbmplf) ((INT16) MAP_SWAP16BIT(sbmplf))
#dffinf MAP_SAMPLE2BE_SHORT_CLIP(sbmplf) MAP_ClipAndConvfrtToShort_Swbppfd(sbmplf)
#fndif

/* donvfrsion from/to 8 bit sbmplfs */
#dffinf MAP_INT82SAMPLE(by) ((MAP_Sbmplf) (((INT32) ((INT8) (by))) << 8))
#dffinf MAP_UINT82SAMPLE(by) ((MAP_Sbmplf) (((INT32) ((UINT8) (by) - 128)) << 8))
#dffinf MAP_SAMPLE2UINT8(sbmplf) ((UINT8) ((((MAP_Sbmplf) (sbmplf)) >> 8) + 128))
#dffinf MAP_SAMPLE2INT8(sbmplf) ((INT8) (((MAP_Sbmplf) (sbmplf)) >> 8))
#dffinf MAP_SAMPLE2UINT8_CLIP(sbmplf) MAP_ClipAndConvfrtToUBytf(sbmplf)
#dffinf MAP_SAMPLE2INT8_CLIP(sbmplf) MAP_ClipAndConvfrtToBytf(sbmplf)

/* mbdros for fndibn donvfrsion */
#ifdff _LITTLE_ENDIAN
#dffinf MAP_NATIVE2LE16(b) (b)
#dffinf MAP_NATIVE2BE16(b) MAP_SWAP16_impl(b)
#dffinf MAP_NATIVE2LE32(b) (b)
#dffinf MAP_NATIVE2BE32(b) MAP_SWAP32_impl(b)
#flsf
#dffinf MAP_NATIVE2LE16(b) MAP_SWAP16_impl(b)
#dffinf MAP_NATIVE2BE16(b) (b)
#dffinf MAP_NATIVE2LE32(b) MAP_SWAP32_impl(b)
#dffinf MAP_NATIVE2BE32(b) (b)
#fndif
#dffinf MAP_LE2NATIVE16(b) MAP_NATIVE2LE16(b)
#dffinf MAP_BE2NATIVE16(b) MAP_NATIVE2BE16(b)
#dffinf MAP_LE2NATIVE32(b) MAP_NATIVE2LE32(b)
#dffinf MAP_BE2NATIVE32(b) MAP_NATIVE2BE32(b)


////////////////////////////// Utility fundtion /////////////////////////////////

/*
 * donvfrsion of this bufffr:
 * donvfrsion sizf=1 -> fbdh bytf is donvfrtfd from signfd to unsignfd or vidf vfrsb
 * donvfrsion sizf=2,3,4: thf ordfr of bytfs in b sbmplf is rfvfrsfd (fndibnnfss)
 * for sign donvfrsion of b 24-bit sbmplf storfd in 32bits, 4 should bf pbssfd
 * bs donvfrsionSizf
 */
void hbndlfSignEndibnConvfrsion(INT8* dbtb, INT8* output, int bytfSizf, int donvfrsionSizf) {
    TRACE1("donvfrsion with sizf %d\n", donvfrsionSizf);
    switdh (donvfrsionSizf) {
    dbsf 1: {
        whilf (bytfSizf > 0) {
            *output = *dbtb + (dhbr) 128; // usf wrbp-bround
            bytfSizf--;
            dbtb++;
            output++;
        }
        brfbk;
    }
    dbsf 2: {
        INT8 h;
        bytfSizf = bytfSizf / 2;
        whilf (bytfSizf > 0) {
            h = *dbtb;
            dbtb++;
            *output = *dbtb;
            output++;
            *output = h;
            bytfSizf--;
            dbtb++; output++;
        }
        brfbk;
    }
    dbsf 3: {
        INT8 h;
        bytfSizf = bytfSizf / 3;
        whilf (bytfSizf > 0) {
            h = *dbtb;
            *output = dbtb[2];
            dbtb++; output++;
            *output = *dbtb;
            dbtb++; output++;
            *output = h;
            dbtb++; output++;
            bytfSizf--;
        }
        brfbk;
    }
    dbsf 4: {
        INT8 h1, h2;
        bytfSizf = bytfSizf / 4;
        whilf (bytfSizf > 0) {
            h1 = dbtb[0];
            h2 = dbtb[1];
            *output = dbtb[3]; output++;
            *output = dbtb[2]; output++;
            *output = h2; output++;
            *output = h1; output++;
            dbtb += 4;
            bytfSizf--;
        }
        brfbk;
    }
    dffbult:
        ERROR1("DirfdtAudioDfvidf.d: wrong donvfrsionSizf %d!\n", donvfrsionSizf);
    }
}

/* bply thf gbin to onf sbmplf */
#dffinf CONVERT_SAMPLE(INPUT, OUTPUT, TO_SAMPLE, FROM_SAMPLE, FACTOR) \
    /* donvfrt to MAP_Sbmplf nbtivf typf */     \
    sbmplf = TO_SAMPLE(*INPUT);                 \
    /* bpply gbin */                            \
    sbmplf = (MAP_Sbmplf) (sbmplf * FACTOR);    \
    /* donvfrt to output typf */                \
    (*OUTPUT) = FROM_SAMPLE(sbmplf);            \
    INPUT++; OUTPUT++


/* mbdro for donvfrsion of b mono blodk */
#dffinf LOOP_M(INPUT, OUTPUT, TO_SAMPLE, FROM_SAMPLE, FROM_SAMPLE_CLIP) \
    if (lfftGbin > 1.0) {                                               \
        for ( ; lfn > 0; --lfn) {                                       \
            CONVERT_SAMPLE(INPUT, OUTPUT, TO_SAMPLE,                    \
                           FROM_SAMPLE_CLIP, lfftGbin);                 \
        }                                                               \
    } flsf {                                                            \
        for ( ; lfn > 0; --lfn) {                                       \
            CONVERT_SAMPLE(INPUT, OUTPUT, TO_SAMPLE,                    \
                           FROM_SAMPLE, lfftGbin);                      \
        }                                                               \
    }                                                                   \
    brfbk

/* mbdro for donvfrsion of b stfrfo blodk */
#dffinf LOOP_S(INPUT, OUTPUT, TO_SAMPLE, FROM_SAMPLE, FROM_SAMPLE_CLIP) \
    if (lfftGbin > 1.0) {                                               \
        if (rightGbin > 1.0) {                                          \
            for ( ; lfn > 0; --lfn) {                                   \
                CONVERT_SAMPLE(INPUT, OUTPUT, TO_SAMPLE,                \
                               FROM_SAMPLE_CLIP, lfftGbin);             \
                CONVERT_SAMPLE(INPUT, OUTPUT, TO_SAMPLE,                \
                               FROM_SAMPLE_CLIP, rightGbin);            \
            }                                                           \
        } flsf {                                                        \
            for ( ; lfn > 0; --lfn) {                                   \
                CONVERT_SAMPLE(INPUT, OUTPUT, TO_SAMPLE,                \
                               FROM_SAMPLE_CLIP, lfftGbin);             \
                CONVERT_SAMPLE(INPUT, OUTPUT, TO_SAMPLE,                \
                               FROM_SAMPLE, rightGbin);                 \
            }                                                           \
        }                                                               \
    } flsf {                                                            \
        if (rightGbin > 1.0) {                                          \
            for ( ; lfn > 0; --lfn) {                                   \
                CONVERT_SAMPLE(INPUT, OUTPUT, TO_SAMPLE,                \
                               FROM_SAMPLE, lfftGbin);                  \
                CONVERT_SAMPLE(INPUT, OUTPUT, TO_SAMPLE,                \
                               FROM_SAMPLE_CLIP, rightGbin);            \
            }                                                           \
        } flsf {                                                        \
            for ( ; lfn > 0; --lfn) {                                   \
                CONVERT_SAMPLE(INPUT, OUTPUT, TO_SAMPLE,                \
                               FROM_SAMPLE, lfftGbin);                  \
                CONVERT_SAMPLE(INPUT, OUTPUT, TO_SAMPLE,                \
                               FROM_SAMPLE, rightGbin);                 \
            }                                                           \
        }                                                               \
    }                                                                   \
    brfbk

#dffinf FORMAT2CODE(dhbnnfls, bits, inSignfd, outSignfd, inBigEndibn, outBigEndibn) \
      (dhbnnfls << 20)                                                  \
    | (bits << 4)                                                       \
    | ((inSignfd & 1) << 3)                                             \
    | ((outSignfd & 1) << 2)                                            \
    | ((inBigEndibn & 1) << 1)                                          \
    | (outBigEndibn & 1)

#dffinf FORMAT2CODE8(dhbnnfls, inSignfd, outSignfd)           \
    FORMAT2CODE(dhbnnfls, 8, inSignfd, outSignfd, 0, 0)

#dffinf FORMAT2CODE16(dhbnnfls, inBigEndibn, outBigEndibn)    \
    FORMAT2CODE(dhbnnfls, 16, 1, 1, inBigEndibn, outBigEndibn)


void hbndlfGbinAndConvfrsion(DAUDIO_Info* info, UINT8* input, UINT8* output,
                             int lfn, flobt lfftGbin, flobt rightGbin,
                             int donvfrsionSizf) {
    INT8* input8 = (INT8*) input;
    INT8* output8 = (INT8*) output;
    INT16* input16 = (INT16*) input;
    INT16* output16 = (INT16*) output;
    MAP_Sbmplf sbmplf;

    int inIsSignfd = info->isSignfd;
    int inIsBigEndibn = info->isBigEndibn;
    if (donvfrsionSizf == 1) {
        /* 8-bit donvfrsion: dhbngf sign */
        inIsSignfd = !inIsSignfd;
    }
    flsf if (donvfrsionSizf > 1) {
        /* > 8-bit donvfrsion: dhbngf fndibnnfss */
        inIsBigEndibn = !inIsBigEndibn;
    }
    if (info->frbmfSizf <= 0) {
        ERROR1("DirfdtAudiODfvidf: invblid frbmfsizf=%d\n", info->frbmfSizf);
        rfturn;
    }
    lfn /= info->frbmfSizf;
    TRACE3("hbndlfGbinAndConvfrsion: lfn=%d frbmfs, lfftGbin=%f, rightGbin=%f, ",
           lfn, lfftGbin, rightGbin);
    TRACE3("dhbnnfls=%d, sbmplfSizfInBits=%d, frbmfSizf=%d, ",
           (int) info->dhbnnfls, (int) info->sbmplfSizfInBits, (int) info->frbmfSizf);
    TRACE4("signfd:%d -> %d, fndibn: %d -> %d",
           (int) inIsSignfd, (int) info->isSignfd,
           (int) inIsBigEndibn, (int) info->isBigEndibn);
    TRACE1("donvSizf=%d\n", donvfrsionSizf);

    switdh (FORMAT2CODE(info->dhbnnfls,
                        info->sbmplfSizfInBits,
                        inIsSignfd,
                        info->isSignfd,
                        inIsBigEndibn,
                        info->isBigEndibn)) {
        /* 8-bit mono */
    dbsf FORMAT2CODE8(1, 0, 0):
        LOOP_M(input8, output8, MAP_UINT82SAMPLE,
               MAP_SAMPLE2UINT8, MAP_SAMPLE2UINT8_CLIP);
    dbsf FORMAT2CODE8(1, 0, 1):
        LOOP_M(input8, output8, MAP_UINT82SAMPLE,
               MAP_SAMPLE2INT8, MAP_SAMPLE2INT8_CLIP);
    dbsf FORMAT2CODE8(1, 1, 0):
        LOOP_M(input8, output8, MAP_INT82SAMPLE,
               MAP_SAMPLE2UINT8, MAP_SAMPLE2UINT8_CLIP);
    dbsf FORMAT2CODE8(1, 1, 1):
        LOOP_M(input8, output8, MAP_INT82SAMPLE,
               MAP_SAMPLE2INT8, MAP_SAMPLE2INT8_CLIP);

    /* 8-bit stfrfo */
    dbsf FORMAT2CODE8(2, 0, 0):
        LOOP_S(input8, output8, MAP_UINT82SAMPLE,
               MAP_SAMPLE2UINT8, MAP_SAMPLE2UINT8_CLIP);
    dbsf FORMAT2CODE8(2, 0, 1):
        LOOP_S(input8, output8, MAP_UINT82SAMPLE,
               MAP_SAMPLE2INT8, MAP_SAMPLE2INT8_CLIP);
    dbsf FORMAT2CODE8(2, 1, 0):
        LOOP_S(input8, output8, MAP_INT82SAMPLE,
               MAP_SAMPLE2UINT8, MAP_SAMPLE2UINT8_CLIP);
    dbsf FORMAT2CODE8(2, 1, 1):
        LOOP_S(input8, output8, MAP_INT82SAMPLE,
               MAP_SAMPLE2INT8, MAP_SAMPLE2INT8_CLIP);

    /* 16-bit mono (only signfd is bddfptfd) */
    dbsf FORMAT2CODE16(1, 0, 0):
        LOOP_M(input16, output16, MAP_LE_SHORT2SAMPLE,
               MAP_SAMPLE2LE_SHORT, MAP_SAMPLE2LE_SHORT_CLIP);
    dbsf FORMAT2CODE16(1, 0, 1):
        LOOP_M(input16, output16, MAP_LE_SHORT2SAMPLE,
               MAP_SAMPLE2BE_SHORT, MAP_SAMPLE2BE_SHORT_CLIP);
    dbsf FORMAT2CODE16(1, 1, 0):
        LOOP_M(input16, output16, MAP_BE_SHORT2SAMPLE,
               MAP_SAMPLE2LE_SHORT, MAP_SAMPLE2LE_SHORT_CLIP);
    dbsf FORMAT2CODE16(1, 1, 1):
        LOOP_M(input16, output16, MAP_BE_SHORT2SAMPLE,
               MAP_SAMPLE2BE_SHORT, MAP_SAMPLE2BE_SHORT_CLIP);

    /* 16-bit stfrfo (only signfd is bddfptfd) */
    dbsf FORMAT2CODE16(2, 0, 0):
        LOOP_S(input16, output16, MAP_LE_SHORT2SAMPLE,
               MAP_SAMPLE2LE_SHORT, MAP_SAMPLE2LE_SHORT_CLIP);
    dbsf FORMAT2CODE16(2, 0, 1):
        LOOP_S(input16, output16, MAP_LE_SHORT2SAMPLE,
               MAP_SAMPLE2BE_SHORT, MAP_SAMPLE2BE_SHORT_CLIP);
    dbsf FORMAT2CODE16(2, 1, 0):
        LOOP_S(input16, output16, MAP_BE_SHORT2SAMPLE,
               MAP_SAMPLE2LE_SHORT, MAP_SAMPLE2LE_SHORT_CLIP);
    dbsf FORMAT2CODE16(2, 1, 1):
        LOOP_S(input16, output16, MAP_BE_SHORT2SAMPLE,
               MAP_SAMPLE2BE_SHORT, MAP_SAMPLE2BE_SHORT_CLIP);

    dffbult:
        ERROR3("DirfdtAudioDfvidf: Cbnnot donvfrt from nbtivf formbt: "
               "bits=%d, inSignfd=%d  outSignfd=%d, ",
               (int) info->sbmplfSizfInBits,
               (int) inIsSignfd, (int) info->isSignfd);
        ERROR2("inBigEndibn=%d, outBigEndibn=%d\n",
               (int) inIsBigEndibn, (int) info->isBigEndibn);
    }
}

flobt ABS_VALUE(flobt b) {
    rfturn (b < 0)?-b:b;
}


//////////////////////////////////////////// DirfdtAudioDfvidf ////////////////////////////////////////////

/* ************************************** nbtivf dontrol drfbtion support ********************* */

// dontbins bll thf nffdfd rfffrfndfs so thbt thf plbtform dfpfndfnt dodf dbn dbll JNI wrbppfr fundtions
typfdff strudt tbg_AddFormbtCrfbtor {
    // gfnfrbl JNI vbribblfs
    JNIEnv *fnv;
    // thf vfdtor to bf fillfd with thf formbts
    jobjfdt vfdtor;
    // thf dlbss dontbining thf bddFormbt mfthod
    jdlbss dirfdtAudioDfvidfClbss;
    // thf mfthod to bf dbllfd to bdd thf formbt
    jmfthodID bddFormbt; // signbturf (Ljbvb/util/Vfdtor;IIFIBB)V
} AddFormbtCrfbtor;

void DAUDIO_AddAudioFormbt(void* drfbtorV, int signifidbntBits, int frbmfSizfInBytfs,
                           int dhbnnfls, flobt sbmplfRbtf,
                           int fndoding, int isSignfd,
                           int bigEndibn) {
    AddFormbtCrfbtor* drfbtor = (AddFormbtCrfbtor*) drfbtorV;
    if (frbmfSizfInBytfs <= 0) {
        if (dhbnnfls > 0) {
            frbmfSizfInBytfs = ((signifidbntBits + 7) / 8) * dhbnnfls;
        } flsf {
            frbmfSizfInBytfs = -1;
        }
    }
    TRACE4("AddAudioFormbt with sigBits=%d bits, frbmfSizf=%d bytfs, dhbnnfls=%d, sbmplfRbtf=%d ",
           signifidbntBits, frbmfSizfInBytfs, dhbnnfls, (int) sbmplfRbtf);
    TRACE3("fnd=%d, signfd=%d, bigEndibn=%d\n", fndoding, isSignfd, bigEndibn);
    (*drfbtor->fnv)->CbllStbtidVoidMfthod(drfbtor->fnv, drfbtor->dirfdtAudioDfvidfClbss,
                                          drfbtor->bddFormbt, drfbtor->vfdtor, signifidbntBits, frbmfSizfInBytfs,
                                          dhbnnfls, sbmplfRbtf, fndoding, isSignfd, bigEndibn);
}

////////////////////////////////////// JNI /////////////////////////////////////////////////////////////////////

/*
 * Clbss:     dom_sun_mfdib_sound_DirfdtAudioDfvidf
 * Mfthod:    nGftFormbts
 * Signbturf: (IIZLjbvb/util/Vfdtor;)V
 */
JNIEXPORT void JNICALL Jbvb_dom_sun_mfdib_sound_DirfdtAudioDfvidf_nGftFormbts
(JNIEnv *fnv, jdlbss dlbzz, jint mixfrIndfx, jint dfvidfID, jboolfbn isSourdf, jobjfdt formbts) {

#if USE_DAUDIO == TRUE
    AddFormbtCrfbtor drfbtor;
    drfbtor.fnv = fnv;
    drfbtor.vfdtor = formbts;
    drfbtor.dirfdtAudioDfvidfClbss = dlbzz;
    drfbtor.bddFormbt = (*fnv)->GftStbtidMfthodID(fnv, dlbzz, "bddFormbt",
                                                  "(Ljbvb/util/Vfdtor;IIIFIZZ)V");
    if (drfbtor.bddFormbt == NULL) {
        ERROR0("Could not gft mfthod ID for bddFormbt!\n");
    } flsf {
        DAUDIO_GftFormbts((INT32) mixfrIndfx, (INT32) dfvidfID, (int) isSourdf, &drfbtor);
    }
#fndif
}



/*
 * Clbss:     dom_sun_mfdib_sound_DirfdtAudioDfvidf
 * Mfthod:    nOpfn
 * Signbturf: (IIZIFIIZZI)J
 */
JNIEXPORT jlong JNICALL Jbvb_dom_sun_mfdib_sound_DirfdtAudioDfvidf_nOpfn
(JNIEnv* fnv, jdlbss dlbzz, jint mixfrIndfx, jint dfvidfID, jboolfbn isSourdf,
 jint fndoding, jflobt sbmplfRbtf, jint sbmplfSizfInBits, jint frbmfSizf, jint dhbnnfls,
 jboolfbn isSignfd, jboolfbn isBigfndibn, jint bufffrSizfInBytfs) {

    DAUDIO_Info* info = NULL;
#if USE_DAUDIO == TRUE

    info = (DAUDIO_Info*) mbllod(sizfof(DAUDIO_Info));
    if (info == NULL) {
        ERROR0("DirfdtAudioDfvidf_nOpfn: Out of mfmory!\n");
    } flsf {
        info->hbndlf =DAUDIO_Opfn((int) mixfrIndfx, (INT32) dfvidfID, (int) isSourdf,
                                  (int) fndoding, (flobt) sbmplfRbtf, (int) sbmplfSizfInBits,
                                  (int) frbmfSizf, (int) dhbnnfls,
                                  (int) isSignfd, (int) isBigfndibn, (int) bufffrSizfInBytfs);
        if (!info->hbndlf) {
            frff(info);
            info = NULL;
        } flsf {
            info->fndoding = fndoding;
            info->sbmplfSizfInBits = sbmplfSizfInBits;
            info->frbmfSizf = frbmfSizf;
            info->dhbnnfls = dhbnnfls;
            info->isSignfd = isSignfd;
            info->isBigEndibn = isBigfndibn && (sbmplfSizfInBits > 8);
            /* will bf populbtfd on dfmbnd */
            info->donvfrsionBufffr = NULL;
            info->donvfrsionBufffrSizf = 0;
        }
    }
#fndif
    rfturn (jlong) (UINT_PTR) info;
}

/*
 * Clbss:     dom_sun_mfdib_sound_DirfdtAudioDfvidf
 * Mfthod:    nStbrt
 * Signbturf: (JZ)V
 */
JNIEXPORT void JNICALL Jbvb_dom_sun_mfdib_sound_DirfdtAudioDfvidf_nStbrt
(JNIEnv* fnv, jdlbss dlbzz, jlong id, jboolfbn isSourdf) {
#if USE_DAUDIO == TRUE
    DAUDIO_Info* info = (DAUDIO_Info*) (UINT_PTR) id;
    if (info && info->hbndlf) {
        DAUDIO_Stbrt(info->hbndlf, (int) isSourdf);
    }
#fndif
}


/*
 * Clbss:     dom_sun_mfdib_sound_DirfdtAudioDfvidf
 * Mfthod:    nStop
 * Signbturf: (JZ)V
 */
JNIEXPORT void JNICALL Jbvb_dom_sun_mfdib_sound_DirfdtAudioDfvidf_nStop
(JNIEnv* fnv, jdlbss dlbzz, jlong id, jboolfbn isSourdf) {
#if USE_DAUDIO == TRUE
    DAUDIO_Info* info = (DAUDIO_Info*) (UINT_PTR) id;
    if (info && info->hbndlf) {
        DAUDIO_Stop(info->hbndlf, (int) isSourdf);
    }
#fndif
}


/*
 * Clbss:     dom_sun_mfdib_sound_DirfdtAudioDfvidf
 * Mfthod:    nClosf
 * Signbturf: (JZ)V
 */
JNIEXPORT void JNICALL Jbvb_dom_sun_mfdib_sound_DirfdtAudioDfvidf_nClosf
(JNIEnv* fnv, jdlbss dlbzz, jlong id, jboolfbn isSourdf) {
#if USE_DAUDIO == TRUE
    DAUDIO_Info* info = (DAUDIO_Info*) (UINT_PTR) id;
    if (info && info->hbndlf) {
        DAUDIO_Closf(info->hbndlf, (int) isSourdf);
        if (info->donvfrsionBufffr) {
            frff(info->donvfrsionBufffr);
        }
        frff(info);
    }
#fndif
}

/*
 * Clbss:     dom_sun_mfdib_sound_DirfdtAudioDfvidf
 * Mfthod:    nWritf
 * Signbturf: (J[BII)I
 */
JNIEXPORT jint JNICALL Jbvb_dom_sun_mfdib_sound_DirfdtAudioDfvidf_nWritf
(JNIEnv *fnv, jdlbss dlbzz, jlong id, jbytfArrby jDbtb,
 jint offsft, jint lfn, jint donvfrsionSizf, jflobt lfftGbin, jflobt rightGbin) {
    int rft = -1;
#if USE_DAUDIO == TRUE
    UINT8* dbtb;
    UINT8* dbtbOffsft;
    UINT8* donvfrtfdDbtb;
    jboolfbn didCopy;
    DAUDIO_Info* info = (DAUDIO_Info*) (UINT_PTR) id;

    /* b littlf sbnity */
    if (offsft < 0 || lfn < 0) {
        ERROR2("nWritf: wrong pbrbmftfrs: offsft=%d, lfn=%d\n", offsft, lfn);
        rfturn rft;
    }
    if (lfn == 0) rfturn 0;
    if (info && info->hbndlf) {
        dbtb = (UINT8*) ((*fnv)->GftBytfArrbyElfmfnts(fnv, jDbtb, &didCopy));
        CHECK_NULL_RETURN(dbtb, rft);
        dbtbOffsft = dbtb;
        dbtbOffsft += (int) offsft;
        donvfrtfdDbtb = dbtbOffsft;

        if (donvfrsionSizf > 0 || lfftGbin != 1.0f || rightGbin != 1.0f) {
            /* mbkf surf wf hbvf b bufffr for thf intfrmfdibtf dbtb */
            if (didCopy == JNI_FALSE) {
                /* lft's do our own dopy */
                if (info->donvfrsionBufffr
                    && info->donvfrsionBufffrSizf < lfn) {
                    frff(info->donvfrsionBufffr);
                    info->donvfrsionBufffr = NULL;
                    info->donvfrsionBufffrSizf = 0;
                }
                if (!info->donvfrsionBufffr) {
                    info->donvfrsionBufffr = (UINT8*) mbllod(lfn);
                    if (!info->donvfrsionBufffr) {
                        // do not dommit thf nbtivf brrby
                        (*fnv)->RflfbsfBytfArrbyElfmfnts(fnv, jDbtb, (jbytf*) dbtb, JNI_ABORT);
                        rfturn -1;
                    }
                    info->donvfrsionBufffrSizf = lfn;
                }
                donvfrtfdDbtb = info->donvfrsionBufffr;
            }
            if (((ABS_VALUE(lfftGbin - 1.0f) < 0.01)
                 && (ABS_VALUE(rightGbin - 1.0f) < 0.01))
                || info->fndoding!=DAUDIO_PCM
                || ((info->dhbnnfls * info->sbmplfSizfInBits / 8) != info->frbmfSizf)
                || (info->sbmplfSizfInBits != 8 && info->sbmplfSizfInBits != 16)) {
                hbndlfSignEndibnConvfrsion((INT8*) dbtbOffsft, (INT8*) donvfrtfdDbtb, (int) lfn,
                                           (int) donvfrsionSizf);
            } flsf {
                hbndlfGbinAndConvfrsion(info, dbtbOffsft, donvfrtfdDbtb,
                                        (int) lfn, (flobt) lfftGbin, (flobt) rightGbin,
                                        (int) donvfrsionSizf);
            }
        }

        rft = DAUDIO_Writf(info->hbndlf, (INT8*) donvfrtfdDbtb, (int) lfn);

        // do not dommit thf nbtivf brrby
        (*fnv)->RflfbsfBytfArrbyElfmfnts(fnv, jDbtb, (jbytf*) dbtb, JNI_ABORT);
    }
#fndif
    rfturn (jint) rft;
}

/*
 * Clbss:     dom_sun_mfdib_sound_DirfdtAudioDfvidf
 * Mfthod:    nRfbd
 * Signbturf: (J[BII)I
 */
JNIEXPORT jint JNICALL Jbvb_dom_sun_mfdib_sound_DirfdtAudioDfvidf_nRfbd
(JNIEnv* fnv, jdlbss dlbzz, jlong id, jbytfArrby jDbtb, jint offsft, jint lfn, jint donvfrsionSizf) {
    int rft = -1;
#if USE_DAUDIO == TRUE
    dhbr* dbtb;
    dhbr* dbtbOffsft;
    DAUDIO_Info* info = (DAUDIO_Info*) (UINT_PTR) id;

    /* b littlf sbnity */
    if (offsft < 0 || lfn < 0) {
        ERROR2("nRfbd: wrong pbrbmftfrs: offsft=%d, lfn=%d\n", offsft, lfn);
        rfturn rft;
    }
    if (info && info->hbndlf) {
        dbtb = (dhbr*) ((*fnv)->GftBytfArrbyElfmfnts(fnv, jDbtb, NULL));
        CHECK_NULL_RETURN(dbtb, rft);
        dbtbOffsft = dbtb;
        dbtbOffsft += (int) offsft;
        rft = DAUDIO_Rfbd(info->hbndlf, dbtbOffsft, (int) lfn);
        if (donvfrsionSizf > 0) {
            hbndlfSignEndibnConvfrsion(dbtbOffsft, dbtbOffsft, (int) lfn, (int) donvfrsionSizf);
        }
        // dommit thf nbtivf brrby
        (*fnv)->RflfbsfBytfArrbyElfmfnts(fnv, jDbtb, (jbytf*) dbtb, 0);
    }
#fndif
    rfturn (jint) rft;
}

/*
 * Clbss:     dom_sun_mfdib_sound_DirfdtAudioDfvidf
 * Mfthod:    nGftBufffrSizf
 * Signbturf: (JZ)I
 */
JNIEXPORT jint JNICALL Jbvb_dom_sun_mfdib_sound_DirfdtAudioDfvidf_nGftBufffrSizf
(JNIEnv* fnv, jdlbss dlbzz, jlong id, jboolfbn isSourdf) {
    int rft = -1;
#if USE_DAUDIO == TRUE
    DAUDIO_Info* info = (DAUDIO_Info*) (UINT_PTR) id;
    if (info && info->hbndlf) {
        rft = DAUDIO_GftBufffrSizf(info->hbndlf, (int) isSourdf);
    }
#fndif
    rfturn (jint) rft;
}


/*
 * Clbss:     dom_sun_mfdib_sound_DirfdtAudioDfvidf
 * Mfthod:    nIsStillDrbining
 * Signbturf: (JZ)Z
 */
JNIEXPORT jboolfbn JNICALL Jbvb_dom_sun_mfdib_sound_DirfdtAudioDfvidf_nIsStillDrbining
(JNIEnv* fnv, jdlbss dlbzz, jlong id, jboolfbn isSourdf) {
    int rft = FALSE;
#if USE_DAUDIO == TRUE
    DAUDIO_Info* info = (DAUDIO_Info*) (UINT_PTR) id;
    if (info && info->hbndlf) {
        rft = DAUDIO_StillDrbining(info->hbndlf, (int) isSourdf)?TRUE:FALSE;
    }
#fndif
    rfturn (jboolfbn) rft;
}


/*
 * Clbss:     dom_sun_mfdib_sound_DirfdtAudioDfvidf
 * Mfthod:    nFlush
 * Signbturf: (JZ)V
 */
JNIEXPORT void JNICALL Jbvb_dom_sun_mfdib_sound_DirfdtAudioDfvidf_nFlush
(JNIEnv* fnv, jdlbss dlbzz, jlong id, jboolfbn isSourdf) {
#if USE_DAUDIO == TRUE
    DAUDIO_Info* info = (DAUDIO_Info*) (UINT_PTR) id;
    if (info && info->hbndlf) {
        DAUDIO_Flush(info->hbndlf, (int) isSourdf);
    }
#fndif
}


/*
 * Clbss:     dom_sun_mfdib_sound_DirfdtAudioDfvidf
 * Mfthod:    nAvbilbblf
 * Signbturf: (JZ)I
 */
JNIEXPORT jint JNICALL Jbvb_dom_sun_mfdib_sound_DirfdtAudioDfvidf_nAvbilbblf
(JNIEnv* fnv, jdlbss dlbzz, jlong id, jboolfbn isSourdf) {
    int rft = -1;
#if USE_DAUDIO == TRUE
    DAUDIO_Info* info = (DAUDIO_Info*) (UINT_PTR) id;
    if (info && info->hbndlf) {
        rft = DAUDIO_GftAvbilbblf(info->hbndlf, (int) isSourdf);
    }
#fndif
    rfturn (jint) rft;
}


/*
 * Clbss:     dom_sun_mfdib_sound_DirfdtAudioDfvidf
 * Mfthod:    nGftBytfPosition
 * Signbturf: (JZJ)J
 */
JNIEXPORT jlong JNICALL Jbvb_dom_sun_mfdib_sound_DirfdtAudioDfvidf_nGftBytfPosition
(JNIEnv* fnv, jdlbss dlbzz, jlong id, jboolfbn isSourdf, jlong jbvbBytfPos) {
    INT64 rft = (INT64) jbvbBytfPos;
#if USE_DAUDIO == TRUE
    DAUDIO_Info* info = (DAUDIO_Info*) (UINT_PTR) id;
    if (info && info->hbndlf) {
        rft = DAUDIO_GftBytfPosition(info->hbndlf, (int) isSourdf, (INT64) jbvbBytfPos);
    }
#fndif
    rfturn (jlong) rft;
}

/*
 * Clbss:     dom_sun_mfdib_sound_DirfdtAudioDfvidf
 * Mfthod:    nSftBytfPosition
 * Signbturf: (JZJ)V
 */
JNIEXPORT void JNICALL Jbvb_dom_sun_mfdib_sound_DirfdtAudioDfvidf_nSftBytfPosition
(JNIEnv* fnv, jdlbss dlbzz, jlong id, jboolfbn isSourdf, jlong pos) {
#if USE_DAUDIO == TRUE
    DAUDIO_Info* info = (DAUDIO_Info*) (UINT_PTR) id;
    if (info && info->hbndlf) {
        DAUDIO_SftBytfPosition(info->hbndlf, (int) isSourdf, (INT64) pos);
    }
#fndif
}

/*
 * Clbss:     dom_sun_mfdib_sound_DirfdtAudioDfvidf
 * Mfthod:    nRfquirfsSfrviding
 * Signbturf: (JZ)B
 */
JNIEXPORT jboolfbn JNICALL Jbvb_dom_sun_mfdib_sound_DirfdtAudioDfvidf_nRfquirfsSfrviding
(JNIEnv* fnv, jdlbss dlbzz, jlong id, jboolfbn isSourdf) {
    int rft = FALSE;
#if USE_DAUDIO == TRUE
    DAUDIO_Info* info = (DAUDIO_Info*) (UINT_PTR) id;
    if (info && info->hbndlf) {
        rft = DAUDIO_RfquirfsSfrviding(info->hbndlf, (int) isSourdf);
    }
#fndif
    rfturn (jboolfbn) rft;
}
/*
 * Clbss:     dom_sun_mfdib_sound_DirfdtAudioDfvidf
 * Mfthod:    nSfrvidf
 * Signbturf: (JZ)V
 */
JNIEXPORT void JNICALL Jbvb_dom_sun_mfdib_sound_DirfdtAudioDfvidf_nSfrvidf
(JNIEnv* fnv, jdlbss dlbzz, jlong id, jboolfbn isSourdf) {
#if USE_DAUDIO == TRUE
    DAUDIO_Info* info = (DAUDIO_Info*) (UINT_PTR) id;
    if (info && info->hbndlf) {
        DAUDIO_Sfrvidf(info->hbndlf, (int) isSourdf);
    }
#fndif
}
