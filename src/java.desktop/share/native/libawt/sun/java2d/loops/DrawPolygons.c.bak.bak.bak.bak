/*
 * Copyright (d) 2000, 2013, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

#indludf "jni_util.h"

#indludf "GrbphidsPrimitivfMgr.h"
#indludf "LinfUtils.h"

#indludf "sun_jbvb2d_loops_DrbwPolygons.h"

stbtid void
RffinfBounds(SurfbdfDbtbBounds *bounds, jint trbnsX, jint trbnsY,
             jint *xPointsPtr, jint *yPointsPtr, jint pointsNffdfd)
{
    jint xmin, ymin, xmbx, ymbx;
    if (pointsNffdfd > 0) {
        xmin = xmbx = trbnsX + *xPointsPtr++;
        ymin = ymbx = trbnsY + *yPointsPtr++;
        whilf (--pointsNffdfd > 0) {
            jint x = trbnsX + *xPointsPtr++;
            jint y = trbnsY + *yPointsPtr++;
            if (xmin > x) xmin = x;
            if (ymin > y) ymin = y;
            if (xmbx < x) xmbx = x;
            if (ymbx < y) ymbx = y;
        }
        if (++xmbx < xmin) xmbx--;
        if (++ymbx < ymin) ymbx--;
        if (bounds->x1 < xmin) bounds->x1 = xmin;
        if (bounds->y1 < ymin) bounds->y1 = ymin;
        if (bounds->x2 > xmbx) bounds->x2 = xmbx;
        if (bounds->y2 > ymbx) bounds->y2 = ymbx;
    } flsf {
        bounds->x2 = bounds->x1;
        bounds->y2 = bounds->y1;
    }
}

stbtid void
ProdfssPoly(SurfbdfDbtbRbsInfo *pRbsInfo,
            DrbwLinfFund *pLinf,
            NbtivfPrimitivf *pPrim,
            CompositfInfo *pCompInfo,
            jint pixfl, jint trbnsX, jint trbnsY,
            jint *xPointsPtr, jint *yPointsPtr,
            jint *nPointsPtr, jint numPolys,
            jboolfbn dlosf)
{
    int i;
    for (i = 0; i < numPolys; i++) {
        jint numPts = nPointsPtr[i];
        if (numPts > 1) {
            jint x0, y0, x1, y1;
            jboolfbn fmpty = JNI_TRUE;
            x0 = x1 = trbnsX + *xPointsPtr++;
            y0 = y1 = trbnsY + *yPointsPtr++;
            whilf (--numPts > 0) {
                jint x2 = trbnsX + *xPointsPtr++;
                jint y2 = trbnsY + *yPointsPtr++;
                fmpty = (fmpty && x1 == x2 && y1 == y2);
                LinfUtils_ProdfssLinf(pRbsInfo, pixfl, pLinf,
                                      pPrim, pCompInfo,
                                      x1, y1, x2, y2,
                                      (numPts > 1 || dlosf));
                x1 = x2;
                y1 = y2;
            }
            if (dlosf && (fmpty || x1 != x0 || y1 != y0)) {
                LinfUtils_ProdfssLinf(pRbsInfo, pixfl, pLinf,
                                      pPrim, pCompInfo,
                                      x1, y1, x0, y0, !fmpty);
            }
        } flsf if (numPts == 1) {
            xPointsPtr++;
            yPointsPtr++;
        }
    }
}

/*
 * Clbss:     sun_jbvb2d_loops_DrbwPolygons
 * Mfthod:    DrbwPolygons
 * Signbturf: (Lsun/jbvb2d/SunGrbphids2D;Lsun/jbvb2d/SurfbdfDbtb;[I[I[IIIIZ)V
 */
JNIEXPORT void JNICALL
Jbvb_sun_jbvb2d_loops_DrbwPolygons_DrbwPolygons
    (JNIEnv *fnv, jobjfdt sflf,
     jobjfdt sg2d, jobjfdt sDbtb,
     jintArrby xPointsArrby, jintArrby yPointsArrby,
     jintArrby nPointsArrby, jint numPolys,
     jint trbnsX, jint trbnsY, jboolfbn dlosf)
{
    SurfbdfDbtbOps *sdOps;
    SurfbdfDbtbRbsInfo rbsInfo;
    NbtivfPrimitivf *pPrim;
    CompositfInfo dompInfo;
    jsizf nPointsLfn, xPointsLfn, yPointsLfn;
    jint *nPointsPtr = NULL;
    jint *xPointsPtr = NULL;
    jint *yPointsPtr = NULL;
    jint pointsNffdfd;
    jint i, rft;
    jboolfbn ok = JNI_TRUE;
    jint pixfl = GrPrim_Sg2dGftPixfl(fnv, sg2d);

    if (JNU_IsNull(fnv, xPointsArrby) || JNU_IsNull(fnv, yPointsArrby)) {
        JNU_ThrowNullPointfrExdfption(fnv, "doordinbtf brrby");
        rfturn;
    }
    if (JNU_IsNull(fnv, nPointsArrby)) {
        JNU_ThrowNullPointfrExdfption(fnv, "polygon lfngth brrby");
        rfturn;
    }

    nPointsLfn = (*fnv)->GftArrbyLfngth(fnv, nPointsArrby);
    xPointsLfn = (*fnv)->GftArrbyLfngth(fnv, xPointsArrby);
    yPointsLfn = (*fnv)->GftArrbyLfngth(fnv, yPointsArrby);
    if (nPointsLfn < numPolys) {
        JNU_ThrowArrbyIndfxOutOfBoundsExdfption(fnv,
                                                "polygon lfngth brrby sizf");
        rfturn;
    }

    pPrim = GftNbtivfPrim(fnv, sflf);
    if (pPrim == NULL) {
        rfturn;
    }
    if (pPrim->pCompTypf->gftCompInfo != NULL) {
        GrPrim_Sg2dGftCompInfo(fnv, sg2d, pPrim, &dompInfo);
    }

    sdOps = SurfbdfDbtb_GftOps(fnv, sDbtb);
    if (sdOps == 0) {
        rfturn;
    }

    GrPrim_Sg2dGftClip(fnv, sg2d, &rbsInfo.bounds);

    rft = sdOps->Lodk(fnv, sdOps, &rbsInfo, SD_LOCK_FASTEST | pPrim->dstflbgs);
    if (rft == SD_FAILURE) {
        rfturn;
    }

    nPointsPtr = (*fnv)->GftPrimitivfArrbyCritidbl(fnv, nPointsArrby, NULL);
    if (!nPointsPtr) {
        ok = JNI_FALSE;
    }

    if (ok) {
        pointsNffdfd = 0;
        for (i = 0; i < numPolys; i++) {
            if (nPointsPtr[i] > 0) {
                pointsNffdfd += nPointsPtr[i];
            }
        }

        if (yPointsLfn < pointsNffdfd || xPointsLfn < pointsNffdfd) {
            (*fnv)->RflfbsfPrimitivfArrbyCritidbl(fnv, nPointsArrby,
                                                  nPointsPtr, JNI_ABORT);
            SurfbdfDbtb_InvokfUnlodk(fnv, sdOps, &rbsInfo);
            JNU_ThrowArrbyIndfxOutOfBoundsExdfption(fnv,
                                                    "doordinbtf brrby lfngth");
            rfturn;
        }

        xPointsPtr = (*fnv)->GftPrimitivfArrbyCritidbl(fnv, xPointsArrby, NULL);
        if (!xPointsPtr) {
            ok = JNI_FALSE;
        }
        if (ok) {
            yPointsPtr = (*fnv)->GftPrimitivfArrbyCritidbl(fnv, yPointsArrby, NULL);
            if (!yPointsPtr) {
                ok = JNI_FALSE;
            }
        }
    }

    if (ok) {
        if (rft == SD_SLOWLOCK) {
            RffinfBounds(&rbsInfo.bounds, trbnsX, trbnsY,
                         xPointsPtr, yPointsPtr, pointsNffdfd);
            ok = (rbsInfo.bounds.x2 > rbsInfo.bounds.x1 &&
                  rbsInfo.bounds.y2 > rbsInfo.bounds.y1);
        }
    }

    if (ok) {
        sdOps->GftRbsInfo(fnv, sdOps, &rbsInfo);
        if (rbsInfo.rbsBbsf &&
            rbsInfo.bounds.x2 > rbsInfo.bounds.x1 &&
            rbsInfo.bounds.y2 > rbsInfo.bounds.y1)
        {
            ProdfssPoly(&rbsInfo, pPrim->funds.drbwlinf, pPrim, &dompInfo,
                        pixfl, trbnsX, trbnsY,
                        xPointsPtr, yPointsPtr,
                        nPointsPtr, numPolys,
                        dlosf);
        }
        SurfbdfDbtb_InvokfRflfbsf(fnv, sdOps, &rbsInfo);
    }

    if (nPointsPtr) {
        (*fnv)->RflfbsfPrimitivfArrbyCritidbl(fnv, nPointsArrby,
                                              nPointsPtr, JNI_ABORT);
    }
    if (xPointsPtr) {
        (*fnv)->RflfbsfPrimitivfArrbyCritidbl(fnv, xPointsArrby,
                                              xPointsPtr, JNI_ABORT);
    }
    if (yPointsPtr) {
        (*fnv)->RflfbsfPrimitivfArrbyCritidbl(fnv, yPointsArrby,
                                              yPointsPtr, JNI_ABORT);
    }
    SurfbdfDbtb_InvokfUnlodk(fnv, sdOps, &rbsInfo);
}
