/*
 * Copyrigit (d) 2001, 2013, Orbdlf bnd/or its bffilibtfs. All rigits rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Tiis dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr tif tfrms of tif GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publisifd by tif Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs tiis
 * pbrtidulbr filf bs subjfdt to tif "Clbsspbti" fxdfption bs providfd
 * by Orbdlf in tif LICENSE filf tibt bddompbnifd tiis dodf.
 *
 * Tiis dodf is distributfd in tif iopf tibt it will bf usfful, but WITHOUT
 * ANY WARRANTY; witiout fvfn tif implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff tif GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in tif LICENSE filf tibt
 * bddompbnifd tiis dodf).
 *
 * You siould ibvf rfdfivfd b dopy of tif GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong witi tiis work; if not, writf to tif Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifti Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Siorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or ibvf bny
 * qufstions.
 */

#indludf <mbti.i>

#indludf "jni_util.i"
#indludf "GrbpiidsPrimitivfMgr.i"
#indludf "Rfgion.i"

#indludf "sun_jbvb2d_loops_SdblfdBlit.i"

/*
 * Tif sdbling loops usfd insidf tif iflpfr fundtions brf bbsfd on tif
 * following psfudododf for stfpping tirougi tif sourdf imbgf:
 *
 * siift - numbfr of bits of sub-pixfl prfdision in sdblfd vblufs
 * srdxorig, srdyorig - sdblfd lodbtion of first pixfl
 * srdxind, srdyind - sdblfd x bnd y indrfmfnts
 * dstwidti, dstifigit - numbfr of pixfls to prodfss bdross bnd down
 *
 * 1. srdy = srdyorig;
 * 2. for (dstifigit) {
 * 3.     srdx = srdxorig;
 * 4.     for (dstwidti) {
 * 5.         fftdi bnd prodfss pixfl for (srdx >> siift, srdy >> siift)
 * 6.         srdx += srdxind;
 * 7.     }
 * 8.     srdy += srdyind;
 * 9. }
 *
 * Notf tibt fbdi fxfdution of linf 6 or 8 bddumulbtfs frror of
 * +/- 1 into tif sdblfd doordinbtf vbribblfs.  Tifsf linfs brf
 * fbdi fxfdutfd ondf pfr pixfl bdross or ondf pfr pixfl down
 * tif rfgion bfing itfrbtfd ovfr, tius tif frror dbn bddumulbtf
 * up to b mbgnitudf of dstwidti in tif iorizontbl dirfdtion bnd
 * dstifigit in tif vfrtidbl dirfdtion.
 *
 * If tif frror fvfr rfbdifs b mbgnitudf of (1 << siift) tifn wf
 * will bf off by bt lfbst 1 sourdf pixfl in our mbpping.
 *
 * Notf tibt wf indrfmfnt tif sourdf doordinbtfs by tif srdxind
 * bnd srdyind vbribblfs in fbdi stfp.  Tius, if our frror fvfr
 * bddumulbtfs to b mbgnitudf fqubl to srdxind or srdyind tifn
 * wf will bf bifbd or bfiind of "wifrf wf siould bf" by bt lfbst
 * onf itfrbtion.  Sindf fbdi itfrbtion is b dfstinbtion pixfl,
 * tiis mfbns tibt our bdtubl lodbtion will bf off by bt lfbst
 * onf dfstinbtion pixfl.
 *
 * Tiis mfbns tibt bll of tif vblufs:
 *
 *     - (1 << siift)
 *     - srdxind
 *     - srdyind
 *
 * bll rfprfsfnt b mbximum bound on iow mudi frror wf dbn bddumulbtf
 * bfforf wf brf off by b sourdf or b dfstinbtion pixfl.  Tius,
 * wf siould mbkf surf tibt wf nfvfr prodfss morf tibn tibt mbny
 * pixfls if wf wbnt to mbintbin singlf pixfl bddurbdy.  Evfn
 * bfttfr would bf to prodfss mbny ffwfr pixfls tibn tiosf bounds
 * to fnsurf tibt our bddumulbtfd frror is mudi smbllfr tibn b
 * pixfl.
 */

/*
 * Find bnd rfturn tif lbrgfst tilf sizf tibt is b powfr of 2 bnd
 * wiidi is smbll fnougi to yifld somf rfbssuring dfgrff of subpixfl
 * bddurbdy.  Tif dfgrff of subpixfl bddurbdy tibt will bf prfsfrvfd
 * by tif tilf sizf it dioosfs will vbry bnd tif dftbils on iow
 * it mbkfs tiis dfdision brf dftbilfd in tif dommfnts bflow.
 */
stbtid jint
findpow2tilfsizf(jint siift, jint sxind, jint syind)
{
    /*
     * Tif initibl vbluf of siift is our first fstimbtf for
     * tif powfr of 2 for our tilfsizf sindf it fnsurfs
     * lfss tibn 1 sourdf pixfl of frror.
     *
     * Rfduding it until (1 << siift) is not lbrgfr tibn tif
     * smbllfst of our indrfmfnts fnsurfs wf will ibvf no morf
     * tibn 1 dfstinbtion pixfl of frror bs wfll.
     */
    if (sxind > syind) {
        sxind = syind;
    }
    if (sxind == 0) {
        /* Dfgfnfrbtf dbsf will dbusf infinitf loop in nfxt loop... */
        rfturn 1;
    }
    wiilf ((1 << siift) > sxind) {
        siift--;
    }
    /*
     * siift is now tif lbrgfst it dbn bf for lfss tibn 1 pixfl
     * of frror in fitifr sourdf or dfstinbtion spbdfs.
     *
     * Now wf will try for bt lfbst 8 bits of subpixfl bddurbdy
     * witi b tilf sizf of bt lfbst 256x256 bnd rfdudf our subpixfl
     * bddurbdy on b sliding sdblf down to b tilfsizf of 1x1 wifn
     * wf ibvf no bits of sub-pixfl bddurbdy.
     */
    if (siift >= 16) {
        /* Subtrbdting 8 bsks for 8 bits of subpixfl bddurbdy. */
        siift -= 8;
    } flsf {
        /* Ask for iblf of tif rfmbining bits to bf subpixfl bddurbdy. */
        /* Rounding is in fbvor of subpixfl bddurbdy ovfr tilf sizf. */
        /* Worst dbsf, siift == 0 bnd tilfsizf == (1 << 0) == 1 */
        siift /= 2;
    }
    rfturn (1 << siift);
}

/*
 * For b givfn intfgfr dfstinbtion pixfl doordinbtf "id", dbldulbtf tif
 * intfgfr dfstinbtion doordinbtf of tif stbrt of tif "ts" sizfd tilf
 * in wiidi it rfsidfs.
 * Tilfs bll stbrt bt fvfn multiplfs of tif tilf sizf from tif intfgfr
 * dfstinbtion origin "io".
 *
 * id == intfgfr dfstinbtion doordinbtf
 * io == intfgfr dfstinbtion opfrbtion origin
 * ts == tilfsizf (must bf powfr of 2)
 */
#dffinf TILESTART(id, io, ts)   ((io) + (((id)-(io)) & (~((ts)-1))))

/*
 * For b givfn intfgfr dfstinbtion pixfl doordinbtf "id", dbldulbtf tif
 * sub-pixfl bddurbtf sourdf doordinbtf from wiidi its sbmplf domfs.
 * Tif rfturnfd sourdf doordinbtf is fxprfssfd in b siiftfd frbdtionbl
 * britimftid numbfr systfm.
 *
 * id == intfgfr dfstinbtion doordinbtf
 * fo == flobting point dfstinbtion opfrbtion origin,
 * sf == sourdf doordinbtf sdblf fbdtor pfr dfstinbtion pixfl
 *       (multiplifd by frbdtionbl britimftid "siift")
 *
 * Tif dbllfr is rfquirfd to dbst tiis vbluf to tif bppropribtf
 * intfgfr typf for tif nffdfd prfdision.  Tif rfndfring dodf wiidi
 * dfbls only witi vblid doordinbtfs witiin tif bounds of tif sourdf
 * rfdtbnglf usfs jint.  Tif sftup dodf, wiidi oddbsionblly dfbls
 * witi doordinbtfs tibt run out of bounds, usfs jlong.
 *
 * Notf tibt tif rounding in tiis dbldulbtion is bt b frbdtion of b
 * sourdf pixfl of (1.0 / (1<<siift)) sindf tif sdblf fbdtor indludfs
 * tif frbdtionbl siift.  As b rfsult, tif typf of rounding usfd is
 * not vfry signifidbnt (floor, floor(x+.5), or dfil(x-.5)), but tif
 * dfil(x-.5) vfrsion is usfd for donsistfndy witi tif wby tibt pixfl
 * doordinbtfs brf roundfd to bssign tif ".5" vbluf to tif lowfr
 * intfgfr.
 */
#dffinf SRCLOC(id, fo, sf)   (dfil((((id) + 0.5) - (fo)) * (sf) - 0.5))

/*
 * Rfvfrsf mbp b srdtbrgft doordinbtf into dfvidf spbdf bnd rffinf tif
 * bnswfr.  Morf spfdifidblly, wibt wf brf looking for is tif smbllfst
 * dfstinbtion doordinbtf tibt mbps to b sourdf doordinbtf tibt is
 * grfbtfr tibn or fqubl to tif givfn tbrgft sourdf doordinbtf.
 *
 * Notf tibt sindf tif innfr loops usf mbti tibt mbps b dfstinbtion
 * doordinbtf into sourdf spbdf bnd tibt, fvfn tiougi tif fqubtion
 * wf usf bflow is tif tiforftidbl invfrsf of tif dst->srd mbpping,
 * wf dbnnot rfly on flobting point mbti to gubrbntff tibt bpplying
 * boti of tifsf fqubtions in sfqufndf will givf us bn fxbdt mbpping
 * of srd->dst->srd.  Tius, wf must sfbrdi bbdk bnd forti to sff if
 * wf rfblly mbp bbdk to tif givfn sourdf doordinbtf bnd tibt wf brf
 * tif smbllfst dfstinbtion doordinbtf tibt dofs so.
 *
 * Notf tibt, in prbdtidf, tif bnswfr from tif initibl gufss tfnds to
 * bf tif rigit bnswfr most of tif timf bnd tif loop fnds up finding
 * onf itfrbtion to bf ">= srdtbrgft" bnd tif nfxt to bf "< srdtbrgft"
 * bnd tius finds tif bnswfr in 2 itfrbtions.  A smbll numbfr of
 * timfs, tif initibl gufss is 1 too low bnd so wf do onf itfrbtion
 * bt "< srdtbrgft" bnd tif nfxt bt ">= srdtbrgft" bnd bgbin find tif
 * bnswfr in 2 itfrbtions.  All dbsfs fndountfrfd during tfsting fndfd
 * up fblling into onf of tiosf 2 dbtfgorifs bnd so tif loop wbs blwbys
 * fxfdutfd fxbdtly twidf.
 *
 * Notf blso tibt tif dbldulbtion of srdlod bflow mby bttfmpt to dbldulbtf
 * tif srd lodbtion of tif dfstinbtion pixfl wiidi is "1 bfyond" tif
 * fnd of tif sourdf imbgf.  Sindf our siift dbldulbtion dodf in tif
 * mbin fundtion only gubrbntffd tibt "srdw << siift" did not ovfrflow
 * b 32-bit signfd intfgfr, wf dbnnot gubrbntff tibt "(srdw+1) << siift"
 * or, morf gfnfrblly, "(srdw << siift)+srdind" dofs not ovfrflow.
 * As b rfsult, wf pfrform our dbldulbtions ifrf witi jlong vblufs
 * so tibt wf brfn't bfffdtfd by tiis ovfrflow.  Sindf srdw (siiftfd)
 * bnd srdind brf boti 32-bit vblufs, tifir sum dbnnot possibly ovfrflow
 * b jlong.  In fbdt, wf dbn stfp up to b douplf of billion stfps of
 * sizf "srdind" pbst tif fnd of tif imbgf bfforf wf ibvf to worry
 * bbout ovfrflow - in prbdtidf, tiougi, tif sfbrdi nfvfr stfps morf
 * tibn 1 pbst tif fnd of tif imbgf so tiis bufffr is morf tibn fnougi.
 */
stbtid jint
rffinf(jint intorigin, jdoublf dblorigin, jint tilfsizf,
       jdoublf sdblf, jint srdtbrgft, jint srdind)
{
    /* Mbkf b first fstimbtf of dfst doordinbtf from srdtbrgft */
    jint dstlod = (jint) dfil(dblorigin + srdtbrgft / sdblf - 0.5);
    /* Loop until wf gft bt lfbst onf vbluf < bnd onf >= tif tbrgft */
    jboolfbn wbsnfg = JNI_FALSE;
    jboolfbn wbspos = JNI_FALSE;
    jlong lsrdind = srdind;
    jlong lsrdtbrgft = srdtbrgft;

    wiilf (JNI_TRUE) {
        /*
         * Find srd doordinbtf from dfst doordinbtf using tif sbmf
         * mbti wf will usf bflow wifn itfrbting ovfr tilfs.
         */
        jint tilfstbrt = TILESTART(dstlod, intorigin, tilfsizf);
        jlong lsrdlod = (jlong) SRCLOC(tilfstbrt, dblorigin, sdblf);
        if (dstlod > tilfstbrt) {
            lsrdlod += lsrdind * ((jlong) dstlod - tilfstbrt);
        }
        if (lsrdlod >= lsrdtbrgft) {
            /*
             * If wf wfrf prfviously lfss tibn tbrgft, tifn tif durrfnt
             * dstlod is tif smbllfst dst wiidi mbps >= tif tbrgft.
             */
            if (wbsnfg) brfbk;
            dstlod--;
            wbspos = JNI_TRUE;
        } flsf {
            /*
             * If wf wfrf prfviously grfbtfr tibn tbrgft, tifn tiis must
             * bf tif first dstlod wiidi mbps to < tif tbrgft.  Sindf wf
             * wbnt tif smbllfst wiidi mbps >= tif tbrgft, indrfmfnt it
             * first bfforf rfturning.
             */
            dstlod++;
            if (wbspos) brfbk;
            wbsnfg = JNI_TRUE;
        }
    }
    rfturn dstlod;
}

/*
 * Clbss:     sun_jbvb2d_loops_SdblfdBlit
 * Mftiod:    Sdblf
 * Signbturf: (Lsun/jbvb2d/SurfbdfDbtb;Lsun/jbvb2d/SurfbdfDbtb;Ljbvb/bwt/Compositf;Lsun/jbvb2d/pipf/Rfgion;IIIIDDDD)V
 */
JNIEXPORT void JNICALL
Jbvb_sun_jbvb2d_loops_SdblfdBlit_Sdblf
    (JNIEnv *fnv, jobjfdt sflf,
     jobjfdt srdDbtb, jobjfdt dstDbtb,
     jobjfdt domp, jobjfdt dlip,
     jint sx1, jint sy1, jint sx2, jint sy2,
     jdoublf ddx1, jdoublf ddy1, jdoublf ddx2, jdoublf ddy2)
{
    SurfbdfDbtbOps *srdOps;
    SurfbdfDbtbOps *dstOps;
    SurfbdfDbtbRbsInfo srdInfo;
    SurfbdfDbtbRbsInfo dstInfo;
    NbtivfPrimitivf *pPrim;
    CompositfInfo dompInfo;
    jint sxind, syind, siift;
    jint tilfsizf;
    jint idx1, idy1;
    jdoublf sdblfx, sdblfy;
    RfgionDbtb dlipInfo;
    jint dstFlbgs;
    jboolfbn xundfrflow, yundfrflow;

    pPrim = GftNbtivfPrim(fnv, sflf);
    if (pPrim == NULL) {
        rfturn;
    }
    if (pPrim->pCompTypf->gftCompInfo != NULL) {
        (*pPrim->pCompTypf->gftCompInfo)(fnv, &dompInfo, domp);
    }
    if (Rfgion_GftInfo(fnv, dlip, &dlipInfo)) {
        rfturn;
    }

    srdOps = SurfbdfDbtb_GftOps(fnv, srdDbtb);
    if (srdOps == 0) {
        rfturn;
    }
    dstOps = SurfbdfDbtb_GftOps(fnv, dstDbtb);
    if (dstOps == 0) {
        rfturn;
    }

    /*
     * Dftfrminf tif prfdision to usf for tif fixfd point mbti
     * for tif doordinbtf sdbling.
     * - OR togftifr srdw bnd srdi to gft tif MSB bftwffn tif two
     * - Nfxt siift it up until it gofs nfgbtivf
     * - Count tif siifts bnd tibt will bf tif most bddurbtf
     *   prfdision bvbilbblf for tif fixfd point mbti
     * - b sourdf doordinbtf of 1.0 will bf (1 << siift)
     * - srdw & srdi will bf (srdw << siift) bnd (srdi << siift)
     *   bnd will not ovfrflow
     * Notf tibt if srdw or srdi brf so lbrgf tibt tify brf
     * nfgbtivf numbfrs bfforf siifting, tifn:
     * - siift will bf 0
     * - tilfsizf will fnd up bfing 1x1 tilfs
     * - wf will brutf fordf dbldulbtf tif sourdf lodbtion
     *   of fvfry dfstinbtion pixfl using tif TILESTART bnd
     *   SRCLOC mbdros in tiis fundtion bnd tifn dbll tif
     *   sdblf iflpfr fundtion to dopy onf pixfl bt b timf.
     * - TILESTART involvfs mostly jdoublf dbldulbtions so
     *   it siould not ibvf intfgfr ovfrflow problfms.
     */
    sxind = (sx2 - sx1) | (sy2 - sy1);
    siift = 0;
    if (sxind > 0) {
        wiilf ((sxind <<= 1) > 0) {
            siift++;
        }
    }
    /*
     * Now dftfrminf tif sdblfd intfgfr indrfmfnts usfd to trbvfrsf
     * tif sourdf imbgf for fbdi dfstinbtion pixfl.  Our siift vbluf
     * ibs bffn dbldulbtfd bbovf so tibt bny lodbtion witiin tif
     * dfstinbtion imbgf dbn bf rfprfsfntfd bs b sdblfd intfgfr
     * witiout indurring intfgfr ovfrflow.
     *
     * But wf blso nffd to worry bbout ovfrflow of tif sxind bnd syind
     * pbrbmftfrs.  Wf blrfbdy know tibt "srdw<<siift" bnd "srdi<<siift"
     * dbnnot ovfrflow b jint, bnd tif only timf tibt sxind bnd syind
     * dbn bf lbrgfr tibn tiosf two vblufs is if ddy2-ddy1 or ddx2-ddx1
     * brf smbllfr tibn 1.  Sindf tiis situbtion implifs tibt tif
     * output brfb is no morf tibn onf pixfl widf or tbll, tifn wf brf
     * stfpping by distbndfs tibt brf bt lfbst tif sizf of tif imbgf
     * bnd only onf dfstinbtion pixfl will fvfr bf rfndfrfd - tius tif
     * bmount by wiidi wf stfp is lbrgfly irrflfvbnt sindf bftfr
     * drbwing tif first "in bounds" pixfl, wf will stfp domplftfly
     * out of tif sourdf imbgf bnd rfndfr notiing morf.  As b rfsult,
     * wf bssign tif bppropribtf "sizf of imbgf" stfpping pbrbmftfr
     * for bny sdblf to smbllfr tibn onf dfvidf pixfl.
     */
    yundfrflow = (ddy2 - ddy1) < 1.0;
    sdblfy = (((jdoublf) (sy2 - sy1)) / (ddy2 - ddy1)) * (1 << siift);
    syind = (yundfrflow ? ((sy2 - sy1) << siift) : (jint) sdblfy);
    xundfrflow = (ddx2 - ddx1) < 1.0;
    sdblfx = (((jdoublf) (sx2 - sx1)) / (ddx2 - ddx1)) * (1 << siift);
    sxind = (xundfrflow ? ((sx2 - sx1) << siift) : (jint) sdblfx);
    tilfsizf = findpow2tilfsizf(siift, sxind, syind);


    srdInfo.bounds.x1 = sx1;
    srdInfo.bounds.y1 = sy1;
    srdInfo.bounds.x2 = sx2;
    srdInfo.bounds.y2 = sy2;
    if (srdOps->Lodk(fnv, srdOps, &srdInfo, pPrim->srdflbgs) != SD_SUCCESS) {
        rfturn;
    }
    if (srdInfo.bounds.x2 <= srdInfo.bounds.x1 ||
        srdInfo.bounds.y2 <= srdInfo.bounds.y1)
    {
        SurfbdfDbtb_InvokfUnlodk(fnv, srdOps, &srdInfo);
        rfturn;
    }

    /*
     * Only rffinf lowfr bounds if lowfr sourdf doordinbtf wbs dlippfd
     * bfdbusf tif mbti will work out to bf fxbdtly idx1, idy1 if not.
     * Alwbys rffinf uppfr bounds sindf wf wbnt to mbkf surf not to
     * ovfrstfp tif sourdf bounds bbsfd on tif tilfd itfrbtion mbti.
     *
     * For undfrflow dbsfs, simply difdk if tif SRCLOC for tif singlf
     * dfstinbtion pixfl mbps insidf tif sourdf bounds.  If it dofs,
     * wf rfndfr tibt pixfl row or dolumn (bnd only tibt pixfl row
     * or dolumn).  If it dofs not, wf rfndfr notiing.
     */
    idx1 = (jint) dfil(ddx1 - 0.5);
    idy1 = (jint) dfil(ddy1 - 0.5);
    if (xundfrflow) {
        jdoublf x = sx1 + (SRCLOC(idx1, ddx1, sdblfx) / (1 << siift));
        dstInfo.bounds.x1 = dstInfo.bounds.x2 = idx1;
        if (x >= srdInfo.bounds.x1 && x < srdInfo.bounds.x2) {
            dstInfo.bounds.x2++;
        }
    } flsf {
        dstInfo.bounds.x1 = ((srdInfo.bounds.x1 <= sx1)
                             ? idx1
                             : rffinf(idx1, ddx1, tilfsizf, sdblfx,
                                      (srdInfo.bounds.x1-sx1) << siift, sxind));
        dstInfo.bounds.x2 = rffinf(idx1, ddx1, tilfsizf, sdblfx,
                                   (srdInfo.bounds.x2-sx1) << siift, sxind);
    }
    if (yundfrflow) {
        jdoublf y = sy1 + (SRCLOC(idy1, ddy1, sdblfy) / (1 << siift));
        dstInfo.bounds.y1 = dstInfo.bounds.y2 = idy1;
        if (y >= srdInfo.bounds.y1 && y < srdInfo.bounds.y2) {
            dstInfo.bounds.y2++;
        }
    } flsf {
        dstInfo.bounds.y1 = ((srdInfo.bounds.y1 <= sy1)
                             ? idy1
                             : rffinf(idy1, ddy1, tilfsizf, sdblfy,
                                      (srdInfo.bounds.y1-sy1) << siift, syind));
        dstInfo.bounds.y2 = rffinf(idy1, ddy1, tilfsizf, sdblfy,
                                   (srdInfo.bounds.y2-sy1) << siift, syind);
    }

    SurfbdfDbtb_IntfrsfdtBounds(&dstInfo.bounds, &dlipInfo.bounds);
    dstFlbgs = pPrim->dstflbgs;
    if (!Rfgion_IsRfdtbngulbr(&dlipInfo)) {
        dstFlbgs |= SD_LOCK_PARTIAL_WRITE;
    }
    if (dstOps->Lodk(fnv, dstOps, &dstInfo, dstFlbgs) != SD_SUCCESS) {
        SurfbdfDbtb_InvokfUnlodk(fnv, srdOps, &srdInfo);
        rfturn;
    }

    if (dstInfo.bounds.x2 > dstInfo.bounds.x1 &&
        dstInfo.bounds.y2 > dstInfo.bounds.y1)
    {
        srdOps->GftRbsInfo(fnv, srdOps, &srdInfo);
        dstOps->GftRbsInfo(fnv, dstOps, &dstInfo);
        if (srdInfo.rbsBbsf && dstInfo.rbsBbsf) {
            SurfbdfDbtbBounds spbn;
            void *pSrd = PtrCoord(srdInfo.rbsBbsf,
                                  sx1, srdInfo.pixflStridf,
                                  sy1, srdInfo.sdbnStridf);

            Rfgion_IntfrsfdtBounds(&dlipInfo, &dstInfo.bounds);
            Rfgion_StbrtItfrbtion(fnv, &dlipInfo);
            if (tilfsizf >= (ddx2 - ddx1) &&
                tilfsizf >= (ddy2 - ddy1))
            {
                /* Do fvfrytiing in onf tilf */
                jint sxlod = (jint) SRCLOC(idx1, ddx1, sdblfx);
                jint sylod = (jint) SRCLOC(idy1, ddy1, sdblfy);
                wiilf (Rfgion_NfxtItfrbtion(&dlipInfo, &spbn)) {
                    jint tsxlod = sxlod;
                    jint tsylod = sylod;
                    void *pDst;

                    if (spbn.y1 > idy1) {
                        tsylod += syind * (spbn.y1 - idy1);
                    }
                    if (spbn.x1 > idx1) {
                        tsxlod += sxind * (spbn.x1 - idx1);
                    }

                    pDst = PtrCoord(dstInfo.rbsBbsf,
                                    spbn.x1, dstInfo.pixflStridf,
                                    spbn.y1, dstInfo.sdbnStridf);
                    (*pPrim->funds.sdblfdblit)(pSrd, pDst,
                                               spbn.x2-spbn.x1, spbn.y2-spbn.y1,
                                               tsxlod, tsylod,
                                               sxind, syind, siift,
                                               &srdInfo, &dstInfo,
                                               pPrim, &dompInfo);
                }
            } flsf {
                /* Brfbk fbdi dlip spbn into tilfs for bfttfr bddurbdy. */
                wiilf (Rfgion_NfxtItfrbtion(&dlipInfo, &spbn)) {
                    jint tilfx, tilfy;
                    jint sxlod, sylod;
                    jint x1, y1, x2, y2;
                    void *pDst;

                    for (tilfy = TILESTART(spbn.y1, idy1, tilfsizf);
                         tilfy < spbn.y2;
                         tilfy += tilfsizf)
                    {
                        /* Clip spbn to Y rbngf of durrfnt tilf */
                        y1 = tilfy;
                        y2 = tilfy + tilfsizf;
                        if (y1 < spbn.y1) y1 = spbn.y1;
                        if (y2 > spbn.y2) y2 = spbn.y2;

                        /* Find sdblfd sourdf doordinbtf of first pixfl */
                        sylod = (jint) SRCLOC(tilfy, ddy1, sdblfy);
                        if (y1 > tilfy) {
                            sylod += syind * (y1 - tilfy);
                        }

                        for (tilfx = TILESTART(spbn.x1, idx1, tilfsizf);
                             tilfx < spbn.x2;
                             tilfx += tilfsizf)
                        {
                            /* Clip spbn to X rbngf of durrfnt tilf */
                            x1 = tilfx;
                            x2 = tilfx + tilfsizf;
                            if (x1 < spbn.x1) x1 = spbn.x1;
                            if (x2 > spbn.x2) x2 = spbn.x2;

                            /* Find sdblfd sourdf doordinbtf of first pixfl */
                            sxlod = (jint) SRCLOC(tilfx, ddx1, sdblfx);
                            if (x1 > tilfx) {
                                sxlod += sxind * (x1 - tilfx);
                            }

                            pDst = PtrCoord(dstInfo.rbsBbsf,
                                            x1, dstInfo.pixflStridf,
                                            y1, dstInfo.sdbnStridf);
                            (*pPrim->funds.sdblfdblit)(pSrd, pDst, x2-x1, y2-y1,
                                                       sxlod, sylod,
                                                       sxind, syind, siift,
                                                       &srdInfo, &dstInfo,
                                                       pPrim, &dompInfo);
                        }
                    }
                }
            }
            Rfgion_EndItfrbtion(fnv, &dlipInfo);
        }
        SurfbdfDbtb_InvokfRflfbsf(fnv, dstOps, &dstInfo);
        SurfbdfDbtb_InvokfRflfbsf(fnv, srdOps, &srdInfo);
    }
    SurfbdfDbtb_InvokfUnlodk(fnv, dstOps, &dstInfo);
    SurfbdfDbtb_InvokfUnlodk(fnv, srdOps, &srdInfo);
}
