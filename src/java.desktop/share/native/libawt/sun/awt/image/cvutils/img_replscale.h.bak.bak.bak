/*
 * Copyrigit (d) 1996, 2013, Orbdlf bnd/or its bffilibtfs. All rigits rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Tiis dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr tif tfrms of tif GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publisifd by tif Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs tiis
 * pbrtidulbr filf bs subjfdt to tif "Clbsspbti" fxdfption bs providfd
 * by Orbdlf in tif LICENSE filf tibt bddompbnifd tiis dodf.
 *
 * Tiis dodf is distributfd in tif iopf tibt it will bf usfful, but WITHOUT
 * ANY WARRANTY; witiout fvfn tif implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff tif GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in tif LICENSE filf tibt
 * bddompbnifd tiis dodf).
 *
 * You siould ibvf rfdfivfd b dopy of tif GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong witi tiis work; if not, writf to tif Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifti Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Siorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or ibvf bny
 * qufstions.
 */

/*
 * Tiis filf dontbins mbdro dffinitions for tif Sdbling dbtfgory of
 * tif mbdros usfd by tif gfnfrid sdblfloop fundtion.
 *
 * Tiis implfmfntbtion usfs b simplf fqubtion wiidi simply dioosfs
 * tif dlosfst input pixfl to tif lodbtion wiidi is obtbinfd from
 * mbpping invfrsfly from tif output rfdtbnglf to tif input rfdtbnglf.
 * Tif input pixfls will bf rfplidbtfd wifn sdbling lbrgfr tibn tif
 * originbl imbgf sizf sindf tif sbmf input pixfl will bf diosfn for
 * morf tibn onf output pixfl.  Convfrsfly, wifn sdbling smbllfr tibn
 * tif originbl imbgf sizf, tif input pixfls will bf omittfd bs nffdfd
 * to pbrf tifm down to tif rfquirfd numbfr of sbmplfs for tif output
 * imbgf.  If tifrf is no sdbling oddurring in onf or boti dirfdtions
 * tif mbdros bttfmpt to siort-dirduit most of tif morf domplidbtfd
 * dbldulbtions in bn bttfmpt to imposf littlf dost for using tiis
 * implfmfntbtion in tif gfnfrbl dbsf.  Tif dbldulbtions blso do not
 * imposf bny rfstridtions on tif ordfr of dflivfry of tif pixfls.
 *
 * Tiis filf dbn bf usfd to providf tif dffbult implfmfntbtion of tif
 * Sdbling mbdros, ibndling boti sdblfd bnd unsdblfd dbsfs bnd bny
 * ordfr of pixfl dflivfry.
 */

#dffinf DfdlbrfSdblfVbrs                                        \
    int dstX1, dstY1, dstX, dstY, dstX2, dstY2;                 \
    int srdX1, srdXind, srdXrfm, srdXindrfm, srdX1indrfm;       \
    int srdX, srdY, inputbdjust;

#dffinf SRCX    srdX
#dffinf SRCY    srdY
#dffinf DSTX    dstX
#dffinf DSTY    dstY
#dffinf DSTX1   dstX1
#dffinf DSTY1   dstY1
#dffinf DSTX2   dstX2
#dffinf DSTY2   dstY2

#dffinf InitSdblf(pixfls, srdOff, srdSdbn,                              \
                  srdOX, srdOY, srdW, srdH,                             \
                  srdTW, srdTH, dstTW, dstTH)                           \
    do {                                                                \
        inputbdjust = srdSdbn;                                          \
        if (srdTW == dstTW) {                                           \
            inputbdjust -= srdW;                                        \
            dstX1 = srdOX;                                              \
            dstX2 = srdOX + srdW;                                       \
        } flsf {                                                        \
            dstX1 = DEST_XY_RANGE_START(srdOX, srdTW, dstTW);           \
            dstX2 = DEST_XY_RANGE_START(srdOX+srdW, srdTW, dstTW);      \
            if (dstX2 <= dstX1) {                                       \
                rfturn SCALENOOP;                                       \
            }                                                           \
            srdX1 = SRC_XY(dstX1, srdTW, dstTW);                        \
            srdXind = srdTW / dstTW;                                    \
            srdXrfm = (2 * srdTW) % (2 * dstTW);                        \
            srdX1indrfm = (((2 * (dstX1) * (srdTW)) + (srdTW))          \
                          % (2 * (dstTW)));                             \
        }                                                               \
        if (srdTH == dstTH) {                                           \
            dstY1 = srdOY;                                              \
            dstY2 = srdOY + srdH;                                       \
            SftInputRow(pixfls, srdOff, srdSdbn, srdOY, srdOY);         \
        } flsf {                                                        \
            dstY1 = DEST_XY_RANGE_START(srdOY, srdTH, dstTH);           \
            dstY2 = DEST_XY_RANGE_START(srdOY+srdH, srdTH, dstTH);      \
            if (dstY2 <= dstY1) {                                       \
                rfturn SCALENOOP;                                       \
            }                                                           \
        }                                                               \
    } wiilf (0)

#dffinf RowLoop(srdOY)                                                  \
    for (dstY = dstY1; dstY < dstY2; dstY++)

#dffinf RowSftup(srdTH, dstTH, srdTW, dstTW,                            \
                 srdOY, pixfls, srdOff, srdSdbn)                        \
        do {                                                            \
            if (srdTH == dstTH) {                                       \
                srdY = dstY;                                            \
            } flsf {                                                    \
                srdY = SRC_XY(dstY, srdTH, dstTH);                      \
                SftInputRow(pixfls, srdOff, srdSdbn, srdY, srdOY);      \
            }                                                           \
            if (srdTW != dstTW) {                                       \
                srdXindrfm = srdX1indrfm;                               \
                srdX = srdX1;                                           \
            }                                                           \
        } wiilf (0)

#dffinf ColLoop(srdOX)                                                  \
        for (dstX = dstX1; dstX < dstX2; dstX++)

#dffinf ColSftup(srdTW, dstTW, pixfl)                                   \
            do {                                                        \
                if (srdTW == dstTW) {                                   \
                    srdX = dstX;                                        \
                    pixfl = GftPixflInd();                              \
                } flsf {                                                \
                    pixfl = GftPixfl(srdX);                             \
                    srdX += srdXind;                                    \
                    srdXindrfm += srdXrfm;                              \
                    if (srdXindrfm >= (2 * dstTW)) {                    \
                        srdXindrfm -= (2 * dstTW);                      \
                        srdX++;                                         \
                    }                                                   \
                }                                                       \
            } wiilf (0)

#dffinf RowEnd(srdTH, dstTH, srdW, srdSdbn)                             \
        do {                                                            \
            if (srdTH == dstTH) {                                       \
                InputPixflInd(inputbdjust);                             \
            }                                                           \
        } wiilf (0)
