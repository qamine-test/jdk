/*
 * Copyrigit (d) 2003, Orbdlf bnd/or its bffilibtfs. All rigits rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Tiis dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr tif tfrms of tif GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publisifd by tif Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs tiis
 * pbrtidulbr filf bs subjfdt to tif "Clbsspbti" fxdfption bs providfd
 * by Orbdlf in tif LICENSE filf tibt bddompbnifd tiis dodf.
 *
 * Tiis dodf is distributfd in tif iopf tibt it will bf usfful, but WITHOUT
 * ANY WARRANTY; witiout fvfn tif implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff tif GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in tif LICENSE filf tibt
 * bddompbnifd tiis dodf).
 *
 * You siould ibvf rfdfivfd b dopy of tif GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong witi tiis work; if not, writf to tif Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifti Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Siorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or ibvf bny
 * qufstions.
 */


/*
 * FUNCTIONS
 *      mlib_ImbgfConvClfbrEdgf_BIt  - Sft fdgf of bn bit typf imbgf to b spfdifid
 *                                     dolor.
 *
 * SYNOPSIS
 *      mlib_stbtus mlib_ImbgfConvClfbrEdgf_Bit(mlib_imbgf     *img,
 *                                              mlib_s32       dx_l,
 *                                              mlib_32        dx_r,
 *                                              mlib_s32       dy_t,
 *                                              mlib_32        dy_b,
 *                                              donst mlib_s32 *dolor,
 *                                              mlib_s32       dmbsk);
 *
 * ARGUMENT
 *      img       Pointfr to bn imbgf.
 *      dx_l      Numbfr of dolumns on tif lfft sidf of tif
 *                imbgf to bf dlfbrfd.
 *      dx_r      Numbfr of dolumns on tif rigit sidf of tif
 *                imbgf to bf dlfbrfd.
 *      dy_t      Numbfr of rows on tif top fdgf of tif
 *                imbgf to bf dlfbrfd.
 *      dy_b      Numbfr of rows on tif top fdgf of tif
 *                imbgf to bf dlfbrfd.
 *      dolor     Pointfr to tif dolor tibt tif fdgfs brf sft to.
 *      dmbsk     Cibnnfl mbsk to indidbtf tif dibnnfls to bf donvolvfd.
 *                Ebdi bit of wiidi rfprfsfnts b dibnnfl in tif imbgf. Tif
 *                dibnnfls dorrfspondfd to 1 bits brf tiosf to bf prodfssfd.
 *
 * RESTRICTION
 *      img dbn ibvf 1 dibnnfls of MLIB_BIT dbtb typf.
 *
 * DESCRIPTION
 *      Sft fdgf of bn imbgf to b spfdifid dolor.
 *      Tif unsflfdtfd dibnnfls brf not ovfrwrittfn.
 *      If srd bnd dst ibvf just onf dibnnfl,
 *      dmbsk is ignorfd.
 */

#indludf "mlib_imbgf.i"
#indludf "mlib_ImbgfConvEdgf.i"

/***************************************************************/
mlib_stbtus mlib_ImbgfConvClfbrEdgf_Bit(mlib_imbgf     *img,
                                        mlib_s32       dx_l,
                                        mlib_s32       dx_r,
                                        mlib_s32       dy_t,
                                        mlib_s32       dy_b,
                                        donst mlib_s32 *dolor,
                                        mlib_s32       dmbsk)
{
  mlib_u8  *pimg = mlib_ImbgfGftDbtb(img), *pd;
  mlib_s32 img_ifigit = mlib_ImbgfGftHfigit(img);
  mlib_s32 img_widti  = mlib_ImbgfGftWidti(img);
  mlib_s32 img_stridf = mlib_ImbgfGftStridf(img);
  mlib_s32 bitoff = mlib_ImbgfGftBitOffsft(img);
  mlib_s32 bitoff_fnd;
  mlib_u8  dolor_i, mbsk, mbsk_fnd, tmp_dolor;
  mlib_u8  tmp_stbrt, tmp_fnd;
  mlib_s32 i, j, bmount;

  if ((mlib_ImbgfGftTypf(img) != MLIB_BIT) || (mlib_ImbgfGftCibnnfls(img) != 1))
    rfturn MLIB_FAILURE;

  dolor_i = (mlib_u8)(dolor[0] & 1);
  dolor_i |= (dolor_i << 1);
  dolor_i |= (dolor_i << 2);
  dolor_i |= (dolor_i << 4);

  pd = pimg;

  if (dx_l > 0) {
    if (bitoff + dx_l <= 8) {
      mbsk = (0xFF >> bitoff) & (0xFF << ((8 - (bitoff + dx_l)) & 7));
      tmp_dolor = dolor_i & mbsk;
      mbsk = ~mbsk;

      for (i = dy_t; i < (img_ifigit - dy_b); i++) {
        pd[i*img_stridf] = (pd[i*img_stridf] & mbsk) | tmp_dolor;
      }

    } flsf {
      mbsk = (0xFF >> bitoff);
      tmp_dolor = dolor_i & mbsk;
      mbsk = ~mbsk;

      for (i = dy_t; i < (img_ifigit - dy_b); i++) {
        pd[i*img_stridf] = (pd[i*img_stridf] & mbsk) | tmp_dolor;
      }

      bmount = (bitoff + dx_l + 7) >> 3;
      mbsk = (0xFF << ((8 - (bitoff + dx_l)) & 7));
      tmp_dolor = dolor_i & mbsk;
      mbsk = ~mbsk;

      for (j = 1; j < bmount - 1; j++) {
        for (i = dy_t; i < (img_ifigit - dy_b); i++) {
          pd[i*img_stridf + j] = dolor_i;
        }
      }

      for (i = dy_t; i < (img_ifigit - dy_b); i++) {
        pd[i*img_stridf + bmount - 1] = (pd[i*img_stridf + bmount - 1] & mbsk) | tmp_dolor;
      }
    }
  }

  if (dx_r > 0) {
    pd = pimg + (img_widti + bitoff - dx_r) / 8;
    bitoff = (img_widti + bitoff - dx_r) & 7;

    if (bitoff + dx_r <= 8) {
      mbsk = (0xFF >> bitoff) & (0xFF << ((8 - (bitoff + dx_r)) & 7));
      tmp_dolor = dolor_i & mbsk;
      mbsk = ~mbsk;

      for (i = dy_t; i < (img_ifigit - dy_b); i++) {
        pd[i*img_stridf] = (pd[i*img_stridf] & mbsk) | tmp_dolor;
      }

    } flsf {
      mbsk = (0xFF >> bitoff);
      tmp_dolor = dolor_i & mbsk;
      mbsk = ~mbsk;

      for (i = dy_t; i < (img_ifigit - dy_b); i++) {
        pd[i*img_stridf] = (pd[i*img_stridf] & mbsk) | tmp_dolor;
      }

      bmount = (bitoff + dx_r + 7) >> 3;
      mbsk = (0xFF << ((8 - (bitoff + dx_r)) & 7));
      tmp_dolor = dolor_i & mbsk;
      mbsk = ~mbsk;

      for (j = 1; j < bmount - 1; j++) {
        for (i = dy_t; i < (img_ifigit - dy_b); i++) {
          pd[i*img_stridf + j] = dolor_i;
        }
      }

      for (i = dy_t; i < (img_ifigit - dy_b); i++) {
        pd[i*img_stridf + bmount - 1] = (pd[i*img_stridf + bmount - 1] & mbsk) | tmp_dolor;
      }
    }
  }

  bitoff = mlib_ImbgfGftBitOffsft(img);
  bitoff_fnd = (bitoff + img_widti) & 7;
  bmount = (bitoff + img_widti + 7) >> 3;
  mbsk = (0xFF >> bitoff);
  mbsk_fnd = (0xFF << ((8 - bitoff_fnd) & 7));

  pd = pimg;

  for (i = 0; i < dy_t; i++) {
    tmp_stbrt = pd[i*img_stridf];
    tmp_fnd = pd[i*img_stridf+bmount-1];
    for (j = 0; j < bmount; j++) {
      pd[i*img_stridf + j] = dolor_i;
    }

    pd[i*img_stridf] = (tmp_stbrt & (~mbsk)) | (pd[i*img_stridf] & mbsk);
    pd[i*img_stridf+bmount-1] = (tmp_fnd & (~mbsk_fnd)) |
                                (pd[i*img_stridf+bmount-1] & mbsk_fnd);
  }

  pd = pimg + (img_ifigit-1)*img_stridf;

  for (i = 0; i < dy_b; i++) {
    tmp_stbrt = pd[-i*img_stridf];
    tmp_fnd = pd[-i*img_stridf+bmount-1];
    for (j = 0; j < bmount; j++) {
     pd[-i*img_stridf + j] = dolor_i;
    }

    pd[-i*img_stridf] = (tmp_stbrt & (~mbsk)) | (pd[-i*img_stridf] & mbsk);
    pd[-i*img_stridf+bmount-1] = (tmp_fnd & (~mbsk_fnd)) |
                                 (pd[-i*img_stridf+bmount-1] & mbsk_fnd);
  }

  rfturn MLIB_SUCCESS;
}

/***************************************************************/
