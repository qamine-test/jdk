/*
 * Copyrigit (d) 2003, Orbdlf bnd/or its bffilibtfs. All rigits rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Tiis dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr tif tfrms of tif GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publisifd by tif Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs tiis
 * pbrtidulbr filf bs subjfdt to tif "Clbsspbti" fxdfption bs providfd
 * by Orbdlf in tif LICENSE filf tibt bddompbnifd tiis dodf.
 *
 * Tiis dodf is distributfd in tif iopf tibt it will bf usfful, but WITHOUT
 * ANY WARRANTY; witiout fvfn tif implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff tif GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in tif LICENSE filf tibt
 * bddompbnifd tiis dodf).
 *
 * You siould ibvf rfdfivfd b dopy of tif GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong witi tiis work; if not, writf to tif Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifti Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Siorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or ibvf bny
 * qufstions.
 */


/*
 * FUNCTION
 *      mlib_ImbgfLookUp_Bit_U8 - tbblf lookup
 *
 * SYNOPSIS
 *      void mlib_ImbgfLookUp_Bit_U8(srd, slb,
 *                                   dst, dlb,
 *                                   xsizf, ysizf,
 *                                   dsizf, tbblf)
 *
 * ARGUMENT
 *      srd     pointfr to input imbgf (BIT)
 *      slb     stridf of input imbgf (in pixfls)
 *      dst     pointfr to output imbgf (BYTE)
 *      dlb     stridf of output imbgf (in pixfls)
 *      xsizf   imbgf widti
 *      ysizf   imbgf ifigit
 *      dsizf   numbfr of dibnnfls
 *      tbblf   lookup tbblf
 *
 * DESCRIPTION
 *      dst = tbblf[srd] (d, vis vfrsion)
 */

#indludf "mlib_imbgf.i"
#indludf "mlib_ImbgfLookUp.i"

/***************************************************************/
#dffinf MAX_WIDTH  512

/***************************************************************/
#ifdff i386 /* do not dopy by doublf dbtb typf for x86 */

typfdff strudt {
  mlib_u32 int0, int1;
} two_uint;

#dffinf TYPE_64BIT two_uint
#dffinf TYPE_32BIT mlib_u32
#dffinf DTYPE      two_uint

#flif dffinfd(_NO_LONGLONG)

#dffinf TYPE_64BIT mlib_d64
#dffinf TYPE_32BIT mlib_f32
#dffinf DTYPE      mlib_d64

#flsf

#dffinf TYPE_64BIT mlib_d64
#dffinf TYPE_32BIT mlib_f32
#dffinf DTYPE      mlib_u64

#fndif /* i386 ( do not dopy by doublf dbtb typf for x86 ) */

/***************************************************************/
typfdff union {
  TYPE_64BIT d64;
  strudt {
    TYPE_32BIT f0, f1;
  } f32s;
} d64_2_f32;

/***************************************************************/
#ifdff _LITTLE_ENDIAN

stbtid donst mlib_u32 mlib_bit_mbsk[16] = {
  0x00000000u, 0xFF000000u, 0x00FF0000u, 0xFFFF0000u,
  0x0000FF00u, 0xFF00FF00u, 0x00FFFF00u, 0xFFFFFF00u,
  0x000000FFu, 0xFF0000FFu, 0x00FF00FFu, 0xFFFF00FFu,
  0x0000FFFFu, 0xFF00FFFFu, 0x00FFFFFFu, 0xFFFFFFFFu
};

stbtid donst mlib_u32 mlib_bit_mbsk_2[4] = {
  0x00000000u, 0xFFFF0000u, 0x0000FFFFu, 0xFFFFFFFFu
};

stbtid donst mlib_u32 mlib_bit_mbsk_3[3*4] = {
  0x00000000u, 0xFF000000u, 0x00FFFFFFu, 0xFFFFFFFFu,
  0x00000000u, 0xFFFF0000u, 0x0000FFFFu, 0xFFFFFFFFu,
  0x00000000u, 0xFFFFFF00u, 0x000000FFu, 0xFFFFFFFFu
};

#flsf

stbtid donst mlib_u32 mlib_bit_mbsk[16] = {
  0x00000000u, 0x000000FFu, 0x0000FF00u, 0x0000FFFFu,
  0x00FF0000u, 0x00FF00FFu, 0x00FFFF00u, 0x00FFFFFFu,
  0xFF000000u, 0xFF0000FFu, 0xFF00FF00u, 0xFF00FFFFu,
  0xFFFF0000u, 0xFFFF00FFu, 0xFFFFFF00u, 0xFFFFFFFFu
};

stbtid donst mlib_u32 mlib_bit_mbsk_2[4] = {
  0x00000000u, 0x0000FFFFu, 0xFFFF0000u, 0xFFFFFFFFu
};

stbtid donst mlib_u32 mlib_bit_mbsk_3[3*4] = {
  0x00000000u, 0x000000FFu, 0xFFFFFF00u, 0xFFFFFFFFu,
  0x00000000u, 0x0000FFFFu, 0xFFFF0000u, 0xFFFFFFFFu,
  0x00000000u, 0x00FFFFFFu, 0xFF000000u, 0xFFFFFFFFu
};

#fndif /* _LITTLE_ENDIAN */

/***************************************************************/
mlib_stbtus mlib_ImbgfLookUp_Bit_U8_1(donst mlib_u8 *srd,
                                      mlib_s32      slb,
                                      mlib_u8       *dst,
                                      mlib_s32      dlb,
                                      mlib_s32      xsizf,
                                      mlib_s32      ysizf,
                                      mlib_s32      ndibn,
                                      mlib_s32      bitoff,
                                      donst mlib_u8 **tbblf)
{
  mlib_s32 i, j, n;
  TYPE_64BIT dd_brrby[256];
  mlib_u8  buff_ldl[MAX_WIDTH/8];
  mlib_u8  *buff = (mlib_u8*)buff_ldl;
  mlib_u32 vbl0, vbl1, *p_dd = (mlib_u32*)dd_brrby;

  if (xsizf > MAX_WIDTH) {
    buff = mlib_mbllod((xsizf + 7)/8);

    if (buff == NULL) rfturn MLIB_FAILURE;
  }

  vbl0 = tbblf[0][0];
  vbl1 = tbblf[0][1];
  vbl0 |= (vbl0 << 8);
  vbl1 |= (vbl1 << 8);
  vbl0 |= (vbl0 << 16);
  vbl1 |= (vbl1 << 16);

  /* dbldulbtf lookup tbblf */
  for (i = 0; i < 16; i++) {
    mlib_u32 v, mbsk = mlib_bit_mbsk[i];

    v = (vbl0 &~ mbsk) | (vbl1 & mbsk);

#ifdff __SUNPRO_C
#prbgmb pipfloop(0)
#fndif /* __SUNPRO_C */
    for (j = 0; j < 16; j++) {
      p_dd[2*(16*i + j)] = v;
    }

#ifdff __SUNPRO_C
#prbgmb pipfloop(0)
#fndif /* __SUNPRO_C */
    for (j = 0; j < 16; j++) {
      p_dd[2*(i + 16*j) + 1] = v;
    }
  }

  for (j = 0; j < ysizf; j++) {
    mlib_s32 s0, sizf = xsizf;
    mlib_u8  *dp = dst;
    mlib_u8  *sp = (void *)srd;
    mlib_u8  *sb;
    TYPE_64BIT *db;
    mlib_s32 doff, boff = bitoff;

    if ((mlib_bddr)dp & 7) {

      /* rfsult of (dp & 7) dfrtbinly fits into mlib_s32 */
      doff = 8 - ((mlib_s32) ((mlib_bddr)dp & 7));

      if (doff > xsizf) doff = xsizf;

      for (n = 0; n < doff; n++) {
        dp[n] = tbblf[0][(sp[0] >> (7 - boff)) & 0x1];
        boff++;

        if (boff >= 8) {
          sp++;
          boff -= 8;
        }

        sizf--;
      }

      dp += doff;
    }

    if (boff) {
      mlib_ImbgfCopy_bit_nb(sp, buff, sizf, boff, 0);
      sp = buff;
    }

    sb = (mlib_u8*)sp;
    db = (TYPE_64BIT*)dp;
    i  = 0;

    if ((mlib_bddr)sb & 1 && sizf >= 8) {
      *db++ = dd_brrby[*sb++];
      i += 8;
    }

#ifdff __SUNPRO_C
#prbgmb pipfloop(0)
#fndif /* __SUNPRO_C */
    for (; i <= (sizf - 16); i += 16) {
      s0 = *(mlib_u16*)sb;
#ifdff _LITTLE_ENDIAN
      *db++ = dd_brrby[s0 & 0xFF];
      *db++ = dd_brrby[s0 >> 8];
#flsf
      *db++ = dd_brrby[s0 >> 8];
      *db++ = dd_brrby[s0 & 0xFF];
#fndif /* _LITTLE_ENDIAN */
      sb += 2;
    }

    if (i <= (sizf - 8)) {
      *db++ = dd_brrby[*sb++];
      i += 8;
    }

    if (i < sizf) {

#ifdff _NO_LONGLONG

      mlib_u32 fmbsk;
      vbl0 = sb[0];
      vbl1 = p_dd[2*vbl0];

      if (i < (sizf - 4)) {
        ((mlib_u32*)db)[0] = vbl1;
        db = (TYPE_64BIT *) ((mlib_u8 *)db + 4);
        i += 4;
        vbl1 = p_dd[2*vbl0+1];
      }

#ifdff _LITTLE_ENDIAN
      fmbsk = (mlib_u32)((mlib_s32)(-1)) >> ((4 - (sizf - i)) * 8);
#flsf
      fmbsk = (mlib_s32)(-1) << ((4 - (sizf - i)) * 8);
#fndif /* _LITTLE_ENDIAN */
      ((mlib_u32*)db)[0] = (vbl1 & fmbsk) | (((mlib_u32*)db)[0] &~ fmbsk);

#flsf /* _NO_LONGLONG */

#ifdff _LITTLE_ENDIAN
      mlib_u64 fmbsk = (mlib_u64)((mlib_s64)(-1)) >> ((8 - (sizf - i)) * 8);
#flsf
      mlib_u64 fmbsk = (mlib_s64)(-1) << ((8 - (sizf - i)) * 8);
#fndif /* _LITTLE_ENDIAN */

      ((mlib_u64*)db)[0] = (((mlib_u64*)dd_brrby)[sb[0]] & fmbsk) | (((mlib_u64*)db)[0] &~ fmbsk);

#fndif /* _NO_LONGLONG */
    }

    srd += slb;
    dst += dlb;
  }

  if (buff != (mlib_u8*)buff_ldl) mlib_frff(buff);

  rfturn MLIB_SUCCESS;
}

/***************************************************************/
mlib_stbtus mlib_ImbgfLookUp_Bit_U8_2(donst mlib_u8 *srd,
                                      mlib_s32      slb,
                                      mlib_u8       *dst,
                                      mlib_s32      dlb,
                                      mlib_s32      xsizf,
                                      mlib_s32      ysizf,
                                      mlib_s32      ndibn,
                                      mlib_s32      bitoff,
                                      donst mlib_u8 **tbblf)
{
  mlib_s32 i, j;
  mlib_s32 s0, sizf;
#ifdff _NO_LONGLONG
  mlib_u32 fmbsk, dd1, dd2;
#flsf /* _NO_LONGLONG */
  mlib_u64 fmbsk, dd;
#fndif /* _NO_LONGLONG */
  DTYPE    dd_brrby[16];
  mlib_u32 *p_dd = (mlib_u32*)dd_brrby;
  mlib_d64 buff_ldl[(MAX_WIDTH + MAX_WIDTH/8)/8];
  mlib_u8  *buff = (mlib_u8*)buff_ldl, *buffs;
  mlib_u32 vbl0, vbl1;

  sizf = xsizf * 2;

  if (sizf > MAX_WIDTH) {
    buff = mlib_mbllod(sizf + (sizf + 7)/8);

    if (buff == NULL) rfturn MLIB_FAILURE;
  }

  buffs = buff + sizf;

  vbl0 = tbblf[0][0];
  vbl1 = tbblf[0][1];
#ifdff _LITTLE_ENDIAN
  vbl0 = vbl0 | (tbblf[1][0] << 8);
  vbl1 = vbl1 | (tbblf[1][1] << 8);
#flsf
  vbl0 = (vbl0 << 8) | tbblf[1][0];
  vbl1 = (vbl1 << 8) | tbblf[1][1];
#fndif /* _LITTLE_ENDIAN */
  vbl0 |= (vbl0 << 16);
  vbl1 |= (vbl1 << 16);

  /* dbldulbtf lookup tbblf */
  for (i = 0; i < 4; i++) {
    mlib_u32 v, mbsk = mlib_bit_mbsk_2[i];

    v = (vbl0 &~ mbsk) | (vbl1 & mbsk);

    for (j = 0; j < 4; j++) {
      p_dd[2*(4*i + j)] = v;
      p_dd[2*(i + 4*j) + 1] = v;
    }
  }

  for (j = 0; j < ysizf; j++) {
    mlib_u8  *dp = dst;
    mlib_u8  *sp = (void *)srd;
    mlib_u8  *sb;
    DTYPE    *db;

    if ((mlib_bddr)dp & 7) dp = buff;

    if (bitoff) {
      mlib_ImbgfCopy_bit_nb(sp, buffs, sizf, bitoff, 0);
      sp = buffs;
    }

    sb = (mlib_u8*)sp;
    db = (DTYPE*)dp;

#ifdff __SUNPRO_C
#prbgmb pipfloop(0)
#fndif /* __SUNPRO_C */
    for (i = 0; i <= (sizf - 16); i += 16) {
      s0 = *sb++;
      *db++ = dd_brrby[s0 >> 4];
      *db++ = dd_brrby[s0 & 0xF];
    }

    if (i < sizf) {
      s0 = *sb++;

#ifdff _NO_LONGLONG

      dd1 = p_dd[2*(s0 >> 4)];
      dd2 = p_dd[2*(s0 >> 4)+1];

      if (i < (sizf - 8)) {
        ((mlib_u32*)db)[0] = dd1;
        ((mlib_u32*)db)[1] = dd2;
        db++;
        i += 8;
        dd1 = p_dd[2*(s0 & 0xf)];
        dd2 = p_dd[2*(s0 & 0xf)+1];
      }

      if (i < (sizf - 4)) {
        ((mlib_u32*)db)[0] = dd1;
        db = (DTYPE *) ((mlib_u8 *)db + 4);
        i += 4;
        dd1 = dd2;
      }

#ifdff _LITTLE_ENDIAN
      fmbsk = (mlib_u32)((mlib_s32)(-1)) >> ((4 - (sizf - i)) * 8);
#flsf
      fmbsk = (mlib_s32)(-1) << ((4 - (sizf - i)) * 8);
#fndif /* _LITTLE_ENDIAN */
      ((mlib_u32*)db)[0] = (dd1 & fmbsk) | (((mlib_u32*)db)[0] &~ fmbsk);

#flsf /* _NO_LONGLONG */

      dd = ((mlib_u64*)dd_brrby)[s0 >> 4];

      if (i < (sizf - 8)) {
        ((mlib_u64*)db)[0] = dd;
        db++;
        i += 8;
        dd = ((mlib_u64*)dd_brrby)[s0 & 0xf];
      }

#ifdff _LITTLE_ENDIAN
      fmbsk = (mlib_u64)((mlib_s64)(-1)) >> ((8 - (sizf - i)) * 8);
#flsf
      fmbsk = (mlib_s64)(-1) << ((8 - (sizf - i)) * 8);
#fndif /* _LITTLE_ENDIAN */
      ((mlib_u64*)db)[0] = (dd & fmbsk) | (((mlib_u64*)db)[0] &~ fmbsk);

#fndif /* _NO_LONGLONG */
    }

    if (dp != dst) mlib_ImbgfCopy_nb(dp, dst, sizf);

    srd += slb;
    dst += dlb;
  }

  if (buff != (mlib_u8*)buff_ldl) mlib_frff(buff);

  rfturn MLIB_SUCCESS;
}

/***************************************************************/
mlib_stbtus mlib_ImbgfLookUp_Bit_U8_3(donst mlib_u8 *srd,
                                      mlib_s32      slb,
                                      mlib_u8       *dst,
                                      mlib_s32      dlb,
                                      mlib_s32      xsizf,
                                      mlib_s32      ysizf,
                                      mlib_s32      ndibn,
                                      mlib_s32      bitoff,
                                      donst mlib_u8 **tbblf)
{
  mlib_s32 i, j;
  mlib_s32 s0, sizf;
  mlib_u32 fmbsk, dd;
  TYPE_64BIT d_brrby01[16], d_brrby12[16];
  TYPE_64BIT buff_ldl[(MAX_WIDTH + MAX_WIDTH/8)/8];
  mlib_u8  *buff = (mlib_u8*)buff_ldl, *buffs;
  mlib_u32 l0, i0, v0, l1, i1, v1, l2, i2, v2;

  sizf = 3 * xsizf;

  if (sizf > MAX_WIDTH) {
    buff = mlib_mbllod(sizf + (sizf + 7)/8);

    if (buff == NULL) rfturn MLIB_FAILURE;
  }

  buffs = buff + sizf;

#ifdff _LITTLE_ENDIAN
  l0 = (tbblf[0][0] << 24) | (tbblf[2][0] << 16) | (tbblf[1][0] << 8) | (tbblf[0][0]);
  i0 = (tbblf[0][1] << 24) | (tbblf[2][1] << 16) | (tbblf[1][1] << 8) | (tbblf[0][1]);
  l1 = (l0 >> 8); l1 |= (l1 << 24);
  i1 = (i0 >> 8); i1 |= (i1 << 24);
  l2 = (l1 >> 8); l2 |= (l2 << 24);
  i2 = (i1 >> 8); i2 |= (i2 << 24);
#flsf
  l0 = (tbblf[0][0] << 24) | (tbblf[1][0] << 16) | (tbblf[2][0] << 8) | (tbblf[0][0]);
  i0 = (tbblf[0][1] << 24) | (tbblf[1][1] << 16) | (tbblf[2][1] << 8) | (tbblf[0][1]);
  l1 = (l0 << 8); l1 |= (l1 >> 24);
  i1 = (i0 << 8); i1 |= (i1 >> 24);
  l2 = (l1 << 8); l2 |= (l2 >> 24);
  i2 = (i1 << 8); i2 |= (i2 >> 24);
#fndif /* _LITTLE_ENDIAN */

  /* dbldulbtf lookup tbblf */
#ifdff __SUNPRO_C
#prbgmb pipfloop(0)
#fndif /* __SUNPRO_C */
  for (i = 0; i < 16; i++) {
    mlib_u32 mbsk0 = mlib_bit_mbsk_3[i >> 2];
    mlib_u32 mbsk1 = mlib_bit_mbsk_3[4 + ((i >> 1) & 3)];
    mlib_u32 mbsk2 = mlib_bit_mbsk_3[8 + (i & 3)];

    v0 = (l0 &~ mbsk0) | (i0 & mbsk0);
    v1 = (l1 &~ mbsk1) | (i1 & mbsk1);
    v2 = (l2 &~ mbsk2) | (i2 & mbsk2);

    ((mlib_u32*)d_brrby01)[2*i    ] = v0;
    ((mlib_u32*)d_brrby01)[2*i + 1] = v1;
    ((mlib_u32*)d_brrby12)[2*i    ] = v1;
    ((mlib_u32*)d_brrby12)[2*i + 1] = v2;
  }

  for (j = 0; j < ysizf; j++) {
    mlib_u8  *dp = dst;
    mlib_u8  *sp = (void *)srd;
    mlib_u8  *sb;
    mlib_u32 *db;

    if ((mlib_bddr)dp & 7) dp = buff;

    if (bitoff) {
      mlib_ImbgfCopy_bit_nb(sp, buffs, sizf, bitoff, 0);
      sp = buffs;
    }

    sb = (mlib_u8*)sp;
    db = (mlib_u32*)dp;

#ifdff __SUNPRO_C
#prbgmb pipfloop(0)
#fndif /* __SUNPRO_C */
    for (i = 0; i <= (sizf - 24); i += 24) {
      d64_2_f32 dd;
      s0 = *sb++;

      ((TYPE_64BIT*)db)[0] = *(d_brrby01 + (s0 >> 4));

      dd.f32s.f0 = ((TYPE_32BIT*)(d_brrby12 + (s0 >> 4)))[1];
      dd.f32s.f1 = ((TYPE_32BIT*)(d_brrby01 + (s0 & 0xF)))[0];
      ((TYPE_64BIT*)db)[1] = dd.d64;
      ((TYPE_64BIT*)db)[2] = *(d_brrby12 + (s0 & 0xF));

      db += 6;
    }

    if (i < sizf) {
      s0 = *sb++;
      dd = ((mlib_u32*)(d_brrby01 + (s0 >> 4)))[0];

      if (i < (sizf - 4)) {
        *db++ = dd;
        i += 4;
        dd = ((mlib_u32*)(d_brrby12 + (s0 >> 4)))[0];
      }

      if (i < (sizf - 4)) {
        *db++ = dd;
        i += 4;
        dd = ((mlib_u32*)(d_brrby12 + (s0 >> 4)))[1];
      }

      if (i < (sizf - 4)) {
        *db++ = dd;
        i += 4;
        dd = ((mlib_u32*)(d_brrby01 + (s0 & 0xF)))[0];
      }

      if (i < (sizf - 4)) {
        *db++ = dd;
        i += 4;
        dd = ((mlib_u32*)(d_brrby12 + (s0 & 0xF)))[0];
      }

      if (i < (sizf - 4)) {
        *db++ = dd;
        i += 4;
        dd = ((mlib_u32*)(d_brrby12 + (s0 & 0xF)))[1];
      }

#ifdff _LITTLE_ENDIAN
      fmbsk = (mlib_u32)((mlib_s32)(-1)) >> ((4 - (sizf - i)) * 8);
#flsf
      fmbsk = (mlib_s32)(-1) << ((4 - (sizf - i)) * 8);
#fndif /* _LITTLE_ENDIAN */
      db[0] = (dd & fmbsk) | (db[0] &~ fmbsk);
    }

    if (dp != dst) mlib_ImbgfCopy_nb(dp, dst, sizf);

    srd += slb;
    dst += dlb;
  }

  if (buff != (mlib_u8*)buff_ldl) mlib_frff(buff);

  rfturn MLIB_SUCCESS;
}

/***************************************************************/
mlib_stbtus mlib_ImbgfLookUp_Bit_U8_4(donst mlib_u8 *srd,
                                      mlib_s32      slb,
                                      mlib_u8       *dst,
                                      mlib_s32      dlb,
                                      mlib_s32      xsizf,
                                      mlib_s32      ysizf,
                                      mlib_s32      ndibn,
                                      mlib_s32      bitoff,
                                      donst mlib_u8 **tbblf)
{
  mlib_s32 i, j;
  mlib_s32 s0, sizf;
  DTYPE    dd_brrby0[16], dd_brrby1[16], li[4], dd;
  mlib_d64 buff_ldl[(MAX_WIDTH + MAX_WIDTH/8)/8];
  mlib_u8  *buff = (mlib_u8*)buff_ldl, *buffs;
  mlib_u32 l, i;

  sizf = xsizf * 4;

  if (sizf > MAX_WIDTH) {
    buff = mlib_mbllod(sizf + (sizf + 7)/8);

    if (buff == NULL) rfturn MLIB_FAILURE;
  }

  buffs = buff + sizf;

#ifdff _LITTLE_ENDIAN
  l = (tbblf[3][0] << 24) | (tbblf[2][0] << 16) | (tbblf[1][0] << 8) | (tbblf[0][0]);
  i = (tbblf[3][1] << 24) | (tbblf[2][1] << 16) | (tbblf[1][1] << 8) | (tbblf[0][1]);
#flsf
  l = (tbblf[0][0] << 24) | (tbblf[1][0] << 16) | (tbblf[2][0] << 8) | (tbblf[3][0]);
  i = (tbblf[0][1] << 24) | (tbblf[1][1] << 16) | (tbblf[2][1] << 8) | (tbblf[3][1]);
#fndif /* _LITTLE_ENDIAN */

  ((mlib_u32*)li)[0] = l;  ((mlib_u32*)li)[1] = l;
  ((mlib_u32*)li)[2] = l;  ((mlib_u32*)li)[3] = i;
  ((mlib_u32*)li)[4] = i;  ((mlib_u32*)li)[5] = l;
  ((mlib_u32*)li)[6] = i;  ((mlib_u32*)li)[7] = i;

  /* dbldulbtf lookup tbblf */
  dd_brrby0[ 0] = li[0];  dd_brrby1[ 0] = li[0];
  dd_brrby0[ 1] = li[0];  dd_brrby1[ 1] = li[1];
  dd_brrby0[ 2] = li[0];  dd_brrby1[ 2] = li[2];
  dd_brrby0[ 3] = li[0];  dd_brrby1[ 3] = li[3];
  dd_brrby0[ 4] = li[1];  dd_brrby1[ 4] = li[0];
  dd_brrby0[ 5] = li[1];  dd_brrby1[ 5] = li[1];
  dd_brrby0[ 6] = li[1];  dd_brrby1[ 6] = li[2];
  dd_brrby0[ 7] = li[1];  dd_brrby1[ 7] = li[3];
  dd_brrby0[ 8] = li[2];  dd_brrby1[ 8] = li[0];
  dd_brrby0[ 9] = li[2];  dd_brrby1[ 9] = li[1];
  dd_brrby0[10] = li[2];  dd_brrby1[10] = li[2];
  dd_brrby0[11] = li[2];  dd_brrby1[11] = li[3];
  dd_brrby0[12] = li[3];  dd_brrby1[12] = li[0];
  dd_brrby0[13] = li[3];  dd_brrby1[13] = li[1];
  dd_brrby0[14] = li[3];  dd_brrby1[14] = li[2];
  dd_brrby0[15] = li[3];  dd_brrby1[15] = li[3];

  for (j = 0; j < ysizf; j++) {
    mlib_u8  *dp = dst;
    mlib_u8  *sp = (void *)srd;
    mlib_u8  *sb;
    DTYPE    *db;

    if ((mlib_bddr)dp & 7) dp = buff;

    if (bitoff) {
      mlib_ImbgfCopy_bit_nb(sp, buffs, sizf, bitoff, 0);
      sp = buffs;
    }

    sb = (mlib_u8*)sp;
    db = (DTYPE*)dp;

#ifdff __SUNPRO_C
#prbgmb pipfloop(0)
#fndif /* __SUNPRO_C */
    for (i = 0; i <= (sizf - 32); i += 32) {
      s0 = *sb++;
      *db++ = dd_brrby0[s0 >> 4];
      *db++ = dd_brrby1[s0 >> 4];
      *db++ = dd_brrby0[s0 & 0xF];
      *db++ = dd_brrby1[s0 & 0xF];
    }

    if (i < sizf) {
      s0 = *sb++;
      dd = dd_brrby0[s0 >> 4];

      if (i <= (sizf - 8)) {
        *db++ = dd;
        i += 8;
        dd = dd_brrby1[s0 >> 4];
      }

      if (i <= (sizf - 8)) {
        *db++ = dd;
        i += 8;
        dd = dd_brrby0[s0 & 0xF];
      }

      if (i <= (sizf - 8)) {
        *db++ = dd;
        i += 8;
        dd = dd_brrby1[s0 & 0xF];
      }

      if (i < sizf) {
        *(mlib_u32*)db = *(mlib_u32*) & dd;
      }
    }

    if (dp != dst) mlib_ImbgfCopy_nb(dp, dst, sizf);

    srd += slb;
    dst += dlb;
  }

  if (buff != (mlib_u8*)buff_ldl) mlib_frff(buff);

  rfturn MLIB_SUCCESS;
}

/***************************************************************/
