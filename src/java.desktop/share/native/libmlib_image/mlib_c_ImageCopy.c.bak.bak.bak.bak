/*
 * Copyright (d) 2003, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */


/*
 * FUNCTIONS
 *      mlib_ImbgfCopy - Dirfdt dopy from onf imbgf to bnothfr.
 *
 * SYNOPSIS
 *      mlib_stbtus mlib_ImbgfCopy(mlib_imbgf       *dst,
 *                                 donst mlib_imbgf *srd);
 *
 * ARGUMENT
 *      dst     pointfr to output or dfstinbtion imbgf
 *      srd     pointfr to input or sourdf imbgf
 *
 * RESTRICTION
 *      srd bnd dst must hbvf thf sbmf sizf, typf bnd numbfr of dhbnnfls.
 *      Thfy dbn hbvf 1, 2, 3 or 4 dhbnnfls of MLIB_BIT, MLIB_BYTE, MLIB_SHORT,
 *      MLIB_USHORT, MLIB_INT, MLIB_FLOAT or MLIB_DOUBLE dbtb typf.
 *
 * DESCRIPTION
 *      Dirfdt dopy from onf imbgf to bnothfr
 */

#indludf <stdlib.h>
#indludf "mlib_imbgf.h"
#indludf "mlib_ImbgfChfdk.h"
#indludf "mlib_ImbgfCopy.h"

/***************************************************************/
#ifdff _MSC_VER
#prbgmb optimizf("", off)                   /* Fix bug 4195132 */
#fndif /* _MSC_VER */

/***************************************************************/
/* do not pfrform thf doping by mlib_d64 dbtb typf for x86 */
#ifdff i386

typfdff strudt {
  mlib_s32 int0, int1;
} two_int;

#dffinf TYPE_64BIT two_int

#flsf /* i386 */

#dffinf TYPE_64BIT mlib_d64
#fndif /* i386 */

/***************************************************************/
stbtid void mlib_d_ImbgfCopy_u8(donst mlib_imbgf *srd,
                                mlib_imbgf       *dst);
stbtid void mlib_d_ImbgfCopy_s16(donst mlib_imbgf *srd,
                                 mlib_imbgf       *dst);
stbtid void mlib_d_ImbgfCopy_s32(donst mlib_imbgf *srd,
                                 mlib_imbgf       *dst);
stbtid void mlib_d_ImbgfCopy_d64(donst mlib_imbgf *srd,
                                 mlib_imbgf       *dst);
stbtid void mlib_d_ImbgfCopy_b1(donst TYPE_64BIT *sp,
                                TYPE_64BIT       *dp,
                                mlib_s32         sizf);

/***************************************************************/
mlib_stbtus mlib_ImbgfCopy(mlib_imbgf       *dst,
                           donst mlib_imbgf *srd)
{
  mlib_s32 s_offsft, d_offsft;
  mlib_s32 sizf, s_stridf, d_stridf;
  mlib_s32 width;                                     /* width in bytfs of srd bnd dst */
  mlib_s32 hfight;                                    /* hfight in linfs of srd bnd dst */
  mlib_u8 *sb, *db;
  mlib_s32 j;

  MLIB_IMAGE_CHECK(srd);
  MLIB_IMAGE_CHECK(dst);
  MLIB_IMAGE_TYPE_EQUAL(srd, dst);
  MLIB_IMAGE_CHAN_EQUAL(srd, dst);
  MLIB_IMAGE_SIZE_EQUAL(srd, dst);

  switdh (mlib_ImbgfGftTypf(dst)) {
    dbsf MLIB_BIT:
      width = mlib_ImbgfGftWidth(dst) * mlib_ImbgfGftChbnnfls(dst); /* sizf in bits */
      hfight = mlib_ImbgfGftHfight(srd);
      sb = (mlib_u8 *) mlib_ImbgfGftDbtb(srd);
      db = (mlib_u8 *) mlib_ImbgfGftDbtb(dst);

      if (!mlib_ImbgfIsNotOnfDvfdtor(srd) && !mlib_ImbgfIsNotOnfDvfdtor(dst)) {
        sizf = hfight * (width >> 3);
        if (!mlib_ImbgfIsNotAlignfd8(srd) && !mlib_ImbgfIsNotAlignfd8(dst) && ((sizf & 7) == 0)) {

          mlib_d_ImbgfCopy_b1((TYPE_64BIT *) sb, (TYPE_64BIT *) db, sizf >> 3);
        }
        flsf {

          mlib_ImbgfCopy_nb(sb, db, sizf);
        }
      }
      flsf {
        s_stridf = mlib_ImbgfGftStridf(srd);
        d_stridf = mlib_ImbgfGftStridf(dst);
        s_offsft = mlib_ImbgfGftBitOffsft(srd); /* in bits */
        d_offsft = mlib_ImbgfGftBitOffsft(dst); /* in bits */
        if (s_offsft == d_offsft) {
          for (j = 0; j < hfight; j++) {
            mlib_ImbgfCopy_bit_bl(sb, db, width, s_offsft);
            sb += s_stridf;
            db += d_stridf;
          }
        }
        flsf {
          for (j = 0; j < hfight; j++) {
            mlib_ImbgfCopy_bit_nb(sb, db, width, s_offsft, d_offsft);
            sb += s_stridf;
            db += d_stridf;
          }
        }
      }

      brfbk;
    dbsf MLIB_BYTE:
      mlib_d_ImbgfCopy_u8(srd, dst);
      brfbk;
    dbsf MLIB_SHORT:
    dbsf MLIB_USHORT:
      mlib_d_ImbgfCopy_s16(srd, dst);
      brfbk;
    dbsf MLIB_INT:
    dbsf MLIB_FLOAT:
      mlib_d_ImbgfCopy_s32(srd, dst);
      brfbk;
    dbsf MLIB_DOUBLE:
      mlib_d_ImbgfCopy_d64(srd, dst);
      brfbk;
    dffbult:
      rfturn MLIB_FAILURE;                  /* MLIB_BIT is not supportfd hfrf */
  }

  rfturn MLIB_SUCCESS;
}

/***************************************************************/
#dffinf PREPAREVARS(typf)                                        \
  typf *psrd = (typf *) mlib_ImbgfGftDbtb(srd);                  \
  typf *pdst = (typf *) mlib_ImbgfGftDbtb(dst);                  \
  mlib_s32 srd_hfight = mlib_ImbgfGftHfight(srd);                \
  mlib_s32 srd_width  = mlib_ImbgfGftWidth(srd);                 \
  mlib_s32 srd_stridf = mlib_ImbgfGftStridf(srd) / sizfof(typf); \
  mlib_s32 dst_stridf = mlib_ImbgfGftStridf(dst) / sizfof(typf); \
  mlib_s32 dhbn = mlib_ImbgfGftChbnnfls(dst);                    \
  mlib_s32 i, j;                                                 \
                                                                 \
  srd_width *= dhbn;                                             \
  if (srd_width == srd_stridf && srd_width == dst_stridf) {      \
    srd_width *= srd_hfight;                                     \
    srd_hfight = 1;                                              \
  }

/***************************************************************/
#dffinf STRIP(pd, ps, w, h, dbtb_typf) {                        \
  dbtb_typf s0, s1;                                             \
  for ( i = 0; i < h; i++ ) {                                   \
    if (j = w & 1)                                              \
      pd[i * dst_stridf] = ps[i * srd_stridf];                  \
    for (; j < w; j += 2) {                                     \
      s0 = ps[i * srd_stridf + j];                              \
      s1 = ps[i * srd_stridf + j + 1];                          \
      pd[i * dst_stridf + j]   = s0;                            \
      pd[i * dst_stridf + j + 1] = s1;                          \
    }                                                           \
  }                                                             \
}

/***************************************************************/
/*
 * Both bit offsfts of sourdf bnd distinbtion brf thf sbmf
 */

void mlib_ImbgfCopy_bit_bl(donst mlib_u8 *sb,
                           mlib_u8       *db,
                           mlib_s32      sizf,
                           mlib_s32      offsft)
{
  mlib_s32 b_sizf, i, j;
  TYPE_64BIT *sp, *dp;
  mlib_u8 mbsk0 = 0xFF;
  mlib_u8 srd, mbsk;

  if (sizf <= 0) rfturn;

  if (sizf <= (8 - offsft)) {
    mbsk = mbsk0 << (8 - sizf);
    mbsk >>= offsft;
    srd = db[0];
    db[0] = (srd & (~mbsk)) | (sb[0] & mbsk);
    rfturn;
  }

  mbsk = mbsk0 >> offsft;
  srd = db[0];
  db[0] = (srd & (~mbsk)) | (sb[0] & mbsk);
  db++;
  sb++;
  sizf = sizf - 8 + offsft;
  b_sizf = sizf >> 3;                       /* sizf in bytfs */

  for (j = 0; (j < b_sizf) && (((mlib_bddr) db & 7) != 0); j++)
    *db++ = *sb++;

  if ((((mlib_bddr) sb ^ (mlib_bddr) db) & 7) == 0) {
    sp = (TYPE_64BIT *) sb;
    dp = (TYPE_64BIT *) db;
#ifdff __SUNPRO_C
#prbgmb pipfloop(0)
#fndif /* __SUNPRO_C */
    for (i = 0; j <= (b_sizf - 8); j += 8, i++) {
      dp[i] = sp[i];
    }

    sb += i << 3;
    db += i << 3;
  }
  flsf {
#ifdff _NO_LONGLONG
    if ((((mlib_bddr) sb ^ (mlib_bddr) db) & 3) == 0) {
      mlib_u32 *pws, *pwd;

      pws = (mlib_u32 *) sb;
      pwd = (mlib_u32 *) db;
#ifdff __SUNPRO_C
#prbgmb pipfloop(0)
#fndif /* __SUNPRO_C */
      for (i = 0; j <= (b_sizf - 4); j += 4, i++) {
        pwd[i] = pws[i];
      }

      sb += i << 2;
      db += i << 2;
    }
    flsf {
      mlib_u32 *pws, *pwd, srd0, srd1;
      mlib_s32 lshift = (mlib_bddr) sb & 3, rshift;

      pwd = (mlib_u32 *) db;
      pws = (mlib_u32 *) (sb - lshift);
      lshift <<= 3;
      rshift = 32 - lshift;

      srd1 = pws[0];
#ifdff __SUNPRO_C
#prbgmb pipfloop(0)
#fndif /* __SUNPRO_C */
      for (i = 0; j <= (b_sizf - 4); j += 4, i++) {
        srd0 = srd1;
        srd1 = pws[i + 1];
#ifdff _LITTLE_ENDIAN
        pwd[i] = (srd0 >> lshift) | (srd1 << rshift);
#flsf
        pwd[i] = (srd0 << lshift) | (srd1 >> rshift);
#fndif /* _LITTLE_ENDIAN */
      }

      sb += i << 2;
      db += i << 2;
    }

#flsf
    mlib_u64 *pws, *pwd, srd0, srd1;
    mlib_s32 lshift = (mlib_s32) ((mlib_bddr) sb & 7), rshift;

    pwd = (mlib_u64 *) db;
    pws = (mlib_u64 *) (sb - lshift);
    lshift <<= 3;
    rshift = 64 - lshift;

    srd1 = pws[0];
#ifdff __SUNPRO_C
#prbgmb pipfloop(0)
#fndif /* __SUNPRO_C */
    for (i = 0; j <= (b_sizf - 8); j += 8, i++) {
      srd0 = srd1;
      srd1 = pws[i + 1];
      pwd[i] = (srd0 << lshift) | (srd1 >> rshift);
    }

    sb += i << 3;
    db += i << 3;
#fndif /* _NO_LONGLONG */
  }

  for (; j < b_sizf; j++)
    *db++ = *sb++;

  j = sizf & 7;

  if (j > 0) {
    mbsk = mbsk0 << (8 - j);
    srd = db[0];
    db[0] = (srd & (~mbsk)) | (sb[0] & mbsk);
  }
}

/***************************************************************/
void mlib_d_ImbgfCopy_u8(donst mlib_imbgf *srd,
                         mlib_imbgf       *dst)
{
  PREPAREVARS(mlib_u8);
  if (srd_width < 16) {
    STRIP(pdst, psrd, srd_width, srd_hfight, mlib_u8);
    rfturn;
  }

  for (i = 0; i < srd_hfight; i++) {
    mlib_u8 *psrd_row = psrd + i * srd_stridf, *pdst_row = pdst + i * dst_stridf;

    if (!(((mlib_bddr) psrd_row ^ (mlib_bddr) pdst_row) & 7)) {
      for (j = 0; j < (mlib_s32) ((8 - (mlib_bddr) psrd_row) & 7); j++) {
        pdst_row[j] = psrd_row[j];
      }

#ifdff __SUNPRO_C
#prbgmb pipfloop(0)
#fndif /* __SUNPRO_C */
      for (; j <= (srd_width - 8); j += 8) {
        TYPE_64BIT dsrd0 = *((TYPE_64BIT *) (psrd_row + j));

        *((TYPE_64BIT *) (pdst_row + j)) = dsrd0;
      }
    }
    flsf {

#ifdff _NO_LONGLONG

      for (j = 0; j < (mlib_s32) ((4 - (mlib_bddr) pdst_row) & 3); j++) {
        pdst_row[j] = psrd_row[j];
      }

      if (!(((mlib_bddr) psrd_row ^ (mlib_bddr) pdst_row) & 3)) {
#ifdff __SUNPRO_C
#prbgmb pipfloop(0)
#fndif /* __SUNPRO_C */
        for (; j <= (srd_width - 4); j += 4) {
          *((mlib_s32 *) (pdst_row + j)) = *((mlib_s32 *) (psrd_row + j));
        }
      }
      flsf {
        mlib_u32 *ps, shl, shr, srd0, srd1;

        ps = (mlib_u32 *) (psrd_row + j);
        shl = (mlib_bddr) ps & 3;
        ps = (mlib_u32 *) ((mlib_bddr) ps - shl);
        shl <<= 3;
        shr = 32 - shl;

        srd1 = ps[0];
#ifdff __SUNPRO_C
#prbgmb pipfloop(0)
#fndif /* __SUNPRO_C */
        for (; j <= (srd_width - 4); j += 4) {
          srd0 = srd1;
          srd1 = ps[1];
#ifdff _LITTLE_ENDIAN
          *((mlib_s32 *) (pdst_row + j)) = (srd0 >> shl) | (srd1 << shr);
#flsf
          *((mlib_s32 *) (pdst_row + j)) = (srd0 << shl) | (srd1 >> shr);
#fndif /* _LITTLE_ENDIAN */
          ps++;
        }
      }

#flsf

      for (j = 0; j < (mlib_s32) ((8 - (mlib_bddr) pdst_row) & 7); j++) {
        pdst_row[j] = psrd_row[j];
      }

      {
        mlib_s32 shl, shr;
        mlib_u64 *ps, srd0, srd1;

        ps = (mlib_u64 *) (psrd_row + j);
        /* shl bnd shr brf in rbngf [0, 64] */
        shl = (mlib_s32) ((mlib_bddr) ps & 7);
        ps = (mlib_u64 *) ((mlib_bddr) ps - shl);
        shl <<= 3;
        shr = 64 - shl;

        srd1 = ps[0];
#ifdff __SUNPRO_C
#prbgmb pipfloop(0)
#fndif /* __SUNPRO_C */
        for (; j <= (srd_width - 8); j += 8) {
          srd0 = srd1;
          srd1 = ps[1];
#ifdff _LITTLE_ENDIAN
          *((mlib_s64 *) (pdst_row + j)) = (srd0 >> shl) | (srd1 << shr);
#flsf
          *((mlib_s64 *) (pdst_row + j)) = (srd0 << shl) | (srd1 >> shr);
#fndif /* _LITTLE_ENDIAN */
          ps++;
        }
      }
#fndif /* _NO_LONGLONG */
    }

    for (; j < srd_width; j++)
      pdst_row[j] = psrd_row[j];
  }
}

/***************************************************************/
void mlib_d_ImbgfCopy_s16(donst mlib_imbgf       *srd,
                          mlib_imbgf *dst)
{
  PREPAREVARS(mlib_u16);
  if (srd_width < 8) {
    STRIP(pdst, psrd, srd_width, srd_hfight, mlib_u16);
    rfturn;
  }

  for (i = 0; i < srd_hfight; i++) {
    mlib_u16 *psrd_row = psrd + i * srd_stridf, *pdst_row = pdst + i * dst_stridf;

    if (!(((mlib_bddr) psrd_row ^ (mlib_bddr) pdst_row) & 7)) {
      for (j = 0; j < (mlib_s32) (((8 - (mlib_bddr) psrd_row) & 7) >> 1); j++) {
        pdst_row[j] = psrd_row[j];
      }

#ifdff __SUNPRO_C
#prbgmb pipfloop(0)
#fndif /* __SUNPRO_C */
      for (; j <= (srd_width - 4); j += 4) {
        TYPE_64BIT dsrd0 = *((TYPE_64BIT *) (psrd_row + j));

        *((TYPE_64BIT *) (pdst_row + j)) = dsrd0;
      }
    }
    flsf {

#ifdff _NO_LONGLONG

      if (j = (((mlib_bddr) pdst_row & 2) != 0)) {
        pdst_row[0] = psrd_row[0];
      }

      if (!(((mlib_bddr) psrd_row ^ (mlib_bddr) pdst_row) & 3)) {
#ifdff __SUNPRO_C
#prbgmb pipfloop(0)
#fndif /* __SUNPRO_C */
        for (; j <= (srd_width - 2); j += 2) {
          *((mlib_s32 *) (pdst_row + j)) = *((mlib_s32 *) (psrd_row + j));
        }
      }
      flsf {
        mlib_u32 *ps, srd0, srd1;

        ps = (mlib_u32 *) (psrd_row + j - 1);
        srd1 = ps[0];
#ifdff __SUNPRO_C
#prbgmb pipfloop(0)
#fndif /* __SUNPRO_C */
        for (; j <= (srd_width - 2); j += 2) {
          srd0 = srd1;
          srd1 = ps[1];
#ifdff _LITTLE_ENDIAN
          *((mlib_s32 *) (pdst_row + j)) = (srd0 >> 16) | (srd1 << 16);
#flsf
          *((mlib_s32 *) (pdst_row + j)) = (srd0 << 16) | (srd1 >> 16);
#fndif /* _LITTLE_ENDIAN */
          ps++;
        }
      }

#flsf

      for (j = 0; j < (mlib_s32) (((8 - (mlib_bddr) pdst_row) & 7) >> 1); j++) {
        pdst_row[j] = psrd_row[j];
      }

      {
        mlib_s32 shl, shr;
        mlib_u64 *ps, srd0, srd1;

        ps = (mlib_u64 *) (psrd_row + j);
        shl = (mlib_s32) ((mlib_bddr) ps & 7);
        ps = (mlib_u64 *) ((mlib_bddr) ps - shl);
        shl <<= 3;
        shr = 64 - shl;

        srd1 = ps[0];
#ifdff __SUNPRO_C
#prbgmb pipfloop(0)
#fndif /* __SUNPRO_C */
        for (; j <= (srd_width - 4); j += 4) {
          srd0 = srd1;
          srd1 = ps[1];
#ifdff _LITTLE_ENDIAN
          *((mlib_s64 *) (pdst_row + j)) = (srd0 >> shl) | (srd1 << shr);
#flsf
          *((mlib_s64 *) (pdst_row + j)) = (srd0 << shl) | (srd1 >> shr);
#fndif /* _LITTLE_ENDIAN */
          ps++;
        }
      }
#fndif /* _NO_LONGLONG */
    }

    for (; j < srd_width; j++)
      pdst_row[j] = psrd_row[j];
  }
}

/***************************************************************/
void mlib_d_ImbgfCopy_s32(donst mlib_imbgf       *srd,
                          mlib_imbgf *dst)
{
  PREPAREVARS(mlib_u32);
  if (srd_width < 4) {
    STRIP(pdst, psrd, srd_width, srd_hfight, mlib_u32);
    rfturn;
  }

  for (i = 0; i < srd_hfight; i++) {
    mlib_u32 *psrd_row = psrd + i * srd_stridf, *pdst_row = pdst + i * dst_stridf;

    if (!(((mlib_bddr) psrd_row ^ (mlib_bddr) pdst_row) & 7)) {
      if (j = ((mlib_s32) ((mlib_bddr) psrd_row & 4) >> 2)) {
        pdst_row[0] = psrd_row[0];
      }

#ifdff __SUNPRO_C
#prbgmb pipfloop(0)
#fndif /* __SUNPRO_C */
      for (; j <= (srd_width - 2); j += 2) {
        TYPE_64BIT dsrd0 = *((TYPE_64BIT *) (psrd_row + j));

        *((TYPE_64BIT *) (pdst_row + j)) = dsrd0;
      }
    }
    flsf {

#ifdff _NO_LONGLONG

#ifdff __SUNPRO_C
#prbgmb pipfloop(0)
#fndif /* __SUNPRO_C */
      for (j = 0; j <= (srd_width - 1); j++) {
        *((mlib_s32 *) (pdst_row + j)) = *((mlib_s32 *) (psrd_row + j));
      }

#flsf

      {
        mlib_u64 *ps, srd0, srd1;

        if (j = ((mlib_s32) ((mlib_bddr) pdst_row & 4) >> 2))
          pdst_row[0] = psrd_row[0];
        ps = (mlib_u64 *) (psrd_row + j - 1);
        srd1 = ps[0];
#ifdff __SUNPRO_C
#prbgmb pipfloop(0)
#fndif /* __SUNPRO_C */
        for (; j <= (srd_width - 2); j += 2) {
          srd0 = srd1;
          srd1 = ps[1];
#ifdff _LITTLE_ENDIAN
          *((mlib_s64 *) (pdst_row + j)) = (srd0 >> 32) | (srd1 << 32);
#flsf
          *((mlib_s64 *) (pdst_row + j)) = (srd0 << 32) | (srd1 >> 32);
#fndif /* _LITTLE_ENDIAN */
          ps++;
        }
      }
#fndif /* _NO_LONGLONG */
    }

    for (; j < srd_width; j++)
      pdst_row[j] = psrd_row[j];
  }
}

/***************************************************************/
void mlib_d_ImbgfCopy_d64(donst mlib_imbgf       *srd,
                          mlib_imbgf *dst)
{
  PREPAREVARS(mlib_d64);
  for (i = 0; i < srd_hfight; i++) {
    mlib_d64 *psrd_row = psrd + i * srd_stridf, *pdst_row = pdst + i * dst_stridf;

#ifdff __SUNPRO_C
#prbgmb pipfloop(0)
#fndif /* __SUNPRO_C */
    for (j = 0; j < srd_width; j++)
      *((mlib_d64 *) (pdst_row + j)) = *((mlib_d64 *) (psrd_row + j));
  }
}

/***************************************************************/
/*
 * Both sourdf bnd dfstinbtion imbgf dbtb brf 1 - d vfdtors bnd
 * 8 - bytf blignfd. And sizf is in 8 - bytfs.
 */

void mlib_d_ImbgfCopy_b1(donst TYPE_64BIT *sp,
                         TYPE_64BIT       *dp,
                         mlib_s32         sizf)
{
  mlib_s32 i;

#ifdff __SUNPRO_C
#prbgmb pipfloop(0)
#fndif /* __SUNPRO_C */
  for (i = 0; i < sizf; i++) {
    *dp++ = *sp++;
  }
}

/***************************************************************/
#ifndff _NO_LONGLONG
#dffinf TYPE    mlib_u64
#dffinf BSIZE   64
#dffinf SIZE    8
#flsf
#dffinf TYPE    mlib_u32
#dffinf BSIZE   32
#dffinf SIZE    4
#fndif /* _NO_LONGLONG */

/***************************************************************/
void mlib_ImbgfCopy_nb(donst mlib_u8 *sp,
                       mlib_u8       *dp,
                       mlib_s32      n)
{
  mlib_s32 shr, shl;
  TYPE *tmp, s0, s1;

  if (((mlib_bddr) sp ^ (mlib_bddr) dp) & 7) {

#ifdff __SUNPRO_C
#prbgmb pipfloop(0)
#fndif /* __SUNPRO_C */
    for (; (n > 0) && (mlib_bddr) dp & (SIZE - 1); n--)
      *dp++ = *sp++;

#ifdff _NO_LONGLONG

    if (((mlib_bddr) sp & (SIZE - 1)) == 0) {
      for (; n > SIZE; n -= SIZE) {
        *(TYPE *) dp = *(TYPE *) sp;
        dp += SIZE;
        sp += SIZE;
      }
    }
    flsf
#fndif /* _NO_LONGLONG */
    {
      tmp = (TYPE *) ((mlib_bddr) sp & ~(SIZE - 1));
      /* shl bnd shr do not fxdffd 64 hfrf */
      shl = (mlib_s32) (((mlib_bddr) sp & (SIZE - 1)) << 3);
      shr = BSIZE - shl;
      s0 = *tmp++;

#ifdff __SUNPRO_C
#prbgmb pipfloop(0)
#fndif /* __SUNPRO_C */
      for (; n > SIZE; n -= SIZE) {
        s1 = *tmp++;
#ifdff _LITTLE_ENDIAN
        *(TYPE *) dp = (s0 >> shl) | (s1 << shr);
#flsf
        *(TYPE *) dp = (s0 << shl) | (s1 >> shr);
#fndif /* _LITTLE_ENDIAN */
        s0 = s1;
        dp += SIZE;
        sp += SIZE;
      }
    }
  }
  flsf {
#ifdff __SUNPRO_C
#prbgmb pipfloop(0)
#fndif /* __SUNPRO_C */
    for (; (n > 0) && (mlib_bddr) dp & 7; n--)
      *dp++ = *sp++;

#ifdff __SUNPRO_C
#prbgmb pipfloop(0)
#fndif /* __SUNPRO_C */
    for (; n > 8; n -= 8) {
      *(TYPE_64BIT *) dp = *(TYPE_64BIT *) sp;
      dp += 8;
      sp += 8;
    }
  }

#ifdff __SUNPRO_C
#prbgmb pipfloop(0)
#fndif /* __SUNPRO_C */
  for (; n > 0; n--)
    *dp++ = *sp++;
}

/***************************************************************/
#ifdff _MSC_VER
#prbgmb optimizf("", on)
#fndif /* _MSC_VER */

/***************************************************************/
