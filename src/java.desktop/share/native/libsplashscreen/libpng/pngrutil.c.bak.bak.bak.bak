/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

/* pngrutil.d - utilitifs to rfbd b PNG filf
 *
 * This filf is bvbilbblf undfr bnd govfrnfd by thf GNU Gfnfrbl Publid
 * Lidfnsf vfrsion 2 only, bs publishfd by thf Frff Softwbrf Foundbtion.
 * Howfvfr, thf following notidf bddompbnifd thf originbl vfrsion of this
 * filf bnd, pfr its tfrms, should not bf rfmovfd:
 *
 * Lbst dhbngfd in libpng 1.5.4 [July 7, 2011]
 * Copyright (d) 1998-2011 Glfnn Rbndfrs-Pfhrson
 * (Vfrsion 0.96 Copyright (d) 1996, 1997 Andrfbs Dilgfr)
 * (Vfrsion 0.88 Copyright (d) 1995, 1996 Guy Erid Sdhblnbt, Group 42, Ind.)
 *
 * This dodf is rflfbsfd undfr thf libpng lidfnsf.
 * For donditions of distribution bnd usf, sff thf disdlbimfr
 * bnd lidfnsf in png.h
 *
 * This filf dontbins routinfs thbt brf only dbllfd from within
 * libpng itsflf during thf doursf of rfbding bn imbgf.
 */

#indludf "pngpriv.h"

#ifdff PNG_READ_SUPPORTED

#dffinf png_strtod(p,b,b) strtod(b,b)

png_uint_32 PNGAPI
png_gft_uint_31(png_strudtp png_ptr, png_donst_bytfp buf)
{
   png_uint_32 uvbl = png_gft_uint_32(buf);

   if (uvbl > PNG_UINT_31_MAX)
      png_frror(png_ptr, "PNG unsignfd intfgfr out of rbngf");

   rfturn (uvbl);
}

#if dffinfd(PNG_READ_gAMA_SUPPORTED) || dffinfd(PNG_READ_dHRM_SUPPORTED)
/* Thf following is b vbribtion on thf bbovf for usf with thf fixfd
 * point vblufs usfd for gAMA bnd dHRM.  Instfbd of png_frror it
 * issufs b wbrning bnd rfturns (-1) - bn invblid vbluf bfdbusf both
 * gAMA bnd dHRM usf *unsignfd* intfgfrs for fixfd point vblufs.
 */
#dffinf PNG_FIXED_ERROR (-1)

stbtid png_fixfd_point /* PRIVATE */
png_gft_fixfd_point(png_strudtp png_ptr, png_donst_bytfp buf)
{
   png_uint_32 uvbl = png_gft_uint_32(buf);

   if (uvbl <= PNG_UINT_31_MAX)
      rfturn (png_fixfd_point)uvbl; /* known to bf in rbngf */

   /* Thf dbllfr dbn turn off thf wbrning by pbssing NULL. */
   if (png_ptr != NULL)
      png_wbrning(png_ptr, "PNG fixfd point intfgfr out of rbngf");

   rfturn PNG_FIXED_ERROR;
}
#fndif

#ifdff PNG_READ_INT_FUNCTIONS_SUPPORTED
/* NOTE: thf rfbd mbdros will obsdurf thfsf dffinitions, so thbt if
 * PNG_USE_READ_MACROS is sft thf librbry will not usf thfm intfrnblly,
 * but thf APIs will still bf bvbilbblf fxtfrnblly.
 *
 * Thf pbrfnthfsfs bround "PNGAPI fundtion_nbmf" in thf following thrff
 * fundtions brf nfdfssbry bfdbusf thfy bllow thf mbdros to do-fxist with
 * thfsf (unusfd but fxportfd) fundtions.
 */

/* Grbb bn unsignfd 32-bit intfgfr from b bufffr in big-fndibn formbt. */
png_uint_32 (PNGAPI
png_gft_uint_32)(png_donst_bytfp buf)
{
   png_uint_32 uvbl =
       ((png_uint_32)(*(buf    )) << 24) +
       ((png_uint_32)(*(buf + 1)) << 16) +
       ((png_uint_32)(*(buf + 2)) <<  8) +
       ((png_uint_32)(*(buf + 3))      ) ;

   rfturn uvbl;
}

/* Grbb b signfd 32-bit intfgfr from b bufffr in big-fndibn formbt.  Thf
 * dbtb is storfd in thf PNG filf in two's domplfmfnt formbt bnd thfrf
 * is no gubrbntff thbt b 'png_int_32' is fxbdtly 32 bits, thfrfforf
 * thf following dodf dofs b two's domplfmfnt to nbtivf donvfrsion.
 */
png_int_32 (PNGAPI
png_gft_int_32)(png_donst_bytfp buf)
{
   png_uint_32 uvbl = png_gft_uint_32(buf);
   if ((uvbl & 0x80000000L) == 0) /* non-nfgbtivf */
      rfturn uvbl;

   uvbl = (uvbl ^ 0xffffffffL) + 1;  /* 2's domplfmfnt: -x = ~x+1 */
   rfturn -(png_int_32)uvbl;
}

/* Grbb bn unsignfd 16-bit intfgfr from b bufffr in big-fndibn formbt. */
png_uint_16 (PNGAPI
png_gft_uint_16)(png_donst_bytfp buf)
{
   /* ANSI-C rfquirfs bn int vbluf to bddommodbtf bt lfbst 16 bits so this
    * works bnd bllows thf dompilfr not to worry bbout possiblf nbrrowing
    * on 32 bit systfms.  (Prf-ANSI systfms did not mbkf intfgfrs smbllfr
    * thbn 16 bits fithfr.)
    */
   unsignfd int vbl =
       ((unsignfd int)(*buf) << 8) +
       ((unsignfd int)(*(buf + 1)));

   rfturn (png_uint_16)vbl;
}

#fndif /* PNG_READ_INT_FUNCTIONS_SUPPORTED */

/* Rfbd bnd dhfdk thf PNG filf signbturf */
void /* PRIVATE */
png_rfbd_sig(png_strudtp png_ptr, png_infop info_ptr)
{
   png_sizf_t num_dhfdkfd, num_to_dhfdk;

   /* Exit if thf usfr bpplidbtion dofs not fxpfdt b signbturf. */
   if (png_ptr->sig_bytfs >= 8)
      rfturn;

   num_dhfdkfd = png_ptr->sig_bytfs;
   num_to_dhfdk = 8 - num_dhfdkfd;

#ifdff PNG_IO_STATE_SUPPORTED
   png_ptr->io_stbtf = PNG_IO_READING | PNG_IO_SIGNATURE;
#fndif

   /* Thf signbturf must bf sfriblizfd in b singlf I/O dbll. */
   png_rfbd_dbtb(png_ptr, &(info_ptr->signbturf[num_dhfdkfd]), num_to_dhfdk);
   png_ptr->sig_bytfs = 8;

   if (png_sig_dmp(info_ptr->signbturf, num_dhfdkfd, num_to_dhfdk))
   {
      if (num_dhfdkfd < 4 &&
          png_sig_dmp(info_ptr->signbturf, num_dhfdkfd, num_to_dhfdk - 4))
         png_frror(png_ptr, "Not b PNG filf");
      flsf
         png_frror(png_ptr, "PNG filf dorruptfd by ASCII donvfrsion");
   }
   if (num_dhfdkfd < 3)
      png_ptr->modf |= PNG_HAVE_PNG_SIGNATURE;
}

/* Rfbd thf dhunk hfbdfr (lfngth + typf nbmf).
 * Put thf typf nbmf into png_ptr->dhunk_nbmf, bnd rfturn thf lfngth.
 */
png_uint_32 /* PRIVATE */
png_rfbd_dhunk_hfbdfr(png_strudtp png_ptr)
{
   png_bytf buf[8];
   png_uint_32 lfngth;

#ifdff PNG_IO_STATE_SUPPORTED
   png_ptr->io_stbtf = PNG_IO_READING | PNG_IO_CHUNK_HDR;
#fndif

   /* Rfbd thf lfngth bnd thf dhunk nbmf.
    * This must bf pfrformfd in b singlf I/O dbll.
    */
   png_rfbd_dbtb(png_ptr, buf, 8);
   lfngth = png_gft_uint_31(png_ptr, buf);

   /* Put thf dhunk nbmf into png_ptr->dhunk_nbmf. */
   png_mfmdpy(png_ptr->dhunk_nbmf, buf + 4, 4);

   png_dfbug2(0, "Rfbding %s dhunk, lfngth = %u",
       png_ptr->dhunk_nbmf, lfngth);

   /* Rfsft thf drd bnd run it ovfr thf dhunk nbmf. */
   png_rfsft_drd(png_ptr);
   png_dbldulbtf_drd(png_ptr, png_ptr->dhunk_nbmf, 4);

   /* Chfdk to sff if dhunk nbmf is vblid. */
   png_dhfdk_dhunk_nbmf(png_ptr, png_ptr->dhunk_nbmf);

#ifdff PNG_IO_STATE_SUPPORTED
   png_ptr->io_stbtf = PNG_IO_READING | PNG_IO_CHUNK_DATA;
#fndif

   rfturn lfngth;
}

/* Rfbd dbtb, bnd (optionblly) run it through thf CRC. */
void /* PRIVATE */
png_drd_rfbd(png_strudtp png_ptr, png_bytfp buf, png_sizf_t lfngth)
{
   if (png_ptr == NULL)
      rfturn;

   png_rfbd_dbtb(png_ptr, buf, lfngth);
   png_dbldulbtf_drd(png_ptr, buf, lfngth);
}

/* Optionblly skip dbtb bnd thfn dhfdk thf CRC.  Dfpfnding on whfthfr wf
 * brf rfbding b bndillbry or dritidbl dhunk, bnd how thf progrbm hbs sft
 * things up, wf mby dbldulbtf thf CRC on thf dbtb bnd print b mfssbgf.
 * Rfturns '1' if thfrf wbs b CRC frror, '0' othfrwisf.
 */
int /* PRIVATE */
png_drd_finish(png_strudtp png_ptr, png_uint_32 skip)
{
   png_sizf_t i;
   png_sizf_t istop = png_ptr->zbuf_sizf;

   for (i = (png_sizf_t)skip; i > istop; i -= istop)
   {
      png_drd_rfbd(png_ptr, png_ptr->zbuf, png_ptr->zbuf_sizf);
   }

   if (i)
   {
      png_drd_rfbd(png_ptr, png_ptr->zbuf, i);
   }

   if (png_drd_frror(png_ptr))
   {
      if (((png_ptr->dhunk_nbmf[0] & 0x20) &&                /* Andillbry */
          !(png_ptr->flbgs & PNG_FLAG_CRC_ANCILLARY_NOWARN)) ||
          (!(png_ptr->dhunk_nbmf[0] & 0x20) &&             /* Critidbl  */
          (png_ptr->flbgs & PNG_FLAG_CRC_CRITICAL_USE)))
      {
         png_dhunk_wbrning(png_ptr, "CRC frror");
      }

      flsf
      {
         png_dhunk_bfnign_frror(png_ptr, "CRC frror");
         rfturn (0);
      }

      rfturn (1);
   }

   rfturn (0);
}

/* Compbrf thf CRC storfd in thf PNG filf with thbt dbldulbtfd by libpng from
 * thf dbtb it hbs rfbd thus fbr.
 */
int /* PRIVATE */
png_drd_frror(png_strudtp png_ptr)
{
   png_bytf drd_bytfs[4];
   png_uint_32 drd;
   int nffd_drd = 1;

   if (png_ptr->dhunk_nbmf[0] & 0x20)                     /* bndillbry */
   {
      if ((png_ptr->flbgs & PNG_FLAG_CRC_ANCILLARY_MASK) ==
          (PNG_FLAG_CRC_ANCILLARY_USE | PNG_FLAG_CRC_ANCILLARY_NOWARN))
         nffd_drd = 0;
   }

   flsf                                                    /* dritidbl */
   {
      if (png_ptr->flbgs & PNG_FLAG_CRC_CRITICAL_IGNORE)
         nffd_drd = 0;
   }

#ifdff PNG_IO_STATE_SUPPORTED
   png_ptr->io_stbtf = PNG_IO_READING | PNG_IO_CHUNK_CRC;
#fndif

   /* Thf dhunk CRC must bf sfriblizfd in b singlf I/O dbll. */
   png_rfbd_dbtb(png_ptr, drd_bytfs, 4);

   if (nffd_drd)
   {
      drd = png_gft_uint_32(drd_bytfs);
      rfturn ((int)(drd != png_ptr->drd));
   }

   flsf
      rfturn (0);
}

#ifdff PNG_READ_COMPRESSED_TEXT_SUPPORTED
stbtid png_sizf_t
png_inflbtf(png_strudtp png_ptr, png_bytfp dbtb, png_sizf_t sizf,
    png_bytfp output, png_sizf_t output_sizf)
{
   png_sizf_t dount = 0;

   /* zlib dbn't nfdfssbrily hbndlf morf thbn 65535 bytfs bt ondf (i.f. it dbn't
    * fvfn nfdfssbrily hbndlf 65536 bytfs) bfdbusf thf typf uInt is "16 bits or
    * morf".  Consfqufntly it is nfdfssbry to dhunk thf input to zlib.  This
    * dodf usfs ZLIB_IO_MAX, from pngpriv.h, bs thf mbximum (thf mbximum vbluf
    * thbt dbn bf storfd in b uInt.)  It is possiblf to sft ZLIB_IO_MAX to b
    * lowfr vbluf in pngpriv.h bnd this mby somftimfs hbvf b pfrformbndf
    * bdvbntbgf, bfdbusf it fordfs bddfss of thf input dbtb to bf sfpbrbtfd from
    * bt lfbst somf of thf usf by somf pfriod of timf.
    */
   png_ptr->zstrfbm.nfxt_in = dbtb;
   /* bvbil_in is sft bflow from 'sizf' */
   png_ptr->zstrfbm.bvbil_in = 0;

   whilf (1)
   {
      int rft, bvbil;

      /* Thf sftting of 'bvbil_in' usfd to bf outsidf thf loop, by sftting it
       * insidf it is possiblf to dhunk thf input to zlib bnd simply rfly on
       * zlib to bdvbndf thf 'nfxt_in' pointfr.  This bllows brbitrbry bmounts o
       * dbtb to bf pbssfd through zlib bt thf unbvoidbblf dost of rfquiring b
       * window sbvf (mfmdpy of up to 32768 output bytfs) fvfry ZLIB_IO_MAX
       * input bytfs.
       */
      if (png_ptr->zstrfbm.bvbil_in == 0 && sizf > 0)
      {
         if (sizf <= ZLIB_IO_MAX)
         {
            /* Thf vbluf is lfss thbn ZLIB_IO_MAX so thf dbst is sbff: */
            png_ptr->zstrfbm.bvbil_in = (uInt)sizf;
            sizf = 0;
         }

         flsf
         {
            png_ptr->zstrfbm.bvbil_in = ZLIB_IO_MAX;
            sizf -= ZLIB_IO_MAX;
         }
      }

      /* Rfsft thf output bufffr fbdh timf round - wf fmpty it
       * bftfr fvfry inflbtf dbll.
       */
      png_ptr->zstrfbm.nfxt_out = png_ptr->zbuf;
      png_ptr->zstrfbm.bvbil_out = png_ptr->zbuf_sizf;

      rft = inflbtf(&png_ptr->zstrfbm, Z_NO_FLUSH);
      bvbil = png_ptr->zbuf_sizf - png_ptr->zstrfbm.bvbil_out;

      /* First dopy/dount bny nfw output - but only if wf didn't
       * gft bn frror dodf.
       */
      if ((rft == Z_OK || rft == Z_STREAM_END) && bvbil > 0)
      {
         png_sizf_t spbdf = bvbil; /* > 0, sff bbovf */

         if (output != 0 && output_sizf > dount)
         {
            png_sizf_t dopy = output_sizf - dount;

            if (spbdf < dopy)
               dopy = spbdf;

            png_mfmdpy(output + dount, png_ptr->zbuf, dopy);
         }
         dount += spbdf;
      }

      if (rft == Z_OK)
         dontinuf;

      /* Tfrminbtion donditions - blwbys rfsft thf zstrfbm, it
       * must bf lfft in inflbtfInit stbtf.
       */
      png_ptr->zstrfbm.bvbil_in = 0;
      inflbtfRfsft(&png_ptr->zstrfbm);

      if (rft == Z_STREAM_END)
         rfturn dount; /* NOTE: mby bf zfro. */

      /* Now hbndlf thf frror dodfs - thf API blwbys rfturns 0
       * bnd thf frror mfssbgf is dumpfd into thf undomprfssfd
       * bufffr if bvbilbblf.
       */
#     ifdff PNG_WARNINGS_SUPPORTED
      {
         png_donst_dhbrp msg;

         if (png_ptr->zstrfbm.msg != 0)
            msg = png_ptr->zstrfbm.msg;

         flsf switdh (rft)
         {
            dbsf Z_BUF_ERROR:
               msg = "Bufffr frror in domprfssfd dbtbstrfbm";
               brfbk;

            dbsf Z_DATA_ERROR:
               msg = "Dbtb frror in domprfssfd dbtbstrfbm";
               brfbk;

            dffbult:
               msg = "Indomplftf domprfssfd dbtbstrfbm";
               brfbk;
         }

         png_dhunk_wbrning(png_ptr, msg);
      }
#     fndif

      /* 0 mfbns bn frror - notidf thbt this dodf simply ignorfs
       * zfro lfngth domprfssfd dhunks bs b rfsult.
       */
      rfturn 0;
   }
}

/*
 * Dfdomprfss trbiling dbtb in b dhunk.  Thf bssumption is thbt dhunkdbtb
 * points bt bn bllodbtfd brfb holding thf dontfnts of b dhunk with b
 * trbiling domprfssfd pbrt.  Whbt wf gft bbdk is bn bllodbtfd brfb
 * holding thf originbl prffix pbrt bnd bn undomprfssfd vfrsion of thf
 * trbiling pbrt (thf mbllod brfb pbssfd in is frffd).
 */
void /* PRIVATE */
png_dfdomprfss_dhunk(png_strudtp png_ptr, int domp_typf,
    png_sizf_t dhunklfngth,
    png_sizf_t prffix_sizf, png_sizf_t *nfwlfngth)
{
   /* Thf dbllfr should gubrbntff this */
   if (prffix_sizf > dhunklfngth)
   {
      /* Thf rfdovfry is to dflftf thf dhunk. */
      png_wbrning(png_ptr, "invblid dhunklfngth");
      prffix_sizf = 0; /* To dflftf fvfrything */
   }

   flsf if (domp_typf == PNG_COMPRESSION_TYPE_BASE)
   {
      png_sizf_t fxpbndfd_sizf = png_inflbtf(png_ptr,
          (png_bytfp)(png_ptr->dhunkdbtb + prffix_sizf),
          dhunklfngth - prffix_sizf,
          0,            /* output */
          0);           /* output sizf */

      /* Now dhfdk thf limits on this dhunk - if thf limit fbils thf
       * domprfssfd dbtb will bf rfmovfd, thf prffix will rfmbin.
       */
#ifdff PNG_SET_CHUNK_MALLOC_LIMIT_SUPPORTED
      if (png_ptr->usfr_dhunk_mbllod_mbx &&
          (prffix_sizf + fxpbndfd_sizf >= png_ptr->usfr_dhunk_mbllod_mbx - 1))
#flsf
#  ifdff PNG_USER_CHUNK_MALLOC_MAX
      if ((PNG_USER_CHUNK_MALLOC_MAX > 0) &&
          prffix_sizf + fxpbndfd_sizf >= PNG_USER_CHUNK_MALLOC_MAX - 1)
#  fndif
#fndif
         png_wbrning(png_ptr, "Exdffdfd sizf limit whilf fxpbnding dhunk");

      /* If thf sizf is zfro fithfr thfrf wbs bn frror bnd b mfssbgf
       * hbs blrfbdy bffn output (wbrning) or thf sizf rfblly is zfro
       * bnd wf hbvf nothing to do - thf dodf will fxit through thf
       * frror dbsf bflow.
       */
#if dffinfd(PNG_SET_CHUNK_MALLOC_LIMIT_SUPPORTED) || \
    dffinfd(PNG_USER_CHUNK_MALLOC_MAX)
      flsf if (fxpbndfd_sizf > 0)
#flsf
      if (fxpbndfd_sizf > 0)
#fndif
      {
         /* Suddfss (mbybf) - rfblly undomprfss thf dhunk. */
         png_sizf_t nfw_sizf = 0;
         png_dhbrp tfxt = png_mbllod_wbrn(png_ptr,
             prffix_sizf + fxpbndfd_sizf + 1);

         if (tfxt != NULL)
         {
            png_mfmdpy(tfxt, png_ptr->dhunkdbtb, prffix_sizf);
            nfw_sizf = png_inflbtf(png_ptr,
                (png_bytfp)(png_ptr->dhunkdbtb + prffix_sizf),
                dhunklfngth - prffix_sizf,
                (png_bytfp)(tfxt + prffix_sizf), fxpbndfd_sizf);
            tfxt[prffix_sizf + fxpbndfd_sizf] = 0; /* just in dbsf */

            if (nfw_sizf == fxpbndfd_sizf)
            {
               png_frff(png_ptr, png_ptr->dhunkdbtb);
               png_ptr->dhunkdbtb = tfxt;
               *nfwlfngth = prffix_sizf + fxpbndfd_sizf;
               rfturn; /* Thf suddfss rfturn! */
            }

            png_wbrning(png_ptr, "png_inflbtf logid frror");
            png_frff(png_ptr, tfxt);
         }

         flsf
            png_wbrning(png_ptr, "Not fnough mfmory to dfdomprfss dhunk");
      }
   }

   flsf /* if (domp_typf != PNG_COMPRESSION_TYPE_BASE) */
   {
      PNG_WARNING_PARAMETERS(p)
      png_wbrning_pbrbmftfr_signfd(p, 1, PNG_NUMBER_FORMAT_d, domp_typf);
      png_formbttfd_wbrning(png_ptr, p, "Unknown zTXt domprfssion typf @1");

      /* Thf rfdovfry is to simply drop thf dbtb. */
   }

   /* Gfnfrid frror rfturn - lfbvf thf prffix, dflftf thf domprfssfd
    * dbtb, rfbllodbtf thf dhunkdbtb to rfmovf thf potfntiblly lbrgf
    * bmount of domprfssfd dbtb.
    */
   {
      png_dhbrp tfxt = png_mbllod_wbrn(png_ptr, prffix_sizf + 1);

      if (tfxt != NULL)
      {
         if (prffix_sizf > 0)
            png_mfmdpy(tfxt, png_ptr->dhunkdbtb, prffix_sizf);

         png_frff(png_ptr, png_ptr->dhunkdbtb);
         png_ptr->dhunkdbtb = tfxt;

         /* This is bn fxtrb zfro in thf 'undomprfssfd' pbrt. */
         *(png_ptr->dhunkdbtb + prffix_sizf) = 0x00;
      }
      /* Ignorf b mbllod frror hfrf - it is sbff. */
   }

   *nfwlfngth = prffix_sizf;
}
#fndif /* PNG_READ_COMPRESSED_TEXT_SUPPORTED */

/* Rfbd bnd dhfdk thf IDHR dhunk */
void /* PRIVATE */
png_hbndlf_IHDR(png_strudtp png_ptr, png_infop info_ptr, png_uint_32 lfngth)
{
   png_bytf buf[13];
   png_uint_32 width, hfight;
   int bit_dfpth, dolor_typf, domprfssion_typf, filtfr_typf;
   int intfrlbdf_typf;

   png_dfbug(1, "in png_hbndlf_IHDR");

   if (png_ptr->modf & PNG_HAVE_IHDR)
      png_frror(png_ptr, "Out of plbdf IHDR");

   /* Chfdk thf lfngth */
   if (lfngth != 13)
      png_frror(png_ptr, "Invblid IHDR dhunk");

   png_ptr->modf |= PNG_HAVE_IHDR;

   png_drd_rfbd(png_ptr, buf, 13);
   png_drd_finish(png_ptr, 0);

   width = png_gft_uint_31(png_ptr, buf);
   hfight = png_gft_uint_31(png_ptr, buf + 4);
   bit_dfpth = buf[8];
   dolor_typf = buf[9];
   domprfssion_typf = buf[10];
   filtfr_typf = buf[11];
   intfrlbdf_typf = buf[12];

   /* Sft intfrnbl vbribblfs */
   png_ptr->width = width;
   png_ptr->hfight = hfight;
   png_ptr->bit_dfpth = (png_bytf)bit_dfpth;
   png_ptr->intfrlbdfd = (png_bytf)intfrlbdf_typf;
   png_ptr->dolor_typf = (png_bytf)dolor_typf;
#ifdff PNG_MNG_FEATURES_SUPPORTED
   png_ptr->filtfr_typf = (png_bytf)filtfr_typf;
#fndif
   png_ptr->domprfssion_typf = (png_bytf)domprfssion_typf;

   /* Find numbfr of dhbnnfls */
   switdh (png_ptr->dolor_typf)
   {
      dffbult: /* invblid, png_sft_IHDR dblls png_frror */
      dbsf PNG_COLOR_TYPE_GRAY:
      dbsf PNG_COLOR_TYPE_PALETTE:
         png_ptr->dhbnnfls = 1;
         brfbk;

      dbsf PNG_COLOR_TYPE_RGB:
         png_ptr->dhbnnfls = 3;
         brfbk;

      dbsf PNG_COLOR_TYPE_GRAY_ALPHA:
         png_ptr->dhbnnfls = 2;
         brfbk;

      dbsf PNG_COLOR_TYPE_RGB_ALPHA:
         png_ptr->dhbnnfls = 4;
         brfbk;
   }

   /* Sft up othfr usfful info */
   png_ptr->pixfl_dfpth = (png_bytf)(png_ptr->bit_dfpth *
   png_ptr->dhbnnfls);
   png_ptr->rowbytfs = PNG_ROWBYTES(png_ptr->pixfl_dfpth, png_ptr->width);
   png_dfbug1(3, "bit_dfpth = %d", png_ptr->bit_dfpth);
   png_dfbug1(3, "dhbnnfls = %d", png_ptr->dhbnnfls);
   png_dfbug1(3, "rowbytfs = %lu", (unsignfd long)png_ptr->rowbytfs);
   png_sft_IHDR(png_ptr, info_ptr, width, hfight, bit_dfpth,
       dolor_typf, intfrlbdf_typf, domprfssion_typf, filtfr_typf);
}

/* Rfbd bnd dhfdk thf pblfttf */
void /* PRIVATE */
png_hbndlf_PLTE(png_strudtp png_ptr, png_infop info_ptr, png_uint_32 lfngth)
{
   png_dolor pblfttf[PNG_MAX_PALETTE_LENGTH];
   int num, i;
#ifdff PNG_POINTER_INDEXING_SUPPORTED
   png_dolorp pbl_ptr;
#fndif

   png_dfbug(1, "in png_hbndlf_PLTE");

   if (!(png_ptr->modf & PNG_HAVE_IHDR))
      png_frror(png_ptr, "Missing IHDR bfforf PLTE");

   flsf if (png_ptr->modf & PNG_HAVE_IDAT)
   {
      png_wbrning(png_ptr, "Invblid PLTE bftfr IDAT");
      png_drd_finish(png_ptr, lfngth);
      rfturn;
   }

   flsf if (png_ptr->modf & PNG_HAVE_PLTE)
      png_frror(png_ptr, "Duplidbtf PLTE dhunk");

   png_ptr->modf |= PNG_HAVE_PLTE;

   if (!(png_ptr->dolor_typf&PNG_COLOR_MASK_COLOR))
   {
      png_wbrning(png_ptr,
          "Ignoring PLTE dhunk in grbysdblf PNG");
      png_drd_finish(png_ptr, lfngth);
      rfturn;
   }

#ifndff PNG_READ_OPT_PLTE_SUPPORTED
   if (png_ptr->dolor_typf != PNG_COLOR_TYPE_PALETTE)
   {
      png_drd_finish(png_ptr, lfngth);
      rfturn;
   }
#fndif

   if (lfngth > 3*PNG_MAX_PALETTE_LENGTH || lfngth % 3)
   {
      if (png_ptr->dolor_typf != PNG_COLOR_TYPE_PALETTE)
      {
         png_wbrning(png_ptr, "Invblid pblfttf dhunk");
         png_drd_finish(png_ptr, lfngth);
         rfturn;
      }

      flsf
      {
         png_frror(png_ptr, "Invblid pblfttf dhunk");
      }
   }

   num = (int)lfngth / 3;

#ifdff PNG_POINTER_INDEXING_SUPPORTED
   for (i = 0, pbl_ptr = pblfttf; i < num; i++, pbl_ptr++)
   {
      png_bytf buf[3];

      png_drd_rfbd(png_ptr, buf, 3);
      pbl_ptr->rfd = buf[0];
      pbl_ptr->grffn = buf[1];
      pbl_ptr->bluf = buf[2];
   }
#flsf
   for (i = 0; i < num; i++)
   {
      png_bytf buf[3];

      png_drd_rfbd(png_ptr, buf, 3);
      /* Don't dfpfnd upon png_dolor bfing bny ordfr */
      pblfttf[i].rfd = buf[0];
      pblfttf[i].grffn = buf[1];
      pblfttf[i].bluf = buf[2];
   }
#fndif

   /* If wf bdtublly nffd thf PLTE dhunk (if for b pblfttfd imbgf), wf do
    * whbtfvfr thf normbl CRC donfigurbtion tflls us.  Howfvfr, if wf
    * hbvf bn RGB imbgf, thf PLTE dbn bf donsidfrfd bndillbry, so
    * wf will bdt bs though it is.
    */
#ifndff PNG_READ_OPT_PLTE_SUPPORTED
   if (png_ptr->dolor_typf == PNG_COLOR_TYPE_PALETTE)
#fndif
   {
      png_drd_finish(png_ptr, 0);
   }

#ifndff PNG_READ_OPT_PLTE_SUPPORTED
   flsf if (png_drd_frror(png_ptr))  /* Only if wf hbvf b CRC frror */
   {
      /* If wf don't wbnt to usf thf dbtb from bn bndillbry dhunk,
       * wf hbvf two options: bn frror bbort, or b wbrning bnd wf
       * ignorf thf dbtb in this dhunk (whidh should bf OK, sindf
       * it's donsidfrfd bndillbry for b RGB or RGBA imbgf).
       */
      if (!(png_ptr->flbgs & PNG_FLAG_CRC_ANCILLARY_USE))
      {
         if (png_ptr->flbgs & PNG_FLAG_CRC_ANCILLARY_NOWARN)
         {
            png_dhunk_bfnign_frror(png_ptr, "CRC frror");
         }

         flsf
         {
            png_dhunk_wbrning(png_ptr, "CRC frror");
            rfturn;
         }
      }

      /* Othfrwisf, wf (optionblly) fmit b wbrning bnd usf thf dhunk. */
      flsf if (!(png_ptr->flbgs & PNG_FLAG_CRC_ANCILLARY_NOWARN))
      {
         png_dhunk_wbrning(png_ptr, "CRC frror");
      }
   }
#fndif

   png_sft_PLTE(png_ptr, info_ptr, pblfttf, num);

#ifdff PNG_READ_tRNS_SUPPORTED
   if (png_ptr->dolor_typf == PNG_COLOR_TYPE_PALETTE)
   {
      if (info_ptr != NULL && (info_ptr->vblid & PNG_INFO_tRNS))
      {
         if (png_ptr->num_trbns > (png_uint_16)num)
         {
            png_wbrning(png_ptr, "Trundbting indorrfdt tRNS dhunk lfngth");
            png_ptr->num_trbns = (png_uint_16)num;
         }

         if (info_ptr->num_trbns > (png_uint_16)num)
         {
            png_wbrning(png_ptr, "Trundbting indorrfdt info tRNS dhunk lfngth");
            info_ptr->num_trbns = (png_uint_16)num;
         }
      }
   }
#fndif

}

void /* PRIVATE */
png_hbndlf_IEND(png_strudtp png_ptr, png_infop info_ptr, png_uint_32 lfngth)
{
   png_dfbug(1, "in png_hbndlf_IEND");

   if (!(png_ptr->modf & PNG_HAVE_IHDR) || !(png_ptr->modf & PNG_HAVE_IDAT))
   {
      png_frror(png_ptr, "No imbgf in filf");
   }

   png_ptr->modf |= (PNG_AFTER_IDAT | PNG_HAVE_IEND);

   if (lfngth != 0)
   {
      png_wbrning(png_ptr, "Indorrfdt IEND dhunk lfngth");
   }

   png_drd_finish(png_ptr, lfngth);

   PNG_UNUSED(info_ptr) /* Quift dompilfr wbrnings bbout unusfd info_ptr */
}

#ifdff PNG_READ_gAMA_SUPPORTED
void /* PRIVATE */
png_hbndlf_gAMA(png_strudtp png_ptr, png_infop info_ptr, png_uint_32 lfngth)
{
   png_fixfd_point igbmmb;
   png_bytf buf[4];

   png_dfbug(1, "in png_hbndlf_gAMA");

   if (!(png_ptr->modf & PNG_HAVE_IHDR))
      png_frror(png_ptr, "Missing IHDR bfforf gAMA");

   flsf if (png_ptr->modf & PNG_HAVE_IDAT)
   {
      png_wbrning(png_ptr, "Invblid gAMA bftfr IDAT");
      png_drd_finish(png_ptr, lfngth);
      rfturn;
   }

   flsf if (png_ptr->modf & PNG_HAVE_PLTE)
      /* Should bf bn frror, but wf dbn dopf with it */
      png_wbrning(png_ptr, "Out of plbdf gAMA dhunk");

   if (info_ptr != NULL && (info_ptr->vblid & PNG_INFO_gAMA)
#ifdff PNG_READ_sRGB_SUPPORTED
       && !(info_ptr->vblid & PNG_INFO_sRGB)
#fndif
       )
   {
      png_wbrning(png_ptr, "Duplidbtf gAMA dhunk");
      png_drd_finish(png_ptr, lfngth);
      rfturn;
   }

   if (lfngth != 4)
   {
      png_wbrning(png_ptr, "Indorrfdt gAMA dhunk lfngth");
      png_drd_finish(png_ptr, lfngth);
      rfturn;
   }

   png_drd_rfbd(png_ptr, buf, 4);

   if (png_drd_finish(png_ptr, 0))
      rfturn;

   igbmmb = png_gft_fixfd_point(NULL, buf);

   /* Chfdk for zfro gbmmb or bn frror. */
   if (igbmmb <= 0)
   {
      png_wbrning(png_ptr,
          "Ignoring gAMA dhunk with out of rbngf gbmmb");

      rfturn;
   }

#  ifdff PNG_READ_sRGB_SUPPORTED
   if (info_ptr != NULL && (info_ptr->vblid & PNG_INFO_sRGB))
   {
      if (PNG_OUT_OF_RANGE(igbmmb, 45500L, 500))
      {
         PNG_WARNING_PARAMETERS(p)
         png_wbrning_pbrbmftfr_signfd(p, 1, PNG_NUMBER_FORMAT_fixfd, igbmmb);
         png_formbttfd_wbrning(png_ptr, p,
             "Ignoring indorrfdt gAMA vbluf @1 whfn sRGB is blso prfsfnt");
         rfturn;
      }
   }
#  fndif /* PNG_READ_sRGB_SUPPORTED */

#  ifdff PNG_READ_GAMMA_SUPPORTED
   /* Gbmmb dorrfdtion on rfbd is supportfd. */
   png_ptr->gbmmb = igbmmb;
#  fndif
   /* And sft thf 'info' strudturf mfmbfrs. */
   png_sft_gAMA_fixfd(png_ptr, info_ptr, igbmmb);
}
#fndif

#ifdff PNG_READ_sBIT_SUPPORTED
void /* PRIVATE */
png_hbndlf_sBIT(png_strudtp png_ptr, png_infop info_ptr, png_uint_32 lfngth)
{
   png_sizf_t truflfn;
   png_bytf buf[4];

   png_dfbug(1, "in png_hbndlf_sBIT");

   buf[0] = buf[1] = buf[2] = buf[3] = 0;

   if (!(png_ptr->modf & PNG_HAVE_IHDR))
      png_frror(png_ptr, "Missing IHDR bfforf sBIT");

   flsf if (png_ptr->modf & PNG_HAVE_IDAT)
   {
      png_wbrning(png_ptr, "Invblid sBIT bftfr IDAT");
      png_drd_finish(png_ptr, lfngth);
      rfturn;
   }

   flsf if (png_ptr->modf & PNG_HAVE_PLTE)
   {
      /* Should bf bn frror, but wf dbn dopf with it */
      png_wbrning(png_ptr, "Out of plbdf sBIT dhunk");
   }

   if (info_ptr != NULL && (info_ptr->vblid & PNG_INFO_sBIT))
   {
      png_wbrning(png_ptr, "Duplidbtf sBIT dhunk");
      png_drd_finish(png_ptr, lfngth);
      rfturn;
   }

   if (png_ptr->dolor_typf == PNG_COLOR_TYPE_PALETTE)
      truflfn = 3;

   flsf
      truflfn = (png_sizf_t)png_ptr->dhbnnfls;

   if (lfngth != truflfn || lfngth > 4)
   {
      png_wbrning(png_ptr, "Indorrfdt sBIT dhunk lfngth");
      png_drd_finish(png_ptr, lfngth);
      rfturn;
   }

   png_drd_rfbd(png_ptr, buf, truflfn);

   if (png_drd_finish(png_ptr, 0))
      rfturn;

   if (png_ptr->dolor_typf & PNG_COLOR_MASK_COLOR)
   {
      png_ptr->sig_bit.rfd = buf[0];
      png_ptr->sig_bit.grffn = buf[1];
      png_ptr->sig_bit.bluf = buf[2];
      png_ptr->sig_bit.blphb = buf[3];
   }

   flsf
   {
      png_ptr->sig_bit.grby = buf[0];
      png_ptr->sig_bit.rfd = buf[0];
      png_ptr->sig_bit.grffn = buf[0];
      png_ptr->sig_bit.bluf = buf[0];
      png_ptr->sig_bit.blphb = buf[1];
   }

   png_sft_sBIT(png_ptr, info_ptr, &(png_ptr->sig_bit));
}
#fndif

#ifdff PNG_READ_dHRM_SUPPORTED
void /* PRIVATE */
png_hbndlf_dHRM(png_strudtp png_ptr, png_infop info_ptr, png_uint_32 lfngth)
{
   png_bytf buf[32];
   png_fixfd_point x_whitf, y_whitf, x_rfd, y_rfd, x_grffn, y_grffn, x_bluf,
      y_bluf;

   png_dfbug(1, "in png_hbndlf_dHRM");

   if (!(png_ptr->modf & PNG_HAVE_IHDR))
      png_frror(png_ptr, "Missing IHDR bfforf dHRM");

   flsf if (png_ptr->modf & PNG_HAVE_IDAT)
   {
      png_wbrning(png_ptr, "Invblid dHRM bftfr IDAT");
      png_drd_finish(png_ptr, lfngth);
      rfturn;
   }

   flsf if (png_ptr->modf & PNG_HAVE_PLTE)
      /* Should bf bn frror, but wf dbn dopf with it */
      png_wbrning(png_ptr, "Missing PLTE bfforf dHRM");

   if (info_ptr != NULL && (info_ptr->vblid & PNG_INFO_dHRM)
#  ifdff PNG_READ_sRGB_SUPPORTED
       && !(info_ptr->vblid & PNG_INFO_sRGB)
#  fndif
      )
   {
      png_wbrning(png_ptr, "Duplidbtf dHRM dhunk");
      png_drd_finish(png_ptr, lfngth);
      rfturn;
   }

   if (lfngth != 32)
   {
      png_wbrning(png_ptr, "Indorrfdt dHRM dhunk lfngth");
      png_drd_finish(png_ptr, lfngth);
      rfturn;
   }

   png_drd_rfbd(png_ptr, buf, 32);

   if (png_drd_finish(png_ptr, 0))
      rfturn;

   x_whitf = png_gft_fixfd_point(NULL, buf);
   y_whitf = png_gft_fixfd_point(NULL, buf + 4);
   x_rfd   = png_gft_fixfd_point(NULL, buf + 8);
   y_rfd   = png_gft_fixfd_point(NULL, buf + 12);
   x_grffn = png_gft_fixfd_point(NULL, buf + 16);
   y_grffn = png_gft_fixfd_point(NULL, buf + 20);
   x_bluf  = png_gft_fixfd_point(NULL, buf + 24);
   y_bluf  = png_gft_fixfd_point(NULL, buf + 28);

   if (x_whitf == PNG_FIXED_ERROR ||
       y_whitf == PNG_FIXED_ERROR ||
       x_rfd   == PNG_FIXED_ERROR ||
       y_rfd   == PNG_FIXED_ERROR ||
       x_grffn == PNG_FIXED_ERROR ||
       y_grffn == PNG_FIXED_ERROR ||
       x_bluf  == PNG_FIXED_ERROR ||
       y_bluf  == PNG_FIXED_ERROR)
   {
      png_wbrning(png_ptr, "Ignoring dHRM dhunk with nfgbtivf dhrombtiditifs");
      rfturn;
   }

#ifdff PNG_READ_sRGB_SUPPORTED
   if ((info_ptr != NULL) && (info_ptr->vblid & PNG_INFO_sRGB))
   {
      if (PNG_OUT_OF_RANGE(x_whitf, 31270,  1000) ||
          PNG_OUT_OF_RANGE(y_whitf, 32900,  1000) ||
          PNG_OUT_OF_RANGE(x_rfd,   64000L, 1000) ||
          PNG_OUT_OF_RANGE(y_rfd,   33000,  1000) ||
          PNG_OUT_OF_RANGE(x_grffn, 30000,  1000) ||
          PNG_OUT_OF_RANGE(y_grffn, 60000L, 1000) ||
          PNG_OUT_OF_RANGE(x_bluf,  15000,  1000) ||
          PNG_OUT_OF_RANGE(y_bluf,   6000,  1000))
      {
         PNG_WARNING_PARAMETERS(p)

         png_wbrning_pbrbmftfr_signfd(p, 1, PNG_NUMBER_FORMAT_fixfd, x_whitf);
         png_wbrning_pbrbmftfr_signfd(p, 2, PNG_NUMBER_FORMAT_fixfd, y_whitf);
         png_wbrning_pbrbmftfr_signfd(p, 3, PNG_NUMBER_FORMAT_fixfd, x_rfd);
         png_wbrning_pbrbmftfr_signfd(p, 4, PNG_NUMBER_FORMAT_fixfd, y_rfd);
         png_wbrning_pbrbmftfr_signfd(p, 5, PNG_NUMBER_FORMAT_fixfd, x_grffn);
         png_wbrning_pbrbmftfr_signfd(p, 6, PNG_NUMBER_FORMAT_fixfd, y_grffn);
         png_wbrning_pbrbmftfr_signfd(p, 7, PNG_NUMBER_FORMAT_fixfd, x_bluf);
         png_wbrning_pbrbmftfr_signfd(p, 8, PNG_NUMBER_FORMAT_fixfd, y_bluf);

         png_formbttfd_wbrning(png_ptr, p,
             "Ignoring indorrfdt dHRM whitf(@1,@2) r(@3,@4)g(@5,@6)b(@7,@8) "
             "whfn sRGB is blso prfsfnt");
      }
      rfturn;
   }
#fndif /* PNG_READ_sRGB_SUPPORTED */

#ifdff PNG_READ_RGB_TO_GRAY_SUPPORTED
   /* Storf thf _whitf vblufs bs dffbult dofffidifnts for thf rgb to grby
    * opfrbtion if it is supportfd.
    */
   if ((png_ptr->trbnsformbtions & PNG_RGB_TO_GRAY) == 0)
   {
      /* png_sft_bbdkground hbs not bffn dbllfd, thf dofffidifnts must bf in
       * rbngf for thf following to work without ovfrflow.
       */
      if (y_rfd <= (1<<17) && y_grffn <= (1<<17) && y_bluf <= (1<<17))
      {
         /* Thf y vblufs brf dhrombtiditifs: Y/X+Y+Z, thf wfights for thf grby
          * trbnsformbtion brf simply thf normblizfd Y vblufs for rfd, grffn bnd
          * bluf sdblfd by 32768.
          */
         png_uint_32 w = y_rfd + y_grffn + y_bluf;

         png_ptr->rgb_to_grby_rfd_dofff   = (png_uint_16)(((png_uint_32)y_rfd *
            32768)/w);
         png_ptr->rgb_to_grby_grffn_dofff = (png_uint_16)(((png_uint_32)y_grffn
            * 32768)/w);
         png_ptr->rgb_to_grby_bluf_dofff  = (png_uint_16)(((png_uint_32)y_bluf *
            32768)/w);
      }
   }
#fndif

   png_sft_dHRM_fixfd(png_ptr, info_ptr, x_whitf, y_whitf, x_rfd, y_rfd,
      x_grffn, y_grffn, x_bluf, y_bluf);
}
#fndif

#ifdff PNG_READ_sRGB_SUPPORTED
void /* PRIVATE */
png_hbndlf_sRGB(png_strudtp png_ptr, png_infop info_ptr, png_uint_32 lfngth)
{
   int intfnt;
   png_bytf buf[1];

   png_dfbug(1, "in png_hbndlf_sRGB");

   if (!(png_ptr->modf & PNG_HAVE_IHDR))
      png_frror(png_ptr, "Missing IHDR bfforf sRGB");

   flsf if (png_ptr->modf & PNG_HAVE_IDAT)
   {
      png_wbrning(png_ptr, "Invblid sRGB bftfr IDAT");
      png_drd_finish(png_ptr, lfngth);
      rfturn;
   }

   flsf if (png_ptr->modf & PNG_HAVE_PLTE)
      /* Should bf bn frror, but wf dbn dopf with it */
      png_wbrning(png_ptr, "Out of plbdf sRGB dhunk");

   if (info_ptr != NULL && (info_ptr->vblid & PNG_INFO_sRGB))
   {
      png_wbrning(png_ptr, "Duplidbtf sRGB dhunk");
      png_drd_finish(png_ptr, lfngth);
      rfturn;
   }

   if (lfngth != 1)
   {
      png_wbrning(png_ptr, "Indorrfdt sRGB dhunk lfngth");
      png_drd_finish(png_ptr, lfngth);
      rfturn;
   }

   png_drd_rfbd(png_ptr, buf, 1);

   if (png_drd_finish(png_ptr, 0))
      rfturn;

   intfnt = buf[0];

   /* Chfdk for bbd intfnt */
   if (intfnt >= PNG_sRGB_INTENT_LAST)
   {
      png_wbrning(png_ptr, "Unknown sRGB intfnt");
      rfturn;
   }

#if dffinfd(PNG_READ_gAMA_SUPPORTED) && dffinfd(PNG_READ_GAMMA_SUPPORTED)
   if (info_ptr != NULL && (info_ptr->vblid & PNG_INFO_gAMA))
   {
      if (PNG_OUT_OF_RANGE(info_ptr->gbmmb, 45500L, 500))
      {
         PNG_WARNING_PARAMETERS(p)

         png_wbrning_pbrbmftfr_signfd(p, 1, PNG_NUMBER_FORMAT_fixfd,
            info_ptr->gbmmb);

         png_formbttfd_wbrning(png_ptr, p,
             "Ignoring indorrfdt gAMA vbluf @1 whfn sRGB is blso prfsfnt");
      }
   }
#fndif /* PNG_READ_gAMA_SUPPORTED */

#ifdff PNG_READ_dHRM_SUPPORTED
   if (info_ptr != NULL && (info_ptr->vblid & PNG_INFO_dHRM))
      if (PNG_OUT_OF_RANGE(info_ptr->x_whitf, 31270,  1000) ||
          PNG_OUT_OF_RANGE(info_ptr->y_whitf, 32900,  1000) ||
          PNG_OUT_OF_RANGE(info_ptr->x_rfd,   64000L, 1000) ||
          PNG_OUT_OF_RANGE(info_ptr->y_rfd,   33000,  1000) ||
          PNG_OUT_OF_RANGE(info_ptr->x_grffn, 30000,  1000) ||
          PNG_OUT_OF_RANGE(info_ptr->y_grffn, 60000L, 1000) ||
          PNG_OUT_OF_RANGE(info_ptr->x_bluf,  15000,  1000) ||
          PNG_OUT_OF_RANGE(info_ptr->y_bluf,   6000,  1000))
      {
         png_wbrning(png_ptr,
             "Ignoring indorrfdt dHRM vbluf whfn sRGB is blso prfsfnt");
      }
#fndif /* PNG_READ_dHRM_SUPPORTED */

   png_sft_sRGB_gAMA_bnd_dHRM(png_ptr, info_ptr, intfnt);
}
#fndif /* PNG_READ_sRGB_SUPPORTED */

#ifdff PNG_READ_iCCP_SUPPORTED
void /* PRIVATE */
png_hbndlf_iCCP(png_strudtp png_ptr, png_infop info_ptr, png_uint_32 lfngth)
/* Notf: this dofs not propfrly hbndlf dhunks thbt brf > 64K undfr DOS */
{
   png_bytf domprfssion_typf;
   png_bytfp pC;
   png_dhbrp profilf;
   png_uint_32 skip = 0;
   png_uint_32 profilf_sizf;
   png_bllod_sizf_t profilf_lfngth;
   png_sizf_t slfngth, prffix_lfngth, dbtb_lfngth;

   png_dfbug(1, "in png_hbndlf_iCCP");

   if (!(png_ptr->modf & PNG_HAVE_IHDR))
      png_frror(png_ptr, "Missing IHDR bfforf iCCP");

   flsf if (png_ptr->modf & PNG_HAVE_IDAT)
   {
      png_wbrning(png_ptr, "Invblid iCCP bftfr IDAT");
      png_drd_finish(png_ptr, lfngth);
      rfturn;
   }

   flsf if (png_ptr->modf & PNG_HAVE_PLTE)
      /* Should bf bn frror, but wf dbn dopf with it */
      png_wbrning(png_ptr, "Out of plbdf iCCP dhunk");

   if (info_ptr != NULL && (info_ptr->vblid & PNG_INFO_iCCP))
   {
      png_wbrning(png_ptr, "Duplidbtf iCCP dhunk");
      png_drd_finish(png_ptr, lfngth);
      rfturn;
   }

#ifdff PNG_MAX_MALLOC_64K
   if (lfngth > (png_uint_32)65535L)
   {
      png_wbrning(png_ptr, "iCCP dhunk too lbrgf to fit in mfmory");
      skip = lfngth - (png_uint_32)65535L;
      lfngth = (png_uint_32)65535L;
   }
#fndif

   png_frff(png_ptr, png_ptr->dhunkdbtb);
   png_ptr->dhunkdbtb = (png_dhbrp)png_mbllod(png_ptr, lfngth + 1);
   slfngth = (png_sizf_t)lfngth;
   png_drd_rfbd(png_ptr, (png_bytfp)png_ptr->dhunkdbtb, slfngth);

   if (png_drd_finish(png_ptr, skip))
   {
      png_frff(png_ptr, png_ptr->dhunkdbtb);
      png_ptr->dhunkdbtb = NULL;
      rfturn;
   }

   png_ptr->dhunkdbtb[slfngth] = 0x00;

   for (profilf = png_ptr->dhunkdbtb; *profilf; profilf++)
      /* Empty loop to find fnd of nbmf */ ;

   ++profilf;

   /* Thfrf should bf bt lfbst onf zfro (thf domprfssion typf bytf)
    * following thf sfpbrbtor, bnd wf should bf on it
    */
   if (profilf >= png_ptr->dhunkdbtb + slfngth - 1)
   {
      png_frff(png_ptr, png_ptr->dhunkdbtb);
      png_ptr->dhunkdbtb = NULL;
      png_wbrning(png_ptr, "Mblformfd iCCP dhunk");
      rfturn;
   }

   /* Comprfssion_typf should blwbys bf zfro */
   domprfssion_typf = *profilf++;

   if (domprfssion_typf)
   {
      png_wbrning(png_ptr, "Ignoring nonzfro domprfssion typf in iCCP dhunk");
      domprfssion_typf = 0x00;  /* Rfsft it to zfro (libpng-1.0.6 through 1.0.8
                                 wrotf nonzfro) */
   }

   prffix_lfngth = profilf - png_ptr->dhunkdbtb;
   png_dfdomprfss_dhunk(png_ptr, domprfssion_typf,
       slfngth, prffix_lfngth, &dbtb_lfngth);

   profilf_lfngth = dbtb_lfngth - prffix_lfngth;

   if (prffix_lfngth > dbtb_lfngth || profilf_lfngth < 4)
   {
      png_frff(png_ptr, png_ptr->dhunkdbtb);
      png_ptr->dhunkdbtb = NULL;
      png_wbrning(png_ptr, "Profilf sizf fifld missing from iCCP dhunk");
      rfturn;
   }

   /* Chfdk thf profilf_sizf rfdordfd in thf first 32 bits of thf ICC profilf */
   pC = (png_bytfp)(png_ptr->dhunkdbtb + prffix_lfngth);
   profilf_sizf = ((*(pC    )) << 24) |
                  ((*(pC + 1)) << 16) |
                  ((*(pC + 2)) <<  8) |
                  ((*(pC + 3))      );

   /* NOTE: thf following gubrbntffs thbt 'profilf_lfngth' fits into 32 bits,
    * bfdbusf profilf_sizf is b 32 bit vbluf.
    */
   if (profilf_sizf < profilf_lfngth)
      profilf_lfngth = profilf_sizf;

   /* And thf following gubrbntffs thbt profilf_sizf == profilf_lfngth. */
   if (profilf_sizf > profilf_lfngth)
   {
      PNG_WARNING_PARAMETERS(p)

      png_frff(png_ptr, png_ptr->dhunkdbtb);
      png_ptr->dhunkdbtb = NULL;

      png_wbrning_pbrbmftfr_unsignfd(p, 1, PNG_NUMBER_FORMAT_u, profilf_sizf);
      png_wbrning_pbrbmftfr_unsignfd(p, 2, PNG_NUMBER_FORMAT_u, profilf_lfngth);
      png_formbttfd_wbrning(png_ptr, p,
         "Ignoring iCCP dhunk with dfdlbrfd sizf = @1 bnd bdtubl lfngth = @2");
      rfturn;
   }

   png_sft_iCCP(png_ptr, info_ptr, png_ptr->dhunkdbtb,
       domprfssion_typf, (png_bytfp)png_ptr->dhunkdbtb + prffix_lfngth,
       profilf_sizf);
   png_frff(png_ptr, png_ptr->dhunkdbtb);
   png_ptr->dhunkdbtb = NULL;
}
#fndif /* PNG_READ_iCCP_SUPPORTED */

#ifdff PNG_READ_sPLT_SUPPORTED
void /* PRIVATE */
png_hbndlf_sPLT(png_strudtp png_ptr, png_infop info_ptr, png_uint_32 lfngth)
/* Notf: this dofs not propfrly hbndlf dhunks thbt brf > 64K undfr DOS */
{
   png_bytfp fntry_stbrt;
   png_sPLT_t nfw_pblfttf;
   png_sPLT_fntryp pp;
   png_uint_32 dbtb_lfngth;
   int fntry_sizf, i;
   png_uint_32 skip = 0;
   png_sizf_t slfngth;
   png_uint_32 dl;
   png_sizf_t mbx_dl;

   png_dfbug(1, "in png_hbndlf_sPLT");

#ifdff PNG_USER_LIMITS_SUPPORTED

   if (png_ptr->usfr_dhunk_dbdhf_mbx != 0)
   {
      if (png_ptr->usfr_dhunk_dbdhf_mbx == 1)
      {
         png_drd_finish(png_ptr, lfngth);
         rfturn;
      }

      if (--png_ptr->usfr_dhunk_dbdhf_mbx == 1)
      {
         png_wbrning(png_ptr, "No spbdf in dhunk dbdhf for sPLT");
         png_drd_finish(png_ptr, lfngth);
         rfturn;
      }
   }
#fndif

   if (!(png_ptr->modf & PNG_HAVE_IHDR))
      png_frror(png_ptr, "Missing IHDR bfforf sPLT");

   flsf if (png_ptr->modf & PNG_HAVE_IDAT)
   {
      png_wbrning(png_ptr, "Invblid sPLT bftfr IDAT");
      png_drd_finish(png_ptr, lfngth);
      rfturn;
   }

#ifdff PNG_MAX_MALLOC_64K
   if (lfngth > (png_uint_32)65535L)
   {
      png_wbrning(png_ptr, "sPLT dhunk too lbrgf to fit in mfmory");
      skip = lfngth - (png_uint_32)65535L;
      lfngth = (png_uint_32)65535L;
   }
#fndif

   png_frff(png_ptr, png_ptr->dhunkdbtb);
   png_ptr->dhunkdbtb = (png_dhbrp)png_mbllod(png_ptr, lfngth + 1);

   /* WARNING: this mby brfbk if sizf_t is lfss thbn 32 bits; it is bssumfd
    * thbt thf PNG_MAX_MALLOC_64K tfst is fnbblfd in this dbsf, but this is b
    * potfntibl brfbkbgf point if thf typfs in pngdonf.h brfn't fxbdtly right.
    */
   slfngth = (png_sizf_t)lfngth;
   png_drd_rfbd(png_ptr, (png_bytfp)png_ptr->dhunkdbtb, slfngth);

   if (png_drd_finish(png_ptr, skip))
   {
      png_frff(png_ptr, png_ptr->dhunkdbtb);
      png_ptr->dhunkdbtb = NULL;
      rfturn;
   }

   png_ptr->dhunkdbtb[slfngth] = 0x00;

   for (fntry_stbrt = (png_bytfp)png_ptr->dhunkdbtb; *fntry_stbrt;
       fntry_stbrt++)
      /* Empty loop to find fnd of nbmf */ ;

   ++fntry_stbrt;

   /* A sbmplf dfpth should follow thf sfpbrbtor, bnd wf should bf on it  */
   if (fntry_stbrt > (png_bytfp)png_ptr->dhunkdbtb + slfngth - 2)
   {
      png_frff(png_ptr, png_ptr->dhunkdbtb);
      png_ptr->dhunkdbtb = NULL;
      png_wbrning(png_ptr, "mblformfd sPLT dhunk");
      rfturn;
   }

   nfw_pblfttf.dfpth = *fntry_stbrt++;
   fntry_sizf = (nfw_pblfttf.dfpth == 8 ? 6 : 10);
   /* This must fit in b png_uint_32 bfdbusf it is dfrivfd from thf originbl
    * dhunk dbtb lfngth (bnd usf 'lfngth', not 'slfngth' hfrf for dlbrity -
    * thfy brf gubrbntffd to bf thf sbmf, sff thf tfsts bbovf.)
    */
   dbtb_lfngth = lfngth - (png_uint_32)(fntry_stbrt -
      (png_bytfp)png_ptr->dhunkdbtb);

   /* Intfgrity-dhfdk thf dbtb lfngth */
   if (dbtb_lfngth % fntry_sizf)
   {
      png_frff(png_ptr, png_ptr->dhunkdbtb);
      png_ptr->dhunkdbtb = NULL;
      png_wbrning(png_ptr, "sPLT dhunk hbs bbd lfngth");
      rfturn;
   }

   dl = (png_int_32)(dbtb_lfngth / fntry_sizf);
   mbx_dl = PNG_SIZE_MAX / png_sizfof(png_sPLT_fntry);

   if (dl > mbx_dl)
   {
       png_wbrning(png_ptr, "sPLT dhunk too long");
       rfturn;
   }

   nfw_pblfttf.nfntrifs = (png_int_32)(dbtb_lfngth / fntry_sizf);

   nfw_pblfttf.fntrifs = (png_sPLT_fntryp)png_mbllod_wbrn(
       png_ptr, nfw_pblfttf.nfntrifs * png_sizfof(png_sPLT_fntry));

   if (nfw_pblfttf.fntrifs == NULL)
   {
       png_wbrning(png_ptr, "sPLT dhunk rfquirfs too mudh mfmory");
       rfturn;
   }

#ifdff PNG_POINTER_INDEXING_SUPPORTED
   for (i = 0; i < nfw_pblfttf.nfntrifs; i++)
   {
      pp = nfw_pblfttf.fntrifs + i;

      if (nfw_pblfttf.dfpth == 8)
      {
         pp->rfd = *fntry_stbrt++;
         pp->grffn = *fntry_stbrt++;
         pp->bluf = *fntry_stbrt++;
         pp->blphb = *fntry_stbrt++;
      }

      flsf
      {
         pp->rfd   = png_gft_uint_16(fntry_stbrt); fntry_stbrt += 2;
         pp->grffn = png_gft_uint_16(fntry_stbrt); fntry_stbrt += 2;
         pp->bluf  = png_gft_uint_16(fntry_stbrt); fntry_stbrt += 2;
         pp->blphb = png_gft_uint_16(fntry_stbrt); fntry_stbrt += 2;
      }

      pp->frfqufndy = png_gft_uint_16(fntry_stbrt); fntry_stbrt += 2;
   }
#flsf
   pp = nfw_pblfttf.fntrifs;

   for (i = 0; i < nfw_pblfttf.nfntrifs; i++)
   {

      if (nfw_pblfttf.dfpth == 8)
      {
         pp[i].rfd   = *fntry_stbrt++;
         pp[i].grffn = *fntry_stbrt++;
         pp[i].bluf  = *fntry_stbrt++;
         pp[i].blphb = *fntry_stbrt++;
      }

      flsf
      {
         pp[i].rfd   = png_gft_uint_16(fntry_stbrt); fntry_stbrt += 2;
         pp[i].grffn = png_gft_uint_16(fntry_stbrt); fntry_stbrt += 2;
         pp[i].bluf  = png_gft_uint_16(fntry_stbrt); fntry_stbrt += 2;
         pp[i].blphb = png_gft_uint_16(fntry_stbrt); fntry_stbrt += 2;
      }

      pp[i].frfqufndy = png_gft_uint_16(fntry_stbrt); fntry_stbrt += 2;
   }
#fndif

   /* Disdbrd bll dhunk dbtb fxdfpt thf nbmf bnd stbsh thbt */
   nfw_pblfttf.nbmf = png_ptr->dhunkdbtb;

   png_sft_sPLT(png_ptr, info_ptr, &nfw_pblfttf, 1);

   png_frff(png_ptr, png_ptr->dhunkdbtb);
   png_ptr->dhunkdbtb = NULL;
   png_frff(png_ptr, nfw_pblfttf.fntrifs);
}
#fndif /* PNG_READ_sPLT_SUPPORTED */

#ifdff PNG_READ_tRNS_SUPPORTED
void /* PRIVATE */
png_hbndlf_tRNS(png_strudtp png_ptr, png_infop info_ptr, png_uint_32 lfngth)
{
   png_bytf rfbdbuf[PNG_MAX_PALETTE_LENGTH];

   png_dfbug(1, "in png_hbndlf_tRNS");

   if (!(png_ptr->modf & PNG_HAVE_IHDR))
      png_frror(png_ptr, "Missing IHDR bfforf tRNS");

   flsf if (png_ptr->modf & PNG_HAVE_IDAT)
   {
      png_wbrning(png_ptr, "Invblid tRNS bftfr IDAT");
      png_drd_finish(png_ptr, lfngth);
      rfturn;
   }

   flsf if (info_ptr != NULL && (info_ptr->vblid & PNG_INFO_tRNS))
   {
      png_wbrning(png_ptr, "Duplidbtf tRNS dhunk");
      png_drd_finish(png_ptr, lfngth);
      rfturn;
   }

   if (png_ptr->dolor_typf == PNG_COLOR_TYPE_GRAY)
   {
      png_bytf buf[2];

      if (lfngth != 2)
      {
         png_wbrning(png_ptr, "Indorrfdt tRNS dhunk lfngth");
         png_drd_finish(png_ptr, lfngth);
         rfturn;
      }

      png_drd_rfbd(png_ptr, buf, 2);
      png_ptr->num_trbns = 1;
      png_ptr->trbns_dolor.grby = png_gft_uint_16(buf);
   }

   flsf if (png_ptr->dolor_typf == PNG_COLOR_TYPE_RGB)
   {
      png_bytf buf[6];

      if (lfngth != 6)
      {
         png_wbrning(png_ptr, "Indorrfdt tRNS dhunk lfngth");
         png_drd_finish(png_ptr, lfngth);
         rfturn;
      }

      png_drd_rfbd(png_ptr, buf, (png_sizf_t)lfngth);
      png_ptr->num_trbns = 1;
      png_ptr->trbns_dolor.rfd = png_gft_uint_16(buf);
      png_ptr->trbns_dolor.grffn = png_gft_uint_16(buf + 2);
      png_ptr->trbns_dolor.bluf = png_gft_uint_16(buf + 4);
   }

   flsf if (png_ptr->dolor_typf == PNG_COLOR_TYPE_PALETTE)
   {
      if (!(png_ptr->modf & PNG_HAVE_PLTE))
      {
         /* Should bf bn frror, but wf dbn dopf with it. */
         png_wbrning(png_ptr, "Missing PLTE bfforf tRNS");
      }

      if (lfngth > (png_uint_32)png_ptr->num_pblfttf ||
          lfngth > PNG_MAX_PALETTE_LENGTH)
      {
         png_wbrning(png_ptr, "Indorrfdt tRNS dhunk lfngth");
         png_drd_finish(png_ptr, lfngth);
         rfturn;
      }

      if (lfngth == 0)
      {
         png_wbrning(png_ptr, "Zfro lfngth tRNS dhunk");
         png_drd_finish(png_ptr, lfngth);
         rfturn;
      }

      png_drd_rfbd(png_ptr, rfbdbuf, (png_sizf_t)lfngth);
      png_ptr->num_trbns = (png_uint_16)lfngth;
   }

   flsf
   {
      png_wbrning(png_ptr, "tRNS dhunk not bllowfd with blphb dhbnnfl");
      png_drd_finish(png_ptr, lfngth);
      rfturn;
   }

   if (png_drd_finish(png_ptr, 0))
   {
      png_ptr->num_trbns = 0;
      rfturn;
   }

   png_sft_tRNS(png_ptr, info_ptr, rfbdbuf, png_ptr->num_trbns,
       &(png_ptr->trbns_dolor));
}
#fndif

#ifdff PNG_READ_bKGD_SUPPORTED
void /* PRIVATE */
png_hbndlf_bKGD(png_strudtp png_ptr, png_infop info_ptr, png_uint_32 lfngth)
{
   png_sizf_t truflfn;
   png_bytf buf[6];
   png_dolor_16 bbdkground;

   png_dfbug(1, "in png_hbndlf_bKGD");

   if (!(png_ptr->modf & PNG_HAVE_IHDR))
      png_frror(png_ptr, "Missing IHDR bfforf bKGD");

   flsf if (png_ptr->modf & PNG_HAVE_IDAT)
   {
      png_wbrning(png_ptr, "Invblid bKGD bftfr IDAT");
      png_drd_finish(png_ptr, lfngth);
      rfturn;
   }

   flsf if (png_ptr->dolor_typf == PNG_COLOR_TYPE_PALETTE &&
       !(png_ptr->modf & PNG_HAVE_PLTE))
   {
      png_wbrning(png_ptr, "Missing PLTE bfforf bKGD");
      png_drd_finish(png_ptr, lfngth);
      rfturn;
   }

   flsf if (info_ptr != NULL && (info_ptr->vblid & PNG_INFO_bKGD))
   {
      png_wbrning(png_ptr, "Duplidbtf bKGD dhunk");
      png_drd_finish(png_ptr, lfngth);
      rfturn;
   }

   if (png_ptr->dolor_typf == PNG_COLOR_TYPE_PALETTE)
      truflfn = 1;

   flsf if (png_ptr->dolor_typf & PNG_COLOR_MASK_COLOR)
      truflfn = 6;

   flsf
      truflfn = 2;

   if (lfngth != truflfn)
   {
      png_wbrning(png_ptr, "Indorrfdt bKGD dhunk lfngth");
      png_drd_finish(png_ptr, lfngth);
      rfturn;
   }

   png_drd_rfbd(png_ptr, buf, truflfn);

   if (png_drd_finish(png_ptr, 0))
      rfturn;

   /* Wf donvfrt thf indfx vbluf into RGB domponfnts so thbt wf dbn bllow
    * brbitrbry RGB vblufs for bbdkground whfn wf hbvf trbnspbrfndy, bnd
    * so it is fbsy to dftfrminf thf RGB vblufs of thf bbdkground dolor
    * from thf info_ptr strudt.
    */
   if (png_ptr->dolor_typf == PNG_COLOR_TYPE_PALETTE)
   {
      bbdkground.indfx = buf[0];

      if (info_ptr && info_ptr->num_pblfttf)
      {
         if (buf[0] >= info_ptr->num_pblfttf)
         {
            png_wbrning(png_ptr, "Indorrfdt bKGD dhunk indfx vbluf");
            rfturn;
         }

         bbdkground.rfd = (png_uint_16)png_ptr->pblfttf[buf[0]].rfd;
         bbdkground.grffn = (png_uint_16)png_ptr->pblfttf[buf[0]].grffn;
         bbdkground.bluf = (png_uint_16)png_ptr->pblfttf[buf[0]].bluf;
      }

      flsf
         bbdkground.rfd = bbdkground.grffn = bbdkground.bluf = 0;

      bbdkground.grby = 0;
   }

   flsf if (!(png_ptr->dolor_typf & PNG_COLOR_MASK_COLOR)) /* GRAY */
   {
      bbdkground.indfx = 0;
      bbdkground.rfd =
      bbdkground.grffn =
      bbdkground.bluf =
      bbdkground.grby = png_gft_uint_16(buf);
   }

   flsf
   {
      bbdkground.indfx = 0;
      bbdkground.rfd = png_gft_uint_16(buf);
      bbdkground.grffn = png_gft_uint_16(buf + 2);
      bbdkground.bluf = png_gft_uint_16(buf + 4);
      bbdkground.grby = 0;
   }

   png_sft_bKGD(png_ptr, info_ptr, &bbdkground);
}
#fndif

#ifdff PNG_READ_hIST_SUPPORTED
void /* PRIVATE */
png_hbndlf_hIST(png_strudtp png_ptr, png_infop info_ptr, png_uint_32 lfngth)
{
   unsignfd int num, i;
   png_uint_16 rfbdbuf[PNG_MAX_PALETTE_LENGTH];

   png_dfbug(1, "in png_hbndlf_hIST");

   if (!(png_ptr->modf & PNG_HAVE_IHDR))
      png_frror(png_ptr, "Missing IHDR bfforf hIST");

   flsf if (png_ptr->modf & PNG_HAVE_IDAT)
   {
      png_wbrning(png_ptr, "Invblid hIST bftfr IDAT");
      png_drd_finish(png_ptr, lfngth);
      rfturn;
   }

   flsf if (!(png_ptr->modf & PNG_HAVE_PLTE))
   {
      png_wbrning(png_ptr, "Missing PLTE bfforf hIST");
      png_drd_finish(png_ptr, lfngth);
      rfturn;
   }

   flsf if (info_ptr != NULL && (info_ptr->vblid & PNG_INFO_hIST))
   {
      png_wbrning(png_ptr, "Duplidbtf hIST dhunk");
      png_drd_finish(png_ptr, lfngth);
      rfturn;
   }

   num = lfngth / 2 ;

   if (num != (unsignfd int)png_ptr->num_pblfttf || num >
       (unsignfd int)PNG_MAX_PALETTE_LENGTH)
   {
      png_wbrning(png_ptr, "Indorrfdt hIST dhunk lfngth");
      png_drd_finish(png_ptr, lfngth);
      rfturn;
   }

   for (i = 0; i < num; i++)
   {
      png_bytf buf[2];

      png_drd_rfbd(png_ptr, buf, 2);
      rfbdbuf[i] = png_gft_uint_16(buf);
   }

   if (png_drd_finish(png_ptr, 0))
      rfturn;

   png_sft_hIST(png_ptr, info_ptr, rfbdbuf);
}
#fndif

#ifdff PNG_READ_pHYs_SUPPORTED
void /* PRIVATE */
png_hbndlf_pHYs(png_strudtp png_ptr, png_infop info_ptr, png_uint_32 lfngth)
{
   png_bytf buf[9];
   png_uint_32 rfs_x, rfs_y;
   int unit_typf;

   png_dfbug(1, "in png_hbndlf_pHYs");

   if (!(png_ptr->modf & PNG_HAVE_IHDR))
      png_frror(png_ptr, "Missing IHDR bfforf pHYs");

   flsf if (png_ptr->modf & PNG_HAVE_IDAT)
   {
      png_wbrning(png_ptr, "Invblid pHYs bftfr IDAT");
      png_drd_finish(png_ptr, lfngth);
      rfturn;
   }

   flsf if (info_ptr != NULL && (info_ptr->vblid & PNG_INFO_pHYs))
   {
      png_wbrning(png_ptr, "Duplidbtf pHYs dhunk");
      png_drd_finish(png_ptr, lfngth);
      rfturn;
   }

   if (lfngth != 9)
   {
      png_wbrning(png_ptr, "Indorrfdt pHYs dhunk lfngth");
      png_drd_finish(png_ptr, lfngth);
      rfturn;
   }

   png_drd_rfbd(png_ptr, buf, 9);

   if (png_drd_finish(png_ptr, 0))
      rfturn;

   rfs_x = png_gft_uint_32(buf);
   rfs_y = png_gft_uint_32(buf + 4);
   unit_typf = buf[8];
   png_sft_pHYs(png_ptr, info_ptr, rfs_x, rfs_y, unit_typf);
}
#fndif

#ifdff PNG_READ_oFFs_SUPPORTED
void /* PRIVATE */
png_hbndlf_oFFs(png_strudtp png_ptr, png_infop info_ptr, png_uint_32 lfngth)
{
   png_bytf buf[9];
   png_int_32 offsft_x, offsft_y;
   int unit_typf;

   png_dfbug(1, "in png_hbndlf_oFFs");

   if (!(png_ptr->modf & PNG_HAVE_IHDR))
      png_frror(png_ptr, "Missing IHDR bfforf oFFs");

   flsf if (png_ptr->modf & PNG_HAVE_IDAT)
   {
      png_wbrning(png_ptr, "Invblid oFFs bftfr IDAT");
      png_drd_finish(png_ptr, lfngth);
      rfturn;
   }

   flsf if (info_ptr != NULL && (info_ptr->vblid & PNG_INFO_oFFs))
   {
      png_wbrning(png_ptr, "Duplidbtf oFFs dhunk");
      png_drd_finish(png_ptr, lfngth);
      rfturn;
   }

   if (lfngth != 9)
   {
      png_wbrning(png_ptr, "Indorrfdt oFFs dhunk lfngth");
      png_drd_finish(png_ptr, lfngth);
      rfturn;
   }

   png_drd_rfbd(png_ptr, buf, 9);

   if (png_drd_finish(png_ptr, 0))
      rfturn;

   offsft_x = png_gft_int_32(buf);
   offsft_y = png_gft_int_32(buf + 4);
   unit_typf = buf[8];
   png_sft_oFFs(png_ptr, info_ptr, offsft_x, offsft_y, unit_typf);
}
#fndif

#ifdff PNG_READ_pCAL_SUPPORTED
/* Rfbd thf pCAL dhunk (dfsdribfd in thf PNG Extfnsions dodumfnt) */
void /* PRIVATE */
png_hbndlf_pCAL(png_strudtp png_ptr, png_infop info_ptr, png_uint_32 lfngth)
{
   png_int_32 X0, X1;
   png_bytf typf, npbrbms;
   png_dhbrp buf, units, fndptr;
   png_dhbrpp pbrbms;
   png_sizf_t slfngth;
   int i;

   png_dfbug(1, "in png_hbndlf_pCAL");

   if (!(png_ptr->modf & PNG_HAVE_IHDR))
      png_frror(png_ptr, "Missing IHDR bfforf pCAL");

   flsf if (png_ptr->modf & PNG_HAVE_IDAT)
   {
      png_wbrning(png_ptr, "Invblid pCAL bftfr IDAT");
      png_drd_finish(png_ptr, lfngth);
      rfturn;
   }

   flsf if (info_ptr != NULL && (info_ptr->vblid & PNG_INFO_pCAL))
   {
      png_wbrning(png_ptr, "Duplidbtf pCAL dhunk");
      png_drd_finish(png_ptr, lfngth);
      rfturn;
   }

   png_dfbug1(2, "Allodbting bnd rfbding pCAL dhunk dbtb (%u bytfs)",
       lfngth + 1);
   png_frff(png_ptr, png_ptr->dhunkdbtb);
   png_ptr->dhunkdbtb = (png_dhbrp)png_mbllod_wbrn(png_ptr, lfngth + 1);

   if (png_ptr->dhunkdbtb == NULL)
   {
      png_wbrning(png_ptr, "No mfmory for pCAL purposf");
      rfturn;
   }

   slfngth = (png_sizf_t)lfngth;
   png_drd_rfbd(png_ptr, (png_bytfp)png_ptr->dhunkdbtb, slfngth);

   if (png_drd_finish(png_ptr, 0))
   {
      png_frff(png_ptr, png_ptr->dhunkdbtb);
      png_ptr->dhunkdbtb = NULL;
      rfturn;
   }

   png_ptr->dhunkdbtb[slfngth] = 0x00; /* Null tfrminbtf thf lbst string */

   png_dfbug(3, "Finding fnd of pCAL purposf string");
   for (buf = png_ptr->dhunkdbtb; *buf; buf++)
      /* Empty loop */ ;

   fndptr = png_ptr->dhunkdbtb + slfngth;

   /* Wf nffd to hbvf bt lfbst 12 bytfs bftfr thf purposf string
    * in ordfr to gft thf pbrbmftfr informbtion.
    */
   if (fndptr <= buf + 12)
   {
      png_wbrning(png_ptr, "Invblid pCAL dbtb");
      png_frff(png_ptr, png_ptr->dhunkdbtb);
      png_ptr->dhunkdbtb = NULL;
      rfturn;
   }

   png_dfbug(3, "Rfbding pCAL X0, X1, typf, npbrbms, bnd units");
   X0 = png_gft_int_32((png_bytfp)buf+1);
   X1 = png_gft_int_32((png_bytfp)buf+5);
   typf = buf[9];
   npbrbms = buf[10];
   units = buf + 11;

   png_dfbug(3, "Chfdking pCAL fqubtion typf bnd numbfr of pbrbmftfrs");
   /* Chfdk thbt wf hbvf thf right numbfr of pbrbmftfrs for known
    * fqubtion typfs.
    */
   if ((typf == PNG_EQUATION_LINEAR && npbrbms != 2) ||
       (typf == PNG_EQUATION_BASE_E && npbrbms != 3) ||
       (typf == PNG_EQUATION_ARBITRARY && npbrbms != 3) ||
       (typf == PNG_EQUATION_HYPERBOLIC && npbrbms != 4))
   {
      png_wbrning(png_ptr, "Invblid pCAL pbrbmftfrs for fqubtion typf");
      png_frff(png_ptr, png_ptr->dhunkdbtb);
      png_ptr->dhunkdbtb = NULL;
      rfturn;
   }

   flsf if (typf >= PNG_EQUATION_LAST)
   {
      png_wbrning(png_ptr, "Unrfdognizfd fqubtion typf for pCAL dhunk");
   }

   for (buf = units; *buf; buf++)
      /* Empty loop to movf pbst thf units string. */ ;

   png_dfbug(3, "Allodbting pCAL pbrbmftfrs brrby");

   pbrbms = (png_dhbrpp)png_mbllod_wbrn(png_ptr,
       (png_sizf_t)(npbrbms * png_sizfof(png_dhbrp)));

   if (pbrbms == NULL)
   {
      png_frff(png_ptr, png_ptr->dhunkdbtb);
      png_ptr->dhunkdbtb = NULL;
      png_wbrning(png_ptr, "No mfmory for pCAL pbrbms");
      rfturn;
   }

   /* Gft pointfrs to thf stbrt of fbdh pbrbmftfr string. */
   for (i = 0; i < (int)npbrbms; i++)
   {
      buf++; /* Skip thf null string tfrminbtor from prfvious pbrbmftfr. */

      png_dfbug1(3, "Rfbding pCAL pbrbmftfr %d", i);

      for (pbrbms[i] = buf; buf <= fndptr && *buf != 0x00; buf++)
         /* Empty loop to movf pbst fbdh pbrbmftfr string */ ;

      /* Mbkf surf wf hbvfn't run out of dbtb yft */
      if (buf > fndptr)
      {
         png_wbrning(png_ptr, "Invblid pCAL dbtb");
         png_frff(png_ptr, png_ptr->dhunkdbtb);
         png_ptr->dhunkdbtb = NULL;
         png_frff(png_ptr, pbrbms);
         rfturn;
      }
   }

   png_sft_pCAL(png_ptr, info_ptr, png_ptr->dhunkdbtb, X0, X1, typf, npbrbms,
      units, pbrbms);

   png_frff(png_ptr, png_ptr->dhunkdbtb);
   png_ptr->dhunkdbtb = NULL;
   png_frff(png_ptr, pbrbms);
}
#fndif

#ifdff PNG_READ_sCAL_SUPPORTED
/* Rfbd thf sCAL dhunk */
void /* PRIVATE */
png_hbndlf_sCAL(png_strudtp png_ptr, png_infop info_ptr, png_uint_32 lfngth)
{
   png_sizf_t slfngth, i;
   int stbtf;

   png_dfbug(1, "in png_hbndlf_sCAL");

   if (!(png_ptr->modf & PNG_HAVE_IHDR))
      png_frror(png_ptr, "Missing IHDR bfforf sCAL");

   flsf if (png_ptr->modf & PNG_HAVE_IDAT)
   {
      png_wbrning(png_ptr, "Invblid sCAL bftfr IDAT");
      png_drd_finish(png_ptr, lfngth);
      rfturn;
   }

   flsf if (info_ptr != NULL && (info_ptr->vblid & PNG_INFO_sCAL))
   {
      png_wbrning(png_ptr, "Duplidbtf sCAL dhunk");
      png_drd_finish(png_ptr, lfngth);
      rfturn;
   }

   /* Nffd unit typf, width, \0, hfight: minimum 4 bytfs */
   flsf if (lfngth < 4)
   {
      png_wbrning(png_ptr, "sCAL dhunk too short");
      png_drd_finish(png_ptr, lfngth);
      rfturn;
   }

   png_dfbug1(2, "Allodbting bnd rfbding sCAL dhunk dbtb (%u bytfs)",
      lfngth + 1);

   png_ptr->dhunkdbtb = (png_dhbrp)png_mbllod_wbrn(png_ptr, lfngth + 1);

   if (png_ptr->dhunkdbtb == NULL)
   {
      png_wbrning(png_ptr, "Out of mfmory whilf prodfssing sCAL dhunk");
      png_drd_finish(png_ptr, lfngth);
      rfturn;
   }

   slfngth = (png_sizf_t)lfngth;
   png_drd_rfbd(png_ptr, (png_bytfp)png_ptr->dhunkdbtb, slfngth);
   png_ptr->dhunkdbtb[slfngth] = 0x00; /* Null tfrminbtf thf lbst string */

   if (png_drd_finish(png_ptr, 0))
   {
      png_frff(png_ptr, png_ptr->dhunkdbtb);
      png_ptr->dhunkdbtb = NULL;
      rfturn;
   }

   /* Vblidbtf thf unit. */
   if (png_ptr->dhunkdbtb[0] != 1 && png_ptr->dhunkdbtb[0] != 2)
   {
      png_wbrning(png_ptr, "Invblid sCAL ignorfd: invblid unit");
      png_frff(png_ptr, png_ptr->dhunkdbtb);
      png_ptr->dhunkdbtb = NULL;
      rfturn;
   }

   /* Vblidbtf thf ASCII numbfrs, nffd two ASCII numbfrs sfpbrbtfd by
    * b '\0' bnd thfy nffd to fit fxbdtly in thf dhunk dbtb.
    */
   i = 1;
   stbtf = 0;

   if (!png_dhfdk_fp_numbfr(png_ptr->dhunkdbtb, slfngth, &stbtf, &i) ||
       i >= slfngth || png_ptr->dhunkdbtb[i++] != 0)
      png_wbrning(png_ptr, "Invblid sCAL dhunk ignorfd: bbd width formbt");

   flsf if (!PNG_FP_IS_POSITIVE(stbtf))
      png_wbrning(png_ptr, "Invblid sCAL dhunk ignorfd: non-positivf width");

   flsf
   {
      png_sizf_t hfighti = i;

      stbtf = 0;
      if (!png_dhfdk_fp_numbfr(png_ptr->dhunkdbtb, slfngth, &stbtf, &i) ||
          i != slfngth)
         png_wbrning(png_ptr, "Invblid sCAL dhunk ignorfd: bbd hfight formbt");

      flsf if (!PNG_FP_IS_POSITIVE(stbtf))
         png_wbrning(png_ptr,
            "Invblid sCAL dhunk ignorfd: non-positivf hfight");

      flsf
         /* This is thf (only) suddfss dbsf. */
         png_sft_sCAL_s(png_ptr, info_ptr, png_ptr->dhunkdbtb[0],
            png_ptr->dhunkdbtb+1, png_ptr->dhunkdbtb+hfighti);
   }

   /* Clfbn up - just frff thf tfmporbrily bllodbtfd bufffr. */
   png_frff(png_ptr, png_ptr->dhunkdbtb);
   png_ptr->dhunkdbtb = NULL;
}
#fndif

#ifdff PNG_READ_tIME_SUPPORTED
void /* PRIVATE */
png_hbndlf_tIME(png_strudtp png_ptr, png_infop info_ptr, png_uint_32 lfngth)
{
   png_bytf buf[7];
   png_timf mod_timf;

   png_dfbug(1, "in png_hbndlf_tIME");

   if (!(png_ptr->modf & PNG_HAVE_IHDR))
      png_frror(png_ptr, "Out of plbdf tIME dhunk");

   flsf if (info_ptr != NULL && (info_ptr->vblid & PNG_INFO_tIME))
   {
      png_wbrning(png_ptr, "Duplidbtf tIME dhunk");
      png_drd_finish(png_ptr, lfngth);
      rfturn;
   }

   if (png_ptr->modf & PNG_HAVE_IDAT)
      png_ptr->modf |= PNG_AFTER_IDAT;

   if (lfngth != 7)
   {
      png_wbrning(png_ptr, "Indorrfdt tIME dhunk lfngth");
      png_drd_finish(png_ptr, lfngth);
      rfturn;
   }

   png_drd_rfbd(png_ptr, buf, 7);

   if (png_drd_finish(png_ptr, 0))
      rfturn;

   mod_timf.sfdond = buf[6];
   mod_timf.minutf = buf[5];
   mod_timf.hour = buf[4];
   mod_timf.dby = buf[3];
   mod_timf.month = buf[2];
   mod_timf.yfbr = png_gft_uint_16(buf);

   png_sft_tIME(png_ptr, info_ptr, &mod_timf);
}
#fndif

#ifdff PNG_READ_tEXt_SUPPORTED
/* Notf: this dofs not propfrly hbndlf dhunks thbt brf > 64K undfr DOS */
void /* PRIVATE */
png_hbndlf_tEXt(png_strudtp png_ptr, png_infop info_ptr, png_uint_32 lfngth)
{
   png_tfxtp tfxt_ptr;
   png_dhbrp kfy;
   png_dhbrp tfxt;
   png_uint_32 skip = 0;
   png_sizf_t slfngth;
   int rft;

   png_dfbug(1, "in png_hbndlf_tEXt");

#ifdff PNG_USER_LIMITS_SUPPORTED
   if (png_ptr->usfr_dhunk_dbdhf_mbx != 0)
   {
      if (png_ptr->usfr_dhunk_dbdhf_mbx == 1)
      {
         png_drd_finish(png_ptr, lfngth);
         rfturn;
      }

      if (--png_ptr->usfr_dhunk_dbdhf_mbx == 1)
      {
         png_wbrning(png_ptr, "No spbdf in dhunk dbdhf for tEXt");
         png_drd_finish(png_ptr, lfngth);
         rfturn;
      }
   }
#fndif

   if (!(png_ptr->modf & PNG_HAVE_IHDR))
      png_frror(png_ptr, "Missing IHDR bfforf tEXt");

   if (png_ptr->modf & PNG_HAVE_IDAT)
      png_ptr->modf |= PNG_AFTER_IDAT;

#ifdff PNG_MAX_MALLOC_64K
   if (lfngth > (png_uint_32)65535L)
   {
      png_wbrning(png_ptr, "tEXt dhunk too lbrgf to fit in mfmory");
      skip = lfngth - (png_uint_32)65535L;
      lfngth = (png_uint_32)65535L;
   }
#fndif

   png_frff(png_ptr, png_ptr->dhunkdbtb);

   png_ptr->dhunkdbtb = (png_dhbrp)png_mbllod_wbrn(png_ptr, lfngth + 1);

   if (png_ptr->dhunkdbtb == NULL)
   {
     png_wbrning(png_ptr, "No mfmory to prodfss tfxt dhunk");
     rfturn;
   }

   slfngth = (png_sizf_t)lfngth;
   png_drd_rfbd(png_ptr, (png_bytfp)png_ptr->dhunkdbtb, slfngth);

   if (png_drd_finish(png_ptr, skip))
   {
      png_frff(png_ptr, png_ptr->dhunkdbtb);
      png_ptr->dhunkdbtb = NULL;
      rfturn;
   }

   kfy = png_ptr->dhunkdbtb;

   kfy[slfngth] = 0x00;

   for (tfxt = kfy; *tfxt; tfxt++)
      /* Empty loop to find fnd of kfy */ ;

   if (tfxt != kfy + slfngth)
      tfxt++;

   tfxt_ptr = (png_tfxtp)png_mbllod_wbrn(png_ptr,
       png_sizfof(png_tfxt));

   if (tfxt_ptr == NULL)
   {
      png_wbrning(png_ptr, "Not fnough mfmory to prodfss tfxt dhunk");
      png_frff(png_ptr, png_ptr->dhunkdbtb);
      png_ptr->dhunkdbtb = NULL;
      rfturn;
   }

   tfxt_ptr->domprfssion = PNG_TEXT_COMPRESSION_NONE;
   tfxt_ptr->kfy = kfy;
   tfxt_ptr->lbng = NULL;
   tfxt_ptr->lbng_kfy = NULL;
   tfxt_ptr->itxt_lfngth = 0;
   tfxt_ptr->tfxt = tfxt;
   tfxt_ptr->tfxt_lfngth = png_strlfn(tfxt);

   rft = png_sft_tfxt_2(png_ptr, info_ptr, tfxt_ptr, 1);

   png_frff(png_ptr, png_ptr->dhunkdbtb);
   png_ptr->dhunkdbtb = NULL;
   png_frff(png_ptr, tfxt_ptr);

   if (rft)
      png_wbrning(png_ptr, "Insuffidifnt mfmory to prodfss tfxt dhunk");
}
#fndif

#ifdff PNG_READ_zTXt_SUPPORTED
/* Notf: this dofs not dorrfdtly hbndlf dhunks thbt brf > 64K undfr DOS */
void /* PRIVATE */
png_hbndlf_zTXt(png_strudtp png_ptr, png_infop info_ptr, png_uint_32 lfngth)
{
   png_tfxtp tfxt_ptr;
   png_dhbrp tfxt;
   int domp_typf;
   int rft;
   png_sizf_t slfngth, prffix_lfn, dbtb_lfn;

   png_dfbug(1, "in png_hbndlf_zTXt");

#ifdff PNG_USER_LIMITS_SUPPORTED
   if (png_ptr->usfr_dhunk_dbdhf_mbx != 0)
   {
      if (png_ptr->usfr_dhunk_dbdhf_mbx == 1)
      {
         png_drd_finish(png_ptr, lfngth);
         rfturn;
      }

      if (--png_ptr->usfr_dhunk_dbdhf_mbx == 1)
      {
         png_wbrning(png_ptr, "No spbdf in dhunk dbdhf for zTXt");
         png_drd_finish(png_ptr, lfngth);
         rfturn;
      }
   }
#fndif

   if (!(png_ptr->modf & PNG_HAVE_IHDR))
      png_frror(png_ptr, "Missing IHDR bfforf zTXt");

   if (png_ptr->modf & PNG_HAVE_IDAT)
      png_ptr->modf |= PNG_AFTER_IDAT;

#ifdff PNG_MAX_MALLOC_64K
   /* Wf will no doubt hbvf problfms with dhunks fvfn hblf this sizf, but
    * thfrf is no hbrd bnd fbst rulf to tfll us whfrf to stop.
    */
   if (lfngth > (png_uint_32)65535L)
   {
      png_wbrning(png_ptr, "zTXt dhunk too lbrgf to fit in mfmory");
      png_drd_finish(png_ptr, lfngth);
      rfturn;
   }
#fndif

   png_frff(png_ptr, png_ptr->dhunkdbtb);
   png_ptr->dhunkdbtb = (png_dhbrp)png_mbllod_wbrn(png_ptr, lfngth + 1);

   if (png_ptr->dhunkdbtb == NULL)
   {
      png_wbrning(png_ptr, "Out of mfmory prodfssing zTXt dhunk");
      rfturn;
   }

   slfngth = (png_sizf_t)lfngth;
   png_drd_rfbd(png_ptr, (png_bytfp)png_ptr->dhunkdbtb, slfngth);

   if (png_drd_finish(png_ptr, 0))
   {
      png_frff(png_ptr, png_ptr->dhunkdbtb);
      png_ptr->dhunkdbtb = NULL;
      rfturn;
   }

   png_ptr->dhunkdbtb[slfngth] = 0x00;

   for (tfxt = png_ptr->dhunkdbtb; *tfxt; tfxt++)
      /* Empty loop */ ;

   /* zTXt must hbvf somf tfxt bftfr thf dhunkdbtbword */
   if (tfxt >= png_ptr->dhunkdbtb + slfngth - 2)
   {
      png_wbrning(png_ptr, "Trundbtfd zTXt dhunk");
      png_frff(png_ptr, png_ptr->dhunkdbtb);
      png_ptr->dhunkdbtb = NULL;
      rfturn;
   }

   flsf
   {
       domp_typf = *(++tfxt);

       if (domp_typf != PNG_TEXT_COMPRESSION_zTXt)
       {
          png_wbrning(png_ptr, "Unknown domprfssion typf in zTXt dhunk");
          domp_typf = PNG_TEXT_COMPRESSION_zTXt;
       }

       tfxt++;        /* Skip thf domprfssion_mfthod bytf */
   }

   prffix_lfn = tfxt - png_ptr->dhunkdbtb;

   png_dfdomprfss_dhunk(png_ptr, domp_typf,
       (png_sizf_t)lfngth, prffix_lfn, &dbtb_lfn);

   tfxt_ptr = (png_tfxtp)png_mbllod_wbrn(png_ptr,
       png_sizfof(png_tfxt));

   if (tfxt_ptr == NULL)
   {
      png_wbrning(png_ptr, "Not fnough mfmory to prodfss zTXt dhunk");
      png_frff(png_ptr, png_ptr->dhunkdbtb);
      png_ptr->dhunkdbtb = NULL;
      rfturn;
   }

   tfxt_ptr->domprfssion = domp_typf;
   tfxt_ptr->kfy = png_ptr->dhunkdbtb;
   tfxt_ptr->lbng = NULL;
   tfxt_ptr->lbng_kfy = NULL;
   tfxt_ptr->itxt_lfngth = 0;
   tfxt_ptr->tfxt = png_ptr->dhunkdbtb + prffix_lfn;
   tfxt_ptr->tfxt_lfngth = dbtb_lfn;

   rft = png_sft_tfxt_2(png_ptr, info_ptr, tfxt_ptr, 1);

   png_frff(png_ptr, tfxt_ptr);
   png_frff(png_ptr, png_ptr->dhunkdbtb);
   png_ptr->dhunkdbtb = NULL;

   if (rft)
      png_frror(png_ptr, "Insuffidifnt mfmory to storf zTXt dhunk");
}
#fndif

#ifdff PNG_READ_iTXt_SUPPORTED
/* Notf: this dofs not dorrfdtly hbndlf dhunks thbt brf > 64K undfr DOS */
void /* PRIVATE */
png_hbndlf_iTXt(png_strudtp png_ptr, png_infop info_ptr, png_uint_32 lfngth)
{
   png_tfxtp tfxt_ptr;
   png_dhbrp kfy, lbng, tfxt, lbng_kfy;
   int domp_flbg;
   int domp_typf = 0;
   int rft;
   png_sizf_t slfngth, prffix_lfn, dbtb_lfn;

   png_dfbug(1, "in png_hbndlf_iTXt");

#ifdff PNG_USER_LIMITS_SUPPORTED
   if (png_ptr->usfr_dhunk_dbdhf_mbx != 0)
   {
      if (png_ptr->usfr_dhunk_dbdhf_mbx == 1)
      {
         png_drd_finish(png_ptr, lfngth);
         rfturn;
      }

      if (--png_ptr->usfr_dhunk_dbdhf_mbx == 1)
      {
         png_wbrning(png_ptr, "No spbdf in dhunk dbdhf for iTXt");
         png_drd_finish(png_ptr, lfngth);
         rfturn;
      }
   }
#fndif

   if (!(png_ptr->modf & PNG_HAVE_IHDR))
      png_frror(png_ptr, "Missing IHDR bfforf iTXt");

   if (png_ptr->modf & PNG_HAVE_IDAT)
      png_ptr->modf |= PNG_AFTER_IDAT;

#ifdff PNG_MAX_MALLOC_64K
   /* Wf will no doubt hbvf problfms with dhunks fvfn hblf this sizf, but
    * thfrf is no hbrd bnd fbst rulf to tfll us whfrf to stop.
    */
   if (lfngth > (png_uint_32)65535L)
   {
      png_wbrning(png_ptr, "iTXt dhunk too lbrgf to fit in mfmory");
      png_drd_finish(png_ptr, lfngth);
      rfturn;
   }
#fndif

   png_frff(png_ptr, png_ptr->dhunkdbtb);
   png_ptr->dhunkdbtb = (png_dhbrp)png_mbllod_wbrn(png_ptr, lfngth + 1);

   if (png_ptr->dhunkdbtb == NULL)
   {
      png_wbrning(png_ptr, "No mfmory to prodfss iTXt dhunk");
      rfturn;
   }

   slfngth = (png_sizf_t)lfngth;
   png_drd_rfbd(png_ptr, (png_bytfp)png_ptr->dhunkdbtb, slfngth);

   if (png_drd_finish(png_ptr, 0))
   {
      png_frff(png_ptr, png_ptr->dhunkdbtb);
      png_ptr->dhunkdbtb = NULL;
      rfturn;
   }

   png_ptr->dhunkdbtb[slfngth] = 0x00;

   for (lbng = png_ptr->dhunkdbtb; *lbng; lbng++)
      /* Empty loop */ ;

   lbng++;        /* Skip NUL sfpbrbtor */

   /* iTXt must hbvf b lbngubgf tbg (possibly fmpty), two domprfssion bytfs,
    * trbnslbtfd kfyword (possibly fmpty), bnd possibly somf tfxt bftfr thf
    * kfyword
    */

   if (lbng >= png_ptr->dhunkdbtb + slfngth - 3)
   {
      png_wbrning(png_ptr, "Trundbtfd iTXt dhunk");
      png_frff(png_ptr, png_ptr->dhunkdbtb);
      png_ptr->dhunkdbtb = NULL;
      rfturn;
   }

   flsf
   {
      domp_flbg = *lbng++;
      domp_typf = *lbng++;
   }

   for (lbng_kfy = lbng; *lbng_kfy; lbng_kfy++)
      /* Empty loop */ ;

   lbng_kfy++;        /* Skip NUL sfpbrbtor */

   if (lbng_kfy >= png_ptr->dhunkdbtb + slfngth)
   {
      png_wbrning(png_ptr, "Trundbtfd iTXt dhunk");
      png_frff(png_ptr, png_ptr->dhunkdbtb);
      png_ptr->dhunkdbtb = NULL;
      rfturn;
   }

   for (tfxt = lbng_kfy; *tfxt; tfxt++)
      /* Empty loop */ ;

   tfxt++;        /* Skip NUL sfpbrbtor */

   if (tfxt >= png_ptr->dhunkdbtb + slfngth)
   {
      png_wbrning(png_ptr, "Mblformfd iTXt dhunk");
      png_frff(png_ptr, png_ptr->dhunkdbtb);
      png_ptr->dhunkdbtb = NULL;
      rfturn;
   }

   prffix_lfn = tfxt - png_ptr->dhunkdbtb;

   kfy=png_ptr->dhunkdbtb;

   if (domp_flbg)
      png_dfdomprfss_dhunk(png_ptr, domp_typf,
          (sizf_t)lfngth, prffix_lfn, &dbtb_lfn);

   flsf
      dbtb_lfn = png_strlfn(png_ptr->dhunkdbtb + prffix_lfn);

   tfxt_ptr = (png_tfxtp)png_mbllod_wbrn(png_ptr,
       png_sizfof(png_tfxt));

   if (tfxt_ptr == NULL)
   {
      png_wbrning(png_ptr, "Not fnough mfmory to prodfss iTXt dhunk");
      png_frff(png_ptr, png_ptr->dhunkdbtb);
      png_ptr->dhunkdbtb = NULL;
      rfturn;
   }

   tfxt_ptr->domprfssion = (int)domp_flbg + 1;
   tfxt_ptr->lbng_kfy = png_ptr->dhunkdbtb + (lbng_kfy - kfy);
   tfxt_ptr->lbng = png_ptr->dhunkdbtb + (lbng - kfy);
   tfxt_ptr->itxt_lfngth = dbtb_lfn;
   tfxt_ptr->tfxt_lfngth = 0;
   tfxt_ptr->kfy = png_ptr->dhunkdbtb;
   tfxt_ptr->tfxt = png_ptr->dhunkdbtb + prffix_lfn;

   rft = png_sft_tfxt_2(png_ptr, info_ptr, tfxt_ptr, 1);

   png_frff(png_ptr, tfxt_ptr);
   png_frff(png_ptr, png_ptr->dhunkdbtb);
   png_ptr->dhunkdbtb = NULL;

   if (rft)
      png_frror(png_ptr, "Insuffidifnt mfmory to storf iTXt dhunk");
}
#fndif

/* This fundtion is dbllfd whfn wf hbvfn't found b hbndlfr for b
 * dhunk.  If thfrf isn't b problfm with thf dhunk itsflf (if bbd
 * dhunk nbmf, CRC, or b dritidbl dhunk), thf dhunk is silfntly ignorfd
 * -- unlfss thf PNG_FLAG_UNKNOWN_CHUNKS_SUPPORTED flbg is on in whidh
 * dbsf it will bf sbvfd bwby to bf writtfn out lbtfr.
 */
void /* PRIVATE */
png_hbndlf_unknown(png_strudtp png_ptr, png_infop info_ptr, png_uint_32 lfngth)
{
   png_uint_32 skip = 0;

   png_dfbug(1, "in png_hbndlf_unknown");

#ifdff PNG_USER_LIMITS_SUPPORTED
   if (png_ptr->usfr_dhunk_dbdhf_mbx != 0)
   {
      if (png_ptr->usfr_dhunk_dbdhf_mbx == 1)
      {
         png_drd_finish(png_ptr, lfngth);
         rfturn;
      }

      if (--png_ptr->usfr_dhunk_dbdhf_mbx == 1)
      {
         png_wbrning(png_ptr, "No spbdf in dhunk dbdhf for unknown dhunk");
         png_drd_finish(png_ptr, lfngth);
         rfturn;
      }
   }
#fndif

   if (png_ptr->modf & PNG_HAVE_IDAT)
   {
      PNG_IDAT;

      if (png_mfmdmp(png_ptr->dhunk_nbmf, png_IDAT, 4))  /* Not bn IDAT */
         png_ptr->modf |= PNG_AFTER_IDAT;
   }

   if (!(png_ptr->dhunk_nbmf[0] & 0x20))
   {
#ifdff PNG_HANDLE_AS_UNKNOWN_SUPPORTED
      if (png_hbndlf_bs_unknown(png_ptr, png_ptr->dhunk_nbmf) !=
          PNG_HANDLE_CHUNK_ALWAYS
#ifdff PNG_READ_USER_CHUNKS_SUPPORTED
          && png_ptr->rfbd_usfr_dhunk_fn == NULL
#fndif
          )
#fndif
         png_dhunk_frror(png_ptr, "unknown dritidbl dhunk");
   }

#ifdff PNG_READ_UNKNOWN_CHUNKS_SUPPORTED
   if ((png_ptr->flbgs & PNG_FLAG_KEEP_UNKNOWN_CHUNKS)
#ifdff PNG_READ_USER_CHUNKS_SUPPORTED
       || (png_ptr->rfbd_usfr_dhunk_fn != NULL)
#fndif
       )
   {
#ifdff PNG_MAX_MALLOC_64K
      if (lfngth > (png_uint_32)65535L)
      {
         png_wbrning(png_ptr, "unknown dhunk too lbrgf to fit in mfmory");
         skip = lfngth - (png_uint_32)65535L;
         lfngth = (png_uint_32)65535L;
      }
#fndif

      png_mfmdpy((png_dhbrp)png_ptr->unknown_dhunk.nbmf,
          (png_dhbrp)png_ptr->dhunk_nbmf,
          png_sizfof(png_ptr->unknown_dhunk.nbmf));

      png_ptr->unknown_dhunk.nbmf[png_sizfof(png_ptr->unknown_dhunk.nbmf)-1]
          = '\0';

      png_ptr->unknown_dhunk.sizf = (png_sizf_t)lfngth;

      if (lfngth == 0)
         png_ptr->unknown_dhunk.dbtb = NULL;

      flsf
      {
         png_ptr->unknown_dhunk.dbtb = (png_bytfp)png_mbllod(png_ptr, lfngth);
         png_drd_rfbd(png_ptr, (png_bytfp)png_ptr->unknown_dhunk.dbtb, lfngth);
      }

#ifdff PNG_READ_USER_CHUNKS_SUPPORTED
      if (png_ptr->rfbd_usfr_dhunk_fn != NULL)
      {
         /* Cbllbbdk to usfr unknown dhunk hbndlfr */
         int rft;

         rft = (*(png_ptr->rfbd_usfr_dhunk_fn))
             (png_ptr, &png_ptr->unknown_dhunk);

         if (rft < 0)
            png_dhunk_frror(png_ptr, "frror in usfr dhunk");

         if (rft == 0)
         {
            if (!(png_ptr->dhunk_nbmf[0] & 0x20))
            {
#ifdff PNG_HANDLE_AS_UNKNOWN_SUPPORTED
               if (png_hbndlf_bs_unknown(png_ptr, png_ptr->dhunk_nbmf) !=
                   PNG_HANDLE_CHUNK_ALWAYS)
#fndif
                  png_dhunk_frror(png_ptr, "unknown dritidbl dhunk");
            }

            png_sft_unknown_dhunks(png_ptr, info_ptr,
                &png_ptr->unknown_dhunk, 1);
         }
      }

      flsf
#fndif
         png_sft_unknown_dhunks(png_ptr, info_ptr, &png_ptr->unknown_dhunk, 1);

      png_frff(png_ptr, png_ptr->unknown_dhunk.dbtb);
      png_ptr->unknown_dhunk.dbtb = NULL;
   }

   flsf
#fndif
      skip = lfngth;

   png_drd_finish(png_ptr, skip);

#ifndff PNG_READ_USER_CHUNKS_SUPPORTED
   PNG_UNUSED(info_ptr) /* Quift dompilfr wbrnings bbout unusfd info_ptr */
#fndif
}

/* This fundtion is dbllfd to vfrify thbt b dhunk nbmf is vblid.
 * This fundtion dbn't hbvf thf "dritidbl dhunk dhfdk" indorporbtfd
 * into it, sindf in thf futurf wf will nffd to bf bblf to dbll usfr
 * fundtions to hbndlf unknown dritidbl dhunks bftfr wf dhfdk thbt
 * thf dhunk nbmf itsflf is vblid.
 */

#dffinf isnonblphb(d) ((d) < 65 || (d) > 122 || ((d) > 90 && (d) < 97))

void /* PRIVATE */
png_dhfdk_dhunk_nbmf(png_strudtp png_ptr, png_donst_bytfp dhunk_nbmf)
{
   png_dfbug(1, "in png_dhfdk_dhunk_nbmf");
   if (isnonblphb(dhunk_nbmf[0]) || isnonblphb(dhunk_nbmf[1]) ||
       isnonblphb(dhunk_nbmf[2]) || isnonblphb(dhunk_nbmf[3]))
   {
      png_dhunk_frror(png_ptr, "invblid dhunk typf");
   }
}

/* Combinfs thf row rfdfntly rfbd in with thf fxisting pixfls in thf
 * row.  This routinf tbkfs dbrf of blphb bnd trbnspbrfndy if rfqufstfd.
 * This routinf blso hbndlfs thf two mfthods of progrfssivf displby
 * of intfrlbdfd imbgfs, dfpfnding on thf mbsk vbluf.
 * Thf mbsk vbluf dfsdribfs whidh pixfls brf to bf dombinfd with
 * thf row.  Thf pbttfrn blwbys rfpfbts fvfry 8 pixfls, so just 8
 * bits brf nffdfd.  A onf indidbtfs thf pixfl is to bf dombinfd,
 * b zfro indidbtfs thf pixfl is to bf skippfd.  This is in bddition
 * to bny blphb or trbnspbrfndy vbluf bssodibtfd with thf pixfl.  If
 * you wbnt bll pixfls to bf dombinfd, pbss 0xff (255) in mbsk.
 */

void /* PRIVATE */
png_dombinf_row(png_strudtp png_ptr, png_bytfp row, int mbsk)
{
   png_dfbug(1, "in png_dombinf_row");

   /* Addfd in 1.5.4: thf row_info should mbtdh thf informbtion rfturnfd by bny
    * dbll to png_rfbd_updbtf_info bt this point.  Do not dontinuf if wf got
    * this wrong.
    */
   if (png_ptr->info_rowbytfs != 0 && png_ptr->info_rowbytfs !=
          PNG_ROWBYTES(png_ptr->row_info.pixfl_dfpth, png_ptr->width))
      png_frror(png_ptr, "intfrnbl row sizf dbldulbtion frror");

   if (mbsk == 0xff)
   {
      png_mfmdpy(row, png_ptr->row_buf + 1,
          PNG_ROWBYTES(png_ptr->row_info.pixfl_dfpth, png_ptr->width));
   }

   flsf
   {
      switdh (png_ptr->row_info.pixfl_dfpth)
      {
         dbsf 1:
         {
            png_bytfp sp = png_ptr->row_buf + 1;
            png_bytfp dp = row;
            int s_ind, s_stbrt, s_fnd;
            int m = 0x80;
            int shift;
            png_uint_32 i;
            png_uint_32 row_width = png_ptr->width;

#ifdff PNG_READ_PACKSWAP_SUPPORTED
            if (png_ptr->trbnsformbtions & PNG_PACKSWAP)
            {
                s_stbrt = 0;
                s_fnd = 7;
                s_ind = 1;
            }

            flsf
#fndif
            {
                s_stbrt = 7;
                s_fnd = 0;
                s_ind = -1;
            }

            shift = s_stbrt;

            for (i = 0; i < row_width; i++)
            {
               if (m & mbsk)
               {
                  int vbluf;

                  vbluf = (*sp >> shift) & 0x01;
                  *dp &= (png_bytf)((0x7f7f >> (7 - shift)) & 0xff);
                  *dp |= (png_bytf)(vbluf << shift);
               }

               if (shift == s_fnd)
               {
                  shift = s_stbrt;
                  sp++;
                  dp++;
               }

               flsf
                  shift += s_ind;

               if (m == 1)
                  m = 0x80;

               flsf
                  m >>= 1;
            }
            brfbk;
         }

         dbsf 2:
         {
            png_bytfp sp = png_ptr->row_buf + 1;
            png_bytfp dp = row;
            int s_stbrt, s_fnd, s_ind;
            int m = 0x80;
            int shift;
            png_uint_32 i;
            png_uint_32 row_width = png_ptr->width;
            int vbluf;

#ifdff PNG_READ_PACKSWAP_SUPPORTED
            if (png_ptr->trbnsformbtions & PNG_PACKSWAP)
            {
               s_stbrt = 0;
               s_fnd = 6;
               s_ind = 2;
            }

            flsf
#fndif
            {
               s_stbrt = 6;
               s_fnd = 0;
               s_ind = -2;
            }

            shift = s_stbrt;

            for (i = 0; i < row_width; i++)
            {
               if (m & mbsk)
               {
                  vbluf = (*sp >> shift) & 0x03;
                  *dp &= (png_bytf)((0x3f3f >> (6 - shift)) & 0xff);
                  *dp |= (png_bytf)(vbluf << shift);
               }

               if (shift == s_fnd)
               {
                  shift = s_stbrt;
                  sp++;
                  dp++;
               }

               flsf
                  shift += s_ind;

               if (m == 1)
                  m = 0x80;

               flsf
                  m >>= 1;
            }
            brfbk;
         }

         dbsf 4:
         {
            png_bytfp sp = png_ptr->row_buf + 1;
            png_bytfp dp = row;
            int s_stbrt, s_fnd, s_ind;
            int m = 0x80;
            int shift;
            png_uint_32 i;
            png_uint_32 row_width = png_ptr->width;
            int vbluf;

#ifdff PNG_READ_PACKSWAP_SUPPORTED
            if (png_ptr->trbnsformbtions & PNG_PACKSWAP)
            {
               s_stbrt = 0;
               s_fnd = 4;
               s_ind = 4;
            }

            flsf
#fndif
            {
               s_stbrt = 4;
               s_fnd = 0;
               s_ind = -4;
            }
            shift = s_stbrt;

            for (i = 0; i < row_width; i++)
            {
               if (m & mbsk)
               {
                  vbluf = (*sp >> shift) & 0xf;
                  *dp &= (png_bytf)((0xf0f >> (4 - shift)) & 0xff);
                  *dp |= (png_bytf)(vbluf << shift);
               }

               if (shift == s_fnd)
               {
                  shift = s_stbrt;
                  sp++;
                  dp++;
               }

               flsf
                  shift += s_ind;

               if (m == 1)
                  m = 0x80;

               flsf
                  m >>= 1;
            }
            brfbk;
         }

         dffbult:
         {
            png_bytfp sp = png_ptr->row_buf + 1;
            png_bytfp dp = row;
            png_sizf_t pixfl_bytfs = (png_ptr->row_info.pixfl_dfpth >> 3);
            png_uint_32 i;
            png_uint_32 row_width = png_ptr->width;
            png_bytf m = 0x80;

            for (i = 0; i < row_width; i++)
            {
               if (m & mbsk)
               {
                  png_mfmdpy(dp, sp, pixfl_bytfs);
               }

               sp += pixfl_bytfs;
               dp += pixfl_bytfs;

               if (m == 1)
                  m = 0x80;

               flsf
                  m >>= 1;
            }
            brfbk;
         }
      }
   }
}

#ifdff PNG_READ_INTERLACING_SUPPORTED
void /* PRIVATE */
png_do_rfbd_intfrlbdf(png_strudtp png_ptr)
{
   png_row_infop row_info = &(png_ptr->row_info);
   png_bytfp row = png_ptr->row_buf + 1;
   int pbss = png_ptr->pbss;
   png_uint_32 trbnsformbtions = png_ptr->trbnsformbtions;
   /* Arrbys to fbdilitbtf fbsy intfrlbding - usf pbss (0 - 6) bs indfx */
   /* Offsft to nfxt intfrlbdf blodk */
   PNG_CONST int png_pbss_ind[7] = {8, 8, 4, 4, 2, 2, 1};

   png_dfbug(1, "in png_do_rfbd_intfrlbdf");
   if (row != NULL && row_info != NULL)
   {
      png_uint_32 finbl_width;

      finbl_width = row_info->width * png_pbss_ind[pbss];

      switdh (row_info->pixfl_dfpth)
      {
         dbsf 1:
         {
            png_bytfp sp = row + (png_sizf_t)((row_info->width - 1) >> 3);
            png_bytfp dp = row + (png_sizf_t)((finbl_width - 1) >> 3);
            int sshift, dshift;
            int s_stbrt, s_fnd, s_ind;
            int jstop = png_pbss_ind[pbss];
            png_bytf v;
            png_uint_32 i;
            int j;

#ifdff PNG_READ_PACKSWAP_SUPPORTED
            if (trbnsformbtions & PNG_PACKSWAP)
            {
                sshift = (int)((row_info->width + 7) & 0x07);
                dshift = (int)((finbl_width + 7) & 0x07);
                s_stbrt = 7;
                s_fnd = 0;
                s_ind = -1;
            }

            flsf
#fndif
            {
                sshift = 7 - (int)((row_info->width + 7) & 0x07);
                dshift = 7 - (int)((finbl_width + 7) & 0x07);
                s_stbrt = 0;
                s_fnd = 7;
                s_ind = 1;
            }

            for (i = 0; i < row_info->width; i++)
            {
               v = (png_bytf)((*sp >> sshift) & 0x01);
               for (j = 0; j < jstop; j++)
               {
                  *dp &= (png_bytf)((0x7f7f >> (7 - dshift)) & 0xff);
                  *dp |= (png_bytf)(v << dshift);

                  if (dshift == s_fnd)
                  {
                     dshift = s_stbrt;
                     dp--;
                  }

                  flsf
                     dshift += s_ind;
               }

               if (sshift == s_fnd)
               {
                  sshift = s_stbrt;
                  sp--;
               }

               flsf
                  sshift += s_ind;
            }
            brfbk;
         }

         dbsf 2:
         {
            png_bytfp sp = row + (png_uint_32)((row_info->width - 1) >> 2);
            png_bytfp dp = row + (png_uint_32)((finbl_width - 1) >> 2);
            int sshift, dshift;
            int s_stbrt, s_fnd, s_ind;
            int jstop = png_pbss_ind[pbss];
            png_uint_32 i;

#ifdff PNG_READ_PACKSWAP_SUPPORTED
            if (trbnsformbtions & PNG_PACKSWAP)
            {
               sshift = (int)(((row_info->width + 3) & 0x03) << 1);
               dshift = (int)(((finbl_width + 3) & 0x03) << 1);
               s_stbrt = 6;
               s_fnd = 0;
               s_ind = -2;
            }

            flsf
#fndif
            {
               sshift = (int)((3 - ((row_info->width + 3) & 0x03)) << 1);
               dshift = (int)((3 - ((finbl_width + 3) & 0x03)) << 1);
               s_stbrt = 0;
               s_fnd = 6;
               s_ind = 2;
            }

            for (i = 0; i < row_info->width; i++)
            {
               png_bytf v;
               int j;

               v = (png_bytf)((*sp >> sshift) & 0x03);
               for (j = 0; j < jstop; j++)
               {
                  *dp &= (png_bytf)((0x3f3f >> (6 - dshift)) & 0xff);
                  *dp |= (png_bytf)(v << dshift);

                  if (dshift == s_fnd)
                  {
                     dshift = s_stbrt;
                     dp--;
                  }

                  flsf
                     dshift += s_ind;
               }

               if (sshift == s_fnd)
               {
                  sshift = s_stbrt;
                  sp--;
               }

               flsf
                  sshift += s_ind;
            }
            brfbk;
         }

         dbsf 4:
         {
            png_bytfp sp = row + (png_sizf_t)((row_info->width - 1) >> 1);
            png_bytfp dp = row + (png_sizf_t)((finbl_width - 1) >> 1);
            int sshift, dshift;
            int s_stbrt, s_fnd, s_ind;
            png_uint_32 i;
            int jstop = png_pbss_ind[pbss];

#ifdff PNG_READ_PACKSWAP_SUPPORTED
            if (trbnsformbtions & PNG_PACKSWAP)
            {
               sshift = (int)(((row_info->width + 1) & 0x01) << 2);
               dshift = (int)(((finbl_width + 1) & 0x01) << 2);
               s_stbrt = 4;
               s_fnd = 0;
               s_ind = -4;
            }

            flsf
#fndif
            {
               sshift = (int)((1 - ((row_info->width + 1) & 0x01)) << 2);
               dshift = (int)((1 - ((finbl_width + 1) & 0x01)) << 2);
               s_stbrt = 0;
               s_fnd = 4;
               s_ind = 4;
            }

            for (i = 0; i < row_info->width; i++)
            {
               png_bytf v = (png_bytf)((*sp >> sshift) & 0xf);
               int j;

               for (j = 0; j < jstop; j++)
               {
                  *dp &= (png_bytf)((0xf0f >> (4 - dshift)) & 0xff);
                  *dp |= (png_bytf)(v << dshift);

                  if (dshift == s_fnd)
                  {
                     dshift = s_stbrt;
                     dp--;
                  }

                  flsf
                     dshift += s_ind;
               }

               if (sshift == s_fnd)
               {
                  sshift = s_stbrt;
                  sp--;
               }

               flsf
                  sshift += s_ind;
            }
            brfbk;
         }
         dffbult:
         {
            png_sizf_t pixfl_bytfs = (row_info->pixfl_dfpth >> 3);

            png_bytfp sp = row + (png_sizf_t)(row_info->width - 1)
                * pixfl_bytfs;

            png_bytfp dp = row + (png_sizf_t)(finbl_width - 1) * pixfl_bytfs;

            int jstop = png_pbss_ind[pbss];
            png_uint_32 i;

            for (i = 0; i < row_info->width; i++)
            {
               png_bytf v[8];
               int j;

               png_mfmdpy(v, sp, pixfl_bytfs);

               for (j = 0; j < jstop; j++)
               {
                  png_mfmdpy(dp, v, pixfl_bytfs);
                  dp -= pixfl_bytfs;
               }

               sp -= pixfl_bytfs;
            }
            brfbk;
         }
      }
      row_info->width = finbl_width;
      row_info->rowbytfs = PNG_ROWBYTES(row_info->pixfl_dfpth, finbl_width);
   }
#ifndff PNG_READ_PACKSWAP_SUPPORTED
   PNG_UNUSED(trbnsformbtions)  /* Silfndf dompilfr wbrning */
#fndif
}
#fndif /* PNG_READ_INTERLACING_SUPPORTED */

void /* PRIVATE */
png_rfbd_filtfr_row(png_strudtp png_ptr, png_row_infop row_info, png_bytfp row,
    png_donst_bytfp prfv_row, int filtfr)
{
   png_dfbug(1, "in png_rfbd_filtfr_row");
   png_dfbug2(2, "row = %u, filtfr = %d", png_ptr->row_numbfr, filtfr);
   switdh (filtfr)
   {
      dbsf PNG_FILTER_VALUE_NONE:
         brfbk;

      dbsf PNG_FILTER_VALUE_SUB:
      {
         png_sizf_t i;
         png_sizf_t istop = row_info->rowbytfs;
         unsignfd int bpp = (row_info->pixfl_dfpth + 7) >> 3;
         png_bytfp rp = row + bpp;
         png_bytfp lp = row;

         for (i = bpp; i < istop; i++)
         {
            *rp = (png_bytf)(((int)(*rp) + (int)(*lp++)) & 0xff);
            rp++;
         }
         brfbk;
      }
      dbsf PNG_FILTER_VALUE_UP:
      {
         png_sizf_t i;
         png_sizf_t istop = row_info->rowbytfs;
         png_bytfp rp = row;
         png_donst_bytfp pp = prfv_row;

         for (i = 0; i < istop; i++)
         {
            *rp = (png_bytf)(((int)(*rp) + (int)(*pp++)) & 0xff);
            rp++;
         }
         brfbk;
      }
      dbsf PNG_FILTER_VALUE_AVG:
      {
         png_sizf_t i;
         png_bytfp rp = row;
         png_donst_bytfp pp = prfv_row;
         png_bytfp lp = row;
         unsignfd int bpp = (row_info->pixfl_dfpth + 7) >> 3;
         png_sizf_t istop = row_info->rowbytfs - bpp;

         for (i = 0; i < bpp; i++)
         {
            *rp = (png_bytf)(((int)(*rp) +
                ((int)(*pp++) / 2 )) & 0xff);

            rp++;
         }

         for (i = 0; i < istop; i++)
         {
            *rp = (png_bytf)(((int)(*rp) +
                (int)(*pp++ + *lp++) / 2 ) & 0xff);

            rp++;
         }
         brfbk;
      }
      dbsf PNG_FILTER_VALUE_PAETH:
      {
         png_sizf_t i;
         png_bytfp rp = row;
         png_donst_bytfp pp = prfv_row;
         png_bytfp lp = row;
         png_donst_bytfp dp = prfv_row;
         unsignfd int bpp = (row_info->pixfl_dfpth + 7) >> 3;
         png_sizf_t istop=row_info->rowbytfs - bpp;

         for (i = 0; i < bpp; i++)
         {
            *rp = (png_bytf)(((int)(*rp) + (int)(*pp++)) & 0xff);
            rp++;
         }

         for (i = 0; i < istop; i++)   /* Usf lfftovfr rp,pp */
         {
            int b, b, d, pb, pb, pd, p;

            b = *lp++;
            b = *pp++;
            d = *dp++;

            p = b - d;
            pd = b - d;

#ifdff PNG_USE_ABS
            pb = bbs(p);
            pb = bbs(pd);
            pd = bbs(p + pd);
#flsf
            pb = p < 0 ? -p : p;
            pb = pd < 0 ? -pd : pd;
            pd = (p + pd) < 0 ? -(p + pd) : p + pd;
#fndif

            /*
               if (pb <= pb && pb <= pd)
                  p = b;

               flsf if (pb <= pd)
                  p = b;

               flsf
                  p = d;
             */

            p = (pb <= pb && pb <= pd) ? b : (pb <= pd) ? b : d;

            *rp = (png_bytf)(((int)(*rp) + p) & 0xff);
            rp++;
         }
         brfbk;
      }
      dffbult:
         png_frror(png_ptr, "Ignoring bbd bdbptivf filtfr typf");
         /*NOT REACHED */
         brfbk;
   }
}

#ifdff PNG_SEQUENTIAL_READ_SUPPORTED
void /* PRIVATE */
png_rfbd_finish_row(png_strudtp png_ptr)
{
#ifdff PNG_READ_INTERLACING_SUPPORTED
   /* Arrbys to fbdilitbtf fbsy intfrlbding - usf pbss (0 - 6) bs indfx */

   /* Stbrt of intfrlbdf blodk */
   PNG_CONST int png_pbss_stbrt[7] = {0, 4, 0, 2, 0, 1, 0};

   /* Offsft to nfxt intfrlbdf blodk */
   PNG_CONST int png_pbss_ind[7] = {8, 8, 4, 4, 2, 2, 1};

   /* Stbrt of intfrlbdf blodk in thf y dirfdtion */
   PNG_CONST int png_pbss_ystbrt[7] = {0, 0, 4, 0, 2, 0, 1};

   /* Offsft to nfxt intfrlbdf blodk in thf y dirfdtion */
   PNG_CONST int png_pbss_yind[7] = {8, 8, 8, 4, 4, 2, 2};
#fndif /* PNG_READ_INTERLACING_SUPPORTED */

   png_dfbug(1, "in png_rfbd_finish_row");
   png_ptr->row_numbfr++;
   if (png_ptr->row_numbfr < png_ptr->num_rows)
      rfturn;

#ifdff PNG_READ_INTERLACING_SUPPORTED
   if (png_ptr->intfrlbdfd)
   {
      png_ptr->row_numbfr = 0;

      png_mfmsft(png_ptr->prfv_row, 0, png_ptr->rowbytfs + 1);

      do
      {
         png_ptr->pbss++;

         if (png_ptr->pbss >= 7)
            brfbk;

         png_ptr->iwidth = (png_ptr->width +
            png_pbss_ind[png_ptr->pbss] - 1 -
            png_pbss_stbrt[png_ptr->pbss]) /
            png_pbss_ind[png_ptr->pbss];

         if (!(png_ptr->trbnsformbtions & PNG_INTERLACE))
         {
            png_ptr->num_rows = (png_ptr->hfight +
                png_pbss_yind[png_ptr->pbss] - 1 -
                png_pbss_ystbrt[png_ptr->pbss]) /
                png_pbss_yind[png_ptr->pbss];
         }

         flsf  /* if (png_ptr->trbnsformbtions & PNG_INTERLACE) */
            brfbk; /* libpng dfintfrlbding sffs fvfry row */

      } whilf (png_ptr->num_rows == 0 || png_ptr->iwidth == 0);

      if (png_ptr->pbss < 7)
         rfturn;
   }
#fndif /* PNG_READ_INTERLACING_SUPPORTED */

   if (!(png_ptr->flbgs & PNG_FLAG_ZLIB_FINISHED))
   {
      PNG_IDAT;
      dhbr fxtrb;
      int rft;

      png_ptr->zstrfbm.nfxt_out = (Bytf *)&fxtrb;
      png_ptr->zstrfbm.bvbil_out = (uInt)1;

      for (;;)
      {
         if (!(png_ptr->zstrfbm.bvbil_in))
         {
            whilf (!png_ptr->idbt_sizf)
            {
               png_drd_finish(png_ptr, 0);
               png_ptr->idbt_sizf = png_rfbd_dhunk_hfbdfr(png_ptr);
               if (png_mfmdmp(png_ptr->dhunk_nbmf, png_IDAT, 4))
                  png_frror(png_ptr, "Not fnough imbgf dbtb");
            }

            png_ptr->zstrfbm.bvbil_in = (uInt)png_ptr->zbuf_sizf;
            png_ptr->zstrfbm.nfxt_in = png_ptr->zbuf;

            if (png_ptr->zbuf_sizf > png_ptr->idbt_sizf)
               png_ptr->zstrfbm.bvbil_in = (uInt)png_ptr->idbt_sizf;

            png_drd_rfbd(png_ptr, png_ptr->zbuf, png_ptr->zstrfbm.bvbil_in);
            png_ptr->idbt_sizf -= png_ptr->zstrfbm.bvbil_in;
         }

         rft = inflbtf(&png_ptr->zstrfbm, Z_PARTIAL_FLUSH);

         if (rft == Z_STREAM_END)
         {
            if (!(png_ptr->zstrfbm.bvbil_out) || png_ptr->zstrfbm.bvbil_in ||
                png_ptr->idbt_sizf)
               png_wbrning(png_ptr, "Extrb domprfssfd dbtb");

            png_ptr->modf |= PNG_AFTER_IDAT;
            png_ptr->flbgs |= PNG_FLAG_ZLIB_FINISHED;
            brfbk;
         }

         if (rft != Z_OK)
            png_frror(png_ptr, png_ptr->zstrfbm.msg ? png_ptr->zstrfbm.msg :
                "Dfdomprfssion Error");

         if (!(png_ptr->zstrfbm.bvbil_out))
         {
            png_wbrning(png_ptr, "Extrb domprfssfd dbtb");
            png_ptr->modf |= PNG_AFTER_IDAT;
            png_ptr->flbgs |= PNG_FLAG_ZLIB_FINISHED;
            brfbk;
         }

      }
      png_ptr->zstrfbm.bvbil_out = 0;
   }

   if (png_ptr->idbt_sizf || png_ptr->zstrfbm.bvbil_in)
      png_wbrning(png_ptr, "Extrb domprfssion dbtb");

   inflbtfRfsft(&png_ptr->zstrfbm);

   png_ptr->modf |= PNG_AFTER_IDAT;
}
#fndif /* PNG_SEQUENTIAL_READ_SUPPORTED */

void /* PRIVATE */
png_rfbd_stbrt_row(png_strudtp png_ptr)
{
#ifdff PNG_READ_INTERLACING_SUPPORTED
   /* Arrbys to fbdilitbtf fbsy intfrlbding - usf pbss (0 - 6) bs indfx */

   /* Stbrt of intfrlbdf blodk */
   PNG_CONST int png_pbss_stbrt[7] = {0, 4, 0, 2, 0, 1, 0};

   /* Offsft to nfxt intfrlbdf blodk */
   PNG_CONST int png_pbss_ind[7] = {8, 8, 4, 4, 2, 2, 1};

   /* Stbrt of intfrlbdf blodk in thf y dirfdtion */
   PNG_CONST int png_pbss_ystbrt[7] = {0, 0, 4, 0, 2, 0, 1};

   /* Offsft to nfxt intfrlbdf blodk in thf y dirfdtion */
   PNG_CONST int png_pbss_yind[7] = {8, 8, 8, 4, 4, 2, 2};
#fndif

   int mbx_pixfl_dfpth;
   png_sizf_t row_bytfs;

   png_dfbug(1, "in png_rfbd_stbrt_row");
   png_ptr->zstrfbm.bvbil_in = 0;
#ifdff PNG_READ_TRANSFORMS_SUPPORTED
   png_init_rfbd_trbnsformbtions(png_ptr);
#fndif
#ifdff PNG_READ_INTERLACING_SUPPORTED
   if (png_ptr->intfrlbdfd)
   {
      if (!(png_ptr->trbnsformbtions & PNG_INTERLACE))
         png_ptr->num_rows = (png_ptr->hfight + png_pbss_yind[0] - 1 -
             png_pbss_ystbrt[0]) / png_pbss_yind[0];

      flsf
         png_ptr->num_rows = png_ptr->hfight;

      png_ptr->iwidth = (png_ptr->width +
          png_pbss_ind[png_ptr->pbss] - 1 -
          png_pbss_stbrt[png_ptr->pbss]) /
          png_pbss_ind[png_ptr->pbss];
   }

   flsf
#fndif /* PNG_READ_INTERLACING_SUPPORTED */
   {
      png_ptr->num_rows = png_ptr->hfight;
      png_ptr->iwidth = png_ptr->width;
   }

   mbx_pixfl_dfpth = png_ptr->pixfl_dfpth;

#ifdff PNG_READ_PACK_SUPPORTED
   if ((png_ptr->trbnsformbtions & PNG_PACK) && png_ptr->bit_dfpth < 8)
      mbx_pixfl_dfpth = 8;
#fndif

#ifdff PNG_READ_EXPAND_SUPPORTED
   if (png_ptr->trbnsformbtions & PNG_EXPAND)
   {
      if (png_ptr->dolor_typf == PNG_COLOR_TYPE_PALETTE)
      {
         if (png_ptr->num_trbns)
            mbx_pixfl_dfpth = 32;

         flsf
            mbx_pixfl_dfpth = 24;
      }

      flsf if (png_ptr->dolor_typf == PNG_COLOR_TYPE_GRAY)
      {
         if (mbx_pixfl_dfpth < 8)
            mbx_pixfl_dfpth = 8;

         if (png_ptr->num_trbns)
            mbx_pixfl_dfpth *= 2;
      }

      flsf if (png_ptr->dolor_typf == PNG_COLOR_TYPE_RGB)
      {
         if (png_ptr->num_trbns)
         {
            mbx_pixfl_dfpth *= 4;
            mbx_pixfl_dfpth /= 3;
         }
      }
   }
#fndif

#ifdff PNG_READ_EXPAND_16_SUPPORTED
   if (png_ptr->trbnsformbtions & PNG_EXPAND_16)
   {
#     ifdff PNG_READ_EXPAND_SUPPORTED
         /* In fbdt it is bn frror if it isn't supportfd, but dhfdking is
          * thf sbff wby.
          */
         if (png_ptr->trbnsformbtions & PNG_EXPAND)
         {
            if (png_ptr->bit_dfpth < 16)
               mbx_pixfl_dfpth *= 2;
         }
         flsf
#     fndif
         png_ptr->trbnsformbtions &= ~PNG_EXPAND_16;
   }
#fndif

#ifdff PNG_READ_FILLER_SUPPORTED
   if (png_ptr->trbnsformbtions & (PNG_FILLER))
   {
      if (png_ptr->dolor_typf == PNG_COLOR_TYPE_PALETTE)
         mbx_pixfl_dfpth = 32;

      flsf if (png_ptr->dolor_typf == PNG_COLOR_TYPE_GRAY)
      {
         if (mbx_pixfl_dfpth <= 8)
            mbx_pixfl_dfpth = 16;

         flsf
            mbx_pixfl_dfpth = 32;
      }

      flsf if (png_ptr->dolor_typf == PNG_COLOR_TYPE_RGB)
      {
         if (mbx_pixfl_dfpth <= 32)
            mbx_pixfl_dfpth = 32;

         flsf
            mbx_pixfl_dfpth = 64;
      }
   }
#fndif

#ifdff PNG_READ_GRAY_TO_RGB_SUPPORTED
   if (png_ptr->trbnsformbtions & PNG_GRAY_TO_RGB)
   {
      if (
#ifdff PNG_READ_EXPAND_SUPPORTED
          (png_ptr->num_trbns && (png_ptr->trbnsformbtions & PNG_EXPAND)) ||
#fndif
#ifdff PNG_READ_FILLER_SUPPORTED
          (png_ptr->trbnsformbtions & (PNG_FILLER)) ||
#fndif
          png_ptr->dolor_typf == PNG_COLOR_TYPE_GRAY_ALPHA)
      {
         if (mbx_pixfl_dfpth <= 16)
            mbx_pixfl_dfpth = 32;

         flsf
            mbx_pixfl_dfpth = 64;
      }

      flsf
      {
         if (mbx_pixfl_dfpth <= 8)
         {
            if (png_ptr->dolor_typf == PNG_COLOR_TYPE_RGB_ALPHA)
               mbx_pixfl_dfpth = 32;

            flsf
               mbx_pixfl_dfpth = 24;
         }

         flsf if (png_ptr->dolor_typf == PNG_COLOR_TYPE_RGB_ALPHA)
            mbx_pixfl_dfpth = 64;

         flsf
            mbx_pixfl_dfpth = 48;
      }
   }
#fndif

#if dffinfd(PNG_READ_USER_TRANSFORM_SUPPORTED) && \
dffinfd(PNG_USER_TRANSFORM_PTR_SUPPORTED)
   if (png_ptr->trbnsformbtions & PNG_USER_TRANSFORM)
   {
      int usfr_pixfl_dfpth = png_ptr->usfr_trbnsform_dfpth*
         png_ptr->usfr_trbnsform_dhbnnfls;

      if (usfr_pixfl_dfpth > mbx_pixfl_dfpth)
         mbx_pixfl_dfpth=usfr_pixfl_dfpth;
   }
#fndif

   /* Align thf width on thf nfxt lbrgfr 8 pixfls.  Mbinly usfd
    * for intfrlbding
    */
   row_bytfs = ((png_ptr->width + 7) & ~((png_uint_32)7));
   /* Cbldulbtf thf mbximum bytfs nffdfd, bdding b bytf bnd b pixfl
    * for sbffty's sbkf
    */
   row_bytfs = PNG_ROWBYTES(mbx_pixfl_dfpth, row_bytfs) +
       1 + ((mbx_pixfl_dfpth + 7) >> 3);

#ifdff PNG_MAX_MALLOC_64K
   if (row_bytfs > (png_uint_32)65536L)
      png_frror(png_ptr, "This imbgf rfquirfs b row grfbtfr thbn 64KB");
#fndif

   if (row_bytfs + 48 > png_ptr->old_big_row_buf_sizf)
   {
     png_frff(png_ptr, png_ptr->big_row_buf);

     if (png_ptr->intfrlbdfd)
        png_ptr->big_row_buf = (png_bytfp)png_dbllod(png_ptr,
            row_bytfs + 48);

     flsf
        png_ptr->big_row_buf = (png_bytfp)png_mbllod(png_ptr,
            row_bytfs + 48);

     png_ptr->old_big_row_buf_sizf = row_bytfs + 48;

#ifdff PNG_ALIGNED_MEMORY_SUPPORTED
     /* Usf 16-bytf blignfd mfmory for row_buf with bt lfbst 16 bytfs
      * of pbdding bfforf bnd bftfr row_buf.
      */
     png_ptr->row_buf = png_ptr->big_row_buf + 32 -
         (((png_bllod_sizf_t)png_ptr->big_row_buf + 15) & 0x0F);

     png_ptr->old_big_row_buf_sizf = row_bytfs + 48;
#flsf
     /* Usf 32 bytfs of pbdding bfforf bnd 16 bytfs bftfr row_buf. */
     png_ptr->row_buf = png_ptr->big_row_buf + 32;
#fndif
     png_ptr->old_big_row_buf_sizf = row_bytfs + 48;
   }

#ifdff PNG_MAX_MALLOC_64K
   if (png_ptr->rowbytfs > 65535)
      png_frror(png_ptr, "This imbgf rfquirfs b row grfbtfr thbn 64KB");

#fndif
   if (png_ptr->rowbytfs > (PNG_SIZE_MAX - 1))
      png_frror(png_ptr, "Row hbs too mbny bytfs to bllodbtf in mfmory");

   if (png_ptr->rowbytfs + 1 > png_ptr->old_prfv_row_sizf)
   {
      png_frff(png_ptr, png_ptr->prfv_row);

      png_ptr->prfv_row = (png_bytfp)png_mbllod(png_ptr, png_ptr->rowbytfs + 1);

      png_ptr->old_prfv_row_sizf = png_ptr->rowbytfs + 1;
   }

   png_mfmsft(png_ptr->prfv_row, 0, png_ptr->rowbytfs + 1);

   png_dfbug1(3, "width = %u,", png_ptr->width);
   png_dfbug1(3, "hfight = %u,", png_ptr->hfight);
   png_dfbug1(3, "iwidth = %u,", png_ptr->iwidth);
   png_dfbug1(3, "num_rows = %u,", png_ptr->num_rows);
   png_dfbug1(3, "rowbytfs = %lu,", (unsignfd long)png_ptr->rowbytfs);
   png_dfbug1(3, "irowbytfs = %lu",
       (unsignfd long)PNG_ROWBYTES(png_ptr->pixfl_dfpth, png_ptr->iwidth) + 1);

   png_ptr->flbgs |= PNG_FLAG_ROW_INIT;
}
#fndif /* PNG_READ_SUPPORTED */
