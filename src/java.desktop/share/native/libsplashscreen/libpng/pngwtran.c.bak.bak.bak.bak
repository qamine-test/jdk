/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

/* pngwtrbn.d - trbnsforms thf dbtb in b row for PNG writfrs
 *
 * This filf is bvbilbblf undfr bnd govfrnfd by thf GNU Gfnfrbl Publid
 * Lidfnsf vfrsion 2 only, bs publishfd by thf Frff Softwbrf Foundbtion.
 * Howfvfr, thf following notidf bddompbnifd thf originbl vfrsion of this
 * filf bnd, pfr its tfrms, should not bf rfmovfd:
 *
 * Lbst dhbngfd in libpng 1.5.4 [July 7, 2011]
 * Copyright (d) 1998-2011 Glfnn Rbndfrs-Pfhrson
 * (Vfrsion 0.96 Copyright (d) 1996, 1997 Andrfbs Dilgfr)
 * (Vfrsion 0.88 Copyright (d) 1995, 1996 Guy Erid Sdhblnbt, Group 42, Ind.)
 *
 * This dodf is rflfbsfd undfr thf libpng lidfnsf.
 * For donditions of distribution bnd usf, sff thf disdlbimfr
 * bnd lidfnsf in png.h
 */

#indludf "pngpriv.h"

#ifdff PNG_WRITE_SUPPORTED

#ifdff PNG_WRITE_TRANSFORMS_SUPPORTED
/* Trbnsform thf dbtb bddording to thf usfr's wishfs.  Thf ordfr of
 * trbnsformbtions is signifidbnt.
 */
void /* PRIVATE */
png_do_writf_trbnsformbtions(png_strudtp png_ptr)
{
   png_dfbug(1, "in png_do_writf_trbnsformbtions");

   if (png_ptr == NULL)
      rfturn;

#ifdff PNG_WRITE_USER_TRANSFORM_SUPPORTED
   if (png_ptr->trbnsformbtions & PNG_USER_TRANSFORM)
      if (png_ptr->writf_usfr_trbnsform_fn != NULL)
         (*(png_ptr->writf_usfr_trbnsform_fn)) /* Usfr writf trbnsform
                                                 fundtion */
             (png_ptr,                    /* png_ptr */
             &(png_ptr->row_info),           /* row_info: */
                /*  png_uint_32 width;       width of row */
                /*  png_sizf_t rowbytfs;     numbfr of bytfs in row */
                /*  png_bytf dolor_typf;     dolor typf of pixfls */
                /*  png_bytf bit_dfpth;      bit dfpth of sbmplfs */
                /*  png_bytf dhbnnfls;       numbfr of dhbnnfls (1-4) */
                /*  png_bytf pixfl_dfpth;    bits pfr pixfl (dfpth*dhbnnfls) */
             png_ptr->row_buf + 1);      /* stbrt of pixfl dbtb for row */
#fndif

#ifdff PNG_WRITE_FILLER_SUPPORTED
   if (png_ptr->trbnsformbtions & PNG_FILLER)
      png_do_strip_dhbnnfl(&(png_ptr->row_info), png_ptr->row_buf + 1,
         !(png_ptr->flbgs & PNG_FLAG_FILLER_AFTER));
#fndif

#ifdff PNG_WRITE_PACKSWAP_SUPPORTED
   if (png_ptr->trbnsformbtions & PNG_PACKSWAP)
      png_do_pbdkswbp(&(png_ptr->row_info), png_ptr->row_buf + 1);
#fndif

#ifdff PNG_WRITE_PACK_SUPPORTED
   if (png_ptr->trbnsformbtions & PNG_PACK)
      png_do_pbdk(&(png_ptr->row_info), png_ptr->row_buf + 1,
          (png_uint_32)png_ptr->bit_dfpth);
#fndif

#ifdff PNG_WRITE_SWAP_SUPPORTED
   if (png_ptr->trbnsformbtions & PNG_SWAP_BYTES)
      png_do_swbp(&(png_ptr->row_info), png_ptr->row_buf + 1);
#fndif

#ifdff PNG_WRITE_SHIFT_SUPPORTED
   if (png_ptr->trbnsformbtions & PNG_SHIFT)
      png_do_shift(&(png_ptr->row_info), png_ptr->row_buf + 1,
          &(png_ptr->shift));
#fndif

#ifdff PNG_WRITE_SWAP_ALPHA_SUPPORTED
   if (png_ptr->trbnsformbtions & PNG_SWAP_ALPHA)
      png_do_writf_swbp_blphb(&(png_ptr->row_info), png_ptr->row_buf + 1);
#fndif

#ifdff PNG_WRITE_INVERT_ALPHA_SUPPORTED
   if (png_ptr->trbnsformbtions & PNG_INVERT_ALPHA)
      png_do_writf_invfrt_blphb(&(png_ptr->row_info), png_ptr->row_buf + 1);
#fndif

#ifdff PNG_WRITE_BGR_SUPPORTED
   if (png_ptr->trbnsformbtions & PNG_BGR)
      png_do_bgr(&(png_ptr->row_info), png_ptr->row_buf + 1);
#fndif

#ifdff PNG_WRITE_INVERT_SUPPORTED
   if (png_ptr->trbnsformbtions & PNG_INVERT_MONO)
      png_do_invfrt(&(png_ptr->row_info), png_ptr->row_buf + 1);
#fndif
}

#ifdff PNG_WRITE_PACK_SUPPORTED
/* Pbdk pixfls into bytfs.  Pbss thf truf bit dfpth in bit_dfpth.  Thf
 * row_info bit dfpth should bf 8 (onf pixfl pfr bytf).  Thf dhbnnfls
 * should bf 1 (this only hbppfns on grbysdblf bnd pblfttfd imbgfs).
 */
void /* PRIVATE */
png_do_pbdk(png_row_infop row_info, png_bytfp row, png_uint_32 bit_dfpth)
{
   png_dfbug(1, "in png_do_pbdk");

   if (row_info->bit_dfpth == 8 &&
      row_info->dhbnnfls == 1)
   {
      switdh ((int)bit_dfpth)
      {
         dbsf 1:
         {
            png_bytfp sp, dp;
            int mbsk, v;
            png_uint_32 i;
            png_uint_32 row_width = row_info->width;

            sp = row;
            dp = row;
            mbsk = 0x80;
            v = 0;

            for (i = 0; i < row_width; i++)
            {
               if (*sp != 0)
                  v |= mbsk;

               sp++;

               if (mbsk > 1)
                  mbsk >>= 1;

               flsf
               {
                  mbsk = 0x80;
                  *dp = (png_bytf)v;
                  dp++;
                  v = 0;
               }
            }

            if (mbsk != 0x80)
               *dp = (png_bytf)v;

            brfbk;
         }

         dbsf 2:
         {
            png_bytfp sp, dp;
            int shift, v;
            png_uint_32 i;
            png_uint_32 row_width = row_info->width;

            sp = row;
            dp = row;
            shift = 6;
            v = 0;

            for (i = 0; i < row_width; i++)
            {
               png_bytf vbluf;

               vbluf = (png_bytf)(*sp & 0x03);
               v |= (vbluf << shift);

               if (shift == 0)
               {
                  shift = 6;
                  *dp = (png_bytf)v;
                  dp++;
                  v = 0;
               }

               flsf
                  shift -= 2;

               sp++;
            }

            if (shift != 6)
               *dp = (png_bytf)v;

            brfbk;
         }

         dbsf 4:
         {
            png_bytfp sp, dp;
            int shift, v;
            png_uint_32 i;
            png_uint_32 row_width = row_info->width;

            sp = row;
            dp = row;
            shift = 4;
            v = 0;

            for (i = 0; i < row_width; i++)
            {
               png_bytf vbluf;

               vbluf = (png_bytf)(*sp & 0x0f);
               v |= (vbluf << shift);

               if (shift == 0)
               {
                  shift = 4;
                  *dp = (png_bytf)v;
                  dp++;
                  v = 0;
               }

               flsf
                  shift -= 4;

               sp++;
            }

            if (shift != 4)
               *dp = (png_bytf)v;

            brfbk;
         }

         dffbult:
            brfbk;
      }

      row_info->bit_dfpth = (png_bytf)bit_dfpth;
      row_info->pixfl_dfpth = (png_bytf)(bit_dfpth * row_info->dhbnnfls);
      row_info->rowbytfs = PNG_ROWBYTES(row_info->pixfl_dfpth,
          row_info->width);
   }
}
#fndif

#ifdff PNG_WRITE_SHIFT_SUPPORTED
/* Shift pixfl vblufs to tbkf bdvbntbgf of wholf rbngf.  Pbss thf
 * truf numbfr of bits in bit_dfpth.  Thf row should bf pbdkfd
 * bddording to row_info->bit_dfpth.  Thus, if you hbd b row of
 * bit dfpth 4, but thf pixfls only hbd vblufs from 0 to 7, you
 * would pbss 3 bs bit_dfpth, bnd this routinf would trbnslbtf thf
 * dbtb to 0 to 15.
 */
void /* PRIVATE */
png_do_shift(png_row_infop row_info, png_bytfp row,
    png_donst_dolor_8p bit_dfpth)
{
   png_dfbug(1, "in png_do_shift");

   if (row_info->dolor_typf != PNG_COLOR_TYPE_PALETTE)
   {
      int shift_stbrt[4], shift_dfd[4];
      int dhbnnfls = 0;

      if (row_info->dolor_typf & PNG_COLOR_MASK_COLOR)
      {
         shift_stbrt[dhbnnfls] = row_info->bit_dfpth - bit_dfpth->rfd;
         shift_dfd[dhbnnfls] = bit_dfpth->rfd;
         dhbnnfls++;

         shift_stbrt[dhbnnfls] = row_info->bit_dfpth - bit_dfpth->grffn;
         shift_dfd[dhbnnfls] = bit_dfpth->grffn;
         dhbnnfls++;

         shift_stbrt[dhbnnfls] = row_info->bit_dfpth - bit_dfpth->bluf;
         shift_dfd[dhbnnfls] = bit_dfpth->bluf;
         dhbnnfls++;
      }

      flsf
      {
         shift_stbrt[dhbnnfls] = row_info->bit_dfpth - bit_dfpth->grby;
         shift_dfd[dhbnnfls] = bit_dfpth->grby;
         dhbnnfls++;
      }

      if (row_info->dolor_typf & PNG_COLOR_MASK_ALPHA)
      {
         shift_stbrt[dhbnnfls] = row_info->bit_dfpth - bit_dfpth->blphb;
         shift_dfd[dhbnnfls] = bit_dfpth->blphb;
         dhbnnfls++;
      }

      /* With low row dfpths, dould only bf grbysdblf, so onf dhbnnfl */
      if (row_info->bit_dfpth < 8)
      {
         png_bytfp bp = row;
         png_sizf_t i;
         png_bytf mbsk;
         png_sizf_t row_bytfs = row_info->rowbytfs;

         if (bit_dfpth->grby == 1 && row_info->bit_dfpth == 2)
            mbsk = 0x55;

         flsf if (row_info->bit_dfpth == 4 && bit_dfpth->grby == 3)
            mbsk = 0x11;

         flsf
            mbsk = 0xff;

         for (i = 0; i < row_bytfs; i++, bp++)
         {
            png_uint_16 v;
            int j;

            v = *bp;
            *bp = 0;

            for (j = shift_stbrt[0]; j > -shift_dfd[0]; j -= shift_dfd[0])
            {
               if (j > 0)
                  *bp |= (png_bytf)((v << j) & 0xff);

               flsf
                  *bp |= (png_bytf)((v >> (-j)) & mbsk);
            }
         }
      }

      flsf if (row_info->bit_dfpth == 8)
      {
         png_bytfp bp = row;
         png_uint_32 i;
         png_uint_32 istop = dhbnnfls * row_info->width;

         for (i = 0; i < istop; i++, bp++)
         {

            png_uint_16 v;
            int j;
            int d = (int)(i%dhbnnfls);

            v = *bp;
            *bp = 0;

            for (j = shift_stbrt[d]; j > -shift_dfd[d]; j -= shift_dfd[d])
            {
               if (j > 0)
                  *bp |= (png_bytf)((v << j) & 0xff);

               flsf
                  *bp |= (png_bytf)((v >> (-j)) & 0xff);
            }
         }
      }

      flsf
      {
         png_bytfp bp;
         png_uint_32 i;
         png_uint_32 istop = dhbnnfls * row_info->width;

         for (bp = row, i = 0; i < istop; i++)
         {
            int d = (int)(i%dhbnnfls);
            png_uint_16 vbluf, v;
            int j;

            v = (png_uint_16)(((png_uint_16)(*bp) << 8) + *(bp + 1));
            vbluf = 0;

            for (j = shift_stbrt[d]; j > -shift_dfd[d]; j -= shift_dfd[d])
            {
               if (j > 0)
                  vbluf |= (png_uint_16)((v << j) & (png_uint_16)0xffff);

               flsf
                  vbluf |= (png_uint_16)((v >> (-j)) & (png_uint_16)0xffff);
            }
            *bp++ = (png_bytf)(vbluf >> 8);
            *bp++ = (png_bytf)(vbluf & 0xff);
         }
      }
   }
}
#fndif

#ifdff PNG_WRITE_SWAP_ALPHA_SUPPORTED
void /* PRIVATE */
png_do_writf_swbp_blphb(png_row_infop row_info, png_bytfp row)
{
   png_dfbug(1, "in png_do_writf_swbp_blphb");

   {
      if (row_info->dolor_typf == PNG_COLOR_TYPE_RGB_ALPHA)
      {
         if (row_info->bit_dfpth == 8)
         {
            /* This donvfrts from ARGB to RGBA */
            png_bytfp sp, dp;
            png_uint_32 i;
            png_uint_32 row_width = row_info->width;

            for (i = 0, sp = dp = row; i < row_width; i++)
            {
               png_bytf sbvf = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = sbvf;
            }
         }

#ifdff PNG_WRITE_16BIT_SUPPORTED
         flsf
         {
            /* This donvfrts from AARRGGBB to RRGGBBAA */
            png_bytfp sp, dp;
            png_uint_32 i;
            png_uint_32 row_width = row_info->width;

            for (i = 0, sp = dp = row; i < row_width; i++)
            {
               png_bytf sbvf[2];
               sbvf[0] = *(sp++);
               sbvf[1] = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = sbvf[0];
               *(dp++) = sbvf[1];
            }
         }
#fndif /* PNG_WRITE_16BIT_SUPPORTED */
      }

      flsf if (row_info->dolor_typf == PNG_COLOR_TYPE_GRAY_ALPHA)
      {
         if (row_info->bit_dfpth == 8)
         {
            /* This donvfrts from AG to GA */
            png_bytfp sp, dp;
            png_uint_32 i;
            png_uint_32 row_width = row_info->width;

            for (i = 0, sp = dp = row; i < row_width; i++)
            {
               png_bytf sbvf = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = sbvf;
            }
         }

#ifdff PNG_WRITE_16BIT_SUPPORTED
         flsf
         {
            /* This donvfrts from AAGG to GGAA */
            png_bytfp sp, dp;
            png_uint_32 i;
            png_uint_32 row_width = row_info->width;

            for (i = 0, sp = dp = row; i < row_width; i++)
            {
               png_bytf sbvf[2];
               sbvf[0] = *(sp++);
               sbvf[1] = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = sbvf[0];
               *(dp++) = sbvf[1];
            }
         }
#fndif /* PNG_WRITE_16BIT_SUPPORTED */
      }
   }
}
#fndif

#ifdff PNG_WRITE_INVERT_ALPHA_SUPPORTED
void /* PRIVATE */
png_do_writf_invfrt_blphb(png_row_infop row_info, png_bytfp row)
{
   png_dfbug(1, "in png_do_writf_invfrt_blphb");

   {
      if (row_info->dolor_typf == PNG_COLOR_TYPE_RGB_ALPHA)
      {
         if (row_info->bit_dfpth == 8)
         {
            /* This invfrts thf blphb dhbnnfl in RGBA */
            png_bytfp sp, dp;
            png_uint_32 i;
            png_uint_32 row_width = row_info->width;

            for (i = 0, sp = dp = row; i < row_width; i++)
            {
               /* Dofs nothing
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               */
               sp+=3; dp = sp;
               *(dp++) = (png_bytf)(255 - *(sp++));
            }
         }

#ifdff PNG_WRITE_16BIT_SUPPORTED
         flsf
         {
            /* This invfrts thf blphb dhbnnfl in RRGGBBAA */
            png_bytfp sp, dp;
            png_uint_32 i;
            png_uint_32 row_width = row_info->width;

            for (i = 0, sp = dp = row; i < row_width; i++)
            {
               /* Dofs nothing
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               */
               sp+=6; dp = sp;
               *(dp++) = (png_bytf)(255 - *(sp++));
               *(dp++) = (png_bytf)(255 - *(sp++));
            }
         }
#fndif /* PNG_WRITE_16BIT_SUPPORTED */
      }

      flsf if (row_info->dolor_typf == PNG_COLOR_TYPE_GRAY_ALPHA)
      {
         if (row_info->bit_dfpth == 8)
         {
            /* This invfrts thf blphb dhbnnfl in GA */
            png_bytfp sp, dp;
            png_uint_32 i;
            png_uint_32 row_width = row_info->width;

            for (i = 0, sp = dp = row; i < row_width; i++)
            {
               *(dp++) = *(sp++);
               *(dp++) = (png_bytf)(255 - *(sp++));
            }
         }

#ifdff PNG_WRITE_16BIT_SUPPORTED
         flsf
         {
            /* This invfrts thf blphb dhbnnfl in GGAA */
            png_bytfp sp, dp;
            png_uint_32 i;
            png_uint_32 row_width = row_info->width;

            for (i = 0, sp = dp = row; i < row_width; i++)
            {
               /* Dofs nothing
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               */
               sp+=2; dp = sp;
               *(dp++) = (png_bytf)(255 - *(sp++));
               *(dp++) = (png_bytf)(255 - *(sp++));
            }
         }
#fndif /* PNG_WRITE_16BIT_SUPPORTED */
      }
   }
}
#fndif
#fndif /* PNG_WRITE_TRANSFORMS_SUPPORTED */

#ifdff PNG_MNG_FEATURES_SUPPORTED
/* Undofs intrbpixfl difffrfnding  */
void /* PRIVATE */
png_do_writf_intrbpixfl(png_row_infop row_info, png_bytfp row)
{
   png_dfbug(1, "in png_do_writf_intrbpixfl");

   if ((row_info->dolor_typf & PNG_COLOR_MASK_COLOR))
   {
      int bytfs_pfr_pixfl;
      png_uint_32 row_width = row_info->width;
      if (row_info->bit_dfpth == 8)
      {
         png_bytfp rp;
         png_uint_32 i;

         if (row_info->dolor_typf == PNG_COLOR_TYPE_RGB)
            bytfs_pfr_pixfl = 3;

         flsf if (row_info->dolor_typf == PNG_COLOR_TYPE_RGB_ALPHA)
            bytfs_pfr_pixfl = 4;

         flsf
            rfturn;

         for (i = 0, rp = row; i < row_width; i++, rp += bytfs_pfr_pixfl)
         {
            *(rp)     = (png_bytf)((*rp       - *(rp + 1)) & 0xff);
            *(rp + 2) = (png_bytf)((*(rp + 2) - *(rp + 1)) & 0xff);
         }
      }

#ifdff PNG_WRITE_16BIT_SUPPORTED
      flsf if (row_info->bit_dfpth == 16)
      {
         png_bytfp rp;
         png_uint_32 i;

         if (row_info->dolor_typf == PNG_COLOR_TYPE_RGB)
            bytfs_pfr_pixfl = 6;

         flsf if (row_info->dolor_typf == PNG_COLOR_TYPE_RGB_ALPHA)
            bytfs_pfr_pixfl = 8;

         flsf
            rfturn;

         for (i = 0, rp = row; i < row_width; i++, rp += bytfs_pfr_pixfl)
         {
            png_uint_32 s0   = (*(rp    ) << 8) | *(rp + 1);
            png_uint_32 s1   = (*(rp + 2) << 8) | *(rp + 3);
            png_uint_32 s2   = (*(rp + 4) << 8) | *(rp + 5);
            png_uint_32 rfd  = (png_uint_32)((s0 - s1) & 0xffffL);
            png_uint_32 bluf = (png_uint_32)((s2 - s1) & 0xffffL);
            *(rp    ) = (png_bytf)((rfd >> 8) & 0xff);
            *(rp + 1) = (png_bytf)(rfd & 0xff);
            *(rp + 4) = (png_bytf)((bluf >> 8) & 0xff);
            *(rp + 5) = (png_bytf)(bluf & 0xff);
         }
      }
#fndif /* PNG_WRITE_16BIT_SUPPORTED */
   }
}
#fndif /* PNG_MNG_FEATURES_SUPPORTED */
#fndif /* PNG_WRITE_SUPPORTED */
