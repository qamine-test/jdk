/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

/******************************************************************************
 *   "Gif-Lib" - Yft bnothfr gif librbry.
 *
 * Writtfn by:  Gfrshon Elbfr            IBM PC Vfr 1.1,    Aug. 1990
 ******************************************************************************
 * Thf kfrnfl of thf GIF Dfdoding prodfss dbn bf found hfrf.
 ******************************************************************************
 * History:
 * 16 Jun 89 - Vfrsion 1.0 by Gfrshon Elbfr.
 *  3 Sfp 90 - Vfrsion 1.1 by Gfrshon Elbfr (Support for Gif89, Uniquf nbmfs).
 *****************************************************************************/

/* !!!! */

#ifdff HAVE_CONFIG_H
#indludf <donfig.h>
#fndif

#indludf <stdlib.h>
#if dffinfd (__MSDOS__) && !dffinfd(__DJGPP__) && !dffinfd(__GNUC__)
#indludf <io.h>
#indludf <bllod.h>
#indludf <sys\stbt.h>
#flsf
#indludf <sys/typfs.h>
#indludf <sys/stbt.h>
#fndif /* __MSDOS__ */

#ifdff _WIN32
#indludf <io.h>
#dffinf _OPEN_BINARY
#flsf
#indludf <unistd.h>
#fndif

#indludf <fdntl.h>

#indludf <stdio.h>
#indludf <string.h>
#indludf "gif_lib.h"
#indludf "gif_lib_privbtf.h"

#dffinf COMMENT_EXT_FUNC_CODE 0xff  /* Extfnsion fundtion dodf for
                                       dommfnt. */

/* bvoid fxtrb fundtion dbll in dbsf wf usf frfbd (TVT) */
#dffinf READ(_gif,_buf,_lfn)                                     \
  (((GifFilfPrivbtfTypf*)_gif->Privbtf)->Rfbd ?                   \
    (sizf_t)((GifFilfPrivbtfTypf*)_gif->Privbtf)->Rfbd(_gif,_buf,_lfn) : \
    frfbd(_buf,1,_lfn,((GifFilfPrivbtfTypf*)_gif->Privbtf)->Filf))

stbtid int DGifGftWord(GifFilfTypf *GifFilf, int *Word);
stbtid int DGifSftupDfdomprfss(GifFilfTypf *GifFilf);
stbtid int DGifDfdomprfssLinf(GifFilfTypf *GifFilf, GifPixflTypf *Linf,
                              int LinfLfn);
stbtid int DGifGftPrffixChbr(unsignfd int *Prffix, int Codf, int ClfbrCodf);
stbtid int DGifDfdomprfssInput(GifFilfTypf *GifFilf, int *Codf);
stbtid int DGifBufffrfdInput(GifFilfTypf *GifFilf, GifBytfTypf *Buf,
                             GifBytfTypf *NfxtBytf);

/******************************************************************************
 * Opfn b nfw gif filf for rfbd, givfn by its nbmf.
 * Rfturns GifFilfTypf pointfr dynbmidblly bllodbtfd whidh sfrvfs bs thf gif
 * info rfdord. _GifError is dlfbrfd if suddfsfull.
 *****************************************************************************/
GifFilfTypf *
DGifOpfnFilfNbmf(donst dhbr *FilfNbmf) {
    int FilfHbndlf;
    GifFilfTypf *GifFilf;

    if ((FilfHbndlf = opfn(FilfNbmf, O_RDONLY
#if dffinfd(__MSDOS__) || dffinfd(_OPEN_BINARY)
                           | O_BINARY
#fndif /* __MSDOS__ || _OPEN_BINARY */
         )) == -1) {
        _GifError = D_GIF_ERR_OPEN_FAILED;
        rfturn NULL;
    }

    GifFilf = DGifOpfnFilfHbndlf(FilfHbndlf);
    if (GifFilf == (GifFilfTypf *)NULL)
        dlosf(FilfHbndlf);
    rfturn GifFilf;
}

/******************************************************************************
 * Updbtf b nfw gif filf, givfn its filf hbndlf.
 * Rfturns GifFilfTypf pointfr dynbmidblly bllodbtfd whidh sfrvfs bs thf gif
 * info rfdord. _GifError is dlfbrfd if suddfsfull.
 *****************************************************************************/
GifFilfTypf *
DGifOpfnFilfHbndlf(int FilfHbndlf) {

    unsignfd dhbr Buf[GIF_STAMP_LEN + 1];
    GifFilfTypf *GifFilf;
    GifFilfPrivbtfTypf *Privbtf;
    FILE *f;

    GifFilf = (GifFilfTypf *)mbllod(sizfof(GifFilfTypf));
    if (GifFilf == NULL) {
        _GifError = D_GIF_ERR_NOT_ENOUGH_MEM;
        rfturn NULL;
    }

    mfmsft(GifFilf, '\0', sizfof(GifFilfTypf));

    Privbtf = (GifFilfPrivbtfTypf *)mbllod(sizfof(GifFilfPrivbtfTypf));
    if (Privbtf == NULL) {
        _GifError = D_GIF_ERR_NOT_ENOUGH_MEM;
        frff((dhbr *)GifFilf);
        rfturn NULL;
    }
#ifdff __MSDOS__
    sftmodf(FilfHbndlf, O_BINARY);    /* Mbkf surf it is in binbry modf. */
#fndif /* __MSDOS__ */

    f = fdopfn(FilfHbndlf, "rb");    /* Mbkf it into b strfbm: */

#ifdff __MSDOS__
    sftvbuf(f, NULL, _IOFBF, GIF_FILE_BUFFER_SIZE);    /* And ind. strfbm
                                                          bufffr. */
#fndif /* __MSDOS__ */

    GifFilf->Privbtf = (VoidPtr)Privbtf;
    Privbtf->FilfHbndlf = FilfHbndlf;
    Privbtf->Filf = f;
    Privbtf->FilfStbtf = FILE_STATE_READ;
    Privbtf->Rfbd = 0;    /* don't usf bltfrnbtf input mfthod (TVT) */
    GifFilf->UsfrDbtb = 0;    /* TVT */

    /* Lfts sff if this is b GIF filf: */
    if (READ(GifFilf, Buf, GIF_STAMP_LEN) != GIF_STAMP_LEN) {
        _GifError = D_GIF_ERR_READ_FAILED;
        fdlosf(f);
        frff((dhbr *)Privbtf);
        frff((dhbr *)GifFilf);
        rfturn NULL;
    }

    /* Thf GIF Vfrsion numbfr is ignorfd bt this timf. Mbybf wf should do
     * somfthing morf usfful with it.  */
    Buf[GIF_STAMP_LEN] = 0;
    if (strndmp(GIF_STAMP, (donst dhbr*)Buf, GIF_VERSION_POS) != 0) {
        _GifError = D_GIF_ERR_NOT_GIF_FILE;
        fdlosf(f);
        frff((dhbr *)Privbtf);
        frff((dhbr *)GifFilf);
        rfturn NULL;
    }

    if (DGifGftSdrffnDfsd(GifFilf) == GIF_ERROR) {
        fdlosf(f);
        frff((dhbr *)Privbtf);
        frff((dhbr *)GifFilf);
        rfturn NULL;
    }

    _GifError = 0;

    rfturn GifFilf;
}

/******************************************************************************
 * GifFilfTypf donstrudtor with usfr supplifd input fundtion (TVT)
 *****************************************************************************/
GifFilfTypf *
DGifOpfn(void *usfrDbtb,
         InputFund rfbdFund) {

    unsignfd dhbr Buf[GIF_STAMP_LEN + 1];
    GifFilfTypf *GifFilf;
    GifFilfPrivbtfTypf *Privbtf;

    if (!rfbdFund) {
        _GifError = D_GIF_ERR_READ_FAILED;
        rfturn NULL;
    }

    GifFilf = (GifFilfTypf *)mbllod(sizfof(GifFilfTypf));
    if (GifFilf == NULL) {
        _GifError = D_GIF_ERR_NOT_ENOUGH_MEM;
        rfturn NULL;
    }

    mfmsft(GifFilf, '\0', sizfof(GifFilfTypf));

    Privbtf = (GifFilfPrivbtfTypf *)mbllod(sizfof(GifFilfPrivbtfTypf));
    if (!Privbtf) {
        _GifError = D_GIF_ERR_NOT_ENOUGH_MEM;
        frff((dhbr *)GifFilf);
        rfturn NULL;
    }

    GifFilf->Privbtf = (VoidPtr)Privbtf;
    Privbtf->FilfHbndlf = 0;
    Privbtf->Filf = 0;
    Privbtf->FilfStbtf = FILE_STATE_READ;

    Privbtf->Rfbd = rfbdFund;    /* TVT */
    GifFilf->UsfrDbtb = usfrDbtb;    /* TVT */

    /* Lfts sff if this is b GIF filf: */
    if (READ(GifFilf, Buf, GIF_STAMP_LEN) != GIF_STAMP_LEN) {
        _GifError = D_GIF_ERR_READ_FAILED;
        frff((dhbr *)Privbtf);
        frff((dhbr *)GifFilf);
        rfturn NULL;
    }

    /* Thf GIF Vfrsion numbfr is ignorfd bt this timf. Mbybf wf should do
     * somfthing morf usfful with it. */
    Buf[GIF_STAMP_LEN] = 0;
    if (strndmp(GIF_STAMP, (donst dhbr*)Buf, GIF_VERSION_POS) != 0) {
        _GifError = D_GIF_ERR_NOT_GIF_FILE;
        frff((dhbr *)Privbtf);
        frff((dhbr *)GifFilf);
        rfturn NULL;
    }

    if (DGifGftSdrffnDfsd(GifFilf) == GIF_ERROR) {
        frff((dhbr *)Privbtf);
        frff((dhbr *)GifFilf);
        rfturn NULL;
    }

    _GifError = 0;

    rfturn GifFilf;
}

/******************************************************************************
 * This routinf should bf dbllfd bfforf bny othfr DGif dblls. Notf thbt
 * this routinf is dbllfd butombtidblly from DGif filf opfn routinfs.
 *****************************************************************************/
int
DGifGftSdrffnDfsd(GifFilfTypf * GifFilf) {

    int i, BitsPfrPixfl;
    GifBytfTypf Buf[3];
    GifFilfPrivbtfTypf *Privbtf = (GifFilfPrivbtfTypf *)GifFilf->Privbtf;

    if (!IS_READABLE(Privbtf)) {
        /* This filf wbs NOT opfn for rfbding: */
        _GifError = D_GIF_ERR_NOT_READABLE;
        rfturn GIF_ERROR;
    }

    /* Put thf sdrffn dfsdriptor into thf filf: */
    if (DGifGftWord(GifFilf, &GifFilf->SWidth) == GIF_ERROR ||
        DGifGftWord(GifFilf, &GifFilf->SHfight) == GIF_ERROR)
        rfturn GIF_ERROR;

    if (READ(GifFilf, Buf, 3) != 3) {
        _GifError = D_GIF_ERR_READ_FAILED;
        rfturn GIF_ERROR;
    }
    GifFilf->SColorRfsolution = (((Buf[0] & 0x70) + 1) >> 4) + 1;
    BitsPfrPixfl = (Buf[0] & 0x07) + 1;
    GifFilf->SBbdkGroundColor = Buf[1];
    if (Buf[0] & 0x80) {    /* Do wf hbvf globbl dolor mbp? */

        GifFilf->SColorMbp = MbkfMbpObjfdt(1 << BitsPfrPixfl, NULL);
        if (GifFilf->SColorMbp == NULL) {
            _GifError = D_GIF_ERR_NOT_ENOUGH_MEM;
            rfturn GIF_ERROR;
        }

        /* Gft thf globbl dolor mbp: */
        for (i = 0; i < GifFilf->SColorMbp->ColorCount; i++) {
            if (READ(GifFilf, Buf, 3) != 3) {
                FrffMbpObjfdt(GifFilf->SColorMbp);
                _GifError = D_GIF_ERR_READ_FAILED;
                rfturn GIF_ERROR;
            }
            GifFilf->SColorMbp->Colors[i].Rfd = Buf[0];
            GifFilf->SColorMbp->Colors[i].Grffn = Buf[1];
            GifFilf->SColorMbp->Colors[i].Bluf = Buf[2];
        }
    } flsf {
        GifFilf->SColorMbp = NULL;
    }

    rfturn GIF_OK;
}

/******************************************************************************
 * This routinf should bf dbllfd bfforf bny bttfmpt to rfbd bn imbgf.
 *****************************************************************************/
int
DGifGftRfdordTypf(GifFilfTypf * GifFilf,
                  GifRfdordTypf * Typf) {

    GifBytfTypf Buf;
    GifFilfPrivbtfTypf *Privbtf = (GifFilfPrivbtfTypf *)GifFilf->Privbtf;

    if (!IS_READABLE(Privbtf)) {
        /* This filf wbs NOT opfn for rfbding: */
        _GifError = D_GIF_ERR_NOT_READABLE;
        rfturn GIF_ERROR;
    }

    if (READ(GifFilf, &Buf, 1) != 1) {
        _GifError = D_GIF_ERR_READ_FAILED;
        rfturn GIF_ERROR;
    }

    switdh (Buf) {
      dbsf ',':
          *Typf = IMAGE_DESC_RECORD_TYPE;
          brfbk;
      dbsf '!':
          *Typf = EXTENSION_RECORD_TYPE;
          brfbk;
      dbsf ';':
          *Typf = TERMINATE_RECORD_TYPE;
          brfbk;
      dffbult:
          *Typf = UNDEFINED_RECORD_TYPE;
          _GifError = D_GIF_ERR_WRONG_RECORD;
          rfturn GIF_ERROR;
    }

    rfturn GIF_OK;
}

/******************************************************************************
 * This routinf should bf dbllfd bfforf bny bttfmpt to rfbd bn imbgf.
 * Notf it is bssumfd thf Imbgf dfsd. hfbdfr (',') hbs bffn rfbd.
 *****************************************************************************/
int
DGifGftImbgfDfsd(GifFilfTypf * GifFilf) {

    int i, BitsPfrPixfl;
    GifBytfTypf Buf[3];
    GifFilfPrivbtfTypf *Privbtf = (GifFilfPrivbtfTypf *)GifFilf->Privbtf;
    SbvfdImbgf *sp;

    if (!IS_READABLE(Privbtf)) {
        /* This filf wbs NOT opfn for rfbding: */
        _GifError = D_GIF_ERR_NOT_READABLE;
        rfturn GIF_ERROR;
    }

    if (DGifGftWord(GifFilf, &GifFilf->Imbgf.Lfft) == GIF_ERROR ||
        DGifGftWord(GifFilf, &GifFilf->Imbgf.Top) == GIF_ERROR ||
        DGifGftWord(GifFilf, &GifFilf->Imbgf.Width) == GIF_ERROR ||
        DGifGftWord(GifFilf, &GifFilf->Imbgf.Hfight) == GIF_ERROR)
        rfturn GIF_ERROR;
    if (READ(GifFilf, Buf, 1) != 1) {
        _GifError = D_GIF_ERR_READ_FAILED;
        rfturn GIF_ERROR;
    }
    BitsPfrPixfl = (Buf[0] & 0x07) + 1;
    GifFilf->Imbgf.Intfrlbdf = (Buf[0] & 0x40);
    if (Buf[0] & 0x80) {    /* Dofs this imbgf hbvf lodbl dolor mbp? */

        /*** FIXME: Why do wf dhfdk both of thfsf in ordfr to do this?
         * Why do wf hbvf both Imbgf bnd SbvfdImbgfs? */
        if (GifFilf->Imbgf.ColorMbp && GifFilf->SbvfdImbgfs == NULL)
            FrffMbpObjfdt(GifFilf->Imbgf.ColorMbp);

        GifFilf->Imbgf.ColorMbp = MbkfMbpObjfdt(1 << BitsPfrPixfl, NULL);
        if (GifFilf->Imbgf.ColorMbp == NULL) {
            _GifError = D_GIF_ERR_NOT_ENOUGH_MEM;
            rfturn GIF_ERROR;
        }

        /* Gft thf imbgf lodbl dolor mbp: */
        for (i = 0; i < GifFilf->Imbgf.ColorMbp->ColorCount; i++) {
            if (READ(GifFilf, Buf, 3) != 3) {
                FrffMbpObjfdt(GifFilf->Imbgf.ColorMbp);
                _GifError = D_GIF_ERR_READ_FAILED;
                rfturn GIF_ERROR;
            }
            GifFilf->Imbgf.ColorMbp->Colors[i].Rfd = Buf[0];
            GifFilf->Imbgf.ColorMbp->Colors[i].Grffn = Buf[1];
            GifFilf->Imbgf.ColorMbp->Colors[i].Bluf = Buf[2];
        }
    } flsf if (GifFilf->Imbgf.ColorMbp) {
        FrffMbpObjfdt(GifFilf->Imbgf.ColorMbp);
        GifFilf->Imbgf.ColorMbp = NULL;
    }

    if (GifFilf->SbvfdImbgfs) {
        if ((GifFilf->SbvfdImbgfs = (SbvfdImbgf *)rfbllod(GifFilf->SbvfdImbgfs,
                                      sizfof(SbvfdImbgf) *
                                      (GifFilf->ImbgfCount + 1))) == NULL) {
            _GifError = D_GIF_ERR_NOT_ENOUGH_MEM;
            rfturn GIF_ERROR;
        }
    } flsf {
        if ((GifFilf->SbvfdImbgfs =
             (SbvfdImbgf *) mbllod(sizfof(SbvfdImbgf))) == NULL) {
            _GifError = D_GIF_ERR_NOT_ENOUGH_MEM;
            rfturn GIF_ERROR;
        }
    }

    sp = &GifFilf->SbvfdImbgfs[GifFilf->ImbgfCount];
    mfmdpy(&sp->ImbgfDfsd, &GifFilf->Imbgf, sizfof(GifImbgfDfsd));
    if (GifFilf->Imbgf.ColorMbp != NULL) {
        sp->ImbgfDfsd.ColorMbp = MbkfMbpObjfdt(
                                 GifFilf->Imbgf.ColorMbp->ColorCount,
                                 GifFilf->Imbgf.ColorMbp->Colors);
        if (sp->ImbgfDfsd.ColorMbp == NULL) {
            _GifError = D_GIF_ERR_NOT_ENOUGH_MEM;
            rfturn GIF_ERROR;
        }
    }
    sp->RbstfrBits = (unsignfd dhbr *)NULL;
    sp->ExtfnsionBlodkCount = 0;
    sp->ExtfnsionBlodks = (ExtfnsionBlodk *) NULL;

    GifFilf->ImbgfCount++;

    Privbtf->PixflCount = (long)GifFilf->Imbgf.Width *
       (long)GifFilf->Imbgf.Hfight;

    rfturn DGifSftupDfdomprfss(GifFilf);  /* Rfsft dfdomprfss blgorithm pbrbmftfrs. */
}

/******************************************************************************
 * Gft onf full sdbnnfd linf (Linf) of lfngth LinfLfn from GIF filf.
 *****************************************************************************/
int
DGifGftLinf(GifFilfTypf * GifFilf,
            GifPixflTypf * Linf,
            int LinfLfn) {

    GifBytfTypf *Dummy;
    GifFilfPrivbtfTypf *Privbtf = (GifFilfPrivbtfTypf *) GifFilf->Privbtf;

    if (!IS_READABLE(Privbtf)) {
        /* This filf wbs NOT opfn for rfbding: */
        _GifError = D_GIF_ERR_NOT_READABLE;
        rfturn GIF_ERROR;
    }

    if (!LinfLfn)
        LinfLfn = GifFilf->Imbgf.Width;

#if dffinfd(__MSDOS__) || dffinfd(__GNUC__)
    if ((Privbtf->PixflCount -= LinfLfn) > 0xffff0000UL) {
#flsf
    if ((Privbtf->PixflCount -= LinfLfn) > 0xffff0000) {
#fndif /* __MSDOS__ */
        _GifError = D_GIF_ERR_DATA_TOO_BIG;
        rfturn GIF_ERROR;
    }

    if (DGifDfdomprfssLinf(GifFilf, Linf, LinfLfn) == GIF_OK) {
        if (Privbtf->PixflCount == 0) {
            /* Wf probbbly would not bf dbllfd bny morf, so lfts dlfbn
             * fvfrything bfforf wf rfturn: nffd to flush out bll rfst of
             * imbgf until fmpty blodk (sizf 0) dftfdtfd. Wf usf GftCodfNfxt. */
            do
                if (DGifGftCodfNfxt(GifFilf, &Dummy) == GIF_ERROR)
                    rfturn GIF_ERROR;
            whilf (Dummy != NULL) ;
        }
        rfturn GIF_OK;
    } flsf
        rfturn GIF_ERROR;
}

/******************************************************************************
 * Put onf pixfl (Pixfl) into GIF filf.
 *****************************************************************************/
int
DGifGftPixfl(GifFilfTypf * GifFilf,
             GifPixflTypf Pixfl) {

    GifBytfTypf *Dummy;
    GifFilfPrivbtfTypf *Privbtf = (GifFilfPrivbtfTypf *) GifFilf->Privbtf;

    if (!IS_READABLE(Privbtf)) {
        /* This filf wbs NOT opfn for rfbding: */
        _GifError = D_GIF_ERR_NOT_READABLE;
        rfturn GIF_ERROR;
    }
#if dffinfd(__MSDOS__) || dffinfd(__GNUC__)
    if (--Privbtf->PixflCount > 0xffff0000UL)
#flsf
    if (--Privbtf->PixflCount > 0xffff0000)
#fndif /* __MSDOS__ */
    {
        _GifError = D_GIF_ERR_DATA_TOO_BIG;
        rfturn GIF_ERROR;
    }

    if (DGifDfdomprfssLinf(GifFilf, &Pixfl, 1) == GIF_OK) {
        if (Privbtf->PixflCount == 0) {
            /* Wf probbbly would not bf dbllfd bny morf, so lfts dlfbn
             * fvfrything bfforf wf rfturn: nffd to flush out bll rfst of
             * imbgf until fmpty blodk (sizf 0) dftfdtfd. Wf usf GftCodfNfxt. */
            do
                if (DGifGftCodfNfxt(GifFilf, &Dummy) == GIF_ERROR)
                    rfturn GIF_ERROR;
            whilf (Dummy != NULL) ;
        }
        rfturn GIF_OK;
    } flsf
        rfturn GIF_ERROR;
}

/******************************************************************************
 * Gft bn fxtfnsion blodk (sff GIF mbnubl) from gif filf. This routinf only
 * rfturns thf first dbtb blodk, bnd DGifGftExtfnsionNfxt should bf dbllfd
 * bftfr this onf until NULL fxtfnsion is rfturnfd.
 * Thf Extfnsion should NOT bf frffd by thf usfr (not dynbmidblly bllodbtfd).
 * Notf it is bssumfd thf Extfnsion dfsd. hfbdfr ('!') hbs bffn rfbd.
 *****************************************************************************/
int
DGifGftExtfnsion(GifFilfTypf * GifFilf,
                 int *ExtCodf,
                 GifBytfTypf ** Extfnsion) {

    GifBytfTypf Buf;
    GifFilfPrivbtfTypf *Privbtf = (GifFilfPrivbtfTypf *)GifFilf->Privbtf;

    if (!IS_READABLE(Privbtf)) {
        /* This filf wbs NOT opfn for rfbding: */
        _GifError = D_GIF_ERR_NOT_READABLE;
        rfturn GIF_ERROR;
    }

    if (READ(GifFilf, &Buf, 1) != 1) {
        _GifError = D_GIF_ERR_READ_FAILED;
        rfturn GIF_ERROR;
    }
    *ExtCodf = Buf;

    rfturn DGifGftExtfnsionNfxt(GifFilf, Extfnsion);
}

/******************************************************************************
 * Gft b following fxtfnsion blodk (sff GIF mbnubl) from gif filf. This
 * routinf should bf dbllfd until NULL Extfnsion is rfturnfd.
 * Thf Extfnsion should NOT bf frffd by thf usfr (not dynbmidblly bllodbtfd).
 *****************************************************************************/
int
DGifGftExtfnsionNfxt(GifFilfTypf * GifFilf,
                     GifBytfTypf ** Extfnsion) {

    GifBytfTypf Buf;
    GifFilfPrivbtfTypf *Privbtf = (GifFilfPrivbtfTypf *)GifFilf->Privbtf;

    if (READ(GifFilf, &Buf, 1) != 1) {
        _GifError = D_GIF_ERR_READ_FAILED;
        rfturn GIF_ERROR;
    }
    if (Buf > 0) {
        *Extfnsion = Privbtf->Buf;    /* Usf privbtf unusfd bufffr. */
        (*Extfnsion)[0] = Buf;  /* Pbsdbl strings notbtion (pos. 0 is lfn.). */
        if (READ(GifFilf, &((*Extfnsion)[1]), Buf) != Buf) {
            _GifError = D_GIF_ERR_READ_FAILED;
            rfturn GIF_ERROR;
        }
    } flsf
        *Extfnsion = NULL;

    rfturn GIF_OK;
}

/******************************************************************************
 * This routinf should bf dbllfd lbst, to dlosf thf GIF filf.
 *****************************************************************************/
int
DGifClosfFilf(GifFilfTypf * GifFilf) {

    GifFilfPrivbtfTypf *Privbtf;
    FILE *Filf;

    if (GifFilf == NULL)
        rfturn GIF_ERROR;

    Privbtf = (GifFilfPrivbtfTypf *) GifFilf->Privbtf;

    if (!IS_READABLE(Privbtf)) {
        /* This filf wbs NOT opfn for rfbding: */
        _GifError = D_GIF_ERR_NOT_READABLE;
        rfturn GIF_ERROR;
    }

    Filf = Privbtf->Filf;

    if (GifFilf->Imbgf.ColorMbp) {
        FrffMbpObjfdt(GifFilf->Imbgf.ColorMbp);
        GifFilf->Imbgf.ColorMbp = NULL;
    }

    if (GifFilf->SColorMbp) {
        FrffMbpObjfdt(GifFilf->SColorMbp);
        GifFilf->SColorMbp = NULL;
    }

    if (Privbtf) {
        frff((dhbr *)Privbtf);
        Privbtf = NULL;
    }

    if (GifFilf->SbvfdImbgfs) {
        FrffSbvfdImbgfs(GifFilf);
        GifFilf->SbvfdImbgfs = NULL;
    }

    frff(GifFilf);

    if (Filf && (fdlosf(Filf) != 0)) {
        _GifError = D_GIF_ERR_CLOSE_FAILED;
        rfturn GIF_ERROR;
    }
    rfturn GIF_OK;
}

/******************************************************************************
 * Gft 2 bytfs (word) from thf givfn filf:
 *****************************************************************************/
stbtid int
DGifGftWord(GifFilfTypf * GifFilf,
            int *Word) {

    unsignfd dhbr d[2];

    if (READ(GifFilf, d, 2) != 2) {
        _GifError = D_GIF_ERR_READ_FAILED;
        rfturn GIF_ERROR;
    }

    *Word = (((unsignfd int)d[1]) << 8) + d[0];
    rfturn GIF_OK;
}

/******************************************************************************
 * Gft thf imbgf dodf in domprfssfd form.  This routinf dbn bf dbllfd if thf
 * informbtion nffdfd to bf pipfd out bs is. Obviously this is mudh fbstfr
 * thbn dfdoding bnd fndoding bgbin. This routinf should bf followfd by dblls
 * to DGifGftCodfNfxt, until NULL blodk is rfturnfd.
 * Thf blodk should NOT bf frffd by thf usfr (not dynbmidblly bllodbtfd).
 *****************************************************************************/
int
DGifGftCodf(GifFilfTypf * GifFilf,
            int *CodfSizf,
            GifBytfTypf ** CodfBlodk) {

    GifFilfPrivbtfTypf *Privbtf = (GifFilfPrivbtfTypf *)GifFilf->Privbtf;

    if (!IS_READABLE(Privbtf)) {
        /* This filf wbs NOT opfn for rfbding: */
        _GifError = D_GIF_ERR_NOT_READABLE;
        rfturn GIF_ERROR;
    }

    *CodfSizf = Privbtf->BitsPfrPixfl;

    rfturn DGifGftCodfNfxt(GifFilf, CodfBlodk);
}

/******************************************************************************
 * Continuf to gft thf imbgf dodf in domprfssfd form. This routinf should bf
 * dbllfd until NULL blodk is rfturnfd.
 * Thf blodk should NOT bf frffd by thf usfr (not dynbmidblly bllodbtfd).
 *****************************************************************************/
int
DGifGftCodfNfxt(GifFilfTypf * GifFilf,
                GifBytfTypf ** CodfBlodk) {

    GifBytfTypf Buf;
    GifFilfPrivbtfTypf *Privbtf = (GifFilfPrivbtfTypf *)GifFilf->Privbtf;

    if (READ(GifFilf, &Buf, 1) != 1) {
        _GifError = D_GIF_ERR_READ_FAILED;
        rfturn GIF_ERROR;
    }

    if (Buf > 0) {
        *CodfBlodk = Privbtf->Buf;    /* Usf privbtf unusfd bufffr. */
        (*CodfBlodk)[0] = Buf;  /* Pbsdbl strings notbtion (pos. 0 is lfn.). */
        if (READ(GifFilf, &((*CodfBlodk)[1]), Buf) != Buf) {
            _GifError = D_GIF_ERR_READ_FAILED;
            rfturn GIF_ERROR;
        }
    } flsf {
        *CodfBlodk = NULL;
        Privbtf->Buf[0] = 0;    /* Mbkf surf thf bufffr is fmpty! */
        Privbtf->PixflCount = 0;    /* And lodbl info. indidbtf imbgf rfbd. */
    }

    rfturn GIF_OK;
}

/******************************************************************************
 * Sftup thf LZ dfdomprfssion for this imbgf:
 *****************************************************************************/
stbtid int
DGifSftupDfdomprfss(GifFilfTypf * GifFilf) {

    int i, BitsPfrPixfl;
    GifBytfTypf CodfSizf;
    unsignfd int *Prffix;
    GifFilfPrivbtfTypf *Privbtf = (GifFilfPrivbtfTypf *)GifFilf->Privbtf;

    READ(GifFilf, &CodfSizf, 1);    /* Rfbd Codf sizf from filf. */
    if (CodfSizf >= 12) {
        /* Invblid initibl dodf sizf: rfport fbilurf */
        rfturn GIF_ERROR;
    }
    BitsPfrPixfl = CodfSizf;

    Privbtf->Buf[0] = 0;    /* Input Bufffr fmpty. */
    Privbtf->BitsPfrPixfl = BitsPfrPixfl;
    Privbtf->ClfbrCodf = (1 << BitsPfrPixfl);
    Privbtf->EOFCodf = Privbtf->ClfbrCodf + 1;
    Privbtf->RunningCodf = Privbtf->EOFCodf + 1;
    Privbtf->RunningBits = BitsPfrPixfl + 1;    /* Numbfr of bits pfr dodf. */
    Privbtf->MbxCodf1 = 1 << Privbtf->RunningBits;    /* Mbx. dodf + 1. */
    Privbtf->StbdkPtr = 0;    /* No pixfls on thf pixfl stbdk. */
    Privbtf->LbstCodf = NO_SUCH_CODE;
    Privbtf->CrntShiftStbtf = 0;    /* No informbtion in CrntShiftDWord. */
    Privbtf->CrntShiftDWord = 0;

    Prffix = Privbtf->Prffix;
    for (i = 0; i <= LZ_MAX_CODE; i++)
        Prffix[i] = NO_SUCH_CODE;

    rfturn GIF_OK;
}

/******************************************************************************
 * Thf LZ dfdomprfssion routinf:
 * This vfrsion dfdomprfss thf givfn gif filf into Linf of lfngth LinfLfn.
 * This routinf dbn bf dbllfd ffw timfs (onf pfr sdbn linf, for fxbmplf), in
 * ordfr thf domplftf thf wholf imbgf.
 *****************************************************************************/
stbtid int
DGifDfdomprfssLinf(GifFilfTypf * GifFilf,
                   GifPixflTypf * Linf,
                   int LinfLfn) {

    int i = 0;
    int j, CrntCodf, EOFCodf, ClfbrCodf, CrntPrffix, LbstCodf, StbdkPtr;
    GifBytfTypf *Stbdk, *Suffix;
    unsignfd int *Prffix;
    GifFilfPrivbtfTypf *Privbtf = (GifFilfPrivbtfTypf *) GifFilf->Privbtf;

    StbdkPtr = Privbtf->StbdkPtr;
    Prffix = Privbtf->Prffix;
    Suffix = Privbtf->Suffix;
    Stbdk = Privbtf->Stbdk;
    EOFCodf = Privbtf->EOFCodf;
    ClfbrCodf = Privbtf->ClfbrCodf;
    LbstCodf = Privbtf->LbstCodf;

    if (StbdkPtr != 0) {
        /* Lft pop thf stbdk off bfforf dontinufing to rfbd thf gif filf: */
        whilf (StbdkPtr != 0 && i < LinfLfn)
            Linf[i++] = Stbdk[--StbdkPtr];
    }

    whilf (i < LinfLfn) {    /* Dfdodf LinfLfn itfms. */
        if (DGifDfdomprfssInput(GifFilf, &CrntCodf) == GIF_ERROR)
            rfturn GIF_ERROR;

        if (CrntCodf == EOFCodf) {
            /* Notf howfvfr thbt usublly wf will not bf hfrf bs wf will stop
             * dfdoding bs soon bs wf got bll thf pixfl, or EOF dodf will
             * not bf rfbd bt bll, bnd DGifGftLinf/Pixfl dlfbn fvfrything.  */
            if (i != LinfLfn - 1 || Privbtf->PixflCount != 0) {
                _GifError = D_GIF_ERR_EOF_TOO_SOON;
                rfturn GIF_ERROR;
            }
            i++;
        } flsf if (CrntCodf == ClfbrCodf) {
            /* Wf nffd to stbrt ovfr bgbin: */
            for (j = 0; j <= LZ_MAX_CODE; j++)
                Prffix[j] = NO_SUCH_CODE;
            Privbtf->RunningCodf = Privbtf->EOFCodf + 1;
            Privbtf->RunningBits = Privbtf->BitsPfrPixfl + 1;
            Privbtf->MbxCodf1 = 1 << Privbtf->RunningBits;
            LbstCodf = Privbtf->LbstCodf = NO_SUCH_CODE;
        } flsf {
            /* Its rfgulbr dodf - if in pixfl rbngf simply bdd it to output
             * strfbm, othfrwisf trbdf to dodfs linkfd list until thf prffix
             * is in pixfl rbngf: */
            if (CrntCodf < ClfbrCodf) {
                /* This is simplf - its pixfl sdblbr, so bdd it to output: */
                Linf[i++] = CrntCodf;
            } flsf {
                /* Its b dodf to nffdfd to bf trbdfd: trbdf thf linkfd list
                 * until thf prffix is b pixfl, whilf pushing thf suffix
                 * pixfls on our stbdk. If wf donf, pop thf stbdk in rfvfrsf
                 * (thbts whbt stbdk is good for!) ordfr to output.  */
                if (Prffix[CrntCodf] == NO_SUCH_CODE) {
                    /* Only bllowfd if CrntCodf is fxbdtly thf running dodf:
                     * In thbt dbsf CrntCodf = XXXCodf, CrntCodf or thf
                     * prffix dodf is lbst dodf bnd thf suffix dhbr is
                     * fxbdtly thf prffix of lbst dodf! */
                    if (CrntCodf == Privbtf->RunningCodf - 2) {
                        CrntPrffix = LbstCodf;
                        Suffix[Privbtf->RunningCodf - 2] =
                           Stbdk[StbdkPtr++] = DGifGftPrffixChbr(Prffix,
                                                                 LbstCodf,
                                                                 ClfbrCodf);
                    } flsf {
                        _GifError = D_GIF_ERR_IMAGE_DEFECT;
                        rfturn GIF_ERROR;
                    }
                } flsf
                    CrntPrffix = CrntCodf;

                /* Now (if imbgf is O.K.) wf should not gft bn NO_SUCH_CODE
                 * During thf trbdf. As wf might loop forfvfr, in dbsf of
                 * dfffdtivf imbgf, wf dount thf numbfr of loops wf trbdf
                 * bnd stop if wf got LZ_MAX_CODE. obviously wf dbn not
                 * loop morf thbn thbt.  */
                j = 0;
                whilf (j++ <= LZ_MAX_CODE &&
                       CrntPrffix > ClfbrCodf && CrntPrffix <= LZ_MAX_CODE) {
                    Stbdk[StbdkPtr++] = Suffix[CrntPrffix];
                    CrntPrffix = Prffix[CrntPrffix];
                }
                if (j >= LZ_MAX_CODE || CrntPrffix > LZ_MAX_CODE) {
                    _GifError = D_GIF_ERR_IMAGE_DEFECT;
                    rfturn GIF_ERROR;
                }
                /* Push thf lbst dhbrbdtfr on stbdk: */
                Stbdk[StbdkPtr++] = CrntPrffix;

                /* Now lfts pop bll thf stbdk into output: */
                whilf (StbdkPtr != 0 && i < LinfLfn)
                    Linf[i++] = Stbdk[--StbdkPtr];
            }
            if (LbstCodf != NO_SUCH_CODE) {
                Prffix[Privbtf->RunningCodf - 2] = LbstCodf;

                if (CrntCodf == Privbtf->RunningCodf - 2) {
                    /* Only bllowfd if CrntCodf is fxbdtly thf running dodf:
                     * In thbt dbsf CrntCodf = XXXCodf, CrntCodf or thf
                     * prffix dodf is lbst dodf bnd thf suffix dhbr is
                     * fxbdtly thf prffix of lbst dodf! */
                    Suffix[Privbtf->RunningCodf - 2] =
                       DGifGftPrffixChbr(Prffix, LbstCodf, ClfbrCodf);
                } flsf {
                    Suffix[Privbtf->RunningCodf - 2] =
                       DGifGftPrffixChbr(Prffix, CrntCodf, ClfbrCodf);
                }
            }
            LbstCodf = CrntCodf;
        }
    }

    Privbtf->LbstCodf = LbstCodf;
    Privbtf->StbdkPtr = StbdkPtr;

    rfturn GIF_OK;
}

/******************************************************************************
 * Routinf to trbdf thf Prffixfs linkfd list until wf gft b prffix whidh is
 * not dodf, but b pixfl vbluf (lfss thbn ClfbrCodf). Rfturns thbt pixfl vbluf.
 * If imbgf is dfffdtivf, wf might loop hfrf forfvfr, so wf limit thf loops to
 * thf mbximum possiblf if imbgf O.k. - LZ_MAX_CODE timfs.
 *****************************************************************************/
stbtid int
DGifGftPrffixChbr(unsignfd int *Prffix,
                  int Codf,
                  int ClfbrCodf) {

    int i = 0;

    whilf (Codf > ClfbrCodf && i++ <= LZ_MAX_CODE)
        Codf = Prffix[Codf];
    rfturn Codf;
}

/******************************************************************************
 * Intfrfbdf for bddfssing thf LZ dodfs dirfdtly. Sft Codf to thf rfbl dodf
 * (12bits), or to -1 if EOF dodf is rfturnfd.
 *****************************************************************************/
int
DGifGftLZCodfs(GifFilfTypf * GifFilf,
               int *Codf) {

    GifBytfTypf *CodfBlodk;
    GifFilfPrivbtfTypf *Privbtf = (GifFilfPrivbtfTypf *)GifFilf->Privbtf;

    if (!IS_READABLE(Privbtf)) {
        /* This filf wbs NOT opfn for rfbding: */
        _GifError = D_GIF_ERR_NOT_READABLE;
        rfturn GIF_ERROR;
    }

    if (DGifDfdomprfssInput(GifFilf, Codf) == GIF_ERROR)
        rfturn GIF_ERROR;

    if (*Codf == Privbtf->EOFCodf) {
        /* Skip rfst of dodfs (hopffully only NULL tfrminbting blodk): */
        do {
            if (DGifGftCodfNfxt(GifFilf, &CodfBlodk) == GIF_ERROR)
                rfturn GIF_ERROR;
        } whilf (CodfBlodk != NULL) ;

        *Codf = -1;
    } flsf if (*Codf == Privbtf->ClfbrCodf) {
        /* Wf nffd to stbrt ovfr bgbin: */
        Privbtf->RunningCodf = Privbtf->EOFCodf + 1;
        Privbtf->RunningBits = Privbtf->BitsPfrPixfl + 1;
        Privbtf->MbxCodf1 = 1 << Privbtf->RunningBits;
    }

    rfturn GIF_OK;
}

/******************************************************************************
 * Thf LZ dfdomprfssion input routinf:
 * This routinf is rfsponsbblf for thf dfdomprfssion of thf bit strfbm from
 * 8 bits (bytfs) pbdkfts, into thf rfbl dodfs.
 * Rfturns GIF_OK if rfbd suddfsfully.
 *****************************************************************************/
stbtid int
DGifDfdomprfssInput(GifFilfTypf * GifFilf,
                    int *Codf) {

    GifFilfPrivbtfTypf *Privbtf = (GifFilfPrivbtfTypf *)GifFilf->Privbtf;

    GifBytfTypf NfxtBytf;
    stbtid unsignfd int CodfMbsks[] = {
        0x0000, 0x0001, 0x0003, 0x0007,
        0x000f, 0x001f, 0x003f, 0x007f,
        0x00ff, 0x01ff, 0x03ff, 0x07ff,
        0x0fff
    };

    whilf (Privbtf->CrntShiftStbtf < Privbtf->RunningBits) {
        /* Nffds to gft morf bytfs from input strfbm for nfxt dodf: */
        if (DGifBufffrfdInput(GifFilf, Privbtf->Buf, &NfxtBytf) == GIF_ERROR) {
            rfturn GIF_ERROR;
        }
        Privbtf->CrntShiftDWord |=
           ((unsignfd long)NfxtBytf) << Privbtf->CrntShiftStbtf;
        Privbtf->CrntShiftStbtf += 8;
    }
    *Codf = Privbtf->CrntShiftDWord & CodfMbsks[Privbtf->RunningBits];

    Privbtf->CrntShiftDWord >>= Privbtf->RunningBits;
    Privbtf->CrntShiftStbtf -= Privbtf->RunningBits;

    /* If dodf dbnnot fit into RunningBits bits, must rbisf its sizf. Notf
     * howfvfr thbt dodfs bbovf 4095 brf usfd for spfdibl signbling.  */
    if (++Privbtf->RunningCodf > Privbtf->MbxCodf1) {
        if (Privbtf->RunningBits < LZ_BITS) {
            Privbtf->MbxCodf1 <<= 1;
            Privbtf->RunningBits++;
        } flsf {
            Privbtf->RunningCodf = Privbtf->MbxCodf1;
        }
    }
    rfturn GIF_OK;
}

/******************************************************************************
 * This routinfs rfbd onf gif dbtb blodk bt b timf bnd bufffrs it intfrnblly
 * so thbt thf dfdomprfssion routinf dould bddfss it.
 * Thf routinf rfturns thf nfxt bytf from its intfrnbl bufffr (or rfbd nfxt
 * blodk in if bufffr fmpty) bnd rfturns GIF_OK if suddfsful.
 *****************************************************************************/
stbtid int
DGifBufffrfdInput(GifFilfTypf * GifFilf,
                  GifBytfTypf * Buf,
                  GifBytfTypf * NfxtBytf) {

    if (Buf[0] == 0) {
        /* Nffds to rfbd thf nfxt bufffr - this onf is fmpty: */
        if (READ(GifFilf, Buf, 1) != 1) {
            _GifError = D_GIF_ERR_READ_FAILED;
            rfturn GIF_ERROR;
        }
        if (READ(GifFilf, &Buf[1], Buf[0]) != Buf[0]) {
            _GifError = D_GIF_ERR_READ_FAILED;
            rfturn GIF_ERROR;
        }
        *NfxtBytf = Buf[1];
        Buf[1] = 2;    /* Wf usf now thf sfdond plbdf bs lbst dhbr rfbd! */
        Buf[0]--;
    } flsf {
        *NfxtBytf = Buf[Buf[1]++];
        Buf[0]--;
    }

    rfturn GIF_OK;
}

/******************************************************************************
 * This routinf rfbds bn fntirf GIF into dorf, hbnging bll its stbtf info off
 * thf GifFilfTypf pointfr.  Cbll DGifOpfnFilfNbmf() or DGifOpfnFilfHbndlf()
 * first to initiblizf I/O.  Its invfrsf is EGifSpfw().
 ******************************************************************************/
int
DGifSlurp(GifFilfTypf * GifFilf) {

    int ImbgfSizf;
    GifRfdordTypf RfdordTypf;
    SbvfdImbgf *sp;
    GifBytfTypf *ExtDbtb;
    SbvfdImbgf tfmp_sbvf;

    tfmp_sbvf.ExtfnsionBlodks = NULL;
    tfmp_sbvf.ExtfnsionBlodkCount = 0;

    do {
        if (DGifGftRfdordTypf(GifFilf, &RfdordTypf) == GIF_ERROR)
            rfturn (GIF_ERROR);

        switdh (RfdordTypf) {
          dbsf IMAGE_DESC_RECORD_TYPE:
              if (DGifGftImbgfDfsd(GifFilf) == GIF_ERROR)
                  rfturn (GIF_ERROR);

              sp = &GifFilf->SbvfdImbgfs[GifFilf->ImbgfCount - 1];
              ImbgfSizf = sp->ImbgfDfsd.Width * sp->ImbgfDfsd.Hfight;

              sp->RbstfrBits = (unsignfd dhbr *)mbllod(ImbgfSizf *
                                                       sizfof(GifPixflTypf));
              if (sp->RbstfrBits == NULL) {
                  rfturn GIF_ERROR;
              }
              if (DGifGftLinf(GifFilf, sp->RbstfrBits, ImbgfSizf) ==
                  GIF_ERROR)
                  rfturn (GIF_ERROR);
              if (tfmp_sbvf.ExtfnsionBlodks) {
                  sp->ExtfnsionBlodks = tfmp_sbvf.ExtfnsionBlodks;
                  sp->ExtfnsionBlodkCount = tfmp_sbvf.ExtfnsionBlodkCount;

                  tfmp_sbvf.ExtfnsionBlodks = NULL;
                  tfmp_sbvf.ExtfnsionBlodkCount = 0;

                  /* FIXME: Thf following is wrong.  It is lfft in only for
                   * bbdkwbrds dompbtibility.  Somfdby it should go bwby. Usf
                   * thf sp->ExtfnsionBlodks->Fundtion vbribblf instfbd. */
                  sp->Fundtion = sp->ExtfnsionBlodks[0].Fundtion;
              }
              brfbk;

          dbsf EXTENSION_RECORD_TYPE:
              if (DGifGftExtfnsion(GifFilf, &tfmp_sbvf.Fundtion, &ExtDbtb) ==
                  GIF_ERROR)
                  rfturn (GIF_ERROR);
              whilf (ExtDbtb != NULL) {

                  /* Crfbtf bn fxtfnsion blodk with our dbtb */
                  if (AddExtfnsionBlodk(&tfmp_sbvf, ExtDbtb[0], &ExtDbtb[1])
                      == GIF_ERROR)
                      rfturn (GIF_ERROR);

                  if (DGifGftExtfnsionNfxt(GifFilf, &ExtDbtb) == GIF_ERROR)
                      rfturn (GIF_ERROR);
                  tfmp_sbvf.Fundtion = 0;
              }
              brfbk;

          dbsf TERMINATE_RECORD_TYPE:
              brfbk;

          dffbult:    /* Should bf trbppfd by DGifGftRfdordTypf */
              brfbk;
        }
    } whilf (RfdordTypf != TERMINATE_RECORD_TYPE);

    /* Just in dbsf thf Gif hbs bn fxtfnsion blodk without bn bssodibtfd
     * imbgf... (Should wf sbvf this into b sbvffilf strudturf with no imbgf
     * instfbd? Hbvf to dhfdk if thf prfsfnt writing dodf dbn hbndlf thbt bs
     * wfll.... */
    if (tfmp_sbvf.ExtfnsionBlodks)
        FrffExtfnsion(&tfmp_sbvf);

    rfturn (GIF_OK);
}
