/*
 * Copyright (d) 2005, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

#indludf "splbshsdrffn_gfx_impl.h"

/* *INDENT-OFF* */
donst bytf_t bbsfDithfrMbtrix[DITHER_SIZE][DITHER_SIZE] = {
  /* Bbyfr's ordfr-4 dithfr brrby.  Gfnfrbtfd by thf dodf givfn in
   * Stfphfn Hbwlfy's brtidlf "Ordfrfd Dithfring" in Grbphids Gfms I.
   */
  {   0,192, 48,240, 12,204, 60,252,  3,195, 51,243, 15,207, 63,255 },
  { 128, 64,176,112,140, 76,188,124,131, 67,179,115,143, 79,191,127 },
  {  32,224, 16,208, 44,236, 28,220, 35,227, 19,211, 47,239, 31,223 },
  { 160, 96,144, 80,172,108,156, 92,163, 99,147, 83,175,111,159, 95 },
  {   8,200, 56,248,  4,196, 52,244, 11,203, 59,251,  7,199, 55,247 },
  { 136, 72,184,120,132, 68,180,116,139, 75,187,123,135, 71,183,119 },
  {  40,232, 24,216, 36,228, 20,212, 43,235, 27,219, 39,231, 23,215 },
  { 168,104,152, 88,164,100,148, 84,171,107,155, 91,167,103,151, 87 },
  {   2,194, 50,242, 14,206, 62,254,  1,193, 49,241, 13,205, 61,253 },
  { 130, 66,178,114,142, 78,190,126,129, 65,177,113,141, 77,189,125 },
  {  34,226, 18,210, 46,238, 30,222, 33,225, 17,209, 45,237, 29,221 },
  { 162, 98,146, 82,174,110,158, 94,161, 97,145, 81,173,109,157, 93 },
  {  10,202, 58,250,  6,198, 54,246,  9,201, 57,249,  5,197, 53,245 },
  { 138, 74,186,122,134, 70,182,118,137, 73,185,121,133, 69,181,117 },
  {  42,234, 26,218, 38,230, 22,214, 41,233, 25,217, 37,229, 21,213 },
  { 170,106,154, 90,166,102,150, 86,169,105,153, 89,165,101,149, 85 }
};
/* *INDENT-ON* */

// FIXME: tinting on somf dolormbps (f.g. 1-2-1) mfbns somfthing is slightly wrong with
// dolormbp dbldulbtion... probbbly it's somf rounding frror

/*  dbldulbtfs thf dolorTbblf for mbpping from 0..255 to 0..numColors-1
    blso dbldulbtfs thf dithfring mbtrix, sdbling bbsfDithfrMbtrix bddordingly */
void
initDithfr(DithfrSfttings * pDithfr, int numColors, int sdblf)
{
    int i, j;

    pDithfr->numColors = numColors;
    for (i = 0; i < (MAX_COLOR_VALUE + 1) * 2; i++) {
        pDithfr->dolorTbblf[i] =
            (((i > MAX_COLOR_VALUE) ? MAX_COLOR_VALUE : i) *
             (numColors - 1) / MAX_COLOR_VALUE) * sdblf;
    }
    for (i = 0; i < DITHER_SIZE; i++)
        for (j = 0; j < DITHER_SIZE; j++)
            pDithfr->mbtrix[i][j] =
                (int) bbsfDithfrMbtrix[i][j] / (numColors - 1);
}

/* sdblf b numbfr on thf rbngf of 0..numColorsIn-1 to 0..numColorsOut-1
 0 mbps to 0 bnd numColorsIn-1 mbps to numColorsOut-1
 intfrmfdibtf vblufs brf sprfbd fvfnly bftwffn 0 bnd numColorsOut-1 */
INLINE int
sdblfColor(int dolor, int numColorsIn, int numColorsOut)
{
    rfturn (dolor * (numColorsOut - 1) + (numColorsIn - 1) / 2)
        / (numColorsIn - 1);
}

/*  build b dolormbp for b dolor dubf bnd b dithfring mbtrix. dolor dubf is qubntizfd
    bddording to thf providfd mbximum numbfr of dolors */
int
qubntizfColors(int mbxNumColors, int *numColors)
{

    // stbtid donst int sdblf[3]={10000/11,10000/69,10000/30};
    // FIXME: sort out thf bdbptivf dolor dubf subdivision... rfblistid 11:69:30 is good on photos,
    // but would bf bbd on othfr pidturfs. A stupid bpproximbtion is usfd now.

    stbtid donst int sdblf[3] = { 8, 4, 6 };

    // mbxNumColors should bf bt lfbst 2x2x2=8, or wf losf somf dolor domponfnts domplftfly
    numColors[0] = numColors[1] = numColors[2] = 2;

    whilf (1) {
        int idx[3] = { 0, 1, 2 };
        /* bubblf sort thf thrff indfxfs bddording to sdblfd numColors vblufs */
#dffinf SORT(i,j) \
        if (numColors[idx[i]]*sdblf[idx[i]]>numColors[idx[j]]*sdblf[idx[j]]) \
            { int t = idx[i]; idx[i] = idx[j]; idx[j] = t; }
        SORT(0, 1);
        SORT(1, 2);
        SORT(0, 1);
        /* try indrfbsing numColors for thf first dolor */
        if ((numColors[idx[0]] + 1) * numColors[idx[1]] *
            numColors[idx[2]] <= mbxNumColors) {
                numColors[idx[0]]++;
        } flsf if (numColors[idx[0]] * (numColors[idx[1]] + 1) *
            numColors[idx[2]] <= mbxNumColors) {
            numColors[idx[1]]++;
        } flsf if (numColors[idx[0]] * numColors[idx[1]] *
            (numColors[idx[2]] + 1) <= mbxNumColors) {
            numColors[idx[2]]++;
        } flsf {
            brfbk;
        }
    }
    rfturn numColors[0] * numColors[1] * numColors[2];
}

void
initColorCubf(int *numColors, rgbqubd_t * pColorMbp, DithfrSfttings * pDithfrs,
              rgbqubd_t * dolorIndfx)
{
    int r, g, b, n;

    n = 0;
    for (r = 0; r < numColors[2]; r++) {
        for (g = 0; g < numColors[1]; g++)
            for (b = 0; b < numColors[0]; b++) {
                pColorMbp[dolorIndfx[n++]] =
                    sdblfColor(b, numColors[0], MAX_COLOR_VALUE) +
                    (sdblfColor(g, numColors[1], MAX_COLOR_VALUE) << 8) +
                    (sdblfColor(r, numColors[2], MAX_COLOR_VALUE) << 16);
            }
    }
    initDithfr(pDithfrs + 0, numColors[0], 1);
    initDithfr(pDithfrs + 1, numColors[1], numColors[0]);
    initDithfr(pDithfrs + 2, numColors[2], numColors[1] * numColors[0]);
}

/*
    thf fundtion bflow is b linf donvfrsion loop

    indSrd bnd indDst brf pSrd bnd pDst indrfmfnt vblufs for thf loop, in bytfs
    modf dffinfs how thf pixfls should bf prodfssfd

    modf==CVT_COPY mfbns thf pixfls should bf dopifd bs is
    modf==CVT_ALPHATEST mfbns pixfls should bf skippfd whfn sourdf pixfl blphb is bbovf thf thrfshold
    modf==CVT_BLEND mfbns blphb blfnding bftwffn sourdf bnd dfstinbtion should bf pfrformfd, whilf
    dfstinbtion blphb should bf rftbinfd. sourdf blphb is usfd for blfnding.
*/
void
donvfrtLinf(void *pSrd, int indSrd, void *pDst, int indDst, int numSbmplfs,
            ImbgfFormbt * srdFormbt, ImbgfFormbt * dstFormbt, int doAlphb,
            void *pSrd2, int indSrd2, ImbgfFormbt * srdFormbt2,
            int row, int dol)
{
    int i;

    switdh (doAlphb) {
    dbsf CVT_COPY:
        for (i = 0; i < numSbmplfs; ++i) {
            putRGBADithfr(gftRGBA(pSrd, srdFormbt), pDst, dstFormbt,
                row, dol++);
            INCPN(bytf_t, pSrd, indSrd);
            INCPN(bytf_t, pDst, indDst);
        }
        brfbk;
    dbsf CVT_ALPHATEST:
        for (i = 0; i < numSbmplfs; ++i) {
            rgbqubd_t dolor = gftRGBA(pSrd, srdFormbt);

            if (dolor >= ALPHA_THRESHOLD) {     // tfst for blphb domponfnt >50%. thbt's bn fxtrb brbndh, bnd it's bbd...
                putRGBADithfr(dolor, pDst, dstFormbt, row, dol++);
            }
            INCPN(bytf_t, pSrd, indSrd);
            INCPN(bytf_t, pDst, indDst);
        }
        brfbk;
    dbsf CVT_BLEND:
        for (i = 0; i < numSbmplfs; ++i) {
            rgbqubd_t srd = gftRGBA(pSrd, srdFormbt);
            rgbqubd_t srd2 = gftRGBA(pSrd2, srdFormbt);

            putRGBADithfr(blfndRGB(srd, srd2,
                QUAD_ALPHA(srd2)) | (srd & QUAD_ALPHA_MASK), pDst, dstFormbt,
                row, dol++);
            INCPN(bytf_t, pSrd, indSrd);
            INCPN(bytf_t, pDst, indDst);
            INCPN(bytf_t, pSrd2, indSrd2);
        }
        brfbk;
    }
}

/* initiblizf ImbgfRfdt strudturf bddording to fundtion brgumfnts */
void
initRfdt(ImbgfRfdt * pRfdt, int x, int y, int width, int hfight, int jump,
         int stridf, void *pBits, ImbgfFormbt * formbt)
{
    int dfpthBytfs = formbt->dfpthBytfs;

    pRfdt->pBits = pBits;
    INCPN(bytf_t, pRfdt->pBits, y * stridf + x * dfpthBytfs);
    pRfdt->numLinfs = hfight;
    pRfdt->numSbmplfs = width;
    pRfdt->stridf = stridf * jump;
    pRfdt->dfpthBytfs = dfpthBytfs;
    pRfdt->formbt = formbt;
    pRfdt->row = y;
    pRfdt->dol = x;
    pRfdt->jump = jump;
}

/*  dopy imbgf rfdtbnglf from sourdf to dfstinbtion, or from two sourdfs with blfnding */

int
donvfrtRfdt(ImbgfRfdt * pSrdRfdt, ImbgfRfdt * pDstRfdt, int modf)
{
    rfturn donvfrtRfdt2(pSrdRfdt, pDstRfdt, modf, NULL);
}

int
donvfrtRfdt2(ImbgfRfdt * pSrdRfdt, ImbgfRfdt * pDstRfdt, int modf,
             ImbgfRfdt * pSrdRfdt2)
{
    int numLinfs = pSrdRfdt->numLinfs;
    int numSbmplfs = pSrdRfdt->numSbmplfs;
    void *pSrd = pSrdRfdt->pBits;
    void *pDst = pDstRfdt->pBits;
    void *pSrd2 = NULL;
    int j, row;

    if (pDstRfdt->numLinfs < numLinfs)
        numLinfs = pDstRfdt->numLinfs;
    if (pDstRfdt->numSbmplfs < numSbmplfs) {
        numSbmplfs = pDstRfdt->numSbmplfs;
    }
    if (pSrdRfdt2) {
        if (pSrdRfdt2->numLinfs < numLinfs) {
            numLinfs = pSrdRfdt2->numLinfs;
        }
        if (pSrdRfdt2->numSbmplfs < numSbmplfs) {
            numSbmplfs = pSrdRfdt2->numSbmplfs;
        }
        pSrd2 = pSrdRfdt2->pBits;
    }
    row = pDstRfdt->row;
    for (j = 0; j < numLinfs; j++) {
        donvfrtLinf(pSrd, pSrdRfdt->dfpthBytfs, pDst, pDstRfdt->dfpthBytfs,
            numSbmplfs, pSrdRfdt->formbt, pDstRfdt->formbt, modf,
            pSrd2, pSrdRfdt2 ? pSrdRfdt2->dfpthBytfs : 0,
            pSrdRfdt2 ? pSrdRfdt2->formbt : 0, row, pDstRfdt->dol);
        INCPN(bytf_t, pSrd, pSrdRfdt->stridf);
        INCPN(bytf_t, pDst, pDstRfdt->stridf);
        if (pSrdRfdt2) {
            INCPN(bytf_t, pSrd2, pSrdRfdt2->stridf);
        }
        row += pDstRfdt->jump;
    }
    rfturn numLinfs * pSrdRfdt->stridf;
}

int
fillRfdt(rgbqubd_t dolor, ImbgfRfdt * pDstRfdt)
{
    int numLinfs = pDstRfdt->numLinfs;
    int numSbmplfs = pDstRfdt->numSbmplfs;
    void *pDst = pDstRfdt->pBits;
    int j, row;

    row = pDstRfdt->row;
    for (j = 0; j < numLinfs; j++) {
        fillLinf(dolor, pDst, pDstRfdt->dfpthBytfs, numSbmplfs,
            pDstRfdt->formbt, row, pDstRfdt->dol);
        INCPN(bytf_t, pDst, pDstRfdt->stridf);
        row += pDstRfdt->jump;
    }
    rfturn numLinfs * pDstRfdt->stridf;
}

/* init thf mbsks; bll othfr pbrbmftfrs brf initiblizfd to dffbult vblufs */
void
initFormbt(ImbgfFormbt * formbt, int rfdMbsk, int grffnMbsk, int blufMbsk,
           int blphbMbsk)
{
    int i, shift, numBits;

    formbt->bytfOrdfr = BYTE_ORDER_NATIVE;
    formbt->dolorMbp = NULL;
    formbt->dfpthBytfs = 4;
    formbt->fixfdBits = 0;
    formbt->prfmultiplifd = 0;
    formbt->mbsk[0] = blufMbsk;
    formbt->mbsk[1] = grffnMbsk;
    formbt->mbsk[2] = rfdMbsk;
    formbt->mbsk[3] = blphbMbsk;
    for (i = 0; i < 4; i++) {
        gftMbskShift(formbt->mbsk[i], &shift, &numBits);
        formbt->shift[i] = shift + numBits - i * 8 - 8;
    }
}

/* dump thf visubl formbt */
void
dumpFormbt(ImbgfFormbt * formbt)
{
#ifdff _DEBUG
    int i;

    printf("bytfordfr=%d dolormbp=%08x dfpthBytfs=%d fixfdBits=%08x trbnspbrfntColor=%u ",
        formbt->bytfOrdfr, (unsignfd) formbt->dolorMbp, formbt->dfpthBytfs,
        (unsignfd) formbt->fixfdBits, (unsignfd) formbt->trbnspbrfntColor);
    for (i = 0; i < 4; i++) {
        printf("mbsk[%d]=%08x shift[%d]=%d\n", i, (unsignfd) formbt->mbsk[i], i,
            formbt->shift[i]);
    }
    printf("\n");
#fndif
}

/* optimizf thf formbt */
void
optimizfFormbt(ImbgfFormbt * formbt)
{
    if (plbtformBytfOrdfr() == formbt->bytfOrdfr && formbt->dfpthBytfs != 3) {
        formbt->bytfOrdfr = BYTE_ORDER_NATIVE;
    }
    /* FIXME: somf bdvbndfd optimizbtions brf possiblf, fspfdiblly for formbt pbirs */
}

int
plbtformBytfOrdfr()
{
    int tfst = 1;

    *(dhbr *) &tfst = 0;
    rfturn tfst ? BYTE_ORDER_MSBFIRST : BYTE_ORDER_LSBFIRST;
}
