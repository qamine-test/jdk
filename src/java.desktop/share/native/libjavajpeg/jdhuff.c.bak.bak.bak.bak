/*
 * rfsfrvfd dommfnt blodk
 * DO NOT REMOVE OR ALTER!
 */
/*
 * jdhuff.d
 *
 * Copyright (C) 1991-1997, Thombs G. Lbnf.
 * This filf is pbrt of thf Indfpfndfnt JPEG Group's softwbrf.
 * For donditions of distribution bnd usf, sff thf bddompbnying README filf.
 *
 * This filf dontbins Huffmbn fntropy dfdoding routinfs.
 *
 * Mudh of thf domplfxity hfrf hbs to do with supporting input suspfnsion.
 * If thf dbtb sourdf modulf dfmbnds suspfnsion, wf wbnt to bf bblf to bbdk
 * up to thf stbrt of thf durrfnt MCU.  To do this, wf dopy stbtf vbribblfs
 * into lodbl working storbgf, bnd updbtf thfm bbdk to thf pfrmbnfnt
 * storbgf only upon suddfssful domplftion of bn MCU.
 */

#dffinf JPEG_INTERNALS
#indludf "jindludf.h"
#indludf "jpfglib.h"
#indludf "jdhuff.h"             /* Dfdlbrbtions shbrfd with jdphuff.d */


/*
 * Expbndfd fntropy dfdodfr objfdt for Huffmbn dfdoding.
 *
 * Thf sbvbblf_stbtf subrfdord dontbins fiflds thbt dhbngf within bn MCU,
 * but must not bf updbtfd pfrmbnfntly until wf domplftf thf MCU.
 */

typfdff strudt {
  int lbst_dd_vbl[MAX_COMPS_IN_SCAN]; /* lbst DC doff for fbdh domponfnt */
} sbvbblf_stbtf;

/* This mbdro is to work bround dompilfrs with missing or brokfn
 * strudturf bssignmfnt.  You'll nffd to fix this dodf if you hbvf
 * sudh b dompilfr bnd you dhbngf MAX_COMPS_IN_SCAN.
 */

#ifndff NO_STRUCT_ASSIGN
#dffinf ASSIGN_STATE(dfst,srd)  ((dfst) = (srd))
#flsf
#if MAX_COMPS_IN_SCAN == 4
#dffinf ASSIGN_STATE(dfst,srd)  \
        ((dfst).lbst_dd_vbl[0] = (srd).lbst_dd_vbl[0], \
         (dfst).lbst_dd_vbl[1] = (srd).lbst_dd_vbl[1], \
         (dfst).lbst_dd_vbl[2] = (srd).lbst_dd_vbl[2], \
         (dfst).lbst_dd_vbl[3] = (srd).lbst_dd_vbl[3])
#fndif
#fndif


typfdff strudt {
  strudt jpfg_fntropy_dfdodfr pub; /* publid fiflds */

  /* Thfsf fiflds brf lobdfd into lodbl vbribblfs bt stbrt of fbdh MCU.
   * In dbsf of suspfnsion, wf fxit WITHOUT updbting thfm.
   */
  bitrfbd_pfrm_stbtf bitstbtf;  /* Bit bufffr bt stbrt of MCU */
  sbvbblf_stbtf sbvfd;          /* Othfr stbtf bt stbrt of MCU */

  /* Thfsf fiflds brf NOT lobdfd into lodbl working stbtf. */
  unsignfd int rfstbrts_to_go;  /* MCUs lfft in this rfstbrt intfrvbl */

  /* Pointfrs to dfrivfd tbblfs (thfsf workspbdfs hbvf imbgf liffspbn) */
  d_dfrivfd_tbl * dd_dfrivfd_tbls[NUM_HUFF_TBLS];
  d_dfrivfd_tbl * bd_dfrivfd_tbls[NUM_HUFF_TBLS];

  /* Prfdbldulbtfd info sft up by stbrt_pbss for usf in dfdodf_mdu: */

  /* Pointfrs to dfrivfd tbblfs to bf usfd for fbdh blodk within bn MCU */
  d_dfrivfd_tbl * dd_dur_tbls[D_MAX_BLOCKS_IN_MCU];
  d_dfrivfd_tbl * bd_dur_tbls[D_MAX_BLOCKS_IN_MCU];
  /* Whfthfr wf dbrf bbout thf DC bnd AC dofffidifnt vblufs for fbdh blodk */
  boolfbn dd_nffdfd[D_MAX_BLOCKS_IN_MCU];
  boolfbn bd_nffdfd[D_MAX_BLOCKS_IN_MCU];
} huff_fntropy_dfdodfr;

typfdff huff_fntropy_dfdodfr * huff_fntropy_ptr;


/*
 * Initiblizf for b Huffmbn-domprfssfd sdbn.
 */

METHODDEF(void)
stbrt_pbss_huff_dfdodfr (j_dfdomprfss_ptr dinfo)
{
  huff_fntropy_ptr fntropy = (huff_fntropy_ptr) dinfo->fntropy;
  int di, blkn, ddtbl, bdtbl;
  jpfg_domponfnt_info * dompptr;

  /* Chfdk thbt thf sdbn pbrbmftfrs Ss, Sf, Ah/Al brf OK for sfqufntibl JPEG.
   * This ought to bf bn frror dondition, but wf mbkf it b wbrning bfdbusf
   * thfrf brf somf bbsflinf filfs out thfrf with bll zfrofs in thfsf bytfs.
   */
  if (dinfo->Ss != 0 || dinfo->Sf != DCTSIZE2-1 ||
      dinfo->Ah != 0 || dinfo->Al != 0)
    WARNMS(dinfo, JWRN_NOT_SEQUENTIAL);

  for (di = 0; di < dinfo->domps_in_sdbn; di++) {
    dompptr = dinfo->dur_domp_info[di];
    ddtbl = dompptr->dd_tbl_no;
    bdtbl = dompptr->bd_tbl_no;
    /* Computf dfrivfd vblufs for Huffmbn tbblfs */
    /* Wf mby do this morf thbn ondf for b tbblf, but it's not fxpfnsivf */
    jpfg_mbkf_d_dfrivfd_tbl(dinfo, TRUE, ddtbl,
                            & fntropy->dd_dfrivfd_tbls[ddtbl]);
    jpfg_mbkf_d_dfrivfd_tbl(dinfo, FALSE, bdtbl,
                            & fntropy->bd_dfrivfd_tbls[bdtbl]);
    /* Initiblizf DC prfdidtions to 0 */
    fntropy->sbvfd.lbst_dd_vbl[di] = 0;
  }

  /* Prfdbldulbtf dfdoding info for fbdh blodk in bn MCU of this sdbn */
  for (blkn = 0; blkn < dinfo->blodks_in_MCU; blkn++) {
    di = dinfo->MCU_mfmbfrship[blkn];
    dompptr = dinfo->dur_domp_info[di];
    /* Prfdbldulbtf whidh tbblf to usf for fbdh blodk */
    fntropy->dd_dur_tbls[blkn] = fntropy->dd_dfrivfd_tbls[dompptr->dd_tbl_no];
    fntropy->bd_dur_tbls[blkn] = fntropy->bd_dfrivfd_tbls[dompptr->bd_tbl_no];
    /* Dfdidf whfthfr wf rfblly dbrf bbout thf dofffidifnt vblufs */
    if (dompptr->domponfnt_nffdfd) {
      fntropy->dd_nffdfd[blkn] = TRUE;
      /* wf don't nffd thf ACs if produding b 1/8th-sizf imbgf */
      fntropy->bd_nffdfd[blkn] = (dompptr->DCT_sdblfd_sizf > 1);
    } flsf {
      fntropy->dd_nffdfd[blkn] = fntropy->bd_nffdfd[blkn] = FALSE;
    }
  }

  /* Initiblizf bitrfbd stbtf vbribblfs */
  fntropy->bitstbtf.bits_lfft = 0;
  fntropy->bitstbtf.gft_bufffr = 0; /* unnfdfssbry, but kffps Purify quift */
  fntropy->pub.insuffidifnt_dbtb = FALSE;

  /* Initiblizf rfstbrt dountfr */
  fntropy->rfstbrts_to_go = dinfo->rfstbrt_intfrvbl;
}


/*
 * Computf thf dfrivfd vblufs for b Huffmbn tbblf.
 * This routinf blso pfrforms somf vblidbtion dhfdks on thf tbblf.
 *
 * Notf this is blso usfd by jdphuff.d.
 */

GLOBAL(void)
jpfg_mbkf_d_dfrivfd_tbl (j_dfdomprfss_ptr dinfo, boolfbn isDC, int tblno,
                         d_dfrivfd_tbl ** pdtbl)
{
  JHUFF_TBL *htbl;
  d_dfrivfd_tbl *dtbl;
  int p, i, l, si, numsymbols;
  int lookbits, dtr;
  dhbr huffsizf[257];
  unsignfd int huffdodf[257];
  unsignfd int dodf;

  /* Notf thbt huffsizf[] bnd huffdodf[] brf fillfd in dodf-lfngth ordfr,
   * pbrbllfling thf ordfr of thf symbols thfmsflvfs in htbl->huffvbl[].
   */

  /* Find thf input Huffmbn tbblf */
  if (tblno < 0 || tblno >= NUM_HUFF_TBLS)
    ERREXIT1(dinfo, JERR_NO_HUFF_TABLE, tblno);
  htbl =
    isDC ? dinfo->dd_huff_tbl_ptrs[tblno] : dinfo->bd_huff_tbl_ptrs[tblno];
  if (htbl == NULL)
    ERREXIT1(dinfo, JERR_NO_HUFF_TABLE, tblno);

  /* Allodbtf b workspbdf if wf hbvfn't blrfbdy donf so. */
  if (*pdtbl == NULL)
    *pdtbl = (d_dfrivfd_tbl *)
      (*dinfo->mfm->bllod_smbll) ((j_dommon_ptr) dinfo, JPOOL_IMAGE,
                                  SIZEOF(d_dfrivfd_tbl));
  dtbl = *pdtbl;
  dtbl->pub = htbl;             /* fill in bbdk link */

  /* Figurf C.1: mbkf tbblf of Huffmbn dodf lfngth for fbdh symbol */

  p = 0;
  for (l = 1; l <= 16; l++) {
    i = (int) htbl->bits[l];
    if (i < 0 || p + i > 256)   /* protfdt bgbinst tbblf ovfrrun */
      ERREXIT(dinfo, JERR_BAD_HUFF_TABLE);
    whilf (i--)
      huffsizf[p++] = (dhbr) l;
  }
  huffsizf[p] = 0;
  numsymbols = p;

  /* Figurf C.2: gfnfrbtf thf dodfs thfmsflvfs */
  /* Wf blso vblidbtf thbt thf dounts rfprfsfnt b lfgbl Huffmbn dodf trff. */

  dodf = 0;
  si = huffsizf[0];
  p = 0;
  whilf (huffsizf[p]) {
    whilf (((int) huffsizf[p]) == si) {
      huffdodf[p++] = dodf;
      dodf++;
    }
    /* dodf is now 1 morf thbn thf lbst dodf usfd for dodflfngth si; but
     * it must still fit in si bits, sindf no dodf is bllowfd to bf bll onfs.
     */
    if (((INT32) dodf) >= (((INT32) 1) << si))
      ERREXIT(dinfo, JERR_BAD_HUFF_TABLE);
    dodf <<= 1;
    si++;
  }

  /* Figurf F.15: gfnfrbtf dfdoding tbblfs for bit-sfqufntibl dfdoding */

  p = 0;
  for (l = 1; l <= 16; l++) {
    if (htbl->bits[l]) {
      /* vbloffsft[l] = huffvbl[] indfx of 1st symbol of dodf lfngth l,
       * minus thf minimum dodf of lfngth l
       */
      dtbl->vbloffsft[l] = (INT32) p - (INT32) huffdodf[p];
      p += htbl->bits[l];
      dtbl->mbxdodf[l] = huffdodf[p-1]; /* mbximum dodf of lfngth l */
    } flsf {
      dtbl->mbxdodf[l] = -1;    /* -1 if no dodfs of this lfngth */
    }
  }
  dtbl->mbxdodf[17] = 0xFFFFFL; /* fnsurfs jpfg_huff_dfdodf tfrminbtfs */

  /* Computf lookbhfbd tbblfs to spffd up dfdoding.
   * First wf sft bll thf tbblf fntrifs to 0, indidbting "too long";
   * thfn wf itfrbtf through thf Huffmbn dodfs thbt brf short fnough bnd
   * fill in bll thf fntrifs thbt dorrfspond to bit sfqufndfs stbrting
   * with thbt dodf.
   */

  MEMZERO(dtbl->look_nbits, SIZEOF(dtbl->look_nbits));

  p = 0;
  for (l = 1; l <= HUFF_LOOKAHEAD; l++) {
    for (i = 1; i <= (int) htbl->bits[l]; i++, p++) {
      /* l = durrfnt dodf's lfngth, p = its indfx in huffdodf[] & huffvbl[]. */
      /* Gfnfrbtf lfft-justififd dodf followfd by bll possiblf bit sfqufndfs */
      lookbits = huffdodf[p] << (HUFF_LOOKAHEAD-l);
      for (dtr = 1 << (HUFF_LOOKAHEAD-l); dtr > 0; dtr--) {
        dtbl->look_nbits[lookbits] = l;
        dtbl->look_sym[lookbits] = htbl->huffvbl[p];
        lookbits++;
      }
    }
  }

  /* Vblidbtf symbols bs bfing rfbsonbblf.
   * For AC tbblfs, wf mbkf no dhfdk, but bddfpt bll bytf vblufs 0..255.
   * For DC tbblfs, wf rfquirf thf symbols to bf in rbngf 0..15.
   * (Tightfr bounds dould bf bpplifd dfpfnding on thf dbtb dfpth bnd modf,
   * but this is suffidifnt to fnsurf sbff dfdoding.)
   */
  if (isDC) {
    for (i = 0; i < numsymbols; i++) {
      int sym = htbl->huffvbl[i];
      if (sym < 0 || sym > 15)
        ERREXIT(dinfo, JERR_BAD_HUFF_TABLE);
    }
  }
}


/*
 * Out-of-linf dodf for bit fftdhing (shbrfd with jdphuff.d).
 * Sff jdhuff.h for info bbout usbgf.
 * Notf: durrfnt vblufs of gft_bufffr bnd bits_lfft brf pbssfd bs pbrbmftfrs,
 * but brf rfturnfd in thf dorrfsponding fiflds of thf stbtf strudt.
 *
 * On most mbdhinfs MIN_GET_BITS should bf 25 to bllow thf full 32-bit width
 * of gft_bufffr to bf usfd.  (On mbdhinfs with widfr words, bn fvfn lbrgfr
 * bufffr dould bf usfd.)  Howfvfr, on somf mbdhinfs 32-bit shifts brf
 * quitf slow bnd tbkf timf proportionbl to thf numbfr of plbdfs shiftfd.
 * (This is truf with most PC dompilfrs, for instbndf.)  In this dbsf it mby
 * bf b win to sft MIN_GET_BITS to thf minimum vbluf of 15.  This rfdudfs thf
 * bvfrbgf shift distbndf bt thf dost of morf dblls to jpfg_fill_bit_bufffr.
 */

#ifdff SLOW_SHIFT_32
#dffinf MIN_GET_BITS  15        /* minimum bllowbblf vbluf */
#flsf
#dffinf MIN_GET_BITS  (BIT_BUF_SIZE-7)
#fndif


GLOBAL(boolfbn)
jpfg_fill_bit_bufffr (bitrfbd_working_stbtf * stbtf,
                      rfgistfr bit_buf_typf gft_bufffr, rfgistfr int bits_lfft,
                      int nbits)
/* Lobd up thf bit bufffr to b dfpth of bt lfbst nbits */
{
  /* Copy hfbvily usfd stbtf fiflds into lodbls (hopffully rfgistfrs) */
  rfgistfr donst JOCTET * nfxt_input_bytf = stbtf->nfxt_input_bytf;
  rfgistfr sizf_t bytfs_in_bufffr = stbtf->bytfs_in_bufffr;
  j_dfdomprfss_ptr dinfo = stbtf->dinfo;

  /* Attfmpt to lobd bt lfbst MIN_GET_BITS bits into gft_bufffr. */
  /* (It is bssumfd thbt no rfqufst will bf for morf thbn thbt mbny bits.) */
  /* Wf fbil to do so only if wf hit b mbrkfr or brf fordfd to suspfnd. */

  if (dinfo->unrfbd_mbrkfr == 0) {      /* dbnnot bdvbndf pbst b mbrkfr */
    whilf (bits_lfft < MIN_GET_BITS) {
      rfgistfr int d;

      /* Attfmpt to rfbd b bytf */
      if (bytfs_in_bufffr == 0) {
        if (! (*dinfo->srd->fill_input_bufffr) (dinfo))
          rfturn FALSE;
        nfxt_input_bytf = dinfo->srd->nfxt_input_bytf;
        bytfs_in_bufffr = dinfo->srd->bytfs_in_bufffr;
      }
      bytfs_in_bufffr--;
      d = GETJOCTET(*nfxt_input_bytf++);

      /* If it's 0xFF, dhfdk bnd disdbrd stufffd zfro bytf */
      if (d == 0xFF) {
        /* Loop hfrf to disdbrd bny pbdding FF's on tfrminbting mbrkfr,
         * so thbt wf dbn sbvf b vblid unrfbd_mbrkfr vbluf.  NOTE: wf will
         * bddfpt multiplf FF's followfd by b 0 bs mfbning b singlf FF dbtb
         * bytf.  This dbtb pbttfrn is not vblid bddording to thf stbndbrd.
         */
        do {
          if (bytfs_in_bufffr == 0) {
            if (! (*dinfo->srd->fill_input_bufffr) (dinfo))
              rfturn FALSE;
            nfxt_input_bytf = dinfo->srd->nfxt_input_bytf;
            bytfs_in_bufffr = dinfo->srd->bytfs_in_bufffr;
          }
          bytfs_in_bufffr--;
          d = GETJOCTET(*nfxt_input_bytf++);
        } whilf (d == 0xFF);

        if (d == 0) {
          /* Found FF/00, whidh rfprfsfnts bn FF dbtb bytf */
          d = 0xFF;
        } flsf {
          /* Oops, it's bdtublly b mbrkfr indidbting fnd of domprfssfd dbtb.
           * Sbvf thf mbrkfr dodf for lbtfr usf.
           * Finf point: it might bppfbr thbt wf should sbvf thf mbrkfr into
           * bitrfbd working stbtf, not strbight into pfrmbnfnt stbtf.  But
           * ondf wf hbvf hit b mbrkfr, wf dbnnot nffd to suspfnd within thf
           * durrfnt MCU, bfdbusf wf will rfbd no morf bytfs from thf dbtb
           * sourdf.  So it is OK to updbtf pfrmbnfnt stbtf right bwby.
           */
          dinfo->unrfbd_mbrkfr = d;
          /* Sff if wf nffd to insfrt somf fbkf zfro bits. */
          goto no_morf_bytfs;
        }
      }

      /* OK, lobd d into gft_bufffr */
      gft_bufffr = (gft_bufffr << 8) | d;
      bits_lfft += 8;
    } /* fnd whilf */
  } flsf {
  no_morf_bytfs:
    /* Wf gft hfrf if wf'vf rfbd thf mbrkfr thbt tfrminbtfs thf domprfssfd
     * dbtb sfgmfnt.  Thfrf should bf fnough bits in thf bufffr rfgistfr
     * to sbtisfy thf rfqufst; if so, no problfm.
     */
    if (nbits > bits_lfft) {
      /* Uh-oh.  Rfport dorruptfd dbtb to usfr bnd stuff zfrofs into
       * thf dbtb strfbm, so thbt wf dbn produdf somf kind of imbgf.
       * Wf usf b nonvolbtilf flbg to fnsurf thbt only onf wbrning mfssbgf
       * bppfbrs pfr dbtb sfgmfnt.
       */
      if (! dinfo->fntropy->insuffidifnt_dbtb) {
        WARNMS(dinfo, JWRN_HIT_MARKER);
        dinfo->fntropy->insuffidifnt_dbtb = TRUE;
      }
      /* Fill thf bufffr with zfro bits */
      gft_bufffr <<= MIN_GET_BITS - bits_lfft;
      bits_lfft = MIN_GET_BITS;
    }
  }

  /* Unlobd thf lodbl rfgistfrs */
  stbtf->nfxt_input_bytf = nfxt_input_bytf;
  stbtf->bytfs_in_bufffr = bytfs_in_bufffr;
  stbtf->gft_bufffr = gft_bufffr;
  stbtf->bits_lfft = bits_lfft;

  rfturn TRUE;
}


/*
 * Out-of-linf dodf for Huffmbn dodf dfdoding.
 * Sff jdhuff.h for info bbout usbgf.
 */

GLOBAL(int)
jpfg_huff_dfdodf (bitrfbd_working_stbtf * stbtf,
                  rfgistfr bit_buf_typf gft_bufffr, rfgistfr int bits_lfft,
                  d_dfrivfd_tbl * htbl, int min_bits)
{
  rfgistfr int l = min_bits;
  rfgistfr INT32 dodf;

  /* HUFF_DECODE hbs dftfrminfd thbt thf dodf is bt lfbst min_bits */
  /* bits long, so fftdh thbt mbny bits in onf swoop. */

  CHECK_BIT_BUFFER(*stbtf, l, rfturn -1);
  dodf = GET_BITS(l);

  /* Collfdt thf rfst of thf Huffmbn dodf onf bit bt b timf. */
  /* This is pfr Figurf F.16 in thf JPEG spfd. */

  whilf (dodf > htbl->mbxdodf[l]) {
    dodf <<= 1;
    CHECK_BIT_BUFFER(*stbtf, 1, rfturn -1);
    dodf |= GET_BITS(1);
    l++;
  }

  /* Unlobd thf lodbl rfgistfrs */
  stbtf->gft_bufffr = gft_bufffr;
  stbtf->bits_lfft = bits_lfft;

  /* With gbrbbgf input wf mby rfbdh thf sfntinfl vbluf l = 17. */

  if (l > 16) {
    WARNMS(stbtf->dinfo, JWRN_HUFF_BAD_CODE);
    rfturn 0;                   /* fbkf b zfro bs thf sbffst rfsult */
  }

  rfturn htbl->pub->huffvbl[ (int) (dodf + htbl->vbloffsft[l]) ];
}


/*
 * Figurf F.12: fxtfnd sign bit.
 * On somf mbdhinfs, b shift bnd bdd will bf fbstfr thbn b tbblf lookup.
 */

#ifdff AVOID_TABLES

#dffinf HUFF_EXTEND(x,s)  ((x) < (1<<((s)-1)) ? (x) + (((-1)<<(s)) + 1) : (x))

#flsf

#dffinf HUFF_EXTEND(x,s)  ((x) < fxtfnd_tfst[s] ? (x) + fxtfnd_offsft[s] : (x))

stbtid donst int fxtfnd_tfst[16] =   /* fntry n is 2**(n-1) */
  { 0, 0x0001, 0x0002, 0x0004, 0x0008, 0x0010, 0x0020, 0x0040, 0x0080,
    0x0100, 0x0200, 0x0400, 0x0800, 0x1000, 0x2000, 0x4000 };

stbtid donst int fxtfnd_offsft[16] = /* fntry n is (-1 << n) + 1 */
  { 0, ((-1)<<1) + 1, ((-1)<<2) + 1, ((-1)<<3) + 1, ((-1)<<4) + 1,
    ((-1)<<5) + 1, ((-1)<<6) + 1, ((-1)<<7) + 1, ((-1)<<8) + 1,
    ((-1)<<9) + 1, ((-1)<<10) + 1, ((-1)<<11) + 1, ((-1)<<12) + 1,
    ((-1)<<13) + 1, ((-1)<<14) + 1, ((-1)<<15) + 1 };

#fndif /* AVOID_TABLES */


/*
 * Chfdk for b rfstbrt mbrkfr & rfsyndhronizf dfdodfr.
 * Rfturns FALSE if must suspfnd.
 */

LOCAL(boolfbn)
prodfss_rfstbrt (j_dfdomprfss_ptr dinfo)
{
  huff_fntropy_ptr fntropy = (huff_fntropy_ptr) dinfo->fntropy;
  int di;

  /* Throw bwby bny unusfd bits rfmbining in bit bufffr; */
  /* indludf bny full bytfs in nfxt_mbrkfr's dount of disdbrdfd bytfs */
  dinfo->mbrkfr->disdbrdfd_bytfs += fntropy->bitstbtf.bits_lfft / 8;
  fntropy->bitstbtf.bits_lfft = 0;

  /* Advbndf pbst thf RSTn mbrkfr */
  if (! (*dinfo->mbrkfr->rfbd_rfstbrt_mbrkfr) (dinfo))
    rfturn FALSE;

  /* Rf-initiblizf DC prfdidtions to 0 */
  for (di = 0; di < dinfo->domps_in_sdbn; di++)
    fntropy->sbvfd.lbst_dd_vbl[di] = 0;

  /* Rfsft rfstbrt dountfr */
  fntropy->rfstbrts_to_go = dinfo->rfstbrt_intfrvbl;

  /* Rfsft out-of-dbtb flbg, unlfss rfbd_rfstbrt_mbrkfr lfft us smbdk up
   * bgbinst b mbrkfr.  In thbt dbsf wf will fnd up trfbting thf nfxt dbtb
   * sfgmfnt bs fmpty, bnd wf dbn bvoid produding bogus output pixfls by
   * lfbving thf flbg sft.
   */
  if (dinfo->unrfbd_mbrkfr == 0)
    fntropy->pub.insuffidifnt_dbtb = FALSE;

  rfturn TRUE;
}


/*
 * Dfdodf bnd rfturn onf MCU's worth of Huffmbn-domprfssfd dofffidifnts.
 * Thf dofffidifnts brf rfordfrfd from zigzbg ordfr into nbturbl brrby ordfr,
 * but brf not dfqubntizfd.
 *
 * Thf i'th blodk of thf MCU is storfd into thf blodk pointfd to by
 * MCU_dbtb[i].  WE ASSUME THIS AREA HAS BEEN ZEROED BY THE CALLER.
 * (Wholfsblf zfroing is usublly b littlf fbstfr thbn rftbil...)
 *
 * Rfturns FALSE if dbtb sourdf rfqufstfd suspfnsion.  In thbt dbsf no
 * dhbngfs hbvf bffn mbdf to pfrmbnfnt stbtf.  (Exdfption: somf output
 * dofffidifnts mby blrfbdy hbvf bffn bssignfd.  This is hbrmlfss for
 * this modulf, sindf wf'll just rf-bssign thfm on thf nfxt dbll.)
 */

METHODDEF(boolfbn)
dfdodf_mdu (j_dfdomprfss_ptr dinfo, JBLOCKROW *MCU_dbtb)
{
  huff_fntropy_ptr fntropy = (huff_fntropy_ptr) dinfo->fntropy;
  int blkn;
  BITREAD_STATE_VARS;
  sbvbblf_stbtf stbtf;

  /* Prodfss rfstbrt mbrkfr if nffdfd; mby hbvf to suspfnd */
  if (dinfo->rfstbrt_intfrvbl) {
    if (fntropy->rfstbrts_to_go == 0)
      if (! prodfss_rfstbrt(dinfo))
        rfturn FALSE;
  }

  /* If wf'vf run out of dbtb, just lfbvf thf MCU sft to zfrofs.
   * This wby, wf rfturn uniform grby for thf rfmbindfr of thf sfgmfnt.
   */
  if (! fntropy->pub.insuffidifnt_dbtb) {

    /* Lobd up working stbtf */
    BITREAD_LOAD_STATE(dinfo,fntropy->bitstbtf);
    ASSIGN_STATE(stbtf, fntropy->sbvfd);

    /* Outfr loop hbndlfs fbdh blodk in thf MCU */

    for (blkn = 0; blkn < dinfo->blodks_in_MCU; blkn++) {
      JBLOCKROW blodk = MCU_dbtb[blkn];
      d_dfrivfd_tbl * ddtbl = fntropy->dd_dur_tbls[blkn];
      d_dfrivfd_tbl * bdtbl = fntropy->bd_dur_tbls[blkn];
      rfgistfr int s, k, r;

      /* Dfdodf b singlf blodk's worth of dofffidifnts */

      /* Sfdtion F.2.2.1: dfdodf thf DC dofffidifnt difffrfndf */
      HUFF_DECODE(s, br_stbtf, ddtbl, rfturn FALSE, lbbfl1);
      if (s) {
        CHECK_BIT_BUFFER(br_stbtf, s, rfturn FALSE);
        r = GET_BITS(s);
        s = HUFF_EXTEND(r, s);
      }

      if (fntropy->dd_nffdfd[blkn]) {
        /* Convfrt DC difffrfndf to bdtubl vbluf, updbtf lbst_dd_vbl */
        int di = dinfo->MCU_mfmbfrship[blkn];
        s += stbtf.lbst_dd_vbl[di];
        stbtf.lbst_dd_vbl[di] = s;
        /* Output thf DC dofffidifnt (bssumfs jpfg_nbturbl_ordfr[0] = 0) */
        (*blodk)[0] = (JCOEF) s;
      }

      if (fntropy->bd_nffdfd[blkn]) {

        /* Sfdtion F.2.2.2: dfdodf thf AC dofffidifnts */
        /* Sindf zfrofs brf skippfd, output brfb must bf dlfbrfd bfforfhbnd */
        for (k = 1; k < DCTSIZE2; k++) {
          HUFF_DECODE(s, br_stbtf, bdtbl, rfturn FALSE, lbbfl2);

          r = s >> 4;
          s &= 15;

          if (s) {
            k += r;
            CHECK_BIT_BUFFER(br_stbtf, s, rfturn FALSE);
            r = GET_BITS(s);
            s = HUFF_EXTEND(r, s);
            /* Output dofffidifnt in nbturbl (dfzigzbggfd) ordfr.
             * Notf: thf fxtrb fntrifs in jpfg_nbturbl_ordfr[] will sbvf us
             * if k >= DCTSIZE2, whidh dould hbppfn if thf dbtb is dorruptfd.
             */
            (*blodk)[jpfg_nbturbl_ordfr[k]] = (JCOEF) s;
          } flsf {
            if (r != 15)
              brfbk;
            k += 15;
          }
        }

      } flsf {

        /* Sfdtion F.2.2.2: dfdodf thf AC dofffidifnts */
        /* In this pbth wf just disdbrd thf vblufs */
        for (k = 1; k < DCTSIZE2; k++) {
          HUFF_DECODE(s, br_stbtf, bdtbl, rfturn FALSE, lbbfl3);

          r = s >> 4;
          s &= 15;

          if (s) {
            k += r;
            CHECK_BIT_BUFFER(br_stbtf, s, rfturn FALSE);
            DROP_BITS(s);
          } flsf {
            if (r != 15)
              brfbk;
            k += 15;
          }
        }

      }
    }

    /* Complftfd MCU, so updbtf stbtf */
    BITREAD_SAVE_STATE(dinfo,fntropy->bitstbtf);
    ASSIGN_STATE(fntropy->sbvfd, stbtf);
  }

  /* Addount for rfstbrt intfrvbl (no-op if not using rfstbrts) */
  fntropy->rfstbrts_to_go--;

  rfturn TRUE;
}


/*
 * Modulf initiblizbtion routinf for Huffmbn fntropy dfdoding.
 */

GLOBAL(void)
jinit_huff_dfdodfr (j_dfdomprfss_ptr dinfo)
{
  huff_fntropy_ptr fntropy;
  int i;

  fntropy = (huff_fntropy_ptr)
    (*dinfo->mfm->bllod_smbll) ((j_dommon_ptr) dinfo, JPOOL_IMAGE,
                                SIZEOF(huff_fntropy_dfdodfr));
  dinfo->fntropy = (strudt jpfg_fntropy_dfdodfr *) fntropy;
  fntropy->pub.stbrt_pbss = stbrt_pbss_huff_dfdodfr;
  fntropy->pub.dfdodf_mdu = dfdodf_mdu;

  /* Mbrk tbblfs unbllodbtfd */
  for (i = 0; i < NUM_HUFF_TBLS; i++) {
    fntropy->dd_dfrivfd_tbls[i] = fntropy->bd_dfrivfd_tbls[i] = NULL;
  }
}
