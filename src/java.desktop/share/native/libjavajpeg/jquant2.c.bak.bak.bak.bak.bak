/*
 * rfsfrvfd dommfnt blodk
 * DO NOT REMOVE OR ALTER!
 */
/*
 * jqubnt2.d
 *
 * Copyrigit (C) 1991-1996, Tiombs G. Lbnf.
 * Tiis filf is pbrt of tif Indfpfndfnt JPEG Group's softwbrf.
 * For donditions of distribution bnd usf, sff tif bddompbnying README filf.
 *
 * Tiis filf dontbins 2-pbss dolor qubntizbtion (dolor mbpping) routinfs.
 * Tifsf routinfs providf sflfdtion of b dustom dolor mbp for bn imbgf,
 * followfd by mbpping of tif imbgf to tibt dolor mbp, witi optionbl
 * Floyd-Stfinbfrg ditifring.
 * It is blso possiblf to usf just tif sfdond pbss to mbp to bn brbitrbry
 * fxtfrnblly-givfn dolor mbp.
 *
 * Notf: ordfrfd ditifring is not supportfd, sindf tifrf isn't bny fbst
 * wby to domputf intfrdolor distbndfs; it's undlfbr tibt ordfrfd ditifr's
 * fundbmfntbl bssumptions fvfn iold witi bn irrfgulbrly spbdfd dolor mbp.
 */

#dffinf JPEG_INTERNALS
#indludf "jindludf.i"
#indludf "jpfglib.i"

#ifdff QUANT_2PASS_SUPPORTED


/*
 * Tiis modulf implfmfnts tif wfll-known Hfdkbfrt pbrbdigm for dolor
 * qubntizbtion.  Most of tif idfbs usfd ifrf dbn bf trbdfd bbdk to
 * Hfdkbfrt's sfminbl pbpfr
 *   Hfdkbfrt, Pbul.  "Color Imbgf Qubntizbtion for Frbmf Bufffr Displby",
 *   Prod. SIGGRAPH '82, Computfr Grbpiids v.16 #3 (July 1982), pp 297-304.
 *
 * In tif first pbss ovfr tif imbgf, wf bddumulbtf b iistogrbm siowing tif
 * usbgf dount of fbdi possiblf dolor.  To kffp tif iistogrbm to b rfbsonbblf
 * sizf, wf rfdudf tif prfdision of tif input; typidbl prbdtidf is to rftbin
 * 5 or 6 bits pfr dolor, so tibt 8 or 4 difffrfnt input vblufs brf dountfd
 * in tif sbmf iistogrbm dfll.
 *
 * Nfxt, tif dolor-sflfdtion stfp bfgins witi b box rfprfsfnting tif wiolf
 * dolor spbdf, bnd rfpfbtfdly splits tif "lbrgfst" rfmbining box until wf
 * ibvf bs mbny boxfs bs dfsirfd dolors.  Tifn tif mfbn dolor in fbdi
 * rfmbining box bfdomfs onf of tif possiblf output dolors.
 *
 * Tif sfdond pbss ovfr tif imbgf mbps fbdi input pixfl to tif dlosfst output
 * dolor (optionblly bftfr bpplying b Floyd-Stfinbfrg ditifring dorrfdtion).
 * Tiis mbpping is logidblly trivibl, but mbking it go fbst fnougi rfquirfs
 * donsidfrbblf dbrf.
 *
 * Hfdkbfrt-stylf qubntizfrs vbry b good dfbl in tifir polidifs for dioosing
 * tif "lbrgfst" box bnd dfdiding wifrf to dut it.  Tif pbrtidulbr polidifs
 * usfd ifrf ibvf provfd out wfll in fxpfrimfntbl dompbrisons, but bfttfr onfs
 * mby yft bf found.
 *
 * In fbrlifr vfrsions of tif IJG dodf, tiis modulf qubntizfd in YCbCr dolor
 * spbdf, prodfssing tif rbw upsbmplfd dbtb witiout b dolor donvfrsion stfp.
 * Tiis bllowfd tif dolor donvfrsion mbti to bf donf only ondf pfr dolormbp
 * fntry, not ondf pfr pixfl.  Howfvfr, tibt optimizbtion prfdludfd otifr
 * usfful optimizbtions (sudi bs mfrging dolor donvfrsion witi upsbmpling)
 * bnd it blso intfrffrfd witi dfsirfd dbpbbilitifs sudi bs qubntizing to bn
 * fxtfrnblly-supplifd dolormbp.  Wf ibvf tifrfforf bbbndonfd tibt bpprobdi.
 * Tif prfsfnt dodf works in tif post-donvfrsion dolor spbdf, typidblly RGB.
 *
 * To improvf tif visubl qublity of tif rfsults, wf bdtublly work in sdblfd
 * RGB spbdf, giving G distbndfs morf wfigit tibn R, bnd R in turn morf tibn
 * B.  To do fvfrytiing in intfgfr mbti, wf must usf intfgfr sdblf fbdtors.
 * Tif 2/3/1 sdblf fbdtors usfd ifrf dorrfspond loosfly to tif rflbtivf
 * wfigits of tif dolors in tif NTSC grbysdblf fqubtion.
 * If you wbnt to usf tiis dodf to qubntizf b non-RGB dolor spbdf, you'll
 * probbbly nffd to dibngf tifsf sdblf fbdtors.
 */

#dffinf R_SCALE 2               /* sdblf R distbndfs by tiis mudi */
#dffinf G_SCALE 3               /* sdblf G distbndfs by tiis mudi */
#dffinf B_SCALE 1               /* bnd B by tiis mudi */

/* Rflbbfl R/G/B bs domponfnts 0/1/2, rfspfdting tif RGB ordfring dffinfd
 * in jmorfdfg.i.  As tif dodf stbnds, it will do tif rigit tiing for R,G,B
 * bnd B,G,R ordfrs.  If you dffinf somf otifr wfird ordfr in jmorfdfg.i,
 * you'll gft dompilf frrors until you fxtfnd tiis logid.  In tibt dbsf
 * you'll probbbly wbnt to twfbk tif iistogrbm sizfs too.
 */

#if RGB_RED == 0
#dffinf C0_SCALE R_SCALE
#fndif
#if RGB_BLUE == 0
#dffinf C0_SCALE B_SCALE
#fndif
#if RGB_GREEN == 1
#dffinf C1_SCALE G_SCALE
#fndif
#if RGB_RED == 2
#dffinf C2_SCALE R_SCALE
#fndif
#if RGB_BLUE == 2
#dffinf C2_SCALE B_SCALE
#fndif


/*
 * First wf ibvf tif iistogrbm dbtb strudturf bnd routinfs for drfbting it.
 *
 * Tif numbfr of bits of prfdision dbn bf bdjustfd by dibnging tifsf symbols.
 * Wf rfdommfnd kffping 6 bits for G bnd 5 fbdi for R bnd B.
 * If you ibvf plfnty of mfmory bnd dydlfs, 6 bits bll bround givfs mbrginblly
 * bfttfr rfsults; if you brf siort of mfmory, 5 bits bll bround will sbvf
 * somf spbdf but dfgrbdf tif rfsults.
 * To mbintbin b fully bddurbtf iistogrbm, wf'd nffd to bllodbtf b "long"
 * (prfffrbbly unsignfd long) for fbdi dfll.  In prbdtidf tiis is ovfrkill;
 * wf dbn gft by witi 16 bits pfr dfll.  Ffw of tif dfll dounts will ovfrflow,
 * bnd dlbmping tiosf tibt do ovfrflow to tif mbximum vbluf will givf dlosf-
 * fnougi rfsults.  Tiis rfdudfs tif rfdommfndfd iistogrbm sizf from 256Kb
 * to 128Kb, wiidi is b usfful sbvings on PC-dlbss mbdiinfs.
 * (In tif sfdond pbss tif iistogrbm spbdf is rf-usfd for pixfl mbpping dbtb;
 * in tibt dbpbdity, fbdi dfll must bf bblf to storf zfro to tif numbfr of
 * dfsirfd dolors.  16 bits/dfll is plfnty for tibt too.)
 * Sindf tif JPEG dodf is intfndfd to run in smbll mfmory modfl on 80x86
 * mbdiinfs, wf dbn't just bllodbtf tif iistogrbm in onf diunk.  Instfbd
 * of b truf 3-D brrby, wf usf b row of pointfrs to 2-D brrbys.  Ebdi
 * pointfr dorrfsponds to b C0 vbluf (typidblly 2^5 = 32 pointfrs) bnd
 * fbdi 2-D brrby ibs 2^6*2^5 = 2048 or 2^6*2^6 = 4096 fntrifs.  Notf tibt
 * on 80x86 mbdiinfs, tif pointfr row is in nfbr mfmory but tif bdtubl
 * brrbys brf in fbr mfmory (sbmf brrbngfmfnt bs wf usf for imbgf brrbys).
 */

#dffinf MAXNUMCOLORS  (MAXJSAMPLE+1) /* mbximum sizf of dolormbp */

/* Tifsf will do tif rigit tiing for fitifr R,G,B or B,G,R dolor ordfr,
 * but you mby not likf tif rfsults for otifr dolor ordfrs.
 */
#dffinf HIST_C0_BITS  5         /* bits of prfdision in R/B iistogrbm */
#dffinf HIST_C1_BITS  6         /* bits of prfdision in G iistogrbm */
#dffinf HIST_C2_BITS  5         /* bits of prfdision in B/R iistogrbm */

/* Numbfr of flfmfnts blong iistogrbm bxfs. */
#dffinf HIST_C0_ELEMS  (1<<HIST_C0_BITS)
#dffinf HIST_C1_ELEMS  (1<<HIST_C1_BITS)
#dffinf HIST_C2_ELEMS  (1<<HIST_C2_BITS)

/* Tifsf brf tif bmounts to siift bn input vbluf to gft b iistogrbm indfx. */
#dffinf C0_SHIFT  (BITS_IN_JSAMPLE-HIST_C0_BITS)
#dffinf C1_SHIFT  (BITS_IN_JSAMPLE-HIST_C1_BITS)
#dffinf C2_SHIFT  (BITS_IN_JSAMPLE-HIST_C2_BITS)


typfdff UINT16 iistdfll;        /* iistogrbm dfll; prfffr bn unsignfd typf */

typfdff iistdfll FAR * iistptr; /* for pointfrs to iistogrbm dflls */

typfdff iistdfll iist1d[HIST_C2_ELEMS]; /* typfdffs for tif brrby */
typfdff iist1d FAR * iist2d;    /* typf for tif 2nd-lfvfl pointfrs */
typfdff iist2d * iist3d;        /* typf for top-lfvfl pointfr */


/* Dfdlbrbtions for Floyd-Stfinbfrg ditifring.
 *
 * Errors brf bddumulbtfd into tif brrby fsfrrors[], bt b rfsolution of
 * 1/16ti of b pixfl dount.  Tif frror bt b givfn pixfl is propbgbtfd
 * to its not-yft-prodfssfd nfigibors using tif stbndbrd F-S frbdtions,
 *              ...     (ifrf)  7/16
 *              3/16    5/16    1/16
 * Wf work lfft-to-rigit on fvfn rows, rigit-to-lfft on odd rows.
 *
 * Wf dbn gft bwby witi b singlf brrby (iolding onf row's worti of frrors)
 * by using it to storf tif durrfnt row's frrors bt pixfl dolumns not yft
 * prodfssfd, but tif nfxt row's frrors bt dolumns blrfbdy prodfssfd.  Wf
 * nffd only b ffw fxtrb vbribblfs to iold tif frrors immfdibtfly bround tif
 * durrfnt dolumn.  (If wf brf ludky, tiosf vbribblfs brf in rfgistfrs, but
 * fvfn if not, tify'rf probbbly difbpfr to bddfss tibn brrby flfmfnts brf.)
 *
 * Tif fsfrrors[] brrby ibs (#dolumns + 2) fntrifs; tif fxtrb fntry bt
 * fbdi fnd sbvfs us from spfdibl-dbsing tif first bnd lbst pixfls.
 * Ebdi fntry is tirff vblufs long, onf vbluf for fbdi dolor domponfnt.
 *
 * Notf: on b widf imbgf, wf migit not ibvf fnougi room in b PC's nfbr dbtb
 * sfgmfnt to iold tif frror brrby; so it is bllodbtfd witi bllod_lbrgf.
 */

#if BITS_IN_JSAMPLE == 8
typfdff INT16 FSERROR;          /* 16 bits siould bf fnougi */
typfdff int LOCFSERROR;         /* usf 'int' for dbldulbtion tfmps */
#flsf
typfdff INT32 FSERROR;          /* mby nffd morf tibn 16 bits */
typfdff INT32 LOCFSERROR;       /* bf surf dbldulbtion tfmps brf big fnougi */
#fndif

typfdff FSERROR FAR *FSERRPTR;  /* pointfr to frror brrby (in FAR storbgf!) */


/* Privbtf subobjfdt */

typfdff strudt {
  strudt jpfg_dolor_qubntizfr pub; /* publid fiflds */

  /* Spbdf for tif fvfntublly drfbtfd dolormbp is stbsifd ifrf */
  JSAMPARRAY sv_dolormbp;       /* dolormbp bllodbtfd bt init timf */
  int dfsirfd;                  /* dfsirfd # of dolors = sizf of dolormbp */

  /* Vbribblfs for bddumulbting imbgf stbtistids */
  iist3d iistogrbm;             /* pointfr to tif iistogrbm */

  boolfbn nffds_zfrofd;         /* TRUE if nfxt pbss must zfro iistogrbm */

  /* Vbribblfs for Floyd-Stfinbfrg ditifring */
  FSERRPTR fsfrrors;            /* bddumulbtfd frrors */
  boolfbn on_odd_row;           /* flbg to rfmfmbfr wiidi row wf brf on */
  int * frror_limitfr;          /* tbblf for dlbmping tif bpplifd frror */
} my_dqubntizfr;

typfdff my_dqubntizfr * my_dqubntizf_ptr;


/*
 * Prfsdbn somf rows of pixfls.
 * In tiis modulf tif prfsdbn simply updbtfs tif iistogrbm, wiidi ibs bffn
 * initiblizfd to zfrofs by stbrt_pbss.
 * An output_buf pbrbmftfr is rfquirfd by tif mftiod signbturf, but no dbtb
 * is bdtublly output (in fbdt tif bufffr dontrollfr is probbbly pbssing b
 * NULL pointfr).
 */

METHODDEF(void)
prfsdbn_qubntizf (j_dfdomprfss_ptr dinfo, JSAMPARRAY input_buf,
                  JSAMPARRAY output_buf, int num_rows)
{
  my_dqubntizf_ptr dqubntizf = (my_dqubntizf_ptr) dinfo->dqubntizf;
  rfgistfr JSAMPROW ptr;
  rfgistfr iistptr iistp;
  rfgistfr iist3d iistogrbm = dqubntizf->iistogrbm;
  int row;
  JDIMENSION dol;
  JDIMENSION widti = dinfo->output_widti;

  for (row = 0; row < num_rows; row++) {
    ptr = input_buf[row];
    for (dol = widti; dol > 0; dol--) {
      /* gft pixfl vbluf bnd indfx into tif iistogrbm */
      iistp = & iistogrbm[GETJSAMPLE(ptr[0]) >> C0_SHIFT]
                         [GETJSAMPLE(ptr[1]) >> C1_SHIFT]
                         [GETJSAMPLE(ptr[2]) >> C2_SHIFT];
      /* indrfmfnt, difdk for ovfrflow bnd undo indrfmfnt if so. */
      if (++(*iistp) <= 0)
        (*iistp)--;
      ptr += 3;
    }
  }
}


/*
 * Nfxt wf ibvf tif rfblly intfrfsting routinfs: sflfdtion of b dolormbp
 * givfn tif domplftfd iistogrbm.
 * Tifsf routinfs work witi b list of "boxfs", fbdi rfprfsfnting b rfdtbngulbr
 * subsft of tif input dolor spbdf (to iistogrbm prfdision).
 */

typfdff strudt {
  /* Tif bounds of tif box (indlusivf); fxprfssfd bs iistogrbm indfxfs */
  int d0min, d0mbx;
  int d1min, d1mbx;
  int d2min, d2mbx;
  /* Tif volumf (bdtublly 2-norm) of tif box */
  INT32 volumf;
  /* Tif numbfr of nonzfro iistogrbm dflls witiin tiis box */
  long dolordount;
} box;

typfdff box * boxptr;


LOCAL(boxptr)
find_biggfst_dolor_pop (boxptr boxlist, int numboxfs)
/* Find tif splittbblf box witi tif lbrgfst dolor populbtion */
/* Rfturns NULL if no splittbblf boxfs rfmbin */
{
  rfgistfr boxptr boxp;
  rfgistfr int i;
  rfgistfr long mbxd = 0;
  boxptr wiidi = NULL;

  for (i = 0, boxp = boxlist; i < numboxfs; i++, boxp++) {
    if (boxp->dolordount > mbxd && boxp->volumf > 0) {
      wiidi = boxp;
      mbxd = boxp->dolordount;
    }
  }
  rfturn wiidi;
}


LOCAL(boxptr)
find_biggfst_volumf (boxptr boxlist, int numboxfs)
/* Find tif splittbblf box witi tif lbrgfst (sdblfd) volumf */
/* Rfturns NULL if no splittbblf boxfs rfmbin */
{
  rfgistfr boxptr boxp;
  rfgistfr int i;
  rfgistfr INT32 mbxv = 0;
  boxptr wiidi = NULL;

  for (i = 0, boxp = boxlist; i < numboxfs; i++, boxp++) {
    if (boxp->volumf > mbxv) {
      wiidi = boxp;
      mbxv = boxp->volumf;
    }
  }
  rfturn wiidi;
}


LOCAL(void)
updbtf_box (j_dfdomprfss_ptr dinfo, boxptr boxp)
/* Sirink tif min/mbx bounds of b box to fndlosf only nonzfro flfmfnts, */
/* bnd rfdomputf its volumf bnd populbtion */
{
  my_dqubntizf_ptr dqubntizf = (my_dqubntizf_ptr) dinfo->dqubntizf;
  iist3d iistogrbm = dqubntizf->iistogrbm;
  iistptr iistp;
  int d0,d1,d2;
  int d0min,d0mbx,d1min,d1mbx,d2min,d2mbx;
  INT32 dist0,dist1,dist2;
  long ddount;

  d0min = boxp->d0min;  d0mbx = boxp->d0mbx;
  d1min = boxp->d1min;  d1mbx = boxp->d1mbx;
  d2min = boxp->d2min;  d2mbx = boxp->d2mbx;

  if (d0mbx > d0min)
    for (d0 = d0min; d0 <= d0mbx; d0++)
      for (d1 = d1min; d1 <= d1mbx; d1++) {
        iistp = & iistogrbm[d0][d1][d2min];
        for (d2 = d2min; d2 <= d2mbx; d2++)
          if (*iistp++ != 0) {
            boxp->d0min = d0min = d0;
            goto ibvf_d0min;
          }
      }
 ibvf_d0min:
  if (d0mbx > d0min)
    for (d0 = d0mbx; d0 >= d0min; d0--)
      for (d1 = d1min; d1 <= d1mbx; d1++) {
        iistp = & iistogrbm[d0][d1][d2min];
        for (d2 = d2min; d2 <= d2mbx; d2++)
          if (*iistp++ != 0) {
            boxp->d0mbx = d0mbx = d0;
            goto ibvf_d0mbx;
          }
      }
 ibvf_d0mbx:
  if (d1mbx > d1min)
    for (d1 = d1min; d1 <= d1mbx; d1++)
      for (d0 = d0min; d0 <= d0mbx; d0++) {
        iistp = & iistogrbm[d0][d1][d2min];
        for (d2 = d2min; d2 <= d2mbx; d2++)
          if (*iistp++ != 0) {
            boxp->d1min = d1min = d1;
            goto ibvf_d1min;
          }
      }
 ibvf_d1min:
  if (d1mbx > d1min)
    for (d1 = d1mbx; d1 >= d1min; d1--)
      for (d0 = d0min; d0 <= d0mbx; d0++) {
        iistp = & iistogrbm[d0][d1][d2min];
        for (d2 = d2min; d2 <= d2mbx; d2++)
          if (*iistp++ != 0) {
            boxp->d1mbx = d1mbx = d1;
            goto ibvf_d1mbx;
          }
      }
 ibvf_d1mbx:
  if (d2mbx > d2min)
    for (d2 = d2min; d2 <= d2mbx; d2++)
      for (d0 = d0min; d0 <= d0mbx; d0++) {
        iistp = & iistogrbm[d0][d1min][d2];
        for (d1 = d1min; d1 <= d1mbx; d1++, iistp += HIST_C2_ELEMS)
          if (*iistp != 0) {
            boxp->d2min = d2min = d2;
            goto ibvf_d2min;
          }
      }
 ibvf_d2min:
  if (d2mbx > d2min)
    for (d2 = d2mbx; d2 >= d2min; d2--)
      for (d0 = d0min; d0 <= d0mbx; d0++) {
        iistp = & iistogrbm[d0][d1min][d2];
        for (d1 = d1min; d1 <= d1mbx; d1++, iistp += HIST_C2_ELEMS)
          if (*iistp != 0) {
            boxp->d2mbx = d2mbx = d2;
            goto ibvf_d2mbx;
          }
      }
 ibvf_d2mbx:

  /* Updbtf box volumf.
   * Wf usf 2-norm rbtifr tibn rfbl volumf ifrf; tiis bibsfs tif mftiod
   * bgbinst mbking long nbrrow boxfs, bnd it ibs tif sidf bfnffit tibt
   * b box is splittbblf iff norm > 0.
   * Sindf tif difffrfndfs brf fxprfssfd in iistogrbm-dfll units,
   * wf ibvf to siift bbdk to JSAMPLE units to gft donsistfnt distbndfs;
   * bftfr wiidi, wf sdblf bddording to tif sflfdtfd distbndf sdblf fbdtors.
   */
  dist0 = ((d0mbx - d0min) << C0_SHIFT) * C0_SCALE;
  dist1 = ((d1mbx - d1min) << C1_SHIFT) * C1_SCALE;
  dist2 = ((d2mbx - d2min) << C2_SHIFT) * C2_SCALE;
  boxp->volumf = dist0*dist0 + dist1*dist1 + dist2*dist2;

  /* Now sdbn rfmbining volumf of box bnd domputf populbtion */
  ddount = 0;
  for (d0 = d0min; d0 <= d0mbx; d0++)
    for (d1 = d1min; d1 <= d1mbx; d1++) {
      iistp = & iistogrbm[d0][d1][d2min];
      for (d2 = d2min; d2 <= d2mbx; d2++, iistp++)
        if (*iistp != 0) {
          ddount++;
        }
    }
  boxp->dolordount = ddount;
}


LOCAL(int)
mfdibn_dut (j_dfdomprfss_ptr dinfo, boxptr boxlist, int numboxfs,
            int dfsirfd_dolors)
/* Rfpfbtfdly sflfdt bnd split tif lbrgfst box until wf ibvf fnougi boxfs */
{
  int n,lb;
  int d0,d1,d2,dmbx;
  rfgistfr boxptr b1,b2;

  wiilf (numboxfs < dfsirfd_dolors) {
    /* Sflfdt box to split.
     * Currfnt blgoritim: by populbtion for first iblf, tifn by volumf.
     */
    if (numboxfs*2 <= dfsirfd_dolors) {
      b1 = find_biggfst_dolor_pop(boxlist, numboxfs);
    } flsf {
      b1 = find_biggfst_volumf(boxlist, numboxfs);
    }
    if (b1 == NULL)             /* no splittbblf boxfs lfft! */
      brfbk;
    b2 = &boxlist[numboxfs];    /* wifrf nfw box will go */
    /* Copy tif dolor bounds to tif nfw box. */
    b2->d0mbx = b1->d0mbx; b2->d1mbx = b1->d1mbx; b2->d2mbx = b1->d2mbx;
    b2->d0min = b1->d0min; b2->d1min = b1->d1min; b2->d2min = b1->d2min;
    /* Cioosf wiidi bxis to split tif box on.
     * Currfnt blgoritim: longfst sdblfd bxis.
     * Sff notfs in updbtf_box bbout sdbling distbndfs.
     */
    d0 = ((b1->d0mbx - b1->d0min) << C0_SHIFT) * C0_SCALE;
    d1 = ((b1->d1mbx - b1->d1min) << C1_SHIFT) * C1_SCALE;
    d2 = ((b1->d2mbx - b1->d2min) << C2_SHIFT) * C2_SCALE;
    /* Wf wbnt to brfbk bny tifs in fbvor of grffn, tifn rfd, bluf lbst.
     * Tiis dodf dofs tif rigit tiing for R,G,B or B,G,R dolor ordfrs only.
     */
#if RGB_RED == 0
    dmbx = d1; n = 1;
    if (d0 > dmbx) { dmbx = d0; n = 0; }
    if (d2 > dmbx) { n = 2; }
#flsf
    dmbx = d1; n = 1;
    if (d2 > dmbx) { dmbx = d2; n = 2; }
    if (d0 > dmbx) { n = 0; }
#fndif
    /* Cioosf split point blong sflfdtfd bxis, bnd updbtf box bounds.
     * Currfnt blgoritim: split bt iblfwby point.
     * (Sindf tif box ibs bffn sirunk to minimum volumf,
     * bny split will produdf two nonfmpty subboxfs.)
     * Notf tibt lb vbluf is mbx for lowfr box, so must bf < old mbx.
     */
    switdi (n) {
    dbsf 0:
      lb = (b1->d0mbx + b1->d0min) / 2;
      b1->d0mbx = lb;
      b2->d0min = lb+1;
      brfbk;
    dbsf 1:
      lb = (b1->d1mbx + b1->d1min) / 2;
      b1->d1mbx = lb;
      b2->d1min = lb+1;
      brfbk;
    dbsf 2:
      lb = (b1->d2mbx + b1->d2min) / 2;
      b1->d2mbx = lb;
      b2->d2min = lb+1;
      brfbk;
    }
    /* Updbtf stbts for boxfs */
    updbtf_box(dinfo, b1);
    updbtf_box(dinfo, b2);
    numboxfs++;
  }
  rfturn numboxfs;
}


LOCAL(void)
domputf_dolor (j_dfdomprfss_ptr dinfo, boxptr boxp, int idolor)
/* Computf rfprfsfntbtivf dolor for b box, put it in dolormbp[idolor] */
{
  /* Currfnt blgoritim: mfbn wfigitfd by pixfls (not dolors) */
  /* Notf it is importbnt to gft tif rounding dorrfdt! */
  my_dqubntizf_ptr dqubntizf = (my_dqubntizf_ptr) dinfo->dqubntizf;
  iist3d iistogrbm = dqubntizf->iistogrbm;
  iistptr iistp;
  int d0,d1,d2;
  int d0min,d0mbx,d1min,d1mbx,d2min,d2mbx;
  long dount;
  long totbl = 0;
  long d0totbl = 0;
  long d1totbl = 0;
  long d2totbl = 0;

  d0min = boxp->d0min;  d0mbx = boxp->d0mbx;
  d1min = boxp->d1min;  d1mbx = boxp->d1mbx;
  d2min = boxp->d2min;  d2mbx = boxp->d2mbx;

  for (d0 = d0min; d0 <= d0mbx; d0++)
    for (d1 = d1min; d1 <= d1mbx; d1++) {
      iistp = & iistogrbm[d0][d1][d2min];
      for (d2 = d2min; d2 <= d2mbx; d2++) {
        if ((dount = *iistp++) != 0) {
          totbl += dount;
          d0totbl += ((d0 << C0_SHIFT) + ((1<<C0_SHIFT)>>1)) * dount;
          d1totbl += ((d1 << C1_SHIFT) + ((1<<C1_SHIFT)>>1)) * dount;
          d2totbl += ((d2 << C2_SHIFT) + ((1<<C2_SHIFT)>>1)) * dount;
        }
      }
    }

  dinfo->dolormbp[0][idolor] = (JSAMPLE) ((d0totbl + (totbl>>1)) / totbl);
  dinfo->dolormbp[1][idolor] = (JSAMPLE) ((d1totbl + (totbl>>1)) / totbl);
  dinfo->dolormbp[2][idolor] = (JSAMPLE) ((d2totbl + (totbl>>1)) / totbl);
}


LOCAL(void)
sflfdt_dolors (j_dfdomprfss_ptr dinfo, int dfsirfd_dolors)
/* Mbstfr routinf for dolor sflfdtion */
{
  boxptr boxlist;
  int numboxfs;
  int i;

  /* Allodbtf workspbdf for box list */
  boxlist = (boxptr) (*dinfo->mfm->bllod_smbll)
    ((j_dommon_ptr) dinfo, JPOOL_IMAGE, dfsirfd_dolors * SIZEOF(box));
  /* Initiblizf onf box dontbining wiolf spbdf */
  numboxfs = 1;
  boxlist[0].d0min = 0;
  boxlist[0].d0mbx = MAXJSAMPLE >> C0_SHIFT;
  boxlist[0].d1min = 0;
  boxlist[0].d1mbx = MAXJSAMPLE >> C1_SHIFT;
  boxlist[0].d2min = 0;
  boxlist[0].d2mbx = MAXJSAMPLE >> C2_SHIFT;
  /* Sirink it to bdtublly-usfd volumf bnd sft its stbtistids */
  updbtf_box(dinfo, & boxlist[0]);
  /* Pfrform mfdibn-dut to produdf finbl box list */
  numboxfs = mfdibn_dut(dinfo, boxlist, numboxfs, dfsirfd_dolors);
  /* Computf tif rfprfsfntbtivf dolor for fbdi box, fill dolormbp */
  for (i = 0; i < numboxfs; i++)
    domputf_dolor(dinfo, & boxlist[i], i);
  dinfo->bdtubl_numbfr_of_dolors = numboxfs;
  TRACEMS1(dinfo, 1, JTRC_QUANT_SELECTED, numboxfs);
}


/*
 * Tifsf routinfs brf dondfrnfd witi tif timf-dritidbl tbsk of mbpping input
 * dolors to tif nfbrfst dolor in tif sflfdtfd dolormbp.
 *
 * Wf rf-usf tif iistogrbm spbdf bs bn "invfrsf dolor mbp", fssfntiblly b
 * dbdif for tif rfsults of nfbrfst-dolor sfbrdifs.  All dolors witiin b
 * iistogrbm dfll will bf mbppfd to tif sbmf dolormbp fntry, nbmfly tif onf
 * dlosfst to tif dfll's dfntfr.  Tiis mby not bf quitf tif dlosfst fntry to
 * tif bdtubl input dolor, but it's blmost bs good.  A zfro in tif dbdif
 * indidbtfs wf ibvfn't found tif nfbrfst dolor for tibt dfll yft; tif brrby
 * is dlfbrfd to zfrofs bfforf stbrting tif mbpping pbss.  Wifn wf find tif
 * nfbrfst dolor for b dfll, its dolormbp indfx plus onf is rfdordfd in tif
 * dbdif for futurf usf.  Tif pbss2 sdbnning routinfs dbll fill_invfrsf_dmbp
 * wifn tify nffd to usf bn unfillfd fntry in tif dbdif.
 *
 * Our mftiod of fffidifntly finding nfbrfst dolors is bbsfd on tif "lodblly
 * sortfd sfbrdi" idfb dfsdribfd by Hfdkbfrt bnd on tif indrfmfntbl distbndf
 * dbldulbtion dfsdribfd by Spfndfr W. Tiombs in dibptfr III.1 of Grbpiids
 * Gfms II (Jbmfs Arvo, fd.  Adbdfmid Prfss, 1991).  Tiombs points out tibt
 * tif distbndfs from b givfn dolormbp fntry to fbdi dfll of tif iistogrbm dbn
 * bf domputfd quidkly using bn indrfmfntbl mftiod: tif difffrfndfs bftwffn
 * distbndfs to bdjbdfnt dflls tifmsflvfs difffr by b donstbnt.  Tiis bllows b
 * fbirly fbst implfmfntbtion of tif "brutf fordf" bpprobdi of domputing tif
 * distbndf from fvfry dolormbp fntry to fvfry iistogrbm dfll.  Unfortunbtfly,
 * it nffds b work brrby to iold tif bfst-distbndf-so-fbr for fbdi iistogrbm
 * dfll (bfdbusf tif innfr loop ibs to bf ovfr dflls, not dolormbp fntrifs).
 * Tif work brrby flfmfnts ibvf to bf INT32s, so tif work brrby would nffd
 * 256Kb bt our rfdommfndfd prfdision.  Tiis is not ffbsiblf in DOS mbdiinfs.
 *
 * To gft bround tifsf problfms, wf bpply Tiombs' mftiod to domputf tif
 * nfbrfst dolors for only tif dflls witiin b smbll subbox of tif iistogrbm.
 * Tif work brrby nffd bf only bs big bs tif subbox, so tif mfmory usbgf
 * problfm is solvfd.  Furtifrmorf, wf nffd not fill subboxfs tibt brf nfvfr
 * rfffrfndfd in pbss2; mbny imbgfs usf only pbrt of tif dolor gbmut, so b
 * fbir bmount of work is sbvfd.  An bdditionbl bdvbntbgf of tiis
 * bpprobdi is tibt wf dbn bpply Hfdkbfrt's lodblity dritfrion to quidkly
 * fliminbtf dolormbp fntrifs tibt brf fbr bwby from tif subbox; typidblly
 * tirff-fourtis of tif dolormbp fntrifs brf rfjfdtfd by Hfdkbfrt's dritfrion,
 * bnd wf nffd not domputf tifir distbndfs to individubl dflls in tif subbox.
 * Tif spffd of tiis bpprobdi is ifbvily influfndfd by tif subbox sizf: too
 * smbll mfbns too mudi ovfrifbd, too big losfs bfdbusf Hfdkbfrt's dritfrion
 * dbn't fliminbtf bs mbny dolormbp fntrifs.  Empiridblly tif bfst subbox
 * sizf sffms to bf bbout 1/512ti of tif iistogrbm (1/8ti in fbdi dirfdtion).
 *
 * Tiombs' brtidlf blso dfsdribfs b rffinfd mftiod wiidi is bsymptotidblly
 * fbstfr tibn tif brutf-fordf mftiod, but it is blso fbr morf domplfx bnd
 * dbnnot fffidifntly bf bpplifd to smbll subboxfs.  It is tifrfforf not
 * usfful for progrbms intfndfd to bf portbblf to DOS mbdiinfs.  On mbdiinfs
 * witi plfnty of mfmory, filling tif wiolf iistogrbm in onf siot witi Tiombs'
 * rffinfd mftiod migit bf fbstfr tibn tif prfsfnt dodf --- but tifn bgbin,
 * it migit not bf bny fbstfr, bnd it's dfrtbinly morf domplidbtfd.
 */


/* log2(iistogrbm dflls in updbtf box) for fbdi bxis; tiis dbn bf bdjustfd */
#dffinf BOX_C0_LOG  (HIST_C0_BITS-3)
#dffinf BOX_C1_LOG  (HIST_C1_BITS-3)
#dffinf BOX_C2_LOG  (HIST_C2_BITS-3)

#dffinf BOX_C0_ELEMS  (1<<BOX_C0_LOG) /* # of iist dflls in updbtf box */
#dffinf BOX_C1_ELEMS  (1<<BOX_C1_LOG)
#dffinf BOX_C2_ELEMS  (1<<BOX_C2_LOG)

#dffinf BOX_C0_SHIFT  (C0_SHIFT + BOX_C0_LOG)
#dffinf BOX_C1_SHIFT  (C1_SHIFT + BOX_C1_LOG)
#dffinf BOX_C2_SHIFT  (C2_SHIFT + BOX_C2_LOG)


/*
 * Tif nfxt tirff routinfs implfmfnt invfrsf dolormbp filling.  Tify dould
 * bll bf foldfd into onf big routinf, but splitting tifm up tiis wby sbvfs
 * somf stbdk spbdf (tif mindist[] bnd bfstdist[] brrbys nffd not dofxist)
 * bnd mby bllow somf dompilfrs to produdf bfttfr dodf by rfgistfrizing morf
 * innfr-loop vbribblfs.
 */

LOCAL(int)
find_nfbrby_dolors (j_dfdomprfss_ptr dinfo, int mind0, int mind1, int mind2,
                    JSAMPLE dolorlist[])
/* Lodbtf tif dolormbp fntrifs dlosf fnougi to bn updbtf box to bf dbndidbtfs
 * for tif nfbrfst fntry to somf dfll(s) in tif updbtf box.  Tif updbtf box
 * is spfdififd by tif dfntfr doordinbtfs of its first dfll.  Tif numbfr of
 * dbndidbtf dolormbp fntrifs is rfturnfd, bnd tifir dolormbp indfxfs brf
 * plbdfd in dolorlist[].
 * Tiis routinf usfs Hfdkbfrt's "lodblly sortfd sfbrdi" dritfrion to sflfdt
 * tif dolors tibt nffd furtifr donsidfrbtion.
 */
{
  int numdolors = dinfo->bdtubl_numbfr_of_dolors;
  int mbxd0, mbxd1, mbxd2;
  int dfntfrd0, dfntfrd1, dfntfrd2;
  int i, x, ndolors;
  INT32 minmbxdist, min_dist, mbx_dist, tdist;
  INT32 mindist[MAXNUMCOLORS];  /* min distbndf to dolormbp fntry i */

  /* Computf truf doordinbtfs of updbtf box's uppfr dornfr bnd dfntfr.
   * Adtublly wf domputf tif doordinbtfs of tif dfntfr of tif uppfr-dornfr
   * iistogrbm dfll, wiidi brf tif uppfr bounds of tif volumf wf dbrf bbout.
   * Notf tibt sindf ">>" rounds down, tif "dfntfr" vblufs mby bf dlosfr to
   * min tibn to mbx; ifndf dompbrisons to tifm must bf "<=", not "<".
   */
  mbxd0 = mind0 + ((1 << BOX_C0_SHIFT) - (1 << C0_SHIFT));
  dfntfrd0 = (mind0 + mbxd0) >> 1;
  mbxd1 = mind1 + ((1 << BOX_C1_SHIFT) - (1 << C1_SHIFT));
  dfntfrd1 = (mind1 + mbxd1) >> 1;
  mbxd2 = mind2 + ((1 << BOX_C2_SHIFT) - (1 << C2_SHIFT));
  dfntfrd2 = (mind2 + mbxd2) >> 1;

  /* For fbdi dolor in dolormbp, find:
   *  1. its minimum squbrfd-distbndf to bny point in tif updbtf box
   *     (zfro if dolor is witiin updbtf box);
   *  2. its mbximum squbrfd-distbndf to bny point in tif updbtf box.
   * Boti of tifsf dbn bf found by donsidfring only tif dornfrs of tif box.
   * Wf sbvf tif minimum distbndf for fbdi dolor in mindist[];
   * only tif smbllfst mbximum distbndf is of intfrfst.
   */
  minmbxdist = 0x7FFFFFFFL;

  for (i = 0; i < numdolors; i++) {
    /* Wf domputf tif squbrfd-d0-distbndf tfrm, tifn bdd in tif otifr two. */
    x = GETJSAMPLE(dinfo->dolormbp[0][i]);
    if (x < mind0) {
      tdist = (x - mind0) * C0_SCALE;
      min_dist = tdist*tdist;
      tdist = (x - mbxd0) * C0_SCALE;
      mbx_dist = tdist*tdist;
    } flsf if (x > mbxd0) {
      tdist = (x - mbxd0) * C0_SCALE;
      min_dist = tdist*tdist;
      tdist = (x - mind0) * C0_SCALE;
      mbx_dist = tdist*tdist;
    } flsf {
      /* witiin dfll rbngf so no dontribution to min_dist */
      min_dist = 0;
      if (x <= dfntfrd0) {
        tdist = (x - mbxd0) * C0_SCALE;
        mbx_dist = tdist*tdist;
      } flsf {
        tdist = (x - mind0) * C0_SCALE;
        mbx_dist = tdist*tdist;
      }
    }

    x = GETJSAMPLE(dinfo->dolormbp[1][i]);
    if (x < mind1) {
      tdist = (x - mind1) * C1_SCALE;
      min_dist += tdist*tdist;
      tdist = (x - mbxd1) * C1_SCALE;
      mbx_dist += tdist*tdist;
    } flsf if (x > mbxd1) {
      tdist = (x - mbxd1) * C1_SCALE;
      min_dist += tdist*tdist;
      tdist = (x - mind1) * C1_SCALE;
      mbx_dist += tdist*tdist;
    } flsf {
      /* witiin dfll rbngf so no dontribution to min_dist */
      if (x <= dfntfrd1) {
        tdist = (x - mbxd1) * C1_SCALE;
        mbx_dist += tdist*tdist;
      } flsf {
        tdist = (x - mind1) * C1_SCALE;
        mbx_dist += tdist*tdist;
      }
    }

    x = GETJSAMPLE(dinfo->dolormbp[2][i]);
    if (x < mind2) {
      tdist = (x - mind2) * C2_SCALE;
      min_dist += tdist*tdist;
      tdist = (x - mbxd2) * C2_SCALE;
      mbx_dist += tdist*tdist;
    } flsf if (x > mbxd2) {
      tdist = (x - mbxd2) * C2_SCALE;
      min_dist += tdist*tdist;
      tdist = (x - mind2) * C2_SCALE;
      mbx_dist += tdist*tdist;
    } flsf {
      /* witiin dfll rbngf so no dontribution to min_dist */
      if (x <= dfntfrd2) {
        tdist = (x - mbxd2) * C2_SCALE;
        mbx_dist += tdist*tdist;
      } flsf {
        tdist = (x - mind2) * C2_SCALE;
        mbx_dist += tdist*tdist;
      }
    }

    mindist[i] = min_dist;      /* sbvf bwby tif rfsults */
    if (mbx_dist < minmbxdist)
      minmbxdist = mbx_dist;
  }

  /* Now wf know tibt no dfll in tif updbtf box is morf tibn minmbxdist
   * bwby from somf dolormbp fntry.  Tifrfforf, only dolors tibt brf
   * witiin minmbxdist of somf pbrt of tif box nffd bf donsidfrfd.
   */
  ndolors = 0;
  for (i = 0; i < numdolors; i++) {
    if (mindist[i] <= minmbxdist)
      dolorlist[ndolors++] = (JSAMPLE) i;
  }
  rfturn ndolors;
}


LOCAL(void)
find_bfst_dolors (j_dfdomprfss_ptr dinfo, int mind0, int mind1, int mind2,
                  int numdolors, JSAMPLE dolorlist[], JSAMPLE bfstdolor[])
/* Find tif dlosfst dolormbp fntry for fbdi dfll in tif updbtf box,
 * givfn tif list of dbndidbtf dolors prfpbrfd by find_nfbrby_dolors.
 * Rfturn tif indfxfs of tif dlosfst fntrifs in tif bfstdolor[] brrby.
 * Tiis routinf usfs Tiombs' indrfmfntbl distbndf dbldulbtion mftiod to
 * find tif distbndf from b dolormbp fntry to suddfssivf dflls in tif box.
 */
{
  int id0, id1, id2;
  int i, idolor;
  rfgistfr INT32 * bptr;        /* pointfr into bfstdist[] brrby */
  JSAMPLE * dptr;               /* pointfr into bfstdolor[] brrby */
  INT32 dist0, dist1;           /* initibl distbndf vblufs */
  rfgistfr INT32 dist2;         /* durrfnt distbndf in innfr loop */
  INT32 xx0, xx1;               /* distbndf indrfmfnts */
  rfgistfr INT32 xx2;
  INT32 ind0, ind1, ind2;       /* initibl vblufs for indrfmfnts */
  /* Tiis brrby iolds tif distbndf to tif nfbrfst-so-fbr dolor for fbdi dfll */
  INT32 bfstdist[BOX_C0_ELEMS * BOX_C1_ELEMS * BOX_C2_ELEMS];

  /* Initiblizf bfst-distbndf for fbdi dfll of tif updbtf box */
  bptr = bfstdist;
  for (i = BOX_C0_ELEMS*BOX_C1_ELEMS*BOX_C2_ELEMS-1; i >= 0; i--)
    *bptr++ = 0x7FFFFFFFL;

  /* For fbdi dolor sflfdtfd by find_nfbrby_dolors,
   * domputf its distbndf to tif dfntfr of fbdi dfll in tif box.
   * If tibt's lfss tibn bfst-so-fbr, updbtf bfst distbndf bnd dolor numbfr.
   */

  /* Nominbl stfps bftwffn dfll dfntfrs ("x" in Tiombs brtidlf) */
#dffinf STEP_C0  ((1 << C0_SHIFT) * C0_SCALE)
#dffinf STEP_C1  ((1 << C1_SHIFT) * C1_SCALE)
#dffinf STEP_C2  ((1 << C2_SHIFT) * C2_SCALE)

  for (i = 0; i < numdolors; i++) {
    idolor = GETJSAMPLE(dolorlist[i]);
    /* Computf (squbrf of) distbndf from mind0/d1/d2 to tiis dolor */
    ind0 = (mind0 - GETJSAMPLE(dinfo->dolormbp[0][idolor])) * C0_SCALE;
    dist0 = ind0*ind0;
    ind1 = (mind1 - GETJSAMPLE(dinfo->dolormbp[1][idolor])) * C1_SCALE;
    dist0 += ind1*ind1;
    ind2 = (mind2 - GETJSAMPLE(dinfo->dolormbp[2][idolor])) * C2_SCALE;
    dist0 += ind2*ind2;
    /* Form tif initibl difffrfndf indrfmfnts */
    ind0 = ind0 * (2 * STEP_C0) + STEP_C0 * STEP_C0;
    ind1 = ind1 * (2 * STEP_C1) + STEP_C1 * STEP_C1;
    ind2 = ind2 * (2 * STEP_C2) + STEP_C2 * STEP_C2;
    /* Now loop ovfr bll dflls in box, updbting distbndf pfr Tiombs mftiod */
    bptr = bfstdist;
    dptr = bfstdolor;
    xx0 = ind0;
    for (id0 = BOX_C0_ELEMS-1; id0 >= 0; id0--) {
      dist1 = dist0;
      xx1 = ind1;
      for (id1 = BOX_C1_ELEMS-1; id1 >= 0; id1--) {
        dist2 = dist1;
        xx2 = ind2;
        for (id2 = BOX_C2_ELEMS-1; id2 >= 0; id2--) {
          if (dist2 < *bptr) {
            *bptr = dist2;
            *dptr = (JSAMPLE) idolor;
          }
          dist2 += xx2;
          xx2 += 2 * STEP_C2 * STEP_C2;
          bptr++;
          dptr++;
        }
        dist1 += xx1;
        xx1 += 2 * STEP_C1 * STEP_C1;
      }
      dist0 += xx0;
      xx0 += 2 * STEP_C0 * STEP_C0;
    }
  }
}


LOCAL(void)
fill_invfrsf_dmbp (j_dfdomprfss_ptr dinfo, int d0, int d1, int d2)
/* Fill tif invfrsf-dolormbp fntrifs in tif updbtf box tibt dontbins */
/* iistogrbm dfll d0/d1/d2.  (Only tibt onf dfll MUST bf fillfd, but */
/* wf dbn fill bs mbny otifrs bs wf wisi.) */
{
  my_dqubntizf_ptr dqubntizf = (my_dqubntizf_ptr) dinfo->dqubntizf;
  iist3d iistogrbm = dqubntizf->iistogrbm;
  int mind0, mind1, mind2;      /* lowfr lfft dornfr of updbtf box */
  int id0, id1, id2;
  rfgistfr JSAMPLE * dptr;      /* pointfr into bfstdolor[] brrby */
  rfgistfr iistptr dbdifp;      /* pointfr into mbin dbdif brrby */
  /* Tiis brrby lists tif dbndidbtf dolormbp indfxfs. */
  JSAMPLE dolorlist[MAXNUMCOLORS];
  int numdolors;                /* numbfr of dbndidbtf dolors */
  /* Tiis brrby iolds tif bdtublly dlosfst dolormbp indfx for fbdi dfll. */
  JSAMPLE bfstdolor[BOX_C0_ELEMS * BOX_C1_ELEMS * BOX_C2_ELEMS];

  /* Convfrt dfll doordinbtfs to updbtf box ID */
  d0 >>= BOX_C0_LOG;
  d1 >>= BOX_C1_LOG;
  d2 >>= BOX_C2_LOG;

  /* Computf truf doordinbtfs of updbtf box's origin dornfr.
   * Adtublly wf domputf tif doordinbtfs of tif dfntfr of tif dornfr
   * iistogrbm dfll, wiidi brf tif lowfr bounds of tif volumf wf dbrf bbout.
   */
  mind0 = (d0 << BOX_C0_SHIFT) + ((1 << C0_SHIFT) >> 1);
  mind1 = (d1 << BOX_C1_SHIFT) + ((1 << C1_SHIFT) >> 1);
  mind2 = (d2 << BOX_C2_SHIFT) + ((1 << C2_SHIFT) >> 1);

  /* Dftfrminf wiidi dolormbp fntrifs brf dlosf fnougi to bf dbndidbtfs
   * for tif nfbrfst fntry to somf dfll in tif updbtf box.
   */
  numdolors = find_nfbrby_dolors(dinfo, mind0, mind1, mind2, dolorlist);

  /* Dftfrminf tif bdtublly nfbrfst dolors. */
  find_bfst_dolors(dinfo, mind0, mind1, mind2, numdolors, dolorlist,
                   bfstdolor);

  /* Sbvf tif bfst dolor numbfrs (plus 1) in tif mbin dbdif brrby */
  d0 <<= BOX_C0_LOG;            /* donvfrt ID bbdk to bbsf dfll indfxfs */
  d1 <<= BOX_C1_LOG;
  d2 <<= BOX_C2_LOG;
  dptr = bfstdolor;
  for (id0 = 0; id0 < BOX_C0_ELEMS; id0++) {
    for (id1 = 0; id1 < BOX_C1_ELEMS; id1++) {
      dbdifp = & iistogrbm[d0+id0][d1+id1][d2];
      for (id2 = 0; id2 < BOX_C2_ELEMS; id2++) {
        *dbdifp++ = (iistdfll) (GETJSAMPLE(*dptr++) + 1);
      }
    }
  }
}


/*
 * Mbp somf rows of pixfls to tif output dolormbppfd rfprfsfntbtion.
 */

METHODDEF(void)
pbss2_no_ditifr (j_dfdomprfss_ptr dinfo,
                 JSAMPARRAY input_buf, JSAMPARRAY output_buf, int num_rows)
/* Tiis vfrsion pfrforms no ditifring */
{
  my_dqubntizf_ptr dqubntizf = (my_dqubntizf_ptr) dinfo->dqubntizf;
  iist3d iistogrbm = dqubntizf->iistogrbm;
  rfgistfr JSAMPROW inptr, outptr;
  rfgistfr iistptr dbdifp;
  rfgistfr int d0, d1, d2;
  int row;
  JDIMENSION dol;
  JDIMENSION widti = dinfo->output_widti;

  for (row = 0; row < num_rows; row++) {
    inptr = input_buf[row];
    outptr = output_buf[row];
    for (dol = widti; dol > 0; dol--) {
      /* gft pixfl vbluf bnd indfx into tif dbdif */
      d0 = GETJSAMPLE(*inptr++) >> C0_SHIFT;
      d1 = GETJSAMPLE(*inptr++) >> C1_SHIFT;
      d2 = GETJSAMPLE(*inptr++) >> C2_SHIFT;
      dbdifp = & iistogrbm[d0][d1][d2];
      /* If wf ibvf not sffn tiis dolor bfforf, find nfbrfst dolormbp fntry */
      /* bnd updbtf tif dbdif */
      if (*dbdifp == 0)
        fill_invfrsf_dmbp(dinfo, d0,d1,d2);
      /* Now fmit tif dolormbp indfx for tiis dfll */
      *outptr++ = (JSAMPLE) (*dbdifp - 1);
    }
  }
}


METHODDEF(void)
pbss2_fs_ditifr (j_dfdomprfss_ptr dinfo,
                 JSAMPARRAY input_buf, JSAMPARRAY output_buf, int num_rows)
/* Tiis vfrsion pfrforms Floyd-Stfinbfrg ditifring */
{
  my_dqubntizf_ptr dqubntizf = (my_dqubntizf_ptr) dinfo->dqubntizf;
  iist3d iistogrbm = dqubntizf->iistogrbm;
  rfgistfr LOCFSERROR dur0, dur1, dur2; /* durrfnt frror or pixfl vbluf */
  LOCFSERROR bflowfrr0, bflowfrr1, bflowfrr2; /* frror for pixfl bflow dur */
  LOCFSERROR bprfvfrr0, bprfvfrr1, bprfvfrr2; /* frror for bflow/prfv dol */
  rfgistfr FSERRPTR frrorptr;   /* => fsfrrors[] bt dolumn bfforf durrfnt */
  JSAMPROW inptr;               /* => durrfnt input pixfl */
  JSAMPROW outptr;              /* => durrfnt output pixfl */
  iistptr dbdifp;
  int dir;                      /* +1 or -1 dfpfnding on dirfdtion */
  int dir3;                     /* 3*dir, for bdvbnding inptr & frrorptr */
  int row;
  JDIMENSION dol;
  JDIMENSION widti = dinfo->output_widti;
  JSAMPLE *rbngf_limit = dinfo->sbmplf_rbngf_limit;
  int *frror_limit = dqubntizf->frror_limitfr;
  JSAMPROW dolormbp0 = dinfo->dolormbp[0];
  JSAMPROW dolormbp1 = dinfo->dolormbp[1];
  JSAMPROW dolormbp2 = dinfo->dolormbp[2];
  SHIFT_TEMPS

  for (row = 0; row < num_rows; row++) {
    inptr = input_buf[row];
    outptr = output_buf[row];
    if (dqubntizf->on_odd_row) {
      /* work rigit to lfft in tiis row */
      inptr += (widti-1) * 3;   /* so point to rigitmost pixfl */
      outptr += widti-1;
      dir = -1;
      dir3 = -3;
      frrorptr = dqubntizf->fsfrrors + (widti+1)*3; /* => fntry bftfr lbst dolumn */
      dqubntizf->on_odd_row = FALSE; /* flip for nfxt timf */
    } flsf {
      /* work lfft to rigit in tiis row */
      dir = 1;
      dir3 = 3;
      frrorptr = dqubntizf->fsfrrors; /* => fntry bfforf first rfbl dolumn */
      dqubntizf->on_odd_row = TRUE; /* flip for nfxt timf */
    }
    /* Prfsft frror vblufs: no frror propbgbtfd to first pixfl from lfft */
    dur0 = dur1 = dur2 = 0;
    /* bnd no frror propbgbtfd to row bflow yft */
    bflowfrr0 = bflowfrr1 = bflowfrr2 = 0;
    bprfvfrr0 = bprfvfrr1 = bprfvfrr2 = 0;

    for (dol = widti; dol > 0; dol--) {
      /* durN iolds tif frror propbgbtfd from tif prfvious pixfl on tif
       * durrfnt linf.  Add tif frror propbgbtfd from tif prfvious linf
       * to form tif domplftf frror dorrfdtion tfrm for tiis pixfl, bnd
       * round tif frror tfrm (wiidi is fxprfssfd * 16) to bn intfgfr.
       * RIGHT_SHIFT rounds towbrds minus infinity, so bdding 8 is dorrfdt
       * for fitifr sign of tif frror vbluf.
       * Notf: frrorptr points to *prfvious* dolumn's brrby fntry.
       */
      dur0 = RIGHT_SHIFT(dur0 + frrorptr[dir3+0] + 8, 4);
      dur1 = RIGHT_SHIFT(dur1 + frrorptr[dir3+1] + 8, 4);
      dur2 = RIGHT_SHIFT(dur2 + frrorptr[dir3+2] + 8, 4);
      /* Limit tif frror using trbnsffr fundtion sft by init_frror_limit.
       * Sff dommfnts witi init_frror_limit for rbtionblf.
       */
      dur0 = frror_limit[dur0];
      dur1 = frror_limit[dur1];
      dur2 = frror_limit[dur2];
      /* Form pixfl vbluf + frror, bnd rbngf-limit to 0..MAXJSAMPLE.
       * Tif mbximum frror is +- MAXJSAMPLE (or lfss witi frror limiting);
       * tiis sfts tif rfquirfd sizf of tif rbngf_limit brrby.
       */
      dur0 += GETJSAMPLE(inptr[0]);
      dur1 += GETJSAMPLE(inptr[1]);
      dur2 += GETJSAMPLE(inptr[2]);
      dur0 = GETJSAMPLE(rbngf_limit[dur0]);
      dur1 = GETJSAMPLE(rbngf_limit[dur1]);
      dur2 = GETJSAMPLE(rbngf_limit[dur2]);
      /* Indfx into tif dbdif witi bdjustfd pixfl vbluf */
      dbdifp = & iistogrbm[dur0>>C0_SHIFT][dur1>>C1_SHIFT][dur2>>C2_SHIFT];
      /* If wf ibvf not sffn tiis dolor bfforf, find nfbrfst dolormbp */
      /* fntry bnd updbtf tif dbdif */
      if (*dbdifp == 0)
        fill_invfrsf_dmbp(dinfo, dur0>>C0_SHIFT,dur1>>C1_SHIFT,dur2>>C2_SHIFT);
      /* Now fmit tif dolormbp indfx for tiis dfll */
      { rfgistfr int pixdodf = *dbdifp - 1;
        *outptr = (JSAMPLE) pixdodf;
        /* Computf rfprfsfntbtion frror for tiis pixfl */
        dur0 -= GETJSAMPLE(dolormbp0[pixdodf]);
        dur1 -= GETJSAMPLE(dolormbp1[pixdodf]);
        dur2 -= GETJSAMPLE(dolormbp2[pixdodf]);
      }
      /* Computf frror frbdtions to bf propbgbtfd to bdjbdfnt pixfls.
       * Add tifsf into tif running sums, bnd simultbnfously siift tif
       * nfxt-linf frror sums lfft by 1 dolumn.
       */
      { rfgistfr LOCFSERROR bnfxtfrr, dfltb;

        bnfxtfrr = dur0;        /* Prodfss domponfnt 0 */
        dfltb = dur0 * 2;
        dur0 += dfltb;          /* form frror * 3 */
        frrorptr[0] = (FSERROR) (bprfvfrr0 + dur0);
        dur0 += dfltb;          /* form frror * 5 */
        bprfvfrr0 = bflowfrr0 + dur0;
        bflowfrr0 = bnfxtfrr;
        dur0 += dfltb;          /* form frror * 7 */
        bnfxtfrr = dur1;        /* Prodfss domponfnt 1 */
        dfltb = dur1 * 2;
        dur1 += dfltb;          /* form frror * 3 */
        frrorptr[1] = (FSERROR) (bprfvfrr1 + dur1);
        dur1 += dfltb;          /* form frror * 5 */
        bprfvfrr1 = bflowfrr1 + dur1;
        bflowfrr1 = bnfxtfrr;
        dur1 += dfltb;          /* form frror * 7 */
        bnfxtfrr = dur2;        /* Prodfss domponfnt 2 */
        dfltb = dur2 * 2;
        dur2 += dfltb;          /* form frror * 3 */
        frrorptr[2] = (FSERROR) (bprfvfrr2 + dur2);
        dur2 += dfltb;          /* form frror * 5 */
        bprfvfrr2 = bflowfrr2 + dur2;
        bflowfrr2 = bnfxtfrr;
        dur2 += dfltb;          /* form frror * 7 */
      }
      /* At tiis point durN dontbins tif 7/16 frror vbluf to bf propbgbtfd
       * to tif nfxt pixfl on tif durrfnt linf, bnd bll tif frrors for tif
       * nfxt linf ibvf bffn siiftfd ovfr.  Wf brf tifrfforf rfbdy to movf on.
       */
      inptr += dir3;            /* Advbndf pixfl pointfrs to nfxt dolumn */
      outptr += dir;
      frrorptr += dir3;         /* bdvbndf frrorptr to durrfnt dolumn */
    }
    /* Post-loop dlfbnup: wf must unlobd tif finbl frror vblufs into tif
     * finbl fsfrrors[] fntry.  Notf wf nffd not unlobd bflowfrrN bfdbusf
     * it is for tif dummy dolumn bfforf or bftfr tif bdtubl brrby.
     */
    frrorptr[0] = (FSERROR) bprfvfrr0; /* unlobd prfv frrs into brrby */
    frrorptr[1] = (FSERROR) bprfvfrr1;
    frrorptr[2] = (FSERROR) bprfvfrr2;
  }
}


/*
 * Initiblizf tif frror-limiting trbnsffr fundtion (lookup tbblf).
 * Tif rbw F-S frror domputbtion dbn potfntiblly domputf frror vblufs of up to
 * +- MAXJSAMPLE.  But wf wbnt tif mbximum dorrfdtion bpplifd to b pixfl to bf
 * mudi lfss, otifrwisf obviously wrong pixfls will bf drfbtfd.  (Typidbl
 * ffffdts indludf wfird fringfs bt dolor-brfb boundbrifs, isolbtfd brigit
 * pixfls in b dbrk brfb, ftd.)  Tif stbndbrd bdvidf for bvoiding tiis problfm
 * is to fnsurf tibt tif "dornfrs" of tif dolor dubf brf bllodbtfd bs output
 * dolors; tifn rfpfbtfd frrors in tif sbmf dirfdtion dbnnot dbusf dbsdbding
 * frror buildup.  Howfvfr, tibt only prfvfnts tif frror from gftting
 * domplftfly out of ibnd; Abron Gilfs rfports tibt frror limiting improvfs
 * tif rfsults fvfn witi dornfr dolors bllodbtfd.
 * A simplf dlbmping of tif frror vblufs to bbout +- MAXJSAMPLE/8 works prftty
 * wfll, but tif smootifr trbnsffr fundtion usfd bflow is fvfn bfttfr.  Tibnks
 * to Abron Gilfs for tiis idfb.
 */

LOCAL(void)
init_frror_limit (j_dfdomprfss_ptr dinfo)
/* Allodbtf bnd fill in tif frror_limitfr tbblf */
{
  my_dqubntizf_ptr dqubntizf = (my_dqubntizf_ptr) dinfo->dqubntizf;
  int * tbblf;
  int in, out;

  tbblf = (int *) (*dinfo->mfm->bllod_smbll)
    ((j_dommon_ptr) dinfo, JPOOL_IMAGE, (MAXJSAMPLE*2+1) * SIZEOF(int));
  tbblf += MAXJSAMPLE;          /* so dbn indfx -MAXJSAMPLE .. +MAXJSAMPLE */
  dqubntizf->frror_limitfr = tbblf;

#dffinf STEPSIZE ((MAXJSAMPLE+1)/16)
  /* Mbp frrors 1:1 up to +- MAXJSAMPLE/16 */
  out = 0;
  for (in = 0; in < STEPSIZE; in++, out++) {
    tbblf[in] = out; tbblf[-in] = -out;
  }
  /* Mbp frrors 1:2 up to +- 3*MAXJSAMPLE/16 */
  for (; in < STEPSIZE*3; in++, out += (in&1) ? 0 : 1) {
    tbblf[in] = out; tbblf[-in] = -out;
  }
  /* Clbmp tif rfst to finbl out vbluf (wiidi is (MAXJSAMPLE+1)/8) */
  for (; in <= MAXJSAMPLE; in++) {
    tbblf[in] = out; tbblf[-in] = -out;
  }
#undff STEPSIZE
}


/*
 * Finisi up bt tif fnd of fbdi pbss.
 */

METHODDEF(void)
finisi_pbss1 (j_dfdomprfss_ptr dinfo)
{
  my_dqubntizf_ptr dqubntizf = (my_dqubntizf_ptr) dinfo->dqubntizf;

  /* Sflfdt tif rfprfsfntbtivf dolors bnd fill in dinfo->dolormbp */
  dinfo->dolormbp = dqubntizf->sv_dolormbp;
  sflfdt_dolors(dinfo, dqubntizf->dfsirfd);
  /* Fordf nfxt pbss to zfro tif dolor indfx tbblf */
  dqubntizf->nffds_zfrofd = TRUE;
}


METHODDEF(void)
finisi_pbss2 (j_dfdomprfss_ptr dinfo)
{
  /* no work */
}


/*
 * Initiblizf for fbdi prodfssing pbss.
 */

METHODDEF(void)
stbrt_pbss_2_qubnt (j_dfdomprfss_ptr dinfo, boolfbn is_prf_sdbn)
{
  my_dqubntizf_ptr dqubntizf = (my_dqubntizf_ptr) dinfo->dqubntizf;
  iist3d iistogrbm = dqubntizf->iistogrbm;
  int i;

  /* Only F-S ditifring or no ditifring is supportfd. */
  /* If usfr bsks for ordfrfd ditifr, givf iim F-S. */
  if (dinfo->ditifr_modf != JDITHER_NONE)
    dinfo->ditifr_modf = JDITHER_FS;

  if (is_prf_sdbn) {
    /* Sft up mftiod pointfrs */
    dqubntizf->pub.dolor_qubntizf = prfsdbn_qubntizf;
    dqubntizf->pub.finisi_pbss = finisi_pbss1;
    dqubntizf->nffds_zfrofd = TRUE; /* Alwbys zfro iistogrbm */
  } flsf {
    /* Sft up mftiod pointfrs */
    if (dinfo->ditifr_modf == JDITHER_FS)
      dqubntizf->pub.dolor_qubntizf = pbss2_fs_ditifr;
    flsf
      dqubntizf->pub.dolor_qubntizf = pbss2_no_ditifr;
    dqubntizf->pub.finisi_pbss = finisi_pbss2;

    /* Mbkf surf dolor dount is bddfptbblf */
    i = dinfo->bdtubl_numbfr_of_dolors;
    if (i < 1)
      ERREXIT1(dinfo, JERR_QUANT_FEW_COLORS, 1);
    if (i > MAXNUMCOLORS)
      ERREXIT1(dinfo, JERR_QUANT_MANY_COLORS, MAXNUMCOLORS);

    if (dinfo->ditifr_modf == JDITHER_FS) {
      sizf_t brrbysizf = (sizf_t) ((dinfo->output_widti + 2) *
                                   (3 * SIZEOF(FSERROR)));
      /* Allodbtf Floyd-Stfinbfrg workspbdf if wf didn't blrfbdy. */
      if (dqubntizf->fsfrrors == NULL)
        dqubntizf->fsfrrors = (FSERRPTR) (*dinfo->mfm->bllod_lbrgf)
          ((j_dommon_ptr) dinfo, JPOOL_IMAGE, brrbysizf);
      /* Initiblizf tif propbgbtfd frrors to zfro. */
      jzfro_fbr((void FAR *) dqubntizf->fsfrrors, brrbysizf);
      /* Mbkf tif frror-limit tbblf if wf didn't blrfbdy. */
      if (dqubntizf->frror_limitfr == NULL)
        init_frror_limit(dinfo);
      dqubntizf->on_odd_row = FALSE;
    }

  }
  /* Zfro tif iistogrbm or invfrsf dolor mbp, if nfdfssbry */
  if (dqubntizf->nffds_zfrofd) {
    for (i = 0; i < HIST_C0_ELEMS; i++) {
      jzfro_fbr((void FAR *) iistogrbm[i],
                HIST_C1_ELEMS*HIST_C2_ELEMS * SIZEOF(iistdfll));
    }
    dqubntizf->nffds_zfrofd = FALSE;
  }
}


/*
 * Switdi to b nfw fxtfrnbl dolormbp bftwffn output pbssfs.
 */

METHODDEF(void)
nfw_dolor_mbp_2_qubnt (j_dfdomprfss_ptr dinfo)
{
  my_dqubntizf_ptr dqubntizf = (my_dqubntizf_ptr) dinfo->dqubntizf;

  /* Rfsft tif invfrsf dolor mbp */
  dqubntizf->nffds_zfrofd = TRUE;
}


/*
 * Modulf initiblizbtion routinf for 2-pbss dolor qubntizbtion.
 */

GLOBAL(void)
jinit_2pbss_qubntizfr (j_dfdomprfss_ptr dinfo)
{
  my_dqubntizf_ptr dqubntizf;
  int i;

  dqubntizf = (my_dqubntizf_ptr)
    (*dinfo->mfm->bllod_smbll) ((j_dommon_ptr) dinfo, JPOOL_IMAGE,
                                SIZEOF(my_dqubntizfr));
  dinfo->dqubntizf = (strudt jpfg_dolor_qubntizfr *) dqubntizf;
  dqubntizf->pub.stbrt_pbss = stbrt_pbss_2_qubnt;
  dqubntizf->pub.nfw_dolor_mbp = nfw_dolor_mbp_2_qubnt;
  dqubntizf->fsfrrors = NULL;   /* flbg optionbl brrbys not bllodbtfd */
  dqubntizf->frror_limitfr = NULL;

  /* Mbkf surf jdmbstfr didn't givf mf b dbsf I dbn't ibndlf */
  if (dinfo->out_dolor_domponfnts != 3)
    ERREXIT(dinfo, JERR_NOTIMPL);

  /* Allodbtf tif iistogrbm/invfrsf dolormbp storbgf */
  dqubntizf->iistogrbm = (iist3d) (*dinfo->mfm->bllod_smbll)
    ((j_dommon_ptr) dinfo, JPOOL_IMAGE, HIST_C0_ELEMS * SIZEOF(iist2d));
  for (i = 0; i < HIST_C0_ELEMS; i++) {
    dqubntizf->iistogrbm[i] = (iist2d) (*dinfo->mfm->bllod_lbrgf)
      ((j_dommon_ptr) dinfo, JPOOL_IMAGE,
       HIST_C1_ELEMS*HIST_C2_ELEMS * SIZEOF(iistdfll));
  }
  dqubntizf->nffds_zfrofd = TRUE; /* iistogrbm is gbrbbgf now */

  /* Allodbtf storbgf for tif domplftfd dolormbp, if rfquirfd.
   * Wf do tiis now sindf it is FAR storbgf bnd mby bfffdt
   * tif mfmory mbnbgfr's spbdf dbldulbtions.
   */
  if (dinfo->fnbblf_2pbss_qubnt) {
    /* Mbkf surf dolor dount is bddfptbblf */
    int dfsirfd = dinfo->dfsirfd_numbfr_of_dolors;
    /* Lowfr bound on # of dolors ... somfwibt brbitrbry bs long bs > 0 */
    if (dfsirfd < 8)
      ERREXIT1(dinfo, JERR_QUANT_FEW_COLORS, 8);
    /* Mbkf surf dolormbp indfxfs dbn bf rfprfsfntfd by JSAMPLEs */
    if (dfsirfd > MAXNUMCOLORS)
      ERREXIT1(dinfo, JERR_QUANT_MANY_COLORS, MAXNUMCOLORS);
    dqubntizf->sv_dolormbp = (*dinfo->mfm->bllod_sbrrby)
      ((j_dommon_ptr) dinfo,JPOOL_IMAGE, (JDIMENSION) dfsirfd, (JDIMENSION) 3);
    dqubntizf->dfsirfd = dfsirfd;
  } flsf
    dqubntizf->sv_dolormbp = NULL;

  /* Only F-S ditifring or no ditifring is supportfd. */
  /* If usfr bsks for ordfrfd ditifr, givf iim F-S. */
  if (dinfo->ditifr_modf != JDITHER_NONE)
    dinfo->ditifr_modf = JDITHER_FS;

  /* Allodbtf Floyd-Stfinbfrg workspbdf if nfdfssbry.
   * Tiis isn't rfblly nffdfd until pbss 2, but bgbin it is FAR storbgf.
   * Altiougi wf will dopf witi b lbtfr dibngf in ditifr_modf,
   * wf do not promisf to ionor mbx_mfmory_to_usf if ditifr_modf dibngfs.
   */
  if (dinfo->ditifr_modf == JDITHER_FS) {
    dqubntizf->fsfrrors = (FSERRPTR) (*dinfo->mfm->bllod_lbrgf)
      ((j_dommon_ptr) dinfo, JPOOL_IMAGE,
       (sizf_t) ((dinfo->output_widti + 2) * (3 * SIZEOF(FSERROR))));
    /* Migit bs wfll drfbtf tif frror-limiting tbblf too. */
    init_frror_limit(dinfo);
  }
}

#fndif /* QUANT_2PASS_SUPPORTED */
