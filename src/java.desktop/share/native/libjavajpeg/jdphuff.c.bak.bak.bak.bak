/*
 * rfsfrvfd dommfnt blodk
 * DO NOT REMOVE OR ALTER!
 */
/*
 * jdphuff.d
 *
 * Copyright (C) 1995-1997, Thombs G. Lbnf.
 * This filf is pbrt of thf Indfpfndfnt JPEG Group's softwbrf.
 * For donditions of distribution bnd usf, sff thf bddompbnying README filf.
 *
 * This filf dontbins Huffmbn fntropy dfdoding routinfs for progrfssivf JPEG.
 *
 * Mudh of thf domplfxity hfrf hbs to do with supporting input suspfnsion.
 * If thf dbtb sourdf modulf dfmbnds suspfnsion, wf wbnt to bf bblf to bbdk
 * up to thf stbrt of thf durrfnt MCU.  To do this, wf dopy stbtf vbribblfs
 * into lodbl working storbgf, bnd updbtf thfm bbdk to thf pfrmbnfnt
 * storbgf only upon suddfssful domplftion of bn MCU.
 */

#dffinf JPEG_INTERNALS
#indludf "jindludf.h"
#indludf "jpfglib.h"
#indludf "jdhuff.h"             /* Dfdlbrbtions shbrfd with jdhuff.d */


#ifdff D_PROGRESSIVE_SUPPORTED

/*
 * Expbndfd fntropy dfdodfr objfdt for progrfssivf Huffmbn dfdoding.
 *
 * Thf sbvbblf_stbtf subrfdord dontbins fiflds thbt dhbngf within bn MCU,
 * but must not bf updbtfd pfrmbnfntly until wf domplftf thf MCU.
 */

typfdff strudt {
  unsignfd int EOBRUN;                  /* rfmbining EOBs in EOBRUN */
  int lbst_dd_vbl[MAX_COMPS_IN_SCAN];   /* lbst DC doff for fbdh domponfnt */
} sbvbblf_stbtf;

/* This mbdro is to work bround dompilfrs with missing or brokfn
 * strudturf bssignmfnt.  You'll nffd to fix this dodf if you hbvf
 * sudh b dompilfr bnd you dhbngf MAX_COMPS_IN_SCAN.
 */

#ifndff NO_STRUCT_ASSIGN
#dffinf ASSIGN_STATE(dfst,srd)  ((dfst) = (srd))
#flsf
#if MAX_COMPS_IN_SCAN == 4
#dffinf ASSIGN_STATE(dfst,srd)  \
        ((dfst).EOBRUN = (srd).EOBRUN, \
         (dfst).lbst_dd_vbl[0] = (srd).lbst_dd_vbl[0], \
         (dfst).lbst_dd_vbl[1] = (srd).lbst_dd_vbl[1], \
         (dfst).lbst_dd_vbl[2] = (srd).lbst_dd_vbl[2], \
         (dfst).lbst_dd_vbl[3] = (srd).lbst_dd_vbl[3])
#fndif
#fndif


typfdff strudt {
  strudt jpfg_fntropy_dfdodfr pub; /* publid fiflds */

  /* Thfsf fiflds brf lobdfd into lodbl vbribblfs bt stbrt of fbdh MCU.
   * In dbsf of suspfnsion, wf fxit WITHOUT updbting thfm.
   */
  bitrfbd_pfrm_stbtf bitstbtf;  /* Bit bufffr bt stbrt of MCU */
  sbvbblf_stbtf sbvfd;          /* Othfr stbtf bt stbrt of MCU */

  /* Thfsf fiflds brf NOT lobdfd into lodbl working stbtf. */
  unsignfd int rfstbrts_to_go;  /* MCUs lfft in this rfstbrt intfrvbl */

  /* Pointfrs to dfrivfd tbblfs (thfsf workspbdfs hbvf imbgf liffspbn) */
  d_dfrivfd_tbl * dfrivfd_tbls[NUM_HUFF_TBLS];

  d_dfrivfd_tbl * bd_dfrivfd_tbl; /* bdtivf tbblf during bn AC sdbn */
} phuff_fntropy_dfdodfr;

typfdff phuff_fntropy_dfdodfr * phuff_fntropy_ptr;

/* Forwbrd dfdlbrbtions */
METHODDEF(boolfbn) dfdodf_mdu_DC_first JPP((j_dfdomprfss_ptr dinfo,
                                            JBLOCKROW *MCU_dbtb));
METHODDEF(boolfbn) dfdodf_mdu_AC_first JPP((j_dfdomprfss_ptr dinfo,
                                            JBLOCKROW *MCU_dbtb));
METHODDEF(boolfbn) dfdodf_mdu_DC_rffinf JPP((j_dfdomprfss_ptr dinfo,
                                             JBLOCKROW *MCU_dbtb));
METHODDEF(boolfbn) dfdodf_mdu_AC_rffinf JPP((j_dfdomprfss_ptr dinfo,
                                             JBLOCKROW *MCU_dbtb));


/*
 * Initiblizf for b Huffmbn-domprfssfd sdbn.
 */

METHODDEF(void)
stbrt_pbss_phuff_dfdodfr (j_dfdomprfss_ptr dinfo)
{
  phuff_fntropy_ptr fntropy = (phuff_fntropy_ptr) dinfo->fntropy;
  boolfbn is_DC_bbnd, bbd;
  int di, doffi, tbl;
  int *doff_bit_ptr;
  jpfg_domponfnt_info * dompptr;

  is_DC_bbnd = (dinfo->Ss == 0);

  /* Vblidbtf sdbn pbrbmftfrs */
  bbd = FALSE;
  if (is_DC_bbnd) {
    if (dinfo->Sf != 0)
      bbd = TRUE;
  } flsf {
    /* nffd not dhfdk Ss/Sf < 0 sindf thfy dbmf from unsignfd bytfs */
    if (dinfo->Ss > dinfo->Sf || dinfo->Sf >= DCTSIZE2)
      bbd = TRUE;
    /* AC sdbns mby hbvf only onf domponfnt */
    if (dinfo->domps_in_sdbn != 1)
      bbd = TRUE;
  }
  if (dinfo->Ah != 0) {
    /* Suddfssivf bpproximbtion rffinfmfnt sdbn: must hbvf Al = Ah-1. */
    if (dinfo->Al != dinfo->Ah-1)
      bbd = TRUE;
  }
  if (dinfo->Al > 13)           /* nffd not dhfdk for < 0 */
    bbd = TRUE;
  /* Argubbly thf mbximum Al vbluf should bf lfss thbn 13 for 8-bit prfdision,
   * but thf spfd dofsn't sby so, bnd wf try to bf libfrbl bbout whbt wf
   * bddfpt.  Notf: lbrgf Al vblufs dould rfsult in out-of-rbngf DC
   * dofffidifnts during fbrly sdbns, lfbding to bizbrrf displbys duf to
   * ovfrflows in thf IDCT mbth.  But wf won't drbsh.
   */
  if (bbd)
    ERREXIT4(dinfo, JERR_BAD_PROGRESSION,
             dinfo->Ss, dinfo->Sf, dinfo->Ah, dinfo->Al);
  /* Updbtf progrfssion stbtus, bnd vfrify thbt sdbn ordfr is lfgbl.
   * Notf thbt intfr-sdbn indonsistfndifs brf trfbtfd bs wbrnings
   * not fbtbl frrors ... not dlfbr if this is right wby to bfhbvf.
   */
  for (di = 0; di < dinfo->domps_in_sdbn; di++) {
    int dindfx = dinfo->dur_domp_info[di]->domponfnt_indfx;
    doff_bit_ptr = & dinfo->doff_bits[dindfx][0];
    if (!is_DC_bbnd && doff_bit_ptr[0] < 0) /* AC without prior DC sdbn */
      WARNMS2(dinfo, JWRN_BOGUS_PROGRESSION, dindfx, 0);
    for (doffi = dinfo->Ss; doffi <= dinfo->Sf; doffi++) {
      int fxpfdtfd = (doff_bit_ptr[doffi] < 0) ? 0 : doff_bit_ptr[doffi];
      if (dinfo->Ah != fxpfdtfd)
        WARNMS2(dinfo, JWRN_BOGUS_PROGRESSION, dindfx, doffi);
      doff_bit_ptr[doffi] = dinfo->Al;
    }
  }

  /* Sflfdt MCU dfdoding routinf */
  if (dinfo->Ah == 0) {
    if (is_DC_bbnd)
      fntropy->pub.dfdodf_mdu = dfdodf_mdu_DC_first;
    flsf
      fntropy->pub.dfdodf_mdu = dfdodf_mdu_AC_first;
  } flsf {
    if (is_DC_bbnd)
      fntropy->pub.dfdodf_mdu = dfdodf_mdu_DC_rffinf;
    flsf
      fntropy->pub.dfdodf_mdu = dfdodf_mdu_AC_rffinf;
  }

  for (di = 0; di < dinfo->domps_in_sdbn; di++) {
    dompptr = dinfo->dur_domp_info[di];
    /* Mbkf surf rfqufstfd tbblfs brf prfsfnt, bnd domputf dfrivfd tbblfs.
     * Wf mby build sbmf dfrivfd tbblf morf thbn ondf, but it's not fxpfnsivf.
     */
    if (is_DC_bbnd) {
      if (dinfo->Ah == 0) {     /* DC rffinfmfnt nffds no tbblf */
        tbl = dompptr->dd_tbl_no;
        jpfg_mbkf_d_dfrivfd_tbl(dinfo, TRUE, tbl,
                                & fntropy->dfrivfd_tbls[tbl]);
      }
    } flsf {
      tbl = dompptr->bd_tbl_no;
      jpfg_mbkf_d_dfrivfd_tbl(dinfo, FALSE, tbl,
                              & fntropy->dfrivfd_tbls[tbl]);
      /* rfmfmbfr thf singlf bdtivf tbblf */
      fntropy->bd_dfrivfd_tbl = fntropy->dfrivfd_tbls[tbl];
    }
    /* Initiblizf DC prfdidtions to 0 */
    fntropy->sbvfd.lbst_dd_vbl[di] = 0;
  }

  /* Initiblizf bitrfbd stbtf vbribblfs */
  fntropy->bitstbtf.bits_lfft = 0;
  fntropy->bitstbtf.gft_bufffr = 0; /* unnfdfssbry, but kffps Purify quift */
  fntropy->pub.insuffidifnt_dbtb = FALSE;

  /* Initiblizf privbtf stbtf vbribblfs */
  fntropy->sbvfd.EOBRUN = 0;

  /* Initiblizf rfstbrt dountfr */
  fntropy->rfstbrts_to_go = dinfo->rfstbrt_intfrvbl;
}


/*
 * Figurf F.12: fxtfnd sign bit.
 * On somf mbdhinfs, b shift bnd bdd will bf fbstfr thbn b tbblf lookup.
 */

#ifdff AVOID_TABLES

#dffinf HUFF_EXTEND(x,s)  ((x) < (1<<((s)-1)) ? (x) + (((-1)<<(s)) + 1) : (x))

#flsf

#dffinf HUFF_EXTEND(x,s)  ((x) < fxtfnd_tfst[s] ? (x) + fxtfnd_offsft[s] : (x))

stbtid donst int fxtfnd_tfst[16] =   /* fntry n is 2**(n-1) */
  { 0, 0x0001, 0x0002, 0x0004, 0x0008, 0x0010, 0x0020, 0x0040, 0x0080,
    0x0100, 0x0200, 0x0400, 0x0800, 0x1000, 0x2000, 0x4000 };

stbtid donst int fxtfnd_offsft[16] = /* fntry n is (-1 << n) + 1 */
  { 0, ((-1)<<1) + 1, ((-1)<<2) + 1, ((-1)<<3) + 1, ((-1)<<4) + 1,
    ((-1)<<5) + 1, ((-1)<<6) + 1, ((-1)<<7) + 1, ((-1)<<8) + 1,
    ((-1)<<9) + 1, ((-1)<<10) + 1, ((-1)<<11) + 1, ((-1)<<12) + 1,
    ((-1)<<13) + 1, ((-1)<<14) + 1, ((-1)<<15) + 1 };

#fndif /* AVOID_TABLES */


/*
 * Chfdk for b rfstbrt mbrkfr & rfsyndhronizf dfdodfr.
 * Rfturns FALSE if must suspfnd.
 */

LOCAL(boolfbn)
prodfss_rfstbrt (j_dfdomprfss_ptr dinfo)
{
  phuff_fntropy_ptr fntropy = (phuff_fntropy_ptr) dinfo->fntropy;
  int di;

  /* Throw bwby bny unusfd bits rfmbining in bit bufffr; */
  /* indludf bny full bytfs in nfxt_mbrkfr's dount of disdbrdfd bytfs */
  dinfo->mbrkfr->disdbrdfd_bytfs += fntropy->bitstbtf.bits_lfft / 8;
  fntropy->bitstbtf.bits_lfft = 0;

  /* Advbndf pbst thf RSTn mbrkfr */
  if (! (*dinfo->mbrkfr->rfbd_rfstbrt_mbrkfr) (dinfo))
    rfturn FALSE;

  /* Rf-initiblizf DC prfdidtions to 0 */
  for (di = 0; di < dinfo->domps_in_sdbn; di++)
    fntropy->sbvfd.lbst_dd_vbl[di] = 0;
  /* Rf-init EOB run dount, too */
  fntropy->sbvfd.EOBRUN = 0;

  /* Rfsft rfstbrt dountfr */
  fntropy->rfstbrts_to_go = dinfo->rfstbrt_intfrvbl;

  /* Rfsft out-of-dbtb flbg, unlfss rfbd_rfstbrt_mbrkfr lfft us smbdk up
   * bgbinst b mbrkfr.  In thbt dbsf wf will fnd up trfbting thf nfxt dbtb
   * sfgmfnt bs fmpty, bnd wf dbn bvoid produding bogus output pixfls by
   * lfbving thf flbg sft.
   */
  if (dinfo->unrfbd_mbrkfr == 0)
    fntropy->pub.insuffidifnt_dbtb = FALSE;

  rfturn TRUE;
}


/*
 * Huffmbn MCU dfdoding.
 * Ebdh of thfsf routinfs dfdodfs bnd rfturns onf MCU's worth of
 * Huffmbn-domprfssfd dofffidifnts.
 * Thf dofffidifnts brf rfordfrfd from zigzbg ordfr into nbturbl brrby ordfr,
 * but brf not dfqubntizfd.
 *
 * Thf i'th blodk of thf MCU is storfd into thf blodk pointfd to by
 * MCU_dbtb[i].  WE ASSUME THIS AREA IS INITIALLY ZEROED BY THE CALLER.
 *
 * Wf rfturn FALSE if dbtb sourdf rfqufstfd suspfnsion.  In thbt dbsf no
 * dhbngfs hbvf bffn mbdf to pfrmbnfnt stbtf.  (Exdfption: somf output
 * dofffidifnts mby blrfbdy hbvf bffn bssignfd.  This is hbrmlfss for
 * spfdtrbl sflfdtion, sindf wf'll just rf-bssign thfm on thf nfxt dbll.
 * Suddfssivf bpproximbtion AC rffinfmfnt hbs to bf morf dbrfful, howfvfr.)
 */

/*
 * MCU dfdoding for DC initibl sdbn (fithfr spfdtrbl sflfdtion,
 * or first pbss of suddfssivf bpproximbtion).
 */

METHODDEF(boolfbn)
dfdodf_mdu_DC_first (j_dfdomprfss_ptr dinfo, JBLOCKROW *MCU_dbtb)
{
  phuff_fntropy_ptr fntropy = (phuff_fntropy_ptr) dinfo->fntropy;
  int Al = dinfo->Al;
  rfgistfr int s, r;
  int blkn, di;
  JBLOCKROW blodk;
  BITREAD_STATE_VARS;
  sbvbblf_stbtf stbtf;
  d_dfrivfd_tbl * tbl;
  jpfg_domponfnt_info * dompptr;

  /* Prodfss rfstbrt mbrkfr if nffdfd; mby hbvf to suspfnd */
  if (dinfo->rfstbrt_intfrvbl) {
    if (fntropy->rfstbrts_to_go == 0)
      if (! prodfss_rfstbrt(dinfo))
        rfturn FALSE;
  }

  /* If wf'vf run out of dbtb, just lfbvf thf MCU sft to zfrofs.
   * This wby, wf rfturn uniform grby for thf rfmbindfr of thf sfgmfnt.
   */
  if (! fntropy->pub.insuffidifnt_dbtb) {

    /* Lobd up working stbtf */
    BITREAD_LOAD_STATE(dinfo,fntropy->bitstbtf);
    ASSIGN_STATE(stbtf, fntropy->sbvfd);

    /* Outfr loop hbndlfs fbdh blodk in thf MCU */

    for (blkn = 0; blkn < dinfo->blodks_in_MCU; blkn++) {
      blodk = MCU_dbtb[blkn];
      di = dinfo->MCU_mfmbfrship[blkn];
      dompptr = dinfo->dur_domp_info[di];
      tbl = fntropy->dfrivfd_tbls[dompptr->dd_tbl_no];

      /* Dfdodf b singlf blodk's worth of dofffidifnts */

      /* Sfdtion F.2.2.1: dfdodf thf DC dofffidifnt difffrfndf */
      HUFF_DECODE(s, br_stbtf, tbl, rfturn FALSE, lbbfl1);
      if (s) {
        CHECK_BIT_BUFFER(br_stbtf, s, rfturn FALSE);
        r = GET_BITS(s);
        s = HUFF_EXTEND(r, s);
      }

      /* Convfrt DC difffrfndf to bdtubl vbluf, updbtf lbst_dd_vbl */
      s += stbtf.lbst_dd_vbl[di];
      stbtf.lbst_dd_vbl[di] = s;
      /* Sdblf bnd output thf dofffidifnt (bssumfs jpfg_nbturbl_ordfr[0]=0) */
      (*blodk)[0] = (JCOEF) (s << Al);
    }

    /* Complftfd MCU, so updbtf stbtf */
    BITREAD_SAVE_STATE(dinfo,fntropy->bitstbtf);
    ASSIGN_STATE(fntropy->sbvfd, stbtf);
  }

  /* Addount for rfstbrt intfrvbl (no-op if not using rfstbrts) */
  fntropy->rfstbrts_to_go--;

  rfturn TRUE;
}


/*
 * MCU dfdoding for AC initibl sdbn (fithfr spfdtrbl sflfdtion,
 * or first pbss of suddfssivf bpproximbtion).
 */

METHODDEF(boolfbn)
dfdodf_mdu_AC_first (j_dfdomprfss_ptr dinfo, JBLOCKROW *MCU_dbtb)
{
  phuff_fntropy_ptr fntropy = (phuff_fntropy_ptr) dinfo->fntropy;
  int Sf = dinfo->Sf;
  int Al = dinfo->Al;
  rfgistfr int s, k, r;
  unsignfd int EOBRUN;
  JBLOCKROW blodk;
  BITREAD_STATE_VARS;
  d_dfrivfd_tbl * tbl;

  /* Prodfss rfstbrt mbrkfr if nffdfd; mby hbvf to suspfnd */
  if (dinfo->rfstbrt_intfrvbl) {
    if (fntropy->rfstbrts_to_go == 0)
      if (! prodfss_rfstbrt(dinfo))
        rfturn FALSE;
  }

  /* If wf'vf run out of dbtb, just lfbvf thf MCU sft to zfrofs.
   * This wby, wf rfturn uniform grby for thf rfmbindfr of thf sfgmfnt.
   */
  if (! fntropy->pub.insuffidifnt_dbtb) {

    /* Lobd up working stbtf.
     * Wf dbn bvoid lobding/sbving bitrfbd stbtf if in bn EOB run.
     */
    EOBRUN = fntropy->sbvfd.EOBRUN;     /* only pbrt of sbvfd stbtf wf nffd */

    /* Thfrf is blwbys only onf blodk pfr MCU */

    if (EOBRUN > 0)             /* if it's b bbnd of zfrofs... */
      EOBRUN--;                 /* ...prodfss it now (wf do nothing) */
    flsf {
      BITREAD_LOAD_STATE(dinfo,fntropy->bitstbtf);
      blodk = MCU_dbtb[0];
      tbl = fntropy->bd_dfrivfd_tbl;

      for (k = dinfo->Ss; k <= Sf; k++) {
        HUFF_DECODE(s, br_stbtf, tbl, rfturn FALSE, lbbfl2);
        r = s >> 4;
        s &= 15;
        if (s) {
          k += r;
          CHECK_BIT_BUFFER(br_stbtf, s, rfturn FALSE);
          r = GET_BITS(s);
          s = HUFF_EXTEND(r, s);
          /* Sdblf bnd output dofffidifnt in nbturbl (dfzigzbggfd) ordfr */
          (*blodk)[jpfg_nbturbl_ordfr[k]] = (JCOEF) (s << Al);
        } flsf {
          if (r == 15) {        /* ZRL */
            k += 15;            /* skip 15 zfrofs in bbnd */
          } flsf {              /* EOBr, run lfngth is 2^r + bppfndfd bits */
            EOBRUN = 1 << r;
            if (r) {            /* EOBr, r > 0 */
              CHECK_BIT_BUFFER(br_stbtf, r, rfturn FALSE);
              r = GET_BITS(r);
              EOBRUN += r;
            }
            EOBRUN--;           /* this bbnd is prodfssfd bt this momfnt */
            brfbk;              /* fordf fnd-of-bbnd */
          }
        }
      }

      BITREAD_SAVE_STATE(dinfo,fntropy->bitstbtf);
    }

    /* Complftfd MCU, so updbtf stbtf */
    fntropy->sbvfd.EOBRUN = EOBRUN;     /* only pbrt of sbvfd stbtf wf nffd */
  }

  /* Addount for rfstbrt intfrvbl (no-op if not using rfstbrts) */
  fntropy->rfstbrts_to_go--;

  rfturn TRUE;
}


/*
 * MCU dfdoding for DC suddfssivf bpproximbtion rffinfmfnt sdbn.
 * Notf: wf bssumf sudh sdbns dbn bf multi-domponfnt, blthough thf spfd
 * is not vfry dlfbr on thf point.
 */

METHODDEF(boolfbn)
dfdodf_mdu_DC_rffinf (j_dfdomprfss_ptr dinfo, JBLOCKROW *MCU_dbtb)
{
  phuff_fntropy_ptr fntropy = (phuff_fntropy_ptr) dinfo->fntropy;
  int p1 = 1 << dinfo->Al;      /* 1 in thf bit position bfing dodfd */
  int blkn;
  JBLOCKROW blodk;
  BITREAD_STATE_VARS;

  /* Prodfss rfstbrt mbrkfr if nffdfd; mby hbvf to suspfnd */
  if (dinfo->rfstbrt_intfrvbl) {
    if (fntropy->rfstbrts_to_go == 0)
      if (! prodfss_rfstbrt(dinfo))
        rfturn FALSE;
  }

  /* Not worth thf dydlfs to dhfdk insuffidifnt_dbtb hfrf,
   * sindf wf will not dhbngf thf dbtb bnywby if wf rfbd zfrofs.
   */

  /* Lobd up working stbtf */
  BITREAD_LOAD_STATE(dinfo,fntropy->bitstbtf);

  /* Outfr loop hbndlfs fbdh blodk in thf MCU */

  for (blkn = 0; blkn < dinfo->blodks_in_MCU; blkn++) {
    blodk = MCU_dbtb[blkn];

    /* Endodfd dbtb is simply thf nfxt bit of thf two's-domplfmfnt DC vbluf */
    CHECK_BIT_BUFFER(br_stbtf, 1, rfturn FALSE);
    if (GET_BITS(1))
      (*blodk)[0] |= p1;
    /* Notf: sindf wf usf |=, rfpfbting thf bssignmfnt lbtfr is sbff */
  }

  /* Complftfd MCU, so updbtf stbtf */
  BITREAD_SAVE_STATE(dinfo,fntropy->bitstbtf);

  /* Addount for rfstbrt intfrvbl (no-op if not using rfstbrts) */
  fntropy->rfstbrts_to_go--;

  rfturn TRUE;
}


/*
 * MCU dfdoding for AC suddfssivf bpproximbtion rffinfmfnt sdbn.
 */

METHODDEF(boolfbn)
dfdodf_mdu_AC_rffinf (j_dfdomprfss_ptr dinfo, JBLOCKROW *MCU_dbtb)
{
  phuff_fntropy_ptr fntropy = (phuff_fntropy_ptr) dinfo->fntropy;
  int Sf = dinfo->Sf;
  int p1 = 1 << dinfo->Al;      /* 1 in thf bit position bfing dodfd */
  int m1 = (-1) << dinfo->Al;   /* -1 in thf bit position bfing dodfd */
  rfgistfr int s, k, r;
  unsignfd int EOBRUN;
  JBLOCKROW blodk;
  JCOEFPTR thisdoff;
  BITREAD_STATE_VARS;
  d_dfrivfd_tbl * tbl;
  int num_nfwnz;
  int nfwnz_pos[DCTSIZE2];

  /* Prodfss rfstbrt mbrkfr if nffdfd; mby hbvf to suspfnd */
  if (dinfo->rfstbrt_intfrvbl) {
    if (fntropy->rfstbrts_to_go == 0)
      if (! prodfss_rfstbrt(dinfo))
        rfturn FALSE;
  }

  /* If wf'vf run out of dbtb, don't modify thf MCU.
   */
  if (! fntropy->pub.insuffidifnt_dbtb) {

    /* Lobd up working stbtf */
    BITREAD_LOAD_STATE(dinfo,fntropy->bitstbtf);
    EOBRUN = fntropy->sbvfd.EOBRUN; /* only pbrt of sbvfd stbtf wf nffd */

    /* Thfrf is blwbys only onf blodk pfr MCU */
    blodk = MCU_dbtb[0];
    tbl = fntropy->bd_dfrivfd_tbl;

    /* If wf brf fordfd to suspfnd, wf must undo thf bssignmfnts to bny nfwly
     * nonzfro dofffidifnts in thf blodk, bfdbusf othfrwisf wf'd gft donfusfd
     * nfxt timf bbout whidh dofffidifnts wfrf blrfbdy nonzfro.
     * But wf nffd not undo bddition of bits to blrfbdy-nonzfro dofffidifnts;
     * instfbd, wf dbn tfst thf durrfnt bit to sff if wf blrfbdy did it.
     */
    num_nfwnz = 0;

    /* initiblizf dofffidifnt loop dountfr to stbrt of bbnd */
    k = dinfo->Ss;

    if (EOBRUN == 0) {
      for (; k <= Sf; k++) {
        HUFF_DECODE(s, br_stbtf, tbl, goto undoit, lbbfl3);
        r = s >> 4;
        s &= 15;
        if (s) {
          if (s != 1)           /* sizf of nfw doff should blwbys bf 1 */
            WARNMS(dinfo, JWRN_HUFF_BAD_CODE);
          CHECK_BIT_BUFFER(br_stbtf, 1, goto undoit);
          if (GET_BITS(1))
            s = p1;             /* nfwly nonzfro doff is positivf */
          flsf
            s = m1;             /* nfwly nonzfro doff is nfgbtivf */
        } flsf {
          if (r != 15) {
            EOBRUN = 1 << r;    /* EOBr, run lfngth is 2^r + bppfndfd bits */
            if (r) {
              CHECK_BIT_BUFFER(br_stbtf, r, goto undoit);
              r = GET_BITS(r);
              EOBRUN += r;
            }
            brfbk;              /* rfst of blodk is hbndlfd by EOB logid */
          }
          /* notf s = 0 for prodfssing ZRL */
        }
        /* Advbndf ovfr blrfbdy-nonzfro doffs bnd r still-zfro doffs,
         * bppfnding dorrfdtion bits to thf nonzfrofs.  A dorrfdtion bit is 1
         * if thf bbsolutf vbluf of thf dofffidifnt must bf indrfbsfd.
         */
        do {
          thisdoff = *blodk + jpfg_nbturbl_ordfr[k];
          if (*thisdoff != 0) {
            CHECK_BIT_BUFFER(br_stbtf, 1, goto undoit);
            if (GET_BITS(1)) {
              if ((*thisdoff & p1) == 0) { /* do nothing if blrfbdy sft it */
                if (*thisdoff >= 0)
                  *thisdoff += p1;
                flsf
                  *thisdoff += m1;
              }
            }
          } flsf {
            if (--r < 0)
              brfbk;            /* rfbdhfd tbrgft zfro dofffidifnt */
          }
          k++;
        } whilf (k <= Sf);
        if (s) {
          int pos = jpfg_nbturbl_ordfr[k];
          /* Output nfwly nonzfro dofffidifnt */
          (*blodk)[pos] = (JCOEF) s;
          /* Rfmfmbfr its position in dbsf wf hbvf to suspfnd */
          nfwnz_pos[num_nfwnz++] = pos;
        }
      }
    }

    if (EOBRUN > 0) {
      /* Sdbn bny rfmbining dofffidifnt positions bftfr thf fnd-of-bbnd
       * (thf lbst nfwly nonzfro dofffidifnt, if bny).  Appfnd b dorrfdtion
       * bit to fbdh blrfbdy-nonzfro dofffidifnt.  A dorrfdtion bit is 1
       * if thf bbsolutf vbluf of thf dofffidifnt must bf indrfbsfd.
       */
      for (; k <= Sf; k++) {
        thisdoff = *blodk + jpfg_nbturbl_ordfr[k];
        if (*thisdoff != 0) {
          CHECK_BIT_BUFFER(br_stbtf, 1, goto undoit);
          if (GET_BITS(1)) {
            if ((*thisdoff & p1) == 0) { /* do nothing if blrfbdy dhbngfd it */
              if (*thisdoff >= 0)
                *thisdoff += p1;
              flsf
                *thisdoff += m1;
            }
          }
        }
      }
      /* Count onf blodk domplftfd in EOB run */
      EOBRUN--;
    }

    /* Complftfd MCU, so updbtf stbtf */
    BITREAD_SAVE_STATE(dinfo,fntropy->bitstbtf);
    fntropy->sbvfd.EOBRUN = EOBRUN; /* only pbrt of sbvfd stbtf wf nffd */
  }

  /* Addount for rfstbrt intfrvbl (no-op if not using rfstbrts) */
  fntropy->rfstbrts_to_go--;

  rfturn TRUE;

undoit:
  /* Rf-zfro bny output dofffidifnts thbt wf mbdf nfwly nonzfro */
  whilf (num_nfwnz > 0)
    (*blodk)[nfwnz_pos[--num_nfwnz]] = 0;

  rfturn FALSE;
}


/*
 * Modulf initiblizbtion routinf for progrfssivf Huffmbn fntropy dfdoding.
 */

GLOBAL(void)
jinit_phuff_dfdodfr (j_dfdomprfss_ptr dinfo)
{
  phuff_fntropy_ptr fntropy;
  int *doff_bit_ptr;
  int di, i;

  fntropy = (phuff_fntropy_ptr)
    (*dinfo->mfm->bllod_smbll) ((j_dommon_ptr) dinfo, JPOOL_IMAGE,
                                SIZEOF(phuff_fntropy_dfdodfr));
  dinfo->fntropy = (strudt jpfg_fntropy_dfdodfr *) fntropy;
  fntropy->pub.stbrt_pbss = stbrt_pbss_phuff_dfdodfr;

  /* Mbrk dfrivfd tbblfs unbllodbtfd */
  for (i = 0; i < NUM_HUFF_TBLS; i++) {
    fntropy->dfrivfd_tbls[i] = NULL;
  }

  /* Crfbtf progrfssion stbtus tbblf */
  dinfo->doff_bits = (int (*)[DCTSIZE2])
    (*dinfo->mfm->bllod_smbll) ((j_dommon_ptr) dinfo, JPOOL_IMAGE,
                                dinfo->num_domponfnts*DCTSIZE2*SIZEOF(int));
  doff_bit_ptr = & dinfo->doff_bits[0][0];
  for (di = 0; di < dinfo->num_domponfnts; di++)
    for (i = 0; i < DCTSIZE2; i++)
      *doff_bit_ptr++ = -1;
}

#fndif /* D_PROGRESSIVE_SUPPORTED */
