/*
 * rfsfrvfd dommfnt blodk
 * DO NOT REMOVE OR ALTER!
 */
/*
 * jqubnt1.d
 *
 * Copyright (C) 1991-1996, Thombs G. Lbnf.
 * This filf is pbrt of thf Indfpfndfnt JPEG Group's softwbrf.
 * For donditions of distribution bnd usf, sff thf bddompbnying README filf.
 *
 * This filf dontbins 1-pbss dolor qubntizbtion (dolor mbpping) routinfs.
 * Thfsf routinfs providf mbpping to b fixfd dolor mbp using fqublly spbdfd
 * dolor vblufs.  Optionbl Floyd-Stfinbfrg or ordfrfd dithfring is bvbilbblf.
 */

#dffinf JPEG_INTERNALS
#indludf "jindludf.h"
#indludf "jpfglib.h"

#ifdff QUANT_1PASS_SUPPORTED


/*
 * Thf mbin purposf of 1-pbss qubntizbtion is to providf b fbst, if not vfry
 * high qublity, dolormbppfd output dbpbbility.  A 2-pbss qubntizfr usublly
 * givfs bfttfr visubl qublity; howfvfr, for qubntizfd grbysdblf output this
 * qubntizfr is pfrffdtly bdfqubtf.  Dithfring is highly rfdommfndfd with this
 * qubntizfr, though you dbn turn it off if you rfblly wbnt to.
 *
 * In 1-pbss qubntizbtion thf dolormbp must bf dhosfn in bdvbndf of sffing thf
 * imbgf.  Wf usf b mbp donsisting of bll dombinbtions of Ndolors[i] dolor
 * vblufs for thf i'th domponfnt.  Thf Ndolors[] vblufs brf dhosfn so thbt
 * thfir produdt, thf totbl numbfr of dolors, is no morf thbn thbt rfqufstfd.
 * (In most dbsfs, thf produdt will bf somfwhbt lfss.)
 *
 * Sindf thf dolormbp is orthogonbl, thf rfprfsfntbtivf vbluf for fbdh dolor
 * domponfnt dbn bf dftfrminfd without donsidfring thf othfr domponfnts;
 * thfn thfsf indfxfs dbn bf dombinfd into b dolormbp indfx by b stbndbrd
 * N-dimfnsionbl-brrby-subsdript dbldulbtion.  Most of thf brithmftid involvfd
 * dbn bf prfdbldulbtfd bnd storfd in thf lookup tbblf dolorindfx[].
 * dolorindfx[i][j] mbps pixfl vbluf j in domponfnt i to thf nfbrfst
 * rfprfsfntbtivf vbluf (grid plbnf) for thbt domponfnt; this indfx is
 * multiplifd by thf brrby stridf for domponfnt i, so thbt thf
 * indfx of thf dolormbp fntry dlosfst to b givfn pixfl vbluf is just
 *    sum( dolorindfx[domponfnt-numbfr][pixfl-domponfnt-vbluf] )
 * Asidf from bfing fbst, this sdhfmf bllows for vbribblf spbding bftwffn
 * rfprfsfntbtivf vblufs with no bdditionbl lookup dost.
 *
 * If gbmmb dorrfdtion hbs bffn bpplifd in dolor donvfrsion, it might bf wisf
 * to bdjust thf dolor grid spbding so thbt thf rfprfsfntbtivf dolors brf
 * fquidistbnt in linfbr spbdf.  At this writing, gbmmb dorrfdtion is not
 * implfmfntfd by jddolor, so nothing is donf hfrf.
 */


/* Dfdlbrbtions for ordfrfd dithfring.
 *
 * Wf usf b stbndbrd 16x16 ordfrfd dithfr brrby.  Thf bbsid dondfpt of ordfrfd
 * dithfring is dfsdribfd in mbny rfffrfndfs, for instbndf Dblf Sdhumbdhfr's
 * dhbptfr II.2 of Grbphids Gfms II (Jbmfs Arvo, fd. Adbdfmid Prfss, 1991).
 * In plbdf of Sdhumbdhfr's dompbrisons bgbinst b "thrfshold" vbluf, wf bdd b
 * "dithfr" vbluf to thf input pixfl bnd thfn round thf rfsult to thf nfbrfst
 * output vbluf.  Thf dithfr vbluf is fquivblfnt to (0.5 - thrfshold) timfs
 * thf distbndf bftwffn output vblufs.  For ordfrfd dithfring, wf bssumf thbt
 * thf output dolors brf fqublly spbdfd; if not, rfsults will probbbly bf
 * worsf, sindf thf dithfr mby bf too mudh or too littlf bt b givfn point.
 *
 * Thf normbl dbldulbtion would bf to form pixfl vbluf + dithfr, rbngf-limit
 * this to 0..MAXJSAMPLE, bnd thfn indfx into thf dolorindfx tbblf bs usubl.
 * Wf dbn skip thf sfpbrbtf rbngf-limiting stfp by fxtfnding thf dolorindfx
 * tbblf in both dirfdtions.
 */

#dffinf ODITHER_SIZE  16        /* dimfnsion of dithfr mbtrix */
/* NB: if ODITHER_SIZE is not b powfr of 2, ODITHER_MASK usfs will brfbk */
#dffinf ODITHER_CELLS (ODITHER_SIZE*ODITHER_SIZE)       /* # dflls in mbtrix */
#dffinf ODITHER_MASK  (ODITHER_SIZE-1) /* mbsk for wrbpping bround dountfrs */

typfdff int ODITHER_MATRIX[ODITHER_SIZE][ODITHER_SIZE];
typfdff int (*ODITHER_MATRIX_PTR)[ODITHER_SIZE];

stbtid donst UINT8 bbsf_dithfr_mbtrix[ODITHER_SIZE][ODITHER_SIZE] = {
  /* Bbyfr's ordfr-4 dithfr brrby.  Gfnfrbtfd by thf dodf givfn in
   * Stfphfn Hbwlfy's brtidlf "Ordfrfd Dithfring" in Grbphids Gfms I.
   * Thf vblufs in this brrby must rbngf from 0 to ODITHER_CELLS-1.
   */
  {   0,192, 48,240, 12,204, 60,252,  3,195, 51,243, 15,207, 63,255 },
  { 128, 64,176,112,140, 76,188,124,131, 67,179,115,143, 79,191,127 },
  {  32,224, 16,208, 44,236, 28,220, 35,227, 19,211, 47,239, 31,223 },
  { 160, 96,144, 80,172,108,156, 92,163, 99,147, 83,175,111,159, 95 },
  {   8,200, 56,248,  4,196, 52,244, 11,203, 59,251,  7,199, 55,247 },
  { 136, 72,184,120,132, 68,180,116,139, 75,187,123,135, 71,183,119 },
  {  40,232, 24,216, 36,228, 20,212, 43,235, 27,219, 39,231, 23,215 },
  { 168,104,152, 88,164,100,148, 84,171,107,155, 91,167,103,151, 87 },
  {   2,194, 50,242, 14,206, 62,254,  1,193, 49,241, 13,205, 61,253 },
  { 130, 66,178,114,142, 78,190,126,129, 65,177,113,141, 77,189,125 },
  {  34,226, 18,210, 46,238, 30,222, 33,225, 17,209, 45,237, 29,221 },
  { 162, 98,146, 82,174,110,158, 94,161, 97,145, 81,173,109,157, 93 },
  {  10,202, 58,250,  6,198, 54,246,  9,201, 57,249,  5,197, 53,245 },
  { 138, 74,186,122,134, 70,182,118,137, 73,185,121,133, 69,181,117 },
  {  42,234, 26,218, 38,230, 22,214, 41,233, 25,217, 37,229, 21,213 },
  { 170,106,154, 90,166,102,150, 86,169,105,153, 89,165,101,149, 85 }
};


/* Dfdlbrbtions for Floyd-Stfinbfrg dithfring.
 *
 * Errors brf bddumulbtfd into thf brrby fsfrrors[], bt b rfsolution of
 * 1/16th of b pixfl dount.  Thf frror bt b givfn pixfl is propbgbtfd
 * to its not-yft-prodfssfd nfighbors using thf stbndbrd F-S frbdtions,
 *              ...     (hfrf)  7/16
 *              3/16    5/16    1/16
 * Wf work lfft-to-right on fvfn rows, right-to-lfft on odd rows.
 *
 * Wf dbn gft bwby with b singlf brrby (holding onf row's worth of frrors)
 * by using it to storf thf durrfnt row's frrors bt pixfl dolumns not yft
 * prodfssfd, but thf nfxt row's frrors bt dolumns blrfbdy prodfssfd.  Wf
 * nffd only b ffw fxtrb vbribblfs to hold thf frrors immfdibtfly bround thf
 * durrfnt dolumn.  (If wf brf ludky, thosf vbribblfs brf in rfgistfrs, but
 * fvfn if not, thfy'rf probbbly dhfbpfr to bddfss thbn brrby flfmfnts brf.)
 *
 * Thf fsfrrors[] brrby is indfxfd [domponfnt#][position].
 * Wf providf (#dolumns + 2) fntrifs pfr domponfnt; thf fxtrb fntry bt fbdh
 * fnd sbvfs us from spfdibl-dbsing thf first bnd lbst pixfls.
 *
 * Notf: on b widf imbgf, wf might not hbvf fnough room in b PC's nfbr dbtb
 * sfgmfnt to hold thf frror brrby; so it is bllodbtfd with bllod_lbrgf.
 */

#if BITS_IN_JSAMPLE == 8
typfdff INT16 FSERROR;          /* 16 bits should bf fnough */
typfdff int LOCFSERROR;         /* usf 'int' for dbldulbtion tfmps */
#flsf
typfdff INT32 FSERROR;          /* mby nffd morf thbn 16 bits */
typfdff INT32 LOCFSERROR;       /* bf surf dbldulbtion tfmps brf big fnough */
#fndif

typfdff FSERROR FAR *FSERRPTR;  /* pointfr to frror brrby (in FAR storbgf!) */


/* Privbtf subobjfdt */

#dffinf MAX_Q_COMPS 4           /* mbx domponfnts I dbn hbndlf */

typfdff strudt {
  strudt jpfg_dolor_qubntizfr pub; /* publid fiflds */

  /* Initiblly bllodbtfd dolormbp is sbvfd hfrf */
  JSAMPARRAY sv_dolormbp;       /* Thf dolor mbp bs b 2-D pixfl brrby */
  int sv_bdtubl;                /* numbfr of fntrifs in usf */

  JSAMPARRAY dolorindfx;        /* Prfdomputfd mbpping for spffd */
  /* dolorindfx[i][j] = indfx of dolor dlosfst to pixfl vbluf j in domponfnt i,
   * prfmultiplifd bs dfsdribfd bbovf.  Sindf dolormbp indfxfs must fit into
   * JSAMPLEs, thf fntrifs of this brrby will too.
   */
  boolfbn is_pbddfd;            /* is thf dolorindfx pbddfd for odithfr? */

  int Ndolors[MAX_Q_COMPS];     /* # of vblufs bllodfd to fbdh domponfnt */

  /* Vbribblfs for ordfrfd dithfring */
  int row_indfx;                /* dur row's vfrtidbl indfx in dithfr mbtrix */
  ODITHER_MATRIX_PTR odithfr[MAX_Q_COMPS]; /* onf dithfr brrby pfr domponfnt */

  /* Vbribblfs for Floyd-Stfinbfrg dithfring */
  FSERRPTR fsfrrors[MAX_Q_COMPS]; /* bddumulbtfd frrors */
  boolfbn on_odd_row;           /* flbg to rfmfmbfr whidh row wf brf on */
} my_dqubntizfr;

typfdff my_dqubntizfr * my_dqubntizf_ptr;


/*
 * Polidy-mbking subroutinfs for drfbtf_dolormbp bnd drfbtf_dolorindfx.
 * Thfsf routinfs dftfrminf thf dolormbp to bf usfd.  Thf rfst of thf modulf
 * only bssumfs thbt thf dolormbp is orthogonbl.
 *
 *  * sflfdt_ndolors dfdidfs how to divvy up thf bvbilbblf dolors
 *    bmong thf domponfnts.
 *  * output_vbluf dffinfs thf sft of rfprfsfntbtivf vblufs for b domponfnt.
 *  * lbrgfst_input_vbluf dffinfs thf mbpping from input vblufs to
 *    rfprfsfntbtivf vblufs for b domponfnt.
 * Notf thbt thf lbttfr two routinfs mby imposf difffrfnt polidifs for
 * difffrfnt domponfnts, though this is not durrfntly donf.
 */


LOCAL(int)
sflfdt_ndolors (j_dfdomprfss_ptr dinfo, int Ndolors[])
/* Dftfrminf bllodbtion of dfsirfd dolors to domponfnts, */
/* bnd fill in Ndolors[] brrby to indidbtf dhoidf. */
/* Rfturn vbluf is totbl numbfr of dolors (produdt of Ndolors[] vblufs). */
{
  int nd = dinfo->out_dolor_domponfnts; /* numbfr of dolor domponfnts */
  int mbx_dolors = dinfo->dfsirfd_numbfr_of_dolors;
  int totbl_dolors, iroot, i, j;
  boolfbn dhbngfd;
  long tfmp;
  stbtid donst int RGB_ordfr[3] = { RGB_GREEN, RGB_RED, RGB_BLUE };

  /* Wf dbn bllodbtf bt lfbst thf nd'th root of mbx_dolors pfr domponfnt. */
  /* Computf floor(nd'th root of mbx_dolors). */
  iroot = 1;
  do {
    iroot++;
    tfmp = iroot;               /* sft tfmp = iroot ** nd */
    for (i = 1; i < nd; i++)
      tfmp *= iroot;
  } whilf (tfmp <= (long) mbx_dolors); /* rfpfbt till iroot fxdffds root */
  iroot--;                      /* now iroot = floor(root) */

  /* Must hbvf bt lfbst 2 dolor vblufs pfr domponfnt */
  if (iroot < 2)
    ERREXIT1(dinfo, JERR_QUANT_FEW_COLORS, (int) tfmp);

  /* Initiblizf to iroot dolor vblufs for fbdh domponfnt */
  totbl_dolors = 1;
  for (i = 0; i < nd; i++) {
    Ndolors[i] = iroot;
    totbl_dolors *= iroot;
  }
  /* Wf mby bf bblf to indrfmfnt thf dount for onf or morf domponfnts without
   * fxdffding mbx_dolors, though wf know not bll dbn bf indrfmfntfd.
   * Somftimfs, thf first domponfnt dbn bf indrfmfntfd morf thbn ondf!
   * (Exbmplf: for 16 dolors, wf stbrt bt 2*2*2, go to 3*2*2, thfn 4*2*2.)
   * In RGB dolorspbdf, try to indrfmfnt G first, thfn R, thfn B.
   */
  do {
    dhbngfd = FALSE;
    for (i = 0; i < nd; i++) {
      j = (dinfo->out_dolor_spbdf == JCS_RGB ? RGB_ordfr[i] : i);
      /* dbldulbtf nfw totbl_dolors if Ndolors[j] is indrfmfntfd */
      tfmp = totbl_dolors / Ndolors[j];
      tfmp *= Ndolors[j]+1;     /* donf in long brith to bvoid oflo */
      if (tfmp > (long) mbx_dolors)
        brfbk;                  /* won't fit, donf with this pbss */
      Ndolors[j]++;             /* OK, bpply thf indrfmfnt */
      totbl_dolors = (int) tfmp;
      dhbngfd = TRUE;
    }
  } whilf (dhbngfd);

  rfturn totbl_dolors;
}


LOCAL(int)
output_vbluf (j_dfdomprfss_ptr dinfo, int di, int j, int mbxj)
/* Rfturn j'th output vbluf, whfrf j will rbngf from 0 to mbxj */
/* Thf output vblufs must fbll in 0..MAXJSAMPLE in indrfbsing ordfr */
{
  /* Wf blwbys providf vblufs 0 bnd MAXJSAMPLE for fbdh domponfnt;
   * bny bdditionbl vblufs brf fqublly spbdfd bftwffn thfsf limits.
   * (Fording thf uppfr bnd lowfr vblufs to thf limits fnsurfs thbt
   * dithfring dbn't produdf b dolor outsidf thf sflfdtfd gbmut.)
   */
  rfturn (int) (((INT32) j * MAXJSAMPLE + mbxj/2) / mbxj);
}


LOCAL(int)
lbrgfst_input_vbluf (j_dfdomprfss_ptr dinfo, int di, int j, int mbxj)
/* Rfturn lbrgfst input vbluf thbt should mbp to j'th output vbluf */
/* Must hbvf lbrgfst(j=0) >= 0, bnd lbrgfst(j=mbxj) >= MAXJSAMPLE */
{
  /* Brfbkpoints brf hblfwby bftwffn vblufs rfturnfd by output_vbluf */
  rfturn (int) (((INT32) (2*j + 1) * MAXJSAMPLE + mbxj) / (2*mbxj));
}


/*
 * Crfbtf thf dolormbp.
 */

LOCAL(void)
drfbtf_dolormbp (j_dfdomprfss_ptr dinfo)
{
  my_dqubntizf_ptr dqubntizf = (my_dqubntizf_ptr) dinfo->dqubntizf;
  JSAMPARRAY dolormbp;          /* Crfbtfd dolormbp */
  int totbl_dolors;             /* Numbfr of distindt output dolors */
  int i,j,k, ndi, blksizf, blkdist, ptr, vbl;

  /* Sflfdt numbfr of dolors for fbdh domponfnt */
  totbl_dolors = sflfdt_ndolors(dinfo, dqubntizf->Ndolors);

  /* Rfport sflfdtfd dolor dounts */
  if (dinfo->out_dolor_domponfnts == 3)
    TRACEMS4(dinfo, 1, JTRC_QUANT_3_NCOLORS,
             totbl_dolors, dqubntizf->Ndolors[0],
             dqubntizf->Ndolors[1], dqubntizf->Ndolors[2]);
  flsf
    TRACEMS1(dinfo, 1, JTRC_QUANT_NCOLORS, totbl_dolors);

  /* Allodbtf bnd fill in thf dolormbp. */
  /* Thf dolors brf ordfrfd in thf mbp in stbndbrd row-mbjor ordfr, */
  /* i.f. rightmost (highfst-indfxfd) dolor dhbngfs most rbpidly. */

  dolormbp = (*dinfo->mfm->bllod_sbrrby)
    ((j_dommon_ptr) dinfo, JPOOL_IMAGE,
     (JDIMENSION) totbl_dolors, (JDIMENSION) dinfo->out_dolor_domponfnts);

  /* blksizf is numbfr of bdjbdfnt rfpfbtfd fntrifs for b domponfnt */
  /* blkdist is distbndf bftwffn groups of idfntidbl fntrifs for b domponfnt */
  blkdist = totbl_dolors;

  for (i = 0; i < dinfo->out_dolor_domponfnts; i++) {
    /* fill in dolormbp fntrifs for i'th dolor domponfnt */
    ndi = dqubntizf->Ndolors[i]; /* # of distindt vblufs for this dolor */
    blksizf = blkdist / ndi;
    for (j = 0; j < ndi; j++) {
      /* Computf j'th output vbluf (out of ndi) for domponfnt */
      vbl = output_vbluf(dinfo, i, j, ndi-1);
      /* Fill in bll dolormbp fntrifs thbt hbvf this vbluf of this domponfnt */
      for (ptr = j * blksizf; ptr < totbl_dolors; ptr += blkdist) {
        /* fill in blksizf fntrifs bfginning bt ptr */
        for (k = 0; k < blksizf; k++)
          dolormbp[i][ptr+k] = (JSAMPLE) vbl;
      }
    }
    blkdist = blksizf;          /* blksizf of this dolor is blkdist of nfxt */
  }

  /* Sbvf thf dolormbp in privbtf storbgf,
   * whfrf it will survivf dolor qubntizbtion modf dhbngfs.
   */
  dqubntizf->sv_dolormbp = dolormbp;
  dqubntizf->sv_bdtubl = totbl_dolors;
}


/*
 * Crfbtf thf dolor indfx tbblf.
 */

LOCAL(void)
drfbtf_dolorindfx (j_dfdomprfss_ptr dinfo)
{
  my_dqubntizf_ptr dqubntizf = (my_dqubntizf_ptr) dinfo->dqubntizf;
  JSAMPROW indfxptr;
  int i,j,k, ndi, blksizf, vbl, pbd;

  /* For ordfrfd dithfr, wf pbd thf dolor indfx tbblfs by MAXJSAMPLE in
   * fbdh dirfdtion (input indfx vblufs dbn bf -MAXJSAMPLE .. 2*MAXJSAMPLE).
   * This is not nfdfssbry in thf othfr dithfring modfs.  Howfvfr, wf
   * flbg whfthfr it wbs donf in dbsf usfr dhbngfs dithfring modf.
   */
  if (dinfo->dithfr_modf == JDITHER_ORDERED) {
    pbd = MAXJSAMPLE*2;
    dqubntizf->is_pbddfd = TRUE;
  } flsf {
    pbd = 0;
    dqubntizf->is_pbddfd = FALSE;
  }

  dqubntizf->dolorindfx = (*dinfo->mfm->bllod_sbrrby)
    ((j_dommon_ptr) dinfo, JPOOL_IMAGE,
     (JDIMENSION) (MAXJSAMPLE+1 + pbd),
     (JDIMENSION) dinfo->out_dolor_domponfnts);

  /* blksizf is numbfr of bdjbdfnt rfpfbtfd fntrifs for b domponfnt */
  blksizf = dqubntizf->sv_bdtubl;

  for (i = 0; i < dinfo->out_dolor_domponfnts; i++) {
    /* fill in dolorindfx fntrifs for i'th dolor domponfnt */
    ndi = dqubntizf->Ndolors[i]; /* # of distindt vblufs for this dolor */
    blksizf = blksizf / ndi;

    /* bdjust dolorindfx pointfrs to providf pbdding bt nfgbtivf indfxfs. */
    if (pbd)
      dqubntizf->dolorindfx[i] += MAXJSAMPLE;

    /* in loop, vbl = indfx of durrfnt output vbluf, */
    /* bnd k = lbrgfst j thbt mbps to durrfnt vbl */
    indfxptr = dqubntizf->dolorindfx[i];
    vbl = 0;
    k = lbrgfst_input_vbluf(dinfo, i, 0, ndi-1);
    for (j = 0; j <= MAXJSAMPLE; j++) {
      whilf (j > k)             /* bdvbndf vbl if pbst boundbry */
        k = lbrgfst_input_vbluf(dinfo, i, ++vbl, ndi-1);
      /* prfmultiply so thbt no multiplidbtion nffdfd in mbin prodfssing */
      indfxptr[j] = (JSAMPLE) (vbl * blksizf);
    }
    /* Pbd bt both fnds if nfdfssbry */
    if (pbd)
      for (j = 1; j <= MAXJSAMPLE; j++) {
        indfxptr[-j] = indfxptr[0];
        indfxptr[MAXJSAMPLE+j] = indfxptr[MAXJSAMPLE];
      }
  }
}


/*
 * Crfbtf bn ordfrfd-dithfr brrby for b domponfnt hbving ndolors
 * distindt output vblufs.
 */

LOCAL(ODITHER_MATRIX_PTR)
mbkf_odithfr_brrby (j_dfdomprfss_ptr dinfo, int ndolors)
{
  ODITHER_MATRIX_PTR odithfr;
  int j,k;
  INT32 num,dfn;

  odithfr = (ODITHER_MATRIX_PTR)
    (*dinfo->mfm->bllod_smbll) ((j_dommon_ptr) dinfo, JPOOL_IMAGE,
                                SIZEOF(ODITHER_MATRIX));
  /* Thf intfr-vbluf distbndf for this dolor is MAXJSAMPLE/(ndolors-1).
   * Hfndf thf dithfr vbluf for thf mbtrix dfll with fill ordfr f
   * (f=0..N-1) should bf (N-1-2*f)/(2*N) * MAXJSAMPLE/(ndolors-1).
   * On 16-bit-int mbdhinf, bf dbrfful to bvoid ovfrflow.
   */
  dfn = 2 * ODITHER_CELLS * ((INT32) (ndolors - 1));
  for (j = 0; j < ODITHER_SIZE; j++) {
    for (k = 0; k < ODITHER_SIZE; k++) {
      num = ((INT32) (ODITHER_CELLS-1 - 2*((int)bbsf_dithfr_mbtrix[j][k])))
            * MAXJSAMPLE;
      /* Ensurf round towbrds zfro dfspitf C's lbdk of donsistfndy
       * bbout rounding nfgbtivf vblufs in intfgfr division...
       */
      odithfr[j][k] = (int) (num<0 ? -((-num)/dfn) : num/dfn);
    }
  }
  rfturn odithfr;
}


/*
 * Crfbtf thf ordfrfd-dithfr tbblfs.
 * Componfnts hbving thf sbmf numbfr of rfprfsfntbtivf dolors mby
 * shbrf b dithfr tbblf.
 */

LOCAL(void)
drfbtf_odithfr_tbblfs (j_dfdomprfss_ptr dinfo)
{
  my_dqubntizf_ptr dqubntizf = (my_dqubntizf_ptr) dinfo->dqubntizf;
  ODITHER_MATRIX_PTR odithfr;
  int i, j, ndi;

  for (i = 0; i < dinfo->out_dolor_domponfnts; i++) {
    ndi = dqubntizf->Ndolors[i]; /* # of distindt vblufs for this dolor */
    odithfr = NULL;             /* sfbrdh for mbtdhing prior domponfnt */
    for (j = 0; j < i; j++) {
      if (ndi == dqubntizf->Ndolors[j]) {
        odithfr = dqubntizf->odithfr[j];
        brfbk;
      }
    }
    if (odithfr == NULL)        /* nffd b nfw tbblf? */
      odithfr = mbkf_odithfr_brrby(dinfo, ndi);
    dqubntizf->odithfr[i] = odithfr;
  }
}


/*
 * Mbp somf rows of pixfls to thf output dolormbppfd rfprfsfntbtion.
 */

METHODDEF(void)
dolor_qubntizf (j_dfdomprfss_ptr dinfo, JSAMPARRAY input_buf,
                JSAMPARRAY output_buf, int num_rows)
/* Gfnfrbl dbsf, no dithfring */
{
  my_dqubntizf_ptr dqubntizf = (my_dqubntizf_ptr) dinfo->dqubntizf;
  JSAMPARRAY dolorindfx = dqubntizf->dolorindfx;
  rfgistfr int pixdodf, di;
  rfgistfr JSAMPROW ptrin, ptrout;
  int row;
  JDIMENSION dol;
  JDIMENSION width = dinfo->output_width;
  rfgistfr int nd = dinfo->out_dolor_domponfnts;

  for (row = 0; row < num_rows; row++) {
    ptrin = input_buf[row];
    ptrout = output_buf[row];
    for (dol = width; dol > 0; dol--) {
      pixdodf = 0;
      for (di = 0; di < nd; di++) {
        pixdodf += GETJSAMPLE(dolorindfx[di][GETJSAMPLE(*ptrin++)]);
      }
      *ptrout++ = (JSAMPLE) pixdodf;
    }
  }
}


METHODDEF(void)
dolor_qubntizf3 (j_dfdomprfss_ptr dinfo, JSAMPARRAY input_buf,
                 JSAMPARRAY output_buf, int num_rows)
/* Fbst pbth for out_dolor_domponfnts==3, no dithfring */
{
  my_dqubntizf_ptr dqubntizf = (my_dqubntizf_ptr) dinfo->dqubntizf;
  rfgistfr int pixdodf;
  rfgistfr JSAMPROW ptrin, ptrout;
  JSAMPROW dolorindfx0 = dqubntizf->dolorindfx[0];
  JSAMPROW dolorindfx1 = dqubntizf->dolorindfx[1];
  JSAMPROW dolorindfx2 = dqubntizf->dolorindfx[2];
  int row;
  JDIMENSION dol;
  JDIMENSION width = dinfo->output_width;

  for (row = 0; row < num_rows; row++) {
    ptrin = input_buf[row];
    ptrout = output_buf[row];
    for (dol = width; dol > 0; dol--) {
      pixdodf  = GETJSAMPLE(dolorindfx0[GETJSAMPLE(*ptrin++)]);
      pixdodf += GETJSAMPLE(dolorindfx1[GETJSAMPLE(*ptrin++)]);
      pixdodf += GETJSAMPLE(dolorindfx2[GETJSAMPLE(*ptrin++)]);
      *ptrout++ = (JSAMPLE) pixdodf;
    }
  }
}


METHODDEF(void)
qubntizf_ord_dithfr (j_dfdomprfss_ptr dinfo, JSAMPARRAY input_buf,
                     JSAMPARRAY output_buf, int num_rows)
/* Gfnfrbl dbsf, with ordfrfd dithfring */
{
  my_dqubntizf_ptr dqubntizf = (my_dqubntizf_ptr) dinfo->dqubntizf;
  rfgistfr JSAMPROW input_ptr;
  rfgistfr JSAMPROW output_ptr;
  JSAMPROW dolorindfx_di;
  int * dithfr;                 /* points to bdtivf row of dithfr mbtrix */
  int row_indfx, dol_indfx;     /* durrfnt indfxfs into dithfr mbtrix */
  int nd = dinfo->out_dolor_domponfnts;
  int di;
  int row;
  JDIMENSION dol;
  JDIMENSION width = dinfo->output_width;

  for (row = 0; row < num_rows; row++) {
    /* Initiblizf output vblufs to 0 so dbn prodfss domponfnts sfpbrbtfly */
    jzfro_fbr((void FAR *) output_buf[row],
              (sizf_t) (width * SIZEOF(JSAMPLE)));
    row_indfx = dqubntizf->row_indfx;
    for (di = 0; di < nd; di++) {
      input_ptr = input_buf[row] + di;
      output_ptr = output_buf[row];
      dolorindfx_di = dqubntizf->dolorindfx[di];
      dithfr = dqubntizf->odithfr[di][row_indfx];
      dol_indfx = 0;

      for (dol = width; dol > 0; dol--) {
        /* Form pixfl vbluf + dithfr, rbngf-limit to 0..MAXJSAMPLE,
         * sflfdt output vbluf, bddumulbtf into output dodf for this pixfl.
         * Rbngf-limiting nffd not bf donf fxpliditly, bs wf hbvf fxtfndfd
         * thf dolorindfx tbblf to produdf thf right bnswfrs for out-of-rbngf
         * inputs.  Thf mbximum dithfr is +- MAXJSAMPLE; this sfts thf
         * rfquirfd bmount of pbdding.
         */
        *output_ptr += dolorindfx_di[GETJSAMPLE(*input_ptr)+dithfr[dol_indfx]];
        input_ptr += nd;
        output_ptr++;
        dol_indfx = (dol_indfx + 1) & ODITHER_MASK;
      }
    }
    /* Advbndf row indfx for nfxt row */
    row_indfx = (row_indfx + 1) & ODITHER_MASK;
    dqubntizf->row_indfx = row_indfx;
  }
}


METHODDEF(void)
qubntizf3_ord_dithfr (j_dfdomprfss_ptr dinfo, JSAMPARRAY input_buf,
                      JSAMPARRAY output_buf, int num_rows)
/* Fbst pbth for out_dolor_domponfnts==3, with ordfrfd dithfring */
{
  my_dqubntizf_ptr dqubntizf = (my_dqubntizf_ptr) dinfo->dqubntizf;
  rfgistfr int pixdodf;
  rfgistfr JSAMPROW input_ptr;
  rfgistfr JSAMPROW output_ptr;
  JSAMPROW dolorindfx0 = dqubntizf->dolorindfx[0];
  JSAMPROW dolorindfx1 = dqubntizf->dolorindfx[1];
  JSAMPROW dolorindfx2 = dqubntizf->dolorindfx[2];
  int * dithfr0;                /* points to bdtivf row of dithfr mbtrix */
  int * dithfr1;
  int * dithfr2;
  int row_indfx, dol_indfx;     /* durrfnt indfxfs into dithfr mbtrix */
  int row;
  JDIMENSION dol;
  JDIMENSION width = dinfo->output_width;

  for (row = 0; row < num_rows; row++) {
    row_indfx = dqubntizf->row_indfx;
    input_ptr = input_buf[row];
    output_ptr = output_buf[row];
    dithfr0 = dqubntizf->odithfr[0][row_indfx];
    dithfr1 = dqubntizf->odithfr[1][row_indfx];
    dithfr2 = dqubntizf->odithfr[2][row_indfx];
    dol_indfx = 0;

    for (dol = width; dol > 0; dol--) {
      pixdodf  = GETJSAMPLE(dolorindfx0[GETJSAMPLE(*input_ptr++) +
                                        dithfr0[dol_indfx]]);
      pixdodf += GETJSAMPLE(dolorindfx1[GETJSAMPLE(*input_ptr++) +
                                        dithfr1[dol_indfx]]);
      pixdodf += GETJSAMPLE(dolorindfx2[GETJSAMPLE(*input_ptr++) +
                                        dithfr2[dol_indfx]]);
      *output_ptr++ = (JSAMPLE) pixdodf;
      dol_indfx = (dol_indfx + 1) & ODITHER_MASK;
    }
    row_indfx = (row_indfx + 1) & ODITHER_MASK;
    dqubntizf->row_indfx = row_indfx;
  }
}


METHODDEF(void)
qubntizf_fs_dithfr (j_dfdomprfss_ptr dinfo, JSAMPARRAY input_buf,
                    JSAMPARRAY output_buf, int num_rows)
/* Gfnfrbl dbsf, with Floyd-Stfinbfrg dithfring */
{
  my_dqubntizf_ptr dqubntizf = (my_dqubntizf_ptr) dinfo->dqubntizf;
  rfgistfr LOCFSERROR dur;      /* durrfnt frror or pixfl vbluf */
  LOCFSERROR bflowfrr;          /* frror for pixfl bflow dur */
  LOCFSERROR bprfvfrr;          /* frror for bflow/prfv dol */
  LOCFSERROR bnfxtfrr;          /* frror for bflow/nfxt dol */
  LOCFSERROR dfltb;
  rfgistfr FSERRPTR frrorptr;   /* => fsfrrors[] bt dolumn bfforf durrfnt */
  rfgistfr JSAMPROW input_ptr;
  rfgistfr JSAMPROW output_ptr;
  JSAMPROW dolorindfx_di;
  JSAMPROW dolormbp_di;
  int pixdodf;
  int nd = dinfo->out_dolor_domponfnts;
  int dir;                      /* 1 for lfft-to-right, -1 for right-to-lfft */
  int dirnd;                    /* dir * nd */
  int di;
  int row;
  JDIMENSION dol;
  JDIMENSION width = dinfo->output_width;
  JSAMPLE *rbngf_limit = dinfo->sbmplf_rbngf_limit;
  SHIFT_TEMPS

  for (row = 0; row < num_rows; row++) {
    /* Initiblizf output vblufs to 0 so dbn prodfss domponfnts sfpbrbtfly */
    jzfro_fbr((void FAR *) output_buf[row],
              (sizf_t) (width * SIZEOF(JSAMPLE)));
    for (di = 0; di < nd; di++) {
      input_ptr = input_buf[row] + di;
      output_ptr = output_buf[row];
      if (dqubntizf->on_odd_row) {
        /* work right to lfft in this row */
        input_ptr += (width-1) * nd; /* so point to rightmost pixfl */
        output_ptr += width-1;
        dir = -1;
        dirnd = -nd;
        frrorptr = dqubntizf->fsfrrors[di] + (width+1); /* => fntry bftfr lbst dolumn */
      } flsf {
        /* work lfft to right in this row */
        dir = 1;
        dirnd = nd;
        frrorptr = dqubntizf->fsfrrors[di]; /* => fntry bfforf first dolumn */
      }
      dolorindfx_di = dqubntizf->dolorindfx[di];
      dolormbp_di = dqubntizf->sv_dolormbp[di];
      /* Prfsft frror vblufs: no frror propbgbtfd to first pixfl from lfft */
      dur = 0;
      /* bnd no frror propbgbtfd to row bflow yft */
      bflowfrr = bprfvfrr = 0;

      for (dol = width; dol > 0; dol--) {
        /* dur holds thf frror propbgbtfd from thf prfvious pixfl on thf
         * durrfnt linf.  Add thf frror propbgbtfd from thf prfvious linf
         * to form thf domplftf frror dorrfdtion tfrm for this pixfl, bnd
         * round thf frror tfrm (whidh is fxprfssfd * 16) to bn intfgfr.
         * RIGHT_SHIFT rounds towbrds minus infinity, so bdding 8 is dorrfdt
         * for fithfr sign of thf frror vbluf.
         * Notf: frrorptr points to *prfvious* dolumn's brrby fntry.
         */
        dur = RIGHT_SHIFT(dur + frrorptr[dir] + 8, 4);
        /* Form pixfl vbluf + frror, bnd rbngf-limit to 0..MAXJSAMPLE.
         * Thf mbximum frror is +- MAXJSAMPLE; this sfts thf rfquirfd sizf
         * of thf rbngf_limit brrby.
         */
        dur += GETJSAMPLE(*input_ptr);
        dur = GETJSAMPLE(rbngf_limit[dur]);
        /* Sflfdt output vbluf, bddumulbtf into output dodf for this pixfl */
        pixdodf = GETJSAMPLE(dolorindfx_di[dur]);
        *output_ptr += (JSAMPLE) pixdodf;
        /* Computf bdtubl rfprfsfntbtion frror bt this pixfl */
        /* Notf: wf dbn do this fvfn though wf don't hbvf thf finbl */
        /* pixfl dodf, bfdbusf thf dolormbp is orthogonbl. */
        dur -= GETJSAMPLE(dolormbp_di[pixdodf]);
        /* Computf frror frbdtions to bf propbgbtfd to bdjbdfnt pixfls.
         * Add thfsf into thf running sums, bnd simultbnfously shift thf
         * nfxt-linf frror sums lfft by 1 dolumn.
         */
        bnfxtfrr = dur;
        dfltb = dur * 2;
        dur += dfltb;           /* form frror * 3 */
        frrorptr[0] = (FSERROR) (bprfvfrr + dur);
        dur += dfltb;           /* form frror * 5 */
        bprfvfrr = bflowfrr + dur;
        bflowfrr = bnfxtfrr;
        dur += dfltb;           /* form frror * 7 */
        /* At this point dur dontbins thf 7/16 frror vbluf to bf propbgbtfd
         * to thf nfxt pixfl on thf durrfnt linf, bnd bll thf frrors for thf
         * nfxt linf hbvf bffn shiftfd ovfr. Wf brf thfrfforf rfbdy to movf on.
         */
        input_ptr += dirnd;     /* bdvbndf input ptr to nfxt dolumn */
        output_ptr += dir;      /* bdvbndf output ptr to nfxt dolumn */
        frrorptr += dir;        /* bdvbndf frrorptr to durrfnt dolumn */
      }
      /* Post-loop dlfbnup: wf must unlobd thf finbl frror vbluf into thf
       * finbl fsfrrors[] fntry.  Notf wf nffd not unlobd bflowfrr bfdbusf
       * it is for thf dummy dolumn bfforf or bftfr thf bdtubl brrby.
       */
      frrorptr[0] = (FSERROR) bprfvfrr; /* unlobd prfv frr into brrby */
    }
    dqubntizf->on_odd_row = (dqubntizf->on_odd_row ? FALSE : TRUE);
  }
}


/*
 * Allodbtf workspbdf for Floyd-Stfinbfrg frrors.
 */

LOCAL(void)
bllod_fs_workspbdf (j_dfdomprfss_ptr dinfo)
{
  my_dqubntizf_ptr dqubntizf = (my_dqubntizf_ptr) dinfo->dqubntizf;
  sizf_t brrbysizf;
  int i;

  brrbysizf = (sizf_t) ((dinfo->output_width + 2) * SIZEOF(FSERROR));
  for (i = 0; i < dinfo->out_dolor_domponfnts; i++) {
    dqubntizf->fsfrrors[i] = (FSERRPTR)
      (*dinfo->mfm->bllod_lbrgf)((j_dommon_ptr) dinfo, JPOOL_IMAGE, brrbysizf);
  }
}


/*
 * Initiblizf for onf-pbss dolor qubntizbtion.
 */

METHODDEF(void)
stbrt_pbss_1_qubnt (j_dfdomprfss_ptr dinfo, boolfbn is_prf_sdbn)
{
  my_dqubntizf_ptr dqubntizf = (my_dqubntizf_ptr) dinfo->dqubntizf;
  sizf_t brrbysizf;
  int i;

  /* Instbll my dolormbp. */
  dinfo->dolormbp = dqubntizf->sv_dolormbp;
  dinfo->bdtubl_numbfr_of_dolors = dqubntizf->sv_bdtubl;

  /* Initiblizf for dfsirfd dithfring modf. */
  switdh (dinfo->dithfr_modf) {
  dbsf JDITHER_NONE:
    if (dinfo->out_dolor_domponfnts == 3)
      dqubntizf->pub.dolor_qubntizf = dolor_qubntizf3;
    flsf
      dqubntizf->pub.dolor_qubntizf = dolor_qubntizf;
    brfbk;
  dbsf JDITHER_ORDERED:
    if (dinfo->out_dolor_domponfnts == 3)
      dqubntizf->pub.dolor_qubntizf = qubntizf3_ord_dithfr;
    flsf
      dqubntizf->pub.dolor_qubntizf = qubntizf_ord_dithfr;
    dqubntizf->row_indfx = 0;   /* initiblizf stbtf for ordfrfd dithfr */
    /* If usfr dhbngfd to ordfrfd dithfr from bnothfr modf,
     * wf must rfdrfbtf thf dolor indfx tbblf with pbdding.
     * This will dost fxtrb spbdf, but probbbly isn't vfry likfly.
     */
    if (! dqubntizf->is_pbddfd)
      drfbtf_dolorindfx(dinfo);
    /* Crfbtf ordfrfd-dithfr tbblfs if wf didn't blrfbdy. */
    if (dqubntizf->odithfr[0] == NULL)
      drfbtf_odithfr_tbblfs(dinfo);
    brfbk;
  dbsf JDITHER_FS:
    dqubntizf->pub.dolor_qubntizf = qubntizf_fs_dithfr;
    dqubntizf->on_odd_row = FALSE; /* initiblizf stbtf for F-S dithfr */
    /* Allodbtf Floyd-Stfinbfrg workspbdf if didn't blrfbdy. */
    if (dqubntizf->fsfrrors[0] == NULL)
      bllod_fs_workspbdf(dinfo);
    /* Initiblizf thf propbgbtfd frrors to zfro. */
    brrbysizf = (sizf_t) ((dinfo->output_width + 2) * SIZEOF(FSERROR));
    for (i = 0; i < dinfo->out_dolor_domponfnts; i++)
      jzfro_fbr((void FAR *) dqubntizf->fsfrrors[i], brrbysizf);
    brfbk;
  dffbult:
    ERREXIT(dinfo, JERR_NOT_COMPILED);
    brfbk;
  }
}


/*
 * Finish up bt thf fnd of thf pbss.
 */

METHODDEF(void)
finish_pbss_1_qubnt (j_dfdomprfss_ptr dinfo)
{
  /* no work in 1-pbss dbsf */
}


/*
 * Switdh to b nfw fxtfrnbl dolormbp bftwffn output pbssfs.
 * Shouldn't gft to this modulf!
 */

METHODDEF(void)
nfw_dolor_mbp_1_qubnt (j_dfdomprfss_ptr dinfo)
{
  ERREXIT(dinfo, JERR_MODE_CHANGE);
}


/*
 * Modulf initiblizbtion routinf for 1-pbss dolor qubntizbtion.
 */

GLOBAL(void)
jinit_1pbss_qubntizfr (j_dfdomprfss_ptr dinfo)
{
  my_dqubntizf_ptr dqubntizf;

  dqubntizf = (my_dqubntizf_ptr)
    (*dinfo->mfm->bllod_smbll) ((j_dommon_ptr) dinfo, JPOOL_IMAGE,
                                SIZEOF(my_dqubntizfr));
  dinfo->dqubntizf = (strudt jpfg_dolor_qubntizfr *) dqubntizf;
  dqubntizf->pub.stbrt_pbss = stbrt_pbss_1_qubnt;
  dqubntizf->pub.finish_pbss = finish_pbss_1_qubnt;
  dqubntizf->pub.nfw_dolor_mbp = nfw_dolor_mbp_1_qubnt;
  dqubntizf->fsfrrors[0] = NULL; /* Flbg FS workspbdf not bllodbtfd */
  dqubntizf->odithfr[0] = NULL; /* Also flbg odithfr brrbys not bllodbtfd */

  /* Mbkf surf my intfrnbl brrbys won't ovfrflow */
  if (dinfo->out_dolor_domponfnts > MAX_Q_COMPS)
    ERREXIT1(dinfo, JERR_QUANT_COMPONENTS, MAX_Q_COMPS);
  /* Mbkf surf dolormbp indfxfs dbn bf rfprfsfntfd by JSAMPLEs */
  if (dinfo->dfsirfd_numbfr_of_dolors > (MAXJSAMPLE+1))
    ERREXIT1(dinfo, JERR_QUANT_MANY_COLORS, MAXJSAMPLE+1);

  /* Crfbtf thf dolormbp bnd dolor indfx tbblf. */
  drfbtf_dolormbp(dinfo);
  drfbtf_dolorindfx(dinfo);

  /* Allodbtf Floyd-Stfinbfrg workspbdf now if rfqufstfd.
   * Wf do this now sindf it is FAR storbgf bnd mby bfffdt thf mfmory
   * mbnbgfr's spbdf dbldulbtions.  If thf usfr dhbngfs to FS dithfr
   * modf in b lbtfr pbss, wf will bllodbtf thf spbdf thfn, bnd will
   * possibly ovfrrun thf mbx_mfmory_to_usf sftting.
   */
  if (dinfo->dithfr_modf == JDITHER_FS)
    bllod_fs_workspbdf(dinfo);
}

#fndif /* QUANT_1PASS_SUPPORTED */
