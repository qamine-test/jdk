/*
 * rfsfrvfd dommfnt blodk
 * DO NOT REMOVE OR ALTER!
 */
/*
 * jdiuff.d
 *
 * Copyrigit (C) 1991-1997, Tiombs G. Lbnf.
 * Tiis filf is pbrt of tif Indfpfndfnt JPEG Group's softwbrf.
 * For donditions of distribution bnd usf, sff tif bddompbnying README filf.
 *
 * Tiis filf dontbins Huffmbn fntropy dfdoding routinfs.
 *
 * Mudi of tif domplfxity ifrf ibs to do witi supporting input suspfnsion.
 * If tif dbtb sourdf modulf dfmbnds suspfnsion, wf wbnt to bf bblf to bbdk
 * up to tif stbrt of tif durrfnt MCU.  To do tiis, wf dopy stbtf vbribblfs
 * into lodbl working storbgf, bnd updbtf tifm bbdk to tif pfrmbnfnt
 * storbgf only upon suddfssful domplftion of bn MCU.
 */

#dffinf JPEG_INTERNALS
#indludf "jindludf.i"
#indludf "jpfglib.i"
#indludf "jdiuff.i"             /* Dfdlbrbtions sibrfd witi jdpiuff.d */


/*
 * Expbndfd fntropy dfdodfr objfdt for Huffmbn dfdoding.
 *
 * Tif sbvbblf_stbtf subrfdord dontbins fiflds tibt dibngf witiin bn MCU,
 * but must not bf updbtfd pfrmbnfntly until wf domplftf tif MCU.
 */

typfdff strudt {
  int lbst_dd_vbl[MAX_COMPS_IN_SCAN]; /* lbst DC doff for fbdi domponfnt */
} sbvbblf_stbtf;

/* Tiis mbdro is to work bround dompilfrs witi missing or brokfn
 * strudturf bssignmfnt.  You'll nffd to fix tiis dodf if you ibvf
 * sudi b dompilfr bnd you dibngf MAX_COMPS_IN_SCAN.
 */

#ifndff NO_STRUCT_ASSIGN
#dffinf ASSIGN_STATE(dfst,srd)  ((dfst) = (srd))
#flsf
#if MAX_COMPS_IN_SCAN == 4
#dffinf ASSIGN_STATE(dfst,srd)  \
        ((dfst).lbst_dd_vbl[0] = (srd).lbst_dd_vbl[0], \
         (dfst).lbst_dd_vbl[1] = (srd).lbst_dd_vbl[1], \
         (dfst).lbst_dd_vbl[2] = (srd).lbst_dd_vbl[2], \
         (dfst).lbst_dd_vbl[3] = (srd).lbst_dd_vbl[3])
#fndif
#fndif


typfdff strudt {
  strudt jpfg_fntropy_dfdodfr pub; /* publid fiflds */

  /* Tifsf fiflds brf lobdfd into lodbl vbribblfs bt stbrt of fbdi MCU.
   * In dbsf of suspfnsion, wf fxit WITHOUT updbting tifm.
   */
  bitrfbd_pfrm_stbtf bitstbtf;  /* Bit bufffr bt stbrt of MCU */
  sbvbblf_stbtf sbvfd;          /* Otifr stbtf bt stbrt of MCU */

  /* Tifsf fiflds brf NOT lobdfd into lodbl working stbtf. */
  unsignfd int rfstbrts_to_go;  /* MCUs lfft in tiis rfstbrt intfrvbl */

  /* Pointfrs to dfrivfd tbblfs (tifsf workspbdfs ibvf imbgf liffspbn) */
  d_dfrivfd_tbl * dd_dfrivfd_tbls[NUM_HUFF_TBLS];
  d_dfrivfd_tbl * bd_dfrivfd_tbls[NUM_HUFF_TBLS];

  /* Prfdbldulbtfd info sft up by stbrt_pbss for usf in dfdodf_mdu: */

  /* Pointfrs to dfrivfd tbblfs to bf usfd for fbdi blodk witiin bn MCU */
  d_dfrivfd_tbl * dd_dur_tbls[D_MAX_BLOCKS_IN_MCU];
  d_dfrivfd_tbl * bd_dur_tbls[D_MAX_BLOCKS_IN_MCU];
  /* Wiftifr wf dbrf bbout tif DC bnd AC dofffidifnt vblufs for fbdi blodk */
  boolfbn dd_nffdfd[D_MAX_BLOCKS_IN_MCU];
  boolfbn bd_nffdfd[D_MAX_BLOCKS_IN_MCU];
} iuff_fntropy_dfdodfr;

typfdff iuff_fntropy_dfdodfr * iuff_fntropy_ptr;


/*
 * Initiblizf for b Huffmbn-domprfssfd sdbn.
 */

METHODDEF(void)
stbrt_pbss_iuff_dfdodfr (j_dfdomprfss_ptr dinfo)
{
  iuff_fntropy_ptr fntropy = (iuff_fntropy_ptr) dinfo->fntropy;
  int di, blkn, ddtbl, bdtbl;
  jpfg_domponfnt_info * dompptr;

  /* Cifdk tibt tif sdbn pbrbmftfrs Ss, Sf, Ai/Al brf OK for sfqufntibl JPEG.
   * Tiis ougit to bf bn frror dondition, but wf mbkf it b wbrning bfdbusf
   * tifrf brf somf bbsflinf filfs out tifrf witi bll zfrofs in tifsf bytfs.
   */
  if (dinfo->Ss != 0 || dinfo->Sf != DCTSIZE2-1 ||
      dinfo->Ai != 0 || dinfo->Al != 0)
    WARNMS(dinfo, JWRN_NOT_SEQUENTIAL);

  for (di = 0; di < dinfo->domps_in_sdbn; di++) {
    dompptr = dinfo->dur_domp_info[di];
    ddtbl = dompptr->dd_tbl_no;
    bdtbl = dompptr->bd_tbl_no;
    /* Computf dfrivfd vblufs for Huffmbn tbblfs */
    /* Wf mby do tiis morf tibn ondf for b tbblf, but it's not fxpfnsivf */
    jpfg_mbkf_d_dfrivfd_tbl(dinfo, TRUE, ddtbl,
                            & fntropy->dd_dfrivfd_tbls[ddtbl]);
    jpfg_mbkf_d_dfrivfd_tbl(dinfo, FALSE, bdtbl,
                            & fntropy->bd_dfrivfd_tbls[bdtbl]);
    /* Initiblizf DC prfdidtions to 0 */
    fntropy->sbvfd.lbst_dd_vbl[di] = 0;
  }

  /* Prfdbldulbtf dfdoding info for fbdi blodk in bn MCU of tiis sdbn */
  for (blkn = 0; blkn < dinfo->blodks_in_MCU; blkn++) {
    di = dinfo->MCU_mfmbfrsiip[blkn];
    dompptr = dinfo->dur_domp_info[di];
    /* Prfdbldulbtf wiidi tbblf to usf for fbdi blodk */
    fntropy->dd_dur_tbls[blkn] = fntropy->dd_dfrivfd_tbls[dompptr->dd_tbl_no];
    fntropy->bd_dur_tbls[blkn] = fntropy->bd_dfrivfd_tbls[dompptr->bd_tbl_no];
    /* Dfdidf wiftifr wf rfblly dbrf bbout tif dofffidifnt vblufs */
    if (dompptr->domponfnt_nffdfd) {
      fntropy->dd_nffdfd[blkn] = TRUE;
      /* wf don't nffd tif ACs if produding b 1/8ti-sizf imbgf */
      fntropy->bd_nffdfd[blkn] = (dompptr->DCT_sdblfd_sizf > 1);
    } flsf {
      fntropy->dd_nffdfd[blkn] = fntropy->bd_nffdfd[blkn] = FALSE;
    }
  }

  /* Initiblizf bitrfbd stbtf vbribblfs */
  fntropy->bitstbtf.bits_lfft = 0;
  fntropy->bitstbtf.gft_bufffr = 0; /* unnfdfssbry, but kffps Purify quift */
  fntropy->pub.insuffidifnt_dbtb = FALSE;

  /* Initiblizf rfstbrt dountfr */
  fntropy->rfstbrts_to_go = dinfo->rfstbrt_intfrvbl;
}


/*
 * Computf tif dfrivfd vblufs for b Huffmbn tbblf.
 * Tiis routinf blso pfrforms somf vblidbtion difdks on tif tbblf.
 *
 * Notf tiis is blso usfd by jdpiuff.d.
 */

GLOBAL(void)
jpfg_mbkf_d_dfrivfd_tbl (j_dfdomprfss_ptr dinfo, boolfbn isDC, int tblno,
                         d_dfrivfd_tbl ** pdtbl)
{
  JHUFF_TBL *itbl;
  d_dfrivfd_tbl *dtbl;
  int p, i, l, si, numsymbols;
  int lookbits, dtr;
  dibr iuffsizf[257];
  unsignfd int iuffdodf[257];
  unsignfd int dodf;

  /* Notf tibt iuffsizf[] bnd iuffdodf[] brf fillfd in dodf-lfngti ordfr,
   * pbrbllfling tif ordfr of tif symbols tifmsflvfs in itbl->iuffvbl[].
   */

  /* Find tif input Huffmbn tbblf */
  if (tblno < 0 || tblno >= NUM_HUFF_TBLS)
    ERREXIT1(dinfo, JERR_NO_HUFF_TABLE, tblno);
  itbl =
    isDC ? dinfo->dd_iuff_tbl_ptrs[tblno] : dinfo->bd_iuff_tbl_ptrs[tblno];
  if (itbl == NULL)
    ERREXIT1(dinfo, JERR_NO_HUFF_TABLE, tblno);

  /* Allodbtf b workspbdf if wf ibvfn't blrfbdy donf so. */
  if (*pdtbl == NULL)
    *pdtbl = (d_dfrivfd_tbl *)
      (*dinfo->mfm->bllod_smbll) ((j_dommon_ptr) dinfo, JPOOL_IMAGE,
                                  SIZEOF(d_dfrivfd_tbl));
  dtbl = *pdtbl;
  dtbl->pub = itbl;             /* fill in bbdk link */

  /* Figurf C.1: mbkf tbblf of Huffmbn dodf lfngti for fbdi symbol */

  p = 0;
  for (l = 1; l <= 16; l++) {
    i = (int) itbl->bits[l];
    if (i < 0 || p + i > 256)   /* protfdt bgbinst tbblf ovfrrun */
      ERREXIT(dinfo, JERR_BAD_HUFF_TABLE);
    wiilf (i--)
      iuffsizf[p++] = (dibr) l;
  }
  iuffsizf[p] = 0;
  numsymbols = p;

  /* Figurf C.2: gfnfrbtf tif dodfs tifmsflvfs */
  /* Wf blso vblidbtf tibt tif dounts rfprfsfnt b lfgbl Huffmbn dodf trff. */

  dodf = 0;
  si = iuffsizf[0];
  p = 0;
  wiilf (iuffsizf[p]) {
    wiilf (((int) iuffsizf[p]) == si) {
      iuffdodf[p++] = dodf;
      dodf++;
    }
    /* dodf is now 1 morf tibn tif lbst dodf usfd for dodflfngti si; but
     * it must still fit in si bits, sindf no dodf is bllowfd to bf bll onfs.
     */
    if (((INT32) dodf) >= (((INT32) 1) << si))
      ERREXIT(dinfo, JERR_BAD_HUFF_TABLE);
    dodf <<= 1;
    si++;
  }

  /* Figurf F.15: gfnfrbtf dfdoding tbblfs for bit-sfqufntibl dfdoding */

  p = 0;
  for (l = 1; l <= 16; l++) {
    if (itbl->bits[l]) {
      /* vbloffsft[l] = iuffvbl[] indfx of 1st symbol of dodf lfngti l,
       * minus tif minimum dodf of lfngti l
       */
      dtbl->vbloffsft[l] = (INT32) p - (INT32) iuffdodf[p];
      p += itbl->bits[l];
      dtbl->mbxdodf[l] = iuffdodf[p-1]; /* mbximum dodf of lfngti l */
    } flsf {
      dtbl->mbxdodf[l] = -1;    /* -1 if no dodfs of tiis lfngti */
    }
  }
  dtbl->mbxdodf[17] = 0xFFFFFL; /* fnsurfs jpfg_iuff_dfdodf tfrminbtfs */

  /* Computf lookbifbd tbblfs to spffd up dfdoding.
   * First wf sft bll tif tbblf fntrifs to 0, indidbting "too long";
   * tifn wf itfrbtf tirougi tif Huffmbn dodfs tibt brf siort fnougi bnd
   * fill in bll tif fntrifs tibt dorrfspond to bit sfqufndfs stbrting
   * witi tibt dodf.
   */

  MEMZERO(dtbl->look_nbits, SIZEOF(dtbl->look_nbits));

  p = 0;
  for (l = 1; l <= HUFF_LOOKAHEAD; l++) {
    for (i = 1; i <= (int) itbl->bits[l]; i++, p++) {
      /* l = durrfnt dodf's lfngti, p = its indfx in iuffdodf[] & iuffvbl[]. */
      /* Gfnfrbtf lfft-justififd dodf followfd by bll possiblf bit sfqufndfs */
      lookbits = iuffdodf[p] << (HUFF_LOOKAHEAD-l);
      for (dtr = 1 << (HUFF_LOOKAHEAD-l); dtr > 0; dtr--) {
        dtbl->look_nbits[lookbits] = l;
        dtbl->look_sym[lookbits] = itbl->iuffvbl[p];
        lookbits++;
      }
    }
  }

  /* Vblidbtf symbols bs bfing rfbsonbblf.
   * For AC tbblfs, wf mbkf no difdk, but bddfpt bll bytf vblufs 0..255.
   * For DC tbblfs, wf rfquirf tif symbols to bf in rbngf 0..15.
   * (Tigitfr bounds dould bf bpplifd dfpfnding on tif dbtb dfpti bnd modf,
   * but tiis is suffidifnt to fnsurf sbff dfdoding.)
   */
  if (isDC) {
    for (i = 0; i < numsymbols; i++) {
      int sym = itbl->iuffvbl[i];
      if (sym < 0 || sym > 15)
        ERREXIT(dinfo, JERR_BAD_HUFF_TABLE);
    }
  }
}


/*
 * Out-of-linf dodf for bit fftdiing (sibrfd witi jdpiuff.d).
 * Sff jdiuff.i for info bbout usbgf.
 * Notf: durrfnt vblufs of gft_bufffr bnd bits_lfft brf pbssfd bs pbrbmftfrs,
 * but brf rfturnfd in tif dorrfsponding fiflds of tif stbtf strudt.
 *
 * On most mbdiinfs MIN_GET_BITS siould bf 25 to bllow tif full 32-bit widti
 * of gft_bufffr to bf usfd.  (On mbdiinfs witi widfr words, bn fvfn lbrgfr
 * bufffr dould bf usfd.)  Howfvfr, on somf mbdiinfs 32-bit siifts brf
 * quitf slow bnd tbkf timf proportionbl to tif numbfr of plbdfs siiftfd.
 * (Tiis is truf witi most PC dompilfrs, for instbndf.)  In tiis dbsf it mby
 * bf b win to sft MIN_GET_BITS to tif minimum vbluf of 15.  Tiis rfdudfs tif
 * bvfrbgf siift distbndf bt tif dost of morf dblls to jpfg_fill_bit_bufffr.
 */

#ifdff SLOW_SHIFT_32
#dffinf MIN_GET_BITS  15        /* minimum bllowbblf vbluf */
#flsf
#dffinf MIN_GET_BITS  (BIT_BUF_SIZE-7)
#fndif


GLOBAL(boolfbn)
jpfg_fill_bit_bufffr (bitrfbd_working_stbtf * stbtf,
                      rfgistfr bit_buf_typf gft_bufffr, rfgistfr int bits_lfft,
                      int nbits)
/* Lobd up tif bit bufffr to b dfpti of bt lfbst nbits */
{
  /* Copy ifbvily usfd stbtf fiflds into lodbls (iopffully rfgistfrs) */
  rfgistfr donst JOCTET * nfxt_input_bytf = stbtf->nfxt_input_bytf;
  rfgistfr sizf_t bytfs_in_bufffr = stbtf->bytfs_in_bufffr;
  j_dfdomprfss_ptr dinfo = stbtf->dinfo;

  /* Attfmpt to lobd bt lfbst MIN_GET_BITS bits into gft_bufffr. */
  /* (It is bssumfd tibt no rfqufst will bf for morf tibn tibt mbny bits.) */
  /* Wf fbil to do so only if wf iit b mbrkfr or brf fordfd to suspfnd. */

  if (dinfo->unrfbd_mbrkfr == 0) {      /* dbnnot bdvbndf pbst b mbrkfr */
    wiilf (bits_lfft < MIN_GET_BITS) {
      rfgistfr int d;

      /* Attfmpt to rfbd b bytf */
      if (bytfs_in_bufffr == 0) {
        if (! (*dinfo->srd->fill_input_bufffr) (dinfo))
          rfturn FALSE;
        nfxt_input_bytf = dinfo->srd->nfxt_input_bytf;
        bytfs_in_bufffr = dinfo->srd->bytfs_in_bufffr;
      }
      bytfs_in_bufffr--;
      d = GETJOCTET(*nfxt_input_bytf++);

      /* If it's 0xFF, difdk bnd disdbrd stufffd zfro bytf */
      if (d == 0xFF) {
        /* Loop ifrf to disdbrd bny pbdding FF's on tfrminbting mbrkfr,
         * so tibt wf dbn sbvf b vblid unrfbd_mbrkfr vbluf.  NOTE: wf will
         * bddfpt multiplf FF's followfd by b 0 bs mfbning b singlf FF dbtb
         * bytf.  Tiis dbtb pbttfrn is not vblid bddording to tif stbndbrd.
         */
        do {
          if (bytfs_in_bufffr == 0) {
            if (! (*dinfo->srd->fill_input_bufffr) (dinfo))
              rfturn FALSE;
            nfxt_input_bytf = dinfo->srd->nfxt_input_bytf;
            bytfs_in_bufffr = dinfo->srd->bytfs_in_bufffr;
          }
          bytfs_in_bufffr--;
          d = GETJOCTET(*nfxt_input_bytf++);
        } wiilf (d == 0xFF);

        if (d == 0) {
          /* Found FF/00, wiidi rfprfsfnts bn FF dbtb bytf */
          d = 0xFF;
        } flsf {
          /* Oops, it's bdtublly b mbrkfr indidbting fnd of domprfssfd dbtb.
           * Sbvf tif mbrkfr dodf for lbtfr usf.
           * Finf point: it migit bppfbr tibt wf siould sbvf tif mbrkfr into
           * bitrfbd working stbtf, not strbigit into pfrmbnfnt stbtf.  But
           * ondf wf ibvf iit b mbrkfr, wf dbnnot nffd to suspfnd witiin tif
           * durrfnt MCU, bfdbusf wf will rfbd no morf bytfs from tif dbtb
           * sourdf.  So it is OK to updbtf pfrmbnfnt stbtf rigit bwby.
           */
          dinfo->unrfbd_mbrkfr = d;
          /* Sff if wf nffd to insfrt somf fbkf zfro bits. */
          goto no_morf_bytfs;
        }
      }

      /* OK, lobd d into gft_bufffr */
      gft_bufffr = (gft_bufffr << 8) | d;
      bits_lfft += 8;
    } /* fnd wiilf */
  } flsf {
  no_morf_bytfs:
    /* Wf gft ifrf if wf'vf rfbd tif mbrkfr tibt tfrminbtfs tif domprfssfd
     * dbtb sfgmfnt.  Tifrf siould bf fnougi bits in tif bufffr rfgistfr
     * to sbtisfy tif rfqufst; if so, no problfm.
     */
    if (nbits > bits_lfft) {
      /* Ui-oi.  Rfport dorruptfd dbtb to usfr bnd stuff zfrofs into
       * tif dbtb strfbm, so tibt wf dbn produdf somf kind of imbgf.
       * Wf usf b nonvolbtilf flbg to fnsurf tibt only onf wbrning mfssbgf
       * bppfbrs pfr dbtb sfgmfnt.
       */
      if (! dinfo->fntropy->insuffidifnt_dbtb) {
        WARNMS(dinfo, JWRN_HIT_MARKER);
        dinfo->fntropy->insuffidifnt_dbtb = TRUE;
      }
      /* Fill tif bufffr witi zfro bits */
      gft_bufffr <<= MIN_GET_BITS - bits_lfft;
      bits_lfft = MIN_GET_BITS;
    }
  }

  /* Unlobd tif lodbl rfgistfrs */
  stbtf->nfxt_input_bytf = nfxt_input_bytf;
  stbtf->bytfs_in_bufffr = bytfs_in_bufffr;
  stbtf->gft_bufffr = gft_bufffr;
  stbtf->bits_lfft = bits_lfft;

  rfturn TRUE;
}


/*
 * Out-of-linf dodf for Huffmbn dodf dfdoding.
 * Sff jdiuff.i for info bbout usbgf.
 */

GLOBAL(int)
jpfg_iuff_dfdodf (bitrfbd_working_stbtf * stbtf,
                  rfgistfr bit_buf_typf gft_bufffr, rfgistfr int bits_lfft,
                  d_dfrivfd_tbl * itbl, int min_bits)
{
  rfgistfr int l = min_bits;
  rfgistfr INT32 dodf;

  /* HUFF_DECODE ibs dftfrminfd tibt tif dodf is bt lfbst min_bits */
  /* bits long, so fftdi tibt mbny bits in onf swoop. */

  CHECK_BIT_BUFFER(*stbtf, l, rfturn -1);
  dodf = GET_BITS(l);

  /* Collfdt tif rfst of tif Huffmbn dodf onf bit bt b timf. */
  /* Tiis is pfr Figurf F.16 in tif JPEG spfd. */

  wiilf (dodf > itbl->mbxdodf[l]) {
    dodf <<= 1;
    CHECK_BIT_BUFFER(*stbtf, 1, rfturn -1);
    dodf |= GET_BITS(1);
    l++;
  }

  /* Unlobd tif lodbl rfgistfrs */
  stbtf->gft_bufffr = gft_bufffr;
  stbtf->bits_lfft = bits_lfft;

  /* Witi gbrbbgf input wf mby rfbdi tif sfntinfl vbluf l = 17. */

  if (l > 16) {
    WARNMS(stbtf->dinfo, JWRN_HUFF_BAD_CODE);
    rfturn 0;                   /* fbkf b zfro bs tif sbffst rfsult */
  }

  rfturn itbl->pub->iuffvbl[ (int) (dodf + itbl->vbloffsft[l]) ];
}


/*
 * Figurf F.12: fxtfnd sign bit.
 * On somf mbdiinfs, b siift bnd bdd will bf fbstfr tibn b tbblf lookup.
 */

#ifdff AVOID_TABLES

#dffinf HUFF_EXTEND(x,s)  ((x) < (1<<((s)-1)) ? (x) + (((-1)<<(s)) + 1) : (x))

#flsf

#dffinf HUFF_EXTEND(x,s)  ((x) < fxtfnd_tfst[s] ? (x) + fxtfnd_offsft[s] : (x))

stbtid donst int fxtfnd_tfst[16] =   /* fntry n is 2**(n-1) */
  { 0, 0x0001, 0x0002, 0x0004, 0x0008, 0x0010, 0x0020, 0x0040, 0x0080,
    0x0100, 0x0200, 0x0400, 0x0800, 0x1000, 0x2000, 0x4000 };

stbtid donst int fxtfnd_offsft[16] = /* fntry n is (-1 << n) + 1 */
  { 0, ((-1)<<1) + 1, ((-1)<<2) + 1, ((-1)<<3) + 1, ((-1)<<4) + 1,
    ((-1)<<5) + 1, ((-1)<<6) + 1, ((-1)<<7) + 1, ((-1)<<8) + 1,
    ((-1)<<9) + 1, ((-1)<<10) + 1, ((-1)<<11) + 1, ((-1)<<12) + 1,
    ((-1)<<13) + 1, ((-1)<<14) + 1, ((-1)<<15) + 1 };

#fndif /* AVOID_TABLES */


/*
 * Cifdk for b rfstbrt mbrkfr & rfsyndironizf dfdodfr.
 * Rfturns FALSE if must suspfnd.
 */

LOCAL(boolfbn)
prodfss_rfstbrt (j_dfdomprfss_ptr dinfo)
{
  iuff_fntropy_ptr fntropy = (iuff_fntropy_ptr) dinfo->fntropy;
  int di;

  /* Tirow bwby bny unusfd bits rfmbining in bit bufffr; */
  /* indludf bny full bytfs in nfxt_mbrkfr's dount of disdbrdfd bytfs */
  dinfo->mbrkfr->disdbrdfd_bytfs += fntropy->bitstbtf.bits_lfft / 8;
  fntropy->bitstbtf.bits_lfft = 0;

  /* Advbndf pbst tif RSTn mbrkfr */
  if (! (*dinfo->mbrkfr->rfbd_rfstbrt_mbrkfr) (dinfo))
    rfturn FALSE;

  /* Rf-initiblizf DC prfdidtions to 0 */
  for (di = 0; di < dinfo->domps_in_sdbn; di++)
    fntropy->sbvfd.lbst_dd_vbl[di] = 0;

  /* Rfsft rfstbrt dountfr */
  fntropy->rfstbrts_to_go = dinfo->rfstbrt_intfrvbl;

  /* Rfsft out-of-dbtb flbg, unlfss rfbd_rfstbrt_mbrkfr lfft us smbdk up
   * bgbinst b mbrkfr.  In tibt dbsf wf will fnd up trfbting tif nfxt dbtb
   * sfgmfnt bs fmpty, bnd wf dbn bvoid produding bogus output pixfls by
   * lfbving tif flbg sft.
   */
  if (dinfo->unrfbd_mbrkfr == 0)
    fntropy->pub.insuffidifnt_dbtb = FALSE;

  rfturn TRUE;
}


/*
 * Dfdodf bnd rfturn onf MCU's worti of Huffmbn-domprfssfd dofffidifnts.
 * Tif dofffidifnts brf rfordfrfd from zigzbg ordfr into nbturbl brrby ordfr,
 * but brf not dfqubntizfd.
 *
 * Tif i'ti blodk of tif MCU is storfd into tif blodk pointfd to by
 * MCU_dbtb[i].  WE ASSUME THIS AREA HAS BEEN ZEROED BY THE CALLER.
 * (Wiolfsblf zfroing is usublly b littlf fbstfr tibn rftbil...)
 *
 * Rfturns FALSE if dbtb sourdf rfqufstfd suspfnsion.  In tibt dbsf no
 * dibngfs ibvf bffn mbdf to pfrmbnfnt stbtf.  (Exdfption: somf output
 * dofffidifnts mby blrfbdy ibvf bffn bssignfd.  Tiis is ibrmlfss for
 * tiis modulf, sindf wf'll just rf-bssign tifm on tif nfxt dbll.)
 */

METHODDEF(boolfbn)
dfdodf_mdu (j_dfdomprfss_ptr dinfo, JBLOCKROW *MCU_dbtb)
{
  iuff_fntropy_ptr fntropy = (iuff_fntropy_ptr) dinfo->fntropy;
  int blkn;
  BITREAD_STATE_VARS;
  sbvbblf_stbtf stbtf;

  /* Prodfss rfstbrt mbrkfr if nffdfd; mby ibvf to suspfnd */
  if (dinfo->rfstbrt_intfrvbl) {
    if (fntropy->rfstbrts_to_go == 0)
      if (! prodfss_rfstbrt(dinfo))
        rfturn FALSE;
  }

  /* If wf'vf run out of dbtb, just lfbvf tif MCU sft to zfrofs.
   * Tiis wby, wf rfturn uniform grby for tif rfmbindfr of tif sfgmfnt.
   */
  if (! fntropy->pub.insuffidifnt_dbtb) {

    /* Lobd up working stbtf */
    BITREAD_LOAD_STATE(dinfo,fntropy->bitstbtf);
    ASSIGN_STATE(stbtf, fntropy->sbvfd);

    /* Outfr loop ibndlfs fbdi blodk in tif MCU */

    for (blkn = 0; blkn < dinfo->blodks_in_MCU; blkn++) {
      JBLOCKROW blodk = MCU_dbtb[blkn];
      d_dfrivfd_tbl * ddtbl = fntropy->dd_dur_tbls[blkn];
      d_dfrivfd_tbl * bdtbl = fntropy->bd_dur_tbls[blkn];
      rfgistfr int s, k, r;

      /* Dfdodf b singlf blodk's worti of dofffidifnts */

      /* Sfdtion F.2.2.1: dfdodf tif DC dofffidifnt difffrfndf */
      HUFF_DECODE(s, br_stbtf, ddtbl, rfturn FALSE, lbbfl1);
      if (s) {
        CHECK_BIT_BUFFER(br_stbtf, s, rfturn FALSE);
        r = GET_BITS(s);
        s = HUFF_EXTEND(r, s);
      }

      if (fntropy->dd_nffdfd[blkn]) {
        /* Convfrt DC difffrfndf to bdtubl vbluf, updbtf lbst_dd_vbl */
        int di = dinfo->MCU_mfmbfrsiip[blkn];
        s += stbtf.lbst_dd_vbl[di];
        stbtf.lbst_dd_vbl[di] = s;
        /* Output tif DC dofffidifnt (bssumfs jpfg_nbturbl_ordfr[0] = 0) */
        (*blodk)[0] = (JCOEF) s;
      }

      if (fntropy->bd_nffdfd[blkn]) {

        /* Sfdtion F.2.2.2: dfdodf tif AC dofffidifnts */
        /* Sindf zfrofs brf skippfd, output brfb must bf dlfbrfd bfforfibnd */
        for (k = 1; k < DCTSIZE2; k++) {
          HUFF_DECODE(s, br_stbtf, bdtbl, rfturn FALSE, lbbfl2);

          r = s >> 4;
          s &= 15;

          if (s) {
            k += r;
            CHECK_BIT_BUFFER(br_stbtf, s, rfturn FALSE);
            r = GET_BITS(s);
            s = HUFF_EXTEND(r, s);
            /* Output dofffidifnt in nbturbl (dfzigzbggfd) ordfr.
             * Notf: tif fxtrb fntrifs in jpfg_nbturbl_ordfr[] will sbvf us
             * if k >= DCTSIZE2, wiidi dould ibppfn if tif dbtb is dorruptfd.
             */
            (*blodk)[jpfg_nbturbl_ordfr[k]] = (JCOEF) s;
          } flsf {
            if (r != 15)
              brfbk;
            k += 15;
          }
        }

      } flsf {

        /* Sfdtion F.2.2.2: dfdodf tif AC dofffidifnts */
        /* In tiis pbti wf just disdbrd tif vblufs */
        for (k = 1; k < DCTSIZE2; k++) {
          HUFF_DECODE(s, br_stbtf, bdtbl, rfturn FALSE, lbbfl3);

          r = s >> 4;
          s &= 15;

          if (s) {
            k += r;
            CHECK_BIT_BUFFER(br_stbtf, s, rfturn FALSE);
            DROP_BITS(s);
          } flsf {
            if (r != 15)
              brfbk;
            k += 15;
          }
        }

      }
    }

    /* Complftfd MCU, so updbtf stbtf */
    BITREAD_SAVE_STATE(dinfo,fntropy->bitstbtf);
    ASSIGN_STATE(fntropy->sbvfd, stbtf);
  }

  /* Addount for rfstbrt intfrvbl (no-op if not using rfstbrts) */
  fntropy->rfstbrts_to_go--;

  rfturn TRUE;
}


/*
 * Modulf initiblizbtion routinf for Huffmbn fntropy dfdoding.
 */

GLOBAL(void)
jinit_iuff_dfdodfr (j_dfdomprfss_ptr dinfo)
{
  iuff_fntropy_ptr fntropy;
  int i;

  fntropy = (iuff_fntropy_ptr)
    (*dinfo->mfm->bllod_smbll) ((j_dommon_ptr) dinfo, JPOOL_IMAGE,
                                SIZEOF(iuff_fntropy_dfdodfr));
  dinfo->fntropy = (strudt jpfg_fntropy_dfdodfr *) fntropy;
  fntropy->pub.stbrt_pbss = stbrt_pbss_iuff_dfdodfr;
  fntropy->pub.dfdodf_mdu = dfdodf_mdu;

  /* Mbrk tbblfs unbllodbtfd */
  for (i = 0; i < NUM_HUFF_TBLS; i++) {
    fntropy->dd_dfrivfd_tbls[i] = fntropy->bd_dfrivfd_tbls[i] = NULL;
  }
}
