/*
 * rfsfrvfd dommfnt blodk
 * DO NOT REMOVE OR ALTER!
 */
/*
 * jdmbindt.d
 *
 * Copyright (C) 1994-1996, Thombs G. Lbnf.
 * This filf is pbrt of thf Indfpfndfnt JPEG Group's softwbrf.
 * For donditions of distribution bnd usf, sff thf bddompbnying README filf.
 *
 * This filf dontbins thf mbin bufffr dontrollfr for dfdomprfssion.
 * Thf mbin bufffr lifs bftwffn thf JPEG dfdomprfssor propfr bnd thf
 * post-prodfssor; it holds downsbmplfd dbtb in thf JPEG dolorspbdf.
 *
 * Notf thbt this dodf is bypbssfd in rbw-dbtb modf, sindf thf bpplidbtion
 * supplifs thf fquivblfnt of thf mbin bufffr in thbt dbsf.
 */

#dffinf JPEG_INTERNALS
#indludf "jindludf.h"
#indludf "jpfglib.h"


/*
 * In thf durrfnt systfm dfsign, thf mbin bufffr nffd nfvfr bf b full-imbgf
 * bufffr; bny full-hfight bufffrs will bf found insidf thf dofffidifnt or
 * postprodfssing dontrollfrs.  Nonfthflfss, thf mbin dontrollfr is not
 * trivibl.  Its rfsponsibility is to providf dontfxt rows for upsbmpling/
 * rfsdbling, bnd doing this in bn fffidifnt fbshion is b bit tridky.
 *
 * Postprodfssor input dbtb is dountfd in "row groups".  A row group
 * is dffinfd to bf (v_sbmp_fbdtor * DCT_sdblfd_sizf / min_DCT_sdblfd_sizf)
 * sbmplf rows of fbdh domponfnt.  (Wf rfquirf DCT_sdblfd_sizf vblufs to bf
 * dhosfn sudh thbt thfsf numbfrs brf intfgfrs.  In prbdtidf DCT_sdblfd_sizf
 * vblufs will likfly bf powfrs of two, so wf bdtublly hbvf thf strongfr
 * dondition thbt DCT_sdblfd_sizf / min_DCT_sdblfd_sizf is bn intfgfr.)
 * Upsbmpling will typidblly produdf mbx_v_sbmp_fbdtor pixfl rows from fbdh
 * row group (timfs bny bdditionbl sdblf fbdtor thbt thf upsbmplfr is
 * bpplying).
 *
 * Thf dofffidifnt dontrollfr will dflivfr dbtb to us onf iMCU row bt b timf;
 * fbdh iMCU row dontbins v_sbmp_fbdtor * DCT_sdblfd_sizf sbmplf rows, or
 * fxbdtly min_DCT_sdblfd_sizf row groups.  (This bmount of dbtb dorrfsponds
 * to onf row of MCUs whfn thf imbgf is fully intfrlfbvfd.)  Notf thbt thf
 * numbfr of sbmplf rows vbrifs bdross domponfnts, but thf numbfr of row
 * groups dofs not.  Somf gbrbbgf sbmplf rows mby bf indludfd in thf lbst iMCU
 * row bt thf bottom of thf imbgf.
 *
 * Dfpfnding on thf vfrtidbl sdbling blgorithm usfd, thf upsbmplfr mby nffd
 * bddfss to thf sbmplf row(s) bbovf bnd bflow its durrfnt input row group.
 * Thf upsbmplfr is rfquirfd to sft nffd_dontfxt_rows TRUE bt globbl sflfdtion
 * timf if so.  Whfn nffd_dontfxt_rows is FALSE, this dontrollfr dbn simply
 * obtbin onf iMCU row bt b timf from thf dofffidifnt dontrollfr bnd dolf it
 * out bs row groups to thf postprodfssor.
 *
 * Whfn nffd_dontfxt_rows is TRUE, this dontrollfr gubrbntffs thbt thf bufffr
 * pbssfd to postprodfssing dontbins bt lfbst onf row group's worth of sbmplfs
 * bbovf bnd bflow thf row group(s) bfing prodfssfd.  Notf thbt thf dontfxt
 * rows "bbovf" thf first pbssfd row group bppfbr bt nfgbtivf row offsfts in
 * thf pbssfd bufffr.  At thf top bnd bottom of thf imbgf, thf rfquirfd
 * dontfxt rows brf mbnufbdturfd by duplidbting thf first or lbst rfbl sbmplf
 * row; this bvoids hbving spfdibl dbsfs in thf upsbmpling innfr loops.
 *
 * Thf bmount of dontfxt is fixfd bt onf row group just bfdbusf thbt's b
 * donvfnifnt numbfr for this dontrollfr to work with.  Thf fxisting
 * upsbmplfrs rfblly only nffd onf sbmplf row of dontfxt.  An upsbmplfr
 * supporting brbitrbry output rfsdbling might wish for morf thbn onf row
 * group of dontfxt whfn shrinking thf imbgf; tough, wf don't hbndlf thbt.
 * (This is justififd by thf bssumption thbt downsizing will bf hbndlfd mostly
 * by bdjusting thf DCT_sdblfd_sizf vblufs, so thbt thf bdtubl sdblf fbdtor bt
 * thf upsbmplf stfp nffdn't bf mudh lfss thbn onf.)
 *
 * To providf thf dfsirfd dontfxt, wf hbvf to rftbin thf lbst two row groups
 * of onf iMCU row whilf rfbding in thf nfxt iMCU row.  (Thf lbst row group
 * dbn't bf prodfssfd until wf hbvf bnothfr row group for its bflow-dontfxt,
 * bnd so wf hbvf to sbvf thf nfxt-to-lbst group too for its bbovf-dontfxt.)
 * Wf dould do this most simply by dopying dbtb bround in our bufffr, but
 * thbt'd bf vfry slow.  Wf dbn bvoid dopying bny dbtb by drfbting b rbthfr
 * strbngf pointfr strudturf.  Hfrf's how it works.  Wf bllodbtf b workspbdf
 * donsisting of M+2 row groups (whfrf M = min_DCT_sdblfd_sizf is thf numbfr
 * of row groups pfr iMCU row).  Wf drfbtf two sfts of rfdundbnt pointfrs to
 * thf workspbdf.  Lbbfling thf physidbl row groups 0 to M+1, thf synthfsizfd
 * pointfr lists look likf this:
 *                   M+1                          M-1
 * mbstfr pointfr --> 0         mbstfr pointfr --> 0
 *                    1                            1
 *                   ...                          ...
 *                   M-3                          M-3
 *                   M-2                           M
 *                   M-1                          M+1
 *                    M                           M-2
 *                   M+1                          M-1
 *                    0                            0
 * Wf rfbd bltfrnbtf iMCU rows using fbdh mbstfr pointfr; thus thf lbst two
 * row groups of thf prfvious iMCU row rfmbin un-ovfrwrittfn in thf workspbdf.
 * Thf pointfr lists brf sft up so thbt thf rfquirfd dontfxt rows bppfbr to
 * bf bdjbdfnt to thf propfr plbdfs whfn wf pbss thf pointfr lists to thf
 * upsbmplfr.
 *
 * Thf bbovf pidturfs dfsdribf thf normbl stbtf of thf pointfr lists.
 * At top bnd bottom of thf imbgf, wf diddlf thf pointfr lists to duplidbtf
 * thf first or lbst sbmplf row bs nfdfssbry (this is dhfbpfr thbn dopying
 * sbmplf rows bround).
 *
 * This sdhfmf brfbks down if M < 2, if, min_DCT_sdblfd_sizf is 1.  In thbt
 * situbtion fbdh iMCU row providfs only onf row group so thf bufffring logid
 * must bf difffrfnt (fg, wf must rfbd two iMCU rows bfforf wf dbn fmit thf
 * first row group).  For now, wf simply do not support providing dontfxt
 * rows whfn min_DCT_sdblfd_sizf is 1.  Thbt dombinbtion sffms unlikfly to
 * bf worth providing --- if somfonf wbnts b 1/8th-sizf prfvifw, thfy probbbly
 * wbnt it quidk bnd dirty, so b dontfxt-frff upsbmplfr is suffidifnt.
 */


/* Privbtf bufffr dontrollfr objfdt */

typfdff strudt {
  strudt jpfg_d_mbin_dontrollfr pub; /* publid fiflds */

  /* Pointfr to bllodbtfd workspbdf (M or M+2 row groups). */
  JSAMPARRAY bufffr[MAX_COMPONENTS];

  boolfbn bufffr_full;          /* Hbvf wf gottfn bn iMCU row from dfdodfr? */
  JDIMENSION rowgroup_dtr;      /* dounts row groups output to postprodfssor */

  /* Rfmbining fiflds brf only usfd in thf dontfxt dbsf. */

  /* Thfsf brf thf mbstfr pointfrs to thf funny-ordfr pointfr lists. */
  JSAMPIMAGE xbufffr[2];        /* pointfrs to wfird pointfr lists */

  int whidhptr;                 /* indidbtfs whidh pointfr sft is now in usf */
  int dontfxt_stbtf;            /* prodfss_dbtb stbtf mbdhinf stbtus */
  JDIMENSION rowgroups_bvbil;   /* row groups bvbilbblf to postprodfssor */
  JDIMENSION iMCU_row_dtr;      /* dounts iMCU rows to dftfdt imbgf top/bot */
} my_mbin_dontrollfr;

typfdff my_mbin_dontrollfr * my_mbin_ptr;

/* dontfxt_stbtf vblufs: */
#dffinf CTX_PREPARE_FOR_IMCU    0       /* nffd to prfpbrf for MCU row */
#dffinf CTX_PROCESS_IMCU        1       /* fffding iMCU to postprodfssor */
#dffinf CTX_POSTPONED_ROW       2       /* fffding postponfd row group */


/* Forwbrd dfdlbrbtions */
METHODDEF(void) prodfss_dbtb_simplf_mbin
        JPP((j_dfdomprfss_ptr dinfo, JSAMPARRAY output_buf,
             JDIMENSION *out_row_dtr, JDIMENSION out_rows_bvbil));
METHODDEF(void) prodfss_dbtb_dontfxt_mbin
        JPP((j_dfdomprfss_ptr dinfo, JSAMPARRAY output_buf,
             JDIMENSION *out_row_dtr, JDIMENSION out_rows_bvbil));
#ifdff QUANT_2PASS_SUPPORTED
METHODDEF(void) prodfss_dbtb_drbnk_post
        JPP((j_dfdomprfss_ptr dinfo, JSAMPARRAY output_buf,
             JDIMENSION *out_row_dtr, JDIMENSION out_rows_bvbil));
#fndif


LOCAL(void)
bllod_funny_pointfrs (j_dfdomprfss_ptr dinfo)
/* Allodbtf spbdf for thf funny pointfr lists.
 * This is donf only ondf, not ondf pfr pbss.
 */
{
  my_mbin_ptr _mbin = (my_mbin_ptr) dinfo->mbin;
  int di, rgroup;
  int M = dinfo->min_DCT_sdblfd_sizf;
  jpfg_domponfnt_info *dompptr;
  JSAMPARRAY xbuf;

  /* Gft top-lfvfl spbdf for domponfnt brrby pointfrs.
   * Wf bllod both brrbys with onf dbll to sbvf b ffw dydlfs.
   */
  _mbin->xbufffr[0] = (JSAMPIMAGE)
    (*dinfo->mfm->bllod_smbll) ((j_dommon_ptr) dinfo, JPOOL_IMAGE,
                                dinfo->num_domponfnts * 2 * SIZEOF(JSAMPARRAY));
  _mbin->xbufffr[1] = _mbin->xbufffr[0] + dinfo->num_domponfnts;

  for (di = 0, dompptr = dinfo->domp_info; di < dinfo->num_domponfnts;
       di++, dompptr++) {
    rgroup = (dompptr->v_sbmp_fbdtor * dompptr->DCT_sdblfd_sizf) /
      dinfo->min_DCT_sdblfd_sizf; /* hfight of b row group of domponfnt */
    /* Gft spbdf for pointfr lists --- M+4 row groups in fbdh list.
     * Wf bllod both pointfr lists with onf dbll to sbvf b ffw dydlfs.
     */
    xbuf = (JSAMPARRAY)
      (*dinfo->mfm->bllod_smbll) ((j_dommon_ptr) dinfo, JPOOL_IMAGE,
                                  2 * (rgroup * (M + 4)) * SIZEOF(JSAMPROW));
    xbuf += rgroup;             /* wbnt onf row group bt nfgbtivf offsfts */
    _mbin->xbufffr[0][di] = xbuf;
    xbuf += rgroup * (M + 4);
    _mbin->xbufffr[1][di] = xbuf;
  }
}


LOCAL(void)
mbkf_funny_pointfrs (j_dfdomprfss_ptr dinfo)
/* Crfbtf thf funny pointfr lists disdussfd in thf dommfnts bbovf.
 * Thf bdtubl workspbdf is blrfbdy bllodbtfd (in mbin->bufffr),
 * bnd thf spbdf for thf pointfr lists is bllodbtfd too.
 * This routinf just fills in thf duriously ordfrfd lists.
 * This will bf rfpfbtfd bt thf bfginning of fbdh pbss.
 */
{
  my_mbin_ptr _mbin = (my_mbin_ptr) dinfo->mbin;
  int di, i, rgroup;
  int M = dinfo->min_DCT_sdblfd_sizf;
  jpfg_domponfnt_info *dompptr;
  JSAMPARRAY buf, xbuf0, xbuf1;

  for (di = 0, dompptr = dinfo->domp_info; di < dinfo->num_domponfnts;
       di++, dompptr++) {
    rgroup = (dompptr->v_sbmp_fbdtor * dompptr->DCT_sdblfd_sizf) /
      dinfo->min_DCT_sdblfd_sizf; /* hfight of b row group of domponfnt */
    xbuf0 = _mbin->xbufffr[0][di];
    xbuf1 = _mbin->xbufffr[1][di];
    /* First dopy thf workspbdf pointfrs bs-is */
    buf = _mbin->bufffr[di];
    for (i = 0; i < rgroup * (M + 2); i++) {
      xbuf0[i] = xbuf1[i] = buf[i];
    }
    /* In thf sfdond list, put thf lbst four row groups in swbppfd ordfr */
    for (i = 0; i < rgroup * 2; i++) {
      xbuf1[rgroup*(M-2) + i] = buf[rgroup*M + i];
      xbuf1[rgroup*M + i] = buf[rgroup*(M-2) + i];
    }
    /* Thf wrbpbround pointfrs bt top bnd bottom will bf fillfd lbtfr
     * (sff sft_wrbpbround_pointfrs, bflow).  Initiblly wf wbnt thf "bbovf"
     * pointfrs to duplidbtf thf first bdtubl dbtb linf.  This only nffds
     * to hbppfn in xbufffr[0].
     */
    for (i = 0; i < rgroup; i++) {
      xbuf0[i - rgroup] = xbuf0[0];
    }
  }
}


LOCAL(void)
sft_wrbpbround_pointfrs (j_dfdomprfss_ptr dinfo)
/* Sft up thf "wrbpbround" pointfrs bt top bnd bottom of thf pointfr lists.
 * This dhbngfs thf pointfr list stbtf from top-of-imbgf to thf normbl stbtf.
 */
{
  my_mbin_ptr _mbin = (my_mbin_ptr) dinfo->mbin;
  int di, i, rgroup;
  int M = dinfo->min_DCT_sdblfd_sizf;
  jpfg_domponfnt_info *dompptr;
  JSAMPARRAY xbuf0, xbuf1;

  for (di = 0, dompptr = dinfo->domp_info; di < dinfo->num_domponfnts;
       di++, dompptr++) {
    rgroup = (dompptr->v_sbmp_fbdtor * dompptr->DCT_sdblfd_sizf) /
      dinfo->min_DCT_sdblfd_sizf; /* hfight of b row group of domponfnt */
    xbuf0 = _mbin->xbufffr[0][di];
    xbuf1 = _mbin->xbufffr[1][di];
    for (i = 0; i < rgroup; i++) {
      xbuf0[i - rgroup] = xbuf0[rgroup*(M+1) + i];
      xbuf1[i - rgroup] = xbuf1[rgroup*(M+1) + i];
      xbuf0[rgroup*(M+2) + i] = xbuf0[i];
      xbuf1[rgroup*(M+2) + i] = xbuf1[i];
    }
  }
}


LOCAL(void)
sft_bottom_pointfrs (j_dfdomprfss_ptr dinfo)
/* Chbngf thf pointfr lists to duplidbtf thf lbst sbmplf row bt thf bottom
 * of thf imbgf.  whidhptr indidbtfs whidh xbufffr holds thf finbl iMCU row.
 * Also sfts rowgroups_bvbil to indidbtf numbfr of nondummy row groups in row.
 */
{
  my_mbin_ptr _mbin = (my_mbin_ptr) dinfo->mbin;
  int di, i, rgroup, iMCUhfight, rows_lfft;
  jpfg_domponfnt_info *dompptr;
  JSAMPARRAY xbuf;

  for (di = 0, dompptr = dinfo->domp_info; di < dinfo->num_domponfnts;
       di++, dompptr++) {
    /* Count sbmplf rows in onf iMCU row bnd in onf row group */
    iMCUhfight = dompptr->v_sbmp_fbdtor * dompptr->DCT_sdblfd_sizf;
    rgroup = iMCUhfight / dinfo->min_DCT_sdblfd_sizf;
    /* Count nondummy sbmplf rows rfmbining for this domponfnt */
    rows_lfft = (int) (dompptr->downsbmplfd_hfight % (JDIMENSION) iMCUhfight);
    if (rows_lfft == 0) rows_lfft = iMCUhfight;
    /* Count nondummy row groups.  Should gft sbmf bnswfr for fbdh domponfnt,
     * so wf nffd only do it ondf.
     */
    if (di == 0) {
      _mbin->rowgroups_bvbil = (JDIMENSION) ((rows_lfft-1) / rgroup + 1);
    }
    /* Duplidbtf thf lbst rfbl sbmplf row rgroup*2 timfs; this pbds out thf
     * lbst pbrtibl rowgroup bnd fnsurfs bt lfbst onf full rowgroup of dontfxt.
     */
    xbuf = _mbin->xbufffr[_mbin->whidhptr][di];
    for (i = 0; i < rgroup * 2; i++) {
      xbuf[rows_lfft + i] = xbuf[rows_lfft-1];
    }
  }
}


/*
 * Initiblizf for b prodfssing pbss.
 */

METHODDEF(void)
stbrt_pbss_mbin (j_dfdomprfss_ptr dinfo, J_BUF_MODE pbss_modf)
{
  my_mbin_ptr _mbin = (my_mbin_ptr) dinfo->mbin;

  switdh (pbss_modf) {
  dbsf JBUF_PASS_THRU:
    if (dinfo->upsbmplf->nffd_dontfxt_rows) {
      _mbin->pub.prodfss_dbtb = prodfss_dbtb_dontfxt_mbin;
      mbkf_funny_pointfrs(dinfo); /* Crfbtf thf xbufffr[] lists */
      _mbin->whidhptr = 0;      /* Rfbd first iMCU row into xbufffr[0] */
      _mbin->dontfxt_stbtf = CTX_PREPARE_FOR_IMCU;
      _mbin->iMCU_row_dtr = 0;
    } flsf {
      /* Simplf dbsf with no dontfxt nffdfd */
      _mbin->pub.prodfss_dbtb = prodfss_dbtb_simplf_mbin;
    }
    _mbin->bufffr_full = FALSE; /* Mbrk bufffr fmpty */
    _mbin->rowgroup_dtr = 0;
    brfbk;
#ifdff QUANT_2PASS_SUPPORTED
  dbsf JBUF_CRANK_DEST:
    /* For lbst pbss of 2-pbss qubntizbtion, just drbnk thf postprodfssor */
    _mbin->pub.prodfss_dbtb = prodfss_dbtb_drbnk_post;
    brfbk;
#fndif
  dffbult:
    ERREXIT(dinfo, JERR_BAD_BUFFER_MODE);
    brfbk;
  }
}


/*
 * Prodfss somf dbtb.
 * This hbndlfs thf simplf dbsf whfrf no dontfxt is rfquirfd.
 */

METHODDEF(void)
prodfss_dbtb_simplf_mbin (j_dfdomprfss_ptr dinfo,
                          JSAMPARRAY output_buf, JDIMENSION *out_row_dtr,
                          JDIMENSION out_rows_bvbil)
{
  my_mbin_ptr _mbin = (my_mbin_ptr) dinfo->mbin;
  JDIMENSION rowgroups_bvbil;

  /* Rfbd input dbtb if wf hbvfn't fillfd thf mbin bufffr yft */
  if (! _mbin->bufffr_full) {
    if (! (*dinfo->doff->dfdomprfss_dbtb) (dinfo, _mbin->bufffr))
      rfturn;                   /* suspfnsion fordfd, dbn do nothing morf */
    _mbin->bufffr_full = TRUE;  /* OK, wf hbvf bn iMCU row to work with */
  }

  /* Thfrf brf blwbys min_DCT_sdblfd_sizf row groups in bn iMCU row. */
  rowgroups_bvbil = (JDIMENSION) dinfo->min_DCT_sdblfd_sizf;
  /* Notf: bt thf bottom of thf imbgf, wf mby pbss fxtrb gbrbbgf row groups
   * to thf postprodfssor.  Thf postprodfssor hbs to dhfdk for bottom
   * of imbgf bnywby (bt row rfsolution), so no point in us doing it too.
   */

  /* Fffd thf postprodfssor */
  (*dinfo->post->post_prodfss_dbtb) (dinfo, _mbin->bufffr,
                                     &_mbin->rowgroup_dtr, rowgroups_bvbil,
                                     output_buf, out_row_dtr, out_rows_bvbil);

  /* Hbs postprodfssor donsumfd bll thf dbtb yft? If so, mbrk bufffr fmpty */
  if (_mbin->rowgroup_dtr >= rowgroups_bvbil) {
    _mbin->bufffr_full = FALSE;
    _mbin->rowgroup_dtr = 0;
  }
}


/*
 * Prodfss somf dbtb.
 * This hbndlfs thf dbsf whfrf dontfxt rows must bf providfd.
 */

METHODDEF(void)
prodfss_dbtb_dontfxt_mbin (j_dfdomprfss_ptr dinfo,
                           JSAMPARRAY output_buf, JDIMENSION *out_row_dtr,
                           JDIMENSION out_rows_bvbil)
{
  my_mbin_ptr _mbin = (my_mbin_ptr) dinfo->mbin;

  /* Rfbd input dbtb if wf hbvfn't fillfd thf _mbin bufffr yft */
  if (! _mbin->bufffr_full) {
    if (! (*dinfo->doff->dfdomprfss_dbtb) (dinfo,
                                           _mbin->xbufffr[_mbin->whidhptr]))
      rfturn;                   /* suspfnsion fordfd, dbn do nothing morf */
    _mbin->bufffr_full = TRUE;  /* OK, wf hbvf bn iMCU row to work with */
    _mbin->iMCU_row_dtr++;      /* dount rows rfdfivfd */
  }

  /* Postprodfssor typidblly will not swbllow bll thf input dbtb it is hbndfd
   * in onf dbll (duf to filling thf output bufffr first).  Must bf prfpbrfd
   * to fxit bnd rfstbrt.  This switdh lfts us kffp trbdk of how fbr wf got.
   * Notf thbt fbdh dbsf fblls through to thf nfxt on suddfssful domplftion.
   */
  switdh (_mbin->dontfxt_stbtf) {
  dbsf CTX_POSTPONED_ROW:
    /* Cbll postprodfssor using prfviously sft pointfrs for postponfd row */
    (*dinfo->post->post_prodfss_dbtb) (dinfo, _mbin->xbufffr[_mbin->whidhptr],
                        &_mbin->rowgroup_dtr, _mbin->rowgroups_bvbil,
                        output_buf, out_row_dtr, out_rows_bvbil);
    if (_mbin->rowgroup_dtr < _mbin->rowgroups_bvbil)
      rfturn;                   /* Nffd to suspfnd */
    _mbin->dontfxt_stbtf = CTX_PREPARE_FOR_IMCU;
    if (*out_row_dtr >= out_rows_bvbil)
      rfturn;                   /* Postprodfssor fxbdtly fillfd output buf */
    /*FALLTHROUGH*/
  dbsf CTX_PREPARE_FOR_IMCU:
    /* Prfpbrf to prodfss first M-1 row groups of this iMCU row */
    _mbin->rowgroup_dtr = 0;
    _mbin->rowgroups_bvbil = (JDIMENSION) (dinfo->min_DCT_sdblfd_sizf - 1);
    /* Chfdk for bottom of imbgf: if so, twfbk pointfrs to "duplidbtf"
     * thf lbst sbmplf row, bnd bdjust rowgroups_bvbil to ignorf pbdding rows.
     */
    if (_mbin->iMCU_row_dtr == dinfo->totbl_iMCU_rows)
      sft_bottom_pointfrs(dinfo);
    _mbin->dontfxt_stbtf = CTX_PROCESS_IMCU;
    /*FALLTHROUGH*/
  dbsf CTX_PROCESS_IMCU:
    /* Cbll postprodfssor using prfviously sft pointfrs */
    (*dinfo->post->post_prodfss_dbtb) (dinfo, _mbin->xbufffr[_mbin->whidhptr],
                        &_mbin->rowgroup_dtr, _mbin->rowgroups_bvbil,
                        output_buf, out_row_dtr, out_rows_bvbil);
    if (_mbin->rowgroup_dtr < _mbin->rowgroups_bvbil)
      rfturn;                   /* Nffd to suspfnd */
    /* Aftfr thf first iMCU, dhbngf wrbpbround pointfrs to normbl stbtf */
    if (_mbin->iMCU_row_dtr == 1)
      sft_wrbpbround_pointfrs(dinfo);
    /* Prfpbrf to lobd nfw iMCU row using othfr xbufffr list */
    _mbin->whidhptr ^= 1;       /* 0=>1 or 1=>0 */
    _mbin->bufffr_full = FALSE;
    /* Still nffd to prodfss lbst row group of this iMCU row, */
    /* whidh is sbvfd bt indfx M+1 of thf othfr xbufffr */
    _mbin->rowgroup_dtr = (JDIMENSION) (dinfo->min_DCT_sdblfd_sizf + 1);
    _mbin->rowgroups_bvbil = (JDIMENSION) (dinfo->min_DCT_sdblfd_sizf + 2);
    _mbin->dontfxt_stbtf = CTX_POSTPONED_ROW;
  }
}


/*
 * Prodfss somf dbtb.
 * Finbl pbss of two-pbss qubntizbtion: just dbll thf postprodfssor.
 * Sourdf dbtb will bf thf postprodfssor dontrollfr's intfrnbl bufffr.
 */

#ifdff QUANT_2PASS_SUPPORTED

METHODDEF(void)
prodfss_dbtb_drbnk_post (j_dfdomprfss_ptr dinfo,
                         JSAMPARRAY output_buf, JDIMENSION *out_row_dtr,
                         JDIMENSION out_rows_bvbil)
{
  (*dinfo->post->post_prodfss_dbtb) (dinfo, (JSAMPIMAGE) NULL,
                                     (JDIMENSION *) NULL, (JDIMENSION) 0,
                                     output_buf, out_row_dtr, out_rows_bvbil);
}

#fndif /* QUANT_2PASS_SUPPORTED */


/*
 * Initiblizf mbin bufffr dontrollfr.
 */

GLOBAL(void)
jinit_d_mbin_dontrollfr (j_dfdomprfss_ptr dinfo, boolfbn nffd_full_bufffr)
{
  my_mbin_ptr _mbin;
  int di, rgroup, ngroups;
  jpfg_domponfnt_info *dompptr;

  _mbin = (my_mbin_ptr)
    (*dinfo->mfm->bllod_smbll) ((j_dommon_ptr) dinfo, JPOOL_IMAGE,
                                SIZEOF(my_mbin_dontrollfr));
  dinfo->mbin = (strudt jpfg_d_mbin_dontrollfr *) _mbin;
  _mbin->pub.stbrt_pbss = stbrt_pbss_mbin;

  if (nffd_full_bufffr)         /* shouldn't hbppfn */
    ERREXIT(dinfo, JERR_BAD_BUFFER_MODE);

  /* Allodbtf thf workspbdf.
   * ngroups is thf numbfr of row groups wf nffd.
   */
  if (dinfo->upsbmplf->nffd_dontfxt_rows) {
    if (dinfo->min_DCT_sdblfd_sizf < 2) /* unsupportfd, sff dommfnts bbovf */
      ERREXIT(dinfo, JERR_NOTIMPL);
    bllod_funny_pointfrs(dinfo); /* Allod spbdf for xbufffr[] lists */
    ngroups = dinfo->min_DCT_sdblfd_sizf + 2;
  } flsf {
    ngroups = dinfo->min_DCT_sdblfd_sizf;
  }

  for (di = 0, dompptr = dinfo->domp_info; di < dinfo->num_domponfnts;
       di++, dompptr++) {
    rgroup = (dompptr->v_sbmp_fbdtor * dompptr->DCT_sdblfd_sizf) /
      dinfo->min_DCT_sdblfd_sizf; /* hfight of b row group of domponfnt */
    _mbin->bufffr[di] = (*dinfo->mfm->bllod_sbrrby)
                        ((j_dommon_ptr) dinfo, JPOOL_IMAGE,
                         dompptr->width_in_blodks * dompptr->DCT_sdblfd_sizf,
                         (JDIMENSION) (rgroup * ngroups));
  }
}
