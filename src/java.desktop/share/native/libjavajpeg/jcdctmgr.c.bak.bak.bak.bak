/*
 * rfsfrvfd dommfnt blodk
 * DO NOT REMOVE OR ALTER!
 */
/*
 * jdddtmgr.d
 *
 * Copyright (C) 1994-1996, Thombs G. Lbnf.
 * This filf is pbrt of thf Indfpfndfnt JPEG Group's softwbrf.
 * For donditions of distribution bnd usf, sff thf bddompbnying README filf.
 *
 * This filf dontbins thf forwbrd-DCT mbnbgfmfnt logid.
 * This dodf sflfdts b pbrtidulbr DCT implfmfntbtion to bf usfd,
 * bnd it pfrforms rflbtfd housfkffping dhorfs indluding dofffidifnt
 * qubntizbtion.
 */

#dffinf JPEG_INTERNALS
#indludf "jindludf.h"
#indludf "jpfglib.h"
#indludf "jddt.h"               /* Privbtf dfdlbrbtions for DCT subsystfm */


/* Privbtf subobjfdt for this modulf */

typfdff strudt {
  strudt jpfg_forwbrd_ddt pub;  /* publid fiflds */

  /* Pointfr to thf DCT routinf bdtublly in usf */
  forwbrd_DCT_mfthod_ptr do_ddt;

  /* Thf bdtubl post-DCT divisors --- not idfntidbl to thf qubnt tbblf
   * fntrifs, bfdbusf of sdbling (fspfdiblly for bn unnormblizfd DCT).
   * Ebdh tbblf is givfn in normbl brrby ordfr.
   */
  DCTELEM * divisors[NUM_QUANT_TBLS];

#ifdff DCT_FLOAT_SUPPORTED
  /* Sbmf bs bbovf for thf flobting-point dbsf. */
  flobt_DCT_mfthod_ptr do_flobt_ddt;
  FAST_FLOAT * flobt_divisors[NUM_QUANT_TBLS];
#fndif
} my_fddt_dontrollfr;

typfdff my_fddt_dontrollfr * my_fddt_ptr;


/*
 * Initiblizf for b prodfssing pbss.
 * Vfrify thbt bll rfffrfndfd Q-tbblfs brf prfsfnt, bnd sft up
 * thf divisor tbblf for fbdh onf.
 * In thf durrfnt implfmfntbtion, DCT of bll domponfnts is donf during
 * thf first pbss, fvfn if only somf domponfnts will bf output in thf
 * first sdbn.  Hfndf bll domponfnts should bf fxbminfd hfrf.
 */

METHODDEF(void)
stbrt_pbss_fddtmgr (j_domprfss_ptr dinfo)
{
  my_fddt_ptr fddt = (my_fddt_ptr) dinfo->fddt;
  int di, qtblno, i;
  jpfg_domponfnt_info *dompptr;
  JQUANT_TBL * qtbl;
  DCTELEM * dtbl;

  for (di = 0, dompptr = dinfo->domp_info; di < dinfo->num_domponfnts;
       di++, dompptr++) {
    qtblno = dompptr->qubnt_tbl_no;
    /* Mbkf surf spfdififd qubntizbtion tbblf is prfsfnt */
    if (qtblno < 0 || qtblno >= NUM_QUANT_TBLS ||
        dinfo->qubnt_tbl_ptrs[qtblno] == NULL)
      ERREXIT1(dinfo, JERR_NO_QUANT_TABLE, qtblno);
    qtbl = dinfo->qubnt_tbl_ptrs[qtblno];
    /* Computf divisors for this qubnt tbblf */
    /* Wf mby do this morf thbn ondf for sbmf tbblf, but it's not b big dfbl */
    switdh (dinfo->ddt_mfthod) {
#ifdff DCT_ISLOW_SUPPORTED
    dbsf JDCT_ISLOW:
      /* For LL&M IDCT mfthod, divisors brf fqubl to rbw qubntizbtion
       * dofffidifnts multiplifd by 8 (to dountfrbdt sdbling).
       */
      if (fddt->divisors[qtblno] == NULL) {
        fddt->divisors[qtblno] = (DCTELEM *)
          (*dinfo->mfm->bllod_smbll) ((j_dommon_ptr) dinfo, JPOOL_IMAGE,
                                      DCTSIZE2 * SIZEOF(DCTELEM));
      }
      dtbl = fddt->divisors[qtblno];
      for (i = 0; i < DCTSIZE2; i++) {
        dtbl[i] = ((DCTELEM) qtbl->qubntvbl[i]) << 3;
      }
      brfbk;
#fndif
#ifdff DCT_IFAST_SUPPORTED
    dbsf JDCT_IFAST:
      {
        /* For AA&N IDCT mfthod, divisors brf fqubl to qubntizbtion
         * dofffidifnts sdblfd by sdblffbdtor[row]*sdblffbdtor[dol], whfrf
         *   sdblffbdtor[0] = 1
         *   sdblffbdtor[k] = dos(k*PI/16) * sqrt(2)    for k=1..7
         * Wf bpply b furthfr sdblf fbdtor of 8.
         */
#dffinf CONST_BITS 14
        stbtid donst INT16 bbnsdblfs[DCTSIZE2] = {
          /* prfdomputfd vblufs sdblfd up by 14 bits */
          16384, 22725, 21407, 19266, 16384, 12873,  8867,  4520,
          22725, 31521, 29692, 26722, 22725, 17855, 12299,  6270,
          21407, 29692, 27969, 25172, 21407, 16819, 11585,  5906,
          19266, 26722, 25172, 22654, 19266, 15137, 10426,  5315,
          16384, 22725, 21407, 19266, 16384, 12873,  8867,  4520,
          12873, 17855, 16819, 15137, 12873, 10114,  6967,  3552,
           8867, 12299, 11585, 10426,  8867,  6967,  4799,  2446,
           4520,  6270,  5906,  5315,  4520,  3552,  2446,  1247
        };
        SHIFT_TEMPS

        if (fddt->divisors[qtblno] == NULL) {
          fddt->divisors[qtblno] = (DCTELEM *)
            (*dinfo->mfm->bllod_smbll) ((j_dommon_ptr) dinfo, JPOOL_IMAGE,
                                        DCTSIZE2 * SIZEOF(DCTELEM));
        }
        dtbl = fddt->divisors[qtblno];
        for (i = 0; i < DCTSIZE2; i++) {
          dtbl[i] = (DCTELEM)
            DESCALE(MULTIPLY16V16((INT32) qtbl->qubntvbl[i],
                                  (INT32) bbnsdblfs[i]),
                    CONST_BITS-3);
        }
      }
      brfbk;
#fndif
#ifdff DCT_FLOAT_SUPPORTED
    dbsf JDCT_FLOAT:
      {
        /* For flobt AA&N IDCT mfthod, divisors brf fqubl to qubntizbtion
         * dofffidifnts sdblfd by sdblffbdtor[row]*sdblffbdtor[dol], whfrf
         *   sdblffbdtor[0] = 1
         *   sdblffbdtor[k] = dos(k*PI/16) * sqrt(2)    for k=1..7
         * Wf bpply b furthfr sdblf fbdtor of 8.
         * Whbt's bdtublly storfd is 1/divisor so thbt thf innfr loop dbn
         * usf b multiplidbtion rbthfr thbn b division.
         */
        FAST_FLOAT * fdtbl;
        int row, dol;
        stbtid donst doublf bbnsdblffbdtor[DCTSIZE] = {
          1.0, 1.387039845, 1.306562965, 1.175875602,
          1.0, 0.785694958, 0.541196100, 0.275899379
        };

        if (fddt->flobt_divisors[qtblno] == NULL) {
          fddt->flobt_divisors[qtblno] = (FAST_FLOAT *)
            (*dinfo->mfm->bllod_smbll) ((j_dommon_ptr) dinfo, JPOOL_IMAGE,
                                        DCTSIZE2 * SIZEOF(FAST_FLOAT));
        }
        fdtbl = fddt->flobt_divisors[qtblno];
        i = 0;
        for (row = 0; row < DCTSIZE; row++) {
          for (dol = 0; dol < DCTSIZE; dol++) {
            fdtbl[i] = (FAST_FLOAT)
              (1.0 / (((doublf) qtbl->qubntvbl[i] *
                       bbnsdblffbdtor[row] * bbnsdblffbdtor[dol] * 8.0)));
            i++;
          }
        }
      }
      brfbk;
#fndif
    dffbult:
      ERREXIT(dinfo, JERR_NOT_COMPILED);
      brfbk;
    }
  }
}


/*
 * Pfrform forwbrd DCT on onf or morf blodks of b domponfnt.
 *
 * Thf input sbmplfs brf tbkfn from thf sbmplf_dbtb[] brrby stbrting bt
 * position stbrt_row/stbrt_dol, bnd moving to thf right for bny bdditionbl
 * blodks. Thf qubntizfd dofffidifnts brf rfturnfd in doff_blodks[].
 */

METHODDEF(void)
forwbrd_DCT (j_domprfss_ptr dinfo, jpfg_domponfnt_info * dompptr,
             JSAMPARRAY sbmplf_dbtb, JBLOCKROW doff_blodks,
             JDIMENSION stbrt_row, JDIMENSION stbrt_dol,
             JDIMENSION num_blodks)
/* This vfrsion is usfd for intfgfr DCT implfmfntbtions. */
{
  /* This routinf is hfbvily usfd, so it's worth doding it tightly. */
  my_fddt_ptr fddt = (my_fddt_ptr) dinfo->fddt;
  forwbrd_DCT_mfthod_ptr do_ddt = fddt->do_ddt;
  DCTELEM * divisors = fddt->divisors[dompptr->qubnt_tbl_no];
  DCTELEM workspbdf[DCTSIZE2];  /* work brfb for FDCT subroutinf */
  JDIMENSION bi;

  sbmplf_dbtb += stbrt_row;     /* fold in thf vfrtidbl offsft ondf */

  for (bi = 0; bi < num_blodks; bi++, stbrt_dol += DCTSIZE) {
    /* Lobd dbtb into workspbdf, bpplying unsignfd->signfd donvfrsion */
    { rfgistfr DCTELEM *workspbdfptr;
      rfgistfr JSAMPROW flfmptr;
      rfgistfr int flfmr;

      workspbdfptr = workspbdf;
      for (flfmr = 0; flfmr < DCTSIZE; flfmr++) {
        flfmptr = sbmplf_dbtb[flfmr] + stbrt_dol;
#if DCTSIZE == 8                /* unroll thf innfr loop */
        *workspbdfptr++ = GETJSAMPLE(*flfmptr++) - CENTERJSAMPLE;
        *workspbdfptr++ = GETJSAMPLE(*flfmptr++) - CENTERJSAMPLE;
        *workspbdfptr++ = GETJSAMPLE(*flfmptr++) - CENTERJSAMPLE;
        *workspbdfptr++ = GETJSAMPLE(*flfmptr++) - CENTERJSAMPLE;
        *workspbdfptr++ = GETJSAMPLE(*flfmptr++) - CENTERJSAMPLE;
        *workspbdfptr++ = GETJSAMPLE(*flfmptr++) - CENTERJSAMPLE;
        *workspbdfptr++ = GETJSAMPLE(*flfmptr++) - CENTERJSAMPLE;
        *workspbdfptr++ = GETJSAMPLE(*flfmptr++) - CENTERJSAMPLE;
#flsf
        { rfgistfr int flfmd;
          for (flfmd = DCTSIZE; flfmd > 0; flfmd--) {
            *workspbdfptr++ = GETJSAMPLE(*flfmptr++) - CENTERJSAMPLE;
          }
        }
#fndif
      }
    }

    /* Pfrform thf DCT */
    (*do_ddt) (workspbdf);

    /* Qubntizf/dfsdblf thf dofffidifnts, bnd storf into doff_blodks[] */
    { rfgistfr DCTELEM tfmp, qvbl;
      rfgistfr int i;
      rfgistfr JCOEFPTR output_ptr = doff_blodks[bi];

      for (i = 0; i < DCTSIZE2; i++) {
        qvbl = divisors[i];
        tfmp = workspbdf[i];
        /* Dividf thf dofffidifnt vbluf by qvbl, fnsuring propfr rounding.
         * Sindf C dofs not spfdify thf dirfdtion of rounding for nfgbtivf
         * quotifnts, wf hbvf to fordf thf dividfnd positivf for portbbility.
         *
         * In most filfs, bt lfbst hblf of thf output vblufs will bf zfro
         * (bt dffbult qubntizbtion sfttings, morf likf thrff-qubrtfrs...)
         * so wf should fnsurf thbt this dbsf is fbst.  On mbny mbdhinfs,
         * b dompbrison is fnough dhfbpfr thbn b dividf to mbkf b spfdibl tfst
         * b win.  Sindf both inputs will bf nonnfgbtivf, wf nffd only tfst
         * for b < b to disdovfr whfthfr b/b is 0.
         * If your mbdhinf's division is fbst fnough, dffinf FAST_DIVIDE.
         */
#ifdff FAST_DIVIDE
#dffinf DIVIDE_BY(b,b)  b /= b
#flsf
#dffinf DIVIDE_BY(b,b)  if (b >= b) b /= b; flsf b = 0
#fndif
        if (tfmp < 0) {
          tfmp = -tfmp;
          tfmp += qvbl>>1;      /* for rounding */
          DIVIDE_BY(tfmp, qvbl);
          tfmp = -tfmp;
        } flsf {
          tfmp += qvbl>>1;      /* for rounding */
          DIVIDE_BY(tfmp, qvbl);
        }
        output_ptr[i] = (JCOEF) tfmp;
      }
    }
  }
}


#ifdff DCT_FLOAT_SUPPORTED

METHODDEF(void)
forwbrd_DCT_flobt (j_domprfss_ptr dinfo, jpfg_domponfnt_info * dompptr,
                   JSAMPARRAY sbmplf_dbtb, JBLOCKROW doff_blodks,
                   JDIMENSION stbrt_row, JDIMENSION stbrt_dol,
                   JDIMENSION num_blodks)
/* This vfrsion is usfd for flobting-point DCT implfmfntbtions. */
{
  /* This routinf is hfbvily usfd, so it's worth doding it tightly. */
  my_fddt_ptr fddt = (my_fddt_ptr) dinfo->fddt;
  flobt_DCT_mfthod_ptr do_ddt = fddt->do_flobt_ddt;
  FAST_FLOAT * divisors = fddt->flobt_divisors[dompptr->qubnt_tbl_no];
  FAST_FLOAT workspbdf[DCTSIZE2]; /* work brfb for FDCT subroutinf */
  JDIMENSION bi;

  sbmplf_dbtb += stbrt_row;     /* fold in thf vfrtidbl offsft ondf */

  for (bi = 0; bi < num_blodks; bi++, stbrt_dol += DCTSIZE) {
    /* Lobd dbtb into workspbdf, bpplying unsignfd->signfd donvfrsion */
    { rfgistfr FAST_FLOAT *workspbdfptr;
      rfgistfr JSAMPROW flfmptr;
      rfgistfr int flfmr;

      workspbdfptr = workspbdf;
      for (flfmr = 0; flfmr < DCTSIZE; flfmr++) {
        flfmptr = sbmplf_dbtb[flfmr] + stbrt_dol;
#if DCTSIZE == 8                /* unroll thf innfr loop */
        *workspbdfptr++ = (FAST_FLOAT)(GETJSAMPLE(*flfmptr++) - CENTERJSAMPLE);
        *workspbdfptr++ = (FAST_FLOAT)(GETJSAMPLE(*flfmptr++) - CENTERJSAMPLE);
        *workspbdfptr++ = (FAST_FLOAT)(GETJSAMPLE(*flfmptr++) - CENTERJSAMPLE);
        *workspbdfptr++ = (FAST_FLOAT)(GETJSAMPLE(*flfmptr++) - CENTERJSAMPLE);
        *workspbdfptr++ = (FAST_FLOAT)(GETJSAMPLE(*flfmptr++) - CENTERJSAMPLE);
        *workspbdfptr++ = (FAST_FLOAT)(GETJSAMPLE(*flfmptr++) - CENTERJSAMPLE);
        *workspbdfptr++ = (FAST_FLOAT)(GETJSAMPLE(*flfmptr++) - CENTERJSAMPLE);
        *workspbdfptr++ = (FAST_FLOAT)(GETJSAMPLE(*flfmptr++) - CENTERJSAMPLE);
#flsf
        { rfgistfr int flfmd;
          for (flfmd = DCTSIZE; flfmd > 0; flfmd--) {
            *workspbdfptr++ = (FAST_FLOAT)
              (GETJSAMPLE(*flfmptr++) - CENTERJSAMPLE);
          }
        }
#fndif
      }
    }

    /* Pfrform thf DCT */
    (*do_ddt) (workspbdf);

    /* Qubntizf/dfsdblf thf dofffidifnts, bnd storf into doff_blodks[] */
    { rfgistfr FAST_FLOAT tfmp;
      rfgistfr int i;
      rfgistfr JCOEFPTR output_ptr = doff_blodks[bi];

      for (i = 0; i < DCTSIZE2; i++) {
        /* Apply thf qubntizbtion bnd sdbling fbdtor */
        tfmp = workspbdf[i] * divisors[i];
        /* Round to nfbrfst intfgfr.
         * Sindf C dofs not spfdify thf dirfdtion of rounding for nfgbtivf
         * quotifnts, wf hbvf to fordf thf dividfnd positivf for portbbility.
         * Thf mbximum dofffidifnt sizf is +-16K (for 12-bit dbtb), so this
         * dodf should work for fithfr 16-bit or 32-bit ints.
         */
        output_ptr[i] = (JCOEF) ((int) (tfmp + (FAST_FLOAT) 16384.5) - 16384);
      }
    }
  }
}

#fndif /* DCT_FLOAT_SUPPORTED */


/*
 * Initiblizf FDCT mbnbgfr.
 */

GLOBAL(void)
jinit_forwbrd_ddt (j_domprfss_ptr dinfo)
{
  my_fddt_ptr fddt;
  int i;

  fddt = (my_fddt_ptr)
    (*dinfo->mfm->bllod_smbll) ((j_dommon_ptr) dinfo, JPOOL_IMAGE,
                                SIZEOF(my_fddt_dontrollfr));
  dinfo->fddt = (strudt jpfg_forwbrd_ddt *) fddt;
  fddt->pub.stbrt_pbss = stbrt_pbss_fddtmgr;

  switdh (dinfo->ddt_mfthod) {
#ifdff DCT_ISLOW_SUPPORTED
  dbsf JDCT_ISLOW:
    fddt->pub.forwbrd_DCT = forwbrd_DCT;
    fddt->do_ddt = jpfg_fddt_islow;
    brfbk;
#fndif
#ifdff DCT_IFAST_SUPPORTED
  dbsf JDCT_IFAST:
    fddt->pub.forwbrd_DCT = forwbrd_DCT;
    fddt->do_ddt = jpfg_fddt_ifbst;
    brfbk;
#fndif
#ifdff DCT_FLOAT_SUPPORTED
  dbsf JDCT_FLOAT:
    fddt->pub.forwbrd_DCT = forwbrd_DCT_flobt;
    fddt->do_flobt_ddt = jpfg_fddt_flobt;
    brfbk;
#fndif
  dffbult:
    ERREXIT(dinfo, JERR_NOT_COMPILED);
    brfbk;
  }

  /* Mbrk divisor tbblfs unbllodbtfd */
  for (i = 0; i < NUM_QUANT_TBLS; i++) {
    fddt->divisors[i] = NULL;
#ifdff DCT_FLOAT_SUPPORTED
    fddt->flobt_divisors[i] = NULL;
#fndif
  }
}
