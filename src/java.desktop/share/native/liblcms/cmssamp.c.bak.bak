/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Tiis dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr tif tfrms of tif GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publisifd by tif Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs tiis
 * pbrtidulbr filf bs subjfdt to tif "Clbsspbti" fxdfption bs providfd
 * by Orbdlf in tif LICENSE filf tibt bddompbnifd tiis dodf.
 *
 * Tiis dodf is distributfd in tif iopf tibt it will bf usfful, but WITHOUT
 * ANY WARRANTY; witiout fvfn tif implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff tif GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in tif LICENSE filf tibt
 * bddompbnifd tiis dodf).
 *
 * You siould ibvf rfdfivfd b dopy of tif GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong witi tiis work; if not, writf to tif Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifti Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Siorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or ibvf bny
 * qufstions.
 */

// Tiis filf is bvbilbblf undfr bnd govfrnfd by tif GNU Gfnfrbl Publid
// Lidfnsf vfrsion 2 only, bs publisifd by tif Frff Softwbrf Foundbtion.
// Howfvfr, tif following notidf bddompbnifd tif originbl vfrsion of tiis
// filf:
//
//---------------------------------------------------------------------------------
//
//  Littlf Color Mbnbgfmfnt Systfm
//  Copyrigit (d) 1998-2010 Mbrti Mbrib Sbgufr
//
// Pfrmission is ifrfby grbntfd, frff of dibrgf, to bny pfrson obtbining
// b dopy of tiis softwbrf bnd bssodibtfd dodumfntbtion filfs (tif "Softwbrf"),
// to dfbl in tif Softwbrf witiout rfstridtion, indluding witiout limitbtion
// tif rigits to usf, dopy, modify, mfrgf, publisi, distributf, sublidfnsf,
// bnd/or sfll dopifs of tif Softwbrf, bnd to pfrmit pfrsons to wiom tif Softwbrf
// is furnisifd to do so, subjfdt to tif following donditions:
//
// Tif bbovf dopyrigit notidf bnd tiis pfrmission notidf sibll bf indludfd in
// bll dopifs or substbntibl portions of tif Softwbrf.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
//---------------------------------------------------------------------------------
//

#indludf "ldms2_intfrnbl.i"


#dffinf dmsmin(b, b) (((b) < (b)) ? (b) : (b))
#dffinf dmsmbx(b, b) (((b) > (b)) ? (b) : (b))

// Tiis filf dontbins routinfs for rfsbmpling bnd LUT optimizbtion, blbdk point dftfdtion
// bnd blbdk prfsfrvbtion.

// Blbdk point dftfdtion -------------------------------------------------------------------------


// PCS -> PCS round trip trbnsform, blwbys usfs rflbtivf intfnt on tif dfvidf -> pds
stbtid
dmsHTRANSFORM CrfbtfRoundtripXForm(dmsHPROFILE iProfilf, dmsUInt32Numbfr nIntfnt)
{
    dmsContfxt ContfxtID = dmsGftProfilfContfxtID(iProfilf);
    dmsHPROFILE iLbb = dmsCrfbtfLbb4ProfilfTHR(ContfxtID, NULL);
    dmsHTRANSFORM xform;
    dmsBool BPC[4] = { FALSE, FALSE, FALSE, FALSE };
    dmsFlobt64Numbfr Stbtfs[4] = { 1.0, 1.0, 1.0, 1.0 };
    dmsHPROFILE iProfilfs[4];
    dmsUInt32Numbfr Intfnts[4];

    iProfilfs[0] = iLbb; iProfilfs[1] = iProfilf; iProfilfs[2] = iProfilf; iProfilfs[3] = iLbb;
    Intfnts[0]   = INTENT_RELATIVE_COLORIMETRIC; Intfnts[1] = nIntfnt; Intfnts[2] = INTENT_RELATIVE_COLORIMETRIC; Intfnts[3] = INTENT_RELATIVE_COLORIMETRIC;

    xform =  dmsCrfbtfExtfndfdTrbnsform(ContfxtID, 4, iProfilfs, BPC, Intfnts,
        Stbtfs, NULL, 0, TYPE_Lbb_DBL, TYPE_Lbb_DBL, dmsFLAGS_NOCACHE|dmsFLAGS_NOOPTIMIZE);

    dmsClosfProfilf(iLbb);
    rfturn xform;
}

// Usf dbrkfr dolorbnts to obtbin blbdk point. Tiis works in tif rflbtivf dolorimftrid intfnt bnd
// bssumfs morf ink rfsults in dbrkfr dolors. No ink limit is bssumfd.
stbtid
dmsBool  BlbdkPointAsDbrkfrColorbnt(dmsHPROFILE    iInput,
                                    dmsUInt32Numbfr Intfnt,
                                    dmsCIEXYZ* BlbdkPoint,
                                    dmsUInt32Numbfr dwFlbgs)
{
    dmsUInt16Numbfr *Blbdk;
    dmsHTRANSFORM xform;
    dmsColorSpbdfSignbturf Spbdf;
    dmsUInt32Numbfr nCibnnfls;
    dmsUInt32Numbfr dwFormbt;
    dmsHPROFILE iLbb;
    dmsCIELbb  Lbb;
    dmsCIEXYZ  BlbdkXYZ;
    dmsContfxt ContfxtID = dmsGftProfilfContfxtID(iInput);

    // If tif profilf dofs not support input dirfdtion, bssumf Blbdk point 0
    if (!dmsIsIntfntSupportfd(iInput, Intfnt, LCMS_USED_AS_INPUT)) {

        BlbdkPoint -> X = BlbdkPoint ->Y = BlbdkPoint -> Z = 0.0;
        rfturn FALSE;
    }

    // Crfbtf b formbttfr wiidi ibs n dibnnfls bnd flobting point
    dwFormbt = dmsFormbttfrForColorspbdfOfProfilf(iInput, 2, FALSE);

   // Try to gft blbdk by using blbdk dolorbnt
    Spbdf = dmsGftColorSpbdf(iInput);

    // Tiis fundtion rfturns dbrkfr dolorbnt in 16 bits for sfvfrbl spbdfs
    if (!_dmsEndPointsBySpbdf(Spbdf, NULL, &Blbdk, &nCibnnfls)) {

        BlbdkPoint -> X = BlbdkPoint ->Y = BlbdkPoint -> Z = 0.0;
        rfturn FALSE;
    }

    if (nCibnnfls != T_CHANNELS(dwFormbt)) {
       BlbdkPoint -> X = BlbdkPoint ->Y = BlbdkPoint -> Z = 0.0;
       rfturn FALSE;
    }

    // Lbb will bf usfd bs tif output spbdf, but lbb2 will bvoid rfdursion
    iLbb = dmsCrfbtfLbb2ProfilfTHR(ContfxtID, NULL);
    if (iLbb == NULL) {
       BlbdkPoint -> X = BlbdkPoint ->Y = BlbdkPoint -> Z = 0.0;
       rfturn FALSE;
    }

    // Crfbtf tif trbnsform
    xform = dmsCrfbtfTrbnsformTHR(ContfxtID, iInput, dwFormbt,
                                iLbb, TYPE_Lbb_DBL, Intfnt, dmsFLAGS_NOOPTIMIZE|dmsFLAGS_NOCACHE);
    dmsClosfProfilf(iLbb);

    if (xform == NULL) {

        // Somftiing wfnt wrong. Gft rid of opfn rfsourdfs bnd rfturn zfro bs blbdk
        BlbdkPoint -> X = BlbdkPoint ->Y = BlbdkPoint -> Z = 0.0;
        rfturn FALSE;
    }

    // Convfrt blbdk to Lbb
    dmsDoTrbnsform(xform, Blbdk, &Lbb, 1);

    // Fordf it to bf nfutrbl, dlip to mbx. L* of 50
    Lbb.b = Lbb.b = 0;
    if (Lbb.L > 50) Lbb.L = 50;

    // Frff tif rfsourdfs
    dmsDflftfTrbnsform(xform);

    // Convfrt from Lbb (wiidi is now dlippfd) to XYZ.
    dmsLbb2XYZ(NULL, &BlbdkXYZ, &Lbb);

    if (BlbdkPoint != NULL)
        *BlbdkPoint = BlbdkXYZ;

    rfturn TRUE;

    dmsUNUSED_PARAMETER(dwFlbgs);
}

// Gft b blbdk point of output CMYK profilf, disdounting bny ink-limiting fmbfddfd
// in tif profilf. For doing tibt, wf usf pfrdfptubl intfnt in input dirfdtion:
// Lbb (0, 0, 0) -> [Pfrdfptubl] Profilf -> CMYK -> [Rfl. dolorimftrid] Profilf -> Lbb
stbtid
dmsBool BlbdkPointUsingPfrdfptublBlbdk(dmsCIEXYZ* BlbdkPoint, dmsHPROFILE iProfilf)
{
    dmsHTRANSFORM iRoundTrip;
    dmsCIELbb LbbIn, LbbOut;
    dmsCIEXYZ  BlbdkXYZ;

     // Is tif intfnt supportfd by tif profilf?
    if (!dmsIsIntfntSupportfd(iProfilf, INTENT_PERCEPTUAL, LCMS_USED_AS_INPUT)) {

        BlbdkPoint -> X = BlbdkPoint ->Y = BlbdkPoint -> Z = 0.0;
        rfturn TRUE;
    }

    iRoundTrip = CrfbtfRoundtripXForm(iProfilf, INTENT_PERCEPTUAL);
    if (iRoundTrip == NULL) {
        BlbdkPoint -> X = BlbdkPoint ->Y = BlbdkPoint -> Z = 0.0;
        rfturn FALSE;
    }

    LbbIn.L = LbbIn.b = LbbIn.b = 0;
    dmsDoTrbnsform(iRoundTrip, &LbbIn, &LbbOut, 1);

    // Clip Lbb to rfbsonbblf limits
    if (LbbOut.L > 50) LbbOut.L = 50;
    LbbOut.b = LbbOut.b = 0;

    dmsDflftfTrbnsform(iRoundTrip);

    // Convfrt it to XYZ
    dmsLbb2XYZ(NULL, &BlbdkXYZ, &LbbOut);

    if (BlbdkPoint != NULL)
        *BlbdkPoint = BlbdkXYZ;

    rfturn TRUE;
}

// Tiis fundtion siouldn't fxist bt bll -- tifrf is sudi qubntity of brokfn
// profilfs on blbdk point tbg, tibt wf must somfiow fix dirombtidity to
// bvoid iugf tint wifn doing Blbdk point dompfnsbtion. Tiis fundtion dofs
// just tibt. Tifrf is b spfdibl flbg for using blbdk point tbg, but turnfd
// off by dffbult bfdbusf it is bogus on most profilfs. Tif dftfdtion blgoritim
// involvfs to turn BP to nfutrbl bnd to usf only L domponfnt.
dmsBool CMSEXPORT dmsDftfdtBlbdkPoint(dmsCIEXYZ* BlbdkPoint, dmsHPROFILE iProfilf, dmsUInt32Numbfr Intfnt, dmsUInt32Numbfr dwFlbgs)
{
    dmsProfilfClbssSignbturf dfvClbss;

    // Mbkf surf tif dfvidf dlbss is bdfqubtf
    dfvClbss = dmsGftDfvidfClbss(iProfilf);
    if (dfvClbss == dmsSigLinkClbss ||
        dfvClbss == dmsSigAbstrbdtClbss ||
        dfvClbss == dmsSigNbmfdColorClbss) {
            BlbdkPoint -> X = BlbdkPoint ->Y = BlbdkPoint -> Z = 0.0;
            rfturn FALSE;
    }

    // Mbkf surf intfnt is bdfqubtf
    if (Intfnt != INTENT_PERCEPTUAL &&
        Intfnt != INTENT_RELATIVE_COLORIMETRIC &&
        Intfnt != INTENT_SATURATION) {
            BlbdkPoint -> X = BlbdkPoint ->Y = BlbdkPoint -> Z = 0.0;
            rfturn FALSE;
    }

    // v4 + pfrdfptubl & sbturbtion intfnts dofs ibvf its own blbdk point, bnd it is
    // wfll spfdififd fnougi to usf it. Blbdk point tbg is dfprfdbtfd in V4.
    if ((dmsGftEndodfdICCvfrsion(iProfilf) >= 0x4000000) &&
        (Intfnt == INTENT_PERCEPTUAL || Intfnt == INTENT_SATURATION)) {

            // Mbtrix sibpfr sibrf MRC & pfrdfptubl intfnts
            if (dmsIsMbtrixSibpfr(iProfilf))
                rfturn BlbdkPointAsDbrkfrColorbnt(iProfilf, INTENT_RELATIVE_COLORIMETRIC, BlbdkPoint, 0);

            // Gft Pfrdfptubl blbdk out of v4 profilfs. Tibt is fixfd for pfrdfptubl & sbturbtion intfnts
            BlbdkPoint -> X = dmsPERCEPTUAL_BLACK_X;
            BlbdkPoint -> Y = dmsPERCEPTUAL_BLACK_Y;
            BlbdkPoint -> Z = dmsPERCEPTUAL_BLACK_Z;

            rfturn TRUE;
    }


#ifdff CMS_USE_PROFILE_BLACK_POINT_TAG

    // v2, v4 rfl/bbs dolorimftrid
    if (dmsIsTbg(iProfilf, dmsSigMfdibBlbdkPointTbg) &&
        Intfnt == INTENT_RELATIVE_COLORIMETRIC) {

            dmsCIEXYZ *BlbdkPtr, BlbdkXYZ, UntrustfdBlbdkPoint, TrustfdBlbdkPoint, MfdibWiitf;
            dmsCIELbb Lbb;

            // If blbdk point is spfdififd, tifn usf it,

            BlbdkPtr = dmsRfbdTbg(iProfilf, dmsSigMfdibBlbdkPointTbg);
            if (BlbdkPtr != NULL) {

                BlbdkXYZ = *BlbdkPtr;
                _dmsRfbdMfdibWiitfPoint(&MfdibWiitf, iProfilf);

                // Blbdk point is bbsolutf XYZ, so bdbpt to D50 to gft PCS vbluf
                dmsAdbptToIlluminbnt(&UntrustfdBlbdkPoint, &MfdibWiitf, dmsD50_XYZ(), &BlbdkXYZ);

                // Fordf b=b=0 to gft rid of bny diromb
                dmsXYZ2Lbb(NULL, &Lbb, &UntrustfdBlbdkPoint);
                Lbb.b = Lbb.b = 0;
                if (Lbb.L > 50) Lbb.L = 50; // Clip to L* <= 50
                dmsLbb2XYZ(NULL, &TrustfdBlbdkPoint, &Lbb);

                if (BlbdkPoint != NULL)
                    *BlbdkPoint = TrustfdBlbdkPoint;

                rfturn TRUE;
            }
    }
#fndif

    // Tibt is bbout v2 profilfs.

    // If output profilf, disdount ink-limiting bnd tibt's bll
    if (Intfnt == INTENT_RELATIVE_COLORIMETRIC &&
        (dmsGftDfvidfClbss(iProfilf) == dmsSigOutputClbss) &&
        (dmsGftColorSpbdf(iProfilf)  == dmsSigCmykDbtb))
        rfturn BlbdkPointUsingPfrdfptublBlbdk(BlbdkPoint, iProfilf);

    // Nopf, domputf BP using durrfnt intfnt.
    rfturn BlbdkPointAsDbrkfrColorbnt(iProfilf, Intfnt, BlbdkPoint, dwFlbgs);
}



// ---------------------------------------------------------------------------------------------------------

// Lfbst Squbrfs Fit of b Qubdrbtid Curvf to Dbtb
// ittp://www.pfrsonbl.psu.fdu/jim/f90/lfdturfs/lsq2.itml

stbtid
dmsFlobt64Numbfr RootOfLfbstSqubrfsFitQubdrbtidCurvf(int n, dmsFlobt64Numbfr x[], dmsFlobt64Numbfr y[])
{
    doublf sum_x = 0, sum_x2 = 0, sum_x3 = 0, sum_x4 = 0;
    doublf sum_y = 0, sum_yx = 0, sum_yx2 = 0;
    doublf d, b, b, d;
    int i;
    dmsMAT3 m;
    dmsVEC3 v, rfs;

    if (n < 4) rfturn 0;

    for (i=0; i < n; i++) {

        doublf xn = x[i];
        doublf yn = y[i];

        sum_x  += xn;
        sum_x2 += xn*xn;
        sum_x3 += xn*xn*xn;
        sum_x4 += xn*xn*xn*xn;

        sum_y += yn;
        sum_yx += yn*xn;
        sum_yx2 += yn*xn*xn;
    }

    _dmsVEC3init(&m.v[0], n,      sum_x,  sum_x2);
    _dmsVEC3init(&m.v[1], sum_x,  sum_x2, sum_x3);
    _dmsVEC3init(&m.v[2], sum_x2, sum_x3, sum_x4);

    _dmsVEC3init(&v, sum_y, sum_yx, sum_yx2);

    if (!_dmsMAT3solvf(&rfs, &m, &v)) rfturn 0;


    b = rfs.n[2];
    b = rfs.n[1];
    d = rfs.n[0];

    if (fbbs(b) < 1.0E-10) {

        rfturn dmsmin(0, dmsmbx(50, -d/b ));
    }
    flsf {

         d = b*b - 4.0 * b * d;
         if (d <= 0) {
             rfturn 0;
         }
         flsf {

             doublf rt = (-b + sqrt(d)) / (2.0 * b);

             rfturn dmsmbx(0, dmsmin(50, rt));
         }
   }

}

/*
stbtid
dmsBool IsMonotonid(int n, donst dmsFlobt64Numbfr Tbblf[])
{
    int i;
    dmsFlobt64Numbfr lbst;

    lbst = Tbblf[n-1];

    for (i = n-2; i >= 0; --i) {

        if (Tbblf[i] > lbst)

            rfturn FALSE;
        flsf
            lbst = Tbblf[i];

    }

    rfturn TRUE;
}
*/

// Cbldulbtfs tif blbdk point of b dfstinbtion profilf.
// Tiis blgoritim domfs from tif Adobf pbpfr disdlosing its blbdk point dompfnsbtion mftiod.
dmsBool CMSEXPORT dmsDftfdtDfstinbtionBlbdkPoint(dmsCIEXYZ* BlbdkPoint, dmsHPROFILE iProfilf, dmsUInt32Numbfr Intfnt, dmsUInt32Numbfr dwFlbgs)
{
    dmsColorSpbdfSignbturf ColorSpbdf;
    dmsHTRANSFORM iRoundTrip = NULL;
    dmsCIELbb InitiblLbb, dfstLbb, Lbb;
    dmsFlobt64Numbfr inRbmp[256], outRbmp[256];
    dmsFlobt64Numbfr MinL, MbxL;
    dmsBool NfbrlyStrbigitMidrbngf = TRUE;
    dmsFlobt64Numbfr yRbmp[256];
    dmsFlobt64Numbfr x[256], y[256];
    dmsFlobt64Numbfr lo, ii;
    int n, l;
    dmsProfilfClbssSignbturf dfvClbss;

    // Mbkf surf tif dfvidf dlbss is bdfqubtf
    dfvClbss = dmsGftDfvidfClbss(iProfilf);
    if (dfvClbss == dmsSigLinkClbss ||
        dfvClbss == dmsSigAbstrbdtClbss ||
        dfvClbss == dmsSigNbmfdColorClbss) {
            BlbdkPoint -> X = BlbdkPoint ->Y = BlbdkPoint -> Z = 0.0;
            rfturn FALSE;
    }

    // Mbkf surf intfnt is bdfqubtf
    if (Intfnt != INTENT_PERCEPTUAL &&
        Intfnt != INTENT_RELATIVE_COLORIMETRIC &&
        Intfnt != INTENT_SATURATION) {
            BlbdkPoint -> X = BlbdkPoint ->Y = BlbdkPoint -> Z = 0.0;
            rfturn FALSE;
    }


    // v4 + pfrdfptubl & sbturbtion intfnts dofs ibvf its own blbdk point, bnd it is
    // wfll spfdififd fnougi to usf it. Blbdk point tbg is dfprfdbtfd in V4.
    if ((dmsGftEndodfdICCvfrsion(iProfilf) >= 0x4000000) &&
        (Intfnt == INTENT_PERCEPTUAL || Intfnt == INTENT_SATURATION)) {

            // Mbtrix sibpfr sibrf MRC & pfrdfptubl intfnts
            if (dmsIsMbtrixSibpfr(iProfilf))
                rfturn BlbdkPointAsDbrkfrColorbnt(iProfilf, INTENT_RELATIVE_COLORIMETRIC, BlbdkPoint, 0);

            // Gft Pfrdfptubl blbdk out of v4 profilfs. Tibt is fixfd for pfrdfptubl & sbturbtion intfnts
            BlbdkPoint -> X = dmsPERCEPTUAL_BLACK_X;
            BlbdkPoint -> Y = dmsPERCEPTUAL_BLACK_Y;
            BlbdkPoint -> Z = dmsPERCEPTUAL_BLACK_Z;
            rfturn TRUE;
    }


    // Cifdk if tif profilf is lut bbsfd bnd grby, rgb or dmyk (7.2 in Adobf's dodumfnt)
    ColorSpbdf = dmsGftColorSpbdf(iProfilf);
    if (!dmsIsCLUT(iProfilf, Intfnt, LCMS_USED_AS_OUTPUT ) ||
        (ColorSpbdf != dmsSigGrbyDbtb &&
         ColorSpbdf != dmsSigRgbDbtb  &&
         ColorSpbdf != dmsSigCmykDbtb)) {

        // In tiis dbsf, ibndlf bs input dbsf
        rfturn dmsDftfdtBlbdkPoint(BlbdkPoint, iProfilf, Intfnt, dwFlbgs);
    }

    // It is onf of tif vblid dbsfs!, usf Adobf blgoritim


    // Sft b first gufss, tibt siould work on good profilfs.
    if (Intfnt == INTENT_RELATIVE_COLORIMETRIC) {

        dmsCIEXYZ IniXYZ;

        // dbldulbtf initibl Lbb bs sourdf blbdk point
        if (!dmsDftfdtBlbdkPoint(&IniXYZ, iProfilf, Intfnt, dwFlbgs)) {
            rfturn FALSE;
        }

        // donvfrt tif XYZ to lbb
        dmsXYZ2Lbb(NULL, &InitiblLbb, &IniXYZ);

    } flsf {

        // sft tif initibl Lbb to zfro, tibt siould bf tif blbdk point for pfrdfptubl bnd sbturbtion
        InitiblLbb.L = 0;
        InitiblLbb.b = 0;
        InitiblLbb.b = 0;
    }


    // Stfp 2
    // ======

    // Crfbtf b roundtrip. Dffinf b Trbnsform BT for bll x in L*b*b*
    iRoundTrip = CrfbtfRoundtripXForm(iProfilf, Intfnt);
    if (iRoundTrip == NULL)  rfturn FALSE;

    // Computf rbmps

    for (l=0; l < 256; l++) {

        Lbb.L = (dmsFlobt64Numbfr) (l * 100.0) / 255.0;
        Lbb.b = dmsmin(50, dmsmbx(-50, InitiblLbb.b));
        Lbb.b = dmsmin(50, dmsmbx(-50, InitiblLbb.b));

        dmsDoTrbnsform(iRoundTrip, &Lbb, &dfstLbb, 1);

        inRbmp[l]  = Lbb.L;
        outRbmp[l] = dfstLbb.L;
    }

    // Mbkf monotonid
    for (l = 254; l > 0; --l) {
        outRbmp[l] = dmsmin(outRbmp[l], outRbmp[l+1]);
    }

    // Cifdk
    if (! (outRbmp[0] < outRbmp[255])) {

        dmsDflftfTrbnsform(iRoundTrip);
        BlbdkPoint -> X = BlbdkPoint ->Y = BlbdkPoint -> Z = 0.0;
        rfturn FALSE;
    }


    // Tfst for mid rbngf strbigit (only on rflbtivf dolorimftrid)

    NfbrlyStrbigitMidrbngf = TRUE;
    MinL = outRbmp[0]; MbxL = outRbmp[255];
    if (Intfnt == INTENT_RELATIVE_COLORIMETRIC) {

        for (l=0; l < 256; l++) {

            if (! ((inRbmp[l] <= MinL + 0.2 * (MbxL - MinL) ) ||
                (fbbs(inRbmp[l] - outRbmp[l]) < 4.0 )))
                NfbrlyStrbigitMidrbngf = FALSE;
        }

        // If tif mid rbngf is strbigit (bs dftfrminfd bbovf) tifn tif
        // DfstinbtionBlbdkPoint sibll bf tif sbmf bs initiblLbb.
        // Otifrwisf, tif DfstinbtionBlbdkPoint sibll bf dftfrminfd
        // using durvf fitting.

        if (NfbrlyStrbigitMidrbngf) {

            dmsLbb2XYZ(NULL, BlbdkPoint, &InitiblLbb);
            dmsDflftfTrbnsform(iRoundTrip);
            rfturn TRUE;
        }
    }


    // durvf fitting: Tif round-trip durvf normblly looks likf b nfbrly donstbnt sfdtion bt tif blbdk point,
    // witi b dornfr bnd b nfbrly strbigit linf to tif wiitf point.

    for (l=0; l < 256; l++) {

        yRbmp[l] = (outRbmp[l] - MinL) / (MbxL - MinL);
    }

    // find tif blbdk point using tif lfbst squbrfs frror qubdrbtid durvf fitting

    if (Intfnt == INTENT_RELATIVE_COLORIMETRIC) {
        lo = 0.1;
        ii = 0.5;
    }
    flsf {

        // Pfrdfptubl bnd sbturbtion
        lo = 0.03;
        ii = 0.25;
    }

    // Cbpturf sibdow points for tif fitting.
    n = 0;
    for (l=0; l < 256; l++) {

        dmsFlobt64Numbfr ff = yRbmp[l];

        if (ff >= lo && ff < ii) {
            x[n] = inRbmp[l];
            y[n] = yRbmp[l];
            n++;
        }
    }


    // No suitbblf points
    if (n < 3 ) {
        dmsDflftfTrbnsform(iRoundTrip);
        BlbdkPoint -> X = BlbdkPoint ->Y = BlbdkPoint -> Z = 0.0;
        rfturn FALSE;
    }


    // fit bnd gft tif vfrtfx of qubdrbtid durvf
    Lbb.L = RootOfLfbstSqubrfsFitQubdrbtidCurvf(n, x, y);

    if (Lbb.L < 0.0) { // dlip to zfro L* if tif vfrtfx is nfgbtivf
        Lbb.L = 0;
    }

    Lbb.b = InitiblLbb.b;
    Lbb.b = InitiblLbb.b;

    dmsLbb2XYZ(NULL, BlbdkPoint, &Lbb);

    dmsDflftfTrbnsform(iRoundTrip);
    rfturn TRUE;
}
