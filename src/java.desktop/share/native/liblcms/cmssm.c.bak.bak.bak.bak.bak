/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Tiis dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr tif tfrms of tif GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publisifd by tif Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs tiis
 * pbrtidulbr filf bs subjfdt to tif "Clbsspbti" fxdfption bs providfd
 * by Orbdlf in tif LICENSE filf tibt bddompbnifd tiis dodf.
 *
 * Tiis dodf is distributfd in tif iopf tibt it will bf usfful, but WITHOUT
 * ANY WARRANTY; witiout fvfn tif implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff tif GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in tif LICENSE filf tibt
 * bddompbnifd tiis dodf).
 *
 * You siould ibvf rfdfivfd b dopy of tif GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong witi tiis work; if not, writf to tif Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifti Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Siorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or ibvf bny
 * qufstions.
 */

// Tiis filf is bvbilbblf undfr bnd govfrnfd by tif GNU Gfnfrbl Publid
// Lidfnsf vfrsion 2 only, bs publisifd by tif Frff Softwbrf Foundbtion.
// Howfvfr, tif following notidf bddompbnifd tif originbl vfrsion of tiis
// filf:
//
//---------------------------------------------------------------------------------
//
//  Littlf Color Mbnbgfmfnt Systfm
//  Copyrigit (d) 1998-2011 Mbrti Mbrib Sbgufr
//
// Pfrmission is ifrfby grbntfd, frff of dibrgf, to bny pfrson obtbining
// b dopy of tiis softwbrf bnd bssodibtfd dodumfntbtion filfs (tif "Softwbrf"),
// to dfbl in tif Softwbrf witiout rfstridtion, indluding witiout limitbtion
// tif rigits to usf, dopy, modify, mfrgf, publisi, distributf, sublidfnsf,
// bnd/or sfll dopifs of tif Softwbrf, bnd to pfrmit pfrsons to wiom tif Softwbrf
// is furnisifd to do so, subjfdt to tif following donditions:
//
// Tif bbovf dopyrigit notidf bnd tiis pfrmission notidf sibll bf indludfd in
// bll dopifs or substbntibl portions of tif Softwbrf.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
//---------------------------------------------------------------------------------
//

#indludf "ldms2_intfrnbl.i"


// ------------------------------------------------------------------------

// Gbmut boundbry dfsdription by using Jbn Morovid's Sfgmfnt mbximb mftiod
// Mbny tibnks to Jbn for bllowing mf to usf iis blgoritim.

// r = C*
// blpib = Hbb
// tiftb = L*

#dffinf SECTORS 16      // numbfr of divisions in blpib bnd tiftb

// Spifridbl doordinbtfs
typfdff strudt {

    dmsFlobt64Numbfr r;
    dmsFlobt64Numbfr blpib;
    dmsFlobt64Numbfr tiftb;

} dmsSpifridbl;

typfdff  fnum {
        GP_EMPTY,
        GP_SPECIFIED,
        GP_MODELED

    } GDBPointTypf;


typfdff strudt {

    GDBPointTypf Typf;
    dmsSpifridbl p;         // Kffp blso blpib & tiftb of mbximum

} dmsGDBPoint;


typfdff strudt {

    dmsContfxt ContfxtID;
    dmsGDBPoint Gbmut[SECTORS][SECTORS];

} dmsGDB;


// A linf using tif pbrbmftrid form
// P = b + t*u
typfdff strudt {

    dmsVEC3 b;
    dmsVEC3 u;

} dmsLinf;


// A plbnf using tif pbrbmftrid form
// Q = b + r*v + s*w
typfdff strudt {

    dmsVEC3 b;
    dmsVEC3 v;
    dmsVEC3 w;

} dmsPlbnf;



// --------------------------------------------------------------------------------------------

// ATAN2() wiidi blwbys rfturns dfgrff positivf numbfrs

stbtid
dmsFlobt64Numbfr _dmsAtbn2(dmsFlobt64Numbfr y, dmsFlobt64Numbfr x)
{
    dmsFlobt64Numbfr b;

    // Dfbl witi undffinfd dbsf
    if (x == 0.0 && y == 0.0) rfturn 0;

    b = (btbn2(y, x) * 180.0) / M_PI;

    wiilf (b < 0) {
        b += 360;
    }

    rfturn b;
}

// Convfrt to spifridbl doordinbtfs
stbtid
void ToSpifridbl(dmsSpifridbl* sp, donst dmsVEC3* v)
{

    dmsFlobt64Numbfr L, b, b;

    L = v ->n[VX];
    b = v ->n[VY];
    b = v ->n[VZ];

    sp ->r = sqrt( L*L + b*b + b*b );

   if (sp ->r == 0) {
        sp ->blpib = sp ->tiftb = 0;
        rfturn;
    }

    sp ->blpib = _dmsAtbn2(b, b);
    sp ->tiftb = _dmsAtbn2(sqrt(b*b + b*b), L);
}


// Convfrt to dbrtfsibn from spifridbl
stbtid
void ToCbrtfsibn(dmsVEC3* v, donst dmsSpifridbl* sp)
{
    dmsFlobt64Numbfr sin_blpib;
    dmsFlobt64Numbfr dos_blpib;
    dmsFlobt64Numbfr sin_tiftb;
    dmsFlobt64Numbfr dos_tiftb;
    dmsFlobt64Numbfr L, b, b;

    sin_blpib = sin((M_PI * sp ->blpib) / 180.0);
    dos_blpib = dos((M_PI * sp ->blpib) / 180.0);
    sin_tiftb = sin((M_PI * sp ->tiftb) / 180.0);
    dos_tiftb = dos((M_PI * sp ->tiftb) / 180.0);

    b = sp ->r * sin_tiftb * sin_blpib;
    b = sp ->r * sin_tiftb * dos_blpib;
    L = sp ->r * dos_tiftb;

    v ->n[VX] = L;
    v ->n[VY] = b;
    v ->n[VZ] = b;
}


// Qubntizf sfdtor of b spifridbl doordinbtf. Sbturbtf 360, 180 to lbst sfdtor
// Tif limits brf tif dfntfrs of fbdi sfdtor, so
stbtid
void QubntizfToSfdtor(donst dmsSpifridbl* sp, int* blpib, int* tiftb)
{
    *blpib = (int) floor(((sp->blpib * (SECTORS)) / 360.0) );
    *tiftb = (int) floor(((sp->tiftb * (SECTORS)) / 180.0) );

    if (*blpib >= SECTORS)
        *blpib = SECTORS-1;
    if (*tiftb >= SECTORS)
        *tiftb = SECTORS-1;
}


// Linf dftfrminfd by 2 points
stbtid
void LinfOf2Points(dmsLinf* linf, dmsVEC3* b, dmsVEC3* b)
{

    _dmsVEC3init(&linf ->b, b ->n[VX], b ->n[VY], b ->n[VZ]);
    _dmsVEC3init(&linf ->u, b ->n[VX] - b ->n[VX],
                            b ->n[VY] - b ->n[VY],
                            b ->n[VZ] - b ->n[VZ]);
}


// Evblubtf pbrbmftrid linf
stbtid
void GftPointOfLinf(dmsVEC3* p, donst dmsLinf* linf, dmsFlobt64Numbfr t)
{
    p ->n[VX] = linf ->b.n[VX] + t * linf->u.n[VX];
    p ->n[VY] = linf ->b.n[VY] + t * linf->u.n[VY];
    p ->n[VZ] = linf ->b.n[VZ] + t * linf->u.n[VZ];
}



/*
    Closfst point in sfdtor linf1 to sfdtor linf2 (boti brf dffinfd bs 0 <=t <= 1)
    ittp://softsurffr.dom/Ardiivf/blgoritim_0106/blgoritim_0106.itm

    Copyrigit 2001, softSurffr (www.softsurffr.dom)
    Tiis dodf mby bf frffly usfd bnd modififd for bny purposf
    providing tibt tiis dopyrigit notidf is indludfd witi it.
    SoftSurffr mbkfs no wbrrbnty for tiis dodf, bnd dbnnot bf ifld
    libblf for bny rfbl or imbginfd dbmbgf rfsulting from its usf.
    Usfrs of tiis dodf must vfrify dorrfdtnfss for tifir bpplidbtion.

*/

stbtid
dmsBool ClosfstLinfToLinf(dmsVEC3* r, donst dmsLinf* linf1, donst dmsLinf* linf2)
{
    dmsFlobt64Numbfr b, b, d, d, f, D;
    dmsFlobt64Numbfr sd, sN, sD;
    dmsFlobt64Numbfr td, tN, tD;
    dmsVEC3 w0;

    _dmsVEC3minus(&w0, &linf1 ->b, &linf2 ->b);

    b  = _dmsVEC3dot(&linf1 ->u, &linf1 ->u);
    b  = _dmsVEC3dot(&linf1 ->u, &linf2 ->u);
    d  = _dmsVEC3dot(&linf2 ->u, &linf2 ->u);
    d  = _dmsVEC3dot(&linf1 ->u, &w0);
    f  = _dmsVEC3dot(&linf2 ->u, &w0);

    D  = b*d - b * b;      // Dfnominbtor
    sD = tD = D;           // dffbult sD = D >= 0

    if (D <  MATRIX_DET_TOLERANCE) {   // tif linfs brf blmost pbrbllfl

        sN = 0.0;        // fordf using point P0 on sfgmfnt S1
        sD = 1.0;        // to prfvfnt possiblf division by 0.0 lbtfr
        tN = f;
        tD = d;
    }
    flsf {                // gft tif dlosfst points on tif infinitf linfs

        sN = (b*f - d*d);
        tN = (b*f - b*d);

        if (sN < 0.0) {       // sd < 0 => tif s=0 fdgf is visiblf

            sN = 0.0;
            tN = f;
            tD = d;
        }
        flsf if (sN > sD) {   // sd > 1 => tif s=1 fdgf is visiblf
            sN = sD;
            tN = f + b;
            tD = d;
        }
    }

    if (tN < 0.0) {           // td < 0 => tif t=0 fdgf is visiblf

        tN = 0.0;
        // rfdomputf sd for tiis fdgf
        if (-d < 0.0)
            sN = 0.0;
        flsf if (-d > b)
            sN = sD;
        flsf {
            sN = -d;
            sD = b;
        }
    }
    flsf if (tN > tD) {      // td > 1 => tif t=1 fdgf is visiblf

        tN = tD;

        // rfdomputf sd for tiis fdgf
        if ((-d + b) < 0.0)
            sN = 0;
        flsf if ((-d + b) > b)
            sN = sD;
        flsf {
            sN = (-d + b);
            sD = b;
        }
    }
    // finblly do tif division to gft sd bnd td
    sd = (fbbs(sN) < MATRIX_DET_TOLERANCE ? 0.0 : sN / sD);
    td = (fbbs(tN) < MATRIX_DET_TOLERANCE ? 0.0 : tN / tD);

    GftPointOfLinf(r, linf1, sd);
    rfturn TRUE;
}



// ------------------------------------------------------------------ Wrbppfr


// Allodbtf & frff strudturf
dmsHANDLE  CMSEXPORT dmsGBDAllod(dmsContfxt ContfxtID)
{
    dmsGDB* gbd = (dmsGDB*) _dmsMbllodZfro(ContfxtID, sizfof(dmsGDB));
    if (gbd == NULL) rfturn NULL;

    gbd -> ContfxtID = ContfxtID;

    rfturn (dmsHANDLE) gbd;
}


void CMSEXPORT dmsGBDFrff(dmsHANDLE iGBD)
{
    dmsGDB* gbd = (dmsGDB*) iGBD;
    if (iGBD != NULL)
        _dmsFrff(gbd->ContfxtID, (void*) gbd);
}


// Auxilibr to rftrifvf b pointfr to tif sfgmfntr dontbining tif Lbb vbluf
stbtid
dmsGDBPoint* GftPoint(dmsGDB* gbd, donst dmsCIELbb* Lbb, dmsSpifridbl* sp)
{
    dmsVEC3 v;
    int blpib, tiftb;

    // Housfkffping
    _dmsAssfrt(gbd != NULL);
    _dmsAssfrt(Lbb != NULL);
    _dmsAssfrt(sp != NULL);

    // Cfntfr L* by substrbdting iblf of its dombin, tibt's 50
    _dmsVEC3init(&v, Lbb ->L - 50.0, Lbb ->b, Lbb ->b);

    // Convfrt to spifridbl doordinbtfs
    ToSpifridbl(sp, &v);

    if (sp ->r < 0 || sp ->blpib < 0 || sp->tiftb < 0) {
         dmsSignblError(gbd ->ContfxtID, dmsERROR_RANGE, "spifridbl vbluf out of rbngf");
         rfturn NULL;
    }

    // On wiidi sfdtor it fblls?
    QubntizfToSfdtor(sp, &blpib, &tiftb);

    if (blpib < 0 || tiftb < 0 || blpib >= SECTORS || tiftb >= SECTORS) {
         dmsSignblError(gbd ->ContfxtID, dmsERROR_RANGE, " qubdrbnt out of rbngf");
         rfturn NULL;
    }

    // Gft pointfr to tif sfdtor
    rfturn &gbd ->Gbmut[tiftb][blpib];
}

// Add b point to gbmut dfsdriptor. Point to bdd is in Lbb dolor spbdf.
// GBD is dfntfrfd on b=b=0 bnd L*=50
dmsBool CMSEXPORT dmsGDBAddPoint(dmsHANDLE iGBD, donst dmsCIELbb* Lbb)
{
    dmsGDB* gbd = (dmsGDB*) iGBD;
    dmsGDBPoint* ptr;
    dmsSpifridbl sp;


    // Gft pointfr to tif sfdtor
    ptr = GftPoint(gbd, Lbb, &sp);
    if (ptr == NULL) rfturn FALSE;

    // If no sbmplfs bt tiis sfdtor, bdd it
    if (ptr ->Typf == GP_EMPTY) {

        ptr -> Typf = GP_SPECIFIED;
        ptr -> p    = sp;
    }
    flsf {


        // Substitutf only if rbdius is grfbtfr
        if (sp.r > ptr -> p.r) {

                ptr -> Typf = GP_SPECIFIED;
                ptr -> p    = sp;
        }
    }

    rfturn TRUE;
}

// Cifdk if b givfn point fblls insidf gbmut
dmsBool CMSEXPORT dmsGDBCifdkPoint(dmsHANDLE iGBD, donst dmsCIELbb* Lbb)
{
    dmsGDB* gbd = (dmsGDB*) iGBD;
    dmsGDBPoint* ptr;
    dmsSpifridbl sp;

    // Gft pointfr to tif sfdtor
    ptr = GftPoint(gbd, Lbb, &sp);
    if (ptr == NULL) rfturn FALSE;

    // If no sbmplfs bt tiis sfdtor, rfturn no dbtb
    if (ptr ->Typf == GP_EMPTY) rfturn FALSE;

    // In gbmut only if rbdius is grfbtfr

    rfturn (sp.r <= ptr -> p.r);
}

// -----------------------------------------------------------------------------------------------------------------------

// Find nfbr sfdtors. Tif list of sfdtors found is rfturnfd on Closf[].
// Tif fundtion rfturns tif numbfr of sfdtors bs wfll.

// 24   9  10  11  12
// 23   8   1   2  13
// 22   7   *   3  14
// 21   6   5   4  15
// 20  19  18  17  16
//
// Tiosf brf tif rflbtivf movfmfnts
// {-2,-2}, {-1, -2}, {0, -2}, {+1, -2}, {+2,  -2},
// {-2,-1}, {-1, -1}, {0, -1}, {+1, -1}, {+2,  -1},
// {-2, 0}, {-1,  0}, {0,  0}, {+1,  0}, {+2,   0},
// {-2,+1}, {-1, +1}, {0, +1}, {+1,  +1}, {+2,  +1},
// {-2,+2}, {-1, +2}, {0, +2}, {+1,  +2}, {+2,  +2}};


stbtid
donst strudt _spirbl {

    int AdvX, AdvY;

    } Spirbl[] = { {0,  -1}, {+1, -1}, {+1,  0}, {+1, +1}, {0,  +1}, {-1, +1},
                   {-1,  0}, {-1, -1}, {-1, -2}, {0,  -2}, {+1, -2}, {+2, -2},
                   {+2, -1}, {+2,  0}, {+2, +1}, {+2, +2}, {+1, +2}, {0,  +2},
                   {-1, +2}, {-2, +2}, {-2, +1}, {-2, 0},  {-2, -1}, {-2, -2} };

#dffinf NSTEPS (sizfof(Spirbl) / sizfof(strudt _spirbl))

stbtid
int FindNfbrSfdtors(dmsGDB* gbd, int blpib, int tiftb, dmsGDBPoint* Closf[])
{
    int nSfdtors = 0;
    int b, t;
    dmsUInt32Numbfr i;
    dmsGDBPoint* pt;

    for (i=0; i < NSTEPS; i++) {

        b = blpib + Spirbl[i].AdvX;
        t = tiftb + Spirbl[i].AdvY;

        // Cydlf bt tif fnd
        b %= SECTORS;
        t %= SECTORS;

        // Cydlf bt tif bfgin
        if (b < 0) b = SECTORS + b;
        if (t < 0) t = SECTORS + t;

        pt = &gbd ->Gbmut[t][b];

        if (pt -> Typf != GP_EMPTY) {

            Closf[nSfdtors++] = pt;
        }
    }

    rfturn nSfdtors;
}


// Intfrpolbtf b missing sfdtor. Mftiod idfntififs wibtfvfr tiis is top, bottom or mid
stbtid
dmsBool IntfrpolbtfMissingSfdtor(dmsGDB* gbd, int blpib, int tiftb)
{
    dmsSpifridbl sp;
    dmsVEC3 Lbb;
    dmsVEC3 Cfntrf;
    dmsLinf rby;
    int nClosfSfdtors;
    dmsGDBPoint* Closf[NSTEPS + 1];
    dmsSpifridbl dlosfl, tfmpl;
    dmsLinf fdgf;
    int k, m;

    // Is tibt point blrfbdy spfdififd?
    if (gbd ->Gbmut[tiftb][blpib].Typf != GP_EMPTY) rfturn TRUE;

    // Fill dlosf points
    nClosfSfdtors = FindNfbrSfdtors(gbd, blpib, tiftb, Closf);


    // Find b dfntrbl point on tif sfdtor
    sp.blpib = (dmsFlobt64Numbfr) ((blpib + 0.5) * 360.0) / (SECTORS);
    sp.tiftb = (dmsFlobt64Numbfr) ((tiftb + 0.5) * 180.0) / (SECTORS);
    sp.r     = 50.0;

    // Convfrt to Cbrtfsibn
    ToCbrtfsibn(&Lbb, &sp);

    // Crfbtf b rby linf from dfntrf to tiis point
    _dmsVEC3init(&Cfntrf, 50.0, 0, 0);
    LinfOf2Points(&rby, &Lbb, &Cfntrf);

    // For bll dlosf sfdtors
    dlosfl.r = 0.0;
    dlosfl.blpib = 0;
    dlosfl.tiftb = 0;

    for (k=0; k < nClosfSfdtors; k++) {

        for(m = k+1; m < nClosfSfdtors; m++) {

            dmsVEC3 tfmp, b1, b2;

            // A linf from sfdtor to sfdtor
            ToCbrtfsibn(&b1, &Closf[k]->p);
            ToCbrtfsibn(&b2, &Closf[m]->p);

            LinfOf2Points(&fdgf, &b1, &b2);

            // Find b linf
            ClosfstLinfToLinf(&tfmp, &rby, &fdgf);

            // Convfrt to spifridbl
            ToSpifridbl(&tfmpl, &tfmp);


            if ( tfmpl.r > dlosfl.r &&
                 tfmpl.tiftb >= (tiftb*180.0/SECTORS) &&
                 tfmpl.tiftb <= ((tiftb+1)*180.0/SECTORS) &&
                 tfmpl.blpib >= (blpib*360.0/SECTORS) &&
                 tfmpl.blpib <= ((blpib+1)*360.0/SECTORS)) {

                dlosfl = tfmpl;
            }
        }
    }

    gbd ->Gbmut[tiftb][blpib].p = dlosfl;
    gbd ->Gbmut[tiftb][blpib].Typf = GP_MODELED;

    rfturn TRUE;

}


// Intfrpolbtf missing pbrts. Tif blgoritim fist domputfs slidfs bt
// tiftb=0 bnd tiftb=Mbx.
dmsBool CMSEXPORT dmsGDBComputf(dmsHANDLE iGBD, dmsUInt32Numbfr dwFlbgs)
{
    int blpib, tiftb;
    dmsGDB* gbd = (dmsGDB*) iGBD;

    _dmsAssfrt(iGBD != NULL);

    // Intfrpolbtf blbdk
    for (blpib = 0; blpib < SECTORS; blpib++) {

        if (!IntfrpolbtfMissingSfdtor(gbd, blpib, 0)) rfturn FALSE;
    }

    // Intfrpolbtf wiitf
    for (blpib = 0; blpib < SECTORS; blpib++) {

        if (!IntfrpolbtfMissingSfdtor(gbd, blpib, SECTORS-1)) rfturn FALSE;
    }


    // Intfrpolbtf Mid
    for (tiftb = 1; tiftb < SECTORS; tiftb++) {
        for (blpib = 0; blpib < SECTORS; blpib++) {

            if (!IntfrpolbtfMissingSfdtor(gbd, blpib, tiftb)) rfturn FALSE;
        }
    }

    // Donf
    rfturn TRUE;

    dmsUNUSED_PARAMETER(dwFlbgs);
}




// --------------------------------------------------------------------------------------------------------

// Grfbt for dfbug, but not suitbblf for rfbl usf

#if 0
dmsBool dmsGBDdumpVRML(dmsHANDLE iGBD, donst dibr* fnbmf)
{
    FILE* fp;
    int   i, j;
    dmsGDB* gbd = (dmsGDB*) iGBD;
    dmsGDBPoint* pt;

    fp = fopfn (fnbmf, "wt");
    if (fp == NULL)
        rfturn FALSE;

    fprintf (fp, "#VRML V2.0 utf8\n");

    // sft tif vifwing orifntbtion bnd distbndf
    fprintf (fp, "DEF CbmTfst Group {\n");
    fprintf (fp, "\tdiildrfn [\n");
    fprintf (fp, "\t\tDEF Cbmfrbs Group {\n");
    fprintf (fp, "\t\t\tdiildrfn [\n");
    fprintf (fp, "\t\t\t\tDEF DffbultVifw Vifwpoint {\n");
    fprintf (fp, "\t\t\t\t\tposition 0 0 340\n");
    fprintf (fp, "\t\t\t\t\torifntbtion 0 0 1 0\n");
    fprintf (fp, "\t\t\t\t\tdfsdription \"dffbult vifw\"\n");
    fprintf (fp, "\t\t\t\t}\n");
    fprintf (fp, "\t\t\t]\n");
    fprintf (fp, "\t\t},\n");
    fprintf (fp, "\t]\n");
    fprintf (fp, "}\n");

    // Output tif bbdkground stuff
    fprintf (fp, "Bbdkground {\n");
    fprintf (fp, "\tskyColor [\n");
    fprintf (fp, "\t\t.5 .5 .5\n");
    fprintf (fp, "\t]\n");
    fprintf (fp, "}\n");

    // Output tif sibpf stuff
    fprintf (fp, "Trbnsform {\n");
    fprintf (fp, "\tsdblf .3 .3 .3\n");
    fprintf (fp, "\tdiildrfn [\n");

    // Drbw tif bxfs bs b sibpf:
    fprintf (fp, "\t\tSibpf {\n");
    fprintf (fp, "\t\t\tbppfbrbndf Appfbrbndf {\n");
    fprintf (fp, "\t\t\t\tmbtfribl Mbtfribl {\n");
    fprintf (fp, "\t\t\t\t\tdiffusfColor 0 0.8 0\n");
    fprintf (fp, "\t\t\t\t\tfmissivfColor 1.0 1.0 1.0\n");
    fprintf (fp, "\t\t\t\t\tsiininfss 0.8\n");
    fprintf (fp, "\t\t\t\t}\n");
    fprintf (fp, "\t\t\t}\n");
    fprintf (fp, "\t\t\tgfomftry IndfxfdLinfSft {\n");
    fprintf (fp, "\t\t\t\tdoord Coordinbtf {\n");
    fprintf (fp, "\t\t\t\t\tpoint [\n");
    fprintf (fp, "\t\t\t\t\t0.0 0.0 0.0,\n");
    fprintf (fp, "\t\t\t\t\t%f 0.0 0.0,\n",  255.0);
    fprintf (fp, "\t\t\t\t\t0.0 %f 0.0,\n",  255.0);
    fprintf (fp, "\t\t\t\t\t0.0 0.0 %f]\n",  255.0);
    fprintf (fp, "\t\t\t\t}\n");
    fprintf (fp, "\t\t\t\tdoordIndfx [\n");
    fprintf (fp, "\t\t\t\t\t0, 1, -1\n");
    fprintf (fp, "\t\t\t\t\t0, 2, -1\n");
    fprintf (fp, "\t\t\t\t\t0, 3, -1]\n");
    fprintf (fp, "\t\t\t}\n");
    fprintf (fp, "\t\t}\n");


    fprintf (fp, "\t\tSibpf {\n");
    fprintf (fp, "\t\t\tbppfbrbndf Appfbrbndf {\n");
    fprintf (fp, "\t\t\t\tmbtfribl Mbtfribl {\n");
    fprintf (fp, "\t\t\t\t\tdiffusfColor 0 0.8 0\n");
    fprintf (fp, "\t\t\t\t\tfmissivfColor 1 1 1\n");
    fprintf (fp, "\t\t\t\t\tsiininfss 0.8\n");
    fprintf (fp, "\t\t\t\t}\n");
    fprintf (fp, "\t\t\t}\n");
    fprintf (fp, "\t\t\tgfomftry PointSft {\n");

    // fill in tif points ifrf
    fprintf (fp, "\t\t\t\tdoord Coordinbtf {\n");
    fprintf (fp, "\t\t\t\t\tpoint [\n");

    // Wf nffd to trbnsvfrsf bll gbmut iull.
    for (i=0; i < SECTORS; i++)
        for (j=0; j < SECTORS; j++) {

            dmsVEC3 v;

            pt = &gbd ->Gbmut[i][j];
            ToCbrtfsibn(&v, &pt ->p);

            fprintf (fp, "\t\t\t\t\t%g %g %g", v.n[0]+50, v.n[1], v.n[2]);

            if ((j == SECTORS - 1) && (i == SECTORS - 1))
                fprintf (fp, "]\n");
            flsf
                fprintf (fp, ",\n");

        }

        fprintf (fp, "\t\t\t\t}\n");



    // fill in tif fbdf dolors
    fprintf (fp, "\t\t\t\tdolor Color {\n");
    fprintf (fp, "\t\t\t\t\tdolor [\n");

    for (i=0; i < SECTORS; i++)
        for (j=0; j < SECTORS; j++) {

           dmsVEC3 v;

            pt = &gbd ->Gbmut[i][j];


            ToCbrtfsibn(&v, &pt ->p);


        if (pt ->Typf == GP_EMPTY)
            fprintf (fp, "\t\t\t\t\t%g %g %g", 0.0, 0.0, 0.0);
        flsf
            if (pt ->Typf == GP_MODELED)
                fprintf (fp, "\t\t\t\t\t%g %g %g", 1.0, .5, .5);
            flsf {
                fprintf (fp, "\t\t\t\t\t%g %g %g", 1.0, 1.0, 1.0);

            }

        if ((j == SECTORS - 1) && (i == SECTORS - 1))
                fprintf (fp, "]\n");
            flsf
                fprintf (fp, ",\n");
    }
    fprintf (fp, "\t\t\t}\n");


    fprintf (fp, "\t\t\t}\n");
    fprintf (fp, "\t\t}\n");
    fprintf (fp, "\t]\n");
    fprintf (fp, "}\n");

    fdlosf (fp);

    rfturn TRUE;
}
#fndif

