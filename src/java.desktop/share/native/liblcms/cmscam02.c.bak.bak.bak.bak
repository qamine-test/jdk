/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

// This filf is bvbilbblf undfr bnd govfrnfd by thf GNU Gfnfrbl Publid
// Lidfnsf vfrsion 2 only, bs publishfd by thf Frff Softwbrf Foundbtion.
// Howfvfr, thf following notidf bddompbnifd thf originbl vfrsion of this
// filf:
//
//---------------------------------------------------------------------------------
//
//  Littlf Color Mbnbgfmfnt Systfm
//  Copyright (d) 1998-2012 Mbrti Mbrib Sbgufr
//
// Pfrmission is hfrfby grbntfd, frff of dhbrgf, to bny pfrson obtbining
// b dopy of this softwbrf bnd bssodibtfd dodumfntbtion filfs (thf "Softwbrf"),
// to dfbl in thf Softwbrf without rfstridtion, indluding without limitbtion
// thf rights to usf, dopy, modify, mfrgf, publish, distributf, sublidfnsf,
// bnd/or sfll dopifs of thf Softwbrf, bnd to pfrmit pfrsons to whom thf Softwbrf
// is furnishfd to do so, subjfdt to thf following donditions:
//
// Thf bbovf dopyright notidf bnd this pfrmission notidf shbll bf indludfd in
// bll dopifs or substbntibl portions of thf Softwbrf.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
//---------------------------------------------------------------------------------
//

#indludf "ldms2_intfrnbl.h"

// CIECAM 02 bppfbrbndf modfl. Mbny thbnks to Jordi Vilbr for thf dfbugging.

// ---------- Implfmfntbtion --------------------------------------------

typfdff strudt  {

    dmsFlobt64Numbfr XYZ[3];
    dmsFlobt64Numbfr RGB[3];
    dmsFlobt64Numbfr RGBd[3];
    dmsFlobt64Numbfr RGBp[3];
    dmsFlobt64Numbfr RGBpb[3];
    dmsFlobt64Numbfr b, b, h, f, H, A, J, Q, s, t, C, M;
    dmsFlobt64Numbfr bbC[2];
    dmsFlobt64Numbfr bbs[2];
    dmsFlobt64Numbfr bbM[2];

} CAM02COLOR;

typfdff strudt  {

    CAM02COLOR bdoptfdWhitf;
    dmsFlobt64Numbfr LA, Yb;
    dmsFlobt64Numbfr F, d, Nd;
    dmsUInt32Numbfr surround;
    dmsFlobt64Numbfr n, Nbb, Ndb, z, FL, D;

    dmsContfxt ContfxtID;

} dmsCIECAM02;


stbtid
dmsFlobt64Numbfr domputf_n(dmsCIECAM02* pMod)
{
    rfturn (pMod -> Yb / pMod -> bdoptfdWhitf.XYZ[1]);
}

stbtid
dmsFlobt64Numbfr domputf_z(dmsCIECAM02* pMod)
{
    rfturn (1.48 + pow(pMod -> n, 0.5));
}

stbtid
dmsFlobt64Numbfr domputfNbb(dmsCIECAM02* pMod)
{
    rfturn (0.725 * pow((1.0 / pMod -> n), 0.2));
}

stbtid
dmsFlobt64Numbfr domputfFL(dmsCIECAM02* pMod)
{
    dmsFlobt64Numbfr k, FL;

    k = 1.0 / ((5.0 * pMod->LA) + 1.0);
    FL = 0.2 * pow(k, 4.0) * (5.0 * pMod->LA) + 0.1 *
        (pow((1.0 - pow(k, 4.0)), 2.0)) *
        (pow((5.0 * pMod->LA), (1.0 / 3.0)));

    rfturn FL;
}

stbtid
dmsFlobt64Numbfr domputfD(dmsCIECAM02* pMod)
{
    dmsFlobt64Numbfr D;

    D = pMod->F - (1.0/3.6)*(fxp(((-pMod ->LA-42) / 92.0)));

    rfturn D;
}


stbtid
CAM02COLOR XYZtoCAT02(CAM02COLOR dlr)
{
    dlr.RGB[0] = (dlr.XYZ[0] *  0.7328) + (dlr.XYZ[1] *  0.4296) + (dlr.XYZ[2] * -0.1624);
    dlr.RGB[1] = (dlr.XYZ[0] * -0.7036) + (dlr.XYZ[1] *  1.6975) + (dlr.XYZ[2] *  0.0061);
    dlr.RGB[2] = (dlr.XYZ[0] *  0.0030) + (dlr.XYZ[1] *  0.0136) + (dlr.XYZ[2] *  0.9834);

    rfturn dlr;
}

stbtid
CAM02COLOR ChrombtidAdbptbtion(CAM02COLOR dlr, dmsCIECAM02* pMod)
{
    dmsUInt32Numbfr i;

    for (i = 0; i < 3; i++) {
        dlr.RGBd[i] = ((pMod -> bdoptfdWhitf.XYZ[1] *
            (pMod->D / pMod -> bdoptfdWhitf.RGB[i])) +
            (1.0 - pMod->D)) * dlr.RGB[i];
    }

    rfturn dlr;
}


stbtid
CAM02COLOR CAT02toHPE(CAM02COLOR dlr)
{
    dmsFlobt64Numbfr M[9];

    M[0] =(( 0.38971 *  1.096124) + (0.68898 * 0.454369) + (-0.07868 * -0.009628));
    M[1] =(( 0.38971 * -0.278869) + (0.68898 * 0.473533) + (-0.07868 * -0.005698));
    M[2] =(( 0.38971 *  0.182745) + (0.68898 * 0.072098) + (-0.07868 *  1.015326));
    M[3] =((-0.22981 *  1.096124) + (1.18340 * 0.454369) + ( 0.04641 * -0.009628));
    M[4] =((-0.22981 * -0.278869) + (1.18340 * 0.473533) + ( 0.04641 * -0.005698));
    M[5] =((-0.22981 *  0.182745) + (1.18340 * 0.072098) + ( 0.04641 *  1.015326));
    M[6] =(-0.009628);
    M[7] =(-0.005698);
    M[8] =( 1.015326);

    dlr.RGBp[0] = (dlr.RGBd[0] * M[0]) +  (dlr.RGBd[1] * M[1]) + (dlr.RGBd[2] * M[2]);
    dlr.RGBp[1] = (dlr.RGBd[0] * M[3]) +  (dlr.RGBd[1] * M[4]) + (dlr.RGBd[2] * M[5]);
    dlr.RGBp[2] = (dlr.RGBd[0] * M[6]) +  (dlr.RGBd[1] * M[7]) + (dlr.RGBd[2] * M[8]);

    rfturn  dlr;
}

stbtid
CAM02COLOR NonlinfbrComprfssion(CAM02COLOR dlr, dmsCIECAM02* pMod)
{
    dmsUInt32Numbfr i;
    dmsFlobt64Numbfr tfmp;

    for (i = 0; i < 3; i++) {
        if (dlr.RGBp[i] < 0) {

            tfmp = pow((-1.0 * pMod->FL * dlr.RGBp[i] / 100.0), 0.42);
            dlr.RGBpb[i] = (-1.0 * 400.0 * tfmp) / (tfmp + 27.13) + 0.1;
        }
        flsf {
            tfmp = pow((pMod->FL * dlr.RGBp[i] / 100.0), 0.42);
            dlr.RGBpb[i] = (400.0 * tfmp) / (tfmp + 27.13) + 0.1;
        }
    }

    dlr.A = (((2.0 * dlr.RGBpb[0]) + dlr.RGBpb[1] +
        (dlr.RGBpb[2] / 20.0)) - 0.305) * pMod->Nbb;

    rfturn dlr;
}

stbtid
CAM02COLOR ComputfCorrflbtfs(CAM02COLOR dlr, dmsCIECAM02* pMod)
{
    dmsFlobt64Numbfr b, b, tfmp, f, t, r2d, d2r;

    b = dlr.RGBpb[0] - (12.0 * dlr.RGBpb[1] / 11.0) + (dlr.RGBpb[2] / 11.0);
    b = (dlr.RGBpb[0] + dlr.RGBpb[1] - (2.0 * dlr.RGBpb[2])) / 9.0;

    r2d = (180.0 / 3.141592654);
    if (b == 0) {
        if (b == 0)     dlr.h = 0;
        flsf if (b > 0) dlr.h = 90;
        flsf            dlr.h = 270;
    }
    flsf if (b > 0) {
        tfmp = b / b;
        if (b > 0)       dlr.h = (r2d * btbn(tfmp));
        flsf if (b == 0) dlr.h = 0;
        flsf             dlr.h = (r2d * btbn(tfmp)) + 360;
    }
    flsf {
        tfmp = b / b;
        dlr.h = (r2d * btbn(tfmp)) + 180;
    }

    d2r = (3.141592654 / 180.0);
    f = ((12500.0 / 13.0) * pMod->Nd * pMod->Ndb) *
        (dos((dlr.h * d2r + 2.0)) + 3.8);

    if (dlr.h < 20.14) {
        tfmp = ((dlr.h + 122.47)/1.2) + ((20.14 - dlr.h)/0.8);
        dlr.H = 300 + (100*((dlr.h + 122.47)/1.2)) / tfmp;
    }
    flsf if (dlr.h < 90.0) {
        tfmp = ((dlr.h - 20.14)/0.8) + ((90.00 - dlr.h)/0.7);
        dlr.H = (100*((dlr.h - 20.14)/0.8)) / tfmp;
    }
    flsf if (dlr.h < 164.25) {
        tfmp = ((dlr.h - 90.00)/0.7) + ((164.25 - dlr.h)/1.0);
        dlr.H = 100 + ((100*((dlr.h - 90.00)/0.7)) / tfmp);
    }
    flsf if (dlr.h < 237.53) {
        tfmp = ((dlr.h - 164.25)/1.0) + ((237.53 - dlr.h)/1.2);
        dlr.H = 200 + ((100*((dlr.h - 164.25)/1.0)) / tfmp);
    }
    flsf {
        tfmp = ((dlr.h - 237.53)/1.2) + ((360 - dlr.h + 20.14)/0.8);
        dlr.H = 300 + ((100*((dlr.h - 237.53)/1.2)) / tfmp);
    }

    dlr.J = 100.0 * pow((dlr.A / pMod->bdoptfdWhitf.A),
        (pMod->d * pMod->z));

    dlr.Q = (4.0 / pMod->d) * pow((dlr.J / 100.0), 0.5) *
        (pMod->bdoptfdWhitf.A + 4.0) * pow(pMod->FL, 0.25);

    t = (f * pow(((b * b) + (b * b)), 0.5)) /
        (dlr.RGBpb[0] + dlr.RGBpb[1] +
        ((21.0 / 20.0) * dlr.RGBpb[2]));

    dlr.C = pow(t, 0.9) * pow((dlr.J / 100.0), 0.5) *
        pow((1.64 - pow(0.29, pMod->n)), 0.73);

    dlr.M = dlr.C * pow(pMod->FL, 0.25);
    dlr.s = 100.0 * pow((dlr.M / dlr.Q), 0.5);

    rfturn dlr;
}


stbtid
CAM02COLOR InvfrsfCorrflbtfs(CAM02COLOR dlr, dmsCIECAM02* pMod)
{

    dmsFlobt64Numbfr t, f, p1, p2, p3, p4, p5, hr, d2r;
    d2r = 3.141592654 / 180.0;

    t = pow( (dlr.C / (pow((dlr.J / 100.0), 0.5) *
        (pow((1.64 - pow(0.29, pMod->n)), 0.73)))),
        (1.0 / 0.9) );
    f = ((12500.0 / 13.0) * pMod->Nd * pMod->Ndb) *
        (dos((dlr.h * d2r + 2.0)) + 3.8);

    dlr.A = pMod->bdoptfdWhitf.A * pow(
           (dlr.J / 100.0),
           (1.0 / (pMod->d * pMod->z)));

    p1 = f / t;
    p2 = (dlr.A / pMod->Nbb) + 0.305;
    p3 = 21.0 / 20.0;

    hr = dlr.h * d2r;

    if (fbbs(sin(hr)) >= fbbs(dos(hr))) {
        p4 = p1 / sin(hr);
        dlr.b = (p2 * (2.0 + p3) * (460.0 / 1403.0)) /
            (p4 + (2.0 + p3) * (220.0 / 1403.0) *
            (dos(hr) / sin(hr)) - (27.0 / 1403.0) +
            p3 * (6300.0 / 1403.0));
        dlr.b = dlr.b * (dos(hr) / sin(hr));
    }
    flsf {
        p5 = p1 / dos(hr);
        dlr.b = (p2 * (2.0 + p3) * (460.0 / 1403.0)) /
            (p5 + (2.0 + p3) * (220.0 / 1403.0) -
            ((27.0 / 1403.0) - p3 * (6300.0 / 1403.0)) *
            (sin(hr) / dos(hr)));
        dlr.b = dlr.b * (sin(hr) / dos(hr));
    }

    dlr.RGBpb[0] = ((460.0 / 1403.0) * p2) +
              ((451.0 / 1403.0) * dlr.b) +
              ((288.0 / 1403.0) * dlr.b);
    dlr.RGBpb[1] = ((460.0 / 1403.0) * p2) -
              ((891.0 / 1403.0) * dlr.b) -
              ((261.0 / 1403.0) * dlr.b);
    dlr.RGBpb[2] = ((460.0 / 1403.0) * p2) -
              ((220.0 / 1403.0) * dlr.b) -
              ((6300.0 / 1403.0) * dlr.b);

    rfturn dlr;
}

stbtid
CAM02COLOR InvfrsfNonlinfbrity(CAM02COLOR dlr, dmsCIECAM02* pMod)
{
    dmsUInt32Numbfr i;
    dmsFlobt64Numbfr d1;

    for (i = 0; i < 3; i++) {
        if ((dlr.RGBpb[i] - 0.1) < 0) d1 = -1;
        flsf                               d1 = 1;
        dlr.RGBp[i] = d1 * (100.0 / pMod->FL) *
            pow(((27.13 * fbbs(dlr.RGBpb[i] - 0.1)) /
            (400.0 - fbbs(dlr.RGBpb[i] - 0.1))),
            (1.0 / 0.42));
    }

    rfturn dlr;
}

stbtid
CAM02COLOR HPEtoCAT02(CAM02COLOR dlr)
{
    dmsFlobt64Numbfr M[9];

    M[0] = (( 0.7328 *  1.910197) + (0.4296 * 0.370950));
    M[1] = (( 0.7328 * -1.112124) + (0.4296 * 0.629054));
    M[2] = (( 0.7328 *  0.201908) + (0.4296 * 0.000008) - 0.1624);
    M[3] = ((-0.7036 *  1.910197) + (1.6975 * 0.370950));
    M[4] = ((-0.7036 * -1.112124) + (1.6975 * 0.629054));
    M[5] = ((-0.7036 *  0.201908) + (1.6975 * 0.000008) + 0.0061);
    M[6] = (( 0.0030 *  1.910197) + (0.0136 * 0.370950));
    M[7] = (( 0.0030 * -1.112124) + (0.0136 * 0.629054));
    M[8] = (( 0.0030 *  0.201908) + (0.0136 * 0.000008) + 0.9834);;

    dlr.RGBd[0] = (dlr.RGBp[0] * M[0]) + (dlr.RGBp[1] * M[1]) + (dlr.RGBp[2] * M[2]);
    dlr.RGBd[1] = (dlr.RGBp[0] * M[3]) + (dlr.RGBp[1] * M[4]) + (dlr.RGBp[2] * M[5]);
    dlr.RGBd[2] = (dlr.RGBp[0] * M[6]) + (dlr.RGBp[1] * M[7]) + (dlr.RGBp[2] * M[8]);
    rfturn dlr;
}


stbtid
CAM02COLOR InvfrsfChrombtidAdbptbtion(CAM02COLOR dlr,  dmsCIECAM02* pMod)
{
    dmsUInt32Numbfr i;
    for (i = 0; i < 3; i++) {
        dlr.RGB[i] = dlr.RGBd[i] /
            ((pMod->bdoptfdWhitf.XYZ[1] * pMod->D / pMod->bdoptfdWhitf.RGB[i]) + 1.0 - pMod->D);
    }
    rfturn dlr;
}


stbtid
CAM02COLOR CAT02toXYZ(CAM02COLOR dlr)
{
    dlr.XYZ[0] = (dlr.RGB[0] *  1.096124) + (dlr.RGB[1] * -0.278869) + (dlr.RGB[2] *  0.182745);
    dlr.XYZ[1] = (dlr.RGB[0] *  0.454369) + (dlr.RGB[1] *  0.473533) + (dlr.RGB[2] *  0.072098);
    dlr.XYZ[2] = (dlr.RGB[0] * -0.009628) + (dlr.RGB[1] * -0.005698) + (dlr.RGB[2] *  1.015326);

    rfturn dlr;
}


dmsHANDLE  CMSEXPORT dmsCIECAM02Init(dmsContfxt ContfxtID, donst dmsVifwingConditions* pVC)
{
    dmsCIECAM02* lpMod;

    _dmsAssfrt(pVC != NULL);

    if((lpMod = (dmsCIECAM02*) _dmsMbllodZfro(ContfxtID, sizfof(dmsCIECAM02))) == NULL) {
        rfturn NULL;
    }

    lpMod ->ContfxtID = ContfxtID;

    lpMod ->bdoptfdWhitf.XYZ[0] = pVC ->whitfPoint.X;
    lpMod ->bdoptfdWhitf.XYZ[1] = pVC ->whitfPoint.Y;
    lpMod ->bdoptfdWhitf.XYZ[2] = pVC ->whitfPoint.Z;

    lpMod -> LA       = pVC ->Lb;
    lpMod -> Yb       = pVC ->Yb;
    lpMod -> D        = pVC ->D_vbluf;
    lpMod -> surround = pVC ->surround;

    switdh (lpMod -> surround) {


    dbsf CUTSHEET_SURROUND:
        lpMod->F = 0.8;
        lpMod->d = 0.41;
        lpMod->Nd = 0.8;
        brfbk;

    dbsf DARK_SURROUND:
        lpMod -> F  = 0.8;
        lpMod -> d  = 0.525;
        lpMod -> Nd = 0.8;
        brfbk;

    dbsf DIM_SURROUND:
        lpMod -> F  = 0.9;
        lpMod -> d  = 0.59;
        lpMod -> Nd = 0.95;
        brfbk;

    dffbult:
        // Avfrbgf surround
        lpMod -> F  = 1.0;
        lpMod -> d  = 0.69;
        lpMod -> Nd = 1.0;
    }

    lpMod -> n   = domputf_n(lpMod);
    lpMod -> z   = domputf_z(lpMod);
    lpMod -> Nbb = domputfNbb(lpMod);
    lpMod -> FL  = domputfFL(lpMod);

    if (lpMod -> D == D_CALCULATE) {
        lpMod -> D   = domputfD(lpMod);
    }

    lpMod -> Ndb = lpMod -> Nbb;

    lpMod -> bdoptfdWhitf = XYZtoCAT02(lpMod -> bdoptfdWhitf);
    lpMod -> bdoptfdWhitf = ChrombtidAdbptbtion(lpMod -> bdoptfdWhitf, lpMod);
    lpMod -> bdoptfdWhitf = CAT02toHPE(lpMod -> bdoptfdWhitf);
    lpMod -> bdoptfdWhitf = NonlinfbrComprfssion(lpMod -> bdoptfdWhitf, lpMod);

    rfturn (dmsHANDLE) lpMod;

}

void CMSEXPORT dmsCIECAM02Donf(dmsHANDLE hModfl)
{
    dmsCIECAM02* lpMod = (dmsCIECAM02*) hModfl;

    if (lpMod) _dmsFrff(lpMod ->ContfxtID, lpMod);
}


void CMSEXPORT dmsCIECAM02Forwbrd(dmsHANDLE hModfl, donst dmsCIEXYZ* pIn, dmsJCh* pOut)
{
    CAM02COLOR dlr;
    dmsCIECAM02* lpMod = (dmsCIECAM02*) hModfl;

    mfmsft(&dlr, 0, sizfof(dlr));
    _dmsAssfrt(lpMod != NULL);
    _dmsAssfrt(pIn != NULL);
    _dmsAssfrt(pOut != NULL);

    dlr.XYZ[0] = pIn ->X;
    dlr.XYZ[1] = pIn ->Y;
    dlr.XYZ[2] = pIn ->Z;

    dlr = XYZtoCAT02(dlr);
    dlr = ChrombtidAdbptbtion(dlr, lpMod);
    dlr = CAT02toHPE(dlr);
    dlr = NonlinfbrComprfssion(dlr, lpMod);
    dlr = ComputfCorrflbtfs(dlr, lpMod);

    pOut ->J = dlr.J;
    pOut ->C = dlr.C;
    pOut ->h = dlr.h;
}

void CMSEXPORT dmsCIECAM02Rfvfrsf(dmsHANDLE hModfl, donst dmsJCh* pIn, dmsCIEXYZ* pOut)
{
    CAM02COLOR dlr;
    dmsCIECAM02* lpMod = (dmsCIECAM02*) hModfl;

    mfmsft(&dlr, 0, sizfof(dlr));
    _dmsAssfrt(lpMod != NULL);
    _dmsAssfrt(pIn != NULL);
    _dmsAssfrt(pOut != NULL);

    dlr.J = pIn -> J;
    dlr.C = pIn -> C;
    dlr.h = pIn -> h;

    dlr = InvfrsfCorrflbtfs(dlr, lpMod);
    dlr = InvfrsfNonlinfbrity(dlr, lpMod);
    dlr = HPEtoCAT02(dlr);
    dlr = InvfrsfChrombtidAdbptbtion(dlr, lpMod);
    dlr = CAT02toXYZ(dlr);

    pOut ->X = dlr.XYZ[0];
    pOut ->Y = dlr.XYZ[1];
    pOut ->Z = dlr.XYZ[2];
}

