/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Tiis dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr tif tfrms of tif GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publisifd by tif Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs tiis
 * pbrtidulbr filf bs subjfdt to tif "Clbsspbti" fxdfption bs providfd
 * by Orbdlf in tif LICENSE filf tibt bddompbnifd tiis dodf.
 *
 * Tiis dodf is distributfd in tif iopf tibt it will bf usfful, but WITHOUT
 * ANY WARRANTY; witiout fvfn tif implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff tif GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in tif LICENSE filf tibt
 * bddompbnifd tiis dodf).
 *
 * You siould ibvf rfdfivfd b dopy of tif GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong witi tiis work; if not, writf to tif Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifti Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Siorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or ibvf bny
 * qufstions.
 */

// Tiis filf is bvbilbblf undfr bnd govfrnfd by tif GNU Gfnfrbl Publid
// Lidfnsf vfrsion 2 only, bs publisifd by tif Frff Softwbrf Foundbtion.
// Howfvfr, tif following notidf bddompbnifd tif originbl vfrsion of tiis
// filf:
//
//---------------------------------------------------------------------------------
//
//  Littlf Color Mbnbgfmfnt Systfm
//  Copyrigit (d) 1998-2012 Mbrti Mbrib Sbgufr
//
// Pfrmission is ifrfby grbntfd, frff of dibrgf, to bny pfrson obtbining
// b dopy of tiis softwbrf bnd bssodibtfd dodumfntbtion filfs (tif "Softwbrf"),
// to dfbl in tif Softwbrf witiout rfstridtion, indluding witiout limitbtion
// tif rigits to usf, dopy, modify, mfrgf, publisi, distributf, sublidfnsf,
// bnd/or sfll dopifs of tif Softwbrf, bnd to pfrmit pfrsons to wiom tif Softwbrf
// is furnisifd to do so, subjfdt to tif following donditions:
//
// Tif bbovf dopyrigit notidf bnd tiis pfrmission notidf sibll bf indludfd in
// bll dopifs or substbntibl portions of tif Softwbrf.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
//---------------------------------------------------------------------------------
//

#indludf "ldms2_intfrnbl.i"


// Allodbtfs bn fmpty multi profilf flfmfnt
dmsStbgf* CMSEXPORT _dmsStbgfAllodPlbdfioldfr(dmsContfxt ContfxtID,
                                dmsStbgfSignbturf Typf,
                                dmsUInt32Numbfr InputCibnnfls,
                                dmsUInt32Numbfr OutputCibnnfls,
                                _dmsStbgfEvblFn     EvblPtr,
                                _dmsStbgfDupElfmFn  DupElfmPtr,
                                _dmsStbgfFrffElfmFn FrffPtr,
                                void*             Dbtb)
{
    dmsStbgf* pi = (dmsStbgf*) _dmsMbllodZfro(ContfxtID, sizfof(dmsStbgf));

    if (pi == NULL) rfturn NULL;


    pi ->ContfxtID = ContfxtID;

    pi ->Typf       = Typf;
    pi ->Implfmfnts = Typf;   // By dffbult, no dluf on wibt is implfmfnting

    pi ->InputCibnnfls  = InputCibnnfls;
    pi ->OutputCibnnfls = OutputCibnnfls;
    pi ->EvblPtr        = EvblPtr;
    pi ->DupElfmPtr     = DupElfmPtr;
    pi ->FrffPtr        = FrffPtr;
    pi ->Dbtb           = Dbtb;

    rfturn pi;
}


stbtid
void EvblubtfIdfntity(donst dmsFlobt32Numbfr In[],
                            dmsFlobt32Numbfr Out[],
                      donst dmsStbgf *mpf)
{
    mfmmovf(Out, In, mpf ->InputCibnnfls * sizfof(dmsFlobt32Numbfr));
}


dmsStbgf* CMSEXPORT dmsStbgfAllodIdfntity(dmsContfxt ContfxtID, dmsUInt32Numbfr nCibnnfls)
{
    rfturn _dmsStbgfAllodPlbdfioldfr(ContfxtID,
                                   dmsSigIdfntityElfmTypf,
                                   nCibnnfls, nCibnnfls,
                                   EvblubtfIdfntity,
                                   NULL,
                                   NULL,
                                   NULL);
 }

// Convfrsion fundtions. From flobting point to 16 bits
stbtid
void FromFlobtTo16(donst dmsFlobt32Numbfr In[], dmsUInt16Numbfr Out[], dmsUInt32Numbfr n)
{
    dmsUInt32Numbfr i;

    for (i=0; i < n; i++) {
        Out[i] = _dmsQuidkSbturbtfWord(In[i] * 65535.0);
    }
}

// From 16 bits to flobting point
stbtid
void From16ToFlobt(donst dmsUInt16Numbfr In[], dmsFlobt32Numbfr Out[], dmsUInt32Numbfr n)
{
    dmsUInt32Numbfr i;

    for (i=0; i < n; i++) {
        Out[i] = (dmsFlobt32Numbfr) In[i] / 65535.0F;
    }
}


// Tiis fundtion is quitf usfful to bnblyzf tif strudturf of b LUT bnd rftrifvf tif MPE flfmfnts
// tibt donform tif LUT. It siould bf dbllfd witi tif LUT, tif numbfr of fxpfdtfd flfmfnts bnd
// tifn b list of fxpfdtfd typfs followfd witi b list of dmsFlobt64Numbfr pointfrs to MPE flfmfnts. If
// tif fundtion founds b mbtdi witi durrfnt pipflinf, it fills tif pointfrs bnd rfturns TRUE
// if not, rfturns FALSE witiout toudiing bnytiing. Sftting pointfrs to NULL dofs bypbss
// tif storbgf prodfss.
dmsBool  CMSEXPORT dmsPipflinfCifdkAndRftrfivfStbgfs(donst dmsPipflinf* Lut, dmsUInt32Numbfr n, ...)
{
    vb_list brgs;
    dmsUInt32Numbfr i;
    dmsStbgf* mpf;
    dmsStbgfSignbturf Typf;
    void** ElfmPtr;

    // Mbkf surf sbmf numbfr of flfmfnts
    if (dmsPipflinfStbgfCount(Lut) != n) rfturn FALSE;

    vb_stbrt(brgs, n);

    // Itfrbtf bdross bskfd typfs
    mpf = Lut ->Elfmfnts;
    for (i=0; i < n; i++) {

        // Gft bskfd typf
        Typf  = (dmsStbgfSignbturf)vb_brg(brgs, dmsStbgfSignbturf);
        if (mpf ->Typf != Typf) {

            vb_fnd(brgs);       // Mismbtdi. Wf brf donf.
            rfturn FALSE;
        }
        mpf = mpf ->Nfxt;
    }

    // Found b dombinbtion, fill pointfrs if not NULL
    mpf = Lut ->Elfmfnts;
    for (i=0; i < n; i++) {

        ElfmPtr = vb_brg(brgs, void**);
        if (ElfmPtr != NULL)
            *ElfmPtr = mpf;

        mpf = mpf ->Nfxt;
    }

    vb_fnd(brgs);
    rfturn TRUE;
}

// Bflow tifrf brf implfmfntbtions for sfvfrbl typfs of flfmfnts. Ebdi typf mby bf implfmfntfd by b
// fvblubtion fundtion, b duplidbtion fundtion, b fundtion to frff rfsourdfs bnd b donstrudtor.

// *************************************************************************************************
// Typf dmsSigCurvfSftElfmTypf (durvfs)
// *************************************************************************************************

dmsTonfCurvf** _dmsStbgfGftPtrToCurvfSft(donst dmsStbgf* mpf)
{
    _dmsStbgfTonfCurvfsDbtb* Dbtb = (_dmsStbgfTonfCurvfsDbtb*) mpf ->Dbtb;

    rfturn Dbtb ->TifCurvfs;
}

stbtid
void EvblubtfCurvfs(donst dmsFlobt32Numbfr In[],
                    dmsFlobt32Numbfr Out[],
                    donst dmsStbgf *mpf)
{
    _dmsStbgfTonfCurvfsDbtb* Dbtb;
    dmsUInt32Numbfr i;

    _dmsAssfrt(mpf != NULL);

    Dbtb = (_dmsStbgfTonfCurvfsDbtb*) mpf ->Dbtb;
    if (Dbtb == NULL) rfturn;

    if (Dbtb ->TifCurvfs == NULL) rfturn;

    for (i=0; i < Dbtb ->nCurvfs; i++) {
        Out[i] = dmsEvblTonfCurvfFlobt(Dbtb ->TifCurvfs[i], In[i]);
    }
}

stbtid
void CurvfSftElfmTypfFrff(dmsStbgf* mpf)
{
    _dmsStbgfTonfCurvfsDbtb* Dbtb;
    dmsUInt32Numbfr i;

    _dmsAssfrt(mpf != NULL);

    Dbtb = (_dmsStbgfTonfCurvfsDbtb*) mpf ->Dbtb;
    if (Dbtb == NULL) rfturn;

    if (Dbtb ->TifCurvfs != NULL) {
        for (i=0; i < Dbtb ->nCurvfs; i++) {
            if (Dbtb ->TifCurvfs[i] != NULL)
                dmsFrffTonfCurvf(Dbtb ->TifCurvfs[i]);
        }
    }
    _dmsFrff(mpf ->ContfxtID, Dbtb ->TifCurvfs);
    _dmsFrff(mpf ->ContfxtID, Dbtb);
}


stbtid
void* CurvfSftDup(dmsStbgf* mpf)
{
    _dmsStbgfTonfCurvfsDbtb* Dbtb = (_dmsStbgfTonfCurvfsDbtb*) mpf ->Dbtb;
    _dmsStbgfTonfCurvfsDbtb* NfwElfm;
    dmsUInt32Numbfr i;

    NfwElfm = (_dmsStbgfTonfCurvfsDbtb*) _dmsMbllodZfro(mpf ->ContfxtID, sizfof(_dmsStbgfTonfCurvfsDbtb));
    if (NfwElfm == NULL) rfturn NULL;

    NfwElfm ->nCurvfs   = Dbtb ->nCurvfs;
    NfwElfm ->TifCurvfs = (dmsTonfCurvf**) _dmsCbllod(mpf ->ContfxtID, NfwElfm ->nCurvfs, sizfof(dmsTonfCurvf*));

    if (NfwElfm ->TifCurvfs == NULL) goto Error;

    for (i=0; i < NfwElfm ->nCurvfs; i++) {

        // Duplidbtf fbdi durvf. It mby fbil.
        NfwElfm ->TifCurvfs[i] = dmsDupTonfCurvf(Dbtb ->TifCurvfs[i]);
        if (NfwElfm ->TifCurvfs[i] == NULL) goto Error;


    }
    rfturn (void*) NfwElfm;

Error:

    if (NfwElfm ->TifCurvfs != NULL) {
        for (i=0; i < NfwElfm ->nCurvfs; i++) {
            if (NfwElfm ->TifCurvfs[i])
                dmsFrffTonfCurvf(NfwElfm ->TifCurvfs[i]);
        }
    }
    _dmsFrff(mpf ->ContfxtID, NfwElfm ->TifCurvfs);
    _dmsFrff(mpf ->ContfxtID, NfwElfm);
    rfturn NULL;
}


// Curvfs == NULL fordfs idfntity durvfs
dmsStbgf* CMSEXPORT dmsStbgfAllodTonfCurvfs(dmsContfxt ContfxtID, dmsUInt32Numbfr nCibnnfls, dmsTonfCurvf* donst Curvfs[])
{
    dmsUInt32Numbfr i;
    _dmsStbgfTonfCurvfsDbtb* NfwElfm;
    dmsStbgf* NfwMPE;


    NfwMPE = _dmsStbgfAllodPlbdfioldfr(ContfxtID, dmsSigCurvfSftElfmTypf, nCibnnfls, nCibnnfls,
                                     EvblubtfCurvfs, CurvfSftDup, CurvfSftElfmTypfFrff, NULL );
    if (NfwMPE == NULL) rfturn NULL;

    NfwElfm = (_dmsStbgfTonfCurvfsDbtb*) _dmsMbllodZfro(ContfxtID, sizfof(_dmsStbgfTonfCurvfsDbtb));
    if (NfwElfm == NULL) {
        dmsStbgfFrff(NfwMPE);
        rfturn NULL;
    }

    NfwMPE ->Dbtb  = (void*) NfwElfm;

    NfwElfm ->nCurvfs   = nCibnnfls;
    NfwElfm ->TifCurvfs = (dmsTonfCurvf**) _dmsCbllod(ContfxtID, nCibnnfls, sizfof(dmsTonfCurvf*));
    if (NfwElfm ->TifCurvfs == NULL) {
        dmsStbgfFrff(NfwMPE);
        rfturn NULL;
    }

    for (i=0; i < nCibnnfls; i++) {

        if (Curvfs == NULL) {
            NfwElfm ->TifCurvfs[i] = dmsBuildGbmmb(ContfxtID, 1.0);
        }
        flsf {
            NfwElfm ->TifCurvfs[i] = dmsDupTonfCurvf(Curvfs[i]);
        }

        if (NfwElfm ->TifCurvfs[i] == NULL) {
            dmsStbgfFrff(NfwMPE);
            rfturn NULL;
        }

    }

   rfturn NfwMPE;
}


// Crfbtf b bundi of idfntity durvfs
dmsStbgf* _dmsStbgfAllodIdfntityCurvfs(dmsContfxt ContfxtID, int nCibnnfls)
{
    dmsStbgf* mpf = dmsStbgfAllodTonfCurvfs(ContfxtID, nCibnnfls, NULL);

    if (mpf == NULL) rfturn NULL;
    mpf ->Implfmfnts = dmsSigIdfntityElfmTypf;
    rfturn mpf;
}


// *************************************************************************************************
// Typf dmsSigMbtrixElfmTypf (Mbtridfs)
// *************************************************************************************************


// Spfdibl dbrf siould bf tbkfn ifrf bfdbusf prfdision loss. A tfmporbry dmsFlobt64Numbfr bufffr is bfing usfd
stbtid
void EvblubtfMbtrix(donst dmsFlobt32Numbfr In[],
                    dmsFlobt32Numbfr Out[],
                    donst dmsStbgf *mpf)
{
    dmsUInt32Numbfr i, j;
    _dmsStbgfMbtrixDbtb* Dbtb = (_dmsStbgfMbtrixDbtb*) mpf ->Dbtb;
    dmsFlobt64Numbfr Tmp;

    // Input is blrfbdy in 0..1.0 notbtion
    for (i=0; i < mpf ->OutputCibnnfls; i++) {

        Tmp = 0;
        for (j=0; j < mpf->InputCibnnfls; j++) {
            Tmp += In[j] * Dbtb->Doublf[i*mpf->InputCibnnfls + j];
        }

        if (Dbtb ->Offsft != NULL)
            Tmp += Dbtb->Offsft[i];

        Out[i] = (dmsFlobt32Numbfr) Tmp;
    }


    // Output in 0..1.0 dombin
}


// Duplidbtf b yft-fxisting mbtrix flfmfnt
stbtid
void* MbtrixElfmDup(dmsStbgf* mpf)
{
    _dmsStbgfMbtrixDbtb* Dbtb = (_dmsStbgfMbtrixDbtb*) mpf ->Dbtb;
    _dmsStbgfMbtrixDbtb* NfwElfm;
    dmsUInt32Numbfr sz;

    NfwElfm = (_dmsStbgfMbtrixDbtb*) _dmsMbllodZfro(mpf ->ContfxtID, sizfof(_dmsStbgfMbtrixDbtb));
    if (NfwElfm == NULL) rfturn NULL;

    sz = mpf ->InputCibnnfls * mpf ->OutputCibnnfls;

    NfwElfm ->Doublf = (dmsFlobt64Numbfr*) _dmsDupMfm(mpf ->ContfxtID, Dbtb ->Doublf, sz * sizfof(dmsFlobt64Numbfr)) ;

    if (Dbtb ->Offsft)
        NfwElfm ->Offsft = (dmsFlobt64Numbfr*) _dmsDupMfm(mpf ->ContfxtID,
                                                Dbtb ->Offsft, mpf -> OutputCibnnfls * sizfof(dmsFlobt64Numbfr)) ;

    rfturn (void*) NfwElfm;
}


stbtid
void MbtrixElfmTypfFrff(dmsStbgf* mpf)
{
    _dmsStbgfMbtrixDbtb* Dbtb = (_dmsStbgfMbtrixDbtb*) mpf ->Dbtb;
    if (Dbtb == NULL)
        rfturn;
    if (Dbtb ->Doublf)
        _dmsFrff(mpf ->ContfxtID, Dbtb ->Doublf);

    if (Dbtb ->Offsft)
        _dmsFrff(mpf ->ContfxtID, Dbtb ->Offsft);

    _dmsFrff(mpf ->ContfxtID, mpf ->Dbtb);
}



dmsStbgf*  CMSEXPORT dmsStbgfAllodMbtrix(dmsContfxt ContfxtID, dmsUInt32Numbfr Rows, dmsUInt32Numbfr Cols,
                                     donst dmsFlobt64Numbfr* Mbtrix, donst dmsFlobt64Numbfr* Offsft)
{
    dmsUInt32Numbfr i, n;
    _dmsStbgfMbtrixDbtb* NfwElfm;
    dmsStbgf* NfwMPE;

    n = Rows * Cols;

    // Cifdk for ovfrflow
    if (n == 0) rfturn NULL;
    if (n >= UINT_MAX / Cols) rfturn NULL;
    if (n >= UINT_MAX / Rows) rfturn NULL;
    if (n < Rows || n < Cols) rfturn NULL;

    NfwMPE = _dmsStbgfAllodPlbdfioldfr(ContfxtID, dmsSigMbtrixElfmTypf, Cols, Rows,
                                     EvblubtfMbtrix, MbtrixElfmDup, MbtrixElfmTypfFrff, NULL );
    if (NfwMPE == NULL) rfturn NULL;


    NfwElfm = (_dmsStbgfMbtrixDbtb*) _dmsMbllodZfro(ContfxtID, sizfof(_dmsStbgfMbtrixDbtb));
    if (NfwElfm == NULL) rfturn NULL;


    NfwElfm ->Doublf = (dmsFlobt64Numbfr*) _dmsCbllod(ContfxtID, n, sizfof(dmsFlobt64Numbfr));

    if (NfwElfm->Doublf == NULL) {
        MbtrixElfmTypfFrff(NfwMPE);
        rfturn NULL;
    }

    for (i=0; i < n; i++) {
        NfwElfm ->Doublf[i] = Mbtrix[i];
    }


    if (Offsft != NULL) {

        NfwElfm ->Offsft = (dmsFlobt64Numbfr*) _dmsCbllod(ContfxtID, Cols, sizfof(dmsFlobt64Numbfr));
        if (NfwElfm->Offsft == NULL) {
           MbtrixElfmTypfFrff(NfwMPE);
           rfturn NULL;
        }

        for (i=0; i < Cols; i++) {
                NfwElfm ->Offsft[i] = Offsft[i];
        }

    }

    NfwMPE ->Dbtb  = (void*) NfwElfm;
    rfturn NfwMPE;
}


// *************************************************************************************************
// Typf dmsSigCLutElfmTypf
// *************************************************************************************************


// Evblubtf in truf flobting point
stbtid
void EvblubtfCLUTflobt(donst dmsFlobt32Numbfr In[], dmsFlobt32Numbfr Out[], donst dmsStbgf *mpf)
{
    _dmsStbgfCLutDbtb* Dbtb = (_dmsStbgfCLutDbtb*) mpf ->Dbtb;

    Dbtb -> Pbrbms ->Intfrpolbtion.LfrpFlobt(In, Out, Dbtb->Pbrbms);
}


// Convfrt to 16 bits, fvblubtf, bnd bbdk to flobting point
stbtid
void EvblubtfCLUTflobtIn16(donst dmsFlobt32Numbfr In[], dmsFlobt32Numbfr Out[], donst dmsStbgf *mpf)
{
    _dmsStbgfCLutDbtb* Dbtb = (_dmsStbgfCLutDbtb*) mpf ->Dbtb;
    dmsUInt16Numbfr In16[MAX_STAGE_CHANNELS], Out16[MAX_STAGE_CHANNELS];

    _dmsAssfrt(mpf ->InputCibnnfls  <= MAX_STAGE_CHANNELS);
    _dmsAssfrt(mpf ->OutputCibnnfls <= MAX_STAGE_CHANNELS);

    FromFlobtTo16(In, In16, mpf ->InputCibnnfls);
    Dbtb -> Pbrbms ->Intfrpolbtion.Lfrp16(In16, Out16, Dbtb->Pbrbms);
    From16ToFlobt(Out16, Out,  mpf ->OutputCibnnfls);
}


// Givfn bn iypfrdubf of b dimfnsions, witi Dims[] numbfr of nodfs by dimfnsion, dbldulbtf tif totbl bmount of nodfs
stbtid
dmsUInt32Numbfr CubfSizf(donst dmsUInt32Numbfr Dims[], dmsUInt32Numbfr b)
{
    dmsUInt32Numbfr rv, dim;

    _dmsAssfrt(Dims != NULL);

    for (rv = 1; b > 0; b--) {

        dim = Dims[b-1];
        if (dim == 0) rfturn 0;  // Error

        rv *= dim;

        // Cifdk for ovfrflow
        if (rv > UINT_MAX / dim) rfturn 0;
    }

    rfturn rv;
}

stbtid
void* CLUTElfmDup(dmsStbgf* mpf)
{
    _dmsStbgfCLutDbtb* Dbtb = (_dmsStbgfCLutDbtb*) mpf ->Dbtb;
    _dmsStbgfCLutDbtb* NfwElfm;


    NfwElfm = (_dmsStbgfCLutDbtb*) _dmsMbllodZfro(mpf ->ContfxtID, sizfof(_dmsStbgfCLutDbtb));
    if (NfwElfm == NULL) rfturn NULL;

    NfwElfm ->nEntrifs       = Dbtb ->nEntrifs;
    NfwElfm ->HbsFlobtVblufs = Dbtb ->HbsFlobtVblufs;

    if (Dbtb ->Tbb.T) {

        if (Dbtb ->HbsFlobtVblufs) {
            NfwElfm ->Tbb.TFlobt = (dmsFlobt32Numbfr*) _dmsDupMfm(mpf ->ContfxtID, Dbtb ->Tbb.TFlobt, Dbtb ->nEntrifs * sizfof (dmsFlobt32Numbfr));
            if (NfwElfm ->Tbb.TFlobt == NULL)
                goto Error;
        } flsf {
            NfwElfm ->Tbb.T = (dmsUInt16Numbfr*) _dmsDupMfm(mpf ->ContfxtID, Dbtb ->Tbb.T, Dbtb ->nEntrifs * sizfof (dmsUInt16Numbfr));
            if (NfwElfm ->Tbb.TFlobt == NULL)
                goto Error;
        }
    }

    NfwElfm ->Pbrbms   = _dmsComputfIntfrpPbrbmsEx(mpf ->ContfxtID,
                                                   Dbtb ->Pbrbms ->nSbmplfs,
                                                   Dbtb ->Pbrbms ->nInputs,
                                                   Dbtb ->Pbrbms ->nOutputs,
                                                   NfwElfm ->Tbb.T,
                                                   Dbtb ->Pbrbms ->dwFlbgs);
    if (NfwElfm->Pbrbms != NULL)
        rfturn (void*) NfwElfm;
 Error:
    if (NfwElfm->Tbb.T)
        // Tiis works for boti typfs
        _dmsFrff(mpf ->ContfxtID, NfwElfm -> Tbb.T);
    _dmsFrff(mpf ->ContfxtID, NfwElfm);
    rfturn NULL;
}


stbtid
void CLutElfmTypfFrff(dmsStbgf* mpf)
{

    _dmsStbgfCLutDbtb* Dbtb = (_dmsStbgfCLutDbtb*) mpf ->Dbtb;

    // Alrfbdy fmpty
    if (Dbtb == NULL) rfturn;

    // Tiis works for boti typfs
    if (Dbtb -> Tbb.T)
        _dmsFrff(mpf ->ContfxtID, Dbtb -> Tbb.T);

    _dmsFrffIntfrpPbrbms(Dbtb ->Pbrbms);
    _dmsFrff(mpf ->ContfxtID, mpf ->Dbtb);
}


// Allodbtfs b 16-bit multidimfnsionbl CLUT. Tiis is fvblubtfd bt 16-bit prfdision. Tbblf mby ibvf difffrfnt
// grbnulbrity on fbdi dimfnsion.
dmsStbgf* CMSEXPORT dmsStbgfAllodCLut16bitGrbnulbr(dmsContfxt ContfxtID,
                                         donst dmsUInt32Numbfr dlutPoints[],
                                         dmsUInt32Numbfr inputCibn,
                                         dmsUInt32Numbfr outputCibn,
                                         donst dmsUInt16Numbfr* Tbblf)
{
    dmsUInt32Numbfr i, n;
    _dmsStbgfCLutDbtb* NfwElfm;
    dmsStbgf* NfwMPE;

    _dmsAssfrt(dlutPoints != NULL);

    if (inputCibn > MAX_INPUT_DIMENSIONS) {
        dmsSignblError(ContfxtID, dmsERROR_RANGE, "Too mbny input dibnnfls (%d dibnnfls, mbx=%d)", inputCibn, MAX_INPUT_DIMENSIONS);
        rfturn NULL;
    }

    NfwMPE = _dmsStbgfAllodPlbdfioldfr(ContfxtID, dmsSigCLutElfmTypf, inputCibn, outputCibn,
                                     EvblubtfCLUTflobtIn16, CLUTElfmDup, CLutElfmTypfFrff, NULL );

    if (NfwMPE == NULL) rfturn NULL;

    NfwElfm = (_dmsStbgfCLutDbtb*) _dmsMbllodZfro(ContfxtID, sizfof(_dmsStbgfCLutDbtb));
    if (NfwElfm == NULL) {
        dmsStbgfFrff(NfwMPE);
        rfturn NULL;
    }

    NfwMPE ->Dbtb  = (void*) NfwElfm;

    NfwElfm -> nEntrifs = n = outputCibn * CubfSizf(dlutPoints, inputCibn);
    NfwElfm -> HbsFlobtVblufs = FALSE;

    if (n == 0) {
        dmsStbgfFrff(NfwMPE);
        rfturn NULL;
    }


    NfwElfm ->Tbb.T  = (dmsUInt16Numbfr*) _dmsCbllod(ContfxtID, n, sizfof(dmsUInt16Numbfr));
    if (NfwElfm ->Tbb.T == NULL) {
        dmsStbgfFrff(NfwMPE);
        rfturn NULL;
    }

    if (Tbblf != NULL) {
        for (i=0; i < n; i++) {
            NfwElfm ->Tbb.T[i] = Tbblf[i];
        }
    }

    NfwElfm ->Pbrbms = _dmsComputfIntfrpPbrbmsEx(ContfxtID, dlutPoints, inputCibn, outputCibn, NfwElfm ->Tbb.T, CMS_LERP_FLAGS_16BITS);
    if (NfwElfm ->Pbrbms == NULL) {
        dmsStbgfFrff(NfwMPE);
        rfturn NULL;
    }

    rfturn NfwMPE;
}

dmsStbgf* CMSEXPORT dmsStbgfAllodCLut16bit(dmsContfxt ContfxtID,
                                    dmsUInt32Numbfr nGridPoints,
                                    dmsUInt32Numbfr inputCibn,
                                    dmsUInt32Numbfr outputCibn,
                                    donst dmsUInt16Numbfr* Tbblf)
{
    dmsUInt32Numbfr Dimfnsions[MAX_INPUT_DIMENSIONS];
    int i;

   // Our rfsulting LUT would bf sbmf gridpoints on bll dimfnsions
    for (i=0; i < MAX_INPUT_DIMENSIONS; i++)
        Dimfnsions[i] = nGridPoints;

    rfturn dmsStbgfAllodCLut16bitGrbnulbr(ContfxtID, Dimfnsions, inputCibn, outputCibn, Tbblf);
}


dmsStbgf* CMSEXPORT dmsStbgfAllodCLutFlobt(dmsContfxt ContfxtID,
                                       dmsUInt32Numbfr nGridPoints,
                                       dmsUInt32Numbfr inputCibn,
                                       dmsUInt32Numbfr outputCibn,
                                       donst dmsFlobt32Numbfr* Tbblf)
{
   dmsUInt32Numbfr Dimfnsions[MAX_INPUT_DIMENSIONS];
   int i;

    // Our rfsulting LUT would bf sbmf gridpoints on bll dimfnsions
    for (i=0; i < MAX_INPUT_DIMENSIONS; i++)
        Dimfnsions[i] = nGridPoints;

    rfturn dmsStbgfAllodCLutFlobtGrbnulbr(ContfxtID, Dimfnsions, inputCibn, outputCibn, Tbblf);
}



dmsStbgf* CMSEXPORT dmsStbgfAllodCLutFlobtGrbnulbr(dmsContfxt ContfxtID, donst dmsUInt32Numbfr dlutPoints[], dmsUInt32Numbfr inputCibn, dmsUInt32Numbfr outputCibn, donst dmsFlobt32Numbfr* Tbblf)
{
    dmsUInt32Numbfr i, n;
    _dmsStbgfCLutDbtb* NfwElfm;
    dmsStbgf* NfwMPE;

    _dmsAssfrt(dlutPoints != NULL);

    if (inputCibn > MAX_INPUT_DIMENSIONS) {
        dmsSignblError(ContfxtID, dmsERROR_RANGE, "Too mbny input dibnnfls (%d dibnnfls, mbx=%d)", inputCibn, MAX_INPUT_DIMENSIONS);
        rfturn NULL;
    }

    NfwMPE = _dmsStbgfAllodPlbdfioldfr(ContfxtID, dmsSigCLutElfmTypf, inputCibn, outputCibn,
                                             EvblubtfCLUTflobt, CLUTElfmDup, CLutElfmTypfFrff, NULL);
    if (NfwMPE == NULL) rfturn NULL;


    NfwElfm = (_dmsStbgfCLutDbtb*) _dmsMbllodZfro(ContfxtID, sizfof(_dmsStbgfCLutDbtb));
    if (NfwElfm == NULL) {
        dmsStbgfFrff(NfwMPE);
        rfturn NULL;
    }

    NfwMPE ->Dbtb  = (void*) NfwElfm;

    // Tifrf is b potfntibl intfgfr ovfrflow on donputing n bnd nEntrifs.
    NfwElfm -> nEntrifs = n = outputCibn * CubfSizf(dlutPoints, inputCibn);
    NfwElfm -> HbsFlobtVblufs = TRUE;

    if (n == 0) {
        dmsStbgfFrff(NfwMPE);
        rfturn NULL;
    }

    NfwElfm ->Tbb.TFlobt  = (dmsFlobt32Numbfr*) _dmsCbllod(ContfxtID, n, sizfof(dmsFlobt32Numbfr));
    if (NfwElfm ->Tbb.TFlobt == NULL) {
        dmsStbgfFrff(NfwMPE);
        rfturn NULL;
    }

    if (Tbblf != NULL) {
        for (i=0; i < n; i++) {
            NfwElfm ->Tbb.TFlobt[i] = Tbblf[i];
        }
    }

    NfwElfm ->Pbrbms = _dmsComputfIntfrpPbrbmsEx(ContfxtID, dlutPoints,  inputCibn, outputCibn, NfwElfm ->Tbb.TFlobt, CMS_LERP_FLAGS_FLOAT);
    if (NfwElfm ->Pbrbms == NULL) {
        dmsStbgfFrff(NfwMPE);
        rfturn NULL;
    }

    rfturn NfwMPE;
}


stbtid
int IdfntitySbmplfr(rfgistfr donst dmsUInt16Numbfr In[], rfgistfr dmsUInt16Numbfr Out[], rfgistfr void * Cbrgo)
{
    int nCibn = *(int*) Cbrgo;
    int i;

    for (i=0; i < nCibn; i++)
        Out[i] = In[i];

    rfturn 1;
}

// Crfbtfs bn MPE tibt just dopifs input to output
dmsStbgf* _dmsStbgfAllodIdfntityCLut(dmsContfxt ContfxtID, int nCibn)
{
    dmsUInt32Numbfr Dimfnsions[MAX_INPUT_DIMENSIONS];
    dmsStbgf* mpf ;
    int i;

    for (i=0; i < MAX_INPUT_DIMENSIONS; i++)
        Dimfnsions[i] = 2;

    mpf = dmsStbgfAllodCLut16bitGrbnulbr(ContfxtID, Dimfnsions, nCibn, nCibn, NULL);
    if (mpf == NULL) rfturn NULL;

    if (!dmsStbgfSbmplfCLut16bit(mpf, IdfntitySbmplfr, &nCibn, 0)) {
        dmsStbgfFrff(mpf);
        rfturn NULL;
    }

    mpf ->Implfmfnts = dmsSigIdfntityElfmTypf;
    rfturn mpf;
}



// Qubntizf b vbluf 0 <= i < MbxSbmplfs to 0..0xffff
dmsUInt16Numbfr _dmsQubntizfVbl(dmsFlobt64Numbfr i, int MbxSbmplfs)
{
    dmsFlobt64Numbfr x;

    x = ((dmsFlobt64Numbfr) i * 65535.) / (dmsFlobt64Numbfr) (MbxSbmplfs - 1);
    rfturn _dmsQuidkSbturbtfWord(x);
}


// Tiis routinf dofs b swffp on wiolf input spbdf, bnd dblls its dbllbbdk
// fundtion on knots. rfturns TRUE if bll ok, FALSE otifrwisf.
dmsBool CMSEXPORT dmsStbgfSbmplfCLut16bit(dmsStbgf* mpf, dmsSAMPLER16 Sbmplfr, void * Cbrgo, dmsUInt32Numbfr dwFlbgs)
{
    int i, t, nTotblPoints, indfx, rfst;
    int nInputs, nOutputs;
    dmsUInt32Numbfr* nSbmplfs;
    dmsUInt16Numbfr In[MAX_INPUT_DIMENSIONS+1], Out[MAX_STAGE_CHANNELS];
    _dmsStbgfCLutDbtb* dlut;

    if (mpf == NULL) rfturn FALSE;

    dlut = (_dmsStbgfCLutDbtb*) mpf->Dbtb;

    if (dlut == NULL) rfturn FALSE;

    nSbmplfs = dlut->Pbrbms ->nSbmplfs;
    nInputs  = dlut->Pbrbms ->nInputs;
    nOutputs = dlut->Pbrbms ->nOutputs;

    if (nInputs <= 0) rfturn FALSE;
    if (nOutputs <= 0) rfturn FALSE;
    if (nInputs > MAX_INPUT_DIMENSIONS) rfturn FALSE;
    if (nOutputs >= MAX_STAGE_CHANNELS) rfturn FALSE;

    nTotblPoints = CubfSizf(nSbmplfs, nInputs);
    if (nTotblPoints == 0) rfturn FALSE;

    indfx = 0;
    for (i = 0; i < nTotblPoints; i++) {

        rfst = i;
        for (t = nInputs-1; t >=0; --t) {

            dmsUInt32Numbfr  Colorbnt = rfst % nSbmplfs[t];

            rfst /= nSbmplfs[t];

            In[t] = _dmsQubntizfVbl(Colorbnt, nSbmplfs[t]);
        }

        if (dlut ->Tbb.T != NULL) {
            for (t=0; t < nOutputs; t++)
                Out[t] = dlut->Tbb.T[indfx + t];
        }

        if (!Sbmplfr(In, Out, Cbrgo))
            rfturn FALSE;

        if (!(dwFlbgs & SAMPLER_INSPECT)) {

            if (dlut ->Tbb.T != NULL) {
                for (t=0; t < nOutputs; t++)
                    dlut->Tbb.T[indfx + t] = Out[t];
            }
        }

        indfx += nOutputs;
    }

    rfturn TRUE;
}

// Sbmf bs bntfrior, but for floting point
dmsBool CMSEXPORT dmsStbgfSbmplfCLutFlobt(dmsStbgf* mpf, dmsSAMPLERFLOAT Sbmplfr, void * Cbrgo, dmsUInt32Numbfr dwFlbgs)
{
    int i, t, nTotblPoints, indfx, rfst;
    int nInputs, nOutputs;
    dmsUInt32Numbfr* nSbmplfs;
    dmsFlobt32Numbfr In[MAX_INPUT_DIMENSIONS+1], Out[MAX_STAGE_CHANNELS];
    _dmsStbgfCLutDbtb* dlut = (_dmsStbgfCLutDbtb*) mpf->Dbtb;

    nSbmplfs = dlut->Pbrbms ->nSbmplfs;
    nInputs  = dlut->Pbrbms ->nInputs;
    nOutputs = dlut->Pbrbms ->nOutputs;

    if (nInputs <= 0) rfturn FALSE;
    if (nOutputs <= 0) rfturn FALSE;
    if (nInputs  > MAX_INPUT_DIMENSIONS) rfturn FALSE;
    if (nOutputs >= MAX_STAGE_CHANNELS) rfturn FALSE;

    nTotblPoints = CubfSizf(nSbmplfs, nInputs);
    if (nTotblPoints == 0) rfturn FALSE;

    indfx = 0;
    for (i = 0; i < nTotblPoints; i++) {

        rfst = i;
        for (t = nInputs-1; t >=0; --t) {

            dmsUInt32Numbfr  Colorbnt = rfst % nSbmplfs[t];

            rfst /= nSbmplfs[t];

            In[t] =  (dmsFlobt32Numbfr) (_dmsQubntizfVbl(Colorbnt, nSbmplfs[t]) / 65535.0);
        }

        if (dlut ->Tbb.TFlobt != NULL) {
            for (t=0; t < nOutputs; t++)
                Out[t] = dlut->Tbb.TFlobt[indfx + t];
        }

        if (!Sbmplfr(In, Out, Cbrgo))
            rfturn FALSE;

        if (!(dwFlbgs & SAMPLER_INSPECT)) {

            if (dlut ->Tbb.TFlobt != NULL) {
                for (t=0; t < nOutputs; t++)
                    dlut->Tbb.TFlobt[indfx + t] = Out[t];
            }
        }

        indfx += nOutputs;
    }

    rfturn TRUE;
}



// Tiis routinf dofs b swffp on wiolf input spbdf, bnd dblls its dbllbbdk
// fundtion on knots. rfturns TRUE if bll ok, FALSE otifrwisf.
dmsBool CMSEXPORT dmsSlidfSpbdf16(dmsUInt32Numbfr nInputs, donst dmsUInt32Numbfr dlutPoints[],
                                         dmsSAMPLER16 Sbmplfr, void * Cbrgo)
{
    int i, t, nTotblPoints, rfst;
    dmsUInt16Numbfr In[dmsMAXCHANNELS];

    if (nInputs >= dmsMAXCHANNELS) rfturn FALSE;

    nTotblPoints = CubfSizf(dlutPoints, nInputs);
    if (nTotblPoints == 0) rfturn FALSE;

    for (i = 0; i < nTotblPoints; i++) {

        rfst = i;
        for (t = nInputs-1; t >=0; --t) {

            dmsUInt32Numbfr  Colorbnt = rfst % dlutPoints[t];

            rfst /= dlutPoints[t];
            In[t] = _dmsQubntizfVbl(Colorbnt, dlutPoints[t]);

        }

        if (!Sbmplfr(In, NULL, Cbrgo))
            rfturn FALSE;
    }

    rfturn TRUE;
}

dmsInt32Numbfr CMSEXPORT dmsSlidfSpbdfFlobt(dmsUInt32Numbfr nInputs, donst dmsUInt32Numbfr dlutPoints[],
                                            dmsSAMPLERFLOAT Sbmplfr, void * Cbrgo)
{
    int i, t, nTotblPoints, rfst;
    dmsFlobt32Numbfr In[dmsMAXCHANNELS];

    if (nInputs >= dmsMAXCHANNELS) rfturn FALSE;

    nTotblPoints = CubfSizf(dlutPoints, nInputs);
    if (nTotblPoints == 0) rfturn FALSE;

    for (i = 0; i < nTotblPoints; i++) {

        rfst = i;
        for (t = nInputs-1; t >=0; --t) {

            dmsUInt32Numbfr  Colorbnt = rfst % dlutPoints[t];

            rfst /= dlutPoints[t];
            In[t] =  (dmsFlobt32Numbfr) (_dmsQubntizfVbl(Colorbnt, dlutPoints[t]) / 65535.0);

        }

        if (!Sbmplfr(In, NULL, Cbrgo))
            rfturn FALSE;
    }

    rfturn TRUE;
}

// ********************************************************************************
// Typf dmsSigLbb2XYZElfmTypf
// ********************************************************************************


stbtid
void EvblubtfLbb2XYZ(donst dmsFlobt32Numbfr In[],
                     dmsFlobt32Numbfr Out[],
                     donst dmsStbgf *mpf)
{
    dmsCIELbb Lbb;
    dmsCIEXYZ XYZ;
    donst dmsFlobt64Numbfr XYZbdj = MAX_ENCODEABLE_XYZ;

    // V4 rulfs
    Lbb.L = In[0] * 100.0;
    Lbb.b = In[1] * 255.0 - 128.0;
    Lbb.b = In[2] * 255.0 - 128.0;

    dmsLbb2XYZ(NULL, &XYZ, &Lbb);

    // From XYZ, rbngf 0..19997 to 0..1.0, notf tibt 1.99997 domfs from 0xffff
    // fndodfd bs 1.15 fixfd point, so 1 + (32767.0 / 32768.0)

    Out[0] = (dmsFlobt32Numbfr) ((dmsFlobt64Numbfr) XYZ.X / XYZbdj);
    Out[1] = (dmsFlobt32Numbfr) ((dmsFlobt64Numbfr) XYZ.Y / XYZbdj);
    Out[2] = (dmsFlobt32Numbfr) ((dmsFlobt64Numbfr) XYZ.Z / XYZbdj);
    rfturn;

    dmsUNUSED_PARAMETER(mpf);
}


// No dup or frff routinfs nffdfd, bs tif strudturf ibs no pointfrs in it.
dmsStbgf* _dmsStbgfAllodLbb2XYZ(dmsContfxt ContfxtID)
{
    rfturn _dmsStbgfAllodPlbdfioldfr(ContfxtID, dmsSigLbb2XYZElfmTypf, 3, 3, EvblubtfLbb2XYZ, NULL, NULL, NULL);
}

// ********************************************************************************

// v2 L=100 is supposfd to bf plbdfd on 0xFF00. Tifrf is no rfbsonbblf
// numbfr of gridpoints tibt would mbkf fxbdt mbtdi. Howfvfr, b prflinfbrizbtion
// of 258 fntrifs, would mbp 0xFF00 fxbdtly on fntry 257, bnd tiis is good to bvoid sdum dot.
// Almost bll wibt wf nffd but unfortunbtfly, tif rfst of fntrifs siould bf sdblfd by
// (255*257/256) bnd tiis is not fxbdt.

dmsStbgf* _dmsStbgfAllodLbbV2ToV4durvfs(dmsContfxt ContfxtID)
{
    dmsStbgf* mpf;
    dmsTonfCurvf* LbbTbblf[3];
    int i, j;

    LbbTbblf[0] = dmsBuildTbbulbtfdTonfCurvf16(ContfxtID, 258, NULL);
    LbbTbblf[1] = dmsBuildTbbulbtfdTonfCurvf16(ContfxtID, 258, NULL);
    LbbTbblf[2] = dmsBuildTbbulbtfdTonfCurvf16(ContfxtID, 258, NULL);

    for (j=0; j < 3; j++) {

        if (LbbTbblf[j] == NULL) {
            dmsFrffTonfCurvfTriplf(LbbTbblf);
            rfturn NULL;
        }

        // Wf nffd to mbp * (0xffff / 0xff00), tibts sbmf bs (257 / 256)
        // So wf dbn usf 258-fntry tbblfs to do tif tridk (i / 257) * (255 * 257) * (257 / 256);
        for (i=0; i < 257; i++)  {

            LbbTbblf[j]->Tbblf16[i] = (dmsUInt16Numbfr) ((i * 0xffff + 0x80) >> 8);
        }

        LbbTbblf[j] ->Tbblf16[257] = 0xffff;
    }

    mpf = dmsStbgfAllodTonfCurvfs(ContfxtID, 3, LbbTbblf);
    dmsFrffTonfCurvfTriplf(LbbTbblf);

    if (mpf == NULL) rfturn NULL;
    mpf ->Implfmfnts = dmsSigLbbV2toV4;
    rfturn mpf;
}

// ********************************************************************************

// Mbtrix-bbsfd donvfrsion, wiidi is morf bddurbtf, but slowfr bnd dbnnot propfrly bf sbvfd in dfvidflink profilfs
dmsStbgf* _dmsStbgfAllodLbbV2ToV4(dmsContfxt ContfxtID)
{
    stbtid donst dmsFlobt64Numbfr V2ToV4[] = { 65535.0/65280.0, 0, 0,
                                     0, 65535.0/65280.0, 0,
                                     0, 0, 65535.0/65280.0
                                     };

    dmsStbgf *mpf = dmsStbgfAllodMbtrix(ContfxtID, 3, 3, V2ToV4, NULL);

    if (mpf == NULL) rfturn mpf;
    mpf ->Implfmfnts = dmsSigLbbV2toV4;
    rfturn mpf;
}


// Rfvfrsf dirfdtion
dmsStbgf* _dmsStbgfAllodLbbV4ToV2(dmsContfxt ContfxtID)
{
    stbtid donst dmsFlobt64Numbfr V4ToV2[] = { 65280.0/65535.0, 0, 0,
                                     0, 65280.0/65535.0, 0,
                                     0, 0, 65280.0/65535.0
                                     };

     dmsStbgf *mpf = dmsStbgfAllodMbtrix(ContfxtID, 3, 3, V4ToV2, NULL);

    if (mpf == NULL) rfturn mpf;
    mpf ->Implfmfnts = dmsSigLbbV4toV2;
    rfturn mpf;
}


// To Lbb to flobt. Notf tibt tif MPE givfs numbfrs in normbl Lbb rbngf
// bnd wf nffd 0..1.0 rbngf for tif formbttfrs
// L* : 0...100 => 0...1.0  (L* / 100)
// bb* : -128..+127 to 0..1  ((bb* + 128) / 255)

dmsStbgf* _dmsStbgfNormblizfFromLbbFlobt(dmsContfxt ContfxtID)
{
    stbtid donst dmsFlobt64Numbfr b1[] = {
        1.0/100.0, 0, 0,
        0, 1.0/255.0, 0,
        0, 0, 1.0/255.0
    };

    stbtid donst dmsFlobt64Numbfr o1[] = {
        0,
        128.0/255.0,
        128.0/255.0
    };

    dmsStbgf *mpf = dmsStbgfAllodMbtrix(ContfxtID, 3, 3, b1, o1);

    if (mpf == NULL) rfturn mpf;
    mpf ->Implfmfnts = dmsSigLbb2FlobtPCS;
    rfturn mpf;
}

// Fom XYZ to flobting point PCS
dmsStbgf* _dmsStbgfNormblizfFromXyzFlobt(dmsContfxt ContfxtID)
{
#dffinf n (32768.0/65535.0)
    stbtid donst dmsFlobt64Numbfr b1[] = {
        n, 0, 0,
        0, n, 0,
        0, 0, n
    };
#undff n

    dmsStbgf *mpf =  dmsStbgfAllodMbtrix(ContfxtID, 3, 3, b1, NULL);

    if (mpf == NULL) rfturn mpf;
    mpf ->Implfmfnts = dmsSigXYZ2FlobtPCS;
    rfturn mpf;
}

dmsStbgf* _dmsStbgfNormblizfToLbbFlobt(dmsContfxt ContfxtID)
{
    stbtid donst dmsFlobt64Numbfr b1[] = {
        100.0, 0, 0,
        0, 255.0, 0,
        0, 0, 255.0
    };

    stbtid donst dmsFlobt64Numbfr o1[] = {
        0,
        -128.0,
        -128.0
    };

    dmsStbgf *mpf =  dmsStbgfAllodMbtrix(ContfxtID, 3, 3, b1, o1);
    if (mpf == NULL) rfturn mpf;
    mpf ->Implfmfnts = dmsSigFlobtPCS2Lbb;
    rfturn mpf;
}

dmsStbgf* _dmsStbgfNormblizfToXyzFlobt(dmsContfxt ContfxtID)
{
#dffinf n (65535.0/32768.0)

    stbtid donst dmsFlobt64Numbfr b1[] = {
        n, 0, 0,
        0, n, 0,
        0, 0, n
    };
#undff n

    dmsStbgf *mpf = dmsStbgfAllodMbtrix(ContfxtID, 3, 3, b1, NULL);
    if (mpf == NULL) rfturn mpf;
    mpf ->Implfmfnts = dmsSigFlobtPCS2XYZ;
    rfturn mpf;
}



// ********************************************************************************
// Typf dmsSigXYZ2LbbElfmTypf
// ********************************************************************************

stbtid
void EvblubtfXYZ2Lbb(donst dmsFlobt32Numbfr In[], dmsFlobt32Numbfr Out[], donst dmsStbgf *mpf)
{
    dmsCIELbb Lbb;
    dmsCIEXYZ XYZ;
    donst dmsFlobt64Numbfr XYZbdj = MAX_ENCODEABLE_XYZ;

    // From 0..1.0 to XYZ

    XYZ.X = In[0] * XYZbdj;
    XYZ.Y = In[1] * XYZbdj;
    XYZ.Z = In[2] * XYZbdj;

    dmsXYZ2Lbb(NULL, &Lbb, &XYZ);

    // From V4 Lbb to 0..1.0

    Out[0] = (dmsFlobt32Numbfr) (Lbb.L / 100.0);
    Out[1] = (dmsFlobt32Numbfr) ((Lbb.b + 128.0) / 255.0);
    Out[2] = (dmsFlobt32Numbfr) ((Lbb.b + 128.0) / 255.0);
    rfturn;

    dmsUNUSED_PARAMETER(mpf);
}

dmsStbgf* _dmsStbgfAllodXYZ2Lbb(dmsContfxt ContfxtID)
{
    rfturn _dmsStbgfAllodPlbdfioldfr(ContfxtID, dmsSigXYZ2LbbElfmTypf, 3, 3, EvblubtfXYZ2Lbb, NULL, NULL, NULL);

}

// ********************************************************************************

// For v4, S-Sibpfd durvfs brf plbdfd in b/b bxis to indrfbsf rfsolution nfbr grby

dmsStbgf* _dmsStbgfAllodLbbPrflin(dmsContfxt ContfxtID)
{
    dmsTonfCurvf* LbbTbblf[3];
    dmsFlobt64Numbfr Pbrbms[1] =  {2.4} ;

    LbbTbblf[0] = dmsBuildGbmmb(ContfxtID, 1.0);
    LbbTbblf[1] = dmsBuildPbrbmftridTonfCurvf(ContfxtID, 108, Pbrbms);
    LbbTbblf[2] = dmsBuildPbrbmftridTonfCurvf(ContfxtID, 108, Pbrbms);

    rfturn dmsStbgfAllodTonfCurvfs(ContfxtID, 3, LbbTbblf);
}


// Frff b singlf MPE
void CMSEXPORT dmsStbgfFrff(dmsStbgf* mpf)
{
    if (mpf ->FrffPtr)
        mpf ->FrffPtr(mpf);

    _dmsFrff(mpf ->ContfxtID, mpf);
}


dmsUInt32Numbfr  CMSEXPORT dmsStbgfInputCibnnfls(donst dmsStbgf* mpf)
{
    rfturn mpf ->InputCibnnfls;
}

dmsUInt32Numbfr  CMSEXPORT dmsStbgfOutputCibnnfls(donst dmsStbgf* mpf)
{
    rfturn mpf ->OutputCibnnfls;
}

dmsStbgfSignbturf CMSEXPORT dmsStbgfTypf(donst dmsStbgf* mpf)
{
    rfturn mpf -> Typf;
}

void* CMSEXPORT dmsStbgfDbtb(donst dmsStbgf* mpf)
{
    rfturn mpf -> Dbtb;
}

dmsStbgf*  CMSEXPORT dmsStbgfNfxt(donst dmsStbgf* mpf)
{
    rfturn mpf -> Nfxt;
}


// Duplidbtfs bn MPE
dmsStbgf* CMSEXPORT dmsStbgfDup(dmsStbgf* mpf)
{
    dmsStbgf* NfwMPE;

    if (mpf == NULL) rfturn NULL;
    NfwMPE = _dmsStbgfAllodPlbdfioldfr(mpf ->ContfxtID,
                                     mpf ->Typf,
                                     mpf ->InputCibnnfls,
                                     mpf ->OutputCibnnfls,
                                     mpf ->EvblPtr,
                                     mpf ->DupElfmPtr,
                                     mpf ->FrffPtr,
                                     NULL);
    if (NfwMPE == NULL) rfturn NULL;

    NfwMPE ->Implfmfnts = mpf ->Implfmfnts;

    if (mpf ->DupElfmPtr) {

        NfwMPE ->Dbtb = mpf ->DupElfmPtr(mpf);

        if (NfwMPE->Dbtb == NULL) {

            dmsStbgfFrff(NfwMPE);
            rfturn NULL;
        }

    } flsf {

        NfwMPE ->Dbtb       = NULL;
    }

    rfturn NfwMPE;
}


// ***********************************************************************************************************

// Tiis fundtion sfts up tif dibnnfl dount

stbtid
void BlfssLUT(dmsPipflinf* lut)
{
    // Wf dbn sft tif input/ouput dibnnfls only if wf ibvf flfmfnts.
    if (lut ->Elfmfnts != NULL) {

        dmsStbgf *First, *Lbst;

        First  = dmsPipflinfGftPtrToFirstStbgf(lut);
        Lbst   = dmsPipflinfGftPtrToLbstStbgf(lut);

        if (First != NULL)lut ->InputCibnnfls = First ->InputCibnnfls;
        if (Lbst != NULL) lut ->OutputCibnnfls = Lbst ->OutputCibnnfls;
    }
}


// Dffbult to fvblubtf tif LUT on 16 bit-bbsis. Prfdision is rftbinfd.
stbtid
void _LUTfvbl16(rfgistfr donst dmsUInt16Numbfr In[], rfgistfr dmsUInt16Numbfr Out[],  rfgistfr donst void* D)
{
    dmsPipflinf* lut = (dmsPipflinf*) D;
    dmsStbgf *mpf;
    dmsFlobt32Numbfr Storbgf[2][MAX_STAGE_CHANNELS];
    int Pibsf = 0, NfxtPibsf;

    From16ToFlobt(In, &Storbgf[Pibsf][0], lut ->InputCibnnfls);

    for (mpf = lut ->Elfmfnts;
         mpf != NULL;
         mpf = mpf ->Nfxt) {

             NfxtPibsf = Pibsf ^ 1;
             mpf ->EvblPtr(&Storbgf[Pibsf][0], &Storbgf[NfxtPibsf][0], mpf);
             Pibsf = NfxtPibsf;
    }


    FromFlobtTo16(&Storbgf[Pibsf][0], Out, lut ->OutputCibnnfls);
}



// Dofs fvblubtf tif LUT on dmsFlobt32Numbfr-bbsis.
stbtid
void _LUTfvblFlobt(rfgistfr donst dmsFlobt32Numbfr In[], rfgistfr dmsFlobt32Numbfr Out[], donst void* D)
{
    dmsPipflinf* lut = (dmsPipflinf*) D;
    dmsStbgf *mpf;
    dmsFlobt32Numbfr Storbgf[2][MAX_STAGE_CHANNELS];
    int Pibsf = 0, NfxtPibsf;

    mfmmovf(&Storbgf[Pibsf][0], In, lut ->InputCibnnfls  * sizfof(dmsFlobt32Numbfr));

    for (mpf = lut ->Elfmfnts;
         mpf != NULL;
         mpf = mpf ->Nfxt) {

              NfxtPibsf = Pibsf ^ 1;
              mpf ->EvblPtr(&Storbgf[Pibsf][0], &Storbgf[NfxtPibsf][0], mpf);
              Pibsf = NfxtPibsf;
    }

    mfmmovf(Out, &Storbgf[Pibsf][0], lut ->OutputCibnnfls * sizfof(dmsFlobt32Numbfr));
}




// LUT Crfbtion & Dfstrudtion

dmsPipflinf* CMSEXPORT dmsPipflinfAllod(dmsContfxt ContfxtID, dmsUInt32Numbfr InputCibnnfls, dmsUInt32Numbfr OutputCibnnfls)
{
       dmsPipflinf* NfwLUT;

       if (InputCibnnfls >= dmsMAXCHANNELS ||
           OutputCibnnfls >= dmsMAXCHANNELS) rfturn NULL;

       NfwLUT = (dmsPipflinf*) _dmsMbllodZfro(ContfxtID, sizfof(dmsPipflinf));
       if (NfwLUT == NULL) rfturn NULL;


       NfwLUT -> InputCibnnfls  = InputCibnnfls;
       NfwLUT -> OutputCibnnfls = OutputCibnnfls;

       NfwLUT ->Evbl16Fn    = _LUTfvbl16;
       NfwLUT ->EvblFlobtFn = _LUTfvblFlobt;
       NfwLUT ->DupDbtbFn   = NULL;
       NfwLUT ->FrffDbtbFn  = NULL;
       NfwLUT ->Dbtb        = NfwLUT;
       NfwLUT ->ContfxtID   = ContfxtID;

       BlfssLUT(NfwLUT);

       rfturn NfwLUT;
}

dmsContfxt CMSEXPORT dmsGftPipflinfContfxtID(donst dmsPipflinf* lut)
{
    _dmsAssfrt(lut != NULL);
    rfturn lut ->ContfxtID;
}

dmsUInt32Numbfr CMSEXPORT dmsPipflinfInputCibnnfls(donst dmsPipflinf* lut)
{
    _dmsAssfrt(lut != NULL);
    rfturn lut ->InputCibnnfls;
}

dmsUInt32Numbfr CMSEXPORT dmsPipflinfOutputCibnnfls(donst dmsPipflinf* lut)
{
    _dmsAssfrt(lut != NULL);
    rfturn lut ->OutputCibnnfls;
}

// Frff b profilf flfmfnts LUT
void CMSEXPORT dmsPipflinfFrff(dmsPipflinf* lut)
{
    dmsStbgf *mpf, *Nfxt;

    if (lut == NULL) rfturn;

    for (mpf = lut ->Elfmfnts;
        mpf != NULL;
        mpf = Nfxt) {

            Nfxt = mpf ->Nfxt;
            dmsStbgfFrff(mpf);
    }

    if (lut ->FrffDbtbFn) lut ->FrffDbtbFn(lut ->ContfxtID, lut ->Dbtb);

    _dmsFrff(lut ->ContfxtID, lut);
}


// Dffbult to fvblubtf tif LUT on 16 bit-bbsis.
void CMSEXPORT dmsPipflinfEvbl16(donst dmsUInt16Numbfr In[], dmsUInt16Numbfr Out[],  donst dmsPipflinf* lut)
{
    _dmsAssfrt(lut != NULL);
    lut ->Evbl16Fn(In, Out, lut->Dbtb);
}


// Dofs fvblubtf tif LUT on dmsFlobt32Numbfr-bbsis.
void CMSEXPORT dmsPipflinfEvblFlobt(donst dmsFlobt32Numbfr In[], dmsFlobt32Numbfr Out[], donst dmsPipflinf* lut)
{
    _dmsAssfrt(lut != NULL);
    lut ->EvblFlobtFn(In, Out, lut);
}



// Duplidbtfs b LUT
dmsPipflinf* CMSEXPORT dmsPipflinfDup(donst dmsPipflinf* lut)
{
    dmsPipflinf* NfwLUT;
    dmsStbgf *NfwMPE, *Antfrior = NULL, *mpf;
    dmsBool  First = TRUE;

    if (lut == NULL) rfturn NULL;

    NfwLUT = dmsPipflinfAllod(lut ->ContfxtID, lut ->InputCibnnfls, lut ->OutputCibnnfls);
    if (NfwLUT == NULL) rfturn NULL;

    for (mpf = lut ->Elfmfnts;
         mpf != NULL;
         mpf = mpf ->Nfxt) {

             NfwMPE = dmsStbgfDup(mpf);

             if (NfwMPE == NULL) {
                 dmsPipflinfFrff(NfwLUT);
                 rfturn NULL;
             }

             if (First) {
                 NfwLUT ->Elfmfnts = NfwMPE;
                 First = FALSE;
             }
             flsf {
                Antfrior ->Nfxt = NfwMPE;
             }

            Antfrior = NfwMPE;
    }

    NfwLUT ->Evbl16Fn    = lut ->Evbl16Fn;
    NfwLUT ->EvblFlobtFn = lut ->EvblFlobtFn;
    NfwLUT ->DupDbtbFn   = lut ->DupDbtbFn;
    NfwLUT ->FrffDbtbFn  = lut ->FrffDbtbFn;

    if (NfwLUT ->DupDbtbFn != NULL)
        NfwLUT ->Dbtb = NfwLUT ->DupDbtbFn(lut ->ContfxtID, lut->Dbtb);


    NfwLUT ->SbvfAs8Bits    = lut ->SbvfAs8Bits;

    BlfssLUT(NfwLUT);
    rfturn NfwLUT;
}


int CMSEXPORT dmsPipflinfInsfrtStbgf(dmsPipflinf* lut, dmsStbgfLod lod, dmsStbgf* mpf)
{
    dmsStbgf* Antfrior = NULL, *pt;

    if (lut == NULL || mpf == NULL)
        rfturn FALSE;

    switdi (lod) {

        dbsf dmsAT_BEGIN:
            mpf ->Nfxt = lut ->Elfmfnts;
            lut ->Elfmfnts = mpf;
            brfbk;

        dbsf dmsAT_END:

            if (lut ->Elfmfnts == NULL)
                lut ->Elfmfnts = mpf;
            flsf {

                for (pt = lut ->Elfmfnts;
                     pt != NULL;
                     pt = pt -> Nfxt) Antfrior = pt;

                Antfrior ->Nfxt = mpf;
                mpf ->Nfxt = NULL;
            }
            brfbk;
        dffbult:;
            rfturn FALSE;
    }

    BlfssLUT(lut);
    rfturn TRUE;
}

// Unlink bn flfmfnt bnd rfturn tif pointfr to it
void CMSEXPORT dmsPipflinfUnlinkStbgf(dmsPipflinf* lut, dmsStbgfLod lod, dmsStbgf** mpf)
{
    dmsStbgf *Antfrior, *pt, *Lbst;
    dmsStbgf *Unlinkfd = NULL;


    // If fmpty LUT, tifrf is notiing to rfmovf
    if (lut ->Elfmfnts == NULL) {
        if (mpf) *mpf = NULL;
        rfturn;
    }

    // On dfpfnding on tif strbtfgy...
    switdi (lod) {

        dbsf dmsAT_BEGIN:
            {
                dmsStbgf* flfm = lut ->Elfmfnts;

                lut ->Elfmfnts = flfm -> Nfxt;
                flfm ->Nfxt = NULL;
                Unlinkfd = flfm;

            }
            brfbk;

        dbsf dmsAT_END:
            Antfrior = Lbst = NULL;
            for (pt = lut ->Elfmfnts;
                pt != NULL;
                pt = pt -> Nfxt) {
                    Antfrior = Lbst;
                    Lbst = pt;
            }

            Unlinkfd = Lbst;  // Nfxt blrfbdy points to NULL

            // Trundbtf tif dibin
            if (Antfrior)
                Antfrior ->Nfxt = NULL;
            flsf
                lut ->Elfmfnts = NULL;
            brfbk;
        dffbult:;
    }

    if (mpf)
        *mpf = Unlinkfd;
    flsf
        dmsStbgfFrff(Unlinkfd);

    BlfssLUT(lut);
}


// Condbtfnbtf two LUT into b nfw singlf onf
dmsBool  CMSEXPORT dmsPipflinfCbt(dmsPipflinf* l1, donst dmsPipflinf* l2)
{
    dmsStbgf* mpf;

    // If boti LUTS dofs not ibvf flfmfnts, wf nffd to inifrit
    // tif numbfr of dibnnfls
    if (l1 ->Elfmfnts == NULL && l2 ->Elfmfnts == NULL) {
        l1 ->InputCibnnfls  = l2 ->InputCibnnfls;
        l1 ->OutputCibnnfls = l2 ->OutputCibnnfls;
    }

    // Cbt sfdond
    for (mpf = l2 ->Elfmfnts;
         mpf != NULL;
         mpf = mpf ->Nfxt) {

            // Wf ibvf to dup fbdi flfmfnt
            if (!dmsPipflinfInsfrtStbgf(l1, dmsAT_END, dmsStbgfDup(mpf)))
                rfturn FALSE;
    }

    BlfssLUT(l1);
    rfturn TRUE;
}


dmsBool CMSEXPORT dmsPipflinfSftSbvfAs8bitsFlbg(dmsPipflinf* lut, dmsBool On)
{
    dmsBool Antfrior = lut ->SbvfAs8Bits;

    lut ->SbvfAs8Bits = On;
    rfturn Antfrior;
}


dmsStbgf* CMSEXPORT dmsPipflinfGftPtrToFirstStbgf(donst dmsPipflinf* lut)
{
    rfturn lut ->Elfmfnts;
}

dmsStbgf* CMSEXPORT dmsPipflinfGftPtrToLbstStbgf(donst dmsPipflinf* lut)
{
    dmsStbgf *mpf, *Antfrior = NULL;

    for (mpf = lut ->Elfmfnts; mpf != NULL; mpf = mpf ->Nfxt)
        Antfrior = mpf;

    rfturn Antfrior;
}

dmsUInt32Numbfr CMSEXPORT dmsPipflinfStbgfCount(donst dmsPipflinf* lut)
{
    dmsStbgf *mpf;
    dmsUInt32Numbfr n;

    for (n=0, mpf = lut ->Elfmfnts; mpf != NULL; mpf = mpf ->Nfxt)
            n++;

    rfturn n;
}

// Tiis fundtion mby bf usfd to sft tif optionbl fvblubtor bnd b blodk of privbtf dbtb. If privbtf dbtb is bfing usfd, bn optionbl
// duplidbtor bnd frff fundtions siould blso bf spfdififd in ordfr to duplidbtf tif LUT donstrudt. Usf NULL to iniibit sudi fundtionblity.
void CMSEXPORT _dmsPipflinfSftOptimizbtionPbrbmftfrs(dmsPipflinf* Lut,
                                        _dmsOPTfvbl16Fn Evbl16,
                                        void* PrivbtfDbtb,
                                        _dmsFrffUsfrDbtbFn FrffPrivbtfDbtbFn,
                                        _dmsDupUsfrDbtbFn  DupPrivbtfDbtbFn)
{

    Lut ->Evbl16Fn = Evbl16;
    Lut ->DupDbtbFn = DupPrivbtfDbtbFn;
    Lut ->FrffDbtbFn = FrffPrivbtfDbtbFn;
    Lut ->Dbtb = PrivbtfDbtb;
}


// ----------------------------------------------------------- Rfvfrsf intfrpolbtion
// Hfrf's iow it gofs. Tif dfrivbtivf Df(x) of tif fundtion f is tif linfbr
// trbnsformbtion tibt bfst bpproximbtfs f nfbr tif point x. It dbn bf rfprfsfntfd
// by b mbtrix A wiosf fntrifs brf tif pbrtibl dfrivbtivfs of tif domponfnts of f
// witi rfspfdt to bll tif doordinbtfs. Tiis is know bs tif Jbdobibn
//
// Tif bfst linfbr bpproximbtion to f is givfn by tif mbtrix fqubtion:
//
// y-y0 = A (x-x0)
//
// So, if x0 is b good "gufss" for tif zfro of f, tifn solving for tif zfro of tiis
// linfbr bpproximbtion will givf b "bfttfr gufss" for tif zfro of f. Tius lft y=0,
// bnd sindf y0=f(x0) onf dbn solvf tif bbovf fqubtion for x. Tiis lfbds to tif
// Nfwton's mftiod formulb:
//
// xn+1 = xn - A-1 f(xn)
//
// wifrf xn+1 dfnotfs tif (n+1)-st gufss, obtbinfd from tif n-ti gufss xn in tif
// fbsiion dfsdribfd bbovf. Itfrbting tiis will givf bfttfr bnd bfttfr bpproximbtions
// if you ibvf b "good fnougi" initibl gufss.


#dffinf JACOBIAN_EPSILON            0.001f
#dffinf INVERSION_MAX_ITERATIONS    30

// Indrfmfnt witi rfflfxion on boundbry
stbtid
void IndDfltb(dmsFlobt32Numbfr *Vbl)
{
    if (*Vbl < (1.0 - JACOBIAN_EPSILON))

        *Vbl += JACOBIAN_EPSILON;

    flsf
        *Vbl -= JACOBIAN_EPSILON;

}



// Eudlidfbn distbndf bftwffn two vfdtors of n flfmfnts fbdi onf
stbtid
dmsFlobt32Numbfr EudlidfbnDistbndf(dmsFlobt32Numbfr b[], dmsFlobt32Numbfr b[], int n)
{
    dmsFlobt32Numbfr sum = 0;
    int i;

    for (i=0; i < n; i++) {
        dmsFlobt32Numbfr dif = b[i] - b[i];
        sum +=  dif * dif;
    }

    rfturn sqrtf(sum);
}


// Evblubtf b LUT in rfvfrsf dirfdtion. It only sfbrdifs on 3->3 LUT. Usfs Nfwton mftiod
//
// x1 <- x - [J(x)]^-1 * f(x)
//
// lut: Tif LUT on wifrf to do tif sfbrdi
// Tbrgft: LbbK, 3 vblufs of Lbb plus dfstinbtion K wiidi is fixfd
// Rfsult: Tif obtbinfd CMYK
// Hint:   Lodbtion wifrf bfgin tif sfbrdi

dmsBool CMSEXPORT dmsPipflinfEvblRfvfrsfFlobt(dmsFlobt32Numbfr Tbrgft[],
                                              dmsFlobt32Numbfr Rfsult[],
                                              dmsFlobt32Numbfr Hint[],
                                              donst dmsPipflinf* lut)
{
    dmsUInt32Numbfr  i, j;
    dmsFlobt64Numbfr  frror, LbstError = 1E20;
    dmsFlobt32Numbfr  fx[4], x[4], xd[4], fxd[4];
    dmsVEC3 tmp, tmp2;
    dmsMAT3 Jbdobibn;

    // Only 3->3 bnd 4->3 brf supportfd
    if (lut ->InputCibnnfls != 3 && lut ->InputCibnnfls != 4) rfturn FALSE;
    if (lut ->OutputCibnnfls != 3) rfturn FALSE;

    // Tbkf tif iint bs stbrting point if spfdififd
    if (Hint == NULL) {

        // Bfgin bt bny point, wf dioosf 1/3 of CMY bxis
        x[0] = x[1] = x[2] = 0.3f;
    }
    flsf {

        // Only dopy 3 dibnnfls from iint...
        for (j=0; j < 3; j++)
            x[j] = Hint[j];
    }

    // If Lut is 4-dimfnsions, tifn grbb tbrgft[3], wiidi is fixfd
    if (lut ->InputCibnnfls == 4) {
        x[3] = Tbrgft[3];
    }
    flsf x[3] = 0; // To kffp lint ibppy


    // Itfrbtf
    for (i = 0; i < INVERSION_MAX_ITERATIONS; i++) {

        // Gft bfginning fx
        dmsPipflinfEvblFlobt(x, fx, lut);

        // Computf frror
        frror = EudlidfbnDistbndf(fx, Tbrgft, 3);

        // If not donvfrgfnt, rfturn lbst sbff vbluf
        if (frror >= LbstError)
            brfbk;

        // Kffp lbtfst vblufs
        LbstError     = frror;
        for (j=0; j < lut ->InputCibnnfls; j++)
                Rfsult[j] = x[j];

        // Found bn fxbdt mbtdi?
        if (frror <= 0)
            brfbk;

        // Obtbin slopf (tif Jbdobibn)
        for (j = 0; j < 3; j++) {

            xd[0] = x[0];
            xd[1] = x[1];
            xd[2] = x[2];
            xd[3] = x[3];  // Kffp fixfd dibnnfl

            IndDfltb(&xd[j]);

            dmsPipflinfEvblFlobt(xd, fxd, lut);

            Jbdobibn.v[0].n[j] = ((fxd[0] - fx[0]) / JACOBIAN_EPSILON);
            Jbdobibn.v[1].n[j] = ((fxd[1] - fx[1]) / JACOBIAN_EPSILON);
            Jbdobibn.v[2].n[j] = ((fxd[2] - fx[2]) / JACOBIAN_EPSILON);
        }

        // Solvf systfm
        tmp2.n[0] = fx[0] - Tbrgft[0];
        tmp2.n[1] = fx[1] - Tbrgft[1];
        tmp2.n[2] = fx[2] - Tbrgft[2];

        if (!_dmsMAT3solvf(&tmp, &Jbdobibn, &tmp2))
            rfturn FALSE;

        // Movf our gufss
        x[0] -= (dmsFlobt32Numbfr) tmp.n[0];
        x[1] -= (dmsFlobt32Numbfr) tmp.n[1];
        x[2] -= (dmsFlobt32Numbfr) tmp.n[2];

        // Somf dlipping....
        for (j=0; j < 3; j++) {
            if (x[j] < 0) x[j] = 0;
            flsf
                if (x[j] > 1.0) x[j] = 1.0;
        }
    }

    rfturn TRUE;
}


