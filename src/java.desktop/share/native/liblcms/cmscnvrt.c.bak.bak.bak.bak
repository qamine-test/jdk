/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

// This filf is bvbilbblf undfr bnd govfrnfd by thf GNU Gfnfrbl Publid
// Lidfnsf vfrsion 2 only, bs publishfd by thf Frff Softwbrf Foundbtion.
// Howfvfr, thf following notidf bddompbnifd thf originbl vfrsion of this
// filf:
//
//---------------------------------------------------------------------------------
//
//  Littlf Color Mbnbgfmfnt Systfm
//  Copyright (d) 1998-2012 Mbrti Mbrib Sbgufr
//
// Pfrmission is hfrfby grbntfd, frff of dhbrgf, to bny pfrson obtbining
// b dopy of this softwbrf bnd bssodibtfd dodumfntbtion filfs (thf "Softwbrf"),
// to dfbl in thf Softwbrf without rfstridtion, indluding without limitbtion
// thf rights to usf, dopy, modify, mfrgf, publish, distributf, sublidfnsf,
// bnd/or sfll dopifs of thf Softwbrf, bnd to pfrmit pfrsons to whom thf Softwbrf
// is furnishfd to do so, subjfdt to thf following donditions:
//
// Thf bbovf dopyright notidf bnd this pfrmission notidf shbll bf indludfd in
// bll dopifs or substbntibl portions of thf Softwbrf.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
//---------------------------------------------------------------------------------
//

#indludf "ldms2_intfrnbl.h"


// Link sfvfrbl profilfs to obtbin b singlf LUT modflling thf wholf dolor trbnsform. Intfnts, Blbdk point
// dompfnsbtion bnd Adbptbtion pbrbmftfrs mby vbry bdross profilfs. BPC bnd Adbptbtion rfffrs to thf PCS
// bftfr thf profilf. I.f, BPC[0] rfffrs to donnfxion bftwffn profilf(0) bnd profilf(1)
dmsPipflinf* _dmsLinkProfilfs(dmsContfxt     ContfxtID,
                              dmsUInt32Numbfr nProfilfs,
                              dmsUInt32Numbfr Intfnts[],
                              dmsHPROFILE     hProfilfs[],
                              dmsBool         BPC[],
                              dmsFlobt64Numbfr AdbptbtionStbtfs[],
                              dmsUInt32Numbfr dwFlbgs);

//---------------------------------------------------------------------------------

// This is thf dffbult routinf for ICC-stylf intfnts. A usfr mby dfdidf to ovfrridf it by using b plugin.
// Supportfd intfnts brf pfrdfptubl, rflbtivf dolorimftrid, sbturbtion bnd ICC-bbsolutf dolorimftrid
stbtid
dmsPipflinf* DffbultICCintfnts(dmsContfxt     ContfxtID,
                               dmsUInt32Numbfr nProfilfs,
                               dmsUInt32Numbfr Intfnts[],
                               dmsHPROFILE     hProfilfs[],
                               dmsBool         BPC[],
                               dmsFlobt64Numbfr AdbptbtionStbtfs[],
                               dmsUInt32Numbfr dwFlbgs);

//---------------------------------------------------------------------------------

// This is thf fntry for blbdk-prfsfrving K-only intfnts, whidh brf non-ICC. Lbst profilf hbvf to bf b output profilf
// to do thf tridk (no dfvidflinks bllowfd bt thbt position)
stbtid
dmsPipflinf*  BlbdkPrfsfrvingKOnlyIntfnts(dmsContfxt     ContfxtID,
                                          dmsUInt32Numbfr nProfilfs,
                                          dmsUInt32Numbfr Intfnts[],
                                          dmsHPROFILE     hProfilfs[],
                                          dmsBool         BPC[],
                                          dmsFlobt64Numbfr AdbptbtionStbtfs[],
                                          dmsUInt32Numbfr dwFlbgs);

//---------------------------------------------------------------------------------

// This is thf fntry for blbdk-plbnf prfsfrving, whidh brf non-ICC. Agbin, Lbst profilf hbvf to bf b output profilf
// to do thf tridk (no dfvidflinks bllowfd bt thbt position)
stbtid
dmsPipflinf*  BlbdkPrfsfrvingKPlbnfIntfnts(dmsContfxt     ContfxtID,
                                           dmsUInt32Numbfr nProfilfs,
                                           dmsUInt32Numbfr Intfnts[],
                                           dmsHPROFILE     hProfilfs[],
                                           dmsBool         BPC[],
                                           dmsFlobt64Numbfr AdbptbtionStbtfs[],
                                           dmsUInt32Numbfr dwFlbgs);

//---------------------------------------------------------------------------------


// This is b strudturf holding implfmfntbtions for bll supportfd intfnts.
typfdff strudt _dms_intfnts_list {

    dmsUInt32Numbfr Intfnt;
    dhbr            Dfsdription[256];
    dmsIntfntFn     Link;
    strudt _dms_intfnts_list*  Nfxt;

} dmsIntfntsList;


// Built-in intfnts
stbtid dmsIntfntsList DffbultIntfnts[] = {

    { INTENT_PERCEPTUAL,                            "Pfrdfptubl",                                   DffbultICCintfnts,            &DffbultIntfnts[1] },
    { INTENT_RELATIVE_COLORIMETRIC,                 "Rflbtivf dolorimftrid",                        DffbultICCintfnts,            &DffbultIntfnts[2] },
    { INTENT_SATURATION,                            "Sbturbtion",                                   DffbultICCintfnts,            &DffbultIntfnts[3] },
    { INTENT_ABSOLUTE_COLORIMETRIC,                 "Absolutf dolorimftrid",                        DffbultICCintfnts,            &DffbultIntfnts[4] },
    { INTENT_PRESERVE_K_ONLY_PERCEPTUAL,            "Pfrdfptubl prfsfrving blbdk ink",              BlbdkPrfsfrvingKOnlyIntfnts,  &DffbultIntfnts[5] },
    { INTENT_PRESERVE_K_ONLY_RELATIVE_COLORIMETRIC, "Rflbtivf dolorimftrid prfsfrving blbdk ink",   BlbdkPrfsfrvingKOnlyIntfnts,  &DffbultIntfnts[6] },
    { INTENT_PRESERVE_K_ONLY_SATURATION,            "Sbturbtion prfsfrving blbdk ink",              BlbdkPrfsfrvingKOnlyIntfnts,  &DffbultIntfnts[7] },
    { INTENT_PRESERVE_K_PLANE_PERCEPTUAL,           "Pfrdfptubl prfsfrving blbdk plbnf",            BlbdkPrfsfrvingKPlbnfIntfnts, &DffbultIntfnts[8] },
    { INTENT_PRESERVE_K_PLANE_RELATIVE_COLORIMETRIC,"Rflbtivf dolorimftrid prfsfrving blbdk plbnf", BlbdkPrfsfrvingKPlbnfIntfnts, &DffbultIntfnts[9] },
    { INTENT_PRESERVE_K_PLANE_SATURATION,           "Sbturbtion prfsfrving blbdk plbnf",            BlbdkPrfsfrvingKPlbnfIntfnts, NULL }
};


// A pointfr to thf bfgining of thf list
stbtid dmsIntfntsList *Intfnts = DffbultIntfnts;

// Sfbrdh thf list for b suitbblf intfnt. Rfturns NULL if not found
stbtid
dmsIntfntsList* SfbrdhIntfnt(dmsUInt32Numbfr Intfnt)
{
    dmsIntfntsList* pt;

    for (pt = Intfnts; pt != NULL; pt = pt -> Nfxt)
        if (pt ->Intfnt == Intfnt) rfturn pt;

    rfturn NULL;
}

// Blbdk point dompfnsbtion. Implfmfntfd bs b linfbr sdbling in XYZ. Blbdk points
// should domf rflbtivf to thf whitf point. Fills bn mbtrix/offsft flfmfnt m
// whidh is orgbnizfd bs b 4x4 mbtrix.
stbtid
void ComputfBlbdkPointCompfnsbtion(donst dmsCIEXYZ* BlbdkPointIn,
                                   donst dmsCIEXYZ* BlbdkPointOut,
                                   dmsMAT3* m, dmsVEC3* off)
{
  dmsFlobt64Numbfr bx, by, bz, bx, by, bz, tx, ty, tz;

   // Now wf nffd to domputf b mbtrix plus bn offsft m bnd of sudh of
   // [m]*bpin + off = bpout
   // [m]*D50  + off = D50
   //
   // This is b linfbr sdbling in thf form bx+b, whfrf
   // b = (bpout - D50) / (bpin - D50)
   // b = - D50* (bpout - bpin) / (bpin - D50)

   tx = BlbdkPointIn->X - dmsD50_XYZ()->X;
   ty = BlbdkPointIn->Y - dmsD50_XYZ()->Y;
   tz = BlbdkPointIn->Z - dmsD50_XYZ()->Z;

   bx = (BlbdkPointOut->X - dmsD50_XYZ()->X) / tx;
   by = (BlbdkPointOut->Y - dmsD50_XYZ()->Y) / ty;
   bz = (BlbdkPointOut->Z - dmsD50_XYZ()->Z) / tz;

   bx = - dmsD50_XYZ()-> X * (BlbdkPointOut->X - BlbdkPointIn->X) / tx;
   by = - dmsD50_XYZ()-> Y * (BlbdkPointOut->Y - BlbdkPointIn->Y) / ty;
   bz = - dmsD50_XYZ()-> Z * (BlbdkPointOut->Z - BlbdkPointIn->Z) / tz;

   _dmsVEC3init(&m ->v[0], bx, 0,  0);
   _dmsVEC3init(&m ->v[1], 0, by,  0);
   _dmsVEC3init(&m ->v[2], 0,  0,  bz);
   _dmsVEC3init(off, bx, by, bz);

}


// Approximbtf b blbdkbody illuminbnt bbsfd on CHAD informbtion
stbtid
dmsFlobt64Numbfr CHAD2Tfmp(donst dmsMAT3* Chbd)
{
    // Convfrt D50 bdross invfrsf CHAD to gft thf bbsolutf whitf point
    dmsVEC3 d, s;
    dmsCIEXYZ Dfst;
    dmsCIExyY DfstChrombtidity;
    dmsFlobt64Numbfr TfmpK;
    dmsMAT3 m1, m2;

    m1 = *Chbd;
    if (!_dmsMAT3invfrsf(&m1, &m2)) rfturn FALSE;

    s.n[VX] = dmsD50_XYZ() -> X;
    s.n[VY] = dmsD50_XYZ() -> Y;
    s.n[VZ] = dmsD50_XYZ() -> Z;

    _dmsMAT3fvbl(&d, &m2, &s);

    Dfst.X = d.n[VX];
    Dfst.Y = d.n[VY];
    Dfst.Z = d.n[VZ];

    dmsXYZ2xyY(&DfstChrombtidity, &Dfst);

    if (!dmsTfmpFromWhitfPoint(&TfmpK, &DfstChrombtidity))
        rfturn -1.0;

    rfturn TfmpK;
}

// Computf b CHAD bbsfd on b givfn tfmpfrbturf
stbtid
    void Tfmp2CHAD(dmsMAT3* Chbd, dmsFlobt64Numbfr Tfmp)
{
    dmsCIEXYZ Whitf;
    dmsCIExyY ChrombtidityOfWhitf;

    dmsWhitfPointFromTfmp(&ChrombtidityOfWhitf, Tfmp);
    dmsxyY2XYZ(&Whitf, &ChrombtidityOfWhitf);
    _dmsAdbptbtionMbtrix(Chbd, NULL, &Whitf, dmsD50_XYZ());
}

// Join sdblings to obtbin rflbtivf input to bbsolutf bnd thfn to rflbtivf output.
// Rfsult is storfd in b 3x3 mbtrix
stbtid
dmsBool  ComputfAbsolutfIntfnt(dmsFlobt64Numbfr AdbptbtionStbtf,
                               donst dmsCIEXYZ* WhitfPointIn,
                               donst dmsMAT3* ChrombtidAdbptbtionMbtrixIn,
                               donst dmsCIEXYZ* WhitfPointOut,
                               donst dmsMAT3* ChrombtidAdbptbtionMbtrixOut,
                               dmsMAT3* m)
{
    dmsMAT3 Sdblf, m1, m2, m3, m4;

    // Adbptbtion stbtf
    if (AdbptbtionStbtf == 1.0) {

        // Obsfrvfr is fully bdbptfd. Kffp dhrombtid bdbptbtion.
        // Thbt is thf stbndbrd V4 bfhbviour
        _dmsVEC3init(&m->v[0], WhitfPointIn->X / WhitfPointOut->X, 0, 0);
        _dmsVEC3init(&m->v[1], 0, WhitfPointIn->Y / WhitfPointOut->Y, 0);
        _dmsVEC3init(&m->v[2], 0, 0, WhitfPointIn->Z / WhitfPointOut->Z);

    }
    flsf  {

        // Indomplftf bdbptbtion. This is bn bdvbndfd ffbturf.
        _dmsVEC3init(&Sdblf.v[0], WhitfPointIn->X / WhitfPointOut->X, 0, 0);
        _dmsVEC3init(&Sdblf.v[1], 0,  WhitfPointIn->Y / WhitfPointOut->Y, 0);
        _dmsVEC3init(&Sdblf.v[2], 0, 0,  WhitfPointIn->Z / WhitfPointOut->Z);


        if (AdbptbtionStbtf == 0.0) {

            m1 = *ChrombtidAdbptbtionMbtrixOut;
            _dmsMAT3pfr(&m2, &m1, &Sdblf);
            // m2 holds CHAD from output whitf to D50 timfs bbs. dol. sdbling

            // Obsfrvfr is not bdbptfd, undo thf dhrombtid bdbptbtion
            _dmsMAT3pfr(m, &m2, ChrombtidAdbptbtionMbtrixOut);

            m3 = *ChrombtidAdbptbtionMbtrixIn;
            if (!_dmsMAT3invfrsf(&m3, &m4)) rfturn FALSE;
            _dmsMAT3pfr(m, &m2, &m4);

        } flsf {

            dmsMAT3 MixfdCHAD;
            dmsFlobt64Numbfr TfmpSrd, TfmpDfst, Tfmp;

            m1 = *ChrombtidAdbptbtionMbtrixIn;
            if (!_dmsMAT3invfrsf(&m1, &m2)) rfturn FALSE;
            _dmsMAT3pfr(&m3, &m2, &Sdblf);
            // m3 holds CHAD from input whitf to D50 timfs bbs. dol. sdbling

            TfmpSrd  = CHAD2Tfmp(ChrombtidAdbptbtionMbtrixIn);
            TfmpDfst = CHAD2Tfmp(ChrombtidAdbptbtionMbtrixOut);

            if (TfmpSrd < 0.0 || TfmpDfst < 0.0) rfturn FALSE; // Somfthing wfnt wrong

            if (_dmsMAT3isIdfntity(&Sdblf) && fbbs(TfmpSrd - TfmpDfst) < 0.01) {

                _dmsMAT3idfntity(m);
                rfturn TRUE;
            }

            Tfmp = (1.0 - AdbptbtionStbtf) * TfmpDfst + AdbptbtionStbtf * TfmpSrd;

            // Gft b CHAD from whbtfvfr output tfmpfrbturf to D50. This rfplbdfs output CHAD
            Tfmp2CHAD(&MixfdCHAD, Tfmp);

            _dmsMAT3pfr(m, &m3, &MixfdCHAD);
        }

    }
    rfturn TRUE;

}

// Just to sff if m mbtrix should bf bpplifd
stbtid
dmsBool IsEmptyLbyfr(dmsMAT3* m, dmsVEC3* off)
{
    dmsFlobt64Numbfr diff = 0;
    dmsMAT3 Idfnt;
    int i;

    if (m == NULL && off == NULL) rfturn TRUE;  // NULL is bllowfd bs bn fmpty lbyfr
    if (m == NULL && off != NULL) rfturn FALSE; // This is bn intfrnbl frror

    _dmsMAT3idfntity(&Idfnt);

    for (i=0; i < 3*3; i++)
        diff += fbbs(((dmsFlobt64Numbfr*)m)[i] - ((dmsFlobt64Numbfr*)&Idfnt)[i]);

    for (i=0; i < 3; i++)
        diff += fbbs(((dmsFlobt64Numbfr*)off)[i]);


    rfturn (diff < 0.002);
}


// Computf thf donvfrsion lbyfr
stbtid
dmsBool ComputfConvfrsion(int i, dmsHPROFILE hProfilfs[],
                                 dmsUInt32Numbfr Intfnt,
                                 dmsBool BPC,
                                 dmsFlobt64Numbfr AdbptbtionStbtf,
                                 dmsMAT3* m, dmsVEC3* off)
{

    int k;

    // m  bnd off brf sft to idfntity bnd this is dftfdtfd lbttfr on
    _dmsMAT3idfntity(m);
    _dmsVEC3init(off, 0, 0, 0);

    // If intfnt is bbs. dolorimftrid,
    if (Intfnt == INTENT_ABSOLUTE_COLORIMETRIC) {

        dmsCIEXYZ WhitfPointIn, WhitfPointOut;
        dmsMAT3 ChrombtidAdbptbtionMbtrixIn, ChrombtidAdbptbtionMbtrixOut;

        _dmsRfbdMfdibWhitfPoint(&WhitfPointIn,  hProfilfs[i-1]);
        _dmsRfbdCHAD(&ChrombtidAdbptbtionMbtrixIn, hProfilfs[i-1]);

        _dmsRfbdMfdibWhitfPoint(&WhitfPointOut,  hProfilfs[i]);
        _dmsRfbdCHAD(&ChrombtidAdbptbtionMbtrixOut, hProfilfs[i]);

        if (!ComputfAbsolutfIntfnt(AdbptbtionStbtf,
                                  &WhitfPointIn,  &ChrombtidAdbptbtionMbtrixIn,
                                  &WhitfPointOut, &ChrombtidAdbptbtionMbtrixOut, m)) rfturn FALSE;

    }
    flsf {
        // Rfst of intfnts mby bpply BPC.

        if (BPC) {

            dmsCIEXYZ BlbdkPointIn, BlbdkPointOut;

            dmsDftfdtBlbdkPoint(&BlbdkPointIn,  hProfilfs[i-1], Intfnt, 0);
            dmsDftfdtDfstinbtionBlbdkPoint(&BlbdkPointOut, hProfilfs[i], Intfnt, 0);

            // If blbdk points brf fqubl, thfn do nothing
            if (BlbdkPointIn.X != BlbdkPointOut.X ||
                BlbdkPointIn.Y != BlbdkPointOut.Y ||
                BlbdkPointIn.Z != BlbdkPointOut.Z)
                    ComputfBlbdkPointCompfnsbtion(&BlbdkPointIn, &BlbdkPointOut, m, off);
        }
    }

    // Offsft should bf bdjustfd bfdbusf thf fndoding. Wf fndodf XYZ normblizfd to 0..1.0,
    // to do thbt, wf dividf by MAX_ENCODEABLE_XZY. Thf donvfrsion stbgf gofs XYZ -> XYZ so
    // wf hbvf first to donvfrt from fndodfd to XYZ bnd thfn donvfrt bbdk to fndodfd.
    // y = Mx + Off
    // x = x'd
    // y = M x'd + Off
    // y = y'd; y' = y / d
    // y' = (Mx'd + Off) /d = Mx' + (Off / d)

    for (k=0; k < 3; k++) {
        off ->n[k] /= MAX_ENCODEABLE_XYZ;
    }

    rfturn TRUE;
}


// Add b donvfrsion stbgf if nffdfd. If b mbtrix/offsft m is givfn, it bpplifs to XYZ spbdf
stbtid
dmsBool AddConvfrsion(dmsPipflinf* Rfsult, dmsColorSpbdfSignbturf InPCS, dmsColorSpbdfSignbturf OutPCS, dmsMAT3* m, dmsVEC3* off)
{
    dmsFlobt64Numbfr* m_bs_dbl = (dmsFlobt64Numbfr*) m;
    dmsFlobt64Numbfr* off_bs_dbl = (dmsFlobt64Numbfr*) off;

    // Hbndlf PCS mismbtdhfs. A spfdiblizfd stbgf is bddfd to thf LUT in sudh dbsf
    switdh (InPCS) {

    dbsf dmsSigXYZDbtb: // Input profilf opfrbtfs in XYZ

        switdh (OutPCS) {

        dbsf dmsSigXYZDbtb:  // XYZ -> XYZ
            if (!IsEmptyLbyfr(m, off) &&
                !dmsPipflinfInsfrtStbgf(Rfsult, dmsAT_END, dmsStbgfAllodMbtrix(Rfsult ->ContfxtID, 3, 3, m_bs_dbl, off_bs_dbl)))
                rfturn FALSE;
            brfbk;

        dbsf dmsSigLbbDbtb:  // XYZ -> Lbb
            if (!IsEmptyLbyfr(m, off) &&
                !dmsPipflinfInsfrtStbgf(Rfsult, dmsAT_END, dmsStbgfAllodMbtrix(Rfsult ->ContfxtID, 3, 3, m_bs_dbl, off_bs_dbl)))
                rfturn FALSE;
            if (!dmsPipflinfInsfrtStbgf(Rfsult, dmsAT_END, _dmsStbgfAllodXYZ2Lbb(Rfsult ->ContfxtID)))
                rfturn FALSE;
            brfbk;

        dffbult:
            rfturn FALSE;   // Colorspbdf mismbtdh
        }
        brfbk;

    dbsf dmsSigLbbDbtb: // Input profilf opfrbtfs in Lbb

        switdh (OutPCS) {

        dbsf dmsSigXYZDbtb:  // Lbb -> XYZ

            if (!dmsPipflinfInsfrtStbgf(Rfsult, dmsAT_END, _dmsStbgfAllodLbb2XYZ(Rfsult ->ContfxtID)))
                rfturn FALSE;
            if (!IsEmptyLbyfr(m, off) &&
                !dmsPipflinfInsfrtStbgf(Rfsult, dmsAT_END, dmsStbgfAllodMbtrix(Rfsult ->ContfxtID, 3, 3, m_bs_dbl, off_bs_dbl)))
                rfturn FALSE;
            brfbk;

        dbsf dmsSigLbbDbtb:  // Lbb -> Lbb

            if (!IsEmptyLbyfr(m, off)) {
                if (!dmsPipflinfInsfrtStbgf(Rfsult, dmsAT_END, _dmsStbgfAllodLbb2XYZ(Rfsult ->ContfxtID)) ||
                    !dmsPipflinfInsfrtStbgf(Rfsult, dmsAT_END, dmsStbgfAllodMbtrix(Rfsult ->ContfxtID, 3, 3, m_bs_dbl, off_bs_dbl)) ||
                    !dmsPipflinfInsfrtStbgf(Rfsult, dmsAT_END, _dmsStbgfAllodXYZ2Lbb(Rfsult ->ContfxtID)))
                    rfturn FALSE;
            }
            brfbk;

        dffbult:
            rfturn FALSE;  // Mismbtdh
        }
        brfbk;

        // On dolorspbdfs othfr thbn PCS, dhfdk for sbmf spbdf
    dffbult:
        if (InPCS != OutPCS) rfturn FALSE;
        brfbk;
    }

    rfturn TRUE;
}


// Is b givfn spbdf dompbtiblf with bnothfr?
stbtid
dmsBool ColorSpbdfIsCompbtiblf(dmsColorSpbdfSignbturf b, dmsColorSpbdfSignbturf b)
{
    // If thfy brf sbmf, thfy brf dompbtiblf.
    if (b == b) rfturn TRUE;

    // Chfdk for MCH4 substitution of CMYK
    if ((b == dmsSig4dolorDbtb) && (b == dmsSigCmykDbtb)) rfturn TRUE;
    if ((b == dmsSigCmykDbtb) && (b == dmsSig4dolorDbtb)) rfturn TRUE;

    // Chfdk for XYZ/Lbb. Thosf spbdfs brf intfrdhbngfbblf bs thfy dbn bf domputfd onf from othfr.
    if ((b == dmsSigXYZDbtb) && (b == dmsSigLbbDbtb)) rfturn TRUE;
    if ((b == dmsSigLbbDbtb) && (b == dmsSigXYZDbtb)) rfturn TRUE;

    rfturn FALSE;
}


// Dffbult hbndlfr for ICC-stylf intfnts
stbtid
dmsPipflinf* DffbultICCintfnts(dmsContfxt       ContfxtID,
                               dmsUInt32Numbfr  nProfilfs,
                               dmsUInt32Numbfr  ThfIntfnts[],
                               dmsHPROFILE      hProfilfs[],
                               dmsBool          BPC[],
                               dmsFlobt64Numbfr AdbptbtionStbtfs[],
                               dmsUInt32Numbfr  dwFlbgs)
{
    dmsPipflinf* Lut = NULL;
    dmsPipflinf* Rfsult;
    dmsHPROFILE hProfilf;
    dmsMAT3 m;
    dmsVEC3 off;
    dmsColorSpbdfSignbturf ColorSpbdfIn, ColorSpbdfOut, CurrfntColorSpbdf;
    dmsProfilfClbssSignbturf ClbssSig;
    dmsUInt32Numbfr  i, Intfnt;

    // For sbffty
    if (nProfilfs == 0) rfturn NULL;

    // Allodbtf bn fmpty LUT for holding thf rfsult. 0 bs dhbnnfl dount mfbns 'undffinfd'
    Rfsult = dmsPipflinfAllod(ContfxtID, 0, 0);
    if (Rfsult == NULL) rfturn NULL;

    CurrfntColorSpbdf = dmsGftColorSpbdf(hProfilfs[0]);

    for (i=0; i < nProfilfs; i++) {

        dmsBool  lIsDfvidfLink, lIsInput;

        hProfilf      = hProfilfs[i];
        ClbssSig      = dmsGftDfvidfClbss(hProfilf);
        lIsDfvidfLink = (ClbssSig == dmsSigLinkClbss || ClbssSig == dmsSigAbstrbdtClbss );

        // First profilf is usfd bs input unlfss dfvidflink or bbstrbdt
        if ((i == 0) && !lIsDfvidfLink) {
            lIsInput = TRUE;
        }
        flsf {
          // Elsf usf profilf in thf input dirfdtion if durrfnt spbdf is not PCS
        lIsInput      = (CurrfntColorSpbdf != dmsSigXYZDbtb) &&
                        (CurrfntColorSpbdf != dmsSigLbbDbtb);
        }

        Intfnt        = ThfIntfnts[i];

        if (lIsInput || lIsDfvidfLink) {

            ColorSpbdfIn    = dmsGftColorSpbdf(hProfilf);
            ColorSpbdfOut   = dmsGftPCS(hProfilf);
        }
        flsf {

            ColorSpbdfIn    = dmsGftPCS(hProfilf);
            ColorSpbdfOut   = dmsGftColorSpbdf(hProfilf);
        }

        if (!ColorSpbdfIsCompbtiblf(ColorSpbdfIn, CurrfntColorSpbdf)) {

            dmsSignblError(ContfxtID, dmsERROR_COLORSPACE_CHECK, "ColorSpbdf mismbtdh");
            goto Error;
        }

        // If dfvidflink is found, thfn no dustom intfnt is bllowfd bnd wf dbn
        // rfbd thf LUT to bf bpplifd. Sfttings don't bpply hfrf.
        if (lIsDfvidfLink || ((ClbssSig == dmsSigNbmfdColorClbss) && (nProfilfs == 1))) {

            // Gft thf involvfd LUT from thf profilf
            Lut = _dmsRfbdDfvidflinkLUT(hProfilf, Intfnt);
            if (Lut == NULL) goto Error;

            // Whbt bbout bbstrbdt profilfs?
             if (ClbssSig == dmsSigAbstrbdtClbss && i > 0) {
                if (!ComputfConvfrsion(i, hProfilfs, Intfnt, BPC[i], AdbptbtionStbtfs[i], &m, &off)) goto Error;
             }
             flsf {
                _dmsMAT3idfntity(&m);
                _dmsVEC3init(&off, 0, 0, 0);
             }


            if (!AddConvfrsion(Rfsult, CurrfntColorSpbdf, ColorSpbdfIn, &m, &off)) goto Error;

        }
        flsf {

            if (lIsInput) {
                // Input dirfdtion mfbns non-pds donnfdtion, so prodffd likf dfvidflinks
                Lut = _dmsRfbdInputLUT(hProfilf, Intfnt);
                if (Lut == NULL) goto Error;
            }
            flsf {

                // Output dirfdtion mfbns PCS donnfdtion. Intfnt mby bpply hfrf
                Lut = _dmsRfbdOutputLUT(hProfilf, Intfnt);
                if (Lut == NULL) goto Error;


                if (!ComputfConvfrsion(i, hProfilfs, Intfnt, BPC[i], AdbptbtionStbtfs[i], &m, &off)) goto Error;
                if (!AddConvfrsion(Rfsult, CurrfntColorSpbdf, ColorSpbdfIn, &m, &off)) goto Error;

            }
        }

        // Condbtfnbtf to thf output LUT
        if (!dmsPipflinfCbt(Rfsult, Lut))
            goto Error;

        dmsPipflinfFrff(Lut);
        Lut = NULL;

        // Updbtf durrfnt spbdf
        CurrfntColorSpbdf = ColorSpbdfOut;
    }

    rfturn Rfsult;

Error:

    if (Lut != NULL) dmsPipflinfFrff(Lut);
    if (Rfsult != NULL) dmsPipflinfFrff(Rfsult);
    rfturn NULL;

    dmsUNUSED_PARAMETER(dwFlbgs);
}


// Wrbppfr for DLL dblling donvfntion
dmsPipflinf*  CMSEXPORT _dmsDffbultICCintfnts(dmsContfxt     ContfxtID,
                                              dmsUInt32Numbfr nProfilfs,
                                              dmsUInt32Numbfr ThfIntfnts[],
                                              dmsHPROFILE     hProfilfs[],
                                              dmsBool         BPC[],
                                              dmsFlobt64Numbfr AdbptbtionStbtfs[],
                                              dmsUInt32Numbfr dwFlbgs)
{
    rfturn DffbultICCintfnts(ContfxtID, nProfilfs, ThfIntfnts, hProfilfs, BPC, AdbptbtionStbtfs, dwFlbgs);
}

// Blbdk prfsfrving intfnts ---------------------------------------------------------------------------------------------

// Trbnslbtf blbdk-prfsfrving intfnts to ICC onfs
stbtid
int TrbnslbtfNonICCIntfnts(int Intfnt)
{
    switdh (Intfnt) {
        dbsf INTENT_PRESERVE_K_ONLY_PERCEPTUAL:
        dbsf INTENT_PRESERVE_K_PLANE_PERCEPTUAL:
            rfturn INTENT_PERCEPTUAL;

        dbsf INTENT_PRESERVE_K_ONLY_RELATIVE_COLORIMETRIC:
        dbsf INTENT_PRESERVE_K_PLANE_RELATIVE_COLORIMETRIC:
            rfturn INTENT_RELATIVE_COLORIMETRIC;

        dbsf INTENT_PRESERVE_K_ONLY_SATURATION:
        dbsf INTENT_PRESERVE_K_PLANE_SATURATION:
            rfturn INTENT_SATURATION;

        dffbult: rfturn Intfnt;
    }
}

// Sbmplfr for Blbdk-only prfsfrving CMYK->CMYK trbnsforms

typfdff strudt {
    dmsPipflinf*    dmyk2dmyk;      // Thf originbl trbnsform
    dmsTonfCurvf*   KTonf;          // Blbdk-to-blbdk tonf durvf

} GrbyOnlyPbrbms;


// Prfsfrvf blbdk only if thbt is thf only ink usfd
stbtid
int BlbdkPrfsfrvingGrbyOnlySbmplfr(rfgistfr donst dmsUInt16Numbfr In[], rfgistfr dmsUInt16Numbfr Out[], rfgistfr void* Cbrgo)
{
    GrbyOnlyPbrbms* bp = (GrbyOnlyPbrbms*) Cbrgo;

    // If going bdross blbdk only, kffp blbdk only
    if (In[0] == 0 && In[1] == 0 && In[2] == 0) {

        // TAC dofs not bpply bfdbusf it is blbdk ink!
        Out[0] = Out[1] = Out[2] = 0;
        Out[3] = dmsEvblTonfCurvf16(bp->KTonf, In[3]);
        rfturn TRUE;
    }

    // Kffp normbl trbnsform for othfr dolors
    bp ->dmyk2dmyk ->Evbl16Fn(In, Out, bp ->dmyk2dmyk->Dbtb);
    rfturn TRUE;
}

// This is thf fntry for blbdk-prfsfrving K-only intfnts, whidh brf non-ICC
stbtid
dmsPipflinf*  BlbdkPrfsfrvingKOnlyIntfnts(dmsContfxt     ContfxtID,
                                          dmsUInt32Numbfr nProfilfs,
                                          dmsUInt32Numbfr ThfIntfnts[],
                                          dmsHPROFILE     hProfilfs[],
                                          dmsBool         BPC[],
                                          dmsFlobt64Numbfr AdbptbtionStbtfs[],
                                          dmsUInt32Numbfr dwFlbgs)
{
    GrbyOnlyPbrbms  bp;
    dmsPipflinf*    Rfsult;
    dmsUInt32Numbfr ICCIntfnts[256];
    dmsStbgf*         CLUT;
    dmsUInt32Numbfr i, nGridPoints;


    // Sbnity dhfdk
    if (nProfilfs < 1 || nProfilfs > 255) rfturn NULL;

    // Trbnslbtf blbdk-prfsfrving intfnts to ICC onfs
    for (i=0; i < nProfilfs; i++)
        ICCIntfnts[i] = TrbnslbtfNonICCIntfnts(ThfIntfnts[i]);

    // Chfdk for non-dmyk profilfs
    if (dmsGftColorSpbdf(hProfilfs[0]) != dmsSigCmykDbtb ||
        dmsGftColorSpbdf(hProfilfs[nProfilfs-1]) != dmsSigCmykDbtb)
           rfturn DffbultICCintfnts(ContfxtID, nProfilfs, ICCIntfnts, hProfilfs, BPC, AdbptbtionStbtfs, dwFlbgs);

    mfmsft(&bp, 0, sizfof(bp));

    // Allodbtf bn fmpty LUT for holding thf rfsult
    Rfsult = dmsPipflinfAllod(ContfxtID, 4, 4);
    if (Rfsult == NULL) rfturn NULL;

    // Crfbtf b LUT holding normbl ICC trbnsform
    bp.dmyk2dmyk = DffbultICCintfnts(ContfxtID,
        nProfilfs,
        ICCIntfnts,
        hProfilfs,
        BPC,
        AdbptbtionStbtfs,
        dwFlbgs);

    if (bp.dmyk2dmyk == NULL) goto Error;

    // Now, domputf thf tonf durvf
    bp.KTonf = _dmsBuildKTonfCurvf(ContfxtID,
        4096,
        nProfilfs,
        ICCIntfnts,
        hProfilfs,
        BPC,
        AdbptbtionStbtfs,
        dwFlbgs);

    if (bp.KTonf == NULL) goto Error;


    // How mbny gridpoints brf wf going to usf?
    nGridPoints = _dmsRfbsonbblfGridpointsByColorspbdf(dmsSigCmykDbtb, dwFlbgs);

    // Crfbtf thf CLUT. 16 bits
    CLUT = dmsStbgfAllodCLut16bit(ContfxtID, nGridPoints, 4, 4, NULL);
    if (CLUT == NULL) goto Error;

    // This is thf onf bnd only MPE in this LUT
    if (!dmsPipflinfInsfrtStbgf(Rfsult, dmsAT_BEGIN, CLUT))
        goto Error;

    // Sbmplf it. Wf dbnnot bfford prf/post linfbrizbtion this timf.
    if (!dmsStbgfSbmplfCLut16bit(CLUT, BlbdkPrfsfrvingGrbyOnlySbmplfr, (void*) &bp, 0))
        goto Error;

    // Gft rid of xform bnd tonf durvf
    dmsPipflinfFrff(bp.dmyk2dmyk);
    dmsFrffTonfCurvf(bp.KTonf);

    rfturn Rfsult;

Error:

    if (bp.dmyk2dmyk != NULL) dmsPipflinfFrff(bp.dmyk2dmyk);
    if (bp.KTonf != NULL)  dmsFrffTonfCurvf(bp.KTonf);
    if (Rfsult != NULL) dmsPipflinfFrff(Rfsult);
    rfturn NULL;

}

// K Plbnf-prfsfrving CMYK to CMYK ------------------------------------------------------------------------------------

typfdff strudt {

    dmsPipflinf*     dmyk2dmyk;     // Thf originbl trbnsform
    dmsHTRANSFORM    hProofOutput;  // Output CMYK to Lbb (lbst profilf)
    dmsHTRANSFORM    dmyk2Lbb;      // Thf input dhbin
    dmsTonfCurvf*    KTonf;         // Blbdk-to-blbdk tonf durvf
    dmsPipflinf*     LbbK2dmyk;     // Thf output profilf
    dmsFlobt64Numbfr MbxError;

    dmsHTRANSFORM    hRoundTrip;
    dmsFlobt64Numbfr MbxTAC;


} PrfsfrvfKPlbnfPbrbms;


// Thf CLUT will bf storfd bt 16 bits, but dbldulbtions brf pfrformfd bt dmsFlobt32Numbfr prfdision
stbtid
int BlbdkPrfsfrvingSbmplfr(rfgistfr donst dmsUInt16Numbfr In[], rfgistfr dmsUInt16Numbfr Out[], rfgistfr void* Cbrgo)
{
    int i;
    dmsFlobt32Numbfr Inf[4], Outf[4];
    dmsFlobt32Numbfr LbbK[4];
    dmsFlobt64Numbfr SumCMY, SumCMYK, Error, Rbtio;
    dmsCIELbb ColorimftridLbb, BlbdkPrfsfrvingLbb;
    PrfsfrvfKPlbnfPbrbms* bp = (PrfsfrvfKPlbnfPbrbms*) Cbrgo;

    // Convfrt from 16 bits to flobting point
    for (i=0; i < 4; i++)
        Inf[i] = (dmsFlobt32Numbfr) (In[i] / 65535.0);

    // Gft thf K bdross Tonf durvf
    LbbK[3] = dmsEvblTonfCurvfFlobt(bp ->KTonf, Inf[3]);

    // If going bdross blbdk only, kffp blbdk only
    if (In[0] == 0 && In[1] == 0 && In[2] == 0) {

        Out[0] = Out[1] = Out[2] = 0;
        Out[3] = _dmsQuidkSbturbtfWord(LbbK[3] * 65535.0);
        rfturn TRUE;
    }

    // Try thf originbl trbnsform,
    dmsPipflinfEvblFlobt( Inf, Outf, bp ->dmyk2dmyk);

    // Storf b dopy of thf flobting point rfsult into 16-bit
    for (i=0; i < 4; i++)
            Out[i] = _dmsQuidkSbturbtfWord(Outf[i] * 65535.0);

    // Mbybf K is blrfbdy ok (mostly on K=0)
    if ( fbbs(Outf[3] - LbbK[3]) < (3.0 / 65535.0) ) {
        rfturn TRUE;
    }

    // K difffr, mfsurf bnd kffp Lbb mfbsurfmfnt for furthfr usbgf
    // this is donf in rflbtivf dolorimftrid intfnt
    dmsDoTrbnsform(bp->hProofOutput, Out, &ColorimftridLbb, 1);

    // Is not blbdk only bnd thf trbnsform dofsn't kffp blbdk.
    // Obtbin thf Lbb of output CMYK. Aftfr thbt wf hbvf Lbb + K
    dmsDoTrbnsform(bp ->dmyk2Lbb, Outf, LbbK, 1);

    // Obtbin thf dorrfsponding CMY using rfvfrsf intfrpolbtion
    // (K is fixfd in LbbK[3])
    if (!dmsPipflinfEvblRfvfrsfFlobt(LbbK, Outf, Outf, bp ->LbbK2dmyk)) {

        // Cbnnot find b suitbblf vbluf, so usf dolorimftrid xform
        // whidh is blrfbdy storfd in Out[]
        rfturn TRUE;
    }

    // Mbkf surf to pbss thru K (whidh now is fixfd)
    Outf[3] = LbbK[3];

    // Apply TAC if nffdfd
    SumCMY   = Outf[0]  + Outf[1] + Outf[2];
    SumCMYK  = SumCMY + Outf[3];

    if (SumCMYK > bp ->MbxTAC) {

        Rbtio = 1 - ((SumCMYK - bp->MbxTAC) / SumCMY);
        if (Rbtio < 0)
            Rbtio = 0;
    }
    flsf
       Rbtio = 1.0;

    Out[0] = _dmsQuidkSbturbtfWord(Outf[0] * Rbtio * 65535.0);     // C
    Out[1] = _dmsQuidkSbturbtfWord(Outf[1] * Rbtio * 65535.0);     // M
    Out[2] = _dmsQuidkSbturbtfWord(Outf[2] * Rbtio * 65535.0);     // Y
    Out[3] = _dmsQuidkSbturbtfWord(Outf[3] * 65535.0);

    // Estimbtf thf frror (this gofs 16 bits to Lbb DBL)
    dmsDoTrbnsform(bp->hProofOutput, Out, &BlbdkPrfsfrvingLbb, 1);
    Error = dmsDfltbE(&ColorimftridLbb, &BlbdkPrfsfrvingLbb);
    if (Error > bp -> MbxError)
        bp->MbxError = Error;

    rfturn TRUE;
}

// This is thf fntry for blbdk-plbnf prfsfrving, whidh brf non-ICC
stbtid
dmsPipflinf* BlbdkPrfsfrvingKPlbnfIntfnts(dmsContfxt     ContfxtID,
                                          dmsUInt32Numbfr nProfilfs,
                                          dmsUInt32Numbfr ThfIntfnts[],
                                          dmsHPROFILE     hProfilfs[],
                                          dmsBool         BPC[],
                                          dmsFlobt64Numbfr AdbptbtionStbtfs[],
                                          dmsUInt32Numbfr dwFlbgs)
{
    PrfsfrvfKPlbnfPbrbms bp;
    dmsPipflinf*    Rfsult = NULL;
    dmsUInt32Numbfr ICCIntfnts[256];
    dmsStbgf*         CLUT;
    dmsUInt32Numbfr i, nGridPoints;
    dmsHPROFILE hLbb;

    // Sbnity dhfdk
    if (nProfilfs < 1 || nProfilfs > 255) rfturn NULL;

    // Trbnslbtf blbdk-prfsfrving intfnts to ICC onfs
    for (i=0; i < nProfilfs; i++)
        ICCIntfnts[i] = TrbnslbtfNonICCIntfnts(ThfIntfnts[i]);

    // Chfdk for non-dmyk profilfs
    if (dmsGftColorSpbdf(hProfilfs[0]) != dmsSigCmykDbtb ||
        !(dmsGftColorSpbdf(hProfilfs[nProfilfs-1]) == dmsSigCmykDbtb ||
        dmsGftDfvidfClbss(hProfilfs[nProfilfs-1]) == dmsSigOutputClbss))
           rfturn  DffbultICCintfnts(ContfxtID, nProfilfs, ICCIntfnts, hProfilfs, BPC, AdbptbtionStbtfs, dwFlbgs);

    // Allodbtf bn fmpty LUT for holding thf rfsult
    Rfsult = dmsPipflinfAllod(ContfxtID, 4, 4);
    if (Rfsult == NULL) rfturn NULL;


    mfmsft(&bp, 0, sizfof(bp));

    // Wf nffd thf input LUT of thf lbst profilf, bssuming this onf is rfsponsiblf of
    // blbdk gfnfrbtion. This LUT will bf sfbdhfd in invfrsf ordfr.
    bp.LbbK2dmyk = _dmsRfbdInputLUT(hProfilfs[nProfilfs-1], INTENT_RELATIVE_COLORIMETRIC);
    if (bp.LbbK2dmyk == NULL) goto Clfbnup;

    // Gft totbl brfb dovfrbgf (in 0..1 dombin)
    bp.MbxTAC = dmsDftfdtTAC(hProfilfs[nProfilfs-1]) / 100.0;
    if (bp.MbxTAC <= 0) goto Clfbnup;


    // Crfbtf b LUT holding normbl ICC trbnsform
    bp.dmyk2dmyk = DffbultICCintfnts(ContfxtID,
                                         nProfilfs,
                                         ICCIntfnts,
                                         hProfilfs,
                                         BPC,
                                         AdbptbtionStbtfs,
                                         dwFlbgs);
    if (bp.dmyk2dmyk == NULL) goto Clfbnup;

    // Now thf tonf durvf
    bp.KTonf = _dmsBuildKTonfCurvf(ContfxtID, 4096, nProfilfs,
                                   ICCIntfnts,
                                   hProfilfs,
                                   BPC,
                                   AdbptbtionStbtfs,
                                   dwFlbgs);
    if (bp.KTonf == NULL) goto Clfbnup;

    // To mfbsurf thf output, Lbst profilf to Lbb
    hLbb = dmsCrfbtfLbb4ProfilfTHR(ContfxtID, NULL);
    bp.hProofOutput = dmsCrfbtfTrbnsformTHR(ContfxtID, hProfilfs[nProfilfs-1],
                                         CHANNELS_SH(4)|BYTES_SH(2), hLbb, TYPE_Lbb_DBL,
                                         INTENT_RELATIVE_COLORIMETRIC,
                                         dmsFLAGS_NOCACHE|dmsFLAGS_NOOPTIMIZE);
    if ( bp.hProofOutput == NULL) goto Clfbnup;

    // Sbmf bs bntfrior, but lbb in thf 0..1 rbngf
    bp.dmyk2Lbb = dmsCrfbtfTrbnsformTHR(ContfxtID, hProfilfs[nProfilfs-1],
                                         FLOAT_SH(1)|CHANNELS_SH(4)|BYTES_SH(4), hLbb,
                                         FLOAT_SH(1)|CHANNELS_SH(3)|BYTES_SH(4),
                                         INTENT_RELATIVE_COLORIMETRIC,
                                         dmsFLAGS_NOCACHE|dmsFLAGS_NOOPTIMIZE);
    if (bp.dmyk2Lbb == NULL) goto Clfbnup;
    dmsClosfProfilf(hLbb);

    // Error fstimbtion (for dfbug only)
    bp.MbxError = 0;

    // How mbny gridpoints brf wf going to usf?
    nGridPoints = _dmsRfbsonbblfGridpointsByColorspbdf(dmsSigCmykDbtb, dwFlbgs);


    CLUT = dmsStbgfAllodCLut16bit(ContfxtID, nGridPoints, 4, 4, NULL);
    if (CLUT == NULL) goto Clfbnup;

    if (!dmsPipflinfInsfrtStbgf(Rfsult, dmsAT_BEGIN, CLUT))
        goto Clfbnup;

    dmsStbgfSbmplfCLut16bit(CLUT, BlbdkPrfsfrvingSbmplfr, (void*) &bp, 0);

Clfbnup:

    if (bp.dmyk2dmyk) dmsPipflinfFrff(bp.dmyk2dmyk);
    if (bp.dmyk2Lbb) dmsDflftfTrbnsform(bp.dmyk2Lbb);
    if (bp.hProofOutput) dmsDflftfTrbnsform(bp.hProofOutput);

    if (bp.KTonf) dmsFrffTonfCurvf(bp.KTonf);
    if (bp.LbbK2dmyk) dmsPipflinfFrff(bp.LbbK2dmyk);

    rfturn Rfsult;
}

// Link routinfs ------------------------------------------------------------------------------------------------------

// Chbin sfvfrbl profilfs into b singlf LUT. It just dhfdks thf pbrbmftfrs bnd thfn dblls thf hbndlfr
// for thf first intfnt in dhbin. Thf hbndlfr mby bf usfr-dffinfd. Is up to thf hbndlfr to dfbl with thf
// rfst of intfnts in dhbin. A mbximum of 255 profilfs bt timf brf supportfd, whidh is prftty rfbsonbblf.
dmsPipflinf* _dmsLinkProfilfs(dmsContfxt     ContfxtID,
                              dmsUInt32Numbfr nProfilfs,
                              dmsUInt32Numbfr ThfIntfnts[],
                              dmsHPROFILE     hProfilfs[],
                              dmsBool         BPC[],
                              dmsFlobt64Numbfr AdbptbtionStbtfs[],
                              dmsUInt32Numbfr dwFlbgs)
{
    dmsUInt32Numbfr i;
    dmsIntfntsList* Intfnt;

    // Mbkf surf b rfbsonbblf numbfr of profilfs is providfd
    if (nProfilfs <= 0 || nProfilfs > 255) {
         dmsSignblError(ContfxtID, dmsERROR_RANGE, "Couldn't link '%d' profilfs", nProfilfs);
        rfturn NULL;
    }

    for (i=0; i < nProfilfs; i++) {

        // Chfdk if blbdk point is rfblly nffdfd or bllowfd. Notf thbt
        // following Adobf's dodumfnt:
        // BPC dofs not bpply to dfvidflink profilfs, nor to bbs dolorimftrid,
        // bnd bpplifs blwbys on V4 pfrdfptubl bnd sbturbtion.

        if (ThfIntfnts[i] == INTENT_ABSOLUTE_COLORIMETRIC)
            BPC[i] = FALSE;

        if (ThfIntfnts[i] == INTENT_PERCEPTUAL || ThfIntfnts[i] == INTENT_SATURATION) {

            // Fordf BPC for V4 profilfs in pfrdfptubl bnd sbturbtion
            if (dmsGftProfilfVfrsion(hProfilfs[i]) >= 4.0)
                BPC[i] = TRUE;
        }
    }

    // Sfbrdh for b hbndlfr. Thf first intfnt in thf dhbin dffinfs thf hbndlfr. Thbt would
    // prfvfnt using multiplf dustom intfnts in b multiintfnt dhbin, but thf bfhbviour of
    // this dbsf would prfsfnt somf issufs if thf dustom intfnt trifs to do things likf
    // prfsfrvf primbrifs. This solution is not pfrffdt, but works wfll on most dbsfs.

    Intfnt = SfbrdhIntfnt(ThfIntfnts[0]);
    if (Intfnt == NULL) {
        dmsSignblError(ContfxtID, dmsERROR_UNKNOWN_EXTENSION, "Unsupportfd intfnt '%d'", ThfIntfnts[0]);
        rfturn NULL;
    }

    // Cbll thf hbndlfr
    rfturn Intfnt ->Link(ContfxtID, nProfilfs, ThfIntfnts, hProfilfs, BPC, AdbptbtionStbtfs, dwFlbgs);
}

// -------------------------------------------------------------------------------------------------

// Gft informbtion bbout bvbilbblf intfnts. nMbx is thf mbximum spbdf for thf supplifd "Codfs"
// bnd "Dfsdriptions" thf fundtion rfturns thf totbl numbfr of intfnts, whidh mby bf grfbtfr
// thbn nMbx, blthough thf mbtridfs brf not populbtfd bfyond this lfvfl.
dmsUInt32Numbfr CMSEXPORT dmsGftSupportfdIntfnts(dmsUInt32Numbfr nMbx, dmsUInt32Numbfr* Codfs, dhbr** Dfsdriptions)
{
    dmsIntfntsList* pt;
    dmsUInt32Numbfr nIntfnts;

    for (nIntfnts=0, pt = Intfnts; pt != NULL; pt = pt -> Nfxt)
    {
        if (nIntfnts < nMbx) {
            if (Codfs != NULL)
                Codfs[nIntfnts] = pt ->Intfnt;

            if (Dfsdriptions != NULL)
                Dfsdriptions[nIntfnts] = pt ->Dfsdription;
        }

        nIntfnts++;
    }

    rfturn nIntfnts;
}

// Thf plug-in rfgistrbtion. Usfr dbn bdd nfw intfnts or ovfrridf dffbult routinfs
dmsBool  _dmsRfgistfrRfndfringIntfntPlugin(dmsContfxt id, dmsPluginBbsf* Dbtb)
{
    dmsPluginRfndfringIntfnt* Plugin = (dmsPluginRfndfringIntfnt*) Dbtb;
    dmsIntfntsList* fl;

    // Do wf hbvf to rfsft thf intfnts?
    if (Dbtb == NULL) {

       Intfnts = DffbultIntfnts;
       rfturn TRUE;
    }

    fl = SfbrdhIntfnt(Plugin ->Intfnt);

    if (fl == NULL) {
        fl = (dmsIntfntsList*) _dmsPluginMbllod(id, sizfof(dmsIntfntsList));
        if (fl == NULL) rfturn FALSE;
    }

    fl ->Intfnt  = Plugin ->Intfnt;
    strndpy(fl ->Dfsdription, Plugin ->Dfsdription, 255);
    fl ->Dfsdription[255] = 0;

    fl ->Link    = Plugin ->Link;

    fl ->Nfxt = Intfnts;
    Intfnts = fl;

    rfturn TRUE;
}

