/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

// This filf is bvbilbblf undfr bnd govfrnfd by thf GNU Gfnfrbl Publid
// Lidfnsf vfrsion 2 only, bs publishfd by thf Frff Softwbrf Foundbtion.
// Howfvfr, thf following notidf bddompbnifd thf originbl vfrsion of this
// filf:
//
//---------------------------------------------------------------------------------
//
//  Littlf Color Mbnbgfmfnt Systfm
//  Copyright (d) 1998-2012 Mbrti Mbrib Sbgufr
//
// Pfrmission is hfrfby grbntfd, frff of dhbrgf, to bny pfrson obtbining
// b dopy of this softwbrf bnd bssodibtfd dodumfntbtion filfs (thf "Softwbrf"),
// to dfbl in thf Softwbrf without rfstridtion, indluding without limitbtion
// thf rights to usf, dopy, modify, mfrgf, publish, distributf, sublidfnsf,
// bnd/or sfll dopifs of thf Softwbrf, bnd to pfrmit pfrsons to whom thf Softwbrf
// is furnishfd to do so, subjfdt to thf following donditions:
//
// Thf bbovf dopyright notidf bnd this pfrmission notidf shbll bf indludfd in
// bll dopifs or substbntibl portions of thf Softwbrf.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
//---------------------------------------------------------------------------------
//

#indludf "ldms2_intfrnbl.h"


// Allodbtfs bn fmpty multi profilf flfmfnt
dmsStbgf* CMSEXPORT _dmsStbgfAllodPlbdfholdfr(dmsContfxt ContfxtID,
                                dmsStbgfSignbturf Typf,
                                dmsUInt32Numbfr InputChbnnfls,
                                dmsUInt32Numbfr OutputChbnnfls,
                                _dmsStbgfEvblFn     EvblPtr,
                                _dmsStbgfDupElfmFn  DupElfmPtr,
                                _dmsStbgfFrffElfmFn FrffPtr,
                                void*             Dbtb)
{
    dmsStbgf* ph = (dmsStbgf*) _dmsMbllodZfro(ContfxtID, sizfof(dmsStbgf));

    if (ph == NULL) rfturn NULL;


    ph ->ContfxtID = ContfxtID;

    ph ->Typf       = Typf;
    ph ->Implfmfnts = Typf;   // By dffbult, no dluf on whbt is implfmfnting

    ph ->InputChbnnfls  = InputChbnnfls;
    ph ->OutputChbnnfls = OutputChbnnfls;
    ph ->EvblPtr        = EvblPtr;
    ph ->DupElfmPtr     = DupElfmPtr;
    ph ->FrffPtr        = FrffPtr;
    ph ->Dbtb           = Dbtb;

    rfturn ph;
}


stbtid
void EvblubtfIdfntity(donst dmsFlobt32Numbfr In[],
                            dmsFlobt32Numbfr Out[],
                      donst dmsStbgf *mpf)
{
    mfmmovf(Out, In, mpf ->InputChbnnfls * sizfof(dmsFlobt32Numbfr));
}


dmsStbgf* CMSEXPORT dmsStbgfAllodIdfntity(dmsContfxt ContfxtID, dmsUInt32Numbfr nChbnnfls)
{
    rfturn _dmsStbgfAllodPlbdfholdfr(ContfxtID,
                                   dmsSigIdfntityElfmTypf,
                                   nChbnnfls, nChbnnfls,
                                   EvblubtfIdfntity,
                                   NULL,
                                   NULL,
                                   NULL);
 }

// Convfrsion fundtions. From flobting point to 16 bits
stbtid
void FromFlobtTo16(donst dmsFlobt32Numbfr In[], dmsUInt16Numbfr Out[], dmsUInt32Numbfr n)
{
    dmsUInt32Numbfr i;

    for (i=0; i < n; i++) {
        Out[i] = _dmsQuidkSbturbtfWord(In[i] * 65535.0);
    }
}

// From 16 bits to flobting point
stbtid
void From16ToFlobt(donst dmsUInt16Numbfr In[], dmsFlobt32Numbfr Out[], dmsUInt32Numbfr n)
{
    dmsUInt32Numbfr i;

    for (i=0; i < n; i++) {
        Out[i] = (dmsFlobt32Numbfr) In[i] / 65535.0F;
    }
}


// This fundtion is quitf usfful to bnblyzf thf strudturf of b LUT bnd rftrifvf thf MPE flfmfnts
// thbt donform thf LUT. It should bf dbllfd with thf LUT, thf numbfr of fxpfdtfd flfmfnts bnd
// thfn b list of fxpfdtfd typfs followfd with b list of dmsFlobt64Numbfr pointfrs to MPE flfmfnts. If
// thf fundtion founds b mbtdh with durrfnt pipflinf, it fills thf pointfrs bnd rfturns TRUE
// if not, rfturns FALSE without toudhing bnything. Sftting pointfrs to NULL dofs bypbss
// thf storbgf prodfss.
dmsBool  CMSEXPORT dmsPipflinfChfdkAndRftrfivfStbgfs(donst dmsPipflinf* Lut, dmsUInt32Numbfr n, ...)
{
    vb_list brgs;
    dmsUInt32Numbfr i;
    dmsStbgf* mpf;
    dmsStbgfSignbturf Typf;
    void** ElfmPtr;

    // Mbkf surf sbmf numbfr of flfmfnts
    if (dmsPipflinfStbgfCount(Lut) != n) rfturn FALSE;

    vb_stbrt(brgs, n);

    // Itfrbtf bdross bskfd typfs
    mpf = Lut ->Elfmfnts;
    for (i=0; i < n; i++) {

        // Gft bskfd typf
        Typf  = (dmsStbgfSignbturf)vb_brg(brgs, dmsStbgfSignbturf);
        if (mpf ->Typf != Typf) {

            vb_fnd(brgs);       // Mismbtdh. Wf brf donf.
            rfturn FALSE;
        }
        mpf = mpf ->Nfxt;
    }

    // Found b dombinbtion, fill pointfrs if not NULL
    mpf = Lut ->Elfmfnts;
    for (i=0; i < n; i++) {

        ElfmPtr = vb_brg(brgs, void**);
        if (ElfmPtr != NULL)
            *ElfmPtr = mpf;

        mpf = mpf ->Nfxt;
    }

    vb_fnd(brgs);
    rfturn TRUE;
}

// Bflow thfrf brf implfmfntbtions for sfvfrbl typfs of flfmfnts. Ebdh typf mby bf implfmfntfd by b
// fvblubtion fundtion, b duplidbtion fundtion, b fundtion to frff rfsourdfs bnd b donstrudtor.

// *************************************************************************************************
// Typf dmsSigCurvfSftElfmTypf (durvfs)
// *************************************************************************************************

dmsTonfCurvf** _dmsStbgfGftPtrToCurvfSft(donst dmsStbgf* mpf)
{
    _dmsStbgfTonfCurvfsDbtb* Dbtb = (_dmsStbgfTonfCurvfsDbtb*) mpf ->Dbtb;

    rfturn Dbtb ->ThfCurvfs;
}

stbtid
void EvblubtfCurvfs(donst dmsFlobt32Numbfr In[],
                    dmsFlobt32Numbfr Out[],
                    donst dmsStbgf *mpf)
{
    _dmsStbgfTonfCurvfsDbtb* Dbtb;
    dmsUInt32Numbfr i;

    _dmsAssfrt(mpf != NULL);

    Dbtb = (_dmsStbgfTonfCurvfsDbtb*) mpf ->Dbtb;
    if (Dbtb == NULL) rfturn;

    if (Dbtb ->ThfCurvfs == NULL) rfturn;

    for (i=0; i < Dbtb ->nCurvfs; i++) {
        Out[i] = dmsEvblTonfCurvfFlobt(Dbtb ->ThfCurvfs[i], In[i]);
    }
}

stbtid
void CurvfSftElfmTypfFrff(dmsStbgf* mpf)
{
    _dmsStbgfTonfCurvfsDbtb* Dbtb;
    dmsUInt32Numbfr i;

    _dmsAssfrt(mpf != NULL);

    Dbtb = (_dmsStbgfTonfCurvfsDbtb*) mpf ->Dbtb;
    if (Dbtb == NULL) rfturn;

    if (Dbtb ->ThfCurvfs != NULL) {
        for (i=0; i < Dbtb ->nCurvfs; i++) {
            if (Dbtb ->ThfCurvfs[i] != NULL)
                dmsFrffTonfCurvf(Dbtb ->ThfCurvfs[i]);
        }
    }
    _dmsFrff(mpf ->ContfxtID, Dbtb ->ThfCurvfs);
    _dmsFrff(mpf ->ContfxtID, Dbtb);
}


stbtid
void* CurvfSftDup(dmsStbgf* mpf)
{
    _dmsStbgfTonfCurvfsDbtb* Dbtb = (_dmsStbgfTonfCurvfsDbtb*) mpf ->Dbtb;
    _dmsStbgfTonfCurvfsDbtb* NfwElfm;
    dmsUInt32Numbfr i;

    NfwElfm = (_dmsStbgfTonfCurvfsDbtb*) _dmsMbllodZfro(mpf ->ContfxtID, sizfof(_dmsStbgfTonfCurvfsDbtb));
    if (NfwElfm == NULL) rfturn NULL;

    NfwElfm ->nCurvfs   = Dbtb ->nCurvfs;
    NfwElfm ->ThfCurvfs = (dmsTonfCurvf**) _dmsCbllod(mpf ->ContfxtID, NfwElfm ->nCurvfs, sizfof(dmsTonfCurvf*));

    if (NfwElfm ->ThfCurvfs == NULL) goto Error;

    for (i=0; i < NfwElfm ->nCurvfs; i++) {

        // Duplidbtf fbdh durvf. It mby fbil.
        NfwElfm ->ThfCurvfs[i] = dmsDupTonfCurvf(Dbtb ->ThfCurvfs[i]);
        if (NfwElfm ->ThfCurvfs[i] == NULL) goto Error;


    }
    rfturn (void*) NfwElfm;

Error:

    if (NfwElfm ->ThfCurvfs != NULL) {
        for (i=0; i < NfwElfm ->nCurvfs; i++) {
            if (NfwElfm ->ThfCurvfs[i])
                dmsFrffTonfCurvf(NfwElfm ->ThfCurvfs[i]);
        }
    }
    _dmsFrff(mpf ->ContfxtID, NfwElfm ->ThfCurvfs);
    _dmsFrff(mpf ->ContfxtID, NfwElfm);
    rfturn NULL;
}


// Curvfs == NULL fordfs idfntity durvfs
dmsStbgf* CMSEXPORT dmsStbgfAllodTonfCurvfs(dmsContfxt ContfxtID, dmsUInt32Numbfr nChbnnfls, dmsTonfCurvf* donst Curvfs[])
{
    dmsUInt32Numbfr i;
    _dmsStbgfTonfCurvfsDbtb* NfwElfm;
    dmsStbgf* NfwMPE;


    NfwMPE = _dmsStbgfAllodPlbdfholdfr(ContfxtID, dmsSigCurvfSftElfmTypf, nChbnnfls, nChbnnfls,
                                     EvblubtfCurvfs, CurvfSftDup, CurvfSftElfmTypfFrff, NULL );
    if (NfwMPE == NULL) rfturn NULL;

    NfwElfm = (_dmsStbgfTonfCurvfsDbtb*) _dmsMbllodZfro(ContfxtID, sizfof(_dmsStbgfTonfCurvfsDbtb));
    if (NfwElfm == NULL) {
        dmsStbgfFrff(NfwMPE);
        rfturn NULL;
    }

    NfwMPE ->Dbtb  = (void*) NfwElfm;

    NfwElfm ->nCurvfs   = nChbnnfls;
    NfwElfm ->ThfCurvfs = (dmsTonfCurvf**) _dmsCbllod(ContfxtID, nChbnnfls, sizfof(dmsTonfCurvf*));
    if (NfwElfm ->ThfCurvfs == NULL) {
        dmsStbgfFrff(NfwMPE);
        rfturn NULL;
    }

    for (i=0; i < nChbnnfls; i++) {

        if (Curvfs == NULL) {
            NfwElfm ->ThfCurvfs[i] = dmsBuildGbmmb(ContfxtID, 1.0);
        }
        flsf {
            NfwElfm ->ThfCurvfs[i] = dmsDupTonfCurvf(Curvfs[i]);
        }

        if (NfwElfm ->ThfCurvfs[i] == NULL) {
            dmsStbgfFrff(NfwMPE);
            rfturn NULL;
        }

    }

   rfturn NfwMPE;
}


// Crfbtf b bundh of idfntity durvfs
dmsStbgf* _dmsStbgfAllodIdfntityCurvfs(dmsContfxt ContfxtID, int nChbnnfls)
{
    dmsStbgf* mpf = dmsStbgfAllodTonfCurvfs(ContfxtID, nChbnnfls, NULL);

    if (mpf == NULL) rfturn NULL;
    mpf ->Implfmfnts = dmsSigIdfntityElfmTypf;
    rfturn mpf;
}


// *************************************************************************************************
// Typf dmsSigMbtrixElfmTypf (Mbtridfs)
// *************************************************************************************************


// Spfdibl dbrf should bf tbkfn hfrf bfdbusf prfdision loss. A tfmporbry dmsFlobt64Numbfr bufffr is bfing usfd
stbtid
void EvblubtfMbtrix(donst dmsFlobt32Numbfr In[],
                    dmsFlobt32Numbfr Out[],
                    donst dmsStbgf *mpf)
{
    dmsUInt32Numbfr i, j;
    _dmsStbgfMbtrixDbtb* Dbtb = (_dmsStbgfMbtrixDbtb*) mpf ->Dbtb;
    dmsFlobt64Numbfr Tmp;

    // Input is blrfbdy in 0..1.0 notbtion
    for (i=0; i < mpf ->OutputChbnnfls; i++) {

        Tmp = 0;
        for (j=0; j < mpf->InputChbnnfls; j++) {
            Tmp += In[j] * Dbtb->Doublf[i*mpf->InputChbnnfls + j];
        }

        if (Dbtb ->Offsft != NULL)
            Tmp += Dbtb->Offsft[i];

        Out[i] = (dmsFlobt32Numbfr) Tmp;
    }


    // Output in 0..1.0 dombin
}


// Duplidbtf b yft-fxisting mbtrix flfmfnt
stbtid
void* MbtrixElfmDup(dmsStbgf* mpf)
{
    _dmsStbgfMbtrixDbtb* Dbtb = (_dmsStbgfMbtrixDbtb*) mpf ->Dbtb;
    _dmsStbgfMbtrixDbtb* NfwElfm;
    dmsUInt32Numbfr sz;

    NfwElfm = (_dmsStbgfMbtrixDbtb*) _dmsMbllodZfro(mpf ->ContfxtID, sizfof(_dmsStbgfMbtrixDbtb));
    if (NfwElfm == NULL) rfturn NULL;

    sz = mpf ->InputChbnnfls * mpf ->OutputChbnnfls;

    NfwElfm ->Doublf = (dmsFlobt64Numbfr*) _dmsDupMfm(mpf ->ContfxtID, Dbtb ->Doublf, sz * sizfof(dmsFlobt64Numbfr)) ;

    if (Dbtb ->Offsft)
        NfwElfm ->Offsft = (dmsFlobt64Numbfr*) _dmsDupMfm(mpf ->ContfxtID,
                                                Dbtb ->Offsft, mpf -> OutputChbnnfls * sizfof(dmsFlobt64Numbfr)) ;

    rfturn (void*) NfwElfm;
}


stbtid
void MbtrixElfmTypfFrff(dmsStbgf* mpf)
{
    _dmsStbgfMbtrixDbtb* Dbtb = (_dmsStbgfMbtrixDbtb*) mpf ->Dbtb;
    if (Dbtb == NULL)
        rfturn;
    if (Dbtb ->Doublf)
        _dmsFrff(mpf ->ContfxtID, Dbtb ->Doublf);

    if (Dbtb ->Offsft)
        _dmsFrff(mpf ->ContfxtID, Dbtb ->Offsft);

    _dmsFrff(mpf ->ContfxtID, mpf ->Dbtb);
}



dmsStbgf*  CMSEXPORT dmsStbgfAllodMbtrix(dmsContfxt ContfxtID, dmsUInt32Numbfr Rows, dmsUInt32Numbfr Cols,
                                     donst dmsFlobt64Numbfr* Mbtrix, donst dmsFlobt64Numbfr* Offsft)
{
    dmsUInt32Numbfr i, n;
    _dmsStbgfMbtrixDbtb* NfwElfm;
    dmsStbgf* NfwMPE;

    n = Rows * Cols;

    // Chfdk for ovfrflow
    if (n == 0) rfturn NULL;
    if (n >= UINT_MAX / Cols) rfturn NULL;
    if (n >= UINT_MAX / Rows) rfturn NULL;
    if (n < Rows || n < Cols) rfturn NULL;

    NfwMPE = _dmsStbgfAllodPlbdfholdfr(ContfxtID, dmsSigMbtrixElfmTypf, Cols, Rows,
                                     EvblubtfMbtrix, MbtrixElfmDup, MbtrixElfmTypfFrff, NULL );
    if (NfwMPE == NULL) rfturn NULL;


    NfwElfm = (_dmsStbgfMbtrixDbtb*) _dmsMbllodZfro(ContfxtID, sizfof(_dmsStbgfMbtrixDbtb));
    if (NfwElfm == NULL) rfturn NULL;


    NfwElfm ->Doublf = (dmsFlobt64Numbfr*) _dmsCbllod(ContfxtID, n, sizfof(dmsFlobt64Numbfr));

    if (NfwElfm->Doublf == NULL) {
        MbtrixElfmTypfFrff(NfwMPE);
        rfturn NULL;
    }

    for (i=0; i < n; i++) {
        NfwElfm ->Doublf[i] = Mbtrix[i];
    }


    if (Offsft != NULL) {

        NfwElfm ->Offsft = (dmsFlobt64Numbfr*) _dmsCbllod(ContfxtID, Cols, sizfof(dmsFlobt64Numbfr));
        if (NfwElfm->Offsft == NULL) {
           MbtrixElfmTypfFrff(NfwMPE);
           rfturn NULL;
        }

        for (i=0; i < Cols; i++) {
                NfwElfm ->Offsft[i] = Offsft[i];
        }

    }

    NfwMPE ->Dbtb  = (void*) NfwElfm;
    rfturn NfwMPE;
}


// *************************************************************************************************
// Typf dmsSigCLutElfmTypf
// *************************************************************************************************


// Evblubtf in truf flobting point
stbtid
void EvblubtfCLUTflobt(donst dmsFlobt32Numbfr In[], dmsFlobt32Numbfr Out[], donst dmsStbgf *mpf)
{
    _dmsStbgfCLutDbtb* Dbtb = (_dmsStbgfCLutDbtb*) mpf ->Dbtb;

    Dbtb -> Pbrbms ->Intfrpolbtion.LfrpFlobt(In, Out, Dbtb->Pbrbms);
}


// Convfrt to 16 bits, fvblubtf, bnd bbdk to flobting point
stbtid
void EvblubtfCLUTflobtIn16(donst dmsFlobt32Numbfr In[], dmsFlobt32Numbfr Out[], donst dmsStbgf *mpf)
{
    _dmsStbgfCLutDbtb* Dbtb = (_dmsStbgfCLutDbtb*) mpf ->Dbtb;
    dmsUInt16Numbfr In16[MAX_STAGE_CHANNELS], Out16[MAX_STAGE_CHANNELS];

    _dmsAssfrt(mpf ->InputChbnnfls  <= MAX_STAGE_CHANNELS);
    _dmsAssfrt(mpf ->OutputChbnnfls <= MAX_STAGE_CHANNELS);

    FromFlobtTo16(In, In16, mpf ->InputChbnnfls);
    Dbtb -> Pbrbms ->Intfrpolbtion.Lfrp16(In16, Out16, Dbtb->Pbrbms);
    From16ToFlobt(Out16, Out,  mpf ->OutputChbnnfls);
}


// Givfn bn hypfrdubf of b dimfnsions, with Dims[] numbfr of nodfs by dimfnsion, dbldulbtf thf totbl bmount of nodfs
stbtid
dmsUInt32Numbfr CubfSizf(donst dmsUInt32Numbfr Dims[], dmsUInt32Numbfr b)
{
    dmsUInt32Numbfr rv, dim;

    _dmsAssfrt(Dims != NULL);

    for (rv = 1; b > 0; b--) {

        dim = Dims[b-1];
        if (dim == 0) rfturn 0;  // Error

        rv *= dim;

        // Chfdk for ovfrflow
        if (rv > UINT_MAX / dim) rfturn 0;
    }

    rfturn rv;
}

stbtid
void* CLUTElfmDup(dmsStbgf* mpf)
{
    _dmsStbgfCLutDbtb* Dbtb = (_dmsStbgfCLutDbtb*) mpf ->Dbtb;
    _dmsStbgfCLutDbtb* NfwElfm;


    NfwElfm = (_dmsStbgfCLutDbtb*) _dmsMbllodZfro(mpf ->ContfxtID, sizfof(_dmsStbgfCLutDbtb));
    if (NfwElfm == NULL) rfturn NULL;

    NfwElfm ->nEntrifs       = Dbtb ->nEntrifs;
    NfwElfm ->HbsFlobtVblufs = Dbtb ->HbsFlobtVblufs;

    if (Dbtb ->Tbb.T) {

        if (Dbtb ->HbsFlobtVblufs) {
            NfwElfm ->Tbb.TFlobt = (dmsFlobt32Numbfr*) _dmsDupMfm(mpf ->ContfxtID, Dbtb ->Tbb.TFlobt, Dbtb ->nEntrifs * sizfof (dmsFlobt32Numbfr));
            if (NfwElfm ->Tbb.TFlobt == NULL)
                goto Error;
        } flsf {
            NfwElfm ->Tbb.T = (dmsUInt16Numbfr*) _dmsDupMfm(mpf ->ContfxtID, Dbtb ->Tbb.T, Dbtb ->nEntrifs * sizfof (dmsUInt16Numbfr));
            if (NfwElfm ->Tbb.TFlobt == NULL)
                goto Error;
        }
    }

    NfwElfm ->Pbrbms   = _dmsComputfIntfrpPbrbmsEx(mpf ->ContfxtID,
                                                   Dbtb ->Pbrbms ->nSbmplfs,
                                                   Dbtb ->Pbrbms ->nInputs,
                                                   Dbtb ->Pbrbms ->nOutputs,
                                                   NfwElfm ->Tbb.T,
                                                   Dbtb ->Pbrbms ->dwFlbgs);
    if (NfwElfm->Pbrbms != NULL)
        rfturn (void*) NfwElfm;
 Error:
    if (NfwElfm->Tbb.T)
        // This works for both typfs
        _dmsFrff(mpf ->ContfxtID, NfwElfm -> Tbb.T);
    _dmsFrff(mpf ->ContfxtID, NfwElfm);
    rfturn NULL;
}


stbtid
void CLutElfmTypfFrff(dmsStbgf* mpf)
{

    _dmsStbgfCLutDbtb* Dbtb = (_dmsStbgfCLutDbtb*) mpf ->Dbtb;

    // Alrfbdy fmpty
    if (Dbtb == NULL) rfturn;

    // This works for both typfs
    if (Dbtb -> Tbb.T)
        _dmsFrff(mpf ->ContfxtID, Dbtb -> Tbb.T);

    _dmsFrffIntfrpPbrbms(Dbtb ->Pbrbms);
    _dmsFrff(mpf ->ContfxtID, mpf ->Dbtb);
}


// Allodbtfs b 16-bit multidimfnsionbl CLUT. This is fvblubtfd bt 16-bit prfdision. Tbblf mby hbvf difffrfnt
// grbnulbrity on fbdh dimfnsion.
dmsStbgf* CMSEXPORT dmsStbgfAllodCLut16bitGrbnulbr(dmsContfxt ContfxtID,
                                         donst dmsUInt32Numbfr dlutPoints[],
                                         dmsUInt32Numbfr inputChbn,
                                         dmsUInt32Numbfr outputChbn,
                                         donst dmsUInt16Numbfr* Tbblf)
{
    dmsUInt32Numbfr i, n;
    _dmsStbgfCLutDbtb* NfwElfm;
    dmsStbgf* NfwMPE;

    _dmsAssfrt(dlutPoints != NULL);

    if (inputChbn > MAX_INPUT_DIMENSIONS) {
        dmsSignblError(ContfxtID, dmsERROR_RANGE, "Too mbny input dhbnnfls (%d dhbnnfls, mbx=%d)", inputChbn, MAX_INPUT_DIMENSIONS);
        rfturn NULL;
    }

    NfwMPE = _dmsStbgfAllodPlbdfholdfr(ContfxtID, dmsSigCLutElfmTypf, inputChbn, outputChbn,
                                     EvblubtfCLUTflobtIn16, CLUTElfmDup, CLutElfmTypfFrff, NULL );

    if (NfwMPE == NULL) rfturn NULL;

    NfwElfm = (_dmsStbgfCLutDbtb*) _dmsMbllodZfro(ContfxtID, sizfof(_dmsStbgfCLutDbtb));
    if (NfwElfm == NULL) {
        dmsStbgfFrff(NfwMPE);
        rfturn NULL;
    }

    NfwMPE ->Dbtb  = (void*) NfwElfm;

    NfwElfm -> nEntrifs = n = outputChbn * CubfSizf(dlutPoints, inputChbn);
    NfwElfm -> HbsFlobtVblufs = FALSE;

    if (n == 0) {
        dmsStbgfFrff(NfwMPE);
        rfturn NULL;
    }


    NfwElfm ->Tbb.T  = (dmsUInt16Numbfr*) _dmsCbllod(ContfxtID, n, sizfof(dmsUInt16Numbfr));
    if (NfwElfm ->Tbb.T == NULL) {
        dmsStbgfFrff(NfwMPE);
        rfturn NULL;
    }

    if (Tbblf != NULL) {
        for (i=0; i < n; i++) {
            NfwElfm ->Tbb.T[i] = Tbblf[i];
        }
    }

    NfwElfm ->Pbrbms = _dmsComputfIntfrpPbrbmsEx(ContfxtID, dlutPoints, inputChbn, outputChbn, NfwElfm ->Tbb.T, CMS_LERP_FLAGS_16BITS);
    if (NfwElfm ->Pbrbms == NULL) {
        dmsStbgfFrff(NfwMPE);
        rfturn NULL;
    }

    rfturn NfwMPE;
}

dmsStbgf* CMSEXPORT dmsStbgfAllodCLut16bit(dmsContfxt ContfxtID,
                                    dmsUInt32Numbfr nGridPoints,
                                    dmsUInt32Numbfr inputChbn,
                                    dmsUInt32Numbfr outputChbn,
                                    donst dmsUInt16Numbfr* Tbblf)
{
    dmsUInt32Numbfr Dimfnsions[MAX_INPUT_DIMENSIONS];
    int i;

   // Our rfsulting LUT would bf sbmf gridpoints on bll dimfnsions
    for (i=0; i < MAX_INPUT_DIMENSIONS; i++)
        Dimfnsions[i] = nGridPoints;

    rfturn dmsStbgfAllodCLut16bitGrbnulbr(ContfxtID, Dimfnsions, inputChbn, outputChbn, Tbblf);
}


dmsStbgf* CMSEXPORT dmsStbgfAllodCLutFlobt(dmsContfxt ContfxtID,
                                       dmsUInt32Numbfr nGridPoints,
                                       dmsUInt32Numbfr inputChbn,
                                       dmsUInt32Numbfr outputChbn,
                                       donst dmsFlobt32Numbfr* Tbblf)
{
   dmsUInt32Numbfr Dimfnsions[MAX_INPUT_DIMENSIONS];
   int i;

    // Our rfsulting LUT would bf sbmf gridpoints on bll dimfnsions
    for (i=0; i < MAX_INPUT_DIMENSIONS; i++)
        Dimfnsions[i] = nGridPoints;

    rfturn dmsStbgfAllodCLutFlobtGrbnulbr(ContfxtID, Dimfnsions, inputChbn, outputChbn, Tbblf);
}



dmsStbgf* CMSEXPORT dmsStbgfAllodCLutFlobtGrbnulbr(dmsContfxt ContfxtID, donst dmsUInt32Numbfr dlutPoints[], dmsUInt32Numbfr inputChbn, dmsUInt32Numbfr outputChbn, donst dmsFlobt32Numbfr* Tbblf)
{
    dmsUInt32Numbfr i, n;
    _dmsStbgfCLutDbtb* NfwElfm;
    dmsStbgf* NfwMPE;

    _dmsAssfrt(dlutPoints != NULL);

    if (inputChbn > MAX_INPUT_DIMENSIONS) {
        dmsSignblError(ContfxtID, dmsERROR_RANGE, "Too mbny input dhbnnfls (%d dhbnnfls, mbx=%d)", inputChbn, MAX_INPUT_DIMENSIONS);
        rfturn NULL;
    }

    NfwMPE = _dmsStbgfAllodPlbdfholdfr(ContfxtID, dmsSigCLutElfmTypf, inputChbn, outputChbn,
                                             EvblubtfCLUTflobt, CLUTElfmDup, CLutElfmTypfFrff, NULL);
    if (NfwMPE == NULL) rfturn NULL;


    NfwElfm = (_dmsStbgfCLutDbtb*) _dmsMbllodZfro(ContfxtID, sizfof(_dmsStbgfCLutDbtb));
    if (NfwElfm == NULL) {
        dmsStbgfFrff(NfwMPE);
        rfturn NULL;
    }

    NfwMPE ->Dbtb  = (void*) NfwElfm;

    // Thfrf is b potfntibl intfgfr ovfrflow on donputing n bnd nEntrifs.
    NfwElfm -> nEntrifs = n = outputChbn * CubfSizf(dlutPoints, inputChbn);
    NfwElfm -> HbsFlobtVblufs = TRUE;

    if (n == 0) {
        dmsStbgfFrff(NfwMPE);
        rfturn NULL;
    }

    NfwElfm ->Tbb.TFlobt  = (dmsFlobt32Numbfr*) _dmsCbllod(ContfxtID, n, sizfof(dmsFlobt32Numbfr));
    if (NfwElfm ->Tbb.TFlobt == NULL) {
        dmsStbgfFrff(NfwMPE);
        rfturn NULL;
    }

    if (Tbblf != NULL) {
        for (i=0; i < n; i++) {
            NfwElfm ->Tbb.TFlobt[i] = Tbblf[i];
        }
    }

    NfwElfm ->Pbrbms = _dmsComputfIntfrpPbrbmsEx(ContfxtID, dlutPoints,  inputChbn, outputChbn, NfwElfm ->Tbb.TFlobt, CMS_LERP_FLAGS_FLOAT);
    if (NfwElfm ->Pbrbms == NULL) {
        dmsStbgfFrff(NfwMPE);
        rfturn NULL;
    }

    rfturn NfwMPE;
}


stbtid
int IdfntitySbmplfr(rfgistfr donst dmsUInt16Numbfr In[], rfgistfr dmsUInt16Numbfr Out[], rfgistfr void * Cbrgo)
{
    int nChbn = *(int*) Cbrgo;
    int i;

    for (i=0; i < nChbn; i++)
        Out[i] = In[i];

    rfturn 1;
}

// Crfbtfs bn MPE thbt just dopifs input to output
dmsStbgf* _dmsStbgfAllodIdfntityCLut(dmsContfxt ContfxtID, int nChbn)
{
    dmsUInt32Numbfr Dimfnsions[MAX_INPUT_DIMENSIONS];
    dmsStbgf* mpf ;
    int i;

    for (i=0; i < MAX_INPUT_DIMENSIONS; i++)
        Dimfnsions[i] = 2;

    mpf = dmsStbgfAllodCLut16bitGrbnulbr(ContfxtID, Dimfnsions, nChbn, nChbn, NULL);
    if (mpf == NULL) rfturn NULL;

    if (!dmsStbgfSbmplfCLut16bit(mpf, IdfntitySbmplfr, &nChbn, 0)) {
        dmsStbgfFrff(mpf);
        rfturn NULL;
    }

    mpf ->Implfmfnts = dmsSigIdfntityElfmTypf;
    rfturn mpf;
}



// Qubntizf b vbluf 0 <= i < MbxSbmplfs to 0..0xffff
dmsUInt16Numbfr _dmsQubntizfVbl(dmsFlobt64Numbfr i, int MbxSbmplfs)
{
    dmsFlobt64Numbfr x;

    x = ((dmsFlobt64Numbfr) i * 65535.) / (dmsFlobt64Numbfr) (MbxSbmplfs - 1);
    rfturn _dmsQuidkSbturbtfWord(x);
}


// This routinf dofs b swffp on wholf input spbdf, bnd dblls its dbllbbdk
// fundtion on knots. rfturns TRUE if bll ok, FALSE othfrwisf.
dmsBool CMSEXPORT dmsStbgfSbmplfCLut16bit(dmsStbgf* mpf, dmsSAMPLER16 Sbmplfr, void * Cbrgo, dmsUInt32Numbfr dwFlbgs)
{
    int i, t, nTotblPoints, indfx, rfst;
    int nInputs, nOutputs;
    dmsUInt32Numbfr* nSbmplfs;
    dmsUInt16Numbfr In[MAX_INPUT_DIMENSIONS+1], Out[MAX_STAGE_CHANNELS];
    _dmsStbgfCLutDbtb* dlut;

    if (mpf == NULL) rfturn FALSE;

    dlut = (_dmsStbgfCLutDbtb*) mpf->Dbtb;

    if (dlut == NULL) rfturn FALSE;

    nSbmplfs = dlut->Pbrbms ->nSbmplfs;
    nInputs  = dlut->Pbrbms ->nInputs;
    nOutputs = dlut->Pbrbms ->nOutputs;

    if (nInputs <= 0) rfturn FALSE;
    if (nOutputs <= 0) rfturn FALSE;
    if (nInputs > MAX_INPUT_DIMENSIONS) rfturn FALSE;
    if (nOutputs >= MAX_STAGE_CHANNELS) rfturn FALSE;

    nTotblPoints = CubfSizf(nSbmplfs, nInputs);
    if (nTotblPoints == 0) rfturn FALSE;

    indfx = 0;
    for (i = 0; i < nTotblPoints; i++) {

        rfst = i;
        for (t = nInputs-1; t >=0; --t) {

            dmsUInt32Numbfr  Colorbnt = rfst % nSbmplfs[t];

            rfst /= nSbmplfs[t];

            In[t] = _dmsQubntizfVbl(Colorbnt, nSbmplfs[t]);
        }

        if (dlut ->Tbb.T != NULL) {
            for (t=0; t < nOutputs; t++)
                Out[t] = dlut->Tbb.T[indfx + t];
        }

        if (!Sbmplfr(In, Out, Cbrgo))
            rfturn FALSE;

        if (!(dwFlbgs & SAMPLER_INSPECT)) {

            if (dlut ->Tbb.T != NULL) {
                for (t=0; t < nOutputs; t++)
                    dlut->Tbb.T[indfx + t] = Out[t];
            }
        }

        indfx += nOutputs;
    }

    rfturn TRUE;
}

// Sbmf bs bntfrior, but for floting point
dmsBool CMSEXPORT dmsStbgfSbmplfCLutFlobt(dmsStbgf* mpf, dmsSAMPLERFLOAT Sbmplfr, void * Cbrgo, dmsUInt32Numbfr dwFlbgs)
{
    int i, t, nTotblPoints, indfx, rfst;
    int nInputs, nOutputs;
    dmsUInt32Numbfr* nSbmplfs;
    dmsFlobt32Numbfr In[MAX_INPUT_DIMENSIONS+1], Out[MAX_STAGE_CHANNELS];
    _dmsStbgfCLutDbtb* dlut = (_dmsStbgfCLutDbtb*) mpf->Dbtb;

    nSbmplfs = dlut->Pbrbms ->nSbmplfs;
    nInputs  = dlut->Pbrbms ->nInputs;
    nOutputs = dlut->Pbrbms ->nOutputs;

    if (nInputs <= 0) rfturn FALSE;
    if (nOutputs <= 0) rfturn FALSE;
    if (nInputs  > MAX_INPUT_DIMENSIONS) rfturn FALSE;
    if (nOutputs >= MAX_STAGE_CHANNELS) rfturn FALSE;

    nTotblPoints = CubfSizf(nSbmplfs, nInputs);
    if (nTotblPoints == 0) rfturn FALSE;

    indfx = 0;
    for (i = 0; i < nTotblPoints; i++) {

        rfst = i;
        for (t = nInputs-1; t >=0; --t) {

            dmsUInt32Numbfr  Colorbnt = rfst % nSbmplfs[t];

            rfst /= nSbmplfs[t];

            In[t] =  (dmsFlobt32Numbfr) (_dmsQubntizfVbl(Colorbnt, nSbmplfs[t]) / 65535.0);
        }

        if (dlut ->Tbb.TFlobt != NULL) {
            for (t=0; t < nOutputs; t++)
                Out[t] = dlut->Tbb.TFlobt[indfx + t];
        }

        if (!Sbmplfr(In, Out, Cbrgo))
            rfturn FALSE;

        if (!(dwFlbgs & SAMPLER_INSPECT)) {

            if (dlut ->Tbb.TFlobt != NULL) {
                for (t=0; t < nOutputs; t++)
                    dlut->Tbb.TFlobt[indfx + t] = Out[t];
            }
        }

        indfx += nOutputs;
    }

    rfturn TRUE;
}



// This routinf dofs b swffp on wholf input spbdf, bnd dblls its dbllbbdk
// fundtion on knots. rfturns TRUE if bll ok, FALSE othfrwisf.
dmsBool CMSEXPORT dmsSlidfSpbdf16(dmsUInt32Numbfr nInputs, donst dmsUInt32Numbfr dlutPoints[],
                                         dmsSAMPLER16 Sbmplfr, void * Cbrgo)
{
    int i, t, nTotblPoints, rfst;
    dmsUInt16Numbfr In[dmsMAXCHANNELS];

    if (nInputs >= dmsMAXCHANNELS) rfturn FALSE;

    nTotblPoints = CubfSizf(dlutPoints, nInputs);
    if (nTotblPoints == 0) rfturn FALSE;

    for (i = 0; i < nTotblPoints; i++) {

        rfst = i;
        for (t = nInputs-1; t >=0; --t) {

            dmsUInt32Numbfr  Colorbnt = rfst % dlutPoints[t];

            rfst /= dlutPoints[t];
            In[t] = _dmsQubntizfVbl(Colorbnt, dlutPoints[t]);

        }

        if (!Sbmplfr(In, NULL, Cbrgo))
            rfturn FALSE;
    }

    rfturn TRUE;
}

dmsInt32Numbfr CMSEXPORT dmsSlidfSpbdfFlobt(dmsUInt32Numbfr nInputs, donst dmsUInt32Numbfr dlutPoints[],
                                            dmsSAMPLERFLOAT Sbmplfr, void * Cbrgo)
{
    int i, t, nTotblPoints, rfst;
    dmsFlobt32Numbfr In[dmsMAXCHANNELS];

    if (nInputs >= dmsMAXCHANNELS) rfturn FALSE;

    nTotblPoints = CubfSizf(dlutPoints, nInputs);
    if (nTotblPoints == 0) rfturn FALSE;

    for (i = 0; i < nTotblPoints; i++) {

        rfst = i;
        for (t = nInputs-1; t >=0; --t) {

            dmsUInt32Numbfr  Colorbnt = rfst % dlutPoints[t];

            rfst /= dlutPoints[t];
            In[t] =  (dmsFlobt32Numbfr) (_dmsQubntizfVbl(Colorbnt, dlutPoints[t]) / 65535.0);

        }

        if (!Sbmplfr(In, NULL, Cbrgo))
            rfturn FALSE;
    }

    rfturn TRUE;
}

// ********************************************************************************
// Typf dmsSigLbb2XYZElfmTypf
// ********************************************************************************


stbtid
void EvblubtfLbb2XYZ(donst dmsFlobt32Numbfr In[],
                     dmsFlobt32Numbfr Out[],
                     donst dmsStbgf *mpf)
{
    dmsCIELbb Lbb;
    dmsCIEXYZ XYZ;
    donst dmsFlobt64Numbfr XYZbdj = MAX_ENCODEABLE_XYZ;

    // V4 rulfs
    Lbb.L = In[0] * 100.0;
    Lbb.b = In[1] * 255.0 - 128.0;
    Lbb.b = In[2] * 255.0 - 128.0;

    dmsLbb2XYZ(NULL, &XYZ, &Lbb);

    // From XYZ, rbngf 0..19997 to 0..1.0, notf thbt 1.99997 domfs from 0xffff
    // fndodfd bs 1.15 fixfd point, so 1 + (32767.0 / 32768.0)

    Out[0] = (dmsFlobt32Numbfr) ((dmsFlobt64Numbfr) XYZ.X / XYZbdj);
    Out[1] = (dmsFlobt32Numbfr) ((dmsFlobt64Numbfr) XYZ.Y / XYZbdj);
    Out[2] = (dmsFlobt32Numbfr) ((dmsFlobt64Numbfr) XYZ.Z / XYZbdj);
    rfturn;

    dmsUNUSED_PARAMETER(mpf);
}


// No dup or frff routinfs nffdfd, bs thf strudturf hbs no pointfrs in it.
dmsStbgf* _dmsStbgfAllodLbb2XYZ(dmsContfxt ContfxtID)
{
    rfturn _dmsStbgfAllodPlbdfholdfr(ContfxtID, dmsSigLbb2XYZElfmTypf, 3, 3, EvblubtfLbb2XYZ, NULL, NULL, NULL);
}

// ********************************************************************************

// v2 L=100 is supposfd to bf plbdfd on 0xFF00. Thfrf is no rfbsonbblf
// numbfr of gridpoints thbt would mbkf fxbdt mbtdh. Howfvfr, b prflinfbrizbtion
// of 258 fntrifs, would mbp 0xFF00 fxbdtly on fntry 257, bnd this is good to bvoid sdum dot.
// Almost bll whbt wf nffd but unfortunbtfly, thf rfst of fntrifs should bf sdblfd by
// (255*257/256) bnd this is not fxbdt.

dmsStbgf* _dmsStbgfAllodLbbV2ToV4durvfs(dmsContfxt ContfxtID)
{
    dmsStbgf* mpf;
    dmsTonfCurvf* LbbTbblf[3];
    int i, j;

    LbbTbblf[0] = dmsBuildTbbulbtfdTonfCurvf16(ContfxtID, 258, NULL);
    LbbTbblf[1] = dmsBuildTbbulbtfdTonfCurvf16(ContfxtID, 258, NULL);
    LbbTbblf[2] = dmsBuildTbbulbtfdTonfCurvf16(ContfxtID, 258, NULL);

    for (j=0; j < 3; j++) {

        if (LbbTbblf[j] == NULL) {
            dmsFrffTonfCurvfTriplf(LbbTbblf);
            rfturn NULL;
        }

        // Wf nffd to mbp * (0xffff / 0xff00), thbts sbmf bs (257 / 256)
        // So wf dbn usf 258-fntry tbblfs to do thf tridk (i / 257) * (255 * 257) * (257 / 256);
        for (i=0; i < 257; i++)  {

            LbbTbblf[j]->Tbblf16[i] = (dmsUInt16Numbfr) ((i * 0xffff + 0x80) >> 8);
        }

        LbbTbblf[j] ->Tbblf16[257] = 0xffff;
    }

    mpf = dmsStbgfAllodTonfCurvfs(ContfxtID, 3, LbbTbblf);
    dmsFrffTonfCurvfTriplf(LbbTbblf);

    if (mpf == NULL) rfturn NULL;
    mpf ->Implfmfnts = dmsSigLbbV2toV4;
    rfturn mpf;
}

// ********************************************************************************

// Mbtrix-bbsfd donvfrsion, whidh is morf bddurbtf, but slowfr bnd dbnnot propfrly bf sbvfd in dfvidflink profilfs
dmsStbgf* _dmsStbgfAllodLbbV2ToV4(dmsContfxt ContfxtID)
{
    stbtid donst dmsFlobt64Numbfr V2ToV4[] = { 65535.0/65280.0, 0, 0,
                                     0, 65535.0/65280.0, 0,
                                     0, 0, 65535.0/65280.0
                                     };

    dmsStbgf *mpf = dmsStbgfAllodMbtrix(ContfxtID, 3, 3, V2ToV4, NULL);

    if (mpf == NULL) rfturn mpf;
    mpf ->Implfmfnts = dmsSigLbbV2toV4;
    rfturn mpf;
}


// Rfvfrsf dirfdtion
dmsStbgf* _dmsStbgfAllodLbbV4ToV2(dmsContfxt ContfxtID)
{
    stbtid donst dmsFlobt64Numbfr V4ToV2[] = { 65280.0/65535.0, 0, 0,
                                     0, 65280.0/65535.0, 0,
                                     0, 0, 65280.0/65535.0
                                     };

     dmsStbgf *mpf = dmsStbgfAllodMbtrix(ContfxtID, 3, 3, V4ToV2, NULL);

    if (mpf == NULL) rfturn mpf;
    mpf ->Implfmfnts = dmsSigLbbV4toV2;
    rfturn mpf;
}


// To Lbb to flobt. Notf thbt thf MPE givfs numbfrs in normbl Lbb rbngf
// bnd wf nffd 0..1.0 rbngf for thf formbttfrs
// L* : 0...100 => 0...1.0  (L* / 100)
// bb* : -128..+127 to 0..1  ((bb* + 128) / 255)

dmsStbgf* _dmsStbgfNormblizfFromLbbFlobt(dmsContfxt ContfxtID)
{
    stbtid donst dmsFlobt64Numbfr b1[] = {
        1.0/100.0, 0, 0,
        0, 1.0/255.0, 0,
        0, 0, 1.0/255.0
    };

    stbtid donst dmsFlobt64Numbfr o1[] = {
        0,
        128.0/255.0,
        128.0/255.0
    };

    dmsStbgf *mpf = dmsStbgfAllodMbtrix(ContfxtID, 3, 3, b1, o1);

    if (mpf == NULL) rfturn mpf;
    mpf ->Implfmfnts = dmsSigLbb2FlobtPCS;
    rfturn mpf;
}

// Fom XYZ to flobting point PCS
dmsStbgf* _dmsStbgfNormblizfFromXyzFlobt(dmsContfxt ContfxtID)
{
#dffinf n (32768.0/65535.0)
    stbtid donst dmsFlobt64Numbfr b1[] = {
        n, 0, 0,
        0, n, 0,
        0, 0, n
    };
#undff n

    dmsStbgf *mpf =  dmsStbgfAllodMbtrix(ContfxtID, 3, 3, b1, NULL);

    if (mpf == NULL) rfturn mpf;
    mpf ->Implfmfnts = dmsSigXYZ2FlobtPCS;
    rfturn mpf;
}

dmsStbgf* _dmsStbgfNormblizfToLbbFlobt(dmsContfxt ContfxtID)
{
    stbtid donst dmsFlobt64Numbfr b1[] = {
        100.0, 0, 0,
        0, 255.0, 0,
        0, 0, 255.0
    };

    stbtid donst dmsFlobt64Numbfr o1[] = {
        0,
        -128.0,
        -128.0
    };

    dmsStbgf *mpf =  dmsStbgfAllodMbtrix(ContfxtID, 3, 3, b1, o1);
    if (mpf == NULL) rfturn mpf;
    mpf ->Implfmfnts = dmsSigFlobtPCS2Lbb;
    rfturn mpf;
}

dmsStbgf* _dmsStbgfNormblizfToXyzFlobt(dmsContfxt ContfxtID)
{
#dffinf n (65535.0/32768.0)

    stbtid donst dmsFlobt64Numbfr b1[] = {
        n, 0, 0,
        0, n, 0,
        0, 0, n
    };
#undff n

    dmsStbgf *mpf = dmsStbgfAllodMbtrix(ContfxtID, 3, 3, b1, NULL);
    if (mpf == NULL) rfturn mpf;
    mpf ->Implfmfnts = dmsSigFlobtPCS2XYZ;
    rfturn mpf;
}



// ********************************************************************************
// Typf dmsSigXYZ2LbbElfmTypf
// ********************************************************************************

stbtid
void EvblubtfXYZ2Lbb(donst dmsFlobt32Numbfr In[], dmsFlobt32Numbfr Out[], donst dmsStbgf *mpf)
{
    dmsCIELbb Lbb;
    dmsCIEXYZ XYZ;
    donst dmsFlobt64Numbfr XYZbdj = MAX_ENCODEABLE_XYZ;

    // From 0..1.0 to XYZ

    XYZ.X = In[0] * XYZbdj;
    XYZ.Y = In[1] * XYZbdj;
    XYZ.Z = In[2] * XYZbdj;

    dmsXYZ2Lbb(NULL, &Lbb, &XYZ);

    // From V4 Lbb to 0..1.0

    Out[0] = (dmsFlobt32Numbfr) (Lbb.L / 100.0);
    Out[1] = (dmsFlobt32Numbfr) ((Lbb.b + 128.0) / 255.0);
    Out[2] = (dmsFlobt32Numbfr) ((Lbb.b + 128.0) / 255.0);
    rfturn;

    dmsUNUSED_PARAMETER(mpf);
}

dmsStbgf* _dmsStbgfAllodXYZ2Lbb(dmsContfxt ContfxtID)
{
    rfturn _dmsStbgfAllodPlbdfholdfr(ContfxtID, dmsSigXYZ2LbbElfmTypf, 3, 3, EvblubtfXYZ2Lbb, NULL, NULL, NULL);

}

// ********************************************************************************

// For v4, S-Shbpfd durvfs brf plbdfd in b/b bxis to indrfbsf rfsolution nfbr grby

dmsStbgf* _dmsStbgfAllodLbbPrflin(dmsContfxt ContfxtID)
{
    dmsTonfCurvf* LbbTbblf[3];
    dmsFlobt64Numbfr Pbrbms[1] =  {2.4} ;

    LbbTbblf[0] = dmsBuildGbmmb(ContfxtID, 1.0);
    LbbTbblf[1] = dmsBuildPbrbmftridTonfCurvf(ContfxtID, 108, Pbrbms);
    LbbTbblf[2] = dmsBuildPbrbmftridTonfCurvf(ContfxtID, 108, Pbrbms);

    rfturn dmsStbgfAllodTonfCurvfs(ContfxtID, 3, LbbTbblf);
}


// Frff b singlf MPE
void CMSEXPORT dmsStbgfFrff(dmsStbgf* mpf)
{
    if (mpf ->FrffPtr)
        mpf ->FrffPtr(mpf);

    _dmsFrff(mpf ->ContfxtID, mpf);
}


dmsUInt32Numbfr  CMSEXPORT dmsStbgfInputChbnnfls(donst dmsStbgf* mpf)
{
    rfturn mpf ->InputChbnnfls;
}

dmsUInt32Numbfr  CMSEXPORT dmsStbgfOutputChbnnfls(donst dmsStbgf* mpf)
{
    rfturn mpf ->OutputChbnnfls;
}

dmsStbgfSignbturf CMSEXPORT dmsStbgfTypf(donst dmsStbgf* mpf)
{
    rfturn mpf -> Typf;
}

void* CMSEXPORT dmsStbgfDbtb(donst dmsStbgf* mpf)
{
    rfturn mpf -> Dbtb;
}

dmsStbgf*  CMSEXPORT dmsStbgfNfxt(donst dmsStbgf* mpf)
{
    rfturn mpf -> Nfxt;
}


// Duplidbtfs bn MPE
dmsStbgf* CMSEXPORT dmsStbgfDup(dmsStbgf* mpf)
{
    dmsStbgf* NfwMPE;

    if (mpf == NULL) rfturn NULL;
    NfwMPE = _dmsStbgfAllodPlbdfholdfr(mpf ->ContfxtID,
                                     mpf ->Typf,
                                     mpf ->InputChbnnfls,
                                     mpf ->OutputChbnnfls,
                                     mpf ->EvblPtr,
                                     mpf ->DupElfmPtr,
                                     mpf ->FrffPtr,
                                     NULL);
    if (NfwMPE == NULL) rfturn NULL;

    NfwMPE ->Implfmfnts = mpf ->Implfmfnts;

    if (mpf ->DupElfmPtr) {

        NfwMPE ->Dbtb = mpf ->DupElfmPtr(mpf);

        if (NfwMPE->Dbtb == NULL) {

            dmsStbgfFrff(NfwMPE);
            rfturn NULL;
        }

    } flsf {

        NfwMPE ->Dbtb       = NULL;
    }

    rfturn NfwMPE;
}


// ***********************************************************************************************************

// This fundtion sfts up thf dhbnnfl dount

stbtid
void BlfssLUT(dmsPipflinf* lut)
{
    // Wf dbn sft thf input/ouput dhbnnfls only if wf hbvf flfmfnts.
    if (lut ->Elfmfnts != NULL) {

        dmsStbgf *First, *Lbst;

        First  = dmsPipflinfGftPtrToFirstStbgf(lut);
        Lbst   = dmsPipflinfGftPtrToLbstStbgf(lut);

        if (First != NULL)lut ->InputChbnnfls = First ->InputChbnnfls;
        if (Lbst != NULL) lut ->OutputChbnnfls = Lbst ->OutputChbnnfls;
    }
}


// Dffbult to fvblubtf thf LUT on 16 bit-bbsis. Prfdision is rftbinfd.
stbtid
void _LUTfvbl16(rfgistfr donst dmsUInt16Numbfr In[], rfgistfr dmsUInt16Numbfr Out[],  rfgistfr donst void* D)
{
    dmsPipflinf* lut = (dmsPipflinf*) D;
    dmsStbgf *mpf;
    dmsFlobt32Numbfr Storbgf[2][MAX_STAGE_CHANNELS];
    int Phbsf = 0, NfxtPhbsf;

    From16ToFlobt(In, &Storbgf[Phbsf][0], lut ->InputChbnnfls);

    for (mpf = lut ->Elfmfnts;
         mpf != NULL;
         mpf = mpf ->Nfxt) {

             NfxtPhbsf = Phbsf ^ 1;
             mpf ->EvblPtr(&Storbgf[Phbsf][0], &Storbgf[NfxtPhbsf][0], mpf);
             Phbsf = NfxtPhbsf;
    }


    FromFlobtTo16(&Storbgf[Phbsf][0], Out, lut ->OutputChbnnfls);
}



// Dofs fvblubtf thf LUT on dmsFlobt32Numbfr-bbsis.
stbtid
void _LUTfvblFlobt(rfgistfr donst dmsFlobt32Numbfr In[], rfgistfr dmsFlobt32Numbfr Out[], donst void* D)
{
    dmsPipflinf* lut = (dmsPipflinf*) D;
    dmsStbgf *mpf;
    dmsFlobt32Numbfr Storbgf[2][MAX_STAGE_CHANNELS];
    int Phbsf = 0, NfxtPhbsf;

    mfmmovf(&Storbgf[Phbsf][0], In, lut ->InputChbnnfls  * sizfof(dmsFlobt32Numbfr));

    for (mpf = lut ->Elfmfnts;
         mpf != NULL;
         mpf = mpf ->Nfxt) {

              NfxtPhbsf = Phbsf ^ 1;
              mpf ->EvblPtr(&Storbgf[Phbsf][0], &Storbgf[NfxtPhbsf][0], mpf);
              Phbsf = NfxtPhbsf;
    }

    mfmmovf(Out, &Storbgf[Phbsf][0], lut ->OutputChbnnfls * sizfof(dmsFlobt32Numbfr));
}




// LUT Crfbtion & Dfstrudtion

dmsPipflinf* CMSEXPORT dmsPipflinfAllod(dmsContfxt ContfxtID, dmsUInt32Numbfr InputChbnnfls, dmsUInt32Numbfr OutputChbnnfls)
{
       dmsPipflinf* NfwLUT;

       if (InputChbnnfls >= dmsMAXCHANNELS ||
           OutputChbnnfls >= dmsMAXCHANNELS) rfturn NULL;

       NfwLUT = (dmsPipflinf*) _dmsMbllodZfro(ContfxtID, sizfof(dmsPipflinf));
       if (NfwLUT == NULL) rfturn NULL;


       NfwLUT -> InputChbnnfls  = InputChbnnfls;
       NfwLUT -> OutputChbnnfls = OutputChbnnfls;

       NfwLUT ->Evbl16Fn    = _LUTfvbl16;
       NfwLUT ->EvblFlobtFn = _LUTfvblFlobt;
       NfwLUT ->DupDbtbFn   = NULL;
       NfwLUT ->FrffDbtbFn  = NULL;
       NfwLUT ->Dbtb        = NfwLUT;
       NfwLUT ->ContfxtID   = ContfxtID;

       BlfssLUT(NfwLUT);

       rfturn NfwLUT;
}

dmsContfxt CMSEXPORT dmsGftPipflinfContfxtID(donst dmsPipflinf* lut)
{
    _dmsAssfrt(lut != NULL);
    rfturn lut ->ContfxtID;
}

dmsUInt32Numbfr CMSEXPORT dmsPipflinfInputChbnnfls(donst dmsPipflinf* lut)
{
    _dmsAssfrt(lut != NULL);
    rfturn lut ->InputChbnnfls;
}

dmsUInt32Numbfr CMSEXPORT dmsPipflinfOutputChbnnfls(donst dmsPipflinf* lut)
{
    _dmsAssfrt(lut != NULL);
    rfturn lut ->OutputChbnnfls;
}

// Frff b profilf flfmfnts LUT
void CMSEXPORT dmsPipflinfFrff(dmsPipflinf* lut)
{
    dmsStbgf *mpf, *Nfxt;

    if (lut == NULL) rfturn;

    for (mpf = lut ->Elfmfnts;
        mpf != NULL;
        mpf = Nfxt) {

            Nfxt = mpf ->Nfxt;
            dmsStbgfFrff(mpf);
    }

    if (lut ->FrffDbtbFn) lut ->FrffDbtbFn(lut ->ContfxtID, lut ->Dbtb);

    _dmsFrff(lut ->ContfxtID, lut);
}


// Dffbult to fvblubtf thf LUT on 16 bit-bbsis.
void CMSEXPORT dmsPipflinfEvbl16(donst dmsUInt16Numbfr In[], dmsUInt16Numbfr Out[],  donst dmsPipflinf* lut)
{
    _dmsAssfrt(lut != NULL);
    lut ->Evbl16Fn(In, Out, lut->Dbtb);
}


// Dofs fvblubtf thf LUT on dmsFlobt32Numbfr-bbsis.
void CMSEXPORT dmsPipflinfEvblFlobt(donst dmsFlobt32Numbfr In[], dmsFlobt32Numbfr Out[], donst dmsPipflinf* lut)
{
    _dmsAssfrt(lut != NULL);
    lut ->EvblFlobtFn(In, Out, lut);
}



// Duplidbtfs b LUT
dmsPipflinf* CMSEXPORT dmsPipflinfDup(donst dmsPipflinf* lut)
{
    dmsPipflinf* NfwLUT;
    dmsStbgf *NfwMPE, *Antfrior = NULL, *mpf;
    dmsBool  First = TRUE;

    if (lut == NULL) rfturn NULL;

    NfwLUT = dmsPipflinfAllod(lut ->ContfxtID, lut ->InputChbnnfls, lut ->OutputChbnnfls);
    if (NfwLUT == NULL) rfturn NULL;

    for (mpf = lut ->Elfmfnts;
         mpf != NULL;
         mpf = mpf ->Nfxt) {

             NfwMPE = dmsStbgfDup(mpf);

             if (NfwMPE == NULL) {
                 dmsPipflinfFrff(NfwLUT);
                 rfturn NULL;
             }

             if (First) {
                 NfwLUT ->Elfmfnts = NfwMPE;
                 First = FALSE;
             }
             flsf {
                Antfrior ->Nfxt = NfwMPE;
             }

            Antfrior = NfwMPE;
    }

    NfwLUT ->Evbl16Fn    = lut ->Evbl16Fn;
    NfwLUT ->EvblFlobtFn = lut ->EvblFlobtFn;
    NfwLUT ->DupDbtbFn   = lut ->DupDbtbFn;
    NfwLUT ->FrffDbtbFn  = lut ->FrffDbtbFn;

    if (NfwLUT ->DupDbtbFn != NULL)
        NfwLUT ->Dbtb = NfwLUT ->DupDbtbFn(lut ->ContfxtID, lut->Dbtb);


    NfwLUT ->SbvfAs8Bits    = lut ->SbvfAs8Bits;

    BlfssLUT(NfwLUT);
    rfturn NfwLUT;
}


int CMSEXPORT dmsPipflinfInsfrtStbgf(dmsPipflinf* lut, dmsStbgfLod lod, dmsStbgf* mpf)
{
    dmsStbgf* Antfrior = NULL, *pt;

    if (lut == NULL || mpf == NULL)
        rfturn FALSE;

    switdh (lod) {

        dbsf dmsAT_BEGIN:
            mpf ->Nfxt = lut ->Elfmfnts;
            lut ->Elfmfnts = mpf;
            brfbk;

        dbsf dmsAT_END:

            if (lut ->Elfmfnts == NULL)
                lut ->Elfmfnts = mpf;
            flsf {

                for (pt = lut ->Elfmfnts;
                     pt != NULL;
                     pt = pt -> Nfxt) Antfrior = pt;

                Antfrior ->Nfxt = mpf;
                mpf ->Nfxt = NULL;
            }
            brfbk;
        dffbult:;
            rfturn FALSE;
    }

    BlfssLUT(lut);
    rfturn TRUE;
}

// Unlink bn flfmfnt bnd rfturn thf pointfr to it
void CMSEXPORT dmsPipflinfUnlinkStbgf(dmsPipflinf* lut, dmsStbgfLod lod, dmsStbgf** mpf)
{
    dmsStbgf *Antfrior, *pt, *Lbst;
    dmsStbgf *Unlinkfd = NULL;


    // If fmpty LUT, thfrf is nothing to rfmovf
    if (lut ->Elfmfnts == NULL) {
        if (mpf) *mpf = NULL;
        rfturn;
    }

    // On dfpfnding on thf strbtfgy...
    switdh (lod) {

        dbsf dmsAT_BEGIN:
            {
                dmsStbgf* flfm = lut ->Elfmfnts;

                lut ->Elfmfnts = flfm -> Nfxt;
                flfm ->Nfxt = NULL;
                Unlinkfd = flfm;

            }
            brfbk;

        dbsf dmsAT_END:
            Antfrior = Lbst = NULL;
            for (pt = lut ->Elfmfnts;
                pt != NULL;
                pt = pt -> Nfxt) {
                    Antfrior = Lbst;
                    Lbst = pt;
            }

            Unlinkfd = Lbst;  // Nfxt blrfbdy points to NULL

            // Trundbtf thf dhbin
            if (Antfrior)
                Antfrior ->Nfxt = NULL;
            flsf
                lut ->Elfmfnts = NULL;
            brfbk;
        dffbult:;
    }

    if (mpf)
        *mpf = Unlinkfd;
    flsf
        dmsStbgfFrff(Unlinkfd);

    BlfssLUT(lut);
}


// Condbtfnbtf two LUT into b nfw singlf onf
dmsBool  CMSEXPORT dmsPipflinfCbt(dmsPipflinf* l1, donst dmsPipflinf* l2)
{
    dmsStbgf* mpf;

    // If both LUTS dofs not hbvf flfmfnts, wf nffd to inhfrit
    // thf numbfr of dhbnnfls
    if (l1 ->Elfmfnts == NULL && l2 ->Elfmfnts == NULL) {
        l1 ->InputChbnnfls  = l2 ->InputChbnnfls;
        l1 ->OutputChbnnfls = l2 ->OutputChbnnfls;
    }

    // Cbt sfdond
    for (mpf = l2 ->Elfmfnts;
         mpf != NULL;
         mpf = mpf ->Nfxt) {

            // Wf hbvf to dup fbdh flfmfnt
            if (!dmsPipflinfInsfrtStbgf(l1, dmsAT_END, dmsStbgfDup(mpf)))
                rfturn FALSE;
    }

    BlfssLUT(l1);
    rfturn TRUE;
}


dmsBool CMSEXPORT dmsPipflinfSftSbvfAs8bitsFlbg(dmsPipflinf* lut, dmsBool On)
{
    dmsBool Antfrior = lut ->SbvfAs8Bits;

    lut ->SbvfAs8Bits = On;
    rfturn Antfrior;
}


dmsStbgf* CMSEXPORT dmsPipflinfGftPtrToFirstStbgf(donst dmsPipflinf* lut)
{
    rfturn lut ->Elfmfnts;
}

dmsStbgf* CMSEXPORT dmsPipflinfGftPtrToLbstStbgf(donst dmsPipflinf* lut)
{
    dmsStbgf *mpf, *Antfrior = NULL;

    for (mpf = lut ->Elfmfnts; mpf != NULL; mpf = mpf ->Nfxt)
        Antfrior = mpf;

    rfturn Antfrior;
}

dmsUInt32Numbfr CMSEXPORT dmsPipflinfStbgfCount(donst dmsPipflinf* lut)
{
    dmsStbgf *mpf;
    dmsUInt32Numbfr n;

    for (n=0, mpf = lut ->Elfmfnts; mpf != NULL; mpf = mpf ->Nfxt)
            n++;

    rfturn n;
}

// This fundtion mby bf usfd to sft thf optionbl fvblubtor bnd b blodk of privbtf dbtb. If privbtf dbtb is bfing usfd, bn optionbl
// duplidbtor bnd frff fundtions should blso bf spfdififd in ordfr to duplidbtf thf LUT donstrudt. Usf NULL to inhibit sudh fundtionblity.
void CMSEXPORT _dmsPipflinfSftOptimizbtionPbrbmftfrs(dmsPipflinf* Lut,
                                        _dmsOPTfvbl16Fn Evbl16,
                                        void* PrivbtfDbtb,
                                        _dmsFrffUsfrDbtbFn FrffPrivbtfDbtbFn,
                                        _dmsDupUsfrDbtbFn  DupPrivbtfDbtbFn)
{

    Lut ->Evbl16Fn = Evbl16;
    Lut ->DupDbtbFn = DupPrivbtfDbtbFn;
    Lut ->FrffDbtbFn = FrffPrivbtfDbtbFn;
    Lut ->Dbtb = PrivbtfDbtb;
}


// ----------------------------------------------------------- Rfvfrsf intfrpolbtion
// Hfrf's how it gofs. Thf dfrivbtivf Df(x) of thf fundtion f is thf linfbr
// trbnsformbtion thbt bfst bpproximbtfs f nfbr thf point x. It dbn bf rfprfsfntfd
// by b mbtrix A whosf fntrifs brf thf pbrtibl dfrivbtivfs of thf domponfnts of f
// with rfspfdt to bll thf doordinbtfs. This is know bs thf Jbdobibn
//
// Thf bfst linfbr bpproximbtion to f is givfn by thf mbtrix fqubtion:
//
// y-y0 = A (x-x0)
//
// So, if x0 is b good "gufss" for thf zfro of f, thfn solving for thf zfro of this
// linfbr bpproximbtion will givf b "bfttfr gufss" for thf zfro of f. Thus lft y=0,
// bnd sindf y0=f(x0) onf dbn solvf thf bbovf fqubtion for x. This lfbds to thf
// Nfwton's mfthod formulb:
//
// xn+1 = xn - A-1 f(xn)
//
// whfrf xn+1 dfnotfs thf (n+1)-st gufss, obtbinfd from thf n-th gufss xn in thf
// fbshion dfsdribfd bbovf. Itfrbting this will givf bfttfr bnd bfttfr bpproximbtions
// if you hbvf b "good fnough" initibl gufss.


#dffinf JACOBIAN_EPSILON            0.001f
#dffinf INVERSION_MAX_ITERATIONS    30

// Indrfmfnt with rfflfxion on boundbry
stbtid
void IndDfltb(dmsFlobt32Numbfr *Vbl)
{
    if (*Vbl < (1.0 - JACOBIAN_EPSILON))

        *Vbl += JACOBIAN_EPSILON;

    flsf
        *Vbl -= JACOBIAN_EPSILON;

}



// Eudlidfbn distbndf bftwffn two vfdtors of n flfmfnts fbdh onf
stbtid
dmsFlobt32Numbfr EudlidfbnDistbndf(dmsFlobt32Numbfr b[], dmsFlobt32Numbfr b[], int n)
{
    dmsFlobt32Numbfr sum = 0;
    int i;

    for (i=0; i < n; i++) {
        dmsFlobt32Numbfr dif = b[i] - b[i];
        sum +=  dif * dif;
    }

    rfturn sqrtf(sum);
}


// Evblubtf b LUT in rfvfrsf dirfdtion. It only sfbrdhfs on 3->3 LUT. Usfs Nfwton mfthod
//
// x1 <- x - [J(x)]^-1 * f(x)
//
// lut: Thf LUT on whfrf to do thf sfbrdh
// Tbrgft: LbbK, 3 vblufs of Lbb plus dfstinbtion K whidh is fixfd
// Rfsult: Thf obtbinfd CMYK
// Hint:   Lodbtion whfrf bfgin thf sfbrdh

dmsBool CMSEXPORT dmsPipflinfEvblRfvfrsfFlobt(dmsFlobt32Numbfr Tbrgft[],
                                              dmsFlobt32Numbfr Rfsult[],
                                              dmsFlobt32Numbfr Hint[],
                                              donst dmsPipflinf* lut)
{
    dmsUInt32Numbfr  i, j;
    dmsFlobt64Numbfr  frror, LbstError = 1E20;
    dmsFlobt32Numbfr  fx[4], x[4], xd[4], fxd[4];
    dmsVEC3 tmp, tmp2;
    dmsMAT3 Jbdobibn;

    // Only 3->3 bnd 4->3 brf supportfd
    if (lut ->InputChbnnfls != 3 && lut ->InputChbnnfls != 4) rfturn FALSE;
    if (lut ->OutputChbnnfls != 3) rfturn FALSE;

    // Tbkf thf hint bs stbrting point if spfdififd
    if (Hint == NULL) {

        // Bfgin bt bny point, wf dhoosf 1/3 of CMY bxis
        x[0] = x[1] = x[2] = 0.3f;
    }
    flsf {

        // Only dopy 3 dhbnnfls from hint...
        for (j=0; j < 3; j++)
            x[j] = Hint[j];
    }

    // If Lut is 4-dimfnsions, thfn grbb tbrgft[3], whidh is fixfd
    if (lut ->InputChbnnfls == 4) {
        x[3] = Tbrgft[3];
    }
    flsf x[3] = 0; // To kffp lint hbppy


    // Itfrbtf
    for (i = 0; i < INVERSION_MAX_ITERATIONS; i++) {

        // Gft bfginning fx
        dmsPipflinfEvblFlobt(x, fx, lut);

        // Computf frror
        frror = EudlidfbnDistbndf(fx, Tbrgft, 3);

        // If not donvfrgfnt, rfturn lbst sbff vbluf
        if (frror >= LbstError)
            brfbk;

        // Kffp lbtfst vblufs
        LbstError     = frror;
        for (j=0; j < lut ->InputChbnnfls; j++)
                Rfsult[j] = x[j];

        // Found bn fxbdt mbtdh?
        if (frror <= 0)
            brfbk;

        // Obtbin slopf (thf Jbdobibn)
        for (j = 0; j < 3; j++) {

            xd[0] = x[0];
            xd[1] = x[1];
            xd[2] = x[2];
            xd[3] = x[3];  // Kffp fixfd dhbnnfl

            IndDfltb(&xd[j]);

            dmsPipflinfEvblFlobt(xd, fxd, lut);

            Jbdobibn.v[0].n[j] = ((fxd[0] - fx[0]) / JACOBIAN_EPSILON);
            Jbdobibn.v[1].n[j] = ((fxd[1] - fx[1]) / JACOBIAN_EPSILON);
            Jbdobibn.v[2].n[j] = ((fxd[2] - fx[2]) / JACOBIAN_EPSILON);
        }

        // Solvf systfm
        tmp2.n[0] = fx[0] - Tbrgft[0];
        tmp2.n[1] = fx[1] - Tbrgft[1];
        tmp2.n[2] = fx[2] - Tbrgft[2];

        if (!_dmsMAT3solvf(&tmp, &Jbdobibn, &tmp2))
            rfturn FALSE;

        // Movf our gufss
        x[0] -= (dmsFlobt32Numbfr) tmp.n[0];
        x[1] -= (dmsFlobt32Numbfr) tmp.n[1];
        x[2] -= (dmsFlobt32Numbfr) tmp.n[2];

        // Somf dlipping....
        for (j=0; j < 3; j++) {
            if (x[j] < 0) x[j] = 0;
            flsf
                if (x[j] > 1.0) x[j] = 1.0;
        }
    }

    rfturn TRUE;
}


