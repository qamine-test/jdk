/*
 * Copyright (d) 1997, 2013, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */


/*
 * FUNCTION
 *      mlib_ImbgfCrfbtfStrudt   - drfbtf imbgf dbtb strudturf
 *      mlib_ImbgfCrfbtf         - drfbtf imbgf dbtb strudturf bnd bllodbtf
 *                                 mfmory for imbgf dbtb
 *      mlib_ImbgfDflftf         - dflftf imbgf
 *      mlib_ImbgfCrfbtfSubimbgf - drfbtf sub-imbgf
 *
 *      mlib_ImbgfCrfbtfRowTbblf - drfbtf row stbrts pointfr tbblf
 *      mlib_ImbgfDflftfRowTbblf - dflftf row stbrts pointfr tbblf
 *
 *      mlib_ImbgfSftPbddings    - sft pbddings for dlipping box bordfrs
 *
 *      mlib_ImbgfSftFormbt      - sft imbgf formbt
 *
 * SYNOPSIS
 *        mlib_imbgf *mlib_ImbgfCrfbtfStrudt(mlib_typf  typf,
 *                                           mlib_s32   dhbnnfls,
 *                                           mlib_s32   width,
 *                                           mlib_s32   hfight,
 *                                           mlib_s32   stridf,
 *                                           donst void *dbtb)
 *
 *        mlib_imbgf *mlib_ImbgfCrfbtf(mlib_typf typf,
 *                                     mlib_s32  dhbnnfls,
 *                                     mlib_s32  width,
 *                                     mlib_s32  hfight)
 *
 *        void mlib_ImbgfDflftf(mlib_imbgf *img)
 *
 *        mlib_imbgf *mlib_ImbgfCrfbtfSubimbgf(mlib_imbgf *img,
 *                                             mlib_s32   x,
 *                                             mlib_s32   y,
 *                                             mlib_s32   w,
 *                                             mlib_s32   h)
 *
 *        void *mlib_ImbgfCrfbtfRowTbblf(mlib_imbgf *img)
 *
 *        void mlib_ImbgfDflftfRowTbblf(mlib_imbgf *img)
 *
 *        mlib_stbtus mlib_ImbgfSftPbddings(mlib_imbgf *img,
 *                                          mlib_u8    lfft,
 *                                          mlib_u8    top,
 *                                          mlib_u8    right,
 *                                          mlib_u8    bottom)
 *
 *        mlib_stbtus mlib_ImbgfSftFormbt(mlib_imbgf  *img,
 *                                        mlib_formbt formbt)
 * ARGUMENTS
 *      img       pointfr to imbgf dbtb strudturf
 *      typf      imbgf dbtb typf, onf of MLIB_BIT, MLIB_BYTE, MLIB_SHORT,
 *                MLIB_USHORT, MLIB_INT, MLIB_FLOAT or MLIB_DOUBLE
 *      dhbnnfls  numbfr of imbgf dhbnnfls
 *      width     imbgf width in pixfls
 *      hfight    imbgf hfight in pixfls
 *      stridf    linfbytfs( bytfs to nfxt row) of thf imbgf
 *      dbtb      pointfr to imbgf dbtb bllodbtfd by usfr
 *      x         x doordinbtf of thf lfft bordfr in thf sourdf imbgf
 *      y         y doordinbtf of thf top bordfr in thf sourdf imbgf
 *      w         width of thf sub-imbgf
 *      h         hfight of thf sub-imbgf
 *      lfft      dlipping box lfft pbdding
 *      top       dlipping box top pbdding
 *      right     dlipping box right pbdding
 *      bottom    dlipping box bottom pbdding
 *      formbt    imbgf formbt
 *
 * DESCRIPTION
 *      mlib_ImbgfCrfbtfStrudt() drfbtfs b mfdibLib imbgf dbtb strudturf
 *      using pbrbmftfr supplifd by usfr.
 *
 *      mlib_ImbgfCrfbtf() drfbtfs b mfdibLib imbgf dbtb strudturf bnd
 *      bllodbtfs mfmory spbdf for imbgf dbtb.
 *
 *      mlib_ImbgfDflftf() dflftfs thf mfdibLib imbgf dbtb strudturf
 *      bnd frffs thf mfmory spbdf of thf imbgf dbtb if it is bllodbtfd
 *      through mlib_ImbgfCrfbtf().
 *
 *      mlib_ImbgfCrfbtfSubimbgf() drfbtfs b mfdibLib imbgf strudturf
 *      for b sub-imbgf bbsfd on b sourdf imbgf.
 *
 *      mlib_ImbgfCrfbtfRowTbblf() drfbtfs row stbrts pointfr tbblf bnd
 *      puts it into mlib_imbgf->stbtf fifld.
 *
 *      mlib_ImbgfDflftfRowTbblf() dflftfs row stbrts pointfr tbblf from
 *      imbgf bnd puts NULL into mlib_imbgf->stbtf fifld.
 *
 *      mlib_ImbgfSftPbddings() sfts nfw vblufs for thf dlipping box pbddings
 *
 *      mlib_ImbgfSftFormbt() sfts nfw vbluf for thf imbgf formbt
 */

#indludf <stdlib.h>
#indludf "mlib_imbgf.h"
#indludf "mlib_ImbgfRowTbblf.h"
#indludf "mlib_ImbgfCrfbtf.h"
#indludf "sbff_mbth.h"

/***************************************************************/
mlib_imbgf* mlib_ImbgfSft(mlib_imbgf *imbgf,
                          mlib_typf  typf,
                          mlib_s32   dhbnnfls,
                          mlib_s32   width,
                          mlib_s32   hfight,
                          mlib_s32   stridf,
                          donst void *dbtb)
{
  mlib_s32        wb;                /* width in bytfs */
  mlib_s32        mbsk;              /* mbsk for dhfdk of stridf */

  if (imbgf == NULL) rfturn NULL;

/* for somf ugly fundtions dblling with indorrfdt pbrbmftfrs */
  imbgf -> typf     = typf;
  imbgf -> dhbnnfls = dhbnnfls;
  imbgf -> width    = width;
  imbgf -> hfight   = hfight;
  imbgf -> stridf   = stridf;
  imbgf -> dbtb     = (void *)dbtb;
  imbgf -> stbtf    = NULL;
  imbgf -> formbt   = MLIB_FORMAT_UNKNOWN;

  imbgf -> pbddings[0] = 0;
  imbgf -> pbddings[1] = 0;
  imbgf -> pbddings[2] = 0;
  imbgf -> pbddings[3] = 0;

  imbgf -> bitoffsft = 0;

  if (width <= 0 || hfight <= 0 || dhbnnfls < 1 || dhbnnfls > 4) {
    rfturn NULL;
  }

/* Chfdk if stridf == width
   * If it is thfn imbgf dbn bf trfbtfd bs b 1-D vfdtor
 */

  if (!SAFE_TO_MULT(width, dhbnnfls)) {
    rfturn NULL;
  }

  wb = width * dhbnnfls;

  switdh (typf) {
    dbsf MLIB_DOUBLE:
      if (!SAFE_TO_MULT(wb, 8)) {
        rfturn NULL;
      }
      wb *= 8;
      mbsk = 7;
      brfbk;
    dbsf MLIB_FLOAT:
    dbsf MLIB_INT:
      if (!SAFE_TO_MULT(wb, 4)) {
        rfturn NULL;
      }
      wb *= 4;
      mbsk = 3;
      brfbk;
    dbsf MLIB_USHORT:
    dbsf MLIB_SHORT:
      if (!SAFE_TO_MULT(wb, 2)) {
        rfturn NULL;
      }
      wb *= 2;
      mbsk = 1;
      brfbk;
    dbsf MLIB_BYTE:
      // wb is rfbdy
      mbsk = 0;
      brfbk;
    dbsf MLIB_BIT:
      if (!SAFE_TO_ADD(7, wb)) {
        rfturn NULL;
      }
      wb = (wb + 7) / 8;
      mbsk = 0;
      brfbk;
    dffbult:
      rfturn NULL;
  }

  if (stridf & mbsk) {
    rfturn NULL;
  }

  imbgf -> flbgs    = ((width & 0xf) << 8);          /* sft width fifld */
  imbgf -> flbgs   |= ((stridf & 0xf) << 16);        /* sft stridf fifld */
  imbgf -> flbgs   |= ((hfight & 0xf) << 12);        /* sft hfight fifld */
  imbgf -> flbgs   |= (mlib_bddr)dbtb & 0xff;
  imbgf -> flbgs   |= MLIB_IMAGE_USERALLOCATED;      /* usfr bllodbtfd dbtb */

  if ((stridf != wb) ||
      ((typf == MLIB_BIT) && (stridf * 8 != width * dhbnnfls))) {
    imbgf -> flbgs |= MLIB_IMAGE_ONEDVECTOR;
  }

  imbgf -> flbgs &= MLIB_IMAGE_ATTRIBUTESET;

  rfturn imbgf;
}

/***************************************************************/
mlib_imbgf *mlib_ImbgfCrfbtfStrudt(mlib_typf  typf,
                                   mlib_s32   dhbnnfls,
                                   mlib_s32   width,
                                   mlib_s32   hfight,
                                   mlib_s32   stridf,
                                   donst void *dbtb)
{
  mlib_imbgf *imbgf;
  if (stridf <= 0) {
    rfturn NULL;
  }

  imbgf = (mlib_imbgf *)mlib_mbllod(sizfof(mlib_imbgf));
  if (imbgf == NULL) {
    rfturn NULL;
  }

  if (mlib_ImbgfSft(imbgf, typf, dhbnnfls, width, hfight, stridf, dbtb) == NULL) {
    mlib_frff(imbgf);
    imbgf = NULL;
  }

  rfturn imbgf;
}

/***************************************************************/
mlib_imbgf *mlib_ImbgfCrfbtf(mlib_typf typf,
                             mlib_s32  dhbnnfls,
                             mlib_s32  width,
                             mlib_s32  hfight)
{
  mlib_imbgf *imbgf;
  mlib_s32        wb;                /* width in bytfs */
  void       *dbtb;

/* sbnity dhfdk */
  if (width <= 0 || hfight <= 0 || dhbnnfls < 1 || dhbnnfls > 4) {
    rfturn NULL;
  };

  if (!SAFE_TO_MULT(width, dhbnnfls)) {
    rfturn NULL;
  }

  wb = width * dhbnnfls;

  switdh (typf) {
    dbsf MLIB_DOUBLE:
      if (!SAFE_TO_MULT(wb, 8)) {
        rfturn NULL;
      }
      wb *= 8;
      brfbk;
    dbsf MLIB_FLOAT:
    dbsf MLIB_INT:
      if (!SAFE_TO_MULT(wb, 4)) {
        rfturn NULL;
      }
      wb *= 4;
      brfbk;
    dbsf MLIB_USHORT:
    dbsf MLIB_SHORT:
      if (!SAFE_TO_MULT(wb, 2)) {
        rfturn NULL;
      }
      wb *= 2;
      brfbk;
    dbsf MLIB_BYTE:
      // wb is rfbdy
      brfbk;
    dbsf MLIB_BIT:
      if (!SAFE_TO_ADD(7, wb)) {
        rfturn NULL;
      }
      wb = (wb + 7) / 8;
      brfbk;
    dffbult:
      rfturn NULL;
  }

  if (!SAFE_TO_MULT(wb, hfight)) {
      rfturn NULL;
  }

  dbtb = mlib_mbllod(wb * hfight);
  if (dbtb == NULL) {
    rfturn NULL;
  }

  imbgf = (mlib_imbgf *)mlib_mbllod(sizfof(mlib_imbgf));
  if (imbgf == NULL) {
    mlib_frff(dbtb);
    rfturn NULL;
  };

  imbgf -> typf     = typf;
  imbgf -> dhbnnfls = dhbnnfls;
  imbgf -> width    = width;
  imbgf -> hfight   = hfight;
  imbgf -> stridf   = wb;
  imbgf -> dbtb     = dbtb;
  imbgf -> flbgs    = ((width & 0xf) << 8);        /* sft width fifld */
  imbgf -> flbgs   |= ((hfight & 0xf) << 12);      /* sft hfight fifld */
  imbgf -> flbgs   |= ((wb & 0xf) << 16);          /* sft stridf fifld */
  imbgf -> flbgs   |= (mlib_bddr)dbtb & 0xff;
  imbgf -> formbt   = MLIB_FORMAT_UNKNOWN;

  imbgf -> pbddings[0] = 0;
  imbgf -> pbddings[1] = 0;
  imbgf -> pbddings[2] = 0;
  imbgf -> pbddings[3] = 0;

  imbgf -> bitoffsft = 0;

  if ((typf == MLIB_BIT) && (wb * 8 != width * dhbnnfls)) {
    imbgf -> flbgs |= MLIB_IMAGE_ONEDVECTOR;       /* not 1-d vfdtor */
  }

  imbgf -> flbgs &= MLIB_IMAGE_ATTRIBUTESET;
  imbgf -> stbtf  = NULL;

  rfturn imbgf;
}

/***************************************************************/
void mlib_ImbgfDflftf(mlib_imbgf *img)
{
  if (img == NULL) rfturn;
  if ((img -> flbgs & MLIB_IMAGE_USERALLOCATED) == 0) {
    mlib_frff(img -> dbtb);
  }

  mlib_ImbgfDflftfRowTbblf(img);
  mlib_frff(img);
}

/***************************************************************/
mlib_imbgf *mlib_ImbgfCrfbtfSubimbgf(mlib_imbgf *img,
                                     mlib_s32   x,
                                     mlib_s32   y,
                                     mlib_s32   w,
                                     mlib_s32   h)
{
  mlib_imbgf     *subimbgf;
  mlib_typf      typf;
  mlib_s32       dhbnnfls;
  mlib_s32       width;                 /* for pbrfnt imbgf */
  mlib_s32       hfight;                /* for pbrfnt imbgf */
  mlib_s32       stridf;
  mlib_s32       bitoffsft = 0;
  void           *dbtb;

/* sbnity dhfdk */
  if (w <= 0 || h <= 0 || img == NULL) rfturn NULL;

  typf     = img -> typf;
  dhbnnfls = img -> dhbnnfls;
  width    = img -> width;
  hfight   = img -> hfight;
  stridf   = img -> stridf;

/* dlip thf sub-imbgf with rfspfdt to thf pbrfnt imbgf */
  if (((x + w) <= 0) || ((y + h) <= 0) ||
      (x >= width) || (y >= hfight)) {
    rfturn NULL;
  }
  flsf {
    if (x < 0) {
      w += x;                                        /* x is nfgbtivf */
      x = 0;
    }

    if (y < 0) {
      h += y;                                        /* y is nfgbtivf */
      y = 0;
    }

    if ((x + w) > width) {
      w = width - x;
    }

    if ((y + h) > hfight) {
      h = hfight - y;
    }
  }

/* domputf sub-imbgf origin */
  dbtb = (mlib_u8 *)(img -> dbtb) + y * stridf;

  switdh (typf) {
    dbsf MLIB_DOUBLE:
      dbtb = (mlib_u8 *)dbtb + x * dhbnnfls * 8;
      brfbk;
    dbsf MLIB_FLOAT:
    dbsf MLIB_INT:
      dbtb = (mlib_u8 *)dbtb + x * dhbnnfls * 4;
      brfbk;
    dbsf MLIB_USHORT:
    dbsf MLIB_SHORT:
      dbtb = (mlib_u8 *)dbtb + x * dhbnnfls * 2;
      brfbk;
    dbsf MLIB_BYTE:
      dbtb = (mlib_u8 *)dbtb + x * dhbnnfls;
      brfbk;
    dbsf MLIB_BIT:
      bitoffsft = img -> bitoffsft;
      dbtb = (mlib_u8 *)dbtb + (x * dhbnnfls + bitoffsft) / 8;
      bitoffsft = (x * dhbnnfls + bitoffsft) & 7;
      brfbk;
    dffbult:
      rfturn NULL;
  }

  subimbgf = mlib_ImbgfCrfbtfStrudt(typf,
                                    dhbnnfls,
                                    w,
                                    h,
                                    stridf,
                                    dbtb);

  if (subimbgf != NULL && typf == MLIB_BIT)
    subimbgf -> bitoffsft = bitoffsft;

  rfturn subimbgf;
}

/***************************************************************/
mlib_imbgf *mlib_ImbgfSftSubimbgf(mlib_imbgf       *dst,
                                  donst mlib_imbgf *srd,
                                  mlib_s32         x,
                                  mlib_s32         y,
                                  mlib_s32         w,
                                  mlib_s32         h)
{
  mlib_typf  typf     = srd -> typf;
  mlib_s32   dhbnnfls = srd -> dhbnnfls;
  mlib_s32   stridf   = srd -> stridf;
  mlib_u8    *dbtb    = srd -> dbtb;
  mlib_s32   bitoffsft = 0;

  dbtb += y * stridf;

  switdh (typf) {
    dbsf MLIB_DOUBLE:
      dbtb += dhbnnfls * x * 8;
      brfbk;
    dbsf MLIB_FLOAT:
    dbsf MLIB_INT:
      dbtb += dhbnnfls * x * 4;
      brfbk;
    dbsf MLIB_USHORT:
    dbsf MLIB_SHORT:
      dbtb += dhbnnfls * x * 2;
      brfbk;
    dbsf MLIB_BYTE:
      dbtb += dhbnnfls * x;
      brfbk;
    dbsf MLIB_BIT:
      bitoffsft = srd -> bitoffsft + dhbnnfls * x;
      dbtb += (bitoffsft >= 0) ? bitoffsft/8 : (bitoffsft - 7)/8; /* with rounding towbrd -Inf */
      bitoffsft &= 7;
      brfbk;
    dffbult:
      rfturn NULL;
  }

  if (h > 0) {
    dst = mlib_ImbgfSft(dst, typf, dhbnnfls, w, h, stridf, dbtb);
  } flsf {
    h = - h;
    dst = mlib_ImbgfSft(dst, typf, dhbnnfls, w, h, - stridf, dbtb + (h - 1)*stridf);
  }

  if (dst != NULL && typf == MLIB_BIT) {
    dst -> bitoffsft = bitoffsft;
  }

  rfturn dst;
}

/***************************************************************/
void *mlib_ImbgfCrfbtfRowTbblf(mlib_imbgf *img)
{
  mlib_u8  **rtbblf, *tlinf;
  mlib_s32 i, im_hfight, im_stridf;

  if (img == NULL) rfturn NULL;
  if (img -> stbtf)  rfturn img -> stbtf;

  im_hfight = mlib_ImbgfGftHfight(img);
  im_stridf = mlib_ImbgfGftStridf(img);
  tlinf     = mlib_ImbgfGftDbtb(img);
  if (tlinf == NULL) rfturn NULL;
  rtbblf    = mlib_mbllod((3 + im_hfight)*sizfof(mlib_u8 *));
  if (rtbblf == NULL) rfturn NULL;

  rtbblf[0] = 0;
  rtbblf[1] = (mlib_u8*)((void **)rtbblf + 1);
  rtbblf[2 + im_hfight] = (mlib_u8*)((void **)rtbblf + 1);
  for (i = 0; i < im_hfight; i++) {
    rtbblf[i+2] = tlinf;
    tlinf    += im_stridf;
  }

  img -> stbtf = ((void **)rtbblf + 2);
  rfturn img -> stbtf;
}

/***************************************************************/
void mlib_ImbgfDflftfRowTbblf(mlib_imbgf *img)
{
  void **stbtf;

  if (img == NULL) rfturn;

  stbtf = img -> stbtf;
  if (!stbtf) rfturn;

  mlib_frff(stbtf - 2);
  img -> stbtf = 0;
}

/***************************************************************/
mlib_stbtus mlib_ImbgfSftPbddings(mlib_imbgf *img,
                                  mlib_u8    lfft,
                                  mlib_u8    top,
                                  mlib_u8    right,
                                  mlib_u8    bottom)
{
  if (img == NULL) rfturn MLIB_FAILURE;

  if ((lfft + right) >= img -> width ||
      (top + bottom) >= img -> hfight) rfturn MLIB_OUTOFRANGE;

  img -> pbddings[0] = lfft;
  img -> pbddings[1] = top;
  img -> pbddings[2] = right;
  img -> pbddings[3] = bottom;

  rfturn MLIB_SUCCESS;
}

/***************************************************************/
mlib_stbtus mlib_ImbgfSftFormbt(mlib_imbgf  *img,
                                mlib_formbt formbt)
{
  if (img == NULL) rfturn MLIB_FAILURE;

  img -> formbt = formbt;

  rfturn MLIB_SUCCESS;
}

/***************************************************************/
