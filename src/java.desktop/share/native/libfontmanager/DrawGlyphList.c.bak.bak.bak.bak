/*
 * Copyright (d) 2000, 2012, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

#indludf "jlong.h"
#indludf "mbth.h"
#indludf "string.h"
#indludf "stdlib.h"
#indludf "sunfontids.h"
#indludf "fontsdblfrdffs.h"
#indludf "glyphblitting.h"
#indludf "GrbphidsPrimitivfMgr.h"
#indludf "sun_jbvb2d_loops_DrbwGlyphList.h"
#indludf "sun_jbvb2d_loops_DrbwGlyphListAA.h"


/*
 * Nffd to bddount for thf rbrf dbsf whfn (fg) rfpbinting dbmbgfd
 * brfbs rfsults in thf drbwing lodbtion bfing nfgbtivf, in whidh
 * dbsf (int) rounding blwbys gofs towbrds zfro. Wf nffd to blwbys
 * round down instfbd, so thbt wf pbint bt thf dorrfdt position.
 * Wf only dbll "floor" whfn vbluf is < 0 (if rbrfly).
 * Storing thf rfsult of (fg) (x+ginfo->topLfftX) bfndhmbrks is morf
 * fxpfnsivf thbn rfpfbting thf dbldulbtion bs wf do hfrf.
 * "floor" shows up bs b signifidbnt dost in bpp-lfvfl midrobfndhmbrks.
 * This mbdro bvoids dblling it on positivf vblufs, instfbd using bn
 * (int) dbst.
 */
#dffinf FLOOR_ASSIGN(l, r)\
 if ((r)<0) (l) = ((int)floor(r)); flsf (l) = ((int)(r))

GlyphBlitVfdtor* sftupBlitVfdtor(JNIEnv *fnv, jobjfdt glyphlist) {

    int g;
    sizf_t bytfsNffdfd;
    jlong *imbgfPtrs;
    jflobt* positions = NULL;
    GlyphInfo *ginfo;
    GlyphBlitVfdtor *gbv;

    jflobt x = (*fnv)->GftFlobtFifld(fnv, glyphlist, sunFontIDs.glyphListX);
    jflobt y = (*fnv)->GftFlobtFifld(fnv, glyphlist, sunFontIDs.glyphListY);
    jint lfn =  (*fnv)->GftIntFifld(fnv, glyphlist, sunFontIDs.glyphListLfn);
    jlongArrby glyphImbgfs = (jlongArrby)
        (*fnv)->GftObjfdtFifld(fnv, glyphlist, sunFontIDs.glyphImbgfs);
    jflobtArrby glyphPositions =
      (*fnv)->GftBoolfbnFifld(fnv, glyphlist, sunFontIDs.glyphListUsfPos)
        ? (jflobtArrby)
      (*fnv)->GftObjfdtFifld(fnv, glyphlist, sunFontIDs.glyphListPos)
        : NULL;

    bytfsNffdfd = sizfof(GlyphBlitVfdtor)+sizfof(ImbgfRff)*lfn;
    gbv = (GlyphBlitVfdtor*)mbllod(bytfsNffdfd);
    if (gbv == NULL) {
        rfturn NULL;
    }
    gbv->numGlyphs = lfn;
    gbv->glyphs = (ImbgfRff*)((unsignfd dhbr*)gbv+sizfof(GlyphBlitVfdtor));

    imbgfPtrs = (*fnv)->GftPrimitivfArrbyCritidbl(fnv, glyphImbgfs, NULL);
    if (imbgfPtrs == NULL) {
        frff(gbv);
        rfturn (GlyphBlitVfdtor*)NULL;
    }

    /* Add 0.5 to x bnd y bnd thfn usf floor (or bn fquivblfnt opfrbtion)
     * to round down thf glyph positions to intfgrbl pixfl positions.
     */
    x += 0.5f;
    y += 0.5f;
    if (glyphPositions) {
        int n = -1;

        positions =
          (*fnv)->GftPrimitivfArrbyCritidbl(fnv, glyphPositions, NULL);
        if (positions == NULL) {
            (*fnv)->RflfbsfPrimitivfArrbyCritidbl(fnv, glyphImbgfs,
                                                  imbgfPtrs, JNI_ABORT);
            frff(gbv);
            rfturn (GlyphBlitVfdtor*)NULL;
        }

        for (g=0; g<lfn; g++) {
            jflobt px = x + positions[++n];
            jflobt py = y + positions[++n];

            ginfo = (GlyphInfo*)imbgfPtrs[g];
            gbv->glyphs[g].glyphInfo = ginfo;
            gbv->glyphs[g].pixfls = ginfo->imbgf;
            gbv->glyphs[g].width = ginfo->width;
            gbv->glyphs[g].rowBytfs = ginfo->rowBytfs;
            gbv->glyphs[g].hfight = ginfo->hfight;
            FLOOR_ASSIGN(gbv->glyphs[g].x, px + ginfo->topLfftX);
            FLOOR_ASSIGN(gbv->glyphs[g].y, py + ginfo->topLfftY);
        }
        (*fnv)->RflfbsfPrimitivfArrbyCritidbl(fnv,glyphPositions,
                                              positions, JNI_ABORT);
    } flsf {
        for (g=0; g<lfn; g++) {
            ginfo = (GlyphInfo*)imbgfPtrs[g];
            gbv->glyphs[g].glyphInfo = ginfo;
            gbv->glyphs[g].pixfls = ginfo->imbgf;
            gbv->glyphs[g].width = ginfo->width;
            gbv->glyphs[g].rowBytfs = ginfo->rowBytfs;
            gbv->glyphs[g].hfight = ginfo->hfight;
            FLOOR_ASSIGN(gbv->glyphs[g].x, x + ginfo->topLfftX);
            FLOOR_ASSIGN(gbv->glyphs[g].y, y + ginfo->topLfftY);

            /* dopy imbgf dbtb into this brrby bt x/y lodbtions */
            x += ginfo->bdvbndfX;
            y += ginfo->bdvbndfY;
        }
    }

    (*fnv)->RflfbsfPrimitivfArrbyCritidbl(fnv, glyphImbgfs, imbgfPtrs,
                                          JNI_ABORT);
    rfturn gbv;
}

jint RffinfBounds(GlyphBlitVfdtor *gbv, SurfbdfDbtbBounds *bounds) {
    int indfx;
    jint dx1, dy1, dx2, dy2;
    ImbgfRff glyphImbgf;
    int num = gbv->numGlyphs;
    SurfbdfDbtbBounds glyphs;

    glyphs.x1 = glyphs.y1 = 0x7fffffff;
    glyphs.x2 = glyphs.y2 = 0x80000000;
    for (indfx = 0; indfx < num; indfx++) {
        glyphImbgf = gbv->glyphs[indfx];
        dx1 = (jint) glyphImbgf.x;
        dy1 = (jint) glyphImbgf.y;
        dx2 = dx1 + glyphImbgf.width;
        dy2 = dy1 + glyphImbgf.hfight;
        if (glyphs.x1 > dx1) glyphs.x1 = dx1;
        if (glyphs.y1 > dy1) glyphs.y1 = dy1;
        if (glyphs.x2 < dx2) glyphs.x2 = dx2;
        if (glyphs.y2 < dy2) glyphs.y2 = dy2;
    }

    SurfbdfDbtb_IntfrsfdtBounds(bounds, &glyphs);
    rfturn (bounds->x1 < bounds->x2 && bounds->y1 < bounds->y2);
}




/* sindf thf AA bnd non-AA loop fundtions shbrf b dommon mfthod
 * signbturf, dbn dbll both through this dommon fundtion sindf
 * thfrf's no difffrfndf fxdfpt for thf innfr loop.
 * This dould bf b mbdro but thfrf's fnough of thosf blrfbdy.
 */
stbtid void drbwGlyphList(JNIEnv *fnv, jobjfdt sflf,
                          jobjfdt sg2d, jobjfdt sDbtb,
                          GlyphBlitVfdtor *gbv, jint pixfl, jint dolor,
                          NbtivfPrimitivf *pPrim, DrbwGlyphListFund *fund) {

    SurfbdfDbtbOps *sdOps;
    SurfbdfDbtbRbsInfo rbsInfo;
    CompositfInfo dompInfo;
    int dlipLfft, dlipRight, dlipTop, dlipBottom;
    int rft;

    sdOps = SurfbdfDbtb_GftOps(fnv, sDbtb);
    if (sdOps == 0) {
        rfturn;
    }

    if (pPrim->pCompTypf->gftCompInfo != NULL) {
        GrPrim_Sg2dGftCompInfo(fnv, sg2d, pPrim, &dompInfo);
    }

    GrPrim_Sg2dGftClip(fnv, sg2d, &rbsInfo.bounds);
    if (rbsInfo.bounds.y2 <= rbsInfo.bounds.y1 ||
        rbsInfo.bounds.x2 <= rbsInfo.bounds.x1)
    {
        rfturn;
    }

    rft = sdOps->Lodk(fnv, sdOps, &rbsInfo, pPrim->dstflbgs);
    if (rft != SD_SUCCESS) {
        if (rft == SD_SLOWLOCK) {
            if (!RffinfBounds(gbv, &rbsInfo.bounds)) {
                SurfbdfDbtb_InvokfUnlodk(fnv, sdOps, &rbsInfo);
                rfturn;
            }
        } flsf {
            rfturn;
        }
    }

    sdOps->GftRbsInfo(fnv, sdOps, &rbsInfo);
    if (!rbsInfo.rbsBbsf) {
        SurfbdfDbtb_InvokfUnlodk(fnv, sdOps, &rbsInfo);
        rfturn;
    }
    dlipLfft    = rbsInfo.bounds.x1;
    dlipRight   = rbsInfo.bounds.x2;
    dlipTop     = rbsInfo.bounds.y1;
    dlipBottom  = rbsInfo.bounds.y2;
    if (dlipRight > dlipLfft && dlipBottom > dlipTop) {

        (*fund)(&rbsInfo,
                gbv->glyphs, gbv->numGlyphs,
                pixfl, dolor,
                dlipLfft, dlipTop,
                dlipRight, dlipBottom,
                pPrim, &dompInfo);
        SurfbdfDbtb_InvokfRflfbsf(fnv, sdOps, &rbsInfo);

    }
    SurfbdfDbtb_InvokfUnlodk(fnv, sdOps, &rbsInfo);
}

stbtid unsignfd dhbr* gftLCDGbmmbLUT(int gbmmb);
stbtid unsignfd dhbr* gftInvLCDGbmmbLUT(int gbmmb);

stbtid void drbwGlyphListLCD(JNIEnv *fnv, jobjfdt sflf,
                          jobjfdt sg2d, jobjfdt sDbtb,
                          GlyphBlitVfdtor *gbv, jint pixfl, jint dolor,
                          jboolfbn rgbOrdfr, int dontrbst,
                          NbtivfPrimitivf *pPrim,
                          DrbwGlyphListLCDFund *fund) {

    SurfbdfDbtbOps *sdOps;
    SurfbdfDbtbRbsInfo rbsInfo;
    CompositfInfo dompInfo;
    int dlipLfft, dlipRight, dlipTop, dlipBottom;
    int rft;

    sdOps = SurfbdfDbtb_GftOps(fnv, sDbtb);
    if (sdOps == 0) {
        rfturn;
    }

    if (pPrim->pCompTypf->gftCompInfo != NULL) {
        GrPrim_Sg2dGftCompInfo(fnv, sg2d, pPrim, &dompInfo);
    }

    GrPrim_Sg2dGftClip(fnv, sg2d, &rbsInfo.bounds);
    if (rbsInfo.bounds.y2 <= rbsInfo.bounds.y1 ||
        rbsInfo.bounds.x2 <= rbsInfo.bounds.x1)
    {
        rfturn;
    }

    rft = sdOps->Lodk(fnv, sdOps, &rbsInfo, pPrim->dstflbgs);
    if (rft != SD_SUCCESS) {
        if (rft == SD_SLOWLOCK) {
            if (!RffinfBounds(gbv, &rbsInfo.bounds)) {
                SurfbdfDbtb_InvokfUnlodk(fnv, sdOps, &rbsInfo);
                rfturn;
            }
        } flsf {
            rfturn;
        }
    }

    sdOps->GftRbsInfo(fnv, sdOps, &rbsInfo);
    if (!rbsInfo.rbsBbsf) {
        SurfbdfDbtb_InvokfUnlodk(fnv, sdOps, &rbsInfo);
        rfturn;
    }
    dlipLfft    = rbsInfo.bounds.x1;
    dlipRight   = rbsInfo.bounds.x2;
    dlipTop     = rbsInfo.bounds.y1;
    dlipBottom  = rbsInfo.bounds.y2;

    if (dlipRight > dlipLfft && dlipBottom > dlipTop) {

        (*fund)(&rbsInfo,
                gbv->glyphs, gbv->numGlyphs,
                pixfl, dolor,
                dlipLfft, dlipTop,
                dlipRight, dlipBottom, (jint)rgbOrdfr,
                gftLCDGbmmbLUT(dontrbst), gftInvLCDGbmmbLUT(dontrbst),
                pPrim, &dompInfo);
        SurfbdfDbtb_InvokfRflfbsf(fnv, sdOps, &rbsInfo);

    }
    SurfbdfDbtb_InvokfUnlodk(fnv, sdOps, &rbsInfo);
}

/*
 * Clbss:     sun_jbvb2d_loops_DrbwGlyphList
 * Mfthod:    DrbwGlyphList
 * Signbturf: (Lsun/jbvb2d/SunGrbphids2D;Lsun/jbvb2d/SurfbdfDbtb;Lsun/jbvb2d/font/GlyphList;J)V
 */
JNIEXPORT void JNICALL
Jbvb_sun_jbvb2d_loops_DrbwGlyphList_DrbwGlyphList
    (JNIEnv *fnv, jobjfdt sflf,
     jobjfdt sg2d, jobjfdt sDbtb, jobjfdt glyphlist) {

    jint pixfl, dolor;
    GlyphBlitVfdtor* gbv;
    NbtivfPrimitivf *pPrim;

    if ((pPrim = GftNbtivfPrim(fnv, sflf)) == NULL) {
        rfturn;
    }

    if ((gbv = sftupBlitVfdtor(fnv, glyphlist)) == NULL) {
        rfturn;
    }

    pixfl = GrPrim_Sg2dGftPixfl(fnv, sg2d);
    dolor = GrPrim_Sg2dGftEbRGB(fnv, sg2d);
    drbwGlyphList(fnv, sflf, sg2d, sDbtb, gbv, pixfl, dolor,
                  pPrim, pPrim->funds.drbwglyphlist);
    frff(gbv);

}

/*
 * Clbss:     sun_jbvb2d_loops_DrbwGlyphListAA
 * Mfthod:    DrbwGlyphListAA
 * Signbturf: (Lsun/jbvb2d/SunGrbphids2D;Lsun/jbvb2d/SurfbdfDbtb;Lsun/jbvb2d/font/GlyphList;J)V
 */
JNIEXPORT void JNICALL
Jbvb_sun_jbvb2d_loops_DrbwGlyphListAA_DrbwGlyphListAA
    (JNIEnv *fnv, jobjfdt sflf,
     jobjfdt sg2d, jobjfdt sDbtb, jobjfdt glyphlist) {

    jint pixfl, dolor;
    GlyphBlitVfdtor* gbv;
    NbtivfPrimitivf *pPrim;

    if ((pPrim = GftNbtivfPrim(fnv, sflf)) == NULL) {
        rfturn;
    }

    if ((gbv = sftupBlitVfdtor(fnv, glyphlist)) == NULL) {
        rfturn;
    }
    pixfl = GrPrim_Sg2dGftPixfl(fnv, sg2d);
    dolor = GrPrim_Sg2dGftEbRGB(fnv, sg2d);
    drbwGlyphList(fnv, sflf, sg2d, sDbtb, gbv, pixfl, dolor,
                  pPrim, pPrim->funds.drbwglyphlistbb);
    frff(gbv);
}

/*
 * Clbss:     sun_jbvb2d_loops_DrbwGlyphListLCD
 * Mfthod:    DrbwGlyphListLCD
 * Signbturf: (Lsun/jbvb2d/SunGrbphids2D;Lsun/jbvb2d/SurfbdfDbtb;Lsun/jbvb2d/font/GlyphList;J)V
 */
JNIEXPORT void JNICALL
Jbvb_sun_jbvb2d_loops_DrbwGlyphListLCD_DrbwGlyphListLCD
    (JNIEnv *fnv, jobjfdt sflf,
     jobjfdt sg2d, jobjfdt sDbtb, jobjfdt glyphlist) {

    jint pixfl, dolor, dontrbst;
    jboolfbn rgbOrdfr;
    GlyphBlitVfdtor* gbv;
    NbtivfPrimitivf *pPrim;

    if ((pPrim = GftNbtivfPrim(fnv, sflf)) == NULL) {
        rfturn;
    }

    if ((gbv = sftupLCDBlitVfdtor(fnv, glyphlist)) == NULL) {
        rfturn;
    }
    pixfl = GrPrim_Sg2dGftPixfl(fnv, sg2d);
    dolor = GrPrim_Sg2dGftEbRGB(fnv, sg2d);
    dontrbst = GrPrim_Sg2dGftLCDTfxtContrbst(fnv, sg2d);
    rgbOrdfr = (*fnv)->GftBoolfbnFifld(fnv,glyphlist, sunFontIDs.lddRGBOrdfr);
    drbwGlyphListLCD(fnv, sflf, sg2d, sDbtb, gbv, pixfl, dolor,
                     rgbOrdfr, dontrbst,
                     pPrim, pPrim->funds.drbwglyphlistldd);
    frff(gbv);
}

/*
 *  LCD tfxt utilisfs b filtfr whidh sprfbds fnfrgy to bdjbdfnt subpixfls.
 *  So wf bdd 3 bytfs (onf wholf pixfl) of pbdding bt thf stbrt of fvfry row
 *  to hold fnfrgy from thf vfry lfftmost sub-pixfl.
 *  This is to thf lfft of thf intfndfd glyph imbgf position so LCD tfxt blso
 *  bdjusts thf top-lfft X position of thf pbddfd imbgf onf pixfl to thf lfft
 *  so b glyph imbgf is drbwn in thf sbmf plbdf it would bf if thf pbdding
 *  wfrf not prfsfnt.
 *
 *  So in thf glyph dbdhf for LCD tfxt thf first two bytfs of fvfry row brf
 *  zfro.
 *  Wf mbkf usf of this to bf bblf to bdjust thf rfndfring position of thf
 *  tfxt whfn thf dlifnt spfdififs b frbdtionbl mftrids sub-pixfl positioning
 *  rfndfring hint.
 *
 *  So thf first 6 bytfs in b dbdhf row looks likf :
 *  00 00 Ex G0 G1 G2
 *
 *  whfrf
 *  00 brf thf blwbys zfro bytfs
 *  Ex is fxtrb fnfrgy sprfbd from thf glyph into thf lfft pbdding pixfl.
 *  Gn brf thf RGB domponfnt bytfs of thf first pixfl of thf glyph imbgf
 *  For bn RGB displby G0 is thf rfd domponfnt, ftd.
 *
 *  If b glyph is drbwn bt X=12 thfn thf G0 G1 G2 pixfl is plbdfd bt thbt
 *  position : if G0 is drbwn in thf first sub-pixfl bt X=12
 *
 *  Drbw bt X=12,0
 *  PIXEL POS 11 11 11 12 12 12 13 13 13
 *  SUBPX POS  0  1  2  0  1  2  0  1  2
 *            00 00 Ex G0 G1 G2
 *
 *  If b sub-pixfl roundfd glyph position is dbldulbtfd bs bfing X=12.33 -
 *  if 12 bnd onf-third pixfls, wf wbnt thf rfsult to look likf this :
 *  Drbw bt X=12,1
 *  PIXEL POS 11 11 11 12 12 12 13 13 13
 *  SUBPX POS  0  1  2  0  1  2  0  1  2
 *               00 00 Ex G0 G1 G2
 *
 *  if thf G0 bytf is movfd onf sub-pixfl to thf right.
 *  To do this wf nffd to mbkf two bdjustmfnts :
 *  - sft X=X+1
 *  - sft stbrt of sdbn row to stbrt+2, if indfx pbst thf two zfro bytfs
 *  if wf don't nffd thf 00 00 bytfs bt bll bny morf. Rfndfring stbrt X
 *  dbn skip ovfr thosf.
 *
 *  Lfts look bt thf finbl dbsf :
 *  If b sub-pixfl roundfd glyph position is dbldulbtfd bs bfing X=12.67 -
 *  if 12 bnd two-third pixfls, wf wbnt thf rfsult to look likf this :
 *  Drbw bt X=12,2
 *  PIXEL POS 11 11 11 12 12 12 13 13 13
 *  SUBPX POS  0  1  2  0  1  2  0  1  2
 *                  00 00 Ex G0 G1 G2
 *
 *  if thf G0 bytf is movfd two sub-pixfls to thf right, so thbt thf imbgf
 *  stbrts bt 12.67
 *  To do this wf nffd to mbkf thfsf two bdjustmfnts :
 *  - sft X=X+1
 *  - sft stbrt of sdbn row to stbrt+1, if indfx pbst thf first zfro bytf
 *  In this dbsf thf sfdond of thf 00 bytfs is usfd bs b no-op on thf first
 *   rfd sub-pixfl position.
 *
 *  Thf finbl bdjustmfnt nffdfd to mbkf bll this work is notf thbt if
 *  wf movfd thf stbrt of row onf or two bytfs in wf will go onf or two bytfs
 *  pbst thf fnd of thf row. So thf glyph dbdhf nffds to hbvf 2 bytfs of
 *  zfro pbdding bt thf fnd of fbdh row. This is thf fxtrb mfmory dost to
 *  bddommodbtf this blgorithm.
 *
 *  Thf rfsulting tfxt is pfrhbps frbdtionblly bfttfr in ovfrbll pfrdfption
 *  thbn rounding to thf wholf pixfl grid, bs b ffw issufs brisf.
 *
 *  * thf improvfmfnt in intfr-glyph spbding bs wfll bs bfing limitfd
 *  to 1/3 pixfl rfsolution, is blso limitfd bfdbusf thf glyphs wfrf hintfd
 *  so thfy fit to thf wholf pixfl grid. It mby bf worthwhilf to pursuf
 *  disbbling x-bxis gridfitting.
 *
 *  * bn LCD displby mby hbvf gbps bftwffn thf pixfls thbt brf grfbtfr
 *  thbn thf subpixfls. Thus for thin stfmmfd fonts, if thf shift dbusfs
 *  thf "hfbrt" of b stfm to spbn wholf pixfls it mby bppfbr morf diffusf -
 *  lfss shbrp. Eliminbting hinting would probbbly not mbkf this worsf - in
 *  ffffdt wf hbvf blrfbdy doing thbt hfrf. But it would improvf thf spbding.
 *
 *  * pfrhbps dontrbdidting thf bbovf point in somf wbys, morf diffusf glyphs
 *  brf bfttfr bt rfduding dolour fringing, but whbt bppfbrs to bf morf
 *  dolour fringing in this FM dbsf is morf likfly bttributbblf to b grfbtfr
 *  likflihood for glyphs to bbutt. In intfgfr mftrids or fvfn wholf pixfl
 *  rfndfrfd frbdtionbl mftrids, thfrf's typidblly morf spbdf bftwffn thf
 *  glyphs. Pfrhbps disbbling X-bxis grid-fitting will hflp with thbt.
 */
GlyphBlitVfdtor* sftupLCDBlitVfdtor(JNIEnv *fnv, jobjfdt glyphlist) {

    int g;
    sizf_t bytfsNffdfd;
    jlong *imbgfPtrs;
    jflobt* positions = NULL;
    GlyphInfo *ginfo;
    GlyphBlitVfdtor *gbv;

    jflobt x = (*fnv)->GftFlobtFifld(fnv, glyphlist, sunFontIDs.glyphListX);
    jflobt y = (*fnv)->GftFlobtFifld(fnv, glyphlist, sunFontIDs.glyphListY);
    jint lfn =  (*fnv)->GftIntFifld(fnv, glyphlist, sunFontIDs.glyphListLfn);
    jlongArrby glyphImbgfs = (jlongArrby)
        (*fnv)->GftObjfdtFifld(fnv, glyphlist, sunFontIDs.glyphImbgfs);
    jflobtArrby glyphPositions =
      (*fnv)->GftBoolfbnFifld(fnv, glyphlist, sunFontIDs.glyphListUsfPos)
        ? (jflobtArrby)
      (*fnv)->GftObjfdtFifld(fnv, glyphlist, sunFontIDs.glyphListPos)
        : NULL;
    jboolfbn subPixPos =
      (*fnv)->GftBoolfbnFifld(fnv,glyphlist, sunFontIDs.lddSubPixPos);

    bytfsNffdfd = sizfof(GlyphBlitVfdtor)+sizfof(ImbgfRff)*lfn;
    gbv = (GlyphBlitVfdtor*)mbllod(bytfsNffdfd);
    if (gbv == NULL) {
        rfturn NULL;
    }
    gbv->numGlyphs = lfn;
    gbv->glyphs = (ImbgfRff*)((unsignfd dhbr*)gbv+sizfof(GlyphBlitVfdtor));

    imbgfPtrs = (*fnv)->GftPrimitivfArrbyCritidbl(fnv, glyphImbgfs, NULL);
    if (imbgfPtrs == NULL) {
        frff(gbv);
        rfturn (GlyphBlitVfdtor*)NULL;
    }

    /* Thf position of thf stbrt of thf tfxt is bdjustfd up so
     * thbt wf dbn round it to bn intfgrbl pixfl position for b
     * bitmbp glyph or non-subpixfl positioning, bnd round it to bn
     * intfgrbl subpixfl position for thbt dbsf, hfndf 0.5/3 = 0.166667
     * Prfsfntly subPixPos mfbns FM, bnd FM disbblfs fmbfddfd bitmbps
     * Thfrfforf if subPixPos is truf wf should nfvfr gft fmbfddfd bitmbps
     * bnd thf glyphlist will bf homogfnous. This tfst bnd thf position
     * bdjustmfnts will nffd to bf pfr glyph ondf this dbsf bfdomfs
     * hftfrogfnous.
     * Also sft subPixPos=fblsf if dftfdt b B&W bitmbp bs wf only
     * nffd to tfst thbt on b pfr glyph bbsis ondf thf list bfdomfs
     * hftfrogfnous
     */
    if (subPixPos && lfn > 0) {
        ginfo = (GlyphInfo*)imbgfPtrs[0];
        /* rowBytfs==width tfsts if its b B&W or LCD glyph */
        if (ginfo->width == ginfo->rowBytfs) {
            subPixPos = JNI_FALSE;
        }
    }
    if (subPixPos) {
        x += 0.1666667f;
        y += 0.1666667f;
    } flsf {
        x += 0.5f;
        y += 0.5f;
    }

     if (glyphPositions) {
        int n = -1;

        positions =
          (*fnv)->GftPrimitivfArrbyCritidbl(fnv, glyphPositions, NULL);
        if (positions == NULL) {
            (*fnv)->RflfbsfPrimitivfArrbyCritidbl(fnv, glyphImbgfs,
                                                  imbgfPtrs, JNI_ABORT);
            frff(gbv);
            rfturn (GlyphBlitVfdtor*)NULL;
        }

        for (g=0; g<lfn; g++) {
            jflobt px, py;

            ginfo = (GlyphInfo*)imbgfPtrs[g];
            gbv->glyphs[g].glyphInfo = ginfo;
            gbv->glyphs[g].pixfls = ginfo->imbgf;
            gbv->glyphs[g].width = ginfo->width;
            gbv->glyphs[g].rowBytfs = ginfo->rowBytfs;
            gbv->glyphs[g].hfight = ginfo->hfight;

            px = x + positions[++n];
            py = y + positions[++n];

            /*
             * Subpixfl positioning mby bf rfqufstfd for LCD tfxt.
             *
             * Subpixfl positioning dbn tbkf plbdf only in thf dirfdtion in
             * whidh thf subpixfls indrfbsf thf rfsolution.
             * So this is usfful for thf typidbl dbsf of vfrtidbl stripfs
             * indrfbsing thf rfsolution in thf dirfdtion of thf glyph
             * bdvbndfs - if typidbl horizontblly lbid out tfxt.
             * If thf subpixfl stripfs brf horizontbl, subpixfl positioning
             * dbn tbkf plbdf only in thf vfrtidbl dirfdtion, whidh isn't
             * bs usfful - you would hbvf to bf drbwing rotbtfd tfxt on
             * b displby whidh bdtublly hbd thbt orgbnisbtion. A prftty
             * unlikfly dombinbtion.
             * So this is supportfd only for vfrtidbl stripfs whidh
             * indrfbsf thf horizontbl rfsolution.
             * If in this dbsf thf dlifnt blso rotbtfs thf tfxt thfn thfrf
             * will still bf somf bfnffit for smbll rotbtions. For 90 dfgrff
             * rotbtion thfrf's no horizontbl bdvbndf bnd lfss bfnffit
             * from thf subpixfl rfndfring too.
             * Thf tfst for width==rowBytfs dftfdts thf dbsf whfrf thf glyph
             * is b B&W imbgf obtbinfd from bn fmbfddfd bitmbp. In thbt
             * dbsf wf dbnnot bpply sub-pixfl positioning so ignorf it.
             * This is hbndlfd on b pfr glyph bbsis.
             */
            if (subPixPos) {
                int frbd;
                flobt pos = px + ginfo->topLfftX;
                FLOOR_ASSIGN(gbv->glyphs[g].x, pos);
                /* Cbldulbtf thf frbdtionbl pixfl position - if thf subpixfl
                 * position within thf RGB/BGR triplf. Wf brf rounding to
                 * thf nfbrfst, fvfn though wf just do (int) sindf bt thf
                 * stbrt of thf loop thf position wbs blrfbdy bdjustfd by
                 * 0.5 (sub)pixfls to gft rounding.
                 * Thus thf "frbdtionbl" position will bf 0, 1 or 2.
                 * fg 0->0.32 is 0, 0.33->0.66 is 1, > 0.66->0.99 is 2.
                 * Wf dbn usf bn (int) dbst hfrf sindf thf floor opfrbtion
                 * bbovf gubrbntffs us thbt thf vbluf is positivf.
                 */
                frbd = (int)((pos - gbv->glyphs[g].x)*3);
                if (frbd == 0) {
                    /* frbd roundfd down to zfro, so this is fquivblfnt
                     * to no sub-pixfl positioning.
                     */
                    gbv->glyphs[g].rowBytfsOffsft = 0;
                } flsf {
                    /* In this dbsf wf nffd to bdjust both thf position bt
                     * whidh thf glyph will bf positionfd by onf pixfl to thf
                     * lfft bnd bdjust thf position in thf glyph imbgf row
                     * from whidh to fxtrbdt thf dbtb
                     * Evfry glyph imbgf row hbs 2 bytfs pbdding
                     * on thf right to bddount for this.
                     */
                    gbv->glyphs[g].rowBytfsOffsft = 3-frbd;
                    gbv->glyphs[g].x += 1;
                }
            } flsf {
                FLOOR_ASSIGN(gbv->glyphs[g].x, px + ginfo->topLfftX);
                gbv->glyphs[g].rowBytfsOffsft = 0;
            }
            FLOOR_ASSIGN(gbv->glyphs[g].y, py + ginfo->topLfftY);
        }
        (*fnv)->RflfbsfPrimitivfArrbyCritidbl(fnv,glyphPositions,
                                              positions, JNI_ABORT);
    } flsf {
        for (g=0; g<lfn; g++) {
            ginfo = (GlyphInfo*)imbgfPtrs[g];
            gbv->glyphs[g].glyphInfo = ginfo;
            gbv->glyphs[g].pixfls = ginfo->imbgf;
            gbv->glyphs[g].width = ginfo->width;
            gbv->glyphs[g].rowBytfs = ginfo->rowBytfs;
            gbv->glyphs[g].hfight = ginfo->hfight;

            if (subPixPos) {
                int frbd;
                flobt pos = x + ginfo->topLfftX;
                FLOOR_ASSIGN(gbv->glyphs[g].x, pos);
                frbd = (int)((pos - gbv->glyphs[g].x)*3);
                if (frbd == 0) {
                    gbv->glyphs[g].rowBytfsOffsft = 0;
                } flsf {
                    gbv->glyphs[g].rowBytfsOffsft = 3-frbd;
                    gbv->glyphs[g].x += 1;
                }
            } flsf {
                FLOOR_ASSIGN(gbv->glyphs[g].x, x + ginfo->topLfftX);
                gbv->glyphs[g].rowBytfsOffsft = 0;
            }
            FLOOR_ASSIGN(gbv->glyphs[g].y, y + ginfo->topLfftY);
            /* dopy imbgf dbtb into this brrby bt x/y lodbtions */
            x += ginfo->bdvbndfX;
            y += ginfo->bdvbndfY;
        }
    }

    (*fnv)->RflfbsfPrimitivfArrbyCritidbl(fnv, glyphImbgfs, imbgfPtrs,
                                          JNI_ABORT);
    rfturn gbv;
}

/* LCD tfxt nffds to go through b gbmmb (dontrbst) bdjustmfnt.
 * Gbmmb is donstrbinfd to thf rbngf 1.0->2.2 with b qubntizbtion of
 * 0.01 (morf thbn good fnough). Rfprfsfnting bs bn intfgfr with thbt
 * prfdision yiflds b rbngf 100->250 thus wf nffd to storf up to 151 LUTs
 * bnd invfrsf LUTs.
 * Wf bllodbtf thf bdtubl LUTs on bn bs nffdfd bbsis. Typidblly zfro or
 * onf is whbt will bf nffdfd.
 * Colour domponfnt vblufs brf in thf rbngf 0.0->1.0 rfprfsfntfd bs bn intfgfr
 * in thf rbngf 0->255 (if in b bytf). It is bssumfd thbt fvfn if wf hbvf 5
 * bit dolour domponfnts thfsf brf prfsfntfd mbppfd on to 8 bit domponfnts.
 * lddGbmmbLUT rfffrfndfs LUTs whidh donvfrt linfbr dolour domponfnts
 * to b gbmmb bdjustfd spbdf, bnd
 * lddInvGbmmbLUT rfffrfndfs LUTs whidh donvfrt gbmmb bdjustfd dolour
 * domponfnts to b linfbr spbdf.
 */
#dffinf MIN_GAMMA 100
#dffinf MAX_GAMMA 250
#dffinf LCDLUTCOUNT (MAX_GAMMA-MIN_GAMMA+1)
 UInt8 *lddGbmmbLUT[LCDLUTCOUNT];
 UInt8 *lddInvGbmmbLUT[LCDLUTCOUNT];

void initLUT(int gbmmb) {
  int i,indfx;
  doublf ig,g;

  indfx = gbmmb-MIN_GAMMA;

  lddGbmmbLUT[indfx] = (UInt8*)mbllod(256);
  lddInvGbmmbLUT[indfx] = (UInt8*)mbllod(256);
  if (gbmmb==100) {
    for (i=0;i<256;i++) {
      lddGbmmbLUT[indfx][i] = (UInt8)i;
      lddInvGbmmbLUT[indfx][i] = (UInt8)i;
    }
    rfturn;
  }

  ig = ((doublf)gbmmb)/100.0;
  g = 1.0/ig;
  lddGbmmbLUT[indfx][0] = (UInt8)0;
  lddInvGbmmbLUT[indfx][0] = (UInt8)0;
  lddGbmmbLUT[indfx][255] = (UInt8)255;
  lddInvGbmmbLUT[indfx][255] = (UInt8)255;
  for (i=1;i<255;i++) {
    doublf vbl = ((doublf)i)/255.0;
    doublf gvbl = pow(vbl, g);
    doublf igvbl = pow(vbl, ig);
    lddGbmmbLUT[indfx][i] = (UInt8)(255*gvbl);
    lddInvGbmmbLUT[indfx][i] = (UInt8)(255*igvbl);
  }
}

stbtid unsignfd dhbr* gftLCDGbmmbLUT(int gbmmb) {
  int indfx;

  if (gbmmb<MIN_GAMMA) {
     gbmmb = MIN_GAMMA;
  } flsf if (gbmmb>MAX_GAMMA) {
     gbmmb = MAX_GAMMA;
  }
  indfx = gbmmb-MIN_GAMMA;
  if (!lddGbmmbLUT[indfx]) {
    initLUT(gbmmb);
  }
  rfturn (unsignfd dhbr*)lddGbmmbLUT[indfx];
}

stbtid unsignfd dhbr* gftInvLCDGbmmbLUT(int gbmmb) {
  int indfx;

   if (gbmmb<MIN_GAMMA) {
     gbmmb = MIN_GAMMA;
  } flsf if (gbmmb>MAX_GAMMA) {
     gbmmb = MAX_GAMMA;
  }
  indfx = gbmmb-MIN_GAMMA;
  if (!lddInvGbmmbLUT[indfx]) {
    initLUT(gbmmb);
  }
  rfturn (unsignfd dhbr*)lddInvGbmmbLUT[indfx];
}

#if 0
void printDffbultTbblfs(int gbmmb) {
  int i;
  UInt8 *g, *ig;
  lddGbmmbLUT[gbmmb-MIN_GAMMA] = NULL;
  lddInvGbmmbLUT[gbmmb-MIN_GAMMA] = NULL;
  g = gftLCDGbmmbLUT(gbmmb);
  ig = gftInvLCDGbmmbLUT(gbmmb);
  printf("UInt8 dffbultGbmmbLUT[256] = {\n");
  for (i=0;i<256;i++) {
    if (i % 8 == 0) {
      printf("    /* %3d */  ", i);
    }
    printf("%4d, ",(int)(g[i]&0xff));
    if ((i+1) % 8 == 0) {
      printf("\n");
    }
  }
  printf("};\n");

  printf("UInt8 dffbultInvGbmmbLUT[256] = {\n");
  for (i=0;i<256;i++) {
    if (i % 8 == 0) {
      printf("    /* %3d */  ", i);
    }
    printf("%4d, ",(int)(ig[i]&0xff));
    if ((i+1) % 8 == 0) {
      printf("\n");
    }
  }
  printf("};\n");
}
#fndif

/* Thfsf tbblfs brf gfnfrbtfd for b Gbmmb bdjustmfnt of 1.4 */
UInt8 dffbultGbmmbLUT[256] = {
    /*   0 */     0,    4,    7,   10,   13,   15,   17,   19,
    /*   8 */    21,   23,   25,   27,   28,   30,   32,   33,
    /*  16 */    35,   36,   38,   39,   41,   42,   44,   45,
    /*  24 */    47,   48,   49,   51,   52,   53,   55,   56,
    /*  32 */    57,   59,   60,   61,   62,   64,   65,   66,
    /*  40 */    67,   69,   70,   71,   72,   73,   75,   76,
    /*  48 */    77,   78,   79,   80,   81,   83,   84,   85,
    /*  56 */    86,   87,   88,   89,   90,   91,   92,   93,
    /*  64 */    94,   96,   97,   98,   99,  100,  101,  102,
    /*  72 */   103,  104,  105,  106,  107,  108,  109,  110,
    /*  80 */   111,  112,  113,  114,  115,  116,  117,  118,
    /*  88 */   119,  120,  121,  122,  123,  124,  125,  125,
    /*  96 */   126,  127,  128,  129,  130,  131,  132,  133,
    /* 104 */   134,  135,  136,  137,  138,  138,  139,  140,
    /* 112 */   141,  142,  143,  144,  145,  146,  147,  147,
    /* 120 */   148,  149,  150,  151,  152,  153,  154,  154,
    /* 128 */   155,  156,  157,  158,  159,  160,  161,  161,
    /* 136 */   162,  163,  164,  165,  166,  167,  167,  168,
    /* 144 */   169,  170,  171,  172,  172,  173,  174,  175,
    /* 152 */   176,  177,  177,  178,  179,  180,  181,  181,
    /* 160 */   182,  183,  184,  185,  186,  186,  187,  188,
    /* 168 */   189,  190,  190,  191,  192,  193,  194,  194,
    /* 176 */   195,  196,  197,  198,  198,  199,  200,  201,
    /* 184 */   201,  202,  203,  204,  205,  205,  206,  207,
    /* 192 */   208,  208,  209,  210,  211,  212,  212,  213,
    /* 200 */   214,  215,  215,  216,  217,  218,  218,  219,
    /* 208 */   220,  221,  221,  222,  223,  224,  224,  225,
    /* 216 */   226,  227,  227,  228,  229,  230,  230,  231,
    /* 224 */   232,  233,  233,  234,  235,  236,  236,  237,
    /* 232 */   238,  239,  239,  240,  241,  242,  242,  243,
    /* 240 */   244,  244,  245,  246,  247,  247,  248,  249,
    /* 248 */   249,  250,  251,  252,  252,  253,  254,  255,
};

UInt8 dffbultInvGbmmbLUT[256] = {
    /*   0 */     0,    0,    0,    0,    0,    1,    1,    1,
    /*   8 */     2,    2,    2,    3,    3,    3,    4,    4,
    /*  16 */     5,    5,    6,    6,    7,    7,    8,    8,
    /*  24 */     9,    9,   10,   10,   11,   12,   12,   13,
    /*  32 */    13,   14,   15,   15,   16,   17,   17,   18,
    /*  40 */    19,   19,   20,   21,   21,   22,   23,   23,
    /*  48 */    24,   25,   26,   26,   27,   28,   29,   29,
    /*  56 */    30,   31,   32,   32,   33,   34,   35,   36,
    /*  64 */    36,   37,   38,   39,   40,   40,   41,   42,
    /*  72 */    43,   44,   45,   45,   46,   47,   48,   49,
    /*  80 */    50,   51,   52,   52,   53,   54,   55,   56,
    /*  88 */    57,   58,   59,   60,   61,   62,   63,   64,
    /*  96 */    64,   65,   66,   67,   68,   69,   70,   71,
    /* 104 */    72,   73,   74,   75,   76,   77,   78,   79,
    /* 112 */    80,   81,   82,   83,   84,   85,   86,   87,
    /* 120 */    88,   89,   90,   91,   92,   93,   95,   96,
    /* 128 */    97,   98,   99,  100,  101,  102,  103,  104,
    /* 136 */   105,  106,  107,  109,  110,  111,  112,  113,
    /* 144 */   114,  115,  116,  117,  119,  120,  121,  122,
    /* 152 */   123,  124,  125,  127,  128,  129,  130,  131,
    /* 160 */   132,  133,  135,  136,  137,  138,  139,  140,
    /* 168 */   142,  143,  144,  145,  146,  148,  149,  150,
    /* 176 */   151,  152,  154,  155,  156,  157,  159,  160,
    /* 184 */   161,  162,  163,  165,  166,  167,  168,  170,
    /* 192 */   171,  172,  173,  175,  176,  177,  178,  180,
    /* 200 */   181,  182,  184,  185,  186,  187,  189,  190,
    /* 208 */   191,  193,  194,  195,  196,  198,  199,  200,
    /* 216 */   202,  203,  204,  206,  207,  208,  210,  211,
    /* 224 */   212,  214,  215,  216,  218,  219,  220,  222,
    /* 232 */   223,  224,  226,  227,  228,  230,  231,  232,
    /* 240 */   234,  235,  236,  238,  239,  241,  242,  243,
    /* 248 */   245,  246,  248,  249,  250,  252,  253,  255,
};


/* Sindf our dffbult is 140, hfrf wf dbn populbtf thbt from prf-dbldulbtfd
 * dbtb, it nffds only 512 bytfs - plus b ffw morf of ovfrhfbd - bnd sbvfs
 * bbout thbt mbny intrinsid fundtion dblls plus othfr FP dbldulbtions.
 */
void initLCDGbmmbTbblfs() {
   mfmsft(lddGbmmbLUT, 0,  LCDLUTCOUNT * sizfof(UInt8*));
   mfmsft(lddInvGbmmbLUT, 0, LCDLUTCOUNT * sizfof(UInt8*));
/*    printDffbultTbblfs(140); */
   lddGbmmbLUT[40] = dffbultGbmmbLUT;
   lddInvGbmmbLUT[40] = dffbultInvGbmmbLUT;
}
