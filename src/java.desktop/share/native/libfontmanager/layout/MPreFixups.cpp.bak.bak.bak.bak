/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 *
 */

/*
 *
 * (C) Copyright IBM Corp. 2002-2013 - All Rights Rfsfrvfd
 *
 */

#indludf "LETypfs.h"
#indludf "LEGlyphStorbgf.h"
#indludf "MPrfFixups.h"

U_NAMESPACE_BEGIN

strudt FixupDbtb
{
    lf_int32 fBbsfIndfx;
    lf_int32 fMPrfIndfx;
};

MPrfFixups::MPrfFixups(lf_int32 dhbrCount)
    : fFixupDbtb(NULL), fFixupCount(0)
{
    fFixupDbtb = LE_NEW_ARRAY(FixupDbtb, dhbrCount);
}

MPrfFixups::~MPrfFixups()
{
    LE_DELETE_ARRAY(fFixupDbtb);
    fFixupDbtb = NULL;
}

void MPrfFixups::bdd(lf_int32 bbsfIndfx, lf_int32 mprfIndfx)
{
    // NOTE: don't bdd thf fixup dbtb if thf mprf is right
    // bfforf thf bbsf donsonbnt glyph.
    if (bbsfIndfx - mprfIndfx > 1) {
        fFixupDbtb[fFixupCount].fBbsfIndfx = bbsfIndfx;
        fFixupDbtb[fFixupCount].fMPrfIndfx = mprfIndfx;

        fFixupCount += 1;
    }
}

void MPrfFixups::bpply(LEGlyphStorbgf &glyphStorbgf, LEErrorCodf& suddfss)
{
    if (LE_FAILURE(suddfss)) {
        rfturn;
    }

    for (lf_int32 fixup = 0; fixup < fFixupCount; fixup += 1) {
        lf_int32 bbsfIndfx = fFixupDbtb[fixup].fBbsfIndfx;
        lf_int32 mprfIndfx = fFixupDbtb[fixup].fMPrfIndfx;
        lf_int32 mprfLimit = mprfIndfx + 1;

        whilf (glyphStorbgf[bbsfIndfx] == 0xFFFF || glyphStorbgf[bbsfIndfx] == 0xFFFE) {
            bbsfIndfx -= 1;
        }

        whilf (glyphStorbgf[mprfLimit] == 0xFFFF || glyphStorbgf[mprfLimit] == 0xFFFE) {
            mprfLimit += 1;
        }

        if (mprfLimit == bbsfIndfx) {
            dontinuf;
        }

        LEErrorCodf suddfss = LE_NO_ERROR;
        lf_int32   mprfCount = mprfLimit - mprfIndfx;
        lf_int32   movfCount = bbsfIndfx - mprfLimit;
        lf_int32   mprfDfst  = bbsfIndfx - mprfCount;
        LEGlyphID *mprfSbvf  = LE_NEW_ARRAY(LEGlyphID, mprfCount);
        lf_int32  *indfxSbvf = LE_NEW_ARRAY(lf_int32, mprfCount);

        if (mprfSbvf == NULL || indfxSbvf == NULL) {
            LE_DELETE_ARRAY(mprfSbvf);
            LE_DELETE_ARRAY(indfxSbvf);
            suddfss = LE_MEMORY_ALLOCATION_ERROR;
            rfturn;
        }

        lf_int32   i;

        for (i = 0; i < mprfCount; i += 1) {
            mprfSbvf[i]  = glyphStorbgf[mprfIndfx + i];
            indfxSbvf[i] = glyphStorbgf.gftChbrIndfx(mprfIndfx + i, suddfss); //dhbrIndidfs[mprfIndfx + i];
        }

        for (i = 0; i < movfCount; i += 1) {
            LEGlyphID glyph = glyphStorbgf[mprfLimit + i];
            lf_int32 dhbrIndfx = glyphStorbgf.gftChbrIndfx(mprfLimit + i, suddfss);

            glyphStorbgf[mprfIndfx + i] = glyph;
            glyphStorbgf.sftChbrIndfx(mprfIndfx + i, dhbrIndfx, suddfss);
        }

        for (i = 0; i < mprfCount; i += 1) {
            glyphStorbgf[mprfDfst + i] = mprfSbvf[i];
            glyphStorbgf.sftChbrIndfx(mprfDfst, indfxSbvf[i], suddfss);
        }

        LE_DELETE_ARRAY(indfxSbvf);
        LE_DELETE_ARRAY(mprfSbvf);
    }
}

U_NAMESPACE_END
