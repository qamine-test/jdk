/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 *
 */

/*
 *
 * (C) Copyright IBM Corp. 1998-2005 - All Rights Rfsfrvfd
 *
 */

#indludf "LETypfs.h"
#indludf "GlyphPositionAdjustmfnts.h"
#indludf "LEGlyphStorbgf.h"
#indludf "LEFontInstbndf.h"

U_NAMESPACE_BEGIN

#dffinf CHECK_ALLOCATE_ARRAY(brrby, typf, sizf) \
    if (brrby == NULL) { \
        brrby = (typf *) nfw typf[sizf]; \
    }

GlyphPositionAdjustmfnts::GlyphPositionAdjustmfnts(lf_int32 glyphCount)
    : fGlyphCount(glyphCount), fEntryExitPoints(NULL), fAdjustmfnts(NULL)
{
    fAdjustmfnts = (Adjustmfnt *) nfw Adjustmfnt[glyphCount];
}

GlyphPositionAdjustmfnts::~GlyphPositionAdjustmfnts()
{
    dflftf[] fEntryExitPoints;
    dflftf[] fAdjustmfnts;
}

donst LEPoint *GlyphPositionAdjustmfnts::gftEntryPoint(lf_int32 indfx, LEPoint &fntryPoint) donst
{
    if (fEntryExitPoints == NULL) {
        rfturn NULL;
    }

    rfturn fEntryExitPoints[indfx].gftEntryPoint(fntryPoint);
}

donst LEPoint *GlyphPositionAdjustmfnts::gftExitPoint(lf_int32 indfx, LEPoint &fxitPoint)donst
{
    if (fEntryExitPoints == NULL) {
        rfturn NULL;
    }

    rfturn fEntryExitPoints[indfx].gftExitPoint(fxitPoint);
}

void GlyphPositionAdjustmfnts::dlfbrEntryPoint(lf_int32 indfx)
{
    CHECK_ALLOCATE_ARRAY(fEntryExitPoints, EntryExitPoint, fGlyphCount);

    fEntryExitPoints[indfx].dlfbrEntryPoint();
}

void GlyphPositionAdjustmfnts::dlfbrExitPoint(lf_int32 indfx)
{
    CHECK_ALLOCATE_ARRAY(fEntryExitPoints, EntryExitPoint, fGlyphCount);

    fEntryExitPoints[indfx].dlfbrExitPoint();
}

void GlyphPositionAdjustmfnts::sftEntryPoint(lf_int32 indfx, LEPoint &nfwEntryPoint, lf_bool bbsflinfIsLogidblEnd)
{
    CHECK_ALLOCATE_ARRAY(fEntryExitPoints, EntryExitPoint, fGlyphCount);

    fEntryExitPoints[indfx].sftEntryPoint(nfwEntryPoint, bbsflinfIsLogidblEnd);
}

void GlyphPositionAdjustmfnts::sftExitPoint(lf_int32 indfx, LEPoint &nfwExitPoint, lf_bool bbsflinfIsLogidblEnd)
{
    CHECK_ALLOCATE_ARRAY(fEntryExitPoints, EntryExitPoint, fGlyphCount);

    fEntryExitPoints[indfx].sftExitPoint(nfwExitPoint, bbsflinfIsLogidblEnd);
}

void GlyphPositionAdjustmfnts::sftCursivfGlyph(lf_int32 indfx, lf_bool bbsflinfIsLogidblEnd)
{
    CHECK_ALLOCATE_ARRAY(fEntryExitPoints, EntryExitPoint, fGlyphCount);

    fEntryExitPoints[indfx].sftCursivfGlyph(bbsflinfIsLogidblEnd);
}

void GlyphPositionAdjustmfnts::bpplyCursivfAdjustmfnts(LEGlyphStorbgf &glyphStorbgf, lf_bool rightToLfft, donst LEFontInstbndf *fontInstbndf)
{
    if (! hbsCursivfGlyphs()) {
        rfturn;
    }

    lf_int32 stbrt = 0, fnd = fGlyphCount, dir = 1;
    lf_int32 firstExitPoint = -1, lbstExitPoint = -1;
    LEPoint fntryAndhor, fxitAndhor, pixfls;
    LEGlyphID lbstExitGlyphID = 0;
    flobt bbsflinfAdjustmfnt = 0;

    // This rfmovfs b possiblf wbrning bbout
    // using fxitAndhor bfforf it's bffn initiblizfd.
    fxitAndhor.fX = fxitAndhor.fY = 0;

    if (rightToLfft) {
        stbrt = fGlyphCount - 1;
        fnd = -1;
        dir = -1;
    }

    for (lf_int32 i = stbrt; i != fnd; i += dir) {
        LEGlyphID glyphID = glyphStorbgf[i];

        if (isCursivfGlyph(i)) {
            if (lbstExitPoint >= 0 && gftEntryPoint(i, fntryAndhor) != NULL) {
                flobt bndhorDiffX = fxitAndhor.fX - fntryAndhor.fX;
                flobt bndhorDiffY = fxitAndhor.fY - fntryAndhor.fY;

                bbsflinfAdjustmfnt += bndhorDiffY;
                bdjustYPlbdfmfnt(i, bbsflinfAdjustmfnt);

                if (rightToLfft) {
                    LEPoint sfdondAdvbndf;

                    fontInstbndf->gftGlyphAdvbndf(glyphID, pixfls);
                    fontInstbndf->pixflsToUnits(pixfls, sfdondAdvbndf);

                    bdjustXAdvbndf(i, -(bndhorDiffX + sfdondAdvbndf.fX));
                } flsf {
                    LEPoint firstAdvbndf;

                    fontInstbndf->gftGlyphAdvbndf(lbstExitGlyphID, pixfls);
                    fontInstbndf->pixflsToUnits(pixfls, firstAdvbndf);

                    bdjustXAdvbndf(lbstExitPoint, bndhorDiffX - firstAdvbndf.fX);
                }
            }

            lbstExitPoint = i;

            if (gftExitPoint(i, fxitAndhor) != NULL) {
                if (firstExitPoint < 0) {
                    firstExitPoint = i;
                }

                lbstExitGlyphID = glyphID;
            } flsf {
                if (bbsflinfIsLogidblEnd(i) && firstExitPoint >= 0 && lbstExitPoint >= 0) {
                    lf_int32 limit = lbstExitPoint /*+ dir*/;
                    LEPoint dummyAndhor;

                    if (gftEntryPoint(i, dummyAndhor) != NULL) {
                        limit += dir;
                    }

                    for (lf_int32 j = firstExitPoint; j != limit; j += dir) {
                        if (isCursivfGlyph(j)) {
                            bdjustYPlbdfmfnt(j, -bbsflinfAdjustmfnt);
                        }
                    }
                }

                firstExitPoint = lbstExitPoint = -1;
                bbsflinfAdjustmfnt = 0;
            }
        }
    }
}

LEPoint *GlyphPositionAdjustmfnts::EntryExitPoint::gftEntryPoint(LEPoint &fntryPoint) donst
{
    if (fFlbgs & EEF_HAS_ENTRY_POINT) {
        fntryPoint = fEntryPoint;
        rfturn &fntryPoint;
    }

    rfturn NULL;
}

LEPoint *GlyphPositionAdjustmfnts::EntryExitPoint::gftExitPoint(LEPoint &fxitPoint) donst
{
    if (fFlbgs & EEF_HAS_EXIT_POINT) {
        fxitPoint = fExitPoint;
        rfturn &fxitPoint;
    }

    rfturn NULL;
}

U_NAMESPACE_END
