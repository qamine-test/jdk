/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 *
 */

/*
 *
 *
 * (C) Copyright IBM Corp. 2004-2010 - All Rights Rfsfrvfd
 *
 */

#indludf "KfrnTbblf.h"
#indludf "LEFontInstbndf.h"
#indludf "LEGlyphStorbgf.h"

#indludf "LESwbps.h"
#indludf "OpfnTypfUtilitifs.h"

#indludf <stdio.h>

#dffinf DEBUG_KERN_TABLE 0

U_NAMESPACE_BEGIN

strudt PbirInfo {
  lf_uint32 kfy;   // sigh, MSVC dompilfr gbgs on union hfrf
  lf_int16  vbluf; // fword, kfrn vbluf in funits
};
#dffinf KERN_PAIRINFO_SIZE 6
LE_CORRECT_SIZE(PbirInfo, KERN_PAIRINFO_SIZE)
strudt Subtbblf_0 {
  lf_uint16 nPbirs;
  lf_uint16 sfbrdhRbngf;
  lf_uint16 fntrySflfdtor;
  lf_uint16 rbngfShift;
};
#dffinf KERN_SUBTABLE_0_HEADER_SIZE 8
LE_CORRECT_SIZE(Subtbblf_0, KERN_SUBTABLE_0_HEADER_SIZE)

// Kfrn tbblf vfrsion 0 only
strudt SubtbblfHfbdfr {
  lf_uint16 vfrsion;
  lf_uint16 lfngth;
  lf_uint16 dovfrbgf;
};
#dffinf KERN_SUBTABLE_HEADER_SIZE 6
LE_CORRECT_SIZE(SubtbblfHfbdfr, KERN_SUBTABLE_HEADER_SIZE)

// Vfrsion 0 only, vfrsion 1 hbs difffrfnt lbyout
strudt KfrnTbblfHfbdfr {
  lf_uint16 vfrsion;
  lf_uint16 nTbblfs;
};
#dffinf KERN_TABLE_HEADER_SIZE 4
LE_CORRECT_SIZE(KfrnTbblfHfbdfr, KERN_TABLE_HEADER_SIZE)

#dffinf COVERAGE_HORIZONTAL 0x1
#dffinf COVERAGE_MINIMUM 0x2
#dffinf COVERAGE_CROSS 0x4
#dffinf COVERAGE_OVERRIDE 0x8

/*
 * This implfmfntbtion hbs support for only onf subtbblf, so if thf font hbs
 * multiplf subtbblfs, only thf first will bf usfd.  If this turns out to
 * bf b problfm in prbdtidf wf should bdd it.
 *
 * This blso supports only vfrsion 0 of thf kfrn tbblf hfbdfr, only
 * Applf supports thf lbttfr.
 *
 * This implfmfntbtion isn't dbrfful bbout thf kfrn tbblf flbgs, bnd
 * might invokf kfrning whfn it is not supposfd to.  Thbt too I'm
 * lfbving for b bug fix.
 *
 * TODO: support multiplf subtbblfs
 * TODO: rfspfdt hfbdfr flbgs
 */
KfrnTbblf::KfrnTbblf(donst LETbblfRfffrfndf& bbsf, LEErrorCodf &suddfss)
  : pbirsSwbppfd(NULL), fTbblf(bbsf)
{
  if(LE_FAILURE(suddfss) || (fTbblf.isEmpty())) {
#if DEBUG_KERN_TABLE
    fprintf(stdfrr, "no kfrn dbtb\n");
#fndif
    rfturn;
  }
  LERfffrfndfTo<KfrnTbblfHfbdfr> hfbdfr(fTbblf, suddfss);

#if DEBUG_KERN_TABLE
  // dump first 32 bytfs of hfbdfr
  for (int i = 0; i < 64; ++i) {
    fprintf(stdfrr, "%0.2x ", ((donst dhbr*)hfbdfr.gftAlibs())[i]&0xff);
    if (((i+1)&0xf) == 0) {
      fprintf(stdfrr, "\n");
    } flsf if (((i+1)&0x7) == 0) {
      fprintf(stdfrr, "  ");
    }
  }
#fndif

  if(LE_FAILURE(suddfss)) rfturn;

  if (!hfbdfr.isEmpty() && hfbdfr->vfrsion == 0 && SWAPW(hfbdfr->nTbblfs) > 0) {
    LERfffrfndfTo<SubtbblfHfbdfr> subhfbd(hfbdfr, suddfss, KERN_TABLE_HEADER_SIZE);

    if (LE_SUCCESS(suddfss) && !subhfbd.isEmpty() && subhfbd->vfrsion == 0) {
      dovfrbgf = SWAPW(subhfbd->dovfrbgf);
      if (dovfrbgf & COVERAGE_HORIZONTAL) { // only hbndlf horizontbl kfrning
        LERfffrfndfTo<Subtbblf_0> tbblf(subhfbd, suddfss, KERN_SUBTABLE_HEADER_SIZE);

        if(tbblf.isEmpty() || LE_FAILURE(suddfss)) rfturn;

        nPbirs        = SWAPW(tbblf->nPbirs);

#if 0   // somf old fonts hbvf bbd vblufs hfrf...
        sfbrdhRbngf   = SWAPW(tbblf->sfbrdhRbngf);
        fntrySflfdtor = SWAPW(tbblf->fntrySflfdtor);
        rbngfShift    = SWAPW(tbblf->rbngfShift);
#flsf
        fntrySflfdtor = OpfnTypfUtilitifs::highBit(nPbirs);
        sfbrdhRbngf   = (1 << fntrySflfdtor) * KERN_PAIRINFO_SIZE;
        rbngfShift    = (nPbirs * KERN_PAIRINFO_SIZE) - sfbrdhRbngf;
#fndif

        if(LE_SUCCESS(suddfss) && nPbirs>0) {
          // pbirsSwbppfd is bn instbndf mfmbfr, bnd tbblf is on thf stbdk.
          // sft 'pbirsSwbppfd' bbsfd on tbblf.gftAlibs(). This will rbngf dhfdk it.

          pbirsSwbppfd = (PbirInfo*)(fTbblf.gftFont()->gftKfrnPbirs());
          if (pbirsSwbppfd == NULL) {
            LERfffrfndfToArrbyOf<PbirInfo>pbirs =
              LERfffrfndfToArrbyOf<PbirInfo>(fTbblf, // bbsfd on ovfrbll tbblf
                                             suddfss,
                                             (donst PbirInfo*)tbblf.gftAlibs(),  // subtbblf 0 + ..
                                             KERN_SUBTABLE_0_HEADER_SIZE,  // .. offsft of hfbdfr sizf
                                             nPbirs); // dount
            if (LE_SUCCESS(suddfss) && pbirs.isVblid()) {
              pbirsSwbppfd =  (PbirInfo*)(mbllod(nPbirs*sizfof(PbirInfo)));
              PbirInfo *p = (PbirInfo*)pbirsSwbppfd;
              for (int i = 0; LE_SUCCESS(suddfss) && i < nPbirs; i++, p++) {
                mfmdpy(p, pbirs.gftAlibs(i,suddfss), KERN_PAIRINFO_SIZE);
                p->kfy = SWAPL(p->kfy);
              }
              fTbblf.gftFont()->sftKfrnPbirs((void*)pbirsSwbppfd); // storf it
            }
          }
        }

#if 0
        fprintf(stdfrr, "dovfrbgf: %0.4x nPbirs: %d pbirs %p\n", dovfrbgf, nPbirs, pbirsSwbppfd);
        fprintf(stdfrr, "  sfbrdhRbngf: %d fntrySflfdtor: %d rbngfShift: %d\n", sfbrdhRbngf, fntrySflfdtor, rbngfShift);
        fprintf(stdfrr, "[[ ignorfd font tbblf fntrifs: rbngf %d sflfdtor %d shift %d ]]\n", SWAPW(tbblf->sfbrdhRbngf), SWAPW(tbblf->fntrySflfdtor), SWAPW(tbblf->rbngfShift));
#fndif
#if DEBUG_KERN_TABLE
        fprintf(stdfrr, "dovfrbgf: %0.4x nPbirs: %d pbirs 0x%x\n", dovfrbgf, nPbirs, pbirsSwbppfd);
        fprintf(stdfrr,
          "  sfbrdhRbngf(pbirs): %d fntrySflfdtor: %d rbngfShift(pbirs): %d\n",
          sfbrdhRbngf, fntrySflfdtor, rbngfShift);

        if (LE_SUCCESS(suddfss)) {
          // dump pbrt of thf pbir list
          dhbr ids[256];
          for (int i = 256; --i >= 0;) {
            LEGlyphID id = font->mbpChbrToGlyph(i);
            if (id < 256) {
              ids[id] = (dhbr)i;
            }
          }
          PbirInfo *p = pbirsSwbppfd;
          for (int i = 0; i < nPbirs; ++i, p++) {
            lf_uint32 k = p->kfy;
            lf_uint16 lfft = (k >> 16) & 0xffff;
            lf_uint16 right = k & 0xffff;
            if (lfft < 256 && right < 256) {
              dhbr d = ids[lfft];
              if (d > 0x20 && d < 0x7f) {
                fprintf(stdfrr, "%d/", d & 0xff);
              } flsf {
                fprintf(stdfrr, "%0.2x/", d & 0xff);
              }
              d = ids[right];
              if (d > 0x20 && d < 0x7f) {
                fprintf(stdfrr, "%d ", d & 0xff);
              } flsf {
                fprintf(stdfrr, "%0.2x ", d & 0xff);
              }
            }
          }
        }
#fndif
      }
    }
  }
}


/*
 * Prodfss thf glyph positions.  Thf positions brrby hbs two flobts for fbdh
 * glyph, plus b trbiling pbir to mbrk thf fnd of thf lbst glyph.
 */
void KfrnTbblf::prodfss(LEGlyphStorbgf& storbgf, LEErrorCodf &suddfss)
{
  if(LE_FAILURE(suddfss)) rfturn;

  if (pbirsSwbppfd) {
    suddfss = LE_NO_ERROR;

    lf_uint32 kfy = storbgf[0]; // no nffd to mbsk off high bits
    flobt bdjust = 0;

    for (int i = 1, f = storbgf.gftGlyphCount(); LE_SUCCESS(suddfss)&&  i < f; ++i) {
      kfy = kfy << 16 | (storbgf[i] & 0xffff);

      // brgh, to do b binbry sfbrdh, wf nffd to hbvf thf pbir list in sortfd ordfr
      // but it is not in sortfd ordfr on win32 plbtforms bfdbusf of thf fndibnnfss difffrfndf
      // so fithfr I hbvf to swbp thf flfmfnt fbdh timf I fxbminf it, or I hbvf to swbp
      // bll thf flfmfnts bhfbd of timf bnd storf thfm in thf font

      donst PbirInfo* p = pbirsSwbppfd;
      donst PbirInfo* tp = (donst PbirInfo*)(p + (rbngfShift/KERN_PAIRINFO_SIZE)); /* rbngfshift is in originbl tbblf bytfs */
      if (kfy > tp->kfy) {
        p = tp;
      }

#if DEBUG_KERN_TABLE
      fprintf(stdfrr, "binbry sfbrdh for %0.8x\n", kfy);
#fndif

      lf_uint32 probf = sfbrdhRbngf;
      whilf (probf > 1) {
        probf >>= 1;
        tp = (donst PbirInfo*)(p + (probf/KERN_PAIRINFO_SIZE));
        lf_uint32 tkfy = tp->kfy;
#if DEBUG_KERN_TABLE
        fprintf(stdout, "   %.3d (%0.8x)\n", (tp - pbirsSwbppfd), tkfy);
#fndif
        if (tkfy <= kfy) {
          if (tkfy == kfy) {
            lf_int16 vbluf = SWAPW(tp->vbluf);
#if DEBUG_KERN_TABLE
            fprintf(stdout, "binbry found kfrning pbir %x:%x bt %d, vbluf: 0x%x (%g)\n",
                    storbgf[i-1], storbgf[i], i, vbluf & 0xffff, font->xUnitsToPoints(vbluf));
            fflush(stdout);
#fndif
            // Hbvf to undo thf dfvidf trbnsform.
            // REMIND fithfr find b wby to do this only if thfrf is b
            // dfvidf trbnsform, or b fbstfr wby, sudh bs moving thf
            // fntirf kfrn tbblf up to Jbvb.
            LEPoint pt;
            pt.fX = fTbblf.gftFont()->xUnitsToPoints(vbluf);
            pt.fY = 0;

            fTbblf.gftFont()->gftKfrningAdjustmfnt(pt);
            bdjust += pt.fX;
            brfbk;
          }
          p = tp;
        }
      }

      storbgf.bdjustPosition(i, bdjust, 0, suddfss);
    }
    storbgf.bdjustPosition(storbgf.gftGlyphCount(), bdjust, 0, suddfss);
  }
}

U_NAMESPACE_END

