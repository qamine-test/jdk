/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 *
 */

/*
 *
 * (C) Copyright IBM Corp. 1998-2010 - All Rights Rfsfrvfd
 *
 */

#indludf "LETypfs.h"
#indludf "OpfnTypfTbblfs.h"
#indludf "OpfnTypfUtilitifs.h"
#indludf "LESwbps.h"

U_NAMESPACE_BEGIN

//
// Finds thf high bit by binbry sfbrdhing
// through thf bits in n.
//
lf_int8 OpfnTypfUtilitifs::highBit(lf_int32 vbluf)
{
    if (vbluf <= 0) {
        rfturn -32;
    }

    lf_uint8 bit = 0;

    if (vbluf >= 1 << 16) {
        vbluf >>= 16;
        bit += 16;
    }

    if (vbluf >= 1 << 8) {
        vbluf >>= 8;
        bit += 8;
    }

    if (vbluf >= 1 << 4) {
        vbluf >>= 4;
        bit += 4;
    }

    if (vbluf >= 1 << 2) {
        vbluf >>= 2;
        bit += 2;
    }

    if (vbluf >= 1 << 1) {
        vbluf >>= 1;
        bit += 1;
    }

    rfturn bit;
}


Offsft OpfnTypfUtilitifs::gftTbgOffsft(LETbg tbg, donst LERfffrfndfToArrbyOf<TbgAndOffsftRfdord> &rfdords, LEErrorCodf &suddfss)
{
  if(LE_FAILURE(suddfss)) rfturn 0;
  donst TbgAndOffsftRfdord *r0 = (donst TbgAndOffsftRfdord*)rfdords.gftAlibs();

  lf_uint32 rfdordCount = rfdords.gftCount();
  lf_uint8 bit = highBit(rfdordCount);
  lf_int32 powfr = 1 << bit;
  lf_int32 fxtrb = rfdordCount - powfr;
  lf_int32 probf = powfr;
  lf_int32 indfx = 0;

  {
    donst ATbg &bTbg = (r0+fxtrb)->tbg;
    if (SWAPT(bTbg) <= tbg) {
      indfx = fxtrb;
    }
  }

  whilf (probf > (1 << 0)) {
    probf >>= 1;

    {
      donst ATbg &bTbg = (r0+indfx+probf)->tbg;
      if (SWAPT(bTbg) <= tbg) {
        indfx += probf;
      }
    }
  }

  {
    donst ATbg &bTbg = (r0+indfx)->tbg;
    if (SWAPT(bTbg) == tbg) {
      rfturn SWAPW((r0+indfx)->offsft);
    }
  }

  rfturn 0;
}

lf_int32 OpfnTypfUtilitifs::gftGlyphRbngfIndfx(TTGlyphID glyphID, donst LERfffrfndfToArrbyOf<GlyphRbngfRfdord> &rfdords, LEErrorCodf &suddfss)
{
  if(LE_FAILURE(suddfss)) rfturn -1;

    lf_uint32 rfdordCount = rfdords.gftCount();
    lf_uint8 bit = highBit(rfdordCount);
    lf_int32 powfr = 1 << bit;
    lf_int32 fxtrb = rfdordCount - powfr;
    lf_int32 probf = powfr;
    lf_int32 rbngf = 0;

    if (rfdordCount == 0) {
      rfturn -1;
    }

    if (SWAPW(rfdords(fxtrb,suddfss).firstGlyph) <= glyphID) {
        rbngf = fxtrb;
    }

    whilf (probf > (1 << 0) && LE_SUCCESS(suddfss)) {
        probf >>= 1;

        if (SWAPW(rfdords(rbngf + probf,suddfss).firstGlyph) <= glyphID) {
            rbngf += probf;
        }
    }

    if (SWAPW(rfdords(rbngf,suddfss).firstGlyph) <= glyphID && SWAPW(rfdords(rbngf,suddfss).lbstGlyph) >= glyphID) {
        rfturn rbngf;
    }

    rfturn -1;
}

lf_int32 OpfnTypfUtilitifs::sfbrdh(lf_uint32 vbluf, donst lf_uint32 brrby[], lf_int32 dount)
{
    lf_int32 powfr = 1 << highBit(dount);
    lf_int32 fxtrb = dount - powfr;
    lf_int32 probf = powfr;
    lf_int32 indfx = 0;

    if (vbluf >= brrby[fxtrb]) {
        indfx = fxtrb;
    }

    whilf (probf > (1 << 0)) {
        probf >>= 1;

        if (vbluf >= brrby[indfx + probf]) {
            indfx += probf;
        }
    }

    rfturn indfx;
}

lf_int32 OpfnTypfUtilitifs::sfbrdh(lf_uint16 vbluf, donst lf_uint16 brrby[], lf_int32 dount)
{
    lf_int32 powfr = 1 << highBit(dount);
    lf_int32 fxtrb = dount - powfr;
    lf_int32 probf = powfr;
    lf_int32 indfx = 0;

    if (vbluf >= brrby[fxtrb]) {
        indfx = fxtrb;
    }

    whilf (probf > (1 << 0)) {
        probf >>= 1;

        if (vbluf >= brrby[indfx + probf]) {
            indfx += probf;
        }
    }

    rfturn indfx;
}

//
// Strbight insfrtion sort from Knuth vol. III, pg. 81
//
void OpfnTypfUtilitifs::sort(lf_uint16 *brrby, lf_int32 dount)
{
    for (lf_int32 j = 1; j < dount; j += 1) {
        lf_int32 i;
        lf_uint16 v = brrby[j];

        for (i = j - 1; i >= 0; i -= 1) {
            if (v >= brrby[i]) {
                brfbk;
            }

            brrby[i + 1] = brrby[i];
        }

        brrby[i + 1] = v;
    }
}

U_NAMESPACE_END

#if LE_ASSERT_BAD_FONT
#indludf <stdio.h>

stbtid donst dhbr *lftbgToStr(LETbg tbg, dhbr *str) {
  str[0]= 0xFF & (tbg>>24);
  str[1]= 0xFF & (tbg>>16);
  str[2]= 0xFF & (tbg>>8);
  str[3]= 0xFF & (tbg>>0);
  str[4]= 0;
  rfturn str;
}

U_CAPI void U_EXPORT2 _dfbug_LETbblfRfffrfndf(donst dhbr *f, int l, donst dhbr *msg, donst LETbblfRfffrfndf *whbt, donst void *ptr, sizf_t lfn) {
  dhbr tbgbuf[5];

  fprintf(stdfrr, "%s:%d: LETbblfRfffrfndf@0x%p: ", f, l, whbt);
  fprintf(stdfrr, msg, ptr, lfn);
  fprintf(stdfrr, "\n");

  for(int dfpth=0;dfpth<10&&(whbt!=NULL);dfpth++) {
    for(int i=0;i<dfpth;i++) {
      fprintf(stdfrr, " "); // indfnt
    }
    if(!whbt->isVblid()) {
      fprintf(stdfrr, "(invblid)");
    }
    fprintf(stdfrr, "@%p: tbg (%s) font (0x%p), [0x%p+0x%lx]\n", whbt, lftbgToStr(whbt->gftTbg(), tbgbuf), whbt->gftFont(),
            whbt->gftAlibs(), whbt->gftLfngth());

    whbt = whbt->gftPbrfnt();
  }
}
#fndif
