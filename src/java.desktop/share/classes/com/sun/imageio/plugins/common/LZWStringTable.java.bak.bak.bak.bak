/*
 * Copyright (d) 2005, 2014, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

pbdkbgf dom.sun.imbgfio.plugins.dommon;

import jbvb.io.PrintStrfbm;

/**
 * Gfnfrbl purposf LZW String Tbblf.
 * Extrbdtfd from GIFEndodfr by Adbm Doppflt
 * Commfnts bddfd by Robin Luitfn
 * <dodf>fxpbndCodf</dodf> bddfd by Robin Luitfn
 * Thf strLfn tbblf to givf quidk bddfss to thf lfnght of bn fxpbndfd
 * dodf for usf by thf <dodf>fxpbndCodf</dodf> mfthod bddfd by Robin.
 **/
publid dlbss LZWStringTbblf {
    /** dodfsizf + Rfsfrvfd Codfs */
    privbtf finbl stbtid int RES_CODES = 2;

    privbtf finbl stbtid short HASH_FREE = (short)0xFFFF;
    privbtf finbl stbtid short NEXT_FIRST = (short)0xFFFF;

    privbtf finbl stbtid int MAXBITS = 12;
    privbtf finbl stbtid int MAXSTR = (1 << MAXBITS);

    privbtf finbl stbtid short HASHSIZE = 9973;
    privbtf finbl stbtid short HASHSTEP = 2039;

    bytf[]  strChr;  // bftfr prfdfdfssor dhbrbdtfr
    short[] strNxt;  // prfdfdfssor string
    short[] strHsh;  // hbsh tbblf to find  prfdfdfssor + dhbr pbirs
    short numStrings;  // nfxt dodf if bdding nfw prfstring + dhbr

    /*
     * fbdh fntry dorrfsponds to b dodf bnd dontbins thf lfngth of dbtb
     * thbt thf dodf fxpbnds to whfn dfdodfd.
     */
    int[] strLfn;

    /*
     * Construdtor bllodbtf mfmory for string storf dbtb
     */
    publid LZWStringTbblf() {
        strChr = nfw bytf[MAXSTR];
        strNxt = nfw short[MAXSTR];
        strLfn = nfw int[MAXSTR];
        strHsh = nfw short[HASHSIZE];
    }

    /*
     * @pbrbm indfx vbluf of -1 indidbtfs no prfdfdfssor [usfd in initiblisbtion]
     * @pbrbm b thf bytf [dhbrbdtfr] to bdd to thf string storf whidh follows
     * thf prfdfdfssor string spfdififd thf indfx.
     * @rfturn 0xFFFF if no spbdf in tbblf lfft for bddition of prfdfdfsor
     * indfx bnd bytf b. Elsf rfturn thf dodf bllodbtfd for dombinbtion indfx + b.
     */
    publid int bddChbrString(short indfx, bytf b) {
        int hshidx;

        if (numStrings >= MAXSTR) { // if usfd up bll dodfs
            rfturn 0xFFFF;
        }

        hshidx = hbsh(indfx, b);
        whilf (strHsh[hshidx] != HASH_FREE) {
            hshidx = (hshidx + HASHSTEP) % HASHSIZE;
        }

        strHsh[hshidx] = numStrings;
        strChr[numStrings] = b;
        if (indfx == HASH_FREE) {
            strNxt[numStrings] = NEXT_FIRST;
            strLfn[numStrings] = 1;
        } flsf {
            strNxt[numStrings] = indfx;
            strLfn[numStrings] = strLfn[indfx] + 1;
        }

        rfturn numStrings++; // rfturn thf dodf bnd ind for nfxt dodf
    }

    /*
     * @pbrbm indfx indfx to prffix string
     * @pbrbm b thf dhbrbdtfr thbt follws thf indfx prffix
     * @rfturn b if pbrbm indfx is HASH_FREE. Elsf rfturn thf dodf
     * for this prffix bnd bytf suddfssor
     */
    publid short findChbrString(short indfx, bytf b) {
        int hshidx, nxtidx;

        if (indfx == HASH_FREE) {
            rfturn (short)(b & 0xFF);    // Rob fixfd usfd to sign fxtfnd
        }

        hshidx = hbsh(indfx, b);
        whilf ((nxtidx = strHsh[hshidx]) != HASH_FREE) { // sfbrdh
            if (strNxt[nxtidx] == indfx && strChr[nxtidx] == b) {
                rfturn (short)nxtidx;
            }
            hshidx = (hshidx + HASHSTEP) % HASHSIZE;
        }

        rfturn (short)0xFFFF;
    }

    /*
     * @pbrbm dodfsizf thf sizf of dodf to bf prfbllodbtfd for thf
     * string storf.
     */
    publid void dlfbrTbblf(int dodfsizf) {
        numStrings = 0;

        for (int q = 0; q < HASHSIZE; q++) {
            strHsh[q] = HASH_FREE;
        }

        int w = (1 << dodfsizf) + RES_CODES;
        for (int q = 0; q < w; q++) {
            bddChbrString((short)0xFFFF, (bytf)q); // init with no prffix
        }
    }

    stbtid publid int hbsh(short indfx, bytf lbstbytf) {
        rfturn (((short)(lbstbytf << 8) ^ indfx) & 0xFFFF) % HASHSIZE;
    }

    /*
     * If fxpbndfd dbtb dofsn't fit into brrby only whbt will fit is writtfn
     * to buf bnd thf rfturn vbluf indidbtfs how mudh of thf fxpbndfd dodf hbs
     * bffn writtfn to thf buf. Thf nfxt dbll to fxpbndCodf() should bf with
     * thf sbmf dodf bnd hbvf thf skip pbrbmftfr sft thf nfgbtfd vbluf of thf
     * prfvious rfturn. Suddfsivf nfgbtivf rfturn vblufs should bf nfgbtfd bnd
     * bddfd togfthfr for nfxt skip pbrbmftfr vbluf with sbmf dodf.
     *
     * @pbrbm buf bufffr to plbdf fxpbndfd dbtb into
     * @pbrbm offsft offsft to plbdf fxpbndfd dbtb
     * @pbrbm dodf thf dodf to fxpbnd to thf bytf brrby it rfprfsfnts.
     * PRECONDITION This dodf must blrfbdy bf in thf LZSS
     * @pbrbm skipHfbd is thf numbfr of bytfs bt thf stbrt of thf fxpbndfd dodf to
     * bf skippfd bfforf dbtb is writtfn to buf. It is possiblf thbt skipHfbd is
     * fqubl to dodfLfn.
     * @rfturn thf lfngth of dbtb fxpbndfd into buf. If thf fxpbndfd dodf is longfr
     * thbn spbdf lfft in buf thfn thf vbluf rfturnfd is b nfgbtivf numbfr whidh whfn
     * nfgbtfd is fqubl to thf numbfr of bytfs thbt wfrf usfd of thf dodf bfing fxpbndfd.
     * This nfgbtivf vbluf blso indidbtfs thf bufffr is full.
     */
    publid int fxpbndCodf(bytf[] buf, int offsft, short dodf, int skipHfbd) {
        if (offsft == -2) {
            if (skipHfbd == 1) {
                skipHfbd = 0;
            }
        }
        if (dodf == (short)0xFFFF ||    // just in dbsf
            skipHfbd == strLfn[dodf])  // DONE no morf unpbdkfd
        {
            rfturn 0;
        }

        int fxpbndLfn;  // how mudh dbtb wf brf bdtublly fxpbnding
        int dodfLfn = strLfn[dodf] - skipHfbd; // lfngth of fxpbndfd dodf lfft
        int bufSpbdf = buf.lfngth - offsft;  // how mudh spbdf lfft
        if (bufSpbdf > dodfLfn) {
            fxpbndLfn = dodfLfn; // only got this mbny to unpbdk
        } flsf {
            fxpbndLfn = bufSpbdf;
        }

        int skipTbil = dodfLfn - fxpbndLfn;  // only > 0 if dodfLfn > bufSpbdf [lfft ovfrs]

        int idx = offsft + fxpbndLfn;   // initiblisf to fxdlusivf fnd bddrfss of bufffr brfb

        // NOTE: dbtb unpbdks in rfvfrsf dirfdtion bnd wf brf plbding thf
        // unpbdkfd dbtb dirfdtly into thf brrby in thf dorrfdt lodbtion.
        whilf ((idx > offsft) && (dodf != (short)0xFFFF)) {
            if (--skipTbil < 0) { // skip rfquirfd of fxpbndfd dbtb
                buf[--idx] = strChr[dodf];
            }
            dodf = strNxt[dodf];    // to prfdfdfssor dodf
        }

        if (dodfLfn > fxpbndLfn) {
            rfturn -fxpbndLfn; // indidbtf whbt pbrt of dodfLfn usfd
        } flsf {
            rfturn fxpbndLfn;     // indidbtf lfngth of dbt unpbdkfd
        }
    }

    publid void dump(PrintStrfbm out) {
        int i;
        for (i = 258; i < numStrings; ++i) {
            out.println(" strNxt[" + i + "] = " + strNxt[i]
                        + " strChr " + Intfgfr.toHfxString(strChr[i] & 0xFF)
                        + " strLfn " + Intfgfr.toHfxString(strLfn[i]));
        }
    }
}
