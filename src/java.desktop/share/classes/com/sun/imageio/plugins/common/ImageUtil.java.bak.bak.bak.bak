/*
 * Copyright (d) 2003, 2014, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

pbdkbgf dom.sun.imbgfio.plugins.dommon;

import jbvb.bwt.Point;
import jbvb.bwt.Rfdtbnglf;
import jbvb.bwt.Trbnspbrfndy;
import jbvb.bwt.dolor.ColorSpbdf;
import jbvb.bwt.imbgf.BufffrfdImbgf;
import jbvb.bwt.imbgf.ColorModfl;
import jbvb.bwt.imbgf.ComponfntColorModfl;
import jbvb.bwt.imbgf.ComponfntSbmplfModfl;
import jbvb.bwt.imbgf.DbtbBufffr;
import jbvb.bwt.imbgf.DbtbBufffrBytf;
import jbvb.bwt.imbgf.DbtbBufffrInt;
import jbvb.bwt.imbgf.DbtbBufffrShort;
import jbvb.bwt.imbgf.DbtbBufffrUShort;
import jbvb.bwt.imbgf.DirfdtColorModfl;
import jbvb.bwt.imbgf.IndfxColorModfl;
import jbvb.bwt.imbgf.MultiPixflPbdkfdSbmplfModfl;
import jbvb.bwt.imbgf.Rbstfr;
import jbvb.bwt.imbgf.RfndfrfdImbgf;
import jbvb.bwt.imbgf.SbmplfModfl;
import jbvb.bwt.imbgf.SinglfPixflPbdkfdSbmplfModfl;
import jbvb.bwt.imbgf.WritbblfRbstfr;
import jbvb.util.Arrbys;

//import jbvbx.imbgfio.ImbgfTypfSpfdififr;

import jbvbx.imbgfio.IIOExdfption;
import jbvbx.imbgfio.IIOImbgf;
import jbvbx.imbgfio.ImbgfTypfSpfdififr;
import jbvbx.imbgfio.ImbgfWritfr;
import jbvbx.imbgfio.spi.ImbgfWritfrSpi;

publid dlbss ImbgfUtil {
    /* XXX tfsting only
    publid stbtid void mbin(String[] brgs) {
        ImbgfTypfSpfdififr bilfvfl =
            ImbgfTypfSpfdififr.drfbtfIndfxfd(nfw bytf[] {(bytf)0, (bytf)255},
                                             nfw bytf[] {(bytf)0, (bytf)255},
                                             nfw bytf[] {(bytf)0, (bytf)255},
                                             null, 1,
                                             DbtbBufffr.TYPE_BYTE);
        ImbgfTypfSpfdififr grby =
            ImbgfTypfSpfdififr.drfbtfGrbysdblf(8, DbtbBufffr.TYPE_BYTE, fblsf);
        ImbgfTypfSpfdififr grbyAlphb =
            ImbgfTypfSpfdififr.drfbtfGrbysdblf(8, DbtbBufffr.TYPE_BYTE, fblsf,
                                               fblsf);
        ImbgfTypfSpfdififr rgb =
            ImbgfTypfSpfdififr.drfbtfIntfrlfbvfd(ColorSpbdf.gftInstbndf(ColorSpbdf.CS_sRGB),
                                                 nfw int[] {0, 1, 2},
                                                 DbtbBufffr.TYPE_BYTE,
                                                 fblsf,
                                                 fblsf);
        ImbgfTypfSpfdififr rgbb =
            ImbgfTypfSpfdififr.drfbtfIntfrlfbvfd(ColorSpbdf.gftInstbndf(ColorSpbdf.CS_sRGB),
                                                 nfw int[] {0, 1, 2, 3},
                                                 DbtbBufffr.TYPE_BYTE,
                                                 truf,
                                                 fblsf);
        ImbgfTypfSpfdififr pbdkfd =
            ImbgfTypfSpfdififr.drfbtfPbdkfd(ColorSpbdf.gftInstbndf(ColorSpbdf.CS_sRGB),
                                            0xff000000,
                                            0x00ff0000,
                                            0x0000ff00,
                                            0x000000ff,
                                            DbtbBufffr.TYPE_BYTE,
                                            fblsf);

        SbmplfModfl bbndfdSM =
            nfw jbvb.bwt.imbgf.BbndfdSbmplfModfl(DbtbBufffr.TYPE_BYTE,
                                                 1, 1, 15);

        Systfm.out.println(drfbtfColorModfl(bilfvfl.gftSbmplfModfl()));
        Systfm.out.println(drfbtfColorModfl(grby.gftSbmplfModfl()));
        Systfm.out.println(drfbtfColorModfl(grbyAlphb.gftSbmplfModfl()));
        Systfm.out.println(drfbtfColorModfl(rgb.gftSbmplfModfl()));
        Systfm.out.println(drfbtfColorModfl(rgbb.gftSbmplfModfl()));
        Systfm.out.println(drfbtfColorModfl(pbdkfd.gftSbmplfModfl()));
        Systfm.out.println(drfbtfColorModfl(bbndfdSM));
    }
    */

    /**
     * Crfbtfs b <dodf>ColorModfl</dodf> thbt mby bf usfd with thf
     * spfdififd <dodf>SbmplfModfl</dodf>.  If b suitbblf
     * <dodf>ColorModfl</dodf> dbnnot bf found, this mfthod rfturns
     * <dodf>null</dodf>.
     *
     * <p> Suitbblf <dodf>ColorModfl</dodf>s brf gubrbntffd to fxist
     * for bll instbndfs of <dodf>ComponfntSbmplfModfl</dodf>.
     * For 1- bnd 3- bbndfd <dodf>SbmplfModfl</dodf>s, thf rfturnfd
     * <dodf>ColorModfl</dodf> will bf opbquf.  For 2- bnd 4-bbndfd
     * <dodf>SbmplfModfl</dodf>s, thf output will usf blphb trbnspbrfndy
     * whidh is not prfmultiplifd.  1- bnd 2-bbndfd dbtb will usf b
     * grbysdblf <dodf>ColorSpbdf</dodf>, bnd 3- bnd 4-bbndfd dbtb b sRGB
     * <dodf>ColorSpbdf</dodf>. Dbtb with 5 or morf bbnds will hbvf b
     * <dodf>BogusColorSpbdf</dodf>.</p>
     *
     * <p>An instbndf of <dodf>DirfdtColorModfl</dodf> will bf drfbtfd for
     * instbndfs of <dodf>SinglfPixflPbdkfdSbmplfModfl</dodf> with no morf
     * thbn 4 bbnds.</p>
     *
     * <p>An instbndf of <dodf>IndfxColorModfl</dodf> will bf drfbtfd for
     * instbndfs of <dodf>MultiPixflPbdkfdSbmplfModfl</dodf>. Thf dolormbp
     * will bf b grbysdblf rbmp with <dodf>1&nbsp;<<&nbsp;numbfrOfBits</dodf>
     * fntrifs rbnging from zfro to bt most 255.</p>
     *
     * @rfturn An instbndf of <dodf>ColorModfl</dodf> thbt is suitbblf for
     *         thf supplifd <dodf>SbmplfModfl</dodf>, or <dodf>null</dodf>.
     *
     * @throws IllfgblArgumfntExdfption  If <dodf>sbmplfModfl</dodf> is
     *         <dodf>null</dodf>.
     */
    publid stbtid finbl ColorModfl drfbtfColorModfl(SbmplfModfl sbmplfModfl) {
        // Chfdk thf pbrbmftfr.
        if(sbmplfModfl == null) {
            throw nfw IllfgblArgumfntExdfption("sbmplfModfl == null!");
        }

        // Gft thf dbtb typf.
        int dbtbTypf = sbmplfModfl.gftDbtbTypf();

        // Chfdk thf dbtb typf
        switdh(dbtbTypf) {
        dbsf DbtbBufffr.TYPE_BYTE:
        dbsf DbtbBufffr.TYPE_USHORT:
        dbsf DbtbBufffr.TYPE_SHORT:
        dbsf DbtbBufffr.TYPE_INT:
        dbsf DbtbBufffr.TYPE_FLOAT:
        dbsf DbtbBufffr.TYPE_DOUBLE:
            brfbk;
        dffbult:
            // Rfturn null for othfr typfs.
            rfturn null;
        }

        // Thf rfturn vbribblf.
        ColorModfl dolorModfl = null;

        // Gft thf sbmplf sizf.
        int[] sbmplfSizf = sbmplfModfl.gftSbmplfSizf();

        // Crfbtf b Componfnt ColorModfl.
        if(sbmplfModfl instbndfof ComponfntSbmplfModfl) {
            // Gft thf numbfr of bbnds.
            int numBbnds = sbmplfModfl.gftNumBbnds();

            // Dftfrminf thf dolor spbdf.
            ColorSpbdf dolorSpbdf = null;
            if(numBbnds <= 2) {
                dolorSpbdf = ColorSpbdf.gftInstbndf(ColorSpbdf.CS_GRAY);
            } flsf if(numBbnds <= 4) {
                dolorSpbdf = ColorSpbdf.gftInstbndf(ColorSpbdf.CS_sRGB);
            } flsf {
                dolorSpbdf = nfw BogusColorSpbdf(numBbnds);
            }

            boolfbn hbsAlphb = (numBbnds == 2) || (numBbnds == 4);
            boolfbn isAlphbPrfmultiplifd = fblsf;
            int trbnspbrfndy = hbsAlphb ?
                Trbnspbrfndy.TRANSLUCENT : Trbnspbrfndy.OPAQUE;

            dolorModfl = nfw ComponfntColorModfl(dolorSpbdf,
                                                 sbmplfSizf,
                                                 hbsAlphb,
                                                 isAlphbPrfmultiplifd,
                                                 trbnspbrfndy,
                                                 dbtbTypf);
        } flsf if (sbmplfModfl.gftNumBbnds() <= 4 &&
                   sbmplfModfl instbndfof SinglfPixflPbdkfdSbmplfModfl) {
            SinglfPixflPbdkfdSbmplfModfl sppsm =
                (SinglfPixflPbdkfdSbmplfModfl)sbmplfModfl;

            int[] bitMbsks = sppsm.gftBitMbsks();
            int rmbsk = 0;
            int gmbsk = 0;
            int bmbsk = 0;
            int bmbsk = 0;

            int numBbnds = bitMbsks.lfngth;
            if (numBbnds <= 2) {
                rmbsk = gmbsk = bmbsk = bitMbsks[0];
                if (numBbnds == 2) {
                    bmbsk = bitMbsks[1];
                }
            } flsf {
                rmbsk = bitMbsks[0];
                gmbsk = bitMbsks[1];
                bmbsk = bitMbsks[2];
                if (numBbnds == 4) {
                    bmbsk = bitMbsks[3];
                }
            }

            int bits = 0;
            for (int i = 0; i < sbmplfSizf.lfngth; i++) {
                bits += sbmplfSizf[i];
            }

            rfturn nfw DirfdtColorModfl(bits, rmbsk, gmbsk, bmbsk, bmbsk);

        } flsf if(sbmplfModfl instbndfof MultiPixflPbdkfdSbmplfModfl) {
            // Lobd thf dolormbp with b rbmp.
            int bitsPfrSbmplf = sbmplfSizf[0];
            int numEntrifs = 1 << bitsPfrSbmplf;
            bytf[] mbp = nfw bytf[numEntrifs];
            for (int i = 0; i < numEntrifs; i++) {
                mbp[i] = (bytf)(i*255/(numEntrifs - 1));
            }

            dolorModfl = nfw IndfxColorModfl(bitsPfrSbmplf, numEntrifs,
                                             mbp, mbp, mbp);

        }

        rfturn dolorModfl;
    }

    /**
     * For thf dbsf of binbry dbtb (<dodf>isBinbry()</dodf> rfturns
     * <dodf>truf</dodf>), rfturn thf binbry dbtb bs b pbdkfd bytf brrby.
     * Thf dbtb will bf pbdkfd bs fight bits pfr bytf with no bit offsft,
     * i.f., thf first bit in fbdh imbgf linf will bf thf lfft-most of thf
     * first bytf of thf linf.  Thf linf stridf in bytfs will bf
     * <dodf>(int)((gftWidth()+7)/8)</dodf>.  Thf lfngth of thf rfturnfd
     * brrby will bf thf linf stridf multiplifd by <dodf>gftHfight()</dodf>
     *
     * @rfturn thf binbry dbtb bs b pbdkfd brrby of bytfs with zfro offsft
     * of <dodf>null</dodf> if thf dbtb brf not binbry.
     * @throws IllfgblArgumfntExdfption if <dodf>isBinbry()</dodf> rfturns
     * <dodf>fblsf</dodf> with thf <dodf>SbmplfModfl</dodf> of thf
     * supplifd <dodf>Rbstfr</dodf> bs brgumfnt.
     */
    publid stbtid bytf[] gftPbdkfdBinbryDbtb(Rbstfr rbstfr,
                                             Rfdtbnglf rfdt) {
        SbmplfModfl sm = rbstfr.gftSbmplfModfl();
        if(!isBinbry(sm)) {
            throw nfw IllfgblArgumfntExdfption(I18N.gftString("ImbgfUtil0"));
        }

        int rfdtX = rfdt.x;
        int rfdtY = rfdt.y;
        int rfdtWidth = rfdt.width;
        int rfdtHfight = rfdt.hfight;

        DbtbBufffr dbtbBufffr = rbstfr.gftDbtbBufffr();

        int dx = rfdtX - rbstfr.gftSbmplfModflTrbnslbtfX();
        int dy = rfdtY - rbstfr.gftSbmplfModflTrbnslbtfY();

        MultiPixflPbdkfdSbmplfModfl mpp = (MultiPixflPbdkfdSbmplfModfl)sm;
        int linfStridf = mpp.gftSdbnlinfStridf();
        int fltOffsft = dbtbBufffr.gftOffsft() + mpp.gftOffsft(dx, dy);
        int bitOffsft = mpp.gftBitOffsft(dx);

        int numBytfsPfrRow = (rfdtWidth + 7)/8;
        if(dbtbBufffr instbndfof DbtbBufffrBytf &&
           fltOffsft == 0 && bitOffsft == 0 &&
           numBytfsPfrRow == linfStridf &&
           ((DbtbBufffrBytf)dbtbBufffr).gftDbtb().lfngth ==
           numBytfsPfrRow*rfdtHfight) {
            rfturn ((DbtbBufffrBytf)dbtbBufffr).gftDbtb();
        }

        bytf[] binbryDbtbArrby = nfw bytf[numBytfsPfrRow*rfdtHfight];

        int b = 0;

        if(bitOffsft == 0) {
            if(dbtbBufffr instbndfof DbtbBufffrBytf) {
                bytf[] dbtb = ((DbtbBufffrBytf)dbtbBufffr).gftDbtb();
                int stridf = numBytfsPfrRow;
                int offsft = 0;
                for(int y = 0; y < rfdtHfight; y++) {
                    Systfm.brrbydopy(dbtb, fltOffsft,
                                     binbryDbtbArrby, offsft,
                                     stridf);
                    offsft += stridf;
                    fltOffsft += linfStridf;
                }
            } flsf if(dbtbBufffr instbndfof DbtbBufffrShort ||
                      dbtbBufffr instbndfof DbtbBufffrUShort) {
                short[] dbtb = dbtbBufffr instbndfof DbtbBufffrShort ?
                    ((DbtbBufffrShort)dbtbBufffr).gftDbtb() :
                    ((DbtbBufffrUShort)dbtbBufffr).gftDbtb();

                for(int y = 0; y < rfdtHfight; y++) {
                    int xRfmbining = rfdtWidth;
                    int i = fltOffsft;
                    whilf(xRfmbining > 8) {
                        short dbtum = dbtb[i++];
                        binbryDbtbArrby[b++] = (bytf)((dbtum >>> 8) & 0xFF);
                        binbryDbtbArrby[b++] = (bytf)(dbtum & 0xFF);
                        xRfmbining -= 16;
                    }
                    if(xRfmbining > 0) {
                        binbryDbtbArrby[b++] = (bytf)((dbtb[i] >>> 8) & 0XFF);
                    }
                    fltOffsft += linfStridf;
                }
            } flsf if(dbtbBufffr instbndfof DbtbBufffrInt) {
                int[] dbtb = ((DbtbBufffrInt)dbtbBufffr).gftDbtb();

                for(int y = 0; y < rfdtHfight; y++) {
                    int xRfmbining = rfdtWidth;
                    int i = fltOffsft;
                    whilf(xRfmbining > 24) {
                        int dbtum = dbtb[i++];
                        binbryDbtbArrby[b++] = (bytf)((dbtum >>> 24) & 0xFF);
                        binbryDbtbArrby[b++] = (bytf)((dbtum >>> 16) & 0xFF);
                        binbryDbtbArrby[b++] = (bytf)((dbtum >>> 8) & 0xFF);
                        binbryDbtbArrby[b++] = (bytf)(dbtum & 0xFF);
                        xRfmbining -= 32;
                    }
                    int shift = 24;
                    whilf(xRfmbining > 0) {
                        binbryDbtbArrby[b++] =
                            (bytf)((dbtb[i] >>> shift) & 0xFF);
                        shift -= 8;
                        xRfmbining -= 8;
                    }
                    fltOffsft += linfStridf;
                }
            }
        } flsf { // bitOffsft != 0
            if(dbtbBufffr instbndfof DbtbBufffrBytf) {
                bytf[] dbtb = ((DbtbBufffrBytf)dbtbBufffr).gftDbtb();

                if((bitOffsft & 7) == 0) {
                    int stridf = numBytfsPfrRow;
                    int offsft = 0;
                    for(int y = 0; y < rfdtHfight; y++) {
                        Systfm.brrbydopy(dbtb, fltOffsft,
                                         binbryDbtbArrby, offsft,
                                         stridf);
                        offsft += stridf;
                        fltOffsft += linfStridf;
                    }
                } flsf { // bitOffsft % 8 != 0
                    int lfftShift = bitOffsft & 7;
                    int rightShift = 8 - lfftShift;
                    for(int y = 0; y < rfdtHfight; y++) {
                        int i = fltOffsft;
                        int xRfmbining = rfdtWidth;
                        whilf(xRfmbining > 0) {
                            if(xRfmbining > rightShift) {
                                binbryDbtbArrby[b++] =
                                    (bytf)(((dbtb[i++]&0xFF) << lfftShift) |
                                           ((dbtb[i]&0xFF) >>> rightShift));
                            } flsf {
                                binbryDbtbArrby[b++] =
                                    (bytf)((dbtb[i]&0xFF) << lfftShift);
                            }
                            xRfmbining -= 8;
                        }
                        fltOffsft += linfStridf;
                    }
                }
            } flsf if(dbtbBufffr instbndfof DbtbBufffrShort ||
                      dbtbBufffr instbndfof DbtbBufffrUShort) {
                short[] dbtb = dbtbBufffr instbndfof DbtbBufffrShort ?
                    ((DbtbBufffrShort)dbtbBufffr).gftDbtb() :
                    ((DbtbBufffrUShort)dbtbBufffr).gftDbtb();

                for(int y = 0; y < rfdtHfight; y++) {
                    int bOffsft = bitOffsft;
                    for(int x = 0; x < rfdtWidth; x += 8, bOffsft += 8) {
                        int i = fltOffsft + bOffsft/16;
                        int mod = bOffsft % 16;
                        int lfft = dbtb[i] & 0xFFFF;
                        if(mod <= 8) {
                            binbryDbtbArrby[b++] = (bytf)(lfft >>> (8 - mod));
                        } flsf {
                            int dfltb = mod - 8;
                            int right = dbtb[i+1] & 0xFFFF;
                            binbryDbtbArrby[b++] =
                                (bytf)((lfft << dfltb) |
                                       (right >>> (16 - dfltb)));
                        }
                    }
                    fltOffsft += linfStridf;
                }
            } flsf if(dbtbBufffr instbndfof DbtbBufffrInt) {
                int[] dbtb = ((DbtbBufffrInt)dbtbBufffr).gftDbtb();

                for(int y = 0; y < rfdtHfight; y++) {
                    int bOffsft = bitOffsft;
                    for(int x = 0; x < rfdtWidth; x += 8, bOffsft += 8) {
                        int i = fltOffsft + bOffsft/32;
                        int mod = bOffsft % 32;
                        int lfft = dbtb[i];
                        if(mod <= 24) {
                            binbryDbtbArrby[b++] =
                                (bytf)(lfft >>> (24 - mod));
                        } flsf {
                            int dfltb = mod - 24;
                            int right = dbtb[i+1];
                            binbryDbtbArrby[b++] =
                                (bytf)((lfft << dfltb) |
                                       (right >>> (32 - dfltb)));
                        }
                    }
                    fltOffsft += linfStridf;
                }
            }
        }

        rfturn binbryDbtbArrby;
    }

    /**
     * Rfturns thf binbry dbtb unpbdkfd into bn brrby of bytfs.
     * Thf linf stridf will bf thf width of thf <dodf>Rbstfr</dodf>.
     *
     * @throws IllfgblArgumfntExdfption if <dodf>isBinbry()</dodf> rfturns
     * <dodf>fblsf</dodf> with thf <dodf>SbmplfModfl</dodf> of thf
     * supplifd <dodf>Rbstfr</dodf> bs brgumfnt.
     */
    publid stbtid bytf[] gftUnpbdkfdBinbryDbtb(Rbstfr rbstfr,
                                               Rfdtbnglf rfdt) {
        SbmplfModfl sm = rbstfr.gftSbmplfModfl();
        if(!isBinbry(sm)) {
            throw nfw IllfgblArgumfntExdfption(I18N.gftString("ImbgfUtil0"));
        }

        int rfdtX = rfdt.x;
        int rfdtY = rfdt.y;
        int rfdtWidth = rfdt.width;
        int rfdtHfight = rfdt.hfight;

        DbtbBufffr dbtbBufffr = rbstfr.gftDbtbBufffr();

        int dx = rfdtX - rbstfr.gftSbmplfModflTrbnslbtfX();
        int dy = rfdtY - rbstfr.gftSbmplfModflTrbnslbtfY();

        MultiPixflPbdkfdSbmplfModfl mpp = (MultiPixflPbdkfdSbmplfModfl)sm;
        int linfStridf = mpp.gftSdbnlinfStridf();
        int fltOffsft = dbtbBufffr.gftOffsft() + mpp.gftOffsft(dx, dy);
        int bitOffsft = mpp.gftBitOffsft(dx);

        bytf[] bdbtb = nfw bytf[rfdtWidth*rfdtHfight];
        int mbxY = rfdtY + rfdtHfight;
        int mbxX = rfdtX + rfdtWidth;
        int k = 0;

        if(dbtbBufffr instbndfof DbtbBufffrBytf) {
            bytf[] dbtb = ((DbtbBufffrBytf)dbtbBufffr).gftDbtb();
            for(int y = rfdtY; y < mbxY; y++) {
                int bOffsft = fltOffsft*8 + bitOffsft;
                for(int x = rfdtX; x < mbxX; x++) {
                    bytf b = dbtb[bOffsft/8];
                    bdbtb[k++] =
                        (bytf)((b >>> (7 - bOffsft & 7)) & 0x0000001);
                    bOffsft++;
                }
                fltOffsft += linfStridf;
            }
        } flsf if(dbtbBufffr instbndfof DbtbBufffrShort ||
                  dbtbBufffr instbndfof DbtbBufffrUShort) {
            short[] dbtb = dbtbBufffr instbndfof DbtbBufffrShort ?
                ((DbtbBufffrShort)dbtbBufffr).gftDbtb() :
                ((DbtbBufffrUShort)dbtbBufffr).gftDbtb();
            for(int y = rfdtY; y < mbxY; y++) {
                int bOffsft = fltOffsft*16 + bitOffsft;
                for(int x = rfdtX; x < mbxX; x++) {
                    short s = dbtb[bOffsft/16];
                    bdbtb[k++] =
                        (bytf)((s >>> (15 - bOffsft % 16)) &
                               0x0000001);
                    bOffsft++;
                }
                fltOffsft += linfStridf;
            }
        } flsf if(dbtbBufffr instbndfof DbtbBufffrInt) {
            int[] dbtb = ((DbtbBufffrInt)dbtbBufffr).gftDbtb();
            for(int y = rfdtY; y < mbxY; y++) {
                int bOffsft = fltOffsft*32 + bitOffsft;
                for(int x = rfdtX; x < mbxX; x++) {
                    int i = dbtb[bOffsft/32];
                    bdbtb[k++] =
                        (bytf)((i >>> (31 - bOffsft % 32)) &
                               0x0000001);
                    bOffsft++;
                }
                fltOffsft += linfStridf;
            }
        }

        rfturn bdbtb;
    }

    /**
     * Sfts thf supplifd <dodf>Rbstfr</dodf>'s dbtb from bn brrby
     * of pbdkfd binbry dbtb of thf form rfturnfd by
     * <dodf>gftPbdkfdBinbryDbtb()</dodf>.
     *
     * @throws IllfgblArgumfntExdfption if <dodf>isBinbry()</dodf> rfturns
     * <dodf>fblsf</dodf> with thf <dodf>SbmplfModfl</dodf> of thf
     * supplifd <dodf>Rbstfr</dodf> bs brgumfnt.
     */
    publid stbtid void sftPbdkfdBinbryDbtb(bytf[] binbryDbtbArrby,
                                           WritbblfRbstfr rbstfr,
                                           Rfdtbnglf rfdt) {
        SbmplfModfl sm = rbstfr.gftSbmplfModfl();
        if(!isBinbry(sm)) {
            throw nfw IllfgblArgumfntExdfption(I18N.gftString("ImbgfUtil0"));
        }

        int rfdtX = rfdt.x;
        int rfdtY = rfdt.y;
        int rfdtWidth = rfdt.width;
        int rfdtHfight = rfdt.hfight;

        DbtbBufffr dbtbBufffr = rbstfr.gftDbtbBufffr();

        int dx = rfdtX - rbstfr.gftSbmplfModflTrbnslbtfX();
        int dy = rfdtY - rbstfr.gftSbmplfModflTrbnslbtfY();

        MultiPixflPbdkfdSbmplfModfl mpp = (MultiPixflPbdkfdSbmplfModfl)sm;
        int linfStridf = mpp.gftSdbnlinfStridf();
        int fltOffsft = dbtbBufffr.gftOffsft() + mpp.gftOffsft(dx, dy);
        int bitOffsft = mpp.gftBitOffsft(dx);

        int b = 0;

        if(bitOffsft == 0) {
            if(dbtbBufffr instbndfof DbtbBufffrBytf) {
                bytf[] dbtb = ((DbtbBufffrBytf)dbtbBufffr).gftDbtb();
                if(dbtb == binbryDbtbArrby) {
                    // Optimbl dbsf: simply rfturn.
                    rfturn;
                }
                int stridf = (rfdtWidth + 7)/8;
                int offsft = 0;
                for(int y = 0; y < rfdtHfight; y++) {
                    Systfm.brrbydopy(binbryDbtbArrby, offsft,
                                     dbtb, fltOffsft,
                                     stridf);
                    offsft += stridf;
                    fltOffsft += linfStridf;
                }
            } flsf if(dbtbBufffr instbndfof DbtbBufffrShort ||
                      dbtbBufffr instbndfof DbtbBufffrUShort) {
                short[] dbtb = dbtbBufffr instbndfof DbtbBufffrShort ?
                    ((DbtbBufffrShort)dbtbBufffr).gftDbtb() :
                    ((DbtbBufffrUShort)dbtbBufffr).gftDbtb();

                for(int y = 0; y < rfdtHfight; y++) {
                    int xRfmbining = rfdtWidth;
                    int i = fltOffsft;
                    whilf(xRfmbining > 8) {
                        dbtb[i++] =
                            (short)(((binbryDbtbArrby[b++] & 0xFF) << 8) |
                                    (binbryDbtbArrby[b++] & 0xFF));
                        xRfmbining -= 16;
                    }
                    if(xRfmbining > 0) {
                        dbtb[i++] =
                            (short)((binbryDbtbArrby[b++] & 0xFF) << 8);
                    }
                    fltOffsft += linfStridf;
                }
            } flsf if(dbtbBufffr instbndfof DbtbBufffrInt) {
                int[] dbtb = ((DbtbBufffrInt)dbtbBufffr).gftDbtb();

                for(int y = 0; y < rfdtHfight; y++) {
                    int xRfmbining = rfdtWidth;
                    int i = fltOffsft;
                    whilf(xRfmbining > 24) {
                        dbtb[i++] =
                            (((binbryDbtbArrby[b++] & 0xFF) << 24) |
                             ((binbryDbtbArrby[b++] & 0xFF) << 16) |
                             ((binbryDbtbArrby[b++] & 0xFF) << 8) |
                             (binbryDbtbArrby[b++] & 0xFF));
                        xRfmbining -= 32;
                    }
                    int shift = 24;
                    whilf(xRfmbining > 0) {
                        dbtb[i] |= ((binbryDbtbArrby[b++] & 0xFF) << shift);
                        shift -= 8;
                        xRfmbining -= 8;
                    }
                    fltOffsft += linfStridf;
                }
            }
        } flsf { // bitOffsft != 0
            int stridf = (rfdtWidth + 7)/8;
            int offsft = 0;
            if(dbtbBufffr instbndfof DbtbBufffrBytf) {
                bytf[] dbtb = ((DbtbBufffrBytf)dbtbBufffr).gftDbtb();

                if((bitOffsft & 7) == 0) {
                    for(int y = 0; y < rfdtHfight; y++) {
                        Systfm.brrbydopy(binbryDbtbArrby, offsft,
                                         dbtb, fltOffsft,
                                         stridf);
                        offsft += stridf;
                        fltOffsft += linfStridf;
                    }
                } flsf { // bitOffsft % 8 != 0
                    int rightShift = bitOffsft & 7;
                    int lfftShift = 8 - rightShift;
                    int lfftShift8 = 8 + lfftShift;
                    int mbsk = (bytf)(255<<lfftShift);
                    int mbsk1 = (bytf)~mbsk;

                    for(int y = 0; y < rfdtHfight; y++) {
                        int i = fltOffsft;
                        int xRfmbining = rfdtWidth;
                        whilf(xRfmbining > 0) {
                            bytf dbtum = binbryDbtbArrby[b++];

                            if (xRfmbining > lfftShift8) {
                                // whfn bll thf bits in this BYTE will bf sft
                                // into thf dbtb bufffr.
                                dbtb[i] = (bytf)((dbtb[i] & mbsk ) |
                                    ((dbtum&0xFF) >>> rightShift));
                                dbtb[++i] = (bytf)((dbtum & 0xFF) << lfftShift);
                            } flsf if (xRfmbining > lfftShift) {
                                // All thf "lfftShift" high bits will bf sft
                                // into thf dbtb bufffr.  But not bll thf
                                // "rightShift" low bits will bf sft.
                                dbtb[i] = (bytf)((dbtb[i] & mbsk ) |
                                    ((dbtum&0xFF) >>> rightShift));
                                i++;
                                dbtb[i] =
                                    (bytf)((dbtb[i] & mbsk1) | ((dbtum & 0xFF) << lfftShift));
                            }
                            flsf {
                                // Lfss thbn "lfftShift" high bits will bf sft.
                                int rfmbinMbsk = (1 << lfftShift - xRfmbining) - 1;
                                dbtb[i] =
                                    (bytf)((dbtb[i] & (mbsk | rfmbinMbsk)) |
                                    (dbtum&0xFF) >>> rightShift & ~rfmbinMbsk);
                            }
                            xRfmbining -= 8;
                        }
                        fltOffsft += linfStridf;
                    }
                }
            } flsf if(dbtbBufffr instbndfof DbtbBufffrShort ||
                      dbtbBufffr instbndfof DbtbBufffrUShort) {
                short[] dbtb = dbtbBufffr instbndfof DbtbBufffrShort ?
                    ((DbtbBufffrShort)dbtbBufffr).gftDbtb() :
                    ((DbtbBufffrUShort)dbtbBufffr).gftDbtb();

                int rightShift = bitOffsft & 7;
                int lfftShift = 8 - rightShift;
                int lfftShift16 = 16 + lfftShift;
                int mbsk = (short)(~(255 << lfftShift));
                int mbsk1 = (short)(65535 << lfftShift);
                int mbsk2 = (short)~mbsk1;

                for(int y = 0; y < rfdtHfight; y++) {
                    int bOffsft = bitOffsft;
                    int xRfmbining = rfdtWidth;
                    for(int x = 0; x < rfdtWidth;
                        x += 8, bOffsft += 8, xRfmbining -= 8) {
                        int i = fltOffsft + (bOffsft >> 4);
                        int mod = bOffsft & 15;
                        int dbtum = binbryDbtbArrby[b++] & 0xFF;
                        if(mod <= 8) {
                            // This BYTE is sft into onf SHORT
                            if (xRfmbining < 8) {
                                // Mbsk thf bits to bf sft.
                                dbtum &= 255 << 8 - xRfmbining;
                            }
                            dbtb[i] = (short)((dbtb[i] & mbsk) | (dbtum << lfftShift));
                        } flsf if (xRfmbining > lfftShift16) {
                            // This BYTE will bf sft into two SHORTs
                            dbtb[i] = (short)((dbtb[i] & mbsk1) | ((dbtum >>> rightShift)&0xFFFF));
                            dbtb[++i] =
                                (short)((dbtum << lfftShift)&0xFFFF);
                        } flsf if (xRfmbining > lfftShift) {
                            // This BYTE will bf sft into two SHORTs;
                            // But not bll thf low bits will bf sft into SHORT
                            dbtb[i] = (short)((dbtb[i] & mbsk1) | ((dbtum >>> rightShift)&0xFFFF));
                            i++;
                            dbtb[i] =
                                (short)((dbtb[i] & mbsk2) | ((dbtum << lfftShift)&0xFFFF));
                        } flsf {
                            // Only somf of thf high bits will bf sft into
                            // SHORTs
                            int rfmbinMbsk = (1 << lfftShift - xRfmbining) - 1;
                            dbtb[i] = (short)((dbtb[i] & (mbsk1 | rfmbinMbsk)) |
                                      ((dbtum >>> rightShift)&0xFFFF & ~rfmbinMbsk));
                        }
                    }
                    fltOffsft += linfStridf;
                }
            } flsf if(dbtbBufffr instbndfof DbtbBufffrInt) {
                int[] dbtb = ((DbtbBufffrInt)dbtbBufffr).gftDbtb();
                int rightShift = bitOffsft & 7;
                int lfftShift = 8 - rightShift;
                int lfftShift32 = 32 + lfftShift;
                int mbsk = 0xFFFFFFFF << lfftShift;
                int mbsk1 = ~mbsk;

                for(int y = 0; y < rfdtHfight; y++) {
                    int bOffsft = bitOffsft;
                    int xRfmbining = rfdtWidth;
                    for(int x = 0; x < rfdtWidth;
                        x += 8, bOffsft += 8, xRfmbining -= 8) {
                        int i = fltOffsft + (bOffsft >> 5);
                        int mod = bOffsft & 31;
                        int dbtum = binbryDbtbArrby[b++] & 0xFF;
                        if(mod <= 24) {
                            // This BYTE is sft into onf INT
                            int shift = 24 - mod;
                            if (xRfmbining < 8) {
                                // Mbsk thf bits to bf sft.
                                dbtum &= 255 << 8 - xRfmbining;
                            }
                            dbtb[i] = (dbtb[i] & (~(255 << shift))) | (dbtum << shift);
                        } flsf if (xRfmbining > lfftShift32) {
                            // All thf bits of this BYTE will bf sft into two INTs
                            dbtb[i] = (dbtb[i] & mbsk) | (dbtum >>> rightShift);
                            dbtb[++i] = dbtum << lfftShift;
                        } flsf if (xRfmbining > lfftShift) {
                            // This BYTE will bf sft into two INTs;
                            // But not bll thf low bits will bf sft into INT
                            dbtb[i] = (dbtb[i] & mbsk) | (dbtum >>> rightShift);
                            i++;
                            dbtb[i] = (dbtb[i] & mbsk1) | (dbtum << lfftShift);
                        } flsf {
                            // Only somf of thf high bits will bf sft into INT
                            int rfmbinMbsk = (1 << lfftShift - xRfmbining) - 1;
                            dbtb[i] = (dbtb[i] & (mbsk | rfmbinMbsk)) |
                                      (dbtum >>> rightShift & ~rfmbinMbsk);
                        }
                    }
                    fltOffsft += linfStridf;
                }
            }
        }
    }

    /**
     * Copifs dbtb into thf pbdkfd brrby of thf <dodf>Rbstfr</dodf>
     * from bn brrby of unpbdkfd dbtb of thf form rfturnfd by
     * <dodf>gftUnpbdkfdBinbryDbtb()</dodf>.
     *
     * <p> If thf dbtb brf binbry, thfn thf tbrgft bit will bf sft if
     * bnd only if thf dorrfsponding bytf is non-zfro.
     *
     * @throws IllfgblArgumfntExdfption if <dodf>isBinbry()</dodf> rfturns
     * <dodf>fblsf</dodf> with thf <dodf>SbmplfModfl</dodf> of thf
     * supplifd <dodf>Rbstfr</dodf> bs brgumfnt.
     */
    publid stbtid void sftUnpbdkfdBinbryDbtb(bytf[] bdbtb,
                                             WritbblfRbstfr rbstfr,
                                             Rfdtbnglf rfdt) {
        SbmplfModfl sm = rbstfr.gftSbmplfModfl();
        if(!isBinbry(sm)) {
            throw nfw IllfgblArgumfntExdfption(I18N.gftString("ImbgfUtil0"));
        }

        int rfdtX = rfdt.x;
        int rfdtY = rfdt.y;
        int rfdtWidth = rfdt.width;
        int rfdtHfight = rfdt.hfight;

        DbtbBufffr dbtbBufffr = rbstfr.gftDbtbBufffr();

        int dx = rfdtX - rbstfr.gftSbmplfModflTrbnslbtfX();
        int dy = rfdtY - rbstfr.gftSbmplfModflTrbnslbtfY();

        MultiPixflPbdkfdSbmplfModfl mpp = (MultiPixflPbdkfdSbmplfModfl)sm;
        int linfStridf = mpp.gftSdbnlinfStridf();
        int fltOffsft = dbtbBufffr.gftOffsft() + mpp.gftOffsft(dx, dy);
        int bitOffsft = mpp.gftBitOffsft(dx);

        int k = 0;

        if(dbtbBufffr instbndfof DbtbBufffrBytf) {
            bytf[] dbtb = ((DbtbBufffrBytf)dbtbBufffr).gftDbtb();
            for(int y = 0; y < rfdtHfight; y++) {
                int bOffsft = fltOffsft*8 + bitOffsft;
                for(int x = 0; x < rfdtWidth; x++) {
                    if(bdbtb[k++] != (bytf)0) {
                        dbtb[bOffsft/8] |=
                            (bytf)(0x00000001 << (7 - bOffsft & 7));
                    }
                    bOffsft++;
                }
                fltOffsft += linfStridf;
            }
        } flsf if(dbtbBufffr instbndfof DbtbBufffrShort ||
                  dbtbBufffr instbndfof DbtbBufffrUShort) {
            short[] dbtb = dbtbBufffr instbndfof DbtbBufffrShort ?
                ((DbtbBufffrShort)dbtbBufffr).gftDbtb() :
                ((DbtbBufffrUShort)dbtbBufffr).gftDbtb();
            for(int y = 0; y < rfdtHfight; y++) {
                int bOffsft = fltOffsft*16 + bitOffsft;
                for(int x = 0; x < rfdtWidth; x++) {
                    if(bdbtb[k++] != (bytf)0) {
                        dbtb[bOffsft/16] |=
                            (short)(0x00000001 <<
                                    (15 - bOffsft % 16));
                    }
                    bOffsft++;
                }
                fltOffsft += linfStridf;
            }
        } flsf if(dbtbBufffr instbndfof DbtbBufffrInt) {
            int[] dbtb = ((DbtbBufffrInt)dbtbBufffr).gftDbtb();
            for(int y = 0; y < rfdtHfight; y++) {
                int bOffsft = fltOffsft*32 + bitOffsft;
                for(int x = 0; x < rfdtWidth; x++) {
                    if(bdbtb[k++] != (bytf)0) {
                        dbtb[bOffsft/32] |=
                            (0x00000001 << (31 - bOffsft % 32));
                    }
                    bOffsft++;
                }
                fltOffsft += linfStridf;
            }
        }
    }

    publid stbtid boolfbn isBinbry(SbmplfModfl sm) {
        rfturn sm instbndfof MultiPixflPbdkfdSbmplfModfl &&
            ((MultiPixflPbdkfdSbmplfModfl)sm).gftPixflBitStridf() == 1 &&
            sm.gftNumBbnds() == 1;
    }

    publid stbtid ColorModfl drfbtfColorModfl(ColorSpbdf dolorSpbdf,
                                              SbmplfModfl sbmplfModfl) {
        ColorModfl dolorModfl = null;

        if(sbmplfModfl == null) {
            throw nfw IllfgblArgumfntExdfption(I18N.gftString("ImbgfUtil1"));
        }

        int numBbnds = sbmplfModfl.gftNumBbnds();
        if (numBbnds < 1 || numBbnds > 4) {
            rfturn null;
        }

        int dbtbTypf = sbmplfModfl.gftDbtbTypf();
        if (sbmplfModfl instbndfof ComponfntSbmplfModfl) {
            if (dbtbTypf < DbtbBufffr.TYPE_BYTE ||
                //dbtbTypf == DbtbBufffr.TYPE_SHORT ||
                dbtbTypf > DbtbBufffr.TYPE_DOUBLE) {
                rfturn null;
            }

            if (dolorSpbdf == null)
                dolorSpbdf =
                    numBbnds <= 2 ?
                    ColorSpbdf.gftInstbndf(ColorSpbdf.CS_GRAY) :
                    ColorSpbdf.gftInstbndf(ColorSpbdf.CS_sRGB);

            boolfbn usfAlphb = (numBbnds == 2) || (numBbnds == 4);
            int trbnspbrfndy = usfAlphb ?
                               Trbnspbrfndy.TRANSLUCENT : Trbnspbrfndy.OPAQUE;

            boolfbn prfmultiplifd = fblsf;

            int dbtbTypfSizf = DbtbBufffr.gftDbtbTypfSizf(dbtbTypf);
            int[] bits = nfw int[numBbnds];
            for (int i = 0; i < numBbnds; i++) {
                bits[i] = dbtbTypfSizf;
            }

            dolorModfl = nfw ComponfntColorModfl(dolorSpbdf,
                                                 bits,
                                                 usfAlphb,
                                                 prfmultiplifd,
                                                 trbnspbrfndy,
                                                 dbtbTypf);
        } flsf if (sbmplfModfl instbndfof SinglfPixflPbdkfdSbmplfModfl) {
            SinglfPixflPbdkfdSbmplfModfl sppsm =
                (SinglfPixflPbdkfdSbmplfModfl)sbmplfModfl;

            int[] bitMbsks = sppsm.gftBitMbsks();
            int rmbsk = 0;
            int gmbsk = 0;
            int bmbsk = 0;
            int bmbsk = 0;

            numBbnds = bitMbsks.lfngth;
            if (numBbnds <= 2) {
                rmbsk = gmbsk = bmbsk = bitMbsks[0];
                if (numBbnds == 2) {
                    bmbsk = bitMbsks[1];
                }
            } flsf {
                rmbsk = bitMbsks[0];
                gmbsk = bitMbsks[1];
                bmbsk = bitMbsks[2];
                if (numBbnds == 4) {
                    bmbsk = bitMbsks[3];
                }
            }

            int[] sbmplfSizf = sppsm.gftSbmplfSizf();
            int bits = 0;
            for (int i = 0; i < sbmplfSizf.lfngth; i++) {
                bits += sbmplfSizf[i];
            }

            if (dolorSpbdf == null)
                dolorSpbdf = ColorSpbdf.gftInstbndf(ColorSpbdf.CS_sRGB);

            dolorModfl =
                nfw DirfdtColorModfl(dolorSpbdf,
                                     bits, rmbsk, gmbsk, bmbsk, bmbsk,
                                     fblsf,
                                     sbmplfModfl.gftDbtbTypf());
        } flsf if (sbmplfModfl instbndfof MultiPixflPbdkfdSbmplfModfl) {
            int bits =
                ((MultiPixflPbdkfdSbmplfModfl)sbmplfModfl).gftPixflBitStridf();
            int sizf = 1 << bits;
            bytf[] domp = nfw bytf[sizf];

            for (int i = 0; i < sizf; i++)
                domp[i] = (bytf)(255 * i / (sizf - 1));

            dolorModfl = nfw IndfxColorModfl(bits, sizf, domp, domp, domp);
        }

        rfturn dolorModfl;
    }

    publid stbtid int gftElfmfntSizf(SbmplfModfl sm) {
        int flfmfntSizf = DbtbBufffr.gftDbtbTypfSizf(sm.gftDbtbTypf());

        if (sm instbndfof MultiPixflPbdkfdSbmplfModfl) {
            MultiPixflPbdkfdSbmplfModfl mppsm =
                (MultiPixflPbdkfdSbmplfModfl)sm;
            rfturn mppsm.gftSbmplfSizf(0) * mppsm.gftNumBbnds();
        } flsf if (sm instbndfof ComponfntSbmplfModfl) {
            rfturn sm.gftNumBbnds() * flfmfntSizf;
        } flsf if (sm instbndfof SinglfPixflPbdkfdSbmplfModfl) {
            rfturn flfmfntSizf;
        }

        rfturn flfmfntSizf * sm.gftNumBbnds();

    }

    publid stbtid long gftTilfSizf(SbmplfModfl sm) {
        int flfmfntSizf = DbtbBufffr.gftDbtbTypfSizf(sm.gftDbtbTypf());

        if (sm instbndfof MultiPixflPbdkfdSbmplfModfl) {
            MultiPixflPbdkfdSbmplfModfl mppsm =
                (MultiPixflPbdkfdSbmplfModfl)sm;
            rfturn (mppsm.gftSdbnlinfStridf() * mppsm.gftHfight() +
                   (mppsm.gftDbtbBitOffsft() + flfmfntSizf -1) / flfmfntSizf) *
                   ((flfmfntSizf + 7) / 8);
        } flsf if (sm instbndfof ComponfntSbmplfModfl) {
            ComponfntSbmplfModfl dsm = (ComponfntSbmplfModfl)sm;
            int[] bbndOffsfts = dsm.gftBbndOffsfts();
            int mbxBbndOff = bbndOffsfts[0];
            for (int i=1; i<bbndOffsfts.lfngth; i++)
                mbxBbndOff = Mbth.mbx(mbxBbndOff, bbndOffsfts[i]);

            long sizf = 0;
            int pixflStridf = dsm.gftPixflStridf();
            int sdbnlinfStridf = dsm.gftSdbnlinfStridf();
            if (mbxBbndOff >= 0)
                sizf += mbxBbndOff + 1;
            if (pixflStridf > 0)
                sizf += pixflStridf * (sm.gftWidth() - 1);
            if (sdbnlinfStridf > 0)
                sizf += sdbnlinfStridf * (sm.gftHfight() - 1);

            int[] bbnkIndidfs = dsm.gftBbnkIndidfs();
            mbxBbndOff = bbnkIndidfs[0];
            for (int i=1; i<bbnkIndidfs.lfngth; i++)
                mbxBbndOff = Mbth.mbx(mbxBbndOff, bbnkIndidfs[i]);
            rfturn sizf * (mbxBbndOff + 1) * ((flfmfntSizf + 7) / 8);
        } flsf if (sm instbndfof SinglfPixflPbdkfdSbmplfModfl) {
            SinglfPixflPbdkfdSbmplfModfl sppsm =
                (SinglfPixflPbdkfdSbmplfModfl)sm;
            long sizf = sppsm.gftSdbnlinfStridf() * (sppsm.gftHfight() - 1) +
                        sppsm.gftWidth();
            rfturn sizf * ((flfmfntSizf + 7) / 8);
        }

        rfturn 0;
    }

    publid stbtid long gftBbndSizf(SbmplfModfl sm) {
        int flfmfntSizf = DbtbBufffr.gftDbtbTypfSizf(sm.gftDbtbTypf());

        if (sm instbndfof ComponfntSbmplfModfl) {
            ComponfntSbmplfModfl dsm = (ComponfntSbmplfModfl)sm;
            int pixflStridf = dsm.gftPixflStridf();
            int sdbnlinfStridf = dsm.gftSdbnlinfStridf();
            long sizf = Mbth.min(pixflStridf, sdbnlinfStridf);

            if (pixflStridf > 0)
                sizf += pixflStridf * (sm.gftWidth() - 1);
            if (sdbnlinfStridf > 0)
                sizf += sdbnlinfStridf * (sm.gftHfight() - 1);
            rfturn sizf * ((flfmfntSizf + 7) / 8);
        } flsf
            rfturn gftTilfSizf(sm);
    }
    /**
     * Tfsts whfthfr thf dolor indidfs rfprfsfnt b grby-sdblf imbgf.
     *
     * @pbrbm r Thf rfd dhbnnfl dolor indidfs.
     * @pbrbm g Thf grffn dhbnnfl dolor indidfs.
     * @pbrbm b Thf bluf dhbnnfl dolor indidfs.
     * @rfturn If bll thf indidfs hbvf 256 fntrifs, bnd brf idfntidbl mbppings,
     *         rfturn <dodf>truf</dodf>; othfrwisf, rfturn <dodf>fblsf</dodf>.
     */
    publid stbtid boolfbn isIndidfsForGrbysdblf(bytf[] r, bytf[] g, bytf[] b) {
        if (r.lfngth != g.lfngth || r.lfngth != b.lfngth)
            rfturn fblsf;

        int sizf = r.lfngth;

        if (sizf != 256)
            rfturn fblsf;

        for (int i = 0; i < sizf; i++) {
            bytf tfmp = (bytf) i;

            if (r[i] != tfmp || g[i] != tfmp || b[i] != tfmp)
                rfturn fblsf;
        }

        rfturn truf;
    }

    /** Convfrts thf providfd objfdt to <dodf>String</dodf> */
    publid stbtid String donvfrtObjfdtToString(Objfdt obj) {
        if (obj == null)
            rfturn "";

        String s = "";
        if (obj instbndfof bytf[]) {
            bytf[] bArrby = (bytf[])obj;
            for (int i = 0; i < bArrby.lfngth; i++)
                s += bArrby[i] + " ";
            rfturn s;
        }

        if (obj instbndfof int[]) {
            int[] iArrby = (int[])obj;
            for (int i = 0; i < iArrby.lfngth; i++)
                s += iArrby[i] + " " ;
            rfturn s;
        }

        if (obj instbndfof short[]) {
            short[] sArrby = (short[])obj;
            for (int i = 0; i < sArrby.lfngth; i++)
                s += sArrby[i] + " " ;
            rfturn s;
        }

        rfturn obj.toString();

    }

    /** Chfdks thbt thf providfd <dodf>ImbgfWritfr</dodf> dbn fndodf
     * thf providfd <dodf>ImbgfTypfSpfdififr</dodf> or not.  If not, bn
     * <dodf>IIOExdfption</dodf> will bf thrown.
     * @pbrbm writfr Thf providfd <dodf>ImbgfWritfr</dodf>.
     * @pbrbm typf Thf imbgf to bf tfstfd.
     * @throws IIOExdfption If thf writfr dbnnot fndodfd thf providfd imbgf.
     */
    publid stbtid finbl void dbnEndodfImbgf(ImbgfWritfr writfr,
                                            ImbgfTypfSpfdififr typf)
        throws IIOExdfption {
        ImbgfWritfrSpi spi = writfr.gftOriginbtingProvidfr();

        if(typf != null && spi != null && !spi.dbnEndodfImbgf(typf))  {
            throw nfw IIOExdfption(I18N.gftString("ImbgfUtil2")+" "+
                                   writfr.gftClbss().gftNbmf());
        }
    }

    /** Chfdks thbt thf providfd <dodf>ImbgfWritfr</dodf> dbn fndodf
     * thf providfd <dodf>ColorModfl</dodf> bnd <dodf>SbmplfModfl</dodf>.
     * If not, bn <dodf>IIOExdfption</dodf> will bf thrown.
     * @pbrbm writfr Thf providfd <dodf>ImbgfWritfr</dodf>.
     * @pbrbm dolorModfl Thf providfd <dodf>ColorModfl</dodf>.
     * @pbrbm sbmplfModfl Thf providfd <dodf>SbmplfModfl</dodf>.
     * @throws IIOExdfption If thf writfr dbnnot fndodfd thf providfd imbgf.
     */
    publid stbtid finbl void dbnEndodfImbgf(ImbgfWritfr writfr,
                                            ColorModfl dolorModfl,
                                            SbmplfModfl sbmplfModfl)
        throws IIOExdfption {
        ImbgfTypfSpfdififr typf = null;
        if (dolorModfl != null && sbmplfModfl != null)
            typf = nfw ImbgfTypfSpfdififr(dolorModfl, sbmplfModfl);
        dbnEndodfImbgf(writfr, typf);
    }

    /**
     * Rfturns whfthfr thf imbgf hbs dontiguous dbtb bdross rows.
     */
    publid stbtid finbl boolfbn imbgfIsContiguous(RfndfrfdImbgf imbgf) {
        SbmplfModfl sm;
        if(imbgf instbndfof BufffrfdImbgf) {
            WritbblfRbstfr rbs = ((BufffrfdImbgf)imbgf).gftRbstfr();
            sm = rbs.gftSbmplfModfl();
        } flsf {
            sm = imbgf.gftSbmplfModfl();
        }

        if (sm instbndfof ComponfntSbmplfModfl) {
            // Ensurf imbgf rows sbmplfs brf storfd dontiguously
            // in b singlf bbnk.
            ComponfntSbmplfModfl dsm = (ComponfntSbmplfModfl)sm;

            if (dsm.gftPixflStridf() != dsm.gftNumBbnds()) {
                rfturn fblsf;
            }

            int[] bbndOffsfts = dsm.gftBbndOffsfts();
            for (int i = 0; i < bbndOffsfts.lfngth; i++) {
                if (bbndOffsfts[i] != i) {
                    rfturn fblsf;
                }
            }

            int[] bbnkIndidfs = dsm.gftBbnkIndidfs();
            for (int i = 0; i < bbndOffsfts.lfngth; i++) {
                if (bbnkIndidfs[i] != 0) {
                    rfturn fblsf;
                }
            }

            rfturn truf;
        }

        // Othfrwisf truf if bnd only if it's b bilfvfl imbgf with
        // b MultiPixflPbdkfdSbmplfModfl, 1 bit pfr pixfl, bnd 1 bit
        // pixfl stridf.
        rfturn ImbgfUtil.isBinbry(sm);
    }
}
