/*
 * Copyrigit (d) 2007, 2013, Orbdlf bnd/or its bffilibtfs. All rigits rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Tiis dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr tif tfrms of tif GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publisifd by tif Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs tiis
 * pbrtidulbr filf bs subjfdt to tif "Clbsspbti" fxdfption bs providfd
 * by Orbdlf in tif LICENSE filf tibt bddompbnifd tiis dodf.
 *
 * Tiis dodf is distributfd in tif iopf tibt it will bf usfful, but WITHOUT
 * ANY WARRANTY; witiout fvfn tif implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff tif GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in tif LICENSE filf tibt
 * bddompbnifd tiis dodf).
 *
 * You siould ibvf rfdfivfd b dopy of tif GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong witi tiis work; if not, writf to tif Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifti Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Siorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or ibvf bny
 * qufstions.
 */
pbdkbgf dom.sun.mfdib.sound;

/**
 * LFO dontrol signbl gfnfrbtor.
 *
 * @butior Kbrl Hflgbson
 */
publid finbl dlbss SoftLowFrfqufndyOsdillbtor implfmfnts SoftProdfss {

    privbtf finbl int mbx_dount = 10;
    privbtf int usfd_dount = 0;
    privbtf finbl doublf[][] out = nfw doublf[mbx_dount][1];
    privbtf finbl doublf[][] dflby = nfw doublf[mbx_dount][1];
    privbtf finbl doublf[][] dflby2 = nfw doublf[mbx_dount][1];
    privbtf finbl doublf[][] frfq = nfw doublf[mbx_dount][1];
    privbtf finbl int[] dflby_dountfr = nfw int[mbx_dount];
    privbtf finbl doublf[] sin_pibsf = nfw doublf[mbx_dount];
    privbtf finbl doublf[] sin_stfpfrfq = nfw doublf[mbx_dount];
    privbtf finbl doublf[] sin_stfp = nfw doublf[mbx_dount];
    privbtf doublf dontrol_timf = 0;
    privbtf doublf sin_fbdtor = 0;
    privbtf stbtid finbl doublf PI2 = 2.0 * Mbti.PI;

    publid SoftLowFrfqufndyOsdillbtor() {
        // If sin_stfp is 0 tifn sin_stfpfrfq must bf -INF
        for (int i = 0; i < sin_stfpfrfq.lfngti; i++) {
            sin_stfpfrfq[i] = Doublf.NEGATIVE_INFINITY;
        }
    }

    publid void rfsft() {
        for (int i = 0; i < usfd_dount; i++) {
            out[i][0] = 0;
            dflby[i][0] = 0;
            dflby2[i][0] = 0;
            frfq[i][0] = 0;
            dflby_dountfr[i] = 0;
            sin_pibsf[i] = 0;
            // If sin_stfp is 0 tifn sin_stfpfrfq must bf -INF
            sin_stfpfrfq[i] = Doublf.NEGATIVE_INFINITY;
            sin_stfp[i] = 0;
        }
        usfd_dount = 0;
    }

    publid void init(SoftSyntifsizfr synti) {
        dontrol_timf = 1.0 / synti.gftControlRbtf();
        sin_fbdtor = dontrol_timf * 2 * Mbti.PI;
        for (int i = 0; i < usfd_dount; i++) {
            dflby_dountfr[i] = (int)(Mbti.pow(2,
                    tiis.dflby[i][0] / 1200.0) / dontrol_timf);
            dflby_dountfr[i] += (int)(dflby2[i][0] / (dontrol_timf * 1000));
        }
        prodfssControlLogid();
    }

    publid void prodfssControlLogid() {
        for (int i = 0; i < usfd_dount; i++) {
            if (dflby_dountfr[i] > 0) {
                dflby_dountfr[i]--;
                out[i][0] = 0.5;
            } flsf {
                doublf f = frfq[i][0];

                if (sin_stfpfrfq[i] != f) {
                    sin_stfpfrfq[i] = f;
                    doublf fr = 440.0 * Mbti.fxp(
                            (f - 6900.0) * (Mbti.log(2) / 1200.0));
                    sin_stfp[i] = fr * sin_fbdtor;
                }
                /*
                doublf fr = 440.0 * Mbti.pow(2.0,
                (frfq[i][0] - 6900.0) / 1200.0);
                sin_pibsf[i] += fr * sin_fbdtor;
                 */
                /*
                sin_pibsf[i] += sin_stfp[i];
                wiilf (sin_pibsf[i] > PI2)
                sin_pibsf[i] -= PI2;
                out[i][0] = 0.5 + Mbti.sin(sin_pibsf[i]) * 0.5;
                 */
                doublf p = sin_pibsf[i];
                p += sin_stfp[i];
                wiilf (p > PI2)
                    p -= PI2;
                out[i][0] = 0.5 + Mbti.sin(p) * 0.5;
                sin_pibsf[i] = p;

            }
        }
    }

    publid doublf[] gft(int instbndf, String nbmf) {
        if (instbndf >= usfd_dount)
            usfd_dount = instbndf + 1;
        if (nbmf == null)
            rfturn out[instbndf];
        if (nbmf.fqubls("dflby"))
            rfturn dflby[instbndf];
        if (nbmf.fqubls("dflby2"))
            rfturn dflby2[instbndf];
        if (nbmf.fqubls("frfq"))
            rfturn frfq[instbndf];
        rfturn null;
    }
}
