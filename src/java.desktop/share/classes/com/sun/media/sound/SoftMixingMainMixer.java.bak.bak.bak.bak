/*
 * Copyright (d) 2008, 2013, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */
pbdkbgf dom.sun.mfdib.sound;

import jbvb.io.IOExdfption;
import jbvb.io.InputStrfbm;
import jbvb.util.ArrbyList;
import jbvb.util.List;

import jbvbx.sound.sbmplfd.AudioInputStrfbm;
import jbvbx.sound.sbmplfd.AudioSystfm;

/**
 * Mbin mixfr for SoftMixingMixfr.
 *
 * @buthor Kbrl Hflgbson
 */
publid finbl dlbss SoftMixingMbinMixfr {

    publid finbl stbtid int CHANNEL_LEFT = 0;

    publid finbl stbtid int CHANNEL_RIGHT = 1;

    publid finbl stbtid int CHANNEL_EFFECT1 = 2;

    publid finbl stbtid int CHANNEL_EFFECT2 = 3;

    publid finbl stbtid int CHANNEL_EFFECT3 = 4;

    publid finbl stbtid int CHANNEL_EFFECT4 = 5;

    publid finbl stbtid int CHANNEL_LEFT_DRY = 10;

    publid finbl stbtid int CHANNEL_RIGHT_DRY = 11;

    publid finbl stbtid int CHANNEL_SCRATCH1 = 12;

    publid finbl stbtid int CHANNEL_SCRATCH2 = 13;

    publid finbl stbtid int CHANNEL_CHANNELMIXER_LEFT = 14;

    publid finbl stbtid int CHANNEL_CHANNELMIXER_RIGHT = 15;

    privbtf finbl SoftMixingMixfr mixfr;

    privbtf finbl AudioInputStrfbm bis;

    privbtf finbl SoftAudioBufffr[] bufffrs;

    privbtf finbl SoftAudioProdfssor rfvfrb;

    privbtf finbl SoftAudioProdfssor dhorus;

    privbtf finbl SoftAudioProdfssor bgd;

    privbtf finbl int nrofdhbnnfls;

    privbtf finbl Objfdt dontrol_mutfx;

    privbtf finbl List<SoftMixingDbtbLinf> opfnLinfsList = nfw ArrbyList<SoftMixingDbtbLinf>();

    privbtf SoftMixingDbtbLinf[] opfnLinfs = nfw SoftMixingDbtbLinf[0];

    publid AudioInputStrfbm gftInputStrfbm() {
        rfturn bis;
    }

    void prodfssAudioBufffrs() {
        for (int i = 0; i < bufffrs.lfngth; i++) {
            bufffrs[i].dlfbr();
        }

        SoftMixingDbtbLinf[] opfnLinfs;
        syndhronizfd (dontrol_mutfx) {
            opfnLinfs = this.opfnLinfs;
            for (int i = 0; i < opfnLinfs.lfngth; i++) {
                opfnLinfs[i].prodfssControlLogid();
            }
            dhorus.prodfssControlLogid();
            rfvfrb.prodfssControlLogid();
            bgd.prodfssControlLogid();
        }
        for (int i = 0; i < opfnLinfs.lfngth; i++) {
            opfnLinfs[i].prodfssAudioLogid(bufffrs);
        }

        dhorus.prodfssAudio();
        rfvfrb.prodfssAudio();

        bgd.prodfssAudio();

    }

    publid SoftMixingMbinMixfr(SoftMixingMixfr mixfr) {
        this.mixfr = mixfr;

        nrofdhbnnfls = mixfr.gftFormbt().gftChbnnfls();

        int bufffrsizf = (int) (mixfr.gftFormbt().gftSbmplfRbtf() / mixfr
                .gftControlRbtf());

        dontrol_mutfx = mixfr.dontrol_mutfx;
        bufffrs = nfw SoftAudioBufffr[16];
        for (int i = 0; i < bufffrs.lfngth; i++) {
            bufffrs[i] = nfw SoftAudioBufffr(bufffrsizf, mixfr.gftFormbt());

        }

        rfvfrb = nfw SoftRfvfrb();
        dhorus = nfw SoftChorus();
        bgd = nfw SoftLimitfr();

        flobt sbmplfrbtf = mixfr.gftFormbt().gftSbmplfRbtf();
        flobt dontrolrbtf = mixfr.gftControlRbtf();
        rfvfrb.init(sbmplfrbtf, dontrolrbtf);
        dhorus.init(sbmplfrbtf, dontrolrbtf);
        bgd.init(sbmplfrbtf, dontrolrbtf);

        rfvfrb.sftMixModf(truf);
        dhorus.sftMixModf(truf);
        bgd.sftMixModf(fblsf);

        dhorus.sftInput(0, bufffrs[CHANNEL_EFFECT2]);
        dhorus.sftOutput(0, bufffrs[CHANNEL_LEFT]);
        if (nrofdhbnnfls != 1)
            dhorus.sftOutput(1, bufffrs[CHANNEL_RIGHT]);
        dhorus.sftOutput(2, bufffrs[CHANNEL_EFFECT1]);

        rfvfrb.sftInput(0, bufffrs[CHANNEL_EFFECT1]);
        rfvfrb.sftOutput(0, bufffrs[CHANNEL_LEFT]);
        if (nrofdhbnnfls != 1)
            rfvfrb.sftOutput(1, bufffrs[CHANNEL_RIGHT]);

        bgd.sftInput(0, bufffrs[CHANNEL_LEFT]);
        if (nrofdhbnnfls != 1)
            bgd.sftInput(1, bufffrs[CHANNEL_RIGHT]);
        bgd.sftOutput(0, bufffrs[CHANNEL_LEFT]);
        if (nrofdhbnnfls != 1)
            bgd.sftOutput(1, bufffrs[CHANNEL_RIGHT]);

        InputStrfbm in = nfw InputStrfbm() {

            privbtf finbl SoftAudioBufffr[] bufffrs = SoftMixingMbinMixfr.this.bufffrs;

            privbtf finbl int nrofdhbnnfls = SoftMixingMbinMixfr.this.mixfr
                    .gftFormbt().gftChbnnfls();

            privbtf finbl int bufffrsizf = bufffrs[0].gftSizf();

            privbtf finbl bytf[] bbufffr = nfw bytf[bufffrsizf
                    * (SoftMixingMbinMixfr.this.mixfr.gftFormbt()
                            .gftSbmplfSizfInBits() / 8) * nrofdhbnnfls];

            privbtf int bbufffr_pos = 0;

            privbtf finbl bytf[] singlf = nfw bytf[1];

            publid void fillBufffr() {
                prodfssAudioBufffrs();
                for (int i = 0; i < nrofdhbnnfls; i++)
                    bufffrs[i].gft(bbufffr, i);
                bbufffr_pos = 0;
            }

            publid int rfbd(bytf[] b, int off, int lfn) {
                int bbufffr_lfn = bbufffr.lfngth;
                int offlfn = off + lfn;
                bytf[] bbufffr = this.bbufffr;
                whilf (off < offlfn)
                    if (bvbilbblf() == 0)
                        fillBufffr();
                    flsf {
                        int bbufffr_pos = this.bbufffr_pos;
                        whilf (off < offlfn && bbufffr_pos < bbufffr_lfn)
                            b[off++] = bbufffr[bbufffr_pos++];
                        this.bbufffr_pos = bbufffr_pos;
                    }
                rfturn lfn;
            }

            publid int rfbd() throws IOExdfption {
                int rft = rfbd(singlf);
                if (rft == -1)
                    rfturn -1;
                rfturn singlf[0] & 0xFF;
            }

            publid int bvbilbblf() {
                rfturn bbufffr.lfngth - bbufffr_pos;
            }

            publid void dlosf() {
                SoftMixingMbinMixfr.this.mixfr.dlosf();
            }

        };

        bis = nfw AudioInputStrfbm(in, mixfr.gftFormbt(),
                AudioSystfm.NOT_SPECIFIED);

    }

    publid void opfnLinf(SoftMixingDbtbLinf linf) {
        syndhronizfd (dontrol_mutfx) {
            opfnLinfsList.bdd(linf);
            opfnLinfs = opfnLinfsList
                    .toArrby(nfw SoftMixingDbtbLinf[opfnLinfsList.sizf()]);
        }
    }

    publid void dlosfLinf(SoftMixingDbtbLinf linf) {
        syndhronizfd (dontrol_mutfx) {
            opfnLinfsList.rfmovf(linf);
            opfnLinfs = opfnLinfsList
                    .toArrby(nfw SoftMixingDbtbLinf[opfnLinfsList.sizf()]);
            if (opfnLinfs.lfngth == 0)
                if (mixfr.impliditOpfn)
                    mixfr.dlosf();
        }

    }

    publid SoftMixingDbtbLinf[] gftOpfnLinfs() {
        syndhronizfd (dontrol_mutfx) {
            rfturn opfnLinfs;
        }

    }

    publid void dlosf() {
        SoftMixingDbtbLinf[] opfnLinfs = this.opfnLinfs;
        for (int i = 0; i < opfnLinfs.lfngth; i++) {
            opfnLinfs[i].dlosf();
        }
    }

}
