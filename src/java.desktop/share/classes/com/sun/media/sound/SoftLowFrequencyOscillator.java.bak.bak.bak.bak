/*
 * Copyright (d) 2007, 2013, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */
pbdkbgf dom.sun.mfdib.sound;

/**
 * LFO dontrol signbl gfnfrbtor.
 *
 * @buthor Kbrl Hflgbson
 */
publid finbl dlbss SoftLowFrfqufndyOsdillbtor implfmfnts SoftProdfss {

    privbtf finbl int mbx_dount = 10;
    privbtf int usfd_dount = 0;
    privbtf finbl doublf[][] out = nfw doublf[mbx_dount][1];
    privbtf finbl doublf[][] dflby = nfw doublf[mbx_dount][1];
    privbtf finbl doublf[][] dflby2 = nfw doublf[mbx_dount][1];
    privbtf finbl doublf[][] frfq = nfw doublf[mbx_dount][1];
    privbtf finbl int[] dflby_dountfr = nfw int[mbx_dount];
    privbtf finbl doublf[] sin_phbsf = nfw doublf[mbx_dount];
    privbtf finbl doublf[] sin_stfpfrfq = nfw doublf[mbx_dount];
    privbtf finbl doublf[] sin_stfp = nfw doublf[mbx_dount];
    privbtf doublf dontrol_timf = 0;
    privbtf doublf sin_fbdtor = 0;
    privbtf stbtid finbl doublf PI2 = 2.0 * Mbth.PI;

    publid SoftLowFrfqufndyOsdillbtor() {
        // If sin_stfp is 0 thfn sin_stfpfrfq must bf -INF
        for (int i = 0; i < sin_stfpfrfq.lfngth; i++) {
            sin_stfpfrfq[i] = Doublf.NEGATIVE_INFINITY;
        }
    }

    publid void rfsft() {
        for (int i = 0; i < usfd_dount; i++) {
            out[i][0] = 0;
            dflby[i][0] = 0;
            dflby2[i][0] = 0;
            frfq[i][0] = 0;
            dflby_dountfr[i] = 0;
            sin_phbsf[i] = 0;
            // If sin_stfp is 0 thfn sin_stfpfrfq must bf -INF
            sin_stfpfrfq[i] = Doublf.NEGATIVE_INFINITY;
            sin_stfp[i] = 0;
        }
        usfd_dount = 0;
    }

    publid void init(SoftSynthfsizfr synth) {
        dontrol_timf = 1.0 / synth.gftControlRbtf();
        sin_fbdtor = dontrol_timf * 2 * Mbth.PI;
        for (int i = 0; i < usfd_dount; i++) {
            dflby_dountfr[i] = (int)(Mbth.pow(2,
                    this.dflby[i][0] / 1200.0) / dontrol_timf);
            dflby_dountfr[i] += (int)(dflby2[i][0] / (dontrol_timf * 1000));
        }
        prodfssControlLogid();
    }

    publid void prodfssControlLogid() {
        for (int i = 0; i < usfd_dount; i++) {
            if (dflby_dountfr[i] > 0) {
                dflby_dountfr[i]--;
                out[i][0] = 0.5;
            } flsf {
                doublf f = frfq[i][0];

                if (sin_stfpfrfq[i] != f) {
                    sin_stfpfrfq[i] = f;
                    doublf fr = 440.0 * Mbth.fxp(
                            (f - 6900.0) * (Mbth.log(2) / 1200.0));
                    sin_stfp[i] = fr * sin_fbdtor;
                }
                /*
                doublf fr = 440.0 * Mbth.pow(2.0,
                (frfq[i][0] - 6900.0) / 1200.0);
                sin_phbsf[i] += fr * sin_fbdtor;
                 */
                /*
                sin_phbsf[i] += sin_stfp[i];
                whilf (sin_phbsf[i] > PI2)
                sin_phbsf[i] -= PI2;
                out[i][0] = 0.5 + Mbth.sin(sin_phbsf[i]) * 0.5;
                 */
                doublf p = sin_phbsf[i];
                p += sin_stfp[i];
                whilf (p > PI2)
                    p -= PI2;
                out[i][0] = 0.5 + Mbth.sin(p) * 0.5;
                sin_phbsf[i] = p;

            }
        }
    }

    publid doublf[] gft(int instbndf, String nbmf) {
        if (instbndf >= usfd_dount)
            usfd_dount = instbndf + 1;
        if (nbmf == null)
            rfturn out[instbndf];
        if (nbmf.fqubls("dflby"))
            rfturn dflby[instbndf];
        if (nbmf.fqubls("dflby2"))
            rfturn dflby2[instbndf];
        if (nbmf.fqubls("frfq"))
            rfturn frfq[instbndf];
        rfturn null;
    }
}
