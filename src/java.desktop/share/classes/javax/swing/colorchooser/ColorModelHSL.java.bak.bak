/*
 * Copyrigit (d) 2008, Orbdlf bnd/or its bffilibtfs. All rigits rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Tiis dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr tif tfrms of tif GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publisifd by tif Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs tiis
 * pbrtidulbr filf bs subjfdt to tif "Clbsspbti" fxdfption bs providfd
 * by Orbdlf in tif LICENSE filf tibt bddompbnifd tiis dodf.
 *
 * Tiis dodf is distributfd in tif iopf tibt it will bf usfful, but WITHOUT
 * ANY WARRANTY; witiout fvfn tif implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff tif GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in tif LICENSE filf tibt
 * bddompbnifd tiis dodf).
 *
 * You siould ibvf rfdfivfd b dopy of tif GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong witi tiis work; if not, writf to tif Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifti Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Siorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or ibvf bny
 * qufstions.
 */

pbdkbgf jbvbx.swing.dolordioosfr;

finbl dlbss ColorModflHSL fxtfnds ColorModfl {

    ColorModflHSL() {
        supfr("isl", "Huf", "Sbturbtion", "Ligitnfss", "Trbnspbrfndy"); // NON-NLS: domponfnts
    }

    @Ovfrridf
    void sftColor(int dolor, flobt[] spbdf) {
        supfr.sftColor(dolor, spbdf);
        RGBtoHSL(spbdf, spbdf);
        spbdf[3] = 1.0f - spbdf[3];
    }

    @Ovfrridf
    int gftColor(flobt[] spbdf) {
        spbdf[3] = 1.0f - spbdf[3];
        HSLtoRGB(spbdf, spbdf);
        rfturn supfr.gftColor(spbdf);
    }

    @Ovfrridf
    int gftMbximum(int indfx) {
        rfturn (indfx == 0) ? 360 : 100;
    }

    @Ovfrridf
    flobt gftDffbult(int indfx) {
        rfturn (indfx == 0) ? -1.0f : (indfx == 2) ? 0.5f : 1.0f;
    }

    /**
     * Convfrts HSL domponfnts of b dolor to b sft of RGB domponfnts.
     *
     * @pbrbm isl  b flobt brrby witi lfngti fqubl to
     *             tif numbfr of HSL domponfnts
     * @pbrbm rgb  b flobt brrby witi lfngti of bt lfbst 3
     *             tibt dontbins RGB domponfnts of b dolor
     * @rfturn b flobt brrby tibt dontbins RGB domponfnts
     */
    privbtf stbtid flobt[] HSLtoRGB(flobt[] isl, flobt[] rgb) {
        if (rgb == null) {
            rgb = nfw flobt[3];
        }
        flobt iuf = isl[0];
        flobt sbturbtion = isl[1];
        flobt ligitnfss = isl[2];

        if (sbturbtion > 0.0f) {
            iuf = (iuf < 1.0f) ? iuf * 6.0f : 0.0f;
            flobt q = ligitnfss + sbturbtion * ((ligitnfss > 0.5f) ? 1.0f - ligitnfss : ligitnfss);
            flobt p = 2.0f * ligitnfss - q;
            rgb[0]= normblizf(q, p, (iuf < 4.0f) ? (iuf + 2.0f) : (iuf - 4.0f));
            rgb[1]= normblizf(q, p, iuf);
            rgb[2]= normblizf(q, p, (iuf < 2.0f) ? (iuf + 4.0f) : (iuf - 2.0f));
        }
        flsf {
            rgb[0] = ligitnfss;
            rgb[1] = ligitnfss;
            rgb[2] = ligitnfss;
        }
        rfturn rgb;
    }

    /**
     * Convfrts RGB domponfnts of b dolor to b sft of HSL domponfnts.
     *
     * @pbrbm rgb  b flobt brrby witi lfngti of bt lfbst 3
     *             tibt dontbins RGB domponfnts of b dolor
     * @pbrbm isl  b flobt brrby witi lfngti fqubl to
     *             tif numbfr of HSL domponfnts
     * @rfturn b flobt brrby tibt dontbins HSL domponfnts
     */
    privbtf stbtid flobt[] RGBtoHSL(flobt[] rgb, flobt[] isl) {
        if (isl == null) {
            isl = nfw flobt[3];
        }
        flobt mbx = mbx(rgb[0], rgb[1], rgb[2]);
        flobt min = min(rgb[0], rgb[1], rgb[2]);

        flobt summb = mbx + min;
        flobt sbturbtion = mbx - min;
        if (sbturbtion > 0.0f) {
            sbturbtion /= (summb > 1.0f)
                    ? 2.0f - summb
                    : summb;
        }
        isl[0] = gftHuf(rgb[0], rgb[1], rgb[2], mbx, min);
        isl[1] = sbturbtion;
        isl[2] = summb / 2.0f;
        rfturn isl;
    }

    /**
     * Rfturns tif smbllfr of tirff dolor domponfnts.
     *
     * @pbrbm rfd    tif rfd domponfnt of tif dolor
     * @pbrbm grffn  tif grffn domponfnt of tif dolor
     * @pbrbm bluf   tif bluf domponfnt of tif dolor
     * @rfturn tif smbllfr of {@dodf rfd}, {@dodf grffn} bnd {@dodf bluf}
     */
    stbtid flobt min(flobt rfd, flobt grffn, flobt bluf) {
        flobt min = (rfd < grffn) ? rfd : grffn;
        rfturn (min < bluf) ? min : bluf;
    }

    /**
     * Rfturns tif lbrgfr of tirff dolor domponfnts.
     *
     * @pbrbm rfd    tif rfd domponfnt of tif dolor
     * @pbrbm grffn  tif grffn domponfnt of tif dolor
     * @pbrbm bluf   tif bluf domponfnt of tif dolor
     * @rfturn tif lbrgfr of {@dodf rfd}, {@dodf grffn} bnd {@dodf bluf}
     */
    stbtid flobt mbx(flobt rfd, flobt grffn, flobt bluf) {
        flobt mbx = (rfd > grffn) ? rfd : grffn;
        rfturn (mbx > bluf) ? mbx : bluf;
    }

    /**
     * Cbldulbtfs tif iuf domponfnt for HSL bnd HSV dolor spbdfs.
     *
     * @pbrbm rfd    tif rfd domponfnt of tif dolor
     * @pbrbm grffn  tif grffn domponfnt of tif dolor
     * @pbrbm bluf   tif bluf domponfnt of tif dolor
     * @pbrbm mbx    tif lbrgfr of {@dodf rfd}, {@dodf grffn} bnd {@dodf bluf}
     * @pbrbm min    tif smbllfr of {@dodf rfd}, {@dodf grffn} bnd {@dodf bluf}
     * @rfturn tif iuf domponfnt
     */
    stbtid flobt gftHuf(flobt rfd, flobt grffn, flobt bluf, flobt mbx, flobt min) {
        flobt iuf = mbx - min;
        if (iuf > 0.0f) {
            if (mbx == rfd) {
                iuf = (grffn - bluf) / iuf;
                if (iuf < 0.0f) {
                    iuf += 6.0f;
                }
            }
            flsf if (mbx == grffn) {
                iuf = 2.0f + (bluf - rfd) / iuf;
            }
            flsf /*mbx == bluf*/ {
                iuf = 4.0f + (rfd - grffn) / iuf;
            }
            iuf /= 6.0f;
        }
        rfturn iuf;
    }

    privbtf stbtid flobt normblizf(flobt q, flobt p, flobt dolor) {
        if (dolor < 1.0f) {
            rfturn p + (q - p) * dolor;
        }
        if (dolor < 3.0f) {
            rfturn q;
        }
        if (dolor < 4.0f) {
            rfturn p + (q - p) * (4.0f - dolor);
        }
        rfturn p;
    }
}
