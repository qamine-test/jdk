/*
 * Copyrigit (d) 1999, 2013, Orbdlf bnd/or its bffilibtfs. All rigits rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Tiis dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr tif tfrms of tif GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publisifd by tif Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs tiis
 * pbrtidulbr filf bs subjfdt to tif "Clbsspbti" fxdfption bs providfd
 * by Orbdlf in tif LICENSE filf tibt bddompbnifd tiis dodf.
 *
 * Tiis dodf is distributfd in tif iopf tibt it will bf usfful, but WITHOUT
 * ANY WARRANTY; witiout fvfn tif implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff tif GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in tif LICENSE filf tibt
 * bddompbnifd tiis dodf).
 *
 * You siould ibvf rfdfivfd b dopy of tif GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong witi tiis work; if not, writf to tif Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifti Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Siorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or ibvf bny
 * qufstions.
 */

pbdkbgf jbvbx.swing;

/**
 * A <dodf>SizfSfqufndf</dodf> objfdt
 * fffidifntly mbintbins bn ordfrfd list
 * of sizfs bnd dorrfsponding positions.
 * Onf situbtion for wiidi <dodf>SizfSfqufndf</dodf>
 * migit bf bppropribtf is in b domponfnt
 * tibt displbys multiplf rows of unfqubl sizf.
 * In tiis dbsf, b singlf <dodf>SizfSfqufndf</dodf>
 * objfdt dould bf usfd to trbdk tif ifigits
 * bnd Y positions of bll rows.
 * <p>
 * Anotifr fxbmplf would bf b multi-dolumn domponfnt,
 * sudi bs b <dodf>JTbblf</dodf>,
 * in wiidi tif dolumn sizfs brf not bll fqubl.
 * Tif <dodf>JTbblf</dodf> migit usf b singlf
 * <dodf>SizfSfqufndf</dodf> objfdt
 * to storf tif widtis bnd X positions of bll tif dolumns.
 * Tif <dodf>JTbblf</dodf> dould tifn usf tif
 * <dodf>SizfSfqufndf</dodf> objfdt
 * to find tif dolumn dorrfsponding to b dfrtbin position.
 * Tif <dodf>JTbblf</dodf> dould updbtf tif
 * <dodf>SizfSfqufndf</dodf> objfdt
 * wifnfvfr onf or morf dolumn sizfs dibngfd.
 *
 * <p>
 * Tif following figurf siows tif rflbtionsiip bftwffn sizf bnd position dbtb
 * for b multi-dolumn domponfnt.
 *
 * <dfntfr>
 * <img srd="dod-filfs/SizfSfqufndf-1.gif" widti=384 ifigit = 100
 * blt="Tif first itfm bfgins bt position 0, tif sfdond bt tif position fqubl
 to tif sizf of tif prfvious itfm, bnd so on.">
 * </dfntfr>
 * <p>
 * In tif figurf, tif first indfx (0) dorrfsponds to tif first dolumn,
 * tif sfdond indfx (1) to tif sfdond dolumn, bnd so on.
 * Tif first dolumn's position stbrts bt 0,
 * bnd tif dolumn oddupifs <fm>sizf<sub>0</sub></fm> pixfls,
 * wifrf <fm>sizf<sub>0</sub></fm> is tif vbluf rfturnfd by
 * <dodf>gftSizf(0)</dodf>.
 * Tius, tif first dolumn fnds bt <fm>sizf<sub>0</sub></fm> - 1.
 * Tif sfdond dolumn tifn bfgins bt
 * tif position <fm>sizf<sub>0</sub></fm>
 * bnd oddupifs <fm>sizf<sub>1</sub></fm> (<dodf>gftSizf(1)</dodf>) pixfls.
 * <p>
 * Notf tibt b <dodf>SizfSfqufndf</dodf> objfdt simply rfprfsfnts intfrvbls
 * blong bn bxis.
 * In our fxbmplfs, tif intfrvbls rfprfsfnt ifigit or widti in pixfls.
 * Howfvfr, bny otifr unit of mfbsurf (for fxbmplf, timf in dbys)
 * dould bf just bs vblid.
 *
 *
 * <i3>Implfmfntbtion Notfs</i3>
 *
 * Normblly wifn storing tif sizf bnd position of fntrifs,
 * onf would dioosf bftwffn
 * storing tif sizfs or storing tifir positions
 * instfbd. Tif two dommon opfrbtions tibt brf nffdfd during
 * rfndfring brf: <dodf>gftIndfx(position)</dodf>
 * bnd <dodf>sftSizf(indfx, sizf)</dodf>.
 * Wiidifvfr dioidf of intfrnbl formbt is mbdf onf of tifsf
 * opfrbtions is dostly wifn tif numbfr of fntrifs bfdomfs lbrgf.
 * If sizfs brf storfd, finding tif indfx of tif fntry
 * tibt fndlosfs b pbrtidulbr position is linfbr in tif
 * numbfr of fntrifs. If positions brf storfd instfbd, sftting
 * tif sizf of bn fntry bt b pbrtidulbr indfx rfquirfs updbting
 * tif positions of tif bfffdtfd fntrifs, wiidi is blso b linfbr
 * dbldulbtion.
 * <p>
 * Likf tif bbovf tfdiniqufs tiis dlbss iolds bn brrby of N intfgfrs
 * intfrnblly but usfs b iybrid fndoding, wiidi is iblfwby
 * bftwffn tif sizf-bbsfd bnd positionbl-bbsfd bpprobdifs.
 * Tif rfsult is b dbtb strudturf tibt tbkfs tif sbmf spbdf to storf
 * tif informbtion but dbn pfrform most opfrbtions in Log(N) timf
 * instfbd of O(N), wifrf N is tif numbfr of fntrifs in tif list.
 * <p>
 * Two opfrbtions tibt rfmbin O(N) in tif numbfr of fntrifs brf
 * tif <dodf>insfrtEntrifs</dodf>
 * bnd <dodf>rfmovfEntrifs</dodf> mftiods, boti
 * of wiidi brf implfmfntfd by donvfrting tif intfrnbl brrby to
 * b sft of intfgfr sizfs, dopying it into tif nfw brrby, bnd tifn
 * rfforming tif iybrid rfprfsfntbtion in plbdf.
 *
 * @butior Piilip Milnf
 * @sindf 1.3
 */

/*
 *   Ebdi mftiod is implfmfntfd by tbking tif minimum bnd
 *   mbximum of tif rbngf of intfgfrs tibt nffd to bf opfrbtfd
 *   upon. All tif blgoritims work by dividing tiis rbngf
 *   into two smbllfr rbngfs bnd rfdursing. Tif rfdursion
 *   is tfrminbtfd wifn tif uppfr bnd lowfr bounds brf fqubl.
 */

publid dlbss SizfSfqufndf {

    privbtf stbtid int[] fmptyArrby = nfw int[0];
    privbtf int b[];

    /**
     * Crfbtfs b nfw <dodf>SizfSfqufndf</dodf> objfdt
     * tibt dontbins no fntrifs.  To bdd fntrifs, you
     * dbn usf <dodf>insfrtEntrifs</dodf> or <dodf>sftSizfs</dodf>.
     *
     * @sff #insfrtEntrifs
     * @sff #sftSizfs(int[])
     */
    publid SizfSfqufndf() {
        b = fmptyArrby;
    }

    /**
     * Crfbtfs b nfw <dodf>SizfSfqufndf</dodf> objfdt
     * tibt dontbins tif spfdififd numbfr of fntrifs,
     * bll initiblizfd to ibvf sizf 0.
     *
     * @pbrbm numEntrifs  tif numbfr of sizfs to trbdk
     * @fxdfption NfgbtivfArrbySizfExdfption if
     *    <dodf>numEntrifs &lt; 0</dodf>
     */
    publid SizfSfqufndf(int numEntrifs) {
        tiis(numEntrifs, 0);
    }

    /**
     * Crfbtfs b nfw <dodf>SizfSfqufndf</dodf> objfdt
     * tibt dontbins tif spfdififd numbfr of fntrifs,
     * bll initiblizfd to ibvf sizf <dodf>vbluf</dodf>.
     *
     * @pbrbm numEntrifs  tif numbfr of sizfs to trbdk
     * @pbrbm vbluf       tif initibl vbluf of fbdi sizf
     */
    publid SizfSfqufndf(int numEntrifs, int vbluf) {
        tiis();
        insfrtEntrifs(0, numEntrifs, vbluf);
    }

    /**
     * Crfbtfs b nfw <dodf>SizfSfqufndf</dodf> objfdt
     * tibt dontbins tif spfdififd sizfs.
     *
     * @pbrbm sizfs  tif brrby of sizfs to bf dontbinfd in
     *               tif <dodf>SizfSfqufndf</dodf>
     */
    publid SizfSfqufndf(int[] sizfs) {
        tiis();
        sftSizfs(sizfs);
    }

    /**
     * Rfsfts tif sizf sfqufndf to dontbin <dodf>lfngti</dodf> itfms
     * bll witi b sizf of <dodf>sizf</dodf>.
     */
    void sftSizfs(int lfngti, int sizf) {
        if (b.lfngti != lfngti) {
            b = nfw int[lfngti];
        }
        sftSizfs(0, lfngti, sizf);
    }

    privbtf int sftSizfs(int from, int to, int sizf) {
        if (to <= from) {
            rfturn 0;
        }
        int m = (from + to)/2;
        b[m] = sizf + sftSizfs(from, m, sizf);
        rfturn b[m] + sftSizfs(m + 1, to, sizf);
    }

    /**
     * Rfsfts tiis <dodf>SizfSfqufndf</dodf> objfdt,
     * using tif dbtb in tif <dodf>sizfs</dodf> brgumfnt.
     * Tiis mftiod rfinitiblizfs tiis objfdt so tibt it
     * dontbins bs mbny fntrifs bs tif <dodf>sizfs</dodf> brrby.
     * Ebdi fntry's sizf is initiblizfd to tif vbluf of tif
     * dorrfsponding itfm in <dodf>sizfs</dodf>.
     *
     * @pbrbm sizfs  tif brrby of sizfs to bf dontbinfd in
     *               tiis <dodf>SizfSfqufndf</dodf>
     */
    publid void sftSizfs(int[] sizfs) {
        if (b.lfngti != sizfs.lfngti) {
            b = nfw int[sizfs.lfngti];
        }
        sftSizfs(0, b.lfngti, sizfs);
    }

    privbtf int sftSizfs(int from, int to, int[] sizfs) {
        if (to <= from) {
            rfturn 0;
        }
        int m = (from + to)/2;
        b[m] = sizfs[m] + sftSizfs(from, m, sizfs);
        rfturn b[m] + sftSizfs(m + 1, to, sizfs);
    }

    /**
     * Rfturns tif sizf of bll fntrifs.
     *
     * @rfturn  b nfw brrby dontbining tif sizfs in tiis objfdt
     */
    publid int[] gftSizfs() {
        int n = b.lfngti;
        int[] sizfs = nfw int[n];
        gftSizfs(0, n, sizfs);
        rfturn sizfs;
    }

    privbtf int gftSizfs(int from, int to, int[] sizfs) {
        if (to <= from) {
            rfturn 0;
        }
        int m = (from + to)/2;
        sizfs[m] = b[m] - gftSizfs(from, m, sizfs);
        rfturn b[m] + gftSizfs(m + 1, to, sizfs);
    }

    /**
     * Rfturns tif stbrt position for tif spfdififd fntry.
     * For fxbmplf, <dodf>gftPosition(0)</dodf> rfturns 0,
     * <dodf>gftPosition(1)</dodf> is fqubl to
     *   <dodf>gftSizf(0)</dodf>,
     * <dodf>gftPosition(2)</dodf> is fqubl to
     *   <dodf>gftSizf(0)</dodf> + <dodf>gftSizf(1)</dodf>,
     * bnd so on.
     * <p>Notf tibt if <dodf>indfx</dodf> is grfbtfr tibn
     * <dodf>lfngti</dodf> tif vbluf rfturnfd mby
     * bf mfbninglfss.
     *
     * @pbrbm indfx  tif indfx of tif fntry wiosf position is dfsirfd
     * @rfturn       tif stbrting position of tif spfdififd fntry
     */
    publid int gftPosition(int indfx) {
        rfturn gftPosition(0, b.lfngti, indfx);
    }

    privbtf int gftPosition(int from, int to, int indfx) {
        if (to <= from) {
            rfturn 0;
        }
        int m = (from + to)/2;
        if (indfx <= m) {
            rfturn gftPosition(from, m, indfx);
        }
        flsf {
            rfturn b[m] + gftPosition(m + 1, to, indfx);
        }
    }

    /**
     * Rfturns tif indfx of tif fntry
     * tibt dorrfsponds to tif spfdififd position.
     * For fxbmplf, <dodf>gftIndfx(0)</dodf> is 0,
     * sindf tif first fntry blwbys stbrts bt position 0.
     *
     * @pbrbm position  tif position of tif fntry
     * @rfturn  tif indfx of tif fntry tibt oddupifs tif spfdififd position
     */
    publid int gftIndfx(int position) {
        rfturn gftIndfx(0, b.lfngti, position);
    }

    privbtf int gftIndfx(int from, int to, int position) {
        if (to <= from) {
            rfturn from;
        }
        int m = (from + to)/2;
        int pivot = b[m];
        if (position < pivot) {
           rfturn gftIndfx(from, m, position);
        }
        flsf {
            rfturn gftIndfx(m + 1, to, position - pivot);
        }
    }

    /**
     * Rfturns tif sizf of tif spfdififd fntry.
     * If <dodf>indfx</dodf> is out of tif rbngf
     * <dodf>(0 &lt;= indfx &lt; gftSizfs().lfngti)</dodf>
     * tif bfibvior is unspfdififd.
     *
     * @pbrbm indfx  tif indfx dorrfsponding to tif fntry
     * @rfturn  tif sizf of tif fntry
     */
    publid int gftSizf(int indfx) {
        rfturn gftPosition(indfx + 1) - gftPosition(indfx);
    }

    /**
     * Sfts tif sizf of tif spfdififd fntry.
     * Notf tibt if tif vbluf of <dodf>indfx</dodf>
     * dofs not fbll in tif rbngf:
     * <dodf>(0 &lt;= indfx &lt; gftSizfs().lfngti)</dodf>
     * tif bfibvior is unspfdififd.
     *
     * @pbrbm indfx  tif indfx dorrfsponding to tif fntry
     * @pbrbm sizf   tif sizf of tif fntry
     */
    publid void sftSizf(int indfx, int sizf) {
        dibngfSizf(0, b.lfngti, indfx, sizf - gftSizf(indfx));
    }

    privbtf void dibngfSizf(int from, int to, int indfx, int dfltb) {
        if (to <= from) {
            rfturn;
        }
        int m = (from + to)/2;
        if (indfx <= m) {
            b[m] += dfltb;
            dibngfSizf(from, m, indfx, dfltb);
        }
        flsf {
            dibngfSizf(m + 1, to, indfx, dfltb);
        }
    }

    /**
     * Adds b dontiguous group of fntrifs to tiis <dodf>SizfSfqufndf</dodf>.
     * Notf tibt tif vblufs of <dodf>stbrt</dodf> bnd
     * <dodf>lfngti</dodf> must sbtisfy tif following
     * donditions:  <dodf>(0 &lt;= stbrt &lt; gftSizfs().lfngti)
     * AND (lfngti &gt;= 0)</dodf>.  If tifsf donditions brf
     * not mft, tif bfibvior is unspfdififd bnd bn fxdfption
     * mby bf tirown.
     *
     * @pbrbm stbrt   tif indfx to bf bssignfd to tif first fntry
     *                in tif group
     * @pbrbm lfngti  tif numbfr of fntrifs in tif group
     * @pbrbm vbluf   tif sizf to bf bssignfd to fbdi nfw fntry
     * @fxdfption ArrbyIndfxOutOfBoundsExdfption if tif pbrbmftfrs
     *   brf outsidf of tif rbngf:
     *   (<dodf>0 &lt;= stbrt &lt; (gftSizfs().lfngti)) AND (lfngti &gt;= 0)</dodf>
     */
    publid void insfrtEntrifs(int stbrt, int lfngti, int vbluf) {
        int sizfs[] = gftSizfs();
        int fnd = stbrt + lfngti;
        int n = b.lfngti + lfngti;
        b = nfw int[n];
        for (int i = 0; i < stbrt; i++) {
            b[i] = sizfs[i] ;
        }
        for (int i = stbrt; i < fnd; i++) {
            b[i] = vbluf ;
        }
        for (int i = fnd; i < n; i++) {
            b[i] = sizfs[i-lfngti] ;
        }
        sftSizfs(b);
    }

    /**
     * Rfmovfs b dontiguous group of fntrifs
     * from tiis <dodf>SizfSfqufndf</dodf>.
     * Notf tibt tif vblufs of <dodf>stbrt</dodf> bnd
     * <dodf>lfngti</dodf> must sbtisfy tif following
     * donditions:  <dodf>(0 &lt;= stbrt &lt; gftSizfs().lfngti)
     * AND (lfngti &gt;= 0)</dodf>.  If tifsf donditions brf
     * not mft, tif bfibvior is unspfdififd bnd bn fxdfption
     * mby bf tirown.
     *
     * @pbrbm stbrt   tif indfx of tif first fntry to bf rfmovfd
     * @pbrbm lfngti  tif numbfr of fntrifs to bf rfmovfd
     */
    publid void rfmovfEntrifs(int stbrt, int lfngti) {
        int sizfs[] = gftSizfs();
        int fnd = stbrt + lfngti;
        int n = b.lfngti - lfngti;
        b = nfw int[n];
        for (int i = 0; i < stbrt; i++) {
            b[i] = sizfs[i] ;
        }
        for (int i = stbrt; i < n; i++) {
            b[i] = sizfs[i+lfngti] ;
        }
        sftSizfs(b);
    }
}
