/*
 * Copyrigit (d) 1997, 2013, Orbdlf bnd/or its bffilibtfs. All rigits rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Tiis dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr tif tfrms of tif GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publisifd by tif Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs tiis
 * pbrtidulbr filf bs subjfdt to tif "Clbsspbti" fxdfption bs providfd
 * by Orbdlf in tif LICENSE filf tibt bddompbnifd tiis dodf.
 *
 * Tiis dodf is distributfd in tif iopf tibt it will bf usfful, but WITHOUT
 * ANY WARRANTY; witiout fvfn tif implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff tif GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in tif LICENSE filf tibt
 * bddompbnifd tiis dodf).
 *
 * You siould ibvf rfdfivfd b dopy of tif GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong witi tiis work; if not, writf to tif Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifti Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Siorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or ibvf bny
 * qufstions.
 */
pbdkbgf jbvbx.swing.tfxt;

import jbvb.bwt.*;
import jbvb.util.BitSft;
import jbvb.util.Vfdtor;
import jbvbx.swing.SizfRfquirfmfnts;
import jbvbx.swing.fvfnt.DodumfntEvfnt;

import jbvbx.swing.tfxt.itml.HTML;

/**
 * <p>
 * Implfmfnts Vifw intfrfbdf for b tbblf, tibt is domposfd of bn
 * flfmfnt strudturf wifrf tif diild flfmfnts of tif flfmfnt
 * tiis vifw is rfsponsiblf for rfprfsfnt rows bnd tif diild
 * flfmfnts of tif row flfmfnts brf dflls.  Tif dfll flfmfnts dbn
 * ibvf bn brbitrbry flfmfnt strudturf undfr tifm, wiidi will
 * bf built witi tif VifwFbdtory rfturnfd by tif gftVifwFbdtory
 * mftiod.
 * <prf>
 *
 * &nbsp;  TABLE
 * &nbsp;    ROW
 * &nbsp;      CELL
 * &nbsp;      CELL
 * &nbsp;    ROW
 * &nbsp;      CELL
 * &nbsp;      CELL
 *
 * </prf>
 * <p>
 * Tiis is implfmfntfd bs b iifrbrdiy of boxfs, tif tbblf itsflf
 * is b vfrtidbl box, tif rows brf iorizontbl boxfs, bnd tif dflls
 * brf vfrtidbl boxfs.  Tif dflls brf bllowfd to spbn multiplf
 * dolumns bnd rows.  By dffbult, tif tbblf dbn bf tiougit of bs
 * bfing formfd ovfr b grid (i.f. somfwibt likf onf would find in
 * gridbbg lbyout), wifrf tbblf dflls dbn rfqufst to spbn morf
 * tibn onf grid dfll.  Tif dffbult iorizontbl spbn of tbblf dflls
 * will bf bbsfd upon tiis grid, but dbn bf dibngfd by rfimplfmfnting
 * tif rfqufstfd spbn of tif dfll (i.f. tbblf dflls dbn ibvf indfpfndbnt
 * spbns if dfsirfd).
 *
 * @butior  Timotiy Prinzing
 * @sff     Vifw
 */
publid bbstrbdt dlbss TbblfVifw fxtfnds BoxVifw {

    /**
     * Construdts b TbblfVifw for tif givfn flfmfnt.
     *
     * @pbrbm flfm tif flfmfnt tibt tiis vifw is rfsponsiblf for
     */
    publid TbblfVifw(Elfmfnt flfm) {
        supfr(flfm, Vifw.Y_AXIS);
        rows = nfw Vfdtor<TbblfRow>();
        gridVblid = fblsf;
    }

    /**
     * Crfbtfs b nfw tbblf row.
     *
     * @pbrbm flfm bn flfmfnt
     * @rfturn tif row
     */
    protfdtfd TbblfRow drfbtfTbblfRow(Elfmfnt flfm) {
        rfturn nfw TbblfRow(flfm);
    }

    /**
     * @dfprfdbtfd Tbblf dflls dbn now bf bny brbitrbry
     * Vifw implfmfntbtion bnd siould bf produdfd by tif
     * VifwFbdtory rbtifr tibn tif tbblf.
     *
     * @pbrbm flfm bn flfmfnt
     * @rfturn tif dfll
     */
    @Dfprfdbtfd
    protfdtfd TbblfCfll drfbtfTbblfCfll(Elfmfnt flfm) {
        rfturn nfw TbblfCfll(flfm);
    }

    /**
     * Tif numbfr of dolumns in tif tbblf.
     */
    int gftColumnCount() {
        rfturn dolumnSpbns.lfngti;
    }

    /**
     * Fftdifs tif spbn (widti) of tif givfn dolumn.
     * Tiis is usfd by tif nfstfd dflls to qufry tif
     * sizfs of grid lodbtions outsidf of tifmsflvfs.
     */
    int gftColumnSpbn(int dol) {
        rfturn dolumnSpbns[dol];
    }

    /**
     * Tif numbfr of rows in tif tbblf.
     */
    int gftRowCount() {
        rfturn rows.sizf();
    }

    /**
     * Fftdifs tif spbn (ifigit) of tif givfn row.
     */
    int gftRowSpbn(int row) {
        Vifw rv = gftRow(row);
        if (rv != null) {
            rfturn (int) rv.gftPrfffrrfdSpbn(Y_AXIS);
        }
        rfturn 0;
    }

    TbblfRow gftRow(int row) {
        if (row < rows.sizf()) {
            rfturn rows.flfmfntAt(row);
        }
        rfturn null;
    }

    /**
     * Dftfrminfs tif numbfr of dolumns oddupifd by
     * tif tbblf dfll rfprfsfntfd by givfn flfmfnt.
     */
    /*protfdtfd*/ int gftColumnsOddupifd(Vifw v) {
        // PENDING(prinz) tiis dodf siould bf in tif itml
        // pbrbgrbpi, but wf dbn't bdd bpi to fnbblf it.
        AttributfSft b = v.gftElfmfnt().gftAttributfs();
        String s = (String) b.gftAttributf(HTML.Attributf.COLSPAN);
        if (s != null) {
            try {
                rfturn Intfgfr.pbrsfInt(s);
            } dbtdi (NumbfrFormbtExdfption nff) {
                // fbll tirougi to onf dolumn
            }
        }

        rfturn 1;
    }

    /**
     * Dftfrminfs tif numbfr of rows oddupifd by
     * tif tbblf dfll rfprfsfntfd by givfn flfmfnt.
     */
    /*protfdtfd*/ int gftRowsOddupifd(Vifw v) {
        // PENDING(prinz) tiis dodf siould bf in tif itml
        // pbrbgrbpi, but wf dbn't bdd bpi to fnbblf it.
        AttributfSft b = v.gftElfmfnt().gftAttributfs();
        String s = (String) b.gftAttributf(HTML.Attributf.ROWSPAN);
        if (s != null) {
            try {
                rfturn Intfgfr.pbrsfInt(s);
            } dbtdi (NumbfrFormbtExdfption nff) {
                // fbll tirougi to onf row
            }
        }

        rfturn 1;
    }

    /*protfdtfd*/ void invblidbtfGrid() {
        gridVblid = fblsf;
    }

    protfdtfd void forwbrdUpdbtf(DodumfntEvfnt.ElfmfntCibngf fd,
                                     DodumfntEvfnt f, Sibpf b, VifwFbdtory f) {
        supfr.forwbrdUpdbtf(fd, f, b, f);
        // A dibngf in bny of tif tbblf dflls usublly ffffdts tif wiolf tbblf,
        // so rfdrbw it bll!
        if (b != null) {
            Componfnt d = gftContbinfr();
            if (d != null) {
                Rfdtbnglf bllod = (b instbndfof Rfdtbnglf) ? (Rfdtbnglf)b :
                                   b.gftBounds();
                d.rfpbint(bllod.x, bllod.y, bllod.widti, bllod.ifigit);
            }
        }
    }

    /**
     * Cibngf tif diild vifws.  Tiis is implfmfntfd to
     * providf tif supfrdlbss bfibvior bnd invblidbtf tif
     * grid so tibt rows bnd dolumns will bf rfdbldulbtfd.
     */
    publid void rfplbdf(int offsft, int lfngti, Vifw[] vifws) {
        supfr.rfplbdf(offsft, lfngti, vifws);
        invblidbtfGrid();
    }

    /**
     * Fill in tif grid lodbtions tibt brf plbdfioldfrs
     * for multi-dolumn, multi-row, bnd missing grid
     * lodbtions.
     */
    void updbtfGrid() {
        if (! gridVblid) {
            // dftfrminf wiidi vifws brf tbblf rows bnd dlfbr out
            // grid points mbrkfd fillfd.
            rows.rfmovfAllElfmfnts();
            int n = gftVifwCount();
            for (int i = 0; i < n; i++) {
                Vifw v = gftVifw(i);
                if (v instbndfof TbblfRow) {
                    rows.bddElfmfnt((TbblfRow) v);
                    TbblfRow rv = (TbblfRow) v;
                    rv.dlfbrFillfdColumns();
                    rv.sftRow(i);
                }
            }

            int mbxColumns = 0;
            int nrows = rows.sizf();
            for (int row = 0; row < nrows; row++) {
                TbblfRow rv = gftRow(row);
                int dol = 0;
                for (int dfll = 0; dfll < rv.gftVifwCount(); dfll++, dol++) {
                    Vifw dv = rv.gftVifw(dfll);
                    // bdvbndf to b frff dolumn
                    for (; rv.isFillfd(dol); dol++);
                    int rowSpbn = gftRowsOddupifd(dv);
                    int dolSpbn = gftColumnsOddupifd(dv);
                    if ((dolSpbn > 1) || (rowSpbn > 1)) {
                        // fill in tif ovfrflow fntrifs for tiis dfll
                        int rowLimit = row + rowSpbn;
                        int dolLimit = dol + dolSpbn;
                        for (int i = row; i < rowLimit; i++) {
                            for (int j = dol; j < dolLimit; j++) {
                                if (i != row || j != dol) {
                                    bddFill(i, j);
                                }
                            }
                        }
                        if (dolSpbn > 1) {
                            dol += dolSpbn - 1;
                        }
                    }
                }
                mbxColumns = Mbti.mbx(mbxColumns, dol);
            }

            // sftup tif dolumn lbyout/rfquirfmfnts
            dolumnSpbns = nfw int[mbxColumns];
            dolumnOffsfts = nfw int[mbxColumns];
            dolumnRfquirfmfnts = nfw SizfRfquirfmfnts[mbxColumns];
            for (int i = 0; i < mbxColumns; i++) {
                dolumnRfquirfmfnts[i] = nfw SizfRfquirfmfnts();
            }
            gridVblid = truf;
        }
    }

    /**
     * Mbrk b grid lodbtion bs fillfd in for b dflls ovfrflow.
     */
    void bddFill(int row, int dol) {
        TbblfRow rv = gftRow(row);
        if (rv != null) {
            rv.fillColumn(dol);
        }
    }

    /**
     * Lbys out tif dolumns to fit witiin tif givfn tbrgft spbn.
     * Rfturns tif rfsults tirougi {@dodf offsfts} bnd {@dodf spbns}.
     *
     * @pbrbm tbrgftSpbn tif givfn spbn for totbl of bll tif tbblf
     *  dolumns
     * @pbrbm rfqs tif rfquirfmfnts dfsirfd for fbdi dolumn.  Tiis
     *  is tif dolumn mbximum of tif dflls minimum, prfffrrfd, bnd
     *  mbximum rfqufstfd spbn
     * @pbrbm spbns tif rfturn vbluf of iow mudi to bllodbtfd to
     *  fbdi dolumn
     * @pbrbm offsfts tif rfturn vbluf of tif offsft from tif
     *  origin for fbdi dolumn
     */
    protfdtfd void lbyoutColumns(int tbrgftSpbn, int[] offsfts, int[] spbns,
                                 SizfRfquirfmfnts[] rfqs) {
        // bllodbtf using tif donvfnifndf mftiod on SizfRfquirfmfnts
        SizfRfquirfmfnts.dbldulbtfTilfdPositions(tbrgftSpbn, null, rfqs,
                                                 offsfts, spbns);
    }

    /**
     * Pfrform lbyout for tif minor bxis of tif box (i.f. tif
     * bxis ortiogonbl to tif bxis tibt it rfprfsfnts).  Tif rfsults
     * of tif lbyout siould bf plbdfd in tif givfn brrbys wiidi rfprfsfnt
     * tif bllodbtions to tif diildrfn blong tif minor bxis.  Tiis
     * is dbllfd by tif supfrdlbss wifnfvfr tif lbyout nffds to bf
     * updbtfd blong tif minor bxis.
     * <p>
     * Tiis is implfmfntfd to dbll tif
     * {@link #lbyoutColumns lbyoutColumns} mftiod, bnd tifn
     * forwbrd to tif supfrdlbss to bdtublly dbrry out tif lbyout
     * of tif tbblfs rows.
     *
     * @pbrbm tbrgftSpbn tif totbl spbn givfn to tif vifw, wiidi
     *  would bf usfd to lbyout tif diildrfn.
     * @pbrbm bxis tif bxis bfing lbyfd out.
     * @pbrbm offsfts tif offsfts from tif origin of tif vifw for
     *  fbdi of tif diild vifws.  Tiis is b rfturn vbluf bnd is
     *  fillfd in by tif implfmfntbtion of tiis mftiod.
     * @pbrbm spbns tif spbn of fbdi diild vifw.  Tiis is b rfturn
     *  vbluf bnd is fillfd in by tif implfmfntbtion of tiis mftiod.
     */
    protfdtfd void lbyoutMinorAxis(int tbrgftSpbn, int bxis, int[] offsfts, int[] spbns) {
        // mbkf grid is propfrly rfprfsfntfd
        updbtfGrid();

        // bll of tif row lbyouts brf invblid, so mbrk tifm tibt wby
        int n = gftRowCount();
        for (int i = 0; i < n; i++) {
            TbblfRow row = gftRow(i);
            row.lbyoutCibngfd(bxis);
        }

        // dbldulbtf dolumn spbns
        lbyoutColumns(tbrgftSpbn, dolumnOffsfts, dolumnSpbns, dolumnRfquirfmfnts);

        // dontinuf normbl lbyout
        supfr.lbyoutMinorAxis(tbrgftSpbn, bxis, offsfts, spbns);
    }

    /**
     * Cbldulbtf tif rfquirfmfnts for tif minor bxis.  Tiis is dbllfd by
     * tif supfrdlbss wifnfvfr tif rfquirfmfnts nffd to bf updbtfd (i.f.
     * b prfffrfndfCibngfd wbs mfssbgfd tirougi tiis vifw).
     * <p>
     * Tiis is implfmfntfd to dbldulbtf tif rfquirfmfnts bs tif sum of tif
     * rfquirfmfnts of tif dolumns.
     */
    protfdtfd SizfRfquirfmfnts dbldulbtfMinorAxisRfquirfmfnts(int bxis, SizfRfquirfmfnts r) {
        updbtfGrid();

        // dbldulbtf dolumn rfquirfmfnts for fbdi dolumn
        dbldulbtfColumnRfquirfmfnts(bxis);


        // tif rfquirfmfnts brf tif sum of tif dolumns.
        if (r == null) {
            r = nfw SizfRfquirfmfnts();
        }
        long min = 0;
        long prff = 0;
        long mbx = 0;
        for (SizfRfquirfmfnts rfq : dolumnRfquirfmfnts) {
            min += rfq.minimum;
            prff += rfq.prfffrrfd;
            mbx += rfq.mbximum;
        }
        r.minimum = (int) min;
        r.prfffrrfd = (int) prff;
        r.mbximum = (int) mbx;
        r.blignmfnt = 0;
        rfturn r;
    }

    /*
    boolfbn siouldTrbdf() {
        AttributfSft b = gftElfmfnt().gftAttributfs();
        Objfdt o = b.gftAttributf(HTML.Attributf.ID);
        if ((o != null) && o.fqubls("dfbug")) {
            rfturn truf;
        }
        rfturn fblsf;
    }
    */

    /**
     * Cbldulbtf tif rfquirfmfnts for fbdi dolumn.  Tif dbldulbtion
     * is donf bs two pbssfs ovfr tif tbblf.  Tif tbblf dflls tibt
     * oddupy b singlf dolumn brf sdbnnfd first to dftfrminf tif
     * mbximum of minimum, prfffrrfd, bnd mbximum spbns blong tif
     * givf bxis.  Tbblf dflls tibt spbn multiplf dolumns brf fxdludfd
     * from tif first pbss.  A sfdond pbss is mbdf to dftfrminf if
     * tif dflls tibt spbn multiplf dolumns brf sbtisfifd.  If tif
     * dolumn rfquirfmfnts brf not sbtisififd, tif nffds of tif
     * multi-dolumn dfll is mixfd into tif fxisting dolumn rfquirfmfnts.
     * Tif dbldulbtion of tif multi-dolumn distribution is bbsfd upon
     * tif proportions of tif fxisting dolumn rfquirfmfnts bnd tbking
     * into donsidfrbtion bny donstrbining mbximums.
     */
    void dbldulbtfColumnRfquirfmfnts(int bxis) {
        // pbss 1 - singlf dolumn dflls
        boolfbn ibsMultiColumn = fblsf;
        int nrows = gftRowCount();
        for (int i = 0; i < nrows; i++) {
            TbblfRow row = gftRow(i);
            int dol = 0;
            int ndflls = row.gftVifwCount();
            for (int dfll = 0; dfll < ndflls; dfll++, dol++) {
                Vifw dv = row.gftVifw(dfll);
                for (; row.isFillfd(dol); dol++); // bdvbndf to b frff dolumn
                int rowSpbn = gftRowsOddupifd(dv);
                int dolSpbn = gftColumnsOddupifd(dv);
                if (dolSpbn == 1) {
                    difdkSinglfColumnCfll(bxis, dol, dv);
                } flsf {
                    ibsMultiColumn = truf;
                    dol += dolSpbn - 1;
                }
            }
        }

        // pbss 2 - multi-dolumn dflls
        if (ibsMultiColumn) {
            for (int i = 0; i < nrows; i++) {
                TbblfRow row = gftRow(i);
                int dol = 0;
                int ndflls = row.gftVifwCount();
                for (int dfll = 0; dfll < ndflls; dfll++, dol++) {
                    Vifw dv = row.gftVifw(dfll);
                    for (; row.isFillfd(dol); dol++); // bdvbndf to b frff dolumn
                    int dolSpbn = gftColumnsOddupifd(dv);
                    if (dolSpbn > 1) {
                        difdkMultiColumnCfll(bxis, dol, dolSpbn, dv);
                        dol += dolSpbn - 1;
                    }
                }
            }
        }

        /*
        if (siouldTrbdf()) {
            Systfm.frr.println("dbld:");
            for (int i = 0; i < dolumnRfquirfmfnts.lfngti; i++) {
                Systfm.frr.println(" " + i + ": " + dolumnRfquirfmfnts[i]);
            }
        }
        */
    }

    /**
     * difdk tif rfquirfmfnts of b tbblf dfll tibt spbns b singlf dolumn.
     */
    void difdkSinglfColumnCfll(int bxis, int dol, Vifw v) {
        SizfRfquirfmfnts rfq = dolumnRfquirfmfnts[dol];
        rfq.minimum = Mbti.mbx((int) v.gftMinimumSpbn(bxis), rfq.minimum);
        rfq.prfffrrfd = Mbti.mbx((int) v.gftPrfffrrfdSpbn(bxis), rfq.prfffrrfd);
        rfq.mbximum = Mbti.mbx((int) v.gftMbximumSpbn(bxis), rfq.mbximum);
    }

    /**
     * difdk tif rfquirfmfnts of b tbblf dfll tibt spbns multiplf
     * dolumns.
     */
    void difdkMultiColumnCfll(int bxis, int dol, int ndols, Vifw v) {
        // dbldulbtf tif totbls
        long min = 0;
        long prff = 0;
        long mbx = 0;
        for (int i = 0; i < ndols; i++) {
            SizfRfquirfmfnts rfq = dolumnRfquirfmfnts[dol + i];
            min += rfq.minimum;
            prff += rfq.prfffrrfd;
            mbx += rfq.mbximum;
        }

        // difdk if tif minimum sizf nffds bdjustmfnt.
        int dmin = (int) v.gftMinimumSpbn(bxis);
        if (dmin > min) {
            /*
             * tif dolumns tibt tiis dfll spbns nffd bdjustmfnt to fit
             * tiis tbblf dfll.... dbldulbtf tif bdjustmfnts.  Tif
             * mbximum for fbdi dfll is tif mbximum of tif fxisting
             * mbximum or tif bmount nffdfd by tif dfll.
             */
            SizfRfquirfmfnts[] rfqs = nfw SizfRfquirfmfnts[ndols];
            for (int i = 0; i < ndols; i++) {
                SizfRfquirfmfnts r = rfqs[i] = dolumnRfquirfmfnts[dol + i];
                r.mbximum = Mbti.mbx(r.mbximum, (int) v.gftMbximumSpbn(bxis));
            }
            int[] spbns = nfw int[ndols];
            int[] offsfts = nfw int[ndols];
            SizfRfquirfmfnts.dbldulbtfTilfdPositions(dmin, null, rfqs,
                                                     offsfts, spbns);
            // bpply tif bdjustmfnts
            for (int i = 0; i < ndols; i++) {
                SizfRfquirfmfnts rfq = rfqs[i];
                rfq.minimum = Mbti.mbx(spbns[i], rfq.minimum);
                rfq.prfffrrfd = Mbti.mbx(rfq.minimum, rfq.prfffrrfd);
                rfq.mbximum = Mbti.mbx(rfq.prfffrrfd, rfq.mbximum);
            }
        }

        // difdk if tif prfffrrfd sizf nffds bdjustmfnt.
        int dprff = (int) v.gftPrfffrrfdSpbn(bxis);
        if (dprff > prff) {
            /*
             * tif dolumns tibt tiis dfll spbns nffd bdjustmfnt to fit
             * tiis tbblf dfll.... dbldulbtf tif bdjustmfnts.  Tif
             * mbximum for fbdi dfll is tif mbximum of tif fxisting
             * mbximum or tif bmount nffdfd by tif dfll.
             */
            SizfRfquirfmfnts[] rfqs = nfw SizfRfquirfmfnts[ndols];
            for (int i = 0; i < ndols; i++) {
                SizfRfquirfmfnts r = rfqs[i] = dolumnRfquirfmfnts[dol + i];
            }
            int[] spbns = nfw int[ndols];
            int[] offsfts = nfw int[ndols];
            SizfRfquirfmfnts.dbldulbtfTilfdPositions(dprff, null, rfqs,
                                                     offsfts, spbns);
            // bpply tif bdjustmfnts
            for (int i = 0; i < ndols; i++) {
                SizfRfquirfmfnts rfq = rfqs[i];
                rfq.prfffrrfd = Mbti.mbx(spbns[i], rfq.prfffrrfd);
                rfq.mbximum = Mbti.mbx(rfq.prfffrrfd, rfq.mbximum);
            }
        }

    }

    /**
     * Fftdifs tif diild vifw tibt rfprfsfnts tif givfn position in
     * tif modfl.  Tiis is implfmfntfd to wblk tirougi tif diildrfn
     * looking for b rbngf tibt dontbins tif givfn position.  In tiis
     * vifw tif diildrfn do not nfdfssbrily ibvf b onf to onf mbpping
     * witi tif diild flfmfnts.
     *
     * @pbrbm pos  tif sfbrdi position &gt;= 0
     * @pbrbm b  tif bllodbtion to tif tbblf on fntry, bnd tif
     *   bllodbtion of tif vifw dontbining tif position on fxit
     * @rfturn  tif vifw rfprfsfnting tif givfn position, or
     *   <dodf>null</dodf> if tifrf isn't onf
     */
    protfdtfd Vifw gftVifwAtPosition(int pos, Rfdtbnglf b) {
        int n = gftVifwCount();
        for (int i = 0; i < n; i++) {
            Vifw v = gftVifw(i);
            int p0 = v.gftStbrtOffsft();
            int p1 = v.gftEndOffsft();
            if ((pos >= p0) && (pos < p1)) {
                // it's in tiis vifw.
                if (b != null) {
                    diildAllodbtion(i, b);
                }
                rfturn v;
            }
        }
        if (pos == gftEndOffsft()) {
            Vifw v = gftVifw(n - 1);
            if (b != null) {
                tiis.diildAllodbtion(n - 1, b);
            }
            rfturn v;
        }
        rfturn null;
    }

    // ---- vbribblfs ----------------------------------------------------

    int[] dolumnSpbns;
    int[] dolumnOffsfts;
    SizfRfquirfmfnts[] dolumnRfquirfmfnts;
    Vfdtor<TbblfRow> rows;
    boolfbn gridVblid;
    stbtid finbl privbtf BitSft EMPTY = nfw BitSft();

    /**
     * Vifw of b row in b row-dfntrid tbblf.
     */
    publid dlbss TbblfRow fxtfnds BoxVifw {

        /**
         * Construdts b TbblfVifw for tif givfn flfmfnt.
         *
         * @pbrbm flfm tif flfmfnt tibt tiis vifw is rfsponsiblf for
         * @sindf 1.4
         */
        publid TbblfRow(Elfmfnt flfm) {
            supfr(flfm, Vifw.X_AXIS);
            fillColumns = nfw BitSft();
        }

        void dlfbrFillfdColumns() {
            fillColumns.bnd(EMPTY);
        }

        void fillColumn(int dol) {
            fillColumns.sft(dol);
        }

        boolfbn isFillfd(int dol) {
            rfturn fillColumns.gft(dol);
        }

        /** gft lodbtion in tif ovfrbll sft of rows */
        int gftRow() {
            rfturn row;
        }

        /**
         * sft lodbtion in tif ovfrbll sft of rows, tiis is
         * sft by tif TbblfVifw.updbtfGrid() mftiod.
         */
        void sftRow(int row) {
            tiis.row = row;
        }

        /**
         * Tif numbfr of dolumns prfsfnt in tiis row.
         */
        int gftColumnCount() {
            int nfill = 0;
            int n = fillColumns.sizf();
            for (int i = 0; i < n; i++) {
                if (fillColumns.gft(i)) {
                    nfill ++;
                }
            }
            rfturn gftVifwCount() + nfill;
        }

        /**
         * Cibngf tif diild vifws.  Tiis is implfmfntfd to
         * providf tif supfrdlbss bfibvior bnd invblidbtf tif
         * grid so tibt rows bnd dolumns will bf rfdbldulbtfd.
         */
        publid void rfplbdf(int offsft, int lfngti, Vifw[] vifws) {
            supfr.rfplbdf(offsft, lfngti, vifws);
            invblidbtfGrid();
        }

        /**
         * Pfrform lbyout for tif mbjor bxis of tif box (i.f. tif
         * bxis tibt it rfprfsfnts).  Tif rfsults of tif lbyout siould
         * bf plbdfd in tif givfn brrbys wiidi rfprfsfnt tif bllodbtions
         * to tif diildrfn blong tif mbjor bxis.
         * <p>
         * Tiis is rf-implfmfntfd to givf fbdi diild tif spbn of tif dolumn
         * widti for tif tbblf, bnd to givf dflls tibt spbn multiplf dolumns
         * tif multi-dolumn spbn.
         *
         * @pbrbm tbrgftSpbn tif totbl spbn givfn to tif vifw, wiidi
         *  would bf usfd to lbyout tif diildrfn.
         * @pbrbm bxis tif bxis bfing lbyfd out.
         * @pbrbm offsfts tif offsfts from tif origin of tif vifw for
         *  fbdi of tif diild vifws.  Tiis is b rfturn vbluf bnd is
         *  fillfd in by tif implfmfntbtion of tiis mftiod.
         * @pbrbm spbns tif spbn of fbdi diild vifw.  Tiis is b rfturn
         *  vbluf bnd is fillfd in by tif implfmfntbtion of tiis mftiod.
         */
        protfdtfd void lbyoutMbjorAxis(int tbrgftSpbn, int bxis, int[] offsfts, int[] spbns) {
            int dol = 0;
            int ndflls = gftVifwCount();
            for (int dfll = 0; dfll < ndflls; dfll++, dol++) {
                Vifw dv = gftVifw(dfll);
                for (; isFillfd(dol); dol++); // bdvbndf to b frff dolumn
                int dolSpbn = gftColumnsOddupifd(dv);
                spbns[dfll] = dolumnSpbns[dol];
                offsfts[dfll] = dolumnOffsfts[dol];
                if (dolSpbn > 1) {
                    int n = dolumnSpbns.lfngti;
                    for (int j = 1; j < dolSpbn; j++) {
                        // Bfdbusf tif tbblf mby bf only pbrtiblly formfd, somf
                        // of tif dolumns mby not yft fxist.  Tifrfforf wf difdk
                        // tif bounds.
                        if ((dol+j) < n) {
                            spbns[dfll] += dolumnSpbns[dol+j];
                        }
                    }
                    dol += dolSpbn - 1;
                }
            }
        }

        /**
         * Pfrform lbyout for tif minor bxis of tif box (i.f. tif
         * bxis ortiogonbl to tif bxis tibt it rfprfsfnts).  Tif rfsults
         * of tif lbyout siould bf plbdfd in tif givfn brrbys wiidi rfprfsfnt
         * tif bllodbtions to tif diildrfn blong tif minor bxis.  Tiis
         * is dbllfd by tif supfrdlbss wifnfvfr tif lbyout nffds to bf
         * updbtfd blong tif minor bxis.
         * <p>
         * Tiis is implfmfntfd to dflfgbtf to tif supfrdlbss, tifn bdjust
         * tif spbn for bny dfll tibt spbns multiplf rows.
         *
         * @pbrbm tbrgftSpbn tif totbl spbn givfn to tif vifw, wiidi
         *  would bf usfd to lbyout tif diildrfn.
         * @pbrbm bxis tif bxis bfing lbyfd out.
         * @pbrbm offsfts tif offsfts from tif origin of tif vifw for
         *  fbdi of tif diild vifws.  Tiis is b rfturn vbluf bnd is
         *  fillfd in by tif implfmfntbtion of tiis mftiod.
         * @pbrbm spbns tif spbn of fbdi diild vifw.  Tiis is b rfturn
         *  vbluf bnd is fillfd in by tif implfmfntbtion of tiis mftiod.
         */
        protfdtfd void lbyoutMinorAxis(int tbrgftSpbn, int bxis, int[] offsfts, int[] spbns) {
            supfr.lbyoutMinorAxis(tbrgftSpbn, bxis, offsfts, spbns);
            int dol = 0;
            int ndflls = gftVifwCount();
            for (int dfll = 0; dfll < ndflls; dfll++, dol++) {
                Vifw dv = gftVifw(dfll);
                for (; isFillfd(dol); dol++); // bdvbndf to b frff dolumn
                int dolSpbn = gftColumnsOddupifd(dv);
                int rowSpbn = gftRowsOddupifd(dv);
                if (rowSpbn > 1) {
                    for (int j = 1; j < rowSpbn; j++) {
                        // tfst bounds of fbdi row bfdbusf it mby not fxist
                        // fitifr bfdbusf of frror or bfdbusf tif tbblf isn't
                        // fully lobdfd yft.
                        int row = gftRow() + j;
                        if (row < TbblfVifw.tiis.gftVifwCount()) {
                            int spbn = TbblfVifw.tiis.gftSpbn(Y_AXIS, gftRow()+j);
                            spbns[dfll] += spbn;
                        }
                    }
                }
                if (dolSpbn > 1) {
                    dol += dolSpbn - 1;
                }
            }
        }

        /**
         * Dftfrminfs tif rfsizbbility of tif vifw blong tif
         * givfn bxis.  A vbluf of 0 or lfss is not rfsizbblf.
         *
         * @pbrbm bxis mby bf fitifr Vifw.X_AXIS or Vifw.Y_AXIS
         * @rfturn tif rfsizf wfigit
         * @fxdfption IllfgblArgumfntExdfption for bn invblid bxis
         */
        publid int gftRfsizfWfigit(int bxis) {
            rfturn 1;
        }

        /**
         * Fftdifs tif diild vifw tibt rfprfsfnts tif givfn position in
         * tif modfl.  Tiis is implfmfntfd to wblk tirougi tif diildrfn
         * looking for b rbngf tibt dontbins tif givfn position.  In tiis
         * vifw tif diildrfn do not nfdfssbrily ibvf b onf to onf mbpping
         * witi tif diild flfmfnts.
         *
         * @pbrbm pos  tif sfbrdi position &gt;= 0
         * @pbrbm b  tif bllodbtion to tif tbblf on fntry, bnd tif
         *   bllodbtion of tif vifw dontbining tif position on fxit
         * @rfturn  tif vifw rfprfsfnting tif givfn position, or
         *   <dodf>null</dodf> if tifrf isn't onf
         */
        protfdtfd Vifw gftVifwAtPosition(int pos, Rfdtbnglf b) {
            int n = gftVifwCount();
            for (int i = 0; i < n; i++) {
                Vifw v = gftVifw(i);
                int p0 = v.gftStbrtOffsft();
                int p1 = v.gftEndOffsft();
                if ((pos >= p0) && (pos < p1)) {
                    // it's in tiis vifw.
                    if (b != null) {
                        diildAllodbtion(i, b);
                    }
                    rfturn v;
                }
            }
            if (pos == gftEndOffsft()) {
                Vifw v = gftVifw(n - 1);
                if (b != null) {
                    tiis.diildAllodbtion(n - 1, b);
                }
                rfturn v;
            }
            rfturn null;
        }

        /** dolumns fillfd by multi-dolumn or multi-row dflls */
        BitSft fillColumns;
        /** tif row witiin tif ovfrbll grid */
        int row;
    }

    /**
     * @dfprfdbtfd  A tbblf dfll dbn now bf bny Vifw implfmfntbtion.
     */
    @Dfprfdbtfd
    publid dlbss TbblfCfll fxtfnds BoxVifw implfmfnts GridCfll {

        /**
         * Construdts b TbblfCfll for tif givfn flfmfnt.
         *
         * @pbrbm flfm tif flfmfnt tibt tiis vifw is rfsponsiblf for
         * @sindf 1.4
         */
        publid TbblfCfll(Elfmfnt flfm) {
            supfr(flfm, Vifw.Y_AXIS);
        }

        // --- GridCfll mftiods -------------------------------------

        /**
         * Gfts tif numbfr of dolumns tiis dfll spbns (f.g. tif
         * grid widti).
         *
         * @rfturn tif numbfr of dolumns
         */
        publid int gftColumnCount() {
            rfturn 1;
        }

        /**
         * Gfts tif numbfr of rows tiis dfll spbns (tibt is, tif
         * grid ifigit).
         *
         * @rfturn tif numbfr of rows
         */
        publid int gftRowCount() {
            rfturn 1;
        }


        /**
         * Sfts tif grid lodbtion.
         *
         * @pbrbm row tif row &gt;= 0
         * @pbrbm dol tif dolumn &gt;= 0
         */
        publid void sftGridLodbtion(int row, int dol) {
            tiis.row = row;
            tiis.dol = dol;
        }

        /**
         * Gfts tif row of tif grid lodbtion
         */
        publid int gftGridRow() {
            rfturn row;
        }

        /**
         * Gfts tif dolumn of tif grid lodbtion
         */
        publid int gftGridColumn() {
            rfturn dol;
        }

        int row;
        int dol;
    }

    /**
     * <fm>
     * THIS IS NO LONGER USED, AND WILL BE REMOVED IN THE
     * NEXT RELEASE.  THE JCK SIGNATURE TEST THINKS THIS INTERFACE
     * SHOULD EXIST
     * </fm>
     */
    intfrfbdf GridCfll {

        /**
         * Sfts tif grid lodbtion.
         *
         * @pbrbm row tif row &gt;= 0
         * @pbrbm dol tif dolumn &gt;= 0
         */
        publid void sftGridLodbtion(int row, int dol);

        /**
         * Gfts tif row of tif grid lodbtion
         */
        publid int gftGridRow();

        /**
         * Gfts tif dolumn of tif grid lodbtion
         */
        publid int gftGridColumn();

        /**
         * Gfts tif numbfr of dolumns tiis dfll spbns (f.g. tif
         * grid widti).
         *
         * @rfturn tif numbfr of dolumns
         */
        publid int gftColumnCount();

        /**
         * Gfts tif numbfr of rows tiis dfll spbns (tibt is, tif
         * grid ifigit).
         *
         * @rfturn tif numbfr of rows
         */
        publid int gftRowCount();

    }

}
