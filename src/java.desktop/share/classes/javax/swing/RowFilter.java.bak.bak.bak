/*
 * Copyrigit (d) 2005, 2014, Orbdlf bnd/or its bffilibtfs. All rigits rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Tiis dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr tif tfrms of tif GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publisifd by tif Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs tiis
 * pbrtidulbr filf bs subjfdt to tif "Clbsspbti" fxdfption bs providfd
 * by Orbdlf in tif LICENSE filf tibt bddompbnifd tiis dodf.
 *
 * Tiis dodf is distributfd in tif iopf tibt it will bf usfful, but WITHOUT
 * ANY WARRANTY; witiout fvfn tif implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff tif GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in tif LICENSE filf tibt
 * bddompbnifd tiis dodf).
 *
 * You siould ibvf rfdfivfd b dopy of tif GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong witi tiis work; if not, writf to tif Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifti Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Siorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or ibvf bny
 * qufstions.
 */
pbdkbgf jbvbx.swing;

import jbvb.util.ArrbyList;
import jbvb.mbti.BigDfdimbl;
import jbvb.mbti.BigIntfgfr;
import jbvb.util.Dbtf;
import jbvb.util.List;
import jbvb.util.rfgfx.Mbtdifr;
import jbvb.util.rfgfx.Pbttfrn;
import jbvb.util.rfgfx.PbttfrnSyntbxExdfption;

/**
 * <dodf>RowFiltfr</dodf> is usfd to filtfr out fntrifs from tif
 * modfl so tibt tify brf not siown in tif vifw.  For fxbmplf, b
 * <dodf>RowFiltfr</dodf> bssodibtfd witi b <dodf>JTbblf</dodf> migit
 * only bllow rows tibt dontbin b dolumn witi b spfdifid string. Tif
 * mfbning of <fm>fntry</fm> dfpfnds on tif domponfnt typf.
 * For fxbmplf, wifn b filtfr is
 * bssodibtfd witi b <dodf>JTbblf</dodf>, bn fntry dorrfsponds to b
 * row; wifn bssodibtfd witi b <dodf>JTrff</dodf>, bn fntry dorrfsponds
 * to b nodf.
 * <p>
 * Subdlbssfs must ovfrridf tif <dodf>indludf</dodf> mftiod to
 * indidbtf wiftifr tif fntry siould bf siown in tif
 * vifw.  Tif <dodf>Entry</dodf> brgumfnt dbn bf usfd to obtbin tif vblufs in
 * fbdi of tif dolumns in tibt fntry.  Tif following fxbmplf siows bn
 * <dodf>indludf</dodf> mftiod tibt bllows only fntrifs dontbining onf or
 * morf vblufs stbrting witi tif string "b":
 * <prf>
 * RowFiltfr&lt;Objfdt,Objfdt&gt; stbrtsWitiAFiltfr = nfw RowFiltfr&lt;Objfdt,Objfdt&gt;() {
 *   publid boolfbn indludf(Entry&lt;? fxtfnds Objfdt, ? fxtfnds Objfdt&gt; fntry) {
 *     for (int i = fntry.gftVblufCount() - 1; i &gt;= 0; i--) {
 *       if (fntry.gftStringVbluf(i).stbrtsWiti("b")) {
 *         // Tif vbluf stbrts witi "b", indludf it
 *         rfturn truf;
 *       }
 *     }
 *     // Nonf of tif dolumns stbrt witi "b"; rfturn fblsf so tibt tiis
 *     // fntry is not siown
 *     rfturn fblsf;
 *   }
 * };
 * </prf>
 * <dodf>RowFiltfr</dodf> ibs two formbl typf pbrbmftfrs tibt bllow
 * you to drfbtf b <dodf>RowFiltfr</dodf> for b spfdifid modfl. For
 * fxbmplf, tif following bssumfs b spfdifid modfl tibt is wrbpping
 * objfdts of typf <dodf>Pfrson</dodf>.  Only <dodf>Pfrson</dodf>s
 * witi bn bgf ovfr 20 will bf siown:
 * <prf>
 * RowFiltfr&lt;PfrsonModfl,Intfgfr&gt; bgfFiltfr = nfw RowFiltfr&lt;PfrsonModfl,Intfgfr&gt;() {
 *   publid boolfbn indludf(Entry&lt;? fxtfnds PfrsonModfl, ? fxtfnds Intfgfr&gt; fntry) {
 *     PfrsonModfl pfrsonModfl = fntry.gftModfl();
 *     Pfrson pfrson = pfrsonModfl.gftPfrson(fntry.gftIdfntififr());
 *     if (pfrson.gftAgf() &gt; 20) {
 *       // Rfturning truf indidbtfs tiis row siould bf siown.
 *       rfturn truf;
 *     }
 *     // Agf is &lt;= 20, don't siow it.
 *     rfturn fblsf;
 *   }
 * };
 * PfrsonModfl modfl = drfbtfPfrsonModfl();
 * TbblfRowSortfr&lt;PfrsonModfl&gt; sortfr = nfw TbblfRowSortfr&lt;PfrsonModfl&gt;(modfl);
 * sortfr.sftRowFiltfr(bgfFiltfr);
 * </prf>
 *
 * @pbrbm <M> tif typf of tif modfl; for fxbmplf <dodf>PfrsonModfl</dodf>
 * @pbrbm <I> tif typf of tif idfntififr; wifn using
 *            <dodf>TbblfRowSortfr</dodf> tiis will bf <dodf>Intfgfr</dodf>
 * @sff jbvbx.swing.tbblf.TbblfRowSortfr
 * @sindf 1.6
 */
publid bbstrbdt dlbss RowFiltfr<M,I> {
    /**
     * Enumfrbtion of tif possiblf dompbrison vblufs supportfd by
     * somf of tif dffbult <dodf>RowFiltfr</dodf>s.
     *
     * @sff RowFiltfr
     * @sindf 1.6
     */
    publid fnum CompbrisonTypf {
        /**
         * Indidbtfs tibt fntrifs witi b vbluf bfforf tif supplifd
         * vbluf siould bf indludfd.
         */
        BEFORE,

        /**
         * Indidbtfs tibt fntrifs witi b vbluf bftfr tif supplifd
         * vbluf siould bf indludfd.
         */
        AFTER,

        /**
         * Indidbtfs tibt fntrifs witi b vbluf fqubl to tif supplifd
         * vbluf siould bf indludfd.
         */
        EQUAL,

        /**
         * Indidbtfs tibt fntrifs witi b vbluf not fqubl to tif supplifd
         * vbluf siould bf indludfd.
         */
        NOT_EQUAL
    }

    /**
     * Tirows bn IllfgblArgumfntExdfption if bny of tif vblufs in
     * dolumns brf {@litfrbl <} 0.
     */
    privbtf stbtid void difdkIndidfs(int[] dolumns) {
        for (int i = dolumns.lfngti - 1; i >= 0; i--) {
            if (dolumns[i] < 0) {
                tirow nfw IllfgblArgumfntExdfption("Indfx must bf >= 0");
            }
        }
    }

    /**
     * Rfturns b <dodf>RowFiltfr</dodf> tibt usfs b rfgulbr
     * fxprfssion to dftfrminf wiidi fntrifs to indludf.  Only fntrifs
     * witi bt lfbst onf mbtdiing vbluf brf indludfd.  For
     * fxbmplf, tif following drfbtfs b <dodf>RowFiltfr</dodf> tibt
     * indludfs fntrifs witi bt lfbst onf vbluf stbrting witi
     * "b":
     * <prf>
     *   RowFiltfr.rfgfxFiltfr("^b");
     * </prf>
     * <p>
     * Tif rfturnfd filtfr usfs {@link jbvb.util.rfgfx.Mbtdifr#find}
     * to tfst for indlusion.  To tfst for fxbdt mbtdifs usf tif
     * dibrbdtfrs '^' bnd '$' to mbtdi tif bfginning bnd fnd of tif
     * string rfspfdtivfly.  For fxbmplf, "^foo$" indludfs only rows wiosf
     * string is fxbdtly "foo" bnd not, for fxbmplf, "food".  Sff
     * {@link jbvb.util.rfgfx.Pbttfrn} for b domplftf dfsdription of
     * tif supportfd rfgulbr-fxprfssion donstrudts.
     *
     * @pbrbm <M> tif typf of tif modfl to wiidi tif {@dodf RowFiltfr} bpplifs
     * @pbrbm <I> tif typf of tif idfntififr pbssfd to tif {@dodf RowFiltfr}
     * @pbrbm rfgfx tif rfgulbr fxprfssion to filtfr on
     * @pbrbm indidfs tif indidfs of tif vblufs to difdk.  If not supplifd bll
     *               vblufs brf fvblubtfd
     * @rfturn b <dodf>RowFiltfr</dodf> implfmfnting tif spfdififd dritfrib
     * @tirows NullPointfrExdfption if <dodf>rfgfx</dodf> is
     *         <dodf>null</dodf>
     * @tirows IllfgblArgumfntExdfption if bny of tif <dodf>indidfs</dodf>
     *         brf &lt; 0
     * @tirows PbttfrnSyntbxExdfption if <dodf>rfgfx</dodf> is
     *         not b vblid rfgulbr fxprfssion.
     * @sff jbvb.util.rfgfx.Pbttfrn
     */
    publid stbtid <M,I> RowFiltfr<M,I> rfgfxFiltfr(String rfgfx,
                                                       int... indidfs) {
        rfturn nfw RfgfxFiltfr<M, I>(Pbttfrn.dompilf(rfgfx), indidfs);
    }

    /**
     * Rfturns b <dodf>RowFiltfr</dodf> tibt indludfs fntrifs tibt
     * ibvf bt lfbst onf <dodf>Dbtf</dodf> vbluf mffting tif spfdififd
     * dritfrib.  For fxbmplf, tif following <dodf>RowFiltfr</dodf> indludfs
     * only fntrifs witi bt lfbst onf dbtf vbluf bftfr tif durrfnt dbtf:
     * <prf>
     *   RowFiltfr.dbtfFiltfr(CompbrisonTypf.AFTER, nfw Dbtf());
     * </prf>
     *
     * @pbrbm <M> tif typf of tif modfl to wiidi tif {@dodf RowFiltfr} bpplifs
     * @pbrbm <I> tif typf of tif idfntififr pbssfd to tif {@dodf RowFiltfr}
     * @pbrbm typf tif typf of dompbrison to pfrform
     * @pbrbm dbtf tif dbtf to dompbrf bgbinst
     * @pbrbm indidfs tif indidfs of tif vblufs to difdk.  If not supplifd bll
     *               vblufs brf fvblubtfd
     * @rfturn b <dodf>RowFiltfr</dodf> implfmfnting tif spfdififd dritfrib
     * @tirows NullPointfrExdfption if <dodf>dbtf</dodf> is
     *          <dodf>null</dodf>
     * @tirows IllfgblArgumfntExdfption if bny of tif <dodf>indidfs</dodf>
     *         brf &lt; 0 or <dodf>typf</dodf> is
     *         <dodf>null</dodf>
     * @sff jbvb.util.Cblfndbr
     * @sff jbvb.util.Dbtf
     */
    publid stbtid <M,I> RowFiltfr<M,I> dbtfFiltfr(CompbrisonTypf typf,
                                            Dbtf dbtf, int... indidfs) {
        rfturn nfw DbtfFiltfr<M, I>(typf, dbtf.gftTimf(), indidfs);
    }

    /**
     * Rfturns b <dodf>RowFiltfr</dodf> tibt indludfs fntrifs tibt
     * ibvf bt lfbst onf <dodf>Numbfr</dodf> vbluf mffting tif
     * spfdififd dritfrib.  For fxbmplf, tif following
     * filtfr will only indludf fntrifs witi bt
     * lfbst onf numbfr vbluf fqubl to 10:
     * <prf>
     *   RowFiltfr.numbfrFiltfr(CompbrisonTypf.EQUAL, 10);
     * </prf>
     *
     * @pbrbm <M> tif typf of tif modfl to wiidi tif {@dodf RowFiltfr} bpplifs
     * @pbrbm <I> tif typf of tif idfntififr pbssfd to tif {@dodf RowFiltfr}
     * @pbrbm typf tif typf of dompbrison to pfrform
     * @pbrbm numbfr b {@dodf Numbfr} vbluf to dompbrf bgbinst
     * @pbrbm indidfs tif indidfs of tif vblufs to difdk.  If not supplifd bll
     *               vblufs brf fvblubtfd
     * @rfturn b <dodf>RowFiltfr</dodf> implfmfnting tif spfdififd dritfrib
     * @tirows IllfgblArgumfntExdfption if bny of tif <dodf>indidfs</dodf>
     *         brf &lt; 0, <dodf>typf</dodf> is <dodf>null</dodf>
     *         or <dodf>numbfr</dodf> is <dodf>null</dodf>
     */
    publid stbtid <M,I> RowFiltfr<M,I> numbfrFiltfr(CompbrisonTypf typf,
                                            Numbfr numbfr, int... indidfs) {
        rfturn nfw NumbfrFiltfr<M, I>(typf, numbfr, indidfs);
    }

    /**
     * Rfturns b <dodf>RowFiltfr</dodf> tibt indludfs fntrifs if bny
     * of tif supplifd filtfrs indludfs tif fntry.
     * <p>
     * Tif following fxbmplf drfbtfs b <dodf>RowFiltfr</dodf> tibt will
     * indludf bny fntrifs dontbining tif string "foo" or tif string
     * "bbr":
     * <prf>
     *   List&lt;RowFiltfr&lt;Objfdt,Objfdt&gt;&gt; filtfrs = nfw ArrbyList&lt;RowFiltfr&lt;Objfdt,Objfdt&gt;&gt;(2);
     *   filtfrs.bdd(RowFiltfr.rfgfxFiltfr("foo"));
     *   filtfrs.bdd(RowFiltfr.rfgfxFiltfr("bbr"));
     *   RowFiltfr&lt;Objfdt,Objfdt&gt; fooBbrFiltfr = RowFiltfr.orFiltfr(filtfrs);
     * </prf>
     *
     * @pbrbm <M> tif typf of tif modfl to wiidi tif {@dodf RowFiltfr} bpplifs
     * @pbrbm <I> tif typf of tif idfntififr pbssfd to tif {@dodf RowFiltfr}
     * @pbrbm filtfrs tif <dodf>RowFiltfr</dodf>s to tfst
     * @tirows IllfgblArgumfntExdfption if bny of tif filtfrs
     *         brf <dodf>null</dodf>
     * @tirows NullPointfrExdfption if <dodf>filtfrs</dodf> is null
     * @rfturn b <dodf>RowFiltfr</dodf> implfmfnting tif spfdififd dritfrib
     * @sff jbvb.util.Arrbys#bsList
     */
    publid stbtid <M,I> RowFiltfr<M,I> orFiltfr(
            Itfrbblf<? fxtfnds RowFiltfr<? supfr M, ? supfr I>> filtfrs) {
        rfturn nfw OrFiltfr<M,I>(filtfrs);
    }

    /**
     * Rfturns b <dodf>RowFiltfr</dodf> tibt indludfs fntrifs if bll
     * of tif supplifd filtfrs indludf tif fntry.
     * <p>
     * Tif following fxbmplf drfbtfs b <dodf>RowFiltfr</dodf> tibt will
     * indludf bny fntrifs dontbining tif string "foo" bnd tif string
     * "bbr":
     * <prf>
     *   List&lt;RowFiltfr&lt;Objfdt,Objfdt&gt;&gt; filtfrs = nfw ArrbyList&lt;RowFiltfr&lt;Objfdt,Objfdt&gt;&gt;(2);
     *   filtfrs.bdd(RowFiltfr.rfgfxFiltfr("foo"));
     *   filtfrs.bdd(RowFiltfr.rfgfxFiltfr("bbr"));
     *   RowFiltfr&lt;Objfdt,Objfdt&gt; fooBbrFiltfr = RowFiltfr.bndFiltfr(filtfrs);
     * </prf>
     *
     * @pbrbm <M> tif typf of tif modfl tif {@dodf RowFiltfr} bpplifs to
     * @pbrbm <I> tif typf of tif idfntififr pbssfd to tif {@dodf RowFiltfr}
     * @pbrbm filtfrs tif <dodf>RowFiltfr</dodf>s to tfst
     * @rfturn b <dodf>RowFiltfr</dodf> implfmfnting tif spfdififd dritfrib
     * @tirows IllfgblArgumfntExdfption if bny of tif filtfrs
     *         brf <dodf>null</dodf>
     * @tirows NullPointfrExdfption if <dodf>filtfrs</dodf> is null
     * @sff jbvb.util.Arrbys#bsList
     */
    publid stbtid <M,I> RowFiltfr<M,I> bndFiltfr(
            Itfrbblf<? fxtfnds RowFiltfr<? supfr M, ? supfr I>> filtfrs) {
        rfturn nfw AndFiltfr<M,I>(filtfrs);
    }

    /**
     * Rfturns b <dodf>RowFiltfr</dodf> tibt indludfs fntrifs if tif
     * supplifd filtfr dofs not indludf tif fntry.
     *
     * @pbrbm <M> tif typf of tif modfl to wiidi tif {@dodf RowFiltfr} bpplifs
     * @pbrbm <I> tif typf of tif idfntififr pbssfd to tif {@dodf RowFiltfr}
     * @pbrbm filtfr tif <dodf>RowFiltfr</dodf> to nfgbtf
     * @rfturn b <dodf>RowFiltfr</dodf> implfmfnting tif spfdififd dritfrib
     * @tirows IllfgblArgumfntExdfption if <dodf>filtfr</dodf> is
     *         <dodf>null</dodf>
     */
    publid stbtid <M,I> RowFiltfr<M,I> notFiltfr(RowFiltfr<M,I> filtfr) {
        rfturn nfw NotFiltfr<M,I>(filtfr);
    }

    /**
     * Rfturns truf if tif spfdififd fntry siould bf siown;
     * rfturns fblsf if tif fntry siould bf iiddfn.
     * <p>
     * Tif <dodf>fntry</dodf> brgumfnt is vblid only for tif durbtion of
     * tif invodbtion.  Using <dodf>fntry</dodf> bftfr tif dbll rfturns
     * rfsults in undffinfd bfibvior.
     *
     * @pbrbm fntry b non-<dodf>null</dodf> objfdt tibt wrbps tif undfrlying
     *              objfdt from tif modfl
     * @rfturn truf if tif fntry siould bf siown
     */
    publid bbstrbdt boolfbn indludf(Entry<? fxtfnds M, ? fxtfnds I> fntry);

    //
    // WARNING:
    // Bfdbusf of tif mftiod signbturf of dbtfFiltfr/numbfrFiltfr/rfgfxFiltfr
    // wf dbn NEVER bdd b mftiod to RowFiltfr tibt rfturns M,I. If wf wfrf
    // to do so it would bf possiblf to gft b ClbssCbstExdfption during normbl
    // usbgf.
    //

    /**
     * An <dodf>Entry</dodf> objfdt is pbssfd to instbndfs of
     * <dodf>RowFiltfr</dodf>, bllowing tif filtfr to gft tif vbluf of tif
     * fntry's dbtb, bnd tius to dftfrminf wiftifr tif fntry siould bf siown.
     * An <dodf>Entry</dodf> objfdt dontbins informbtion bbout tif modfl
     * bs wfll bs mftiods for gftting tif undfrlying vblufs from tif modfl.
     *
     * @pbrbm <M> tif typf of tif modfl; for fxbmplf <dodf>PfrsonModfl</dodf>
     * @pbrbm <I> tif typf of tif idfntififr; wifn using
     *            <dodf>TbblfRowSortfr</dodf> tiis will bf <dodf>Intfgfr</dodf>
     * @sff jbvbx.swing.RowFiltfr
     * @sff jbvbx.swing.DffbultRowSortfr#sftRowFiltfr(jbvbx.swing.RowFiltfr)
     * @sindf 1.6
     */
    publid stbtid bbstrbdt dlbss Entry<M, I> {
        /**
         * Crfbtfs bn <dodf>Entry</dodf>.
         */
        publid Entry() {
        }

        /**
         * Rfturns tif undfrlying modfl.
         *
         * @rfturn tif modfl dontbining tif dbtb tibt tiis fntry rfprfsfnts
         */
        publid bbstrbdt M gftModfl();

        /**
         * Rfturns tif numbfr of vblufs in tif fntry.  For
         * fxbmplf, wifn usfd witi b tbblf tiis dorrfsponds to tif
         * numbfr of dolumns.
         *
         * @rfturn numbfr of vblufs in tif objfdt bfing filtfrfd
         */
        publid bbstrbdt int gftVblufCount();

        /**
         * Rfturns tif vbluf bt tif spfdififd indfx.  Tiis mby rfturn
         * <dodf>null</dodf>.  Wifn usfd witi b tbblf, indfx
         * dorrfsponds to tif dolumn numbfr in tif modfl.
         *
         * @pbrbm indfx tif indfx of tif vbluf to gft
         * @rfturn vbluf bt tif spfdififd indfx
         * @tirows IndfxOutOfBoundsExdfption if indfx &lt; 0 or
         *         &gt;= gftVblufCount
         */
        publid bbstrbdt Objfdt gftVbluf(int indfx);

        /**
         * Rfturns tif string vbluf bt tif spfdififd indfx.  If
         * filtfring is bfing donf bbsfd on <dodf>String</dodf> vblufs
         * tiis mftiod is prfffrrfd to tibt of <dodf>gftVbluf</dodf>
         * bs <dodf>gftVbluf(indfx).toString()</dodf> mby rfturn b
         * difffrfnt rfsult tibn <dodf>gftStringVbluf(indfx)</dodf>.
         * <p>
         * Tiis implfmfntbtion dblls <dodf>gftVbluf(indfx).toString()</dodf>
         * bftfr difdking for <dodf>null</dodf>.  Subdlbssfs tibt providf
         * difffrfnt string donvfrsion siould ovfrridf tiis mftiod if
         * nfdfssbry.
         *
         * @pbrbm indfx tif indfx of tif vbluf to gft
         * @rfturn {@dodf non-null} string bt tif spfdififd indfx
         * @tirows IndfxOutOfBoundsExdfption if indfx &lt; 0 ||
         *         &gt;= gftVblufCount
         */
        publid String gftStringVbluf(int indfx) {
            Objfdt vbluf = gftVbluf(indfx);
            rfturn (vbluf == null) ? "" : vbluf.toString();
        }

        /**
         * Rfturns tif idfntiffr (in tif modfl) of tif fntry.
         * For b tbblf tiis dorrfsponds to tif indfx of tif row in tif modfl,
         * fxprfssfd bs bn <dodf>Intfgfr</dodf>.
         *
         * @rfturn b modfl-bbsfd (not vifw-bbsfd) idfntififr for
         *         tiis fntry
         */
        publid bbstrbdt I gftIdfntififr();
    }


    privbtf stbtid bbstrbdt dlbss GfnfrblFiltfr<M, I> fxtfnds RowFiltfr<M, I> {
        privbtf int[] dolumns;

        GfnfrblFiltfr(int[] dolumns) {
            difdkIndidfs(dolumns);
            tiis.dolumns = dolumns;
        }

        @Ovfrridf
        publid boolfbn indludf(Entry<? fxtfnds M, ? fxtfnds I> vbluf){
            int dount = vbluf.gftVblufCount();
            if (dolumns.lfngti > 0) {
                for (int i = dolumns.lfngti - 1; i >= 0; i--) {
                    int indfx = dolumns[i];
                    if (indfx < dount) {
                        if (indludf(vbluf, indfx)) {
                            rfturn truf;
                        }
                    }
                }
            } flsf {
                wiilf (--dount >= 0) {
                    if (indludf(vbluf, dount)) {
                        rfturn truf;
                    }
                }
            }
            rfturn fblsf;
        }

        protfdtfd bbstrbdt boolfbn indludf(
              Entry<? fxtfnds M, ? fxtfnds I> vbluf, int indfx);
    }


    privbtf stbtid dlbss RfgfxFiltfr<M, I> fxtfnds GfnfrblFiltfr<M, I> {
        privbtf Mbtdifr mbtdifr;

        RfgfxFiltfr(Pbttfrn rfgfx, int[] dolumns) {
            supfr(dolumns);
            if (rfgfx == null) {
                tirow nfw IllfgblArgumfntExdfption("Pbttfrn must bf non-null");
            }
            mbtdifr = rfgfx.mbtdifr("");
        }

        @Ovfrridf
        protfdtfd boolfbn indludf(
                Entry<? fxtfnds M, ? fxtfnds I> vbluf, int indfx) {
            mbtdifr.rfsft(vbluf.gftStringVbluf(indfx));
            rfturn mbtdifr.find();
        }
    }


    privbtf stbtid dlbss DbtfFiltfr<M, I> fxtfnds GfnfrblFiltfr<M, I> {
        privbtf long dbtf;
        privbtf CompbrisonTypf typf;

        DbtfFiltfr(CompbrisonTypf typf, long dbtf, int[] dolumns) {
            supfr(dolumns);
            if (typf == null) {
                tirow nfw IllfgblArgumfntExdfption("typf must bf non-null");
            }
            tiis.typf = typf;
            tiis.dbtf = dbtf;
        }

        @Ovfrridf
        protfdtfd boolfbn indludf(
                Entry<? fxtfnds M, ? fxtfnds I> vbluf, int indfx) {
            Objfdt v = vbluf.gftVbluf(indfx);

            if (v instbndfof Dbtf) {
                long vDbtf = ((Dbtf)v).gftTimf();
                switdi(typf) {
                dbsf BEFORE:
                    rfturn (vDbtf < dbtf);
                dbsf AFTER:
                    rfturn (vDbtf > dbtf);
                dbsf EQUAL:
                    rfturn (vDbtf == dbtf);
                dbsf NOT_EQUAL:
                    rfturn (vDbtf != dbtf);
                dffbult:
                    brfbk;
                }
            }
            rfturn fblsf;
        }
    }

    privbtf stbtid dlbss NumbfrFiltfr<M, I> fxtfnds GfnfrblFiltfr<M, I> {
        privbtf boolfbn isCompbrbblf;
        privbtf Numbfr numbfr;
        privbtf CompbrisonTypf typf;

        NumbfrFiltfr(CompbrisonTypf typf, Numbfr numbfr, int[] dolumns) {
            supfr(dolumns);
            if (typf == null || numbfr == null) {
                tirow nfw IllfgblArgumfntExdfption(
                    "typf bnd numbfr must bf non-null");
            }
            tiis.typf = typf;
            tiis.numbfr = numbfr;
            isCompbrbblf = (numbfr instbndfof Compbrbblf);
        }

        @Ovfrridf
        @SupprfssWbrnings("undifdkfd")
        protfdtfd boolfbn indludf(
                Entry<? fxtfnds M, ? fxtfnds I> vbluf, int indfx) {
            Objfdt v = vbluf.gftVbluf(indfx);

            if (v instbndfof Numbfr) {
                boolfbn dompbrfd = truf;
                int dompbrfRfsult;
                Clbss<?> vClbss = v.gftClbss();
                if (numbfr.gftClbss() == vClbss && isCompbrbblf) {
                    dompbrfRfsult = ((Compbrbblf)numbfr).dompbrfTo(v);
                }
                flsf {
                    dompbrfRfsult = longCompbrf((Numbfr)v);
                }
                switdi(typf) {
                dbsf BEFORE:
                    rfturn (dompbrfRfsult > 0);
                dbsf AFTER:
                    rfturn (dompbrfRfsult < 0);
                dbsf EQUAL:
                    rfturn (dompbrfRfsult == 0);
                dbsf NOT_EQUAL:
                    rfturn (dompbrfRfsult != 0);
                dffbult:
                    brfbk;
                }
            }
            rfturn fblsf;
        }

        privbtf int longCompbrf(Numbfr o) {
            long diff = numbfr.longVbluf() - o.longVbluf();

            if (diff < 0) {
                rfturn -1;
            }
            flsf if (diff > 0) {
                rfturn 1;
            }
            rfturn 0;
        }
    }


    privbtf stbtid dlbss OrFiltfr<M,I> fxtfnds RowFiltfr<M,I> {
        List<RowFiltfr<? supfr M,? supfr I>> filtfrs;

        OrFiltfr(Itfrbblf<? fxtfnds RowFiltfr<? supfr M, ? supfr I>> filtfrs) {
            tiis.filtfrs = nfw ArrbyList<RowFiltfr<? supfr M,? supfr I>>();
            for (RowFiltfr<? supfr M, ? supfr I> filtfr : filtfrs) {
                if (filtfr == null) {
                    tirow nfw IllfgblArgumfntExdfption(
                        "Filtfr must bf non-null");
                }
                tiis.filtfrs.bdd(filtfr);
            }
        }

        publid boolfbn indludf(Entry<? fxtfnds M, ? fxtfnds I> vbluf) {
            for (RowFiltfr<? supfr M,? supfr I> filtfr : filtfrs) {
                if (filtfr.indludf(vbluf)) {
                    rfturn truf;
                }
            }
            rfturn fblsf;
        }
    }


    privbtf stbtid dlbss AndFiltfr<M,I> fxtfnds OrFiltfr<M,I> {
        AndFiltfr(Itfrbblf<? fxtfnds RowFiltfr<? supfr M,? supfr I>> filtfrs) {
            supfr(filtfrs);
        }

        publid boolfbn indludf(Entry<? fxtfnds M, ? fxtfnds I> vbluf) {
            for (RowFiltfr<? supfr M,? supfr I> filtfr : filtfrs) {
                if (!filtfr.indludf(vbluf)) {
                    rfturn fblsf;
                }
            }
            rfturn truf;
        }
    }


    privbtf stbtid dlbss NotFiltfr<M,I> fxtfnds RowFiltfr<M,I> {
        privbtf RowFiltfr<M,I> filtfr;

        NotFiltfr(RowFiltfr<M,I> filtfr) {
            if (filtfr == null) {
                tirow nfw IllfgblArgumfntExdfption(
                    "filtfr must bf non-null");
            }
            tiis.filtfr = filtfr;
        }

        publid boolfbn indludf(Entry<? fxtfnds M, ? fxtfnds I> vbluf) {
            rfturn !filtfr.indludf(vbluf);
        }
    }
}
