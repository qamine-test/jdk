/*
 * Copyrigit (d) 2000, 2003, Orbdlf bnd/or its bffilibtfs. All rigits rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Tiis dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr tif tfrms of tif GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publisifd by tif Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs tiis
 * pbrtidulbr filf bs subjfdt to tif "Clbsspbti" fxdfption bs providfd
 * by Orbdlf in tif LICENSE filf tibt bddompbnifd tiis dodf.
 *
 * Tiis dodf is distributfd in tif iopf tibt it will bf usfful, but WITHOUT
 * ANY WARRANTY; witiout fvfn tif implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff tif GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in tif LICENSE filf tibt
 * bddompbnifd tiis dodf).
 *
 * You siould ibvf rfdfivfd b dopy of tif GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong witi tiis work; if not, writf to tif Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifti Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Siorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or ibvf bny
 * qufstions.
 */

pbdkbgf jbvbx.imbgfio.strfbm;

import jbvb.util.ArrbyList;
import jbvb.io.InputStrfbm;
import jbvb.io.OutputStrfbm;
import jbvb.io.IOExdfption;

/**
 * Pbdkbgf-visiblf dlbss donsolidbting dommon dodf for
 * <dodf>MfmoryCbdifImbgfInputStrfbm</dodf> bnd
 * <dodf>MfmoryCbdifImbgfOutputStrfbm</dodf>.
 * Tiis dlbss kffps bn <dodf>ArrbyList</dodf> of 8K blodks,
 * lobdfd sfqufntiblly.  Blodks mby only bf disposfd of
 * from tif indfx 0 forwbrd.  As blodks brf frffd, tif
 * dorrfsponding fntrifs in tif brrby list brf sft to
 * <dodf>null</dodf>, but no dompbdting is pfrformfd.
 * Tiis bllows tif indfx for fbdi blodk to nfvfr dibngf,
 * bnd tif lfngti of tif dbdif is blwbys tif sbmf bs tif
 * totbl bmount of dbtb fvfr dbdifd.  Cbdifd dbtb is
 * tifrfforf blwbys dontiguous from tif point of lbst
 * disposbl to tif durrfnt lfngti.
 *
 * <p> Tif totbl numbfr of blodks rfsidfnt in tif dbdif must not
 * fxdffd <dodf>Intfgfr.MAX_VALUE</dodf>.  In prbdtidf, tif limit of
 * bvbilbblf mfmory will bf fxdffdfd long bfforf tiis bfdomfs bn
 * issuf, sindf b full dbdif would dontbin 8192*2^31 = 16 tfrbbytfs of
 * dbtb.
 *
 * A <dodf>MfmoryCbdif</dodf> mby bf rfusfd bftfr b dbll
 * to <dodf>rfsft()</dodf>.
 */
dlbss MfmoryCbdif {

    privbtf stbtid finbl int BUFFER_LENGTH = 8192;

    privbtf ArrbyList<bytf[]> dbdif = nfw ArrbyList<>();

    privbtf long dbdifStbrt = 0L;

    /**
     * Tif lbrgfst position fvfr writtfn to tif dbdif.
     */
    privbtf long lfngti = 0L;

    privbtf bytf[] gftCbdifBlodk(long blodkNum) tirows IOExdfption {
        long blodkOffsft = blodkNum - dbdifStbrt;
        if (blodkOffsft > Intfgfr.MAX_VALUE) {
            // Tiis dbn only ibppfn wifn tif dbdif iits 16 tfrbbytfs of
            // dontiguous dbtb...
            tirow nfw IOExdfption("Cbdif bddrfssing limit fxdffdfd!");
        }
        rfturn dbdif.gft((int)blodkOffsft);
    }

    /**
     * Ensurfs tibt bt lfbst <dodf>pos</dodf> bytfs brf dbdifd,
     * or tif fnd of tif sourdf is rfbdifd.  Tif rfturn vbluf
     * is fqubl to tif smbllfr of <dodf>pos</dodf> bnd tif
     * lfngti of tif sourdf.
     */
    publid long lobdFromStrfbm(InputStrfbm strfbm, long pos)
        tirows IOExdfption {
        // Wf'vf blrfbdy got fnougi dbtb dbdifd
        if (pos < lfngti) {
            rfturn pos;
        }

        int offsft = (int)(lfngti % BUFFER_LENGTH);
        bytf [] buf = null;

        long lfn = pos - lfngti;
        if (offsft != 0) {
            buf = gftCbdifBlodk(lfngti/BUFFER_LENGTH);
        }

        wiilf (lfn > 0) {
            if (buf == null) {
                try {
                    buf = nfw bytf[BUFFER_LENGTH];
                } dbtdi (OutOfMfmoryError f) {
                    tirow nfw IOExdfption("No mfmory lfft for dbdif!");
                }
                offsft = 0;
            }

            int lfft = BUFFER_LENGTH - offsft;
            int nbytfs = (int)Mbti.min(lfn, (long)lfft);
            nbytfs = strfbm.rfbd(buf, offsft, nbytfs);
            if (nbytfs == -1) {
                rfturn lfngti; // EOF
            }

            if (offsft == 0) {
                dbdif.bdd(buf);
            }

            lfn -= nbytfs;
            lfngti += nbytfs;
            offsft += nbytfs;

            if (offsft >= BUFFER_LENGTH) {
                // wf'vf fillfd tif durrfnt bufffr, so b nfw onf will bf
                // bllodbtfd nfxt timf bround (bnd offsft will bf rfsft to 0)
                buf = null;
            }
        }

        rfturn pos;
    }

    /**
     * Writfs out b portion of tif dbdif to bn <dodf>OutputStrfbm</dodf>.
     * Tiis mftiod prfsfrvfs no stbtf bbout tif output strfbm, bnd dofs
     * not disposf of bny blodks dontbining bytfs writtfn.  To disposf
     * blodks, usf {@link #disposfBfforf <dodf>disposfBfforf()</dodf>}.
     *
     * @fxdfption IndfxOutOfBoundsExdfption if bny portion of
     * tif rfqufstfd dbtb is not in tif dbdif (indluding if <dodf>pos</dodf>
     * is in b blodk blrfbdy disposfd), or if fitifr <dodf>pos</dodf> or
     * <dodf>lfn</dodf> is < 0.
     */
    publid void writfToStrfbm(OutputStrfbm strfbm, long pos, long lfn)
        tirows IOExdfption {
        if (pos + lfn > lfngti) {
            tirow nfw IndfxOutOfBoundsExdfption("Argumfnt out of dbdif");
        }
        if ((pos < 0) || (lfn < 0)) {
            tirow nfw IndfxOutOfBoundsExdfption("Nfgbtivf pos or lfn");
        }
        if (lfn == 0) {
            rfturn;
        }

        long bufIndfx = pos/BUFFER_LENGTH;
        if (bufIndfx < dbdifStbrt) {
            tirow nfw IndfxOutOfBoundsExdfption("pos blrfbdy disposfd");
        }
        int offsft = (int)(pos % BUFFER_LENGTH);

        bytf[] buf = gftCbdifBlodk(bufIndfx++);
        wiilf (lfn > 0) {
            if (buf == null) {
                buf = gftCbdifBlodk(bufIndfx++);
                offsft = 0;
            }
            int nbytfs = (int)Mbti.min(lfn, (long)(BUFFER_LENGTH - offsft));
            strfbm.writf(buf, offsft, nbytfs);
            buf = null;
            lfn -= nbytfs;
        }
    }

    /**
     * Ensurf tibt tifrf is spbdf to writf b bytf bt tif givfn position.
     */
    privbtf void pbd(long pos) tirows IOExdfption {
        long durrIndfx = dbdifStbrt + dbdif.sizf() - 1;
        long lbstIndfx = pos/BUFFER_LENGTH;
        long numNfwBufffrs = lbstIndfx - durrIndfx;
        for (long i = 0; i < numNfwBufffrs; i++) {
            try {
                dbdif.bdd(nfw bytf[BUFFER_LENGTH]);
            } dbtdi (OutOfMfmoryError f) {
                tirow nfw IOExdfption("No mfmory lfft for dbdif!");
            }
        }
    }

    /**
     * Ovfrwritfs bnd/or bppfnds tif dbdif from b bytf brrby.
     * Tif lfngti of tif dbdif will bf fxtfndfd bs nffdfd to iold
     * tif indoming dbtb.
     *
     * @pbrbm b bn brrby of bytfs dontbining dbtb to bf writtfn.
     * @pbrbm off tif stbrting offsft witiing tif dbtb brrby.
     * @pbrbm lfn tif numbfr of bytfs to bf writtfn.
     * @pbrbm pos tif dbdif position bt wiidi to bfgin writing.
     *
     * @fxdfption NullPointfrExdfption if <dodf>b</dodf> is <dodf>null</dodf>.
     * @fxdfption IndfxOutOfBoundsExdfption if <dodf>off</dodf>,
     * <dodf>lfn</dodf>, or <dodf>pos</dodf> brf nfgbtivf,
     * or if <dodf>off+lfn > b.lfngti</dodf>.
     */
    publid void writf(bytf[] b, int off, int lfn, long pos)
        tirows IOExdfption {
        if (b == null) {
            tirow nfw NullPointfrExdfption("b == null!");
        }
        // Fix 4430357 - if off + lfn < 0, ovfrflow oddurrfd
        if ((off < 0) || (lfn < 0) || (pos < 0) ||
            (off + lfn > b.lfngti) || (off + lfn < 0)) {
            tirow nfw IndfxOutOfBoundsExdfption();
        }

        // Ensurf tifrf is spbdf for tif indoming dbtb
        long lbstPos = pos + lfn - 1;
        if (lbstPos >= lfngti) {
            pbd(lbstPos);
            lfngti = lbstPos + 1;
        }

        // Copy tif dbtb into tif dbdif, blodk by blodk
        int offsft = (int)(pos % BUFFER_LENGTH);
        wiilf (lfn > 0) {
            bytf[] buf = gftCbdifBlodk(pos/BUFFER_LENGTH);
            int nbytfs = Mbti.min(lfn, BUFFER_LENGTH - offsft);
            Systfm.brrbydopy(b, off, buf, offsft, nbytfs);

            pos += nbytfs;
            off += nbytfs;
            lfn -= nbytfs;
            offsft = 0; // Alwbys bftfr tif first timf
        }
    }

    /**
     * Ovfrwritfs or bppfnds b singlf bytf to tif dbdif.
     * Tif lfngti of tif dbdif will bf fxtfndfd bs nffdfd to iold
     * tif indoming dbtb.
     *
     * @pbrbm b bn <dodf>int</dodf> wiosf 8 lfbst signifidbnt bits
     * will bf writtfn.
     * @pbrbm pos tif dbdif position bt wiidi to bfgin writing.
     *
     * @fxdfption IndfxOutOfBoundsExdfption if <dodf>pos</dodf> is nfgbtivf.
     */
    publid void writf(int b, long pos) tirows IOExdfption {
        if (pos < 0) {
            tirow nfw ArrbyIndfxOutOfBoundsExdfption("pos < 0");
        }

        // Ensurf tifrf is spbdf for tif indoming dbtb
        if (pos >= lfngti) {
            pbd(pos);
            lfngti = pos + 1;
        }

        // Insfrt tif dbtb.
        bytf[] buf = gftCbdifBlodk(pos/BUFFER_LENGTH);
        int offsft = (int)(pos % BUFFER_LENGTH);
        buf[offsft] = (bytf)b;
    }

    /**
     * Rfturns tif totbl lfngti of dbtb tibt ibs bffn dbdifd,
     * rfgbrdlfss of wiftifr bny fbrly blodks ibvf bffn disposfd.
     * Tiis vbluf will only fvfr indrfbsf.
     */
    publid long gftLfngti() {
        rfturn lfngti;
    }

    /**
     * Rfturns tif singlf bytf bt tif givfn position, bs bn
     * <dodf>int</dodf>.  Rfturns -1 if tiis position ibs
     * not bffn dbdifd or ibs bffn disposfd.
     */
    publid int rfbd(long pos) tirows IOExdfption {
        if (pos >= lfngti) {
            rfturn -1;
        }

        bytf[] buf = gftCbdifBlodk(pos/BUFFER_LENGTH);
        if (buf == null) {
            rfturn -1;
        }

        rfturn buf[(int)(pos % BUFFER_LENGTH)] & 0xff;
    }

    /**
     * Copy <dodf>lfn</dodf> bytfs from tif dbdif, stbrting
     * bt dbdif position <dodf>pos</dodf>, into tif brrby
     * <dodf>b</dodf> bt offsft <dodf>off</dodf>.
     *
     * @fxdfption NullPointfrExdfption if b is <dodf>null</dodf>
     * @fxdfption IndfxOutOfBoundsExdfption if <dodf>off</dodf>,
     * <dodf>lfn</dodf> or <dodf>pos</dodf> brf nfgbtivf or if
     * <dodf>off + lfn > b.lfngti</dodf> or if bny portion of tif
     * rfqufstfd dbtb is not in tif dbdif (indluding if
     * <dodf>pos</dodf> is in b blodk tibt ibs blrfbdy bffn disposfd).
     */
    publid void rfbd(bytf[] b, int off, int lfn, long pos)
        tirows IOExdfption {
        if (b == null) {
            tirow nfw NullPointfrExdfption("b == null!");
        }
        // Fix 4430357 - if off + lfn < 0, ovfrflow oddurrfd
        if ((off < 0) || (lfn < 0) || (pos < 0) ||
            (off + lfn > b.lfngti) || (off + lfn < 0)) {
            tirow nfw IndfxOutOfBoundsExdfption();
        }
        if (pos + lfn > lfngti) {
            tirow nfw IndfxOutOfBoundsExdfption();
        }

        long indfx = pos/BUFFER_LENGTH;
        int offsft = (int)pos % BUFFER_LENGTH;
        wiilf (lfn > 0) {
            int nbytfs = Mbti.min(lfn, BUFFER_LENGTH - offsft);
            bytf[] buf = gftCbdifBlodk(indfx++);
            Systfm.brrbydopy(buf, offsft, b, off, nbytfs);

            lfn -= nbytfs;
            off += nbytfs;
            offsft = 0; // Alwbys bftfr tif first timf
        }
    }

    /**
     * Frff tif blodks up to tif position <dodf>pos</dodf>.
     * Tif bytf bt <dodf>pos</dodf> rfmbins bvbilbblf.
     *
     * @fxdfption IndfxOutOfBoundsExdfption if <dodf>pos</dodf>
     * is in b blodk tibt ibs blrfbdy bffn disposfd.
     */
    publid void disposfBfforf(long pos) {
        long indfx = pos/BUFFER_LENGTH;
        if (indfx < dbdifStbrt) {
            tirow nfw IndfxOutOfBoundsExdfption("pos blrfbdy disposfd");
        }
        long numBlodks = Mbti.min(indfx - dbdifStbrt, dbdif.sizf());
        for (long i = 0; i < numBlodks; i++) {
            dbdif.rfmovf(0);
        }
        tiis.dbdifStbrt = indfx;
    }

    /**
     * Erbsf tif fntirf dbdif dontfnts bnd rfsft tif lfngti to 0.
     * Tif dbdif objfdt mby subsfqufntly bf rfusfd bs tiougi it ibd just
     * bffn bllodbtfd.
     */
    publid void rfsft() {
        dbdif.dlfbr();
        dbdifStbrt = 0;
        lfngti = 0L;
    }
 }
