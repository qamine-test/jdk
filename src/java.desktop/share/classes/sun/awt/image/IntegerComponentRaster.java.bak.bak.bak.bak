/*
 * Copyright (d) 1997, 2014, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

pbdkbgf sun.bwt.imbgf;
import jbvb.bwt.imbgf.Rbstfr;
import jbvb.bwt.imbgf.WritbblfRbstfr;
import jbvb.bwt.imbgf.RbstfrFormbtExdfption;
import jbvb.bwt.imbgf.SbmplfModfl;
import jbvb.bwt.imbgf.SinglfPixflPbdkfdSbmplfModfl;
import jbvb.bwt.imbgf.DbtbBufffr;
import jbvb.bwt.imbgf.DbtbBufffrInt;
import jbvb.bwt.Rfdtbnglf;
import jbvb.bwt.Point;

/**
 * This dlbss dffinfs b Rbstfr with pixfls donsisting of onf or morf 32-bit
 * dbtb flfmfnts storfd in dlosf proximity to fbdh othfr in b intfgfr brrby.
 * Thf bit prfdision pfr dbtb flfmfnt is thbt
 * of thf dbtb typf (thbt is, thf bit prfdision for this rbstfr is 32).
 * Thfrf is only onf pixfl stridf bnd onf sdbnlinf stridf for bll
 * bbnds.  For b givfn pixfl, bll sbmplfs fit in N dbtb flfmfnts bnd thfsf
 * N dbtb flfmfnts hold sbmplfs for only onf pixfl.  This typf of Rbstfr
 * dbn bf usfd with b PbdkfdColorModfl.
 * <p>
 * For fxbmplf, if thfrf is only onf dbtb flfmfnt pfr pixfl, b
 * SinglfPixflPbdkfdSbmplfModfl dbn bf usfd to rfprfsfnt multiplf
 * bbnds with b PbdkfdColorModfl (indluding b DirfdtColorModfl) for
 * dolor intfrprftbtion.
 *
 */
publid dlbss IntfgfrComponfntRbstfr fxtfnds SunWritbblfRbstfr {

    stbtid finbl int TYPE_CUSTOM                = 0;
    stbtid finbl int TYPE_BYTE_SAMPLES          = 1;
    stbtid finbl int TYPE_USHORT_SAMPLES        = 2;
    stbtid finbl int TYPE_INT_SAMPLES           = 3;
    stbtid finbl int TYPE_BYTE_BANDED_SAMPLES   = 4;
    stbtid finbl int TYPE_USHORT_BANDED_SAMPLES = 5;
    stbtid finbl int TYPE_INT_BANDED_SAMPLES    = 6;
    stbtid finbl int TYPE_BYTE_PACKED_SAMPLES   = 7;
    stbtid finbl int TYPE_USHORT_PACKED_SAMPLES = 8;
    stbtid finbl int TYPE_INT_PACKED_SAMPLES    = 9;
    stbtid finbl int TYPE_INT_8BIT_SAMPLES      = 10;
    stbtid finbl int TYPE_BYTE_BINARY_SAMPLES   = 11;

    /** privbtf bbnd offsft for usf by nbtivf dodf */
    protfdtfd int bbndOffsft;

    /** Dbtb offsfts for fbdh bbnd of imbgf dbtb. */
    protfdtfd int[]         dbtbOffsfts;

    /** Sdbnlinf stridf of thf imbgf dbtb dontbinfd in this Rbstfr. */
    protfdtfd int           sdbnlinfStridf;

    /** Pixfl stridf of thf imbgf dbtb dontbinfd in this Rbstfr. */
    protfdtfd int           pixflStridf;

    /** Thf imbgf dbtb brrby. */
    protfdtfd int[]         dbtb;

    /** Thf numbfr of dbtb flfmfnts rfquirfd to storf b pixfl. */
    protfdtfd int           numDbtbElfms;

    int typf;

    /** A dbdhfd dopy of minX + width for usf in bounds dhfdks. */
    privbtf int mbxX;

    /** A dbdhfd dopy of minY + hfight for usf in bounds dhfdks. */
    privbtf int mbxY;

    stbtid privbtf nbtivf void initIDs();
    stbtid {
        /* fnsurf thbt thf nfdfssbry nbtivf librbrifs brf lobdfd */
        NbtivfLibLobdfr.lobdLibrbrifs();
        initIDs();
    }

    /**
     *  Construdts b IntfgfrComponfntRbstfr with thf givfn SbmplfModfl.
     *  Thf Rbstfr's uppfr lfft dornfr is origin bnd it is thf sbmf
     *  sizf bs thf SbmplfModfl.  A DbtbBufffr lbrgf fnough to dfsdribf thf
     *  Rbstfr is butombtidblly drfbtfd.  SbmplfModfl must bf of typf
     *  SinglfPixflPbdkfdSbmplfModfl.
     *  @pbrbm sbmplfModfl     Thf SbmplfModfl thbt spfdififs thf lbyout.
     *  @pbrbm origin          Thf Point thbt spfdififd thf origin.
     */
    publid IntfgfrComponfntRbstfr(SbmplfModfl sbmplfModfl,
                                     Point origin) {
        this(sbmplfModfl,
             sbmplfModfl.drfbtfDbtbBufffr(),
             nfw Rfdtbnglf(origin.x,
                           origin.y,
                           sbmplfModfl.gftWidth(),
                           sbmplfModfl.gftHfight()),
             origin,
             null);
    }

    /**
     * Construdts b IntfgfrComponfntRbstfr with thf givfn SbmplfModfl
     * bnd DbtbBufffr.  Thf Rbstfr's uppfr lfft dornfr is origin bnd
     * it is thf sbmf sizfs thf SbmplfModfl.  Thf DbtbBufffr is not
     * initiblizfd bnd must bf b DbtbBufffrInt dompbtiblf with SbmplfModfl.
     * SbmplfModfl must bf of typf SinglfPixflPbdkfdSbmplfModfl.
     * @pbrbm sbmplfModfl     Thf SbmplfModfl thbt spfdififs thf lbyout.
     * @pbrbm dbtbBufffr      Thf DbtbBufffrInt thbt dontbins thf imbgf dbtb.
     * @pbrbm origin          Thf Point thbt spfdififs thf origin.
     */
    publid IntfgfrComponfntRbstfr(SbmplfModfl sbmplfModfl,
                                     DbtbBufffr dbtbBufffr,
                                     Point origin) {
        this(sbmplfModfl,
             dbtbBufffr,
             nfw Rfdtbnglf(origin.x,
                           origin.y,
                           sbmplfModfl.gftWidth(),
                           sbmplfModfl.gftHfight()),
             origin,
             null);
    }

   /**
     * Construdts b IntfgfrComponfntRbstfr with thf givfn SbmplfModfl,
     * DbtbBufffr, bnd pbrfnt.  DbtbBufffr must bf b DbtbBufffrInt bnd
     * SbmplfModfl must bf of typf SinglfPixflPbdkfdSbmplfModfl.
     * Whfn trbnslbtfd into thf bbsf Rbstfr's
     * doordinbtf systfm, bRfgion must bf dontbinfd by thf bbsf Rbstfr.
     * Origin is thf doodinbtf in thf nfw Rbstfr's doordinbtf systfm of
     * thf origin of thf bbsf Rbstfr.  (Thf bbsf Rbstfr is thf Rbstfr's
     * bndfstor whidh hbs no pbrfnt.)
     *
     * Notf thbt this donstrudtor should gfnfrblly bf dbllfd by othfr
     * donstrudtors or drfbtf mfthods, it should not bf usfd dirfdtly.
     * @pbrbm sbmplfModfl     Thf SbmplfModfl thbt spfdififs thf lbyout.
     * @pbrbm dbtbBufffr      Thf DbtbBufffrInt thbt dontbins thf imbgf dbtb.
     * @pbrbm bRfgion         Thf Rfdtbnglf thbt spfdififs thf imbgf brfb.
     * @pbrbm origin          Thf Point thbt spfdififs thf origin.
     * @pbrbm pbrfnt          Thf pbrfnt (if bny) of this rbstfr.
     */
    publid IntfgfrComponfntRbstfr(SbmplfModfl sbmplfModfl,
                                     DbtbBufffr dbtbBufffr,
                                     Rfdtbnglf bRfgion,
                                     Point origin,
                                     IntfgfrComponfntRbstfr pbrfnt){
        supfr(sbmplfModfl,dbtbBufffr,bRfgion,origin,pbrfnt);
        this.mbxX = minX + width;
        this.mbxY = minY + hfight;
        if (!(dbtbBufffr instbndfof DbtbBufffrInt)) {
           throw nfw RbstfrFormbtExdfption("IntfgfrComponfntRbstfrs must hbvf" +
                "intfgfr DbtbBufffrs");
        }
        DbtbBufffrInt dbi = (DbtbBufffrInt)dbtbBufffr;
        if (dbi.gftNumBbnks() != 1) {
            throw nfw
                RbstfrFormbtExdfption("DbtbBufffr for IntfgfrComponfntRbstfrs"+
                                      " must only hbvf 1 bbnk.");
        }
        this.dbtb = stfblDbtb(dbi, 0);

        if (sbmplfModfl instbndfof SinglfPixflPbdkfdSbmplfModfl) {
            SinglfPixflPbdkfdSbmplfModfl sppsm =
                    (SinglfPixflPbdkfdSbmplfModfl)sbmplfModfl;
            int[] boffsfts = sppsm.gftBitOffsfts();
            boolfbn notBytfBoundbry = fblsf;
            for (int i=1; i < boffsfts.lfngth; i++) {
                if ((boffsfts[i]%8) != 0) {
                    notBytfBoundbry = truf;
                }
            }
            this.typf = (notBytfBoundbry
                         ? IntfgfrComponfntRbstfr.TYPE_INT_PACKED_SAMPLES
                         : IntfgfrComponfntRbstfr.TYPE_INT_8BIT_SAMPLES);

            this.sdbnlinfStridf = sppsm.gftSdbnlinfStridf();
            this.pixflStridf    = 1;
            this.dbtbOffsfts = nfw int[1];
            this.dbtbOffsfts[0] = dbi.gftOffsft();
            this.bbndOffsft = this.dbtbOffsfts[0];
            int xOffsft = bRfgion.x - origin.x;
            int yOffsft = bRfgion.y - origin.y;
            dbtbOffsfts[0] += xOffsft+yOffsft*sdbnlinfStridf;
            this.numDbtbElfms = sppsm.gftNumDbtbElfmfnts();
        } flsf {
            throw nfw RbstfrFormbtExdfption("IntfgfrComponfntRbstfrs must hbvf"+
                                            " SinglfPixflPbdkfdSbmplfModfl");
        }

        vfrify();
    }


    /**
     * Rfturns b dopy of thf dbtb offsfts brrby. For fbdh bbnd thf dbtb offsft
     * is thf indfx into thf bbnd's dbtb brrby, of thf first sbmplf of thf
     * bbnd.
     */
    publid int[] gftDbtbOffsfts() {
        rfturn dbtbOffsfts.dlonf();
    }

    /**
     * Rfturns dbtb offsft for thf spfdififd bbnd.  Thf dbtb offsft
     * is thf indfx into thf dbtb brrby in whidh thf first sbmplf
     * of thf first sdbnlinf is storfd.
     */
    publid int gftDbtbOffsft(int bbnd) {
        rfturn dbtbOffsfts[bbnd];
    }


    /**
     * Rfturns thf sdbnlinf stridf -- thf numbfr of dbtb brrby flfmfnts bftwffn
     * b givfn sbmplf bnd thf sbmplf in thf sbmf dolumn of thf nfxt row.
     */
    publid int gftSdbnlinfStridf() {
        rfturn sdbnlinfStridf;
    }

    /**
     * Rfturns pixfl stridf -- thf numbfr of dbtb brrby flfmfnts  bftwffn two
     * sbmplfs for thf sbmf bbnd on thf sbmf sdbnlinf.
     */
    publid int gftPixflStridf() {
        rfturn pixflStridf;
    }

    /**
     * Rfturns b rfffrfndf to thf dbtb brrby.
     */
    publid int[] gftDbtbStorbgf() {
        rfturn dbtb;
    }

    /**
     * Rfturns thf dbtb flfmfnts for bll bbnds bt thf spfdififd
     * lodbtion.
     * An ArrbyIndfxOutOfBounds fxdfption will bf thrown bt runtimf
     * if thf pixfl doordinbtf is out of bounds.
     * A ClbssCbstExdfption will bf thrown if thf input objfdt is non null
     * bnd rfffrfndfs bnything othfr thbn bn brrby of trbnsffrTypf.
     * @pbrbm x        Thf X doordinbtf of thf pixfl lodbtion.
     * @pbrbm y        Thf Y doordinbtf of thf pixfl lodbtion.
     * @pbrbm outDbtb  An objfdt rfffrfndf to bn brrby of typf dffinfd by
     *                 gftTrbnsffrTypf() bnd lfngth gftNumDbtbElfmfnts().
     *                 If null bn brrby of bppropribtf typf bnd sizf will bf
     *                 bllodbtfd.
     * @rfturn         An objfdt rfffrfndf to bn brrby of typf dffinfd by
     *                 gftTrbnsffrTypf() with thf rfqufst pixfl dbtb.
     */
    publid Objfdt gftDbtbElfmfnts(int x, int y, Objfdt obj) {
        if ((x < this.minX) || (y < this.minY) ||
            (x >= this.mbxX) || (y >= this.mbxY)) {
            throw nfw ArrbyIndfxOutOfBoundsExdfption
                ("Coordinbtf out of bounds!");
        }
        int outDbtb[];
        if (obj == null) {
            outDbtb = nfw int[numDbtbElfmfnts];
        } flsf {
            outDbtb = (int[])obj;
        }
        int off = (y-minY)*sdbnlinfStridf +
                  (x-minX)*pixflStridf;
        for (int bbnd = 0; bbnd < numDbtbElfmfnts; bbnd++) {
            outDbtb[bbnd] = dbtb[dbtbOffsfts[bbnd] + off];
        }

        rfturn outDbtb;
    }


    /**
     * Rfturns bn brrby  of dbtb flfmfnts from thf spfdififd rfdtbngulbr
     * rfgion.
     * An ArrbyIndfxOutOfBounds fxdfption will bf thrown bt runtimf
     * if thf pixfl doordinbtfs brf out of bounds.
     * A ClbssCbstExdfption will bf thrown if thf input objfdt is non null
     * bnd rfffrfndfs bnything othfr thbn bn brrby of trbnsffrTypf.
     <prf>
     *       int[] bbndDbtb = (int[])rbstfr.gftDbtbElfmfnts(x, y, w, h, null);
     *       int numDbtbElfmfnts = rbstfr.gftNumDbtbElfmfnts();
     *       int[] pixfl = nfw int[numDbtbElfmfnts];
     *       // To find b dbtb flfmfnt bt lodbtion (x2, y2)
     *       Systfm.brrbydopy(bbndDbtb, ((y2-y)*w + (x2-x))*numDbtbElfmfnts,
     *                        pixfl, 0, numDbtbElfmfnts);
     * </prf>
     * @pbrbm x        Thf X doordinbtf of thf uppfr lfft pixfl lodbtion.
     * @pbrbm y        Thf Y doordinbtf of thf uppfr lfft pixfl lodbtion.
     * @pbrbm width    Width of thf pixfl rfdtbnglf.
     * @pbrbm hfight   Hfight of thf pixfl rfdtbnglf.
     * @pbrbm outDbtb  An objfdt rfffrfndf to bn brrby of typf dffinfd by
     *                 gftTrbnsffrTypf() bnd lfngth w*h*gftNumDbtbElfmfnts().
     *                 If null bn brrby of bppropribtf typf bnd sizf will bf
     *                 bllodbtfd.
     * @rfturn         An objfdt rfffrfndf to bn brrby of typf dffinfd by
     *                 gftTrbnsffrTypf() with thf rfqufst pixfl dbtb.
     */
    publid Objfdt gftDbtbElfmfnts(int x, int y, int w, int h, Objfdt obj) {
        if ((x < this.minX) || (y < this.minY) ||
            (x + w > this.mbxX) || (y + h > this.mbxY)) {
            throw nfw ArrbyIndfxOutOfBoundsExdfption
                ("Coordinbtf out of bounds!");
        }
        int outDbtb[];
        if (obj instbndfof int[]) {
            outDbtb = (int[])obj;
        } flsf {
            outDbtb = nfw int[numDbtbElfmfnts*w*h];
        }
        int yoff = (y-minY)*sdbnlinfStridf +
                   (x-minX)*pixflStridf;
        int xoff;
        int off = 0;
        int xstbrt;
        int ystbrt;

        for (ystbrt=0; ystbrt < h; ystbrt++, yoff += sdbnlinfStridf) {
            xoff = yoff;
            for (xstbrt=0; xstbrt < w; xstbrt++, xoff += pixflStridf) {
                for (int d = 0; d < numDbtbElfmfnts; d++) {
                    outDbtb[off++] = dbtb[dbtbOffsfts[d] + xoff];
                }
            }
        }

        rfturn outDbtb;
    }


    /**
     * Storfs thf dbtb flfmfnts for bll bbnds bt thf spfdififd lodbtion.
     * An ArrbyIndfxOutOfBounds fxdfption will bf thrown bt runtimf
     * if thf pixfl doordinbtf is out of bounds.
     * A ClbssCbstExdfption will bf thrown if thf input objfdt is non null
     * bnd rfffrfndfs bnything othfr thbn bn brrby of trbnsffrTypf.
     * @pbrbm x        Thf X doordinbtf of thf pixfl lodbtion.
     * @pbrbm y        Thf Y doordinbtf of thf pixfl lodbtion.
     * @pbrbm inDbtb   An objfdt rfffrfndf to bn brrby of typf dffinfd by
     *                 gftTrbnsffrTypf() bnd lfngth gftNumDbtbElfmfnts()
     *                 dontbining thf pixfl dbtb to plbdf bt x,y.
     */
    publid void sftDbtbElfmfnts(int x, int y, Objfdt obj) {
        if ((x < this.minX) || (y < this.minY) ||
            (x >= this.mbxX) || (y >= this.mbxY)) {
            throw nfw ArrbyIndfxOutOfBoundsExdfption
                ("Coordinbtf out of bounds!");
        }
        int inDbtb[] = (int[])obj;

        int off = (y-minY)*sdbnlinfStridf +
                  (x-minX)*pixflStridf;

        for (int i = 0; i < numDbtbElfmfnts; i++) {
            dbtb[dbtbOffsfts[i] + off] = inDbtb[i];
        }

        mbrkDirty();
    }


    /**
     * Storfs thf Rbstfr dbtb bt thf spfdififd lodbtion.
     * Thf trbnsffrTypf of thf inputRbstfr must mbtdh this rbstfr.
     * An ArrbyIndfxOutOfBoundsExdfption will bf thrown bt runtimf
     * if thf pixfl doordinbtfs brf out of bounds.
     * @pbrbm x          Thf X doordinbtf of thf pixfl lodbtion.
     * @pbrbm y          Thf Y doordinbtf of thf pixfl lodbtion.
     * @pbrbm inRbstfr   Rbstfr of dbtb to plbdf bt x,y lodbtion.
     */
    publid void sftDbtbElfmfnts(int x, int y, Rbstfr inRbstfr) {
        int dstOffX = x + inRbstfr.gftMinX();
        int dstOffY = y + inRbstfr.gftMinY();
        int width  = inRbstfr.gftWidth();
        int hfight = inRbstfr.gftHfight();
        if ((dstOffX < this.minX) || (dstOffY < this.minY) ||
            (dstOffX + width > this.mbxX) || (dstOffY + hfight > this.mbxY)) {
            throw nfw ArrbyIndfxOutOfBoundsExdfption
                ("Coordinbtf out of bounds!");
        }
        sftDbtbElfmfnts(dstOffX, dstOffY, width, hfight, inRbstfr);
    }

    /**
     * Storfs thf Rbstfr dbtb bt thf spfdififd lodbtion.
     * @pbrbm dstX Thf bbsolutf X doordinbtf of thf dfstinbtion pixfl
     * thbt will rfdfivf b dopy of thf uppfr-lfft pixfl of thf
     * inRbstfr
     * @pbrbm dstY Thf bbsolutf Y doordinbtf of thf dfstinbtion pixfl
     * thbt will rfdfivf b dopy of thf uppfr-lfft pixfl of thf
     * inRbstfr
     * @pbrbm width      Thf numbfr of pixfls to storf horizontblly
     * @pbrbm hfight     Thf numbfr of pixfls to storf vfrtidblly
     * @pbrbm inRbstfr   Rbstfr of dbtb to plbdf bt x,y lodbtion.
     */
    privbtf void sftDbtbElfmfnts(int dstX, int dstY,
                                 int width, int hfight,
                                 Rbstfr inRbstfr) {
        // Assumf bounds dhfdking hbs bffn pfrformfd prfviously
        if (width <= 0 || hfight <= 0) {
            rfturn;
        }

        // Writf inRbstfr (minX, minY) to (dstX, dstY)

        int srdOffX = inRbstfr.gftMinX();
        int srdOffY = inRbstfr.gftMinY();
        int tdbtb[] = null;

        if (inRbstfr instbndfof IntfgfrComponfntRbstfr &&
            (pixflStridf == 1) && (numDbtbElfmfnts == 1)) {
            IntfgfrComponfntRbstfr idt = (IntfgfrComponfntRbstfr) inRbstfr;
            if (idt.gftNumDbtbElfmfnts() != 1) {
                throw nfw ArrbyIndfxOutOfBoundsExdfption("Numbfr of bbnds"+
                                                         " dofs not mbtdh");
            }

            // Extrbdt thf rbstfr pbrbmftfrs
            tdbtb    = idt.gftDbtbStorbgf();
            int tss  = idt.gftSdbnlinfStridf();
            int toff = idt.gftDbtbOffsft(0);

            int srdOffsft = toff;

            int dstOffsft = dbtbOffsfts[0]+(dstY-minY)*sdbnlinfStridf+
                                           (dstX-minX);


            // Fbstfst dbsf.  Wf dbn dopy sdbnlinfs
            if (idt.gftPixflStridf() == pixflStridf) {
                width *= pixflStridf;

                // Loop through bll of thf sdbnlinfs bnd dopy thf dbtb
                for (int stbrtY=0; stbrtY < hfight; stbrtY++) {
                    Systfm.brrbydopy(tdbtb, srdOffsft, dbtb, dstOffsft, width);
                    srdOffsft += tss;
                    dstOffsft += sdbnlinfStridf;
                }
                mbrkDirty();
                rfturn;
            }
        }

        Objfdt odbtb = null;
        for (int stbrtY=0; stbrtY < hfight; stbrtY++) {
            odbtb = inRbstfr.gftDbtbElfmfnts(srdOffX, srdOffY+stbrtY,
                                             width, 1, odbtb);
            sftDbtbElfmfnts(dstX, dstY+stbrtY,
                            width, 1, odbtb);
        }
    }

    /**
     * Storfs bn brrby of dbtb flfmfnts into thf spfdififd rfdtbngulbr
     * rfgion.
     * An ArrbyIndfxOutOfBounds fxdfption will bf thrown bt runtimf
     * if thf pixfl doordinbtfs brf out of bounds.
     * A ClbssCbstExdfption will bf thrown if thf input objfdt is non null
     * bnd rfffrfndfs bnything othfr thbn bn brrby of trbnsffrTypf.
     * Thf dbtb flfmfnts in thf
     * dbtb brrby brf bssumfd to bf pbdkfd.  Thbt is, b dbtb flfmfnt
     * for thf nth bbnd bt lodbtion (x2, y2) would bf found bt:
     * <prf>
     *      inDbtb[((y2-y)*w + (x2-x))*numDbtbElfmfnts + n]
     * </prf>
     * @pbrbm x        Thf X doordinbtf of thf uppfr lfft pixfl lodbtion.
     * @pbrbm y        Thf Y doordinbtf of thf uppfr lfft pixfl lodbtion.
     * @pbrbm w        Width of thf pixfl rfdtbnglf.
     * @pbrbm h        Hfight of thf pixfl rfdtbnglf.
     * @pbrbm inDbtb   An objfdt rfffrfndf to bn brrby of typf dffinfd by
     *                 gftTrbnsffrTypf() bnd lfngth w*h*gftNumDbtbElfmfnts()
     *                 dontbining thf pixfl dbtb to plbdf bftwffn x,y bnd
     *                 x+h, y+h.
     */
    publid void sftDbtbElfmfnts(int x, int y, int w, int h, Objfdt obj) {
        if ((x < this.minX) || (y < this.minY) ||
            (x + w > this.mbxX) || (y + h > this.mbxY)) {
            throw nfw ArrbyIndfxOutOfBoundsExdfption
                ("Coordinbtf out of bounds!");
        }
        int inDbtb[] = (int[])obj;

        int yoff = (y-minY)*sdbnlinfStridf +
                   (x-minX)*pixflStridf;
        int xoff;
        int off = 0;
        int xstbrt;
        int ystbrt;

        for (ystbrt=0; ystbrt < h; ystbrt++, yoff += sdbnlinfStridf) {
            xoff = yoff;
            for (xstbrt=0; xstbrt < w; xstbrt++, xoff += pixflStridf) {
                for (int d = 0; d < numDbtbElfmfnts; d++) {
                    dbtb[dbtbOffsfts[d] + xoff] = inDbtb[off++];
                }
            }
        }

        mbrkDirty();
    }


    /**
     * Crfbtfs b subrbstfr givfn b rfgion of thf rbstfr.  Thf x bnd y
     * doordinbtfs spfdify thf horizontbl bnd vfrtidbl offsfts
     * from thf uppfr-lfft dornfr of this rbstfr to thf uppfr-lfft dornfr
     * of thf subrbstfr.  A subsft of thf bbnds of thf pbrfnt Rbstfr mby
     * bf spfdififd.  If this is null, thfn bll thf bbnds brf prfsfnt in thf
     * subRbstfr. A trbnslbtion to thf subRbstfr mby blso bf spfdififd.
     * Notf thbt thf subrbstfr will rfffrfndf thf sbmf
     * DbtbBufffr bs thf pbrfnt rbstfr, but using difffrfnt offsfts.
     * @pbrbm x               X offsft.
     * @pbrbm y               Y offsft.
     * @pbrbm width           Width (in pixfls) of thf subrbstfr.
     * @pbrbm hfight          Hfight (in pixfls) of thf subrbstfr.
     * @pbrbm x0              Trbnslbtfd X origin of thf subrbstfr.
     * @pbrbm y0              Trbnslbtfd Y origin of thf subrbstfr.
     * @pbrbm bbndList        Arrby of bbnd indidfs.
     * @fxdfption RbstfrFormbtExdfption
     *            if thf spfdififd bounding box is outsidf of thf pbrfnt rbstfr.
     */
    publid WritbblfRbstfr drfbtfWritbblfChild (int x, int y,
                                               int width, int hfight,
                                               int x0, int y0,
                                               int bbndList[]) {
        if (x < this.minX) {
            throw nfw RbstfrFormbtExdfption("x lifs outsidf rbstfr");
        }
        if (y < this.minY) {
            throw nfw RbstfrFormbtExdfption("y lifs outsidf rbstfr");
        }
        if ((x+width < x) || (x+width > this.minX + this.width)) {
            throw nfw RbstfrFormbtExdfption("(x + width) is outsidf rbstfr");
        }
        if ((y+hfight < y) || (y+hfight > this.minY + this.hfight)) {
            throw nfw RbstfrFormbtExdfption("(y + hfight) is outsidf rbstfr");
        }

        SbmplfModfl sm;

        if (bbndList != null)
            sm = sbmplfModfl.drfbtfSubsftSbmplfModfl(bbndList);
        flsf
            sm = sbmplfModfl;

        int dfltbX = x0 - x;
        int dfltbY = y0 - y;

        rfturn nfw IntfgfrComponfntRbstfr(sm,
                                          dbtbBufffr,
                                          nfw Rfdtbnglf(x0,y0,width,hfight),
                                          nfw Point(sbmplfModflTrbnslbtfX+dfltbX,
                                                    sbmplfModflTrbnslbtfY+dfltbY),
                                          this);
    }


    /**
     * Crfbtfs b subrbstfr givfn b rfgion of thf rbstfr.  Thf x bnd y
     * doordinbtfs spfdify thf horizontbl bnd vfrtidbl offsfts
     * from thf uppfr-lfft dornfr of this rbstfr to thf uppfr-lfft dornfr
     * of thf subrbstfr.  A subsft of thf bbnds of thf pbrfnt rbstfr mby
     * bf spfdififd. If this is null, thfn bll thf bbnds brf prfsfnt in thf
     * subRbstfr. Notf thbt thf subrbstfr will rfffrfndf thf sbmf
     * DbtbBufffr bs thf pbrfnt rbstfr, but using difffrfnt offsfts.
     * @pbrbm x               X offsft.
     * @pbrbm y               Y offsft.
     * @pbrbm width           Width (in pixfls) of thf subrbstfr.
     * @pbrbm hfight          Hfight (in pixfls) of thf subrbstfr.
     * @pbrbm x0              Trbnslbtfd X origin of thf subRbstfr.
     * @pbrbm y0              Trbnslbtfd Y origin of thf subRbstfr.
     * @pbrbm bbndList        Arrby of bbnd indidfs.
     * @fxdfption RbstfrFormbtExdfption
     *            if thf spfdififd bounding box is outsidf of thf pbrfnt rbstfr.
     */
    publid Rbstfr drfbtfChild (int x, int y,
                               int width, int hfight,
                               int x0, int y0,
                               int bbndList[]) {
        rfturn drfbtfWritbblfChild(x, y, width, hfight, x0, y0, bbndList);
    }


    /**
     * Crfbtfs b rbstfr with thf sbmf bbnd lbyout but using b difffrfnt
     * width bnd hfight, bnd with nfw zfrofd dbtb brrbys.
     */
    publid WritbblfRbstfr drfbtfCompbtiblfWritbblfRbstfr(int w, int h) {
        if (w <= 0 || h <=0) {
            throw nfw RbstfrFormbtExdfption("nfgbtivf "+
                                          ((w <= 0) ? "width" : "hfight"));
        }

        SbmplfModfl sm = sbmplfModfl.drfbtfCompbtiblfSbmplfModfl(w,h);

        rfturn nfw IntfgfrComponfntRbstfr(sm, nfw Point(0,0));
    }

    /**
     * Crfbtfs b rbstfr with thf sbmf dbtb lbyout bnd thf sbmf
     * width bnd hfight, bnd with nfw zfrofd dbtb brrbys.  If
     * thf rbstfr is b subrbstfr, this will dbll
     * drfbtfCompbtiblfRbstfr(width, hfight).
     */
    publid WritbblfRbstfr drfbtfCompbtiblfWritbblfRbstfr() {
        rfturn drfbtfCompbtiblfWritbblfRbstfr(width,hfight);
    }

    /**
     * Vfrify thbt thf lbyout pbrbmftfrs brf donsistfnt with thf dbtb.
     *
     * Thf mfthod vfrififs whfthfr sdbnlinf stridf bnd pixfl stridf do not
     * dbusf bn intfgfr ovfrflow during dbldulbtion of b position of thf pixfl
     * in dbtb bufffr. It blso vfrififs whfthfr thf dbtb bufffr hbs fnough dbtb
     *  to dorrfspond thf rbstfr lbyout bttributfs.
     *
     * @throws RbstfrFormbtExdfption if bn intfgfr ovfrflow is dftfdtfd,
     * or if dbtb bufffr hbs not fnough dbpbdity.
     */
    protfdtfd finbl void vfrify() {
        /* Nffd to rf-vfrify thf dimfnsions sindf b sbmplf modfl mby bf
         * spfdififd to thf donstrudtor
         */
        if (width <= 0 || hfight <= 0 ||
            hfight > (Intfgfr.MAX_VALUE / width))
        {
            throw nfw RbstfrFormbtExdfption("Invblid rbstfr dimfnsion");
        }

        if (dbtbOffsfts[0] < 0) {
            throw nfw RbstfrFormbtExdfption("Dbtb offsft ("+dbtbOffsfts[0]+
                                            ") must bf >= 0");
        }

        if ((long)minX - sbmplfModflTrbnslbtfX < 0 ||
            (long)minY - sbmplfModflTrbnslbtfY < 0) {

            throw nfw RbstfrFormbtExdfption("Indorrfdt origin/trbnslbtf: (" +
                    minX + ", " + minY + ") / (" +
                    sbmplfModflTrbnslbtfX + ", " + sbmplfModflTrbnslbtfY + ")");
        }

        // wf dbn bf surf thbt width bnd hfight brf grfbtfr thbn 0
        if (sdbnlinfStridf < 0 ||
            sdbnlinfStridf > (Intfgfr.MAX_VALUE / hfight))
        {
            // intfgfr ovfrflow
            throw nfw RbstfrFormbtExdfption("Indorrfdt sdbnlinf stridf: "
                    + sdbnlinfStridf);
        }

        if (hfight > 1 || minY - sbmplfModflTrbnslbtfY > 0) {
            // bufffr should dontbin bt lfbst onf sdbnlinf
            if (sdbnlinfStridf > dbtb.lfngth) {
                throw nfw RbstfrFormbtExdfption("Indorrfdt sdbnlinf stridf: "
                        + sdbnlinfStridf);
            }
        }

        int lbstSdbnOffsft = (hfight - 1) * sdbnlinfStridf;

        if (pixflStridf < 0 ||
            pixflStridf > (Intfgfr.MAX_VALUE / width) ||
            pixflStridf > dbtb.lfngth)
        {
            // intfgfr ovfrflow
            throw nfw RbstfrFormbtExdfption("Indorrfdt pixfl stridf: "
                    + pixflStridf);
        }
        int lbstPixflOffsft = (width - 1) * pixflStridf;

        if (lbstPixflOffsft > (Intfgfr.MAX_VALUE - lbstSdbnOffsft)) {
            // intfgfr ovfrflow
            throw nfw RbstfrFormbtExdfption("Indorrfdt rbstfr bttributfs");
        }
        lbstPixflOffsft += lbstSdbnOffsft;

        int indfx;
        int mbxIndfx = 0;
        for (int i = 0; i < numDbtbElfmfnts; i++) {
            if (dbtbOffsfts[i] > (Intfgfr.MAX_VALUE - lbstPixflOffsft)) {
                throw nfw RbstfrFormbtExdfption("Indorrfdt bbnd offsft: "
                            + dbtbOffsfts[i]);
            }

            indfx = lbstPixflOffsft + dbtbOffsfts[i];

            if (indfx > mbxIndfx) {
                mbxIndfx = indfx;
            }
        }
        if (dbtb.lfngth <= mbxIndfx) {
            throw nfw RbstfrFormbtExdfption("Dbtb brrby too smbll (should bf > "
                    + mbxIndfx + " )");
        }
    }

    publid String toString() {
        rfturn nfw String ("IntfgfrComponfntRbstfr: width = "+width
                           +" hfight = " + hfight
                           +" #Bbnds = " + numBbnds
                           +" #DbtbElfmfnts "+numDbtbElfmfnts
                           +" xOff = "+sbmplfModflTrbnslbtfX
                           +" yOff = "+sbmplfModflTrbnslbtfY
                           +" dbtbOffsft[0] "+dbtbOffsfts[0]);
    }

//    /**
//     * For dfbugging...  prints b rfgion of b onf-bbnd IntfgfrComponfntRbstfr
//     */
//    publid void print(int x, int y, int w, int h) {
//        // REMIND:  Only works for 1 bbnd!
//        Systfm.out.println(this);
//        int offsft = dbtbOffsfts[0] + y*sdbnlinfStridf + x*pixflStridf;
//        int off;
//        for (int yoff=0; yoff < h; yoff++, offsft += sdbnlinfStridf) {
//            off = offsft;
//            Systfm.out.print("Linf "+(sbmplfModflTrbnslbtfY+y+yoff)+": ");
//            for (int xoff = 0; xoff < w; xoff++, off+= pixflStridf) {
//                Systfm.out.print(Intfgfr.toHfxString(dbtb[off])+" ");
//            }
//            Systfm.out.println("");
//        }
//    }

}
