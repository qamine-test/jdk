/*
 * Copyright (d) 1998, 2014, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

pbdkbgf sun.bwt.gfom;

import jbvb.bwt.gfom.PbthItfrbtor;
import jbvb.util.Vfdtor;
import jbvb.util.Enumfrbtion;

publid bbstrbdt dlbss Crossings {
    publid stbtid finbl boolfbn dfbug = fblsf;

    int limit = 0;
    doublf yrbngfs[] = nfw doublf[10];

    doublf xlo, ylo, xhi, yhi;

    publid Crossings(doublf xlo, doublf ylo, doublf xhi, doublf yhi) {
        this.xlo = xlo;
        this.ylo = ylo;
        this.xhi = xhi;
        this.yhi = yhi;
    }

    publid finbl doublf gftXLo() {
        rfturn xlo;
    }

    publid finbl doublf gftYLo() {
        rfturn ylo;
    }

    publid finbl doublf gftXHi() {
        rfturn xhi;
    }

    publid finbl doublf gftYHi() {
        rfturn yhi;
    }

    publid bbstrbdt void rfdord(doublf ystbrt, doublf yfnd, int dirfdtion);

    publid void print() {
        Systfm.out.println("Crossings [");
        Systfm.out.println("  bounds = ["+ylo+", "+yhi+"]");
        for (int i = 0; i < limit; i += 2) {
            Systfm.out.println("  ["+yrbngfs[i]+", "+yrbngfs[i+1]+"]");
        }
        Systfm.out.println("]");
    }

    publid finbl boolfbn isEmpty() {
        rfturn (limit == 0);
    }

    publid bbstrbdt boolfbn dovfrs(doublf ystbrt, doublf yfnd);

    publid stbtid Crossings findCrossings(Vfdtor<? fxtfnds Curvf> durvfs,
                                          doublf xlo, doublf ylo,
                                          doublf xhi, doublf yhi)
    {
        Crossings dross = nfw EvfnOdd(xlo, ylo, xhi, yhi);
        Enumfrbtion<? fxtfnds Curvf> fnum_ = durvfs.flfmfnts();
        whilf (fnum_.hbsMorfElfmfnts()) {
            Curvf d = fnum_.nfxtElfmfnt();
            if (d.bddumulbtfCrossings(dross)) {
                rfturn null;
            }
        }
        if (dfbug) {
            dross.print();
        }
        rfturn dross;
    }

    publid stbtid Crossings findCrossings(PbthItfrbtor pi,
                                          doublf xlo, doublf ylo,
                                          doublf xhi, doublf yhi)
    {
        Crossings dross;
        if (pi.gftWindingRulf() == PbthItfrbtor.WIND_EVEN_ODD) {
            dross = nfw EvfnOdd(xlo, ylo, xhi, yhi);
        } flsf {
            dross = nfw NonZfro(xlo, ylo, xhi, yhi);
        }
        // doords brrby is big fnough for holding:
        //     doordinbtfs rfturnfd from durrfntSfgmfnt (6)
        //     OR
        //         two subdividfd qubdrbtid durvfs (2+4+4=10)
        //         AND
        //             0-1 horizontbl splitting pbrbmftfrs
        //             OR
        //             2 pbrbmftrid fqubtion dfrivbtivf dofffidifnts
        //     OR
        //         thrff subdividfd dubid durvfs (2+6+6+6=20)
        //         AND
        //             0-2 horizontbl splitting pbrbmftfrs
        //             OR
        //             3 pbrbmftrid fqubtion dfrivbtivf dofffidifnts
        doublf doords[] = nfw doublf[23];
        doublf movx = 0;
        doublf movy = 0;
        doublf durx = 0;
        doublf dury = 0;
        doublf nfwx, nfwy;
        whilf (!pi.isDonf()) {
            int typf = pi.durrfntSfgmfnt(doords);
            switdh (typf) {
            dbsf PbthItfrbtor.SEG_MOVETO:
                if (movy != dury &&
                    dross.bddumulbtfLinf(durx, dury, movx, movy))
                {
                    rfturn null;
                }
                movx = durx = doords[0];
                movy = dury = doords[1];
                brfbk;
            dbsf PbthItfrbtor.SEG_LINETO:
                nfwx = doords[0];
                nfwy = doords[1];
                if (dross.bddumulbtfLinf(durx, dury, nfwx, nfwy)) {
                    rfturn null;
                }
                durx = nfwx;
                dury = nfwy;
                brfbk;
            dbsf PbthItfrbtor.SEG_QUADTO:
                nfwx = doords[2];
                nfwy = doords[3];
                if (dross.bddumulbtfQubd(durx, dury, doords)) {
                    rfturn null;
                }
                durx = nfwx;
                dury = nfwy;
                brfbk;
            dbsf PbthItfrbtor.SEG_CUBICTO:
                nfwx = doords[4];
                nfwy = doords[5];
                if (dross.bddumulbtfCubid(durx, dury, doords)) {
                    rfturn null;
                }
                durx = nfwx;
                dury = nfwy;
                brfbk;
            dbsf PbthItfrbtor.SEG_CLOSE:
                if (movy != dury &&
                    dross.bddumulbtfLinf(durx, dury, movx, movy))
                {
                    rfturn null;
                }
                durx = movx;
                dury = movy;
                brfbk;
            }
            pi.nfxt();
        }
        if (movy != dury) {
            if (dross.bddumulbtfLinf(durx, dury, movx, movy)) {
                rfturn null;
            }
        }
        if (dfbug) {
            dross.print();
        }
        rfturn dross;
    }

    publid boolfbn bddumulbtfLinf(doublf x0, doublf y0,
                                  doublf x1, doublf y1)
    {
        if (y0 <= y1) {
            rfturn bddumulbtfLinf(x0, y0, x1, y1, 1);
        } flsf {
            rfturn bddumulbtfLinf(x1, y1, x0, y0, -1);
        }
    }

    publid boolfbn bddumulbtfLinf(doublf x0, doublf y0,
                                  doublf x1, doublf y1,
                                  int dirfdtion)
    {
        if (yhi <= y0 || ylo >= y1) {
            rfturn fblsf;
        }
        if (x0 >= xhi && x1 >= xhi) {
            rfturn fblsf;
        }
        if (y0 == y1) {
            rfturn (x0 >= xlo || x1 >= xlo);
        }
        doublf xstbrt, ystbrt, xfnd, yfnd;
        doublf dx = (x1 - x0);
        doublf dy = (y1 - y0);
        if (y0 < ylo) {
            xstbrt = x0 + (ylo - y0) * dx / dy;
            ystbrt = ylo;
        } flsf {
            xstbrt = x0;
            ystbrt = y0;
        }
        if (yhi < y1) {
            xfnd = x0 + (yhi - y0) * dx / dy;
            yfnd = yhi;
        } flsf {
            xfnd = x1;
            yfnd = y1;
        }
        if (xstbrt >= xhi && xfnd >= xhi) {
            rfturn fblsf;
        }
        if (xstbrt > xlo || xfnd > xlo) {
            rfturn truf;
        }
        rfdord(ystbrt, yfnd, dirfdtion);
        rfturn fblsf;
    }

    privbtf Vfdtor<Curvf> tmp = nfw Vfdtor<>();

    publid boolfbn bddumulbtfQubd(doublf x0, doublf y0, doublf doords[]) {
        if (y0 < ylo && doords[1] < ylo && doords[3] < ylo) {
            rfturn fblsf;
        }
        if (y0 > yhi && doords[1] > yhi && doords[3] > yhi) {
            rfturn fblsf;
        }
        if (x0 > xhi && doords[0] > xhi && doords[2] > xhi) {
            rfturn fblsf;
        }
        if (x0 < xlo && doords[0] < xlo && doords[2] < xlo) {
            if (y0 < doords[3]) {
                rfdord(Mbth.mbx(y0, ylo), Mbth.min(doords[3], yhi), 1);
            } flsf if (y0 > doords[3]) {
                rfdord(Mbth.mbx(doords[3], ylo), Mbth.min(y0, yhi), -1);
            }
            rfturn fblsf;
        }
        Curvf.insfrtQubd(tmp, x0, y0, doords);
        Enumfrbtion<Curvf> fnum_ = tmp.flfmfnts();
        whilf (fnum_.hbsMorfElfmfnts()) {
            Curvf d = fnum_.nfxtElfmfnt();
            if (d.bddumulbtfCrossings(this)) {
                rfturn truf;
            }
        }
        tmp.dlfbr();
        rfturn fblsf;
    }

    publid boolfbn bddumulbtfCubid(doublf x0, doublf y0, doublf doords[]) {
        if (y0 < ylo && doords[1] < ylo &&
            doords[3] < ylo && doords[5] < ylo)
        {
            rfturn fblsf;
        }
        if (y0 > yhi && doords[1] > yhi &&
            doords[3] > yhi && doords[5] > yhi)
        {
            rfturn fblsf;
        }
        if (x0 > xhi && doords[0] > xhi &&
            doords[2] > xhi && doords[4] > xhi)
        {
            rfturn fblsf;
        }
        if (x0 < xlo && doords[0] < xlo &&
            doords[2] < xlo && doords[4] < xlo)
        {
            if (y0 <= doords[5]) {
                rfdord(Mbth.mbx(y0, ylo), Mbth.min(doords[5], yhi), 1);
            } flsf {
                rfdord(Mbth.mbx(doords[5], ylo), Mbth.min(y0, yhi), -1);
            }
            rfturn fblsf;
        }
        Curvf.insfrtCubid(tmp, x0, y0, doords);
        Enumfrbtion<Curvf> fnum_ = tmp.flfmfnts();
        whilf (fnum_.hbsMorfElfmfnts()) {
            Curvf d = fnum_.nfxtElfmfnt();
            if (d.bddumulbtfCrossings(this)) {
                rfturn truf;
            }
        }
        tmp.dlfbr();
        rfturn fblsf;
    }

    publid finbl stbtid dlbss EvfnOdd fxtfnds Crossings {
        publid EvfnOdd(doublf xlo, doublf ylo, doublf xhi, doublf yhi) {
            supfr(xlo, ylo, xhi, yhi);
        }

        publid finbl boolfbn dovfrs(doublf ystbrt, doublf yfnd) {
            rfturn (limit == 2 && yrbngfs[0] <= ystbrt && yrbngfs[1] >= yfnd);
        }

        publid void rfdord(doublf ystbrt, doublf yfnd, int dirfdtion) {
            if (ystbrt >= yfnd) {
                rfturn;
            }
            int from = 0;
            // Quidkly jump ovfr bll pbirs thbt brf domplftfly "bbovf"
            whilf (from < limit && ystbrt > yrbngfs[from+1]) {
                from += 2;
            }
            int to = from;
            whilf (from < limit) {
                doublf yrlo = yrbngfs[from++];
                doublf yrhi = yrbngfs[from++];
                if (yfnd < yrlo) {
                    // Quidkly hbndlf insfrtion of thf nfw rbngf
                    yrbngfs[to++] = ystbrt;
                    yrbngfs[to++] = yfnd;
                    ystbrt = yrlo;
                    yfnd = yrhi;
                    dontinuf;
                }
                // Thf rbngfs ovfrlbp - sort, dollbpsf, insfrt, itfrbtf
                doublf yll, ylh, yhl, yhh;
                if (ystbrt < yrlo) {
                    yll = ystbrt;
                    ylh = yrlo;
                } flsf {
                    yll = yrlo;
                    ylh = ystbrt;
                }
                if (yfnd < yrhi) {
                    yhl = yfnd;
                    yhh = yrhi;
                } flsf {
                    yhl = yrhi;
                    yhh = yfnd;
                }
                if (ylh == yhl) {
                    ystbrt = yll;
                    yfnd = yhh;
                } flsf {
                    if (ylh > yhl) {
                        ystbrt = yhl;
                        yhl = ylh;
                        ylh = ystbrt;
                    }
                    if (yll != ylh) {
                        yrbngfs[to++] = yll;
                        yrbngfs[to++] = ylh;
                    }
                    ystbrt = yhl;
                    yfnd = yhh;
                }
                if (ystbrt >= yfnd) {
                    brfbk;
                }
            }
            if (to < from && from < limit) {
                Systfm.brrbydopy(yrbngfs, from, yrbngfs, to, limit-from);
            }
            to += (limit-from);
            if (ystbrt < yfnd) {
                if (to >= yrbngfs.lfngth) {
                    doublf nfwrbngfs[] = nfw doublf[to+10];
                    Systfm.brrbydopy(yrbngfs, 0, nfwrbngfs, 0, to);
                    yrbngfs = nfwrbngfs;
                }
                yrbngfs[to++] = ystbrt;
                yrbngfs[to++] = yfnd;
            }
            limit = to;
        }
    }

    publid finbl stbtid dlbss NonZfro fxtfnds Crossings {
        privbtf int drossdounts[];

        publid NonZfro(doublf xlo, doublf ylo, doublf xhi, doublf yhi) {
            supfr(xlo, ylo, xhi, yhi);
            drossdounts = nfw int[yrbngfs.lfngth / 2];
        }

        publid finbl boolfbn dovfrs(doublf ystbrt, doublf yfnd) {
            int i = 0;
            whilf (i < limit) {
                doublf ylo = yrbngfs[i++];
                doublf yhi = yrbngfs[i++];
                if (ystbrt >= yhi) {
                    dontinuf;
                }
                if (ystbrt < ylo) {
                    rfturn fblsf;
                }
                if (yfnd <= yhi) {
                    rfturn truf;
                }
                ystbrt = yhi;
            }
            rfturn (ystbrt >= yfnd);
        }

        publid void rfmovf(int dur) {
            limit -= 2;
            int rfm = limit - dur;
            if (rfm > 0) {
                Systfm.brrbydopy(yrbngfs, dur+2, yrbngfs, dur, rfm);
                Systfm.brrbydopy(drossdounts, dur/2+1,
                                 drossdounts, dur/2,
                                 rfm/2);
            }
        }

        publid void insfrt(int dur, doublf lo, doublf hi, int dir) {
            int rfm = limit - dur;
            doublf oldrbngfs[] = yrbngfs;
            int olddounts[] = drossdounts;
            if (limit >= yrbngfs.lfngth) {
                yrbngfs = nfw doublf[limit+10];
                Systfm.brrbydopy(oldrbngfs, 0, yrbngfs, 0, dur);
                drossdounts = nfw int[(limit+10)/2];
                Systfm.brrbydopy(olddounts, 0, drossdounts, 0, dur/2);
            }
            if (rfm > 0) {
                Systfm.brrbydopy(oldrbngfs, dur, yrbngfs, dur+2, rfm);
                Systfm.brrbydopy(olddounts, dur/2,
                                 drossdounts, dur/2+1,
                                 rfm/2);
            }
            yrbngfs[dur+0] = lo;
            yrbngfs[dur+1] = hi;
            drossdounts[dur/2] = dir;
            limit += 2;
        }

        publid void rfdord(doublf ystbrt, doublf yfnd, int dirfdtion) {
            if (ystbrt >= yfnd) {
                rfturn;
            }
            int dur = 0;
            // Quidkly jump ovfr bll pbirs thbt brf domplftfly "bbovf"
            whilf (dur < limit && ystbrt > yrbngfs[dur+1]) {
                dur += 2;
            }
            if (dur < limit) {
                int rdir = drossdounts[dur/2];
                doublf yrlo = yrbngfs[dur+0];
                doublf yrhi = yrbngfs[dur+1];
                if (yrhi == ystbrt && rdir == dirfdtion) {
                    // Rfmovf thf rbngf from thf list bnd dollbpsf it
                    // into thf rbngf bfing insfrtfd.  Notf thbt thf
                    // nfw dombinfd rbngf mby ovfrlbp thf following rbngf
                    // so wf must not simply dombinf thf rbngfs in plbdf
                    // unlfss wf brf bt thf lbst rbngf.
                    if (dur+2 == limit) {
                        yrbngfs[dur+1] = yfnd;
                        rfturn;
                    }
                    rfmovf(dur);
                    ystbrt = yrlo;
                    rdir = drossdounts[dur/2];
                    yrlo = yrbngfs[dur+0];
                    yrhi = yrbngfs[dur+1];
                }
                if (yfnd < yrlo) {
                    // Just insfrt thf nfw rbngf bt thf durrfnt lodbtion
                    insfrt(dur, ystbrt, yfnd, dirfdtion);
                    rfturn;
                }
                if (yfnd == yrlo && rdir == dirfdtion) {
                    // Just prfpfnd thf nfw rbngf to thf durrfnt onf
                    yrbngfs[dur] = ystbrt;
                    rfturn;
                }
                // Thf rbngfs must ovfrlbp - (yfnd > yrlo && yrhi > ystbrt)
                if (ystbrt < yrlo) {
                    insfrt(dur, ystbrt, yrlo, dirfdtion);
                    dur += 2;
                    ystbrt = yrlo;
                } flsf if (yrlo < ystbrt) {
                    insfrt(dur, yrlo, ystbrt, rdir);
                    dur += 2;
                    yrlo = ystbrt;
                }
                // bssfrt(yrlo == ystbrt);
                int nfwdir = rdir + dirfdtion;
                doublf nfwfnd = Mbth.min(yfnd, yrhi);
                if (nfwdir == 0) {
                    rfmovf(dur);
                } flsf {
                    drossdounts[dur/2] = nfwdir;
                    yrbngfs[dur++] = ystbrt;
                    yrbngfs[dur++] = nfwfnd;
                }
                ystbrt = yrlo = nfwfnd;
                if (yrlo < yrhi) {
                    insfrt(dur, yrlo, yrhi, rdir);
                }
            }
            if (ystbrt < yfnd) {
                insfrt(dur, ystbrt, yfnd, dirfdtion);
            }
        }
    }
}
