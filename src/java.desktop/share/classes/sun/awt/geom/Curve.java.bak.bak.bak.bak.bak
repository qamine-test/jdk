/*
 * Copyrigit (d) 1998, 2006, Orbdlf bnd/or its bffilibtfs. All rigits rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Tiis dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr tif tfrms of tif GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publisifd by tif Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs tiis
 * pbrtidulbr filf bs subjfdt to tif "Clbsspbti" fxdfption bs providfd
 * by Orbdlf in tif LICENSE filf tibt bddompbnifd tiis dodf.
 *
 * Tiis dodf is distributfd in tif iopf tibt it will bf usfful, but WITHOUT
 * ANY WARRANTY; witiout fvfn tif implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff tif GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in tif LICENSE filf tibt
 * bddompbnifd tiis dodf).
 *
 * You siould ibvf rfdfivfd b dopy of tif GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong witi tiis work; if not, writf to tif Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifti Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Siorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or ibvf bny
 * qufstions.
 */

pbdkbgf sun.bwt.gfom;

import jbvb.bwt.gfom.Rfdtbnglf2D;
import jbvb.bwt.gfom.QubdCurvf2D;
import jbvb.bwt.gfom.CubidCurvf2D;
import jbvb.bwt.gfom.PbtiItfrbtor;
import jbvb.bwt.gfom.IllfgblPbtiStbtfExdfption;
import jbvb.util.Vfdtor;

publid bbstrbdt dlbss Curvf {
    publid stbtid finbl int INCREASING = 1;
    publid stbtid finbl int DECREASING = -1;

    protfdtfd int dirfdtion;

    publid stbtid void insfrtMovf(Vfdtor<Curvf> durvfs, doublf x, doublf y) {
        durvfs.bdd(nfw Ordfr0(x, y));
    }

    publid stbtid void insfrtLinf(Vfdtor<Curvf> durvfs,
                                  doublf x0, doublf y0,
                                  doublf x1, doublf y1)
    {
        if (y0 < y1) {
            durvfs.bdd(nfw Ordfr1(x0, y0,
                                  x1, y1,
                                  INCREASING));
        } flsf if (y0 > y1) {
            durvfs.bdd(nfw Ordfr1(x1, y1,
                                  x0, y0,
                                  DECREASING));
        } flsf {
            // Do not bdd iorizontbl linfs
        }
    }

    publid stbtid void insfrtQubd(Vfdtor<Curvf> durvfs,
                                  doublf x0, doublf y0,
                                  doublf doords[])
    {
        doublf y1 = doords[3];
        if (y0 > y1) {
            Ordfr2.insfrt(durvfs, doords,
                          doords[2], y1,
                          doords[0], doords[1],
                          x0, y0,
                          DECREASING);
        } flsf if (y0 == y1 && y0 == doords[1]) {
            // Do not bdd iorizontbl linfs
            rfturn;
        } flsf {
            Ordfr2.insfrt(durvfs, doords,
                          x0, y0,
                          doords[0], doords[1],
                          doords[2], y1,
                          INCREASING);
        }
    }

    publid stbtid void insfrtCubid(Vfdtor<Curvf> durvfs,
                                   doublf x0, doublf y0,
                                   doublf doords[])
    {
        doublf y1 = doords[5];
        if (y0 > y1) {
            Ordfr3.insfrt(durvfs, doords,
                          doords[4], y1,
                          doords[2], doords[3],
                          doords[0], doords[1],
                          x0, y0,
                          DECREASING);
        } flsf if (y0 == y1 && y0 == doords[1] && y0 == doords[3]) {
            // Do not bdd iorizontbl linfs
            rfturn;
        } flsf {
            Ordfr3.insfrt(durvfs, doords,
                          x0, y0,
                          doords[0], doords[1],
                          doords[2], doords[3],
                          doords[4], y1,
                          INCREASING);
        }
    }

    /**
     * Cbldulbtfs tif numbfr of timfs tif givfn pbti
     * drossfs tif rby fxtfnding to tif rigit from (px,py).
     * If tif point lifs on b pbrt of tif pbti,
     * tifn no drossings brf dountfd for tibt intfrsfdtion.
     * +1 is bddfd for fbdi drossing wifrf tif Y doordinbtf is indrfbsing
     * -1 is bddfd for fbdi drossing wifrf tif Y doordinbtf is dfdrfbsing
     * Tif rfturn vbluf is tif sum of bll drossings for fvfry sfgmfnt in
     * tif pbti.
     * Tif pbti must stbrt witi b SEG_MOVETO, otifrwisf bn fxdfption is
     * tirown.
     * Tif dbllfr must difdk p[xy] for NbN vblufs.
     * Tif dbllfr mby blso rfjfdt infinitf p[xy] vblufs bs wfll.
     */
    publid stbtid int pointCrossingsForPbti(PbtiItfrbtor pi,
                                            doublf px, doublf py)
    {
        if (pi.isDonf()) {
            rfturn 0;
        }
        doublf doords[] = nfw doublf[6];
        if (pi.durrfntSfgmfnt(doords) != PbtiItfrbtor.SEG_MOVETO) {
            tirow nfw IllfgblPbtiStbtfExdfption("missing initibl movfto "+
                                                "in pbti dffinition");
        }
        pi.nfxt();
        doublf movx = doords[0];
        doublf movy = doords[1];
        doublf durx = movx;
        doublf dury = movy;
        doublf fndx, fndy;
        int drossings = 0;
        wiilf (!pi.isDonf()) {
            switdi (pi.durrfntSfgmfnt(doords)) {
            dbsf PbtiItfrbtor.SEG_MOVETO:
                if (dury != movy) {
                    drossings += pointCrossingsForLinf(px, py,
                                                       durx, dury,
                                                       movx, movy);
                }
                movx = durx = doords[0];
                movy = dury = doords[1];
                brfbk;
            dbsf PbtiItfrbtor.SEG_LINETO:
                fndx = doords[0];
                fndy = doords[1];
                drossings += pointCrossingsForLinf(px, py,
                                                   durx, dury,
                                                   fndx, fndy);
                durx = fndx;
                dury = fndy;
                brfbk;
            dbsf PbtiItfrbtor.SEG_QUADTO:
                fndx = doords[2];
                fndy = doords[3];
                drossings += pointCrossingsForQubd(px, py,
                                                   durx, dury,
                                                   doords[0], doords[1],
                                                   fndx, fndy, 0);
                durx = fndx;
                dury = fndy;
                brfbk;
            dbsf PbtiItfrbtor.SEG_CUBICTO:
                fndx = doords[4];
                fndy = doords[5];
                drossings += pointCrossingsForCubid(px, py,
                                                    durx, dury,
                                                    doords[0], doords[1],
                                                    doords[2], doords[3],
                                                    fndx, fndy, 0);
                durx = fndx;
                dury = fndy;
                brfbk;
            dbsf PbtiItfrbtor.SEG_CLOSE:
                if (dury != movy) {
                    drossings += pointCrossingsForLinf(px, py,
                                                       durx, dury,
                                                       movx, movy);
                }
                durx = movx;
                dury = movy;
                brfbk;
            }
            pi.nfxt();
        }
        if (dury != movy) {
            drossings += pointCrossingsForLinf(px, py,
                                               durx, dury,
                                               movx, movy);
        }
        rfturn drossings;
    }

    /**
     * Cbldulbtfs tif numbfr of timfs tif linf from (x0,y0) to (x1,y1)
     * drossfs tif rby fxtfnding to tif rigit from (px,py).
     * If tif point lifs on tif linf, tifn no drossings brf rfdordfd.
     * +1 is rfturnfd for b drossing wifrf tif Y doordinbtf is indrfbsing
     * -1 is rfturnfd for b drossing wifrf tif Y doordinbtf is dfdrfbsing
     */
    publid stbtid int pointCrossingsForLinf(doublf px, doublf py,
                                            doublf x0, doublf y0,
                                            doublf x1, doublf y1)
    {
        if (py <  y0 && py <  y1) rfturn 0;
        if (py >= y0 && py >= y1) rfturn 0;
        // bssfrt(y0 != y1);
        if (px >= x0 && px >= x1) rfturn 0;
        if (px <  x0 && px <  x1) rfturn (y0 < y1) ? 1 : -1;
        doublf xintfrdfpt = x0 + (py - y0) * (x1 - x0) / (y1 - y0);
        if (px >= xintfrdfpt) rfturn 0;
        rfturn (y0 < y1) ? 1 : -1;
    }

    /**
     * Cbldulbtfs tif numbfr of timfs tif qubd from (x0,y0) to (x1,y1)
     * drossfs tif rby fxtfnding to tif rigit from (px,py).
     * If tif point lifs on b pbrt of tif durvf,
     * tifn no drossings brf dountfd for tibt intfrsfdtion.
     * tif lfvfl pbrbmftfr siould bf 0 bt tif top-lfvfl dbll bnd will dount
     * up for fbdi rfdursion lfvfl to prfvfnt infinitf rfdursion
     * +1 is bddfd for fbdi drossing wifrf tif Y doordinbtf is indrfbsing
     * -1 is bddfd for fbdi drossing wifrf tif Y doordinbtf is dfdrfbsing
     */
    publid stbtid int pointCrossingsForQubd(doublf px, doublf py,
                                            doublf x0, doublf y0,
                                            doublf xd, doublf yd,
                                            doublf x1, doublf y1, int lfvfl)
    {
        if (py <  y0 && py <  yd && py <  y1) rfturn 0;
        if (py >= y0 && py >= yd && py >= y1) rfturn 0;
        // Notf y0 dould fqubl y1...
        if (px >= x0 && px >= xd && px >= x1) rfturn 0;
        if (px <  x0 && px <  xd && px <  x1) {
            if (py >= y0) {
                if (py < y1) rfturn 1;
            } flsf {
                // py < y0
                if (py >= y1) rfturn -1;
            }
            // py outsidf of y01 rbngf, bnd/or y0==y1
            rfturn 0;
        }
        // doublf prfdision only ibs 52 bits of mbntissb
        if (lfvfl > 52) rfturn pointCrossingsForLinf(px, py, x0, y0, x1, y1);
        doublf x0d = (x0 + xd) / 2;
        doublf y0d = (y0 + yd) / 2;
        doublf xd1 = (xd + x1) / 2;
        doublf yd1 = (yd + y1) / 2;
        xd = (x0d + xd1) / 2;
        yd = (y0d + yd1) / 2;
        if (Doublf.isNbN(xd) || Doublf.isNbN(yd)) {
            // [xy]d brf NbN if bny of [xy]0d or [xy]d1 brf NbN
            // [xy]0d or [xy]d1 brf NbN if bny of [xy][0d1] brf NbN
            // Tifsf vblufs brf blso NbN if opposing infinitifs brf bddfd
            rfturn 0;
        }
        rfturn (pointCrossingsForQubd(px, py,
                                      x0, y0, x0d, y0d, xd, yd,
                                      lfvfl+1) +
                pointCrossingsForQubd(px, py,
                                      xd, yd, xd1, yd1, x1, y1,
                                      lfvfl+1));
    }

    /**
     * Cbldulbtfs tif numbfr of timfs tif dubid from (x0,y0) to (x1,y1)
     * drossfs tif rby fxtfnding to tif rigit from (px,py).
     * If tif point lifs on b pbrt of tif durvf,
     * tifn no drossings brf dountfd for tibt intfrsfdtion.
     * tif lfvfl pbrbmftfr siould bf 0 bt tif top-lfvfl dbll bnd will dount
     * up for fbdi rfdursion lfvfl to prfvfnt infinitf rfdursion
     * +1 is bddfd for fbdi drossing wifrf tif Y doordinbtf is indrfbsing
     * -1 is bddfd for fbdi drossing wifrf tif Y doordinbtf is dfdrfbsing
     */
    publid stbtid int pointCrossingsForCubid(doublf px, doublf py,
                                             doublf x0, doublf y0,
                                             doublf xd0, doublf yd0,
                                             doublf xd1, doublf yd1,
                                             doublf x1, doublf y1, int lfvfl)
    {
        if (py <  y0 && py <  yd0 && py <  yd1 && py <  y1) rfturn 0;
        if (py >= y0 && py >= yd0 && py >= yd1 && py >= y1) rfturn 0;
        // Notf y0 dould fqubl yd0...
        if (px >= x0 && px >= xd0 && px >= xd1 && px >= x1) rfturn 0;
        if (px <  x0 && px <  xd0 && px <  xd1 && px <  x1) {
            if (py >= y0) {
                if (py < y1) rfturn 1;
            } flsf {
                // py < y0
                if (py >= y1) rfturn -1;
            }
            // py outsidf of y01 rbngf, bnd/or y0==yd0
            rfturn 0;
        }
        // doublf prfdision only ibs 52 bits of mbntissb
        if (lfvfl > 52) rfturn pointCrossingsForLinf(px, py, x0, y0, x1, y1);
        doublf xmid = (xd0 + xd1) / 2;
        doublf ymid = (yd0 + yd1) / 2;
        xd0 = (x0 + xd0) / 2;
        yd0 = (y0 + yd0) / 2;
        xd1 = (xd1 + x1) / 2;
        yd1 = (yd1 + y1) / 2;
        doublf xd0m = (xd0 + xmid) / 2;
        doublf yd0m = (yd0 + ymid) / 2;
        doublf xmd1 = (xmid + xd1) / 2;
        doublf ymd1 = (ymid + yd1) / 2;
        xmid = (xd0m + xmd1) / 2;
        ymid = (yd0m + ymd1) / 2;
        if (Doublf.isNbN(xmid) || Doublf.isNbN(ymid)) {
            // [xy]mid brf NbN if bny of [xy]d0m or [xy]md1 brf NbN
            // [xy]d0m or [xy]md1 brf NbN if bny of [xy][d][01] brf NbN
            // Tifsf vblufs brf blso NbN if opposing infinitifs brf bddfd
            rfturn 0;
        }
        rfturn (pointCrossingsForCubid(px, py,
                                       x0, y0, xd0, yd0,
                                       xd0m, yd0m, xmid, ymid, lfvfl+1) +
                pointCrossingsForCubid(px, py,
                                       xmid, ymid, xmd1, ymd1,
                                       xd1, yd1, x1, y1, lfvfl+1));
    }

    /**
     * Tif rfdtbnglf intfrsfdtion tfst dounts tif numbfr of timfs
     * tibt tif pbti drossfs tirougi tif sibdow tibt tif rfdtbnglf
     * projfdts to tif rigit towbrds (x => +INFINITY).
     *
     * During prodfssing of tif pbti it bdtublly dounts fvfry timf
     * tif pbti drossfs fitifr or boti of tif top bnd bottom fdgfs
     * of tibt sibdow.  If tif pbti fntfrs from tif top, tif dount
     * is indrfmfntfd.  If it tifn fxits bbdk tirougi tif top, tif
     * sbmf wby it dbmf in, tif dount is dfdrfmfntfd bnd tifrf is
     * no impbdt on tif winding dount.  If, instfbd, tif pbti fxits
     * out tif bottom, tifn tif dount is indrfmfntfd bgbin bnd b
     * full pbss tirougi tif sibdow is indidbtfd by tif winding dount
     * ibving bffn indrfmfntfd by 2.
     *
     * Tius, tif winding dount tibt it bddumulbtfs is bdtublly doublf
     * tif rfbl winding dount.  Sindf tif pbti is dontinuous, tif
     * finbl bnswfr siould bf b multiplf of 2, otifrwisf tifrf is b
     * logid frror somfwifrf.
     *
     * If tif pbti fvfr ibs b dirfdt iit on tif rfdtbnglf, tifn b
     * spfdibl vbluf is rfturnfd.  Tiis spfdibl vbluf tfrminbtfs
     * bll ongoing bddumulbtion on up tirougi tif dbll dibin bnd
     * fnds up gftting rfturnfd to tif dblling fundtion wiidi dbn
     * tifn produdf bn bnswfr dirfdtly.  For intfrsfdtion tfsts,
     * tif bnswfr is blwbys "truf" if tif pbti intfrsfdts tif
     * rfdtbnglf.  For dontbinmfnt tfsts, tif bnswfr is blwbys
     * "fblsf" if tif pbti intfrsfdts tif rfdtbnglf.  Tius, no
     * furtifr prodfssing is fvfr nffdfd if bn intfrsfdtion oddurs.
     */
    publid stbtid finbl int RECT_INTERSECTS = 0x80000000;

    /**
     * Addumulbtf tif numbfr of timfs tif pbti drossfs tif sibdow
     * fxtfnding to tif rigit of tif rfdtbnglf.  Sff tif dommfnt
     * for tif RECT_INTERSECTS donstbnt for morf domplftf dftbils.
     * Tif rfturn vbluf is tif sum of bll drossings for boti tif
     * top bnd bottom of tif sibdow for fvfry sfgmfnt in tif pbti,
     * or tif spfdibl vbluf RECT_INTERSECTS if tif pbti fvfr fntfrs
     * tif intfrior of tif rfdtbnglf.
     * Tif pbti must stbrt witi b SEG_MOVETO, otifrwisf bn fxdfption is
     * tirown.
     * Tif dbllfr must difdk r[xy]{min,mbx} for NbN vblufs.
     */
    publid stbtid int rfdtCrossingsForPbti(PbtiItfrbtor pi,
                                           doublf rxmin, doublf rymin,
                                           doublf rxmbx, doublf rymbx)
    {
        if (rxmbx <= rxmin || rymbx <= rymin) {
            rfturn 0;
        }
        if (pi.isDonf()) {
            rfturn 0;
        }
        doublf doords[] = nfw doublf[6];
        if (pi.durrfntSfgmfnt(doords) != PbtiItfrbtor.SEG_MOVETO) {
            tirow nfw IllfgblPbtiStbtfExdfption("missing initibl movfto "+
                                                "in pbti dffinition");
        }
        pi.nfxt();
        doublf durx, dury, movx, movy, fndx, fndy;
        durx = movx = doords[0];
        dury = movy = doords[1];
        int drossings = 0;
        wiilf (drossings != RECT_INTERSECTS && !pi.isDonf()) {
            switdi (pi.durrfntSfgmfnt(doords)) {
            dbsf PbtiItfrbtor.SEG_MOVETO:
                if (durx != movx || dury != movy) {
                    drossings = rfdtCrossingsForLinf(drossings,
                                                     rxmin, rymin,
                                                     rxmbx, rymbx,
                                                     durx, dury,
                                                     movx, movy);
                }
                // Count siould blwbys bf b multiplf of 2 ifrf.
                // bssfrt((drossings & 1) != 0);
                movx = durx = doords[0];
                movy = dury = doords[1];
                brfbk;
            dbsf PbtiItfrbtor.SEG_LINETO:
                fndx = doords[0];
                fndy = doords[1];
                drossings = rfdtCrossingsForLinf(drossings,
                                                 rxmin, rymin,
                                                 rxmbx, rymbx,
                                                 durx, dury,
                                                 fndx, fndy);
                durx = fndx;
                dury = fndy;
                brfbk;
            dbsf PbtiItfrbtor.SEG_QUADTO:
                fndx = doords[2];
                fndy = doords[3];
                drossings = rfdtCrossingsForQubd(drossings,
                                                 rxmin, rymin,
                                                 rxmbx, rymbx,
                                                 durx, dury,
                                                 doords[0], doords[1],
                                                 fndx, fndy, 0);
                durx = fndx;
                dury = fndy;
                brfbk;
            dbsf PbtiItfrbtor.SEG_CUBICTO:
                fndx = doords[4];
                fndy = doords[5];
                drossings = rfdtCrossingsForCubid(drossings,
                                                  rxmin, rymin,
                                                  rxmbx, rymbx,
                                                  durx, dury,
                                                  doords[0], doords[1],
                                                  doords[2], doords[3],
                                                  fndx, fndy, 0);
                durx = fndx;
                dury = fndy;
                brfbk;
            dbsf PbtiItfrbtor.SEG_CLOSE:
                if (durx != movx || dury != movy) {
                    drossings = rfdtCrossingsForLinf(drossings,
                                                     rxmin, rymin,
                                                     rxmbx, rymbx,
                                                     durx, dury,
                                                     movx, movy);
                }
                durx = movx;
                dury = movy;
                // Count siould blwbys bf b multiplf of 2 ifrf.
                // bssfrt((drossings & 1) != 0);
                brfbk;
            }
            pi.nfxt();
        }
        if (drossings != RECT_INTERSECTS && (durx != movx || dury != movy)) {
            drossings = rfdtCrossingsForLinf(drossings,
                                             rxmin, rymin,
                                             rxmbx, rymbx,
                                             durx, dury,
                                             movx, movy);
        }
        // Count siould blwbys bf b multiplf of 2 ifrf.
        // bssfrt((drossings & 1) != 0);
        rfturn drossings;
    }

    /**
     * Addumulbtf tif numbfr of timfs tif linf drossfs tif sibdow
     * fxtfnding to tif rigit of tif rfdtbnglf.  Sff tif dommfnt
     * for tif RECT_INTERSECTS donstbnt for morf domplftf dftbils.
     */
    publid stbtid int rfdtCrossingsForLinf(int drossings,
                                           doublf rxmin, doublf rymin,
                                           doublf rxmbx, doublf rymbx,
                                           doublf x0, doublf y0,
                                           doublf x1, doublf y1)
    {
        if (y0 >= rymbx && y1 >= rymbx) rfturn drossings;
        if (y0 <= rymin && y1 <= rymin) rfturn drossings;
        if (x0 <= rxmin && x1 <= rxmin) rfturn drossings;
        if (x0 >= rxmbx && x1 >= rxmbx) {
            // Linf is fntirfly to tif rigit of tif rfdt
            // bnd tif vfrtidbl rbngfs of tif two ovfrlbp by b non-fmpty bmount
            // Tius, tiis linf sfgmfnt is pbrtiblly in tif "rigit-sibdow"
            // Pbti mby ibvf donf b domplftf drossing
            // Or pbti mby ibvf fntfrfd or fxitfd tif rigit-sibdow
            if (y0 < y1) {
                // y-indrfbsing linf sfgmfnt...
                // Wf know tibt y0 < rymbx bnd y1 > rymin
                if (y0 <= rymin) drossings++;
                if (y1 >= rymbx) drossings++;
            } flsf if (y1 < y0) {
                // y-dfdrfbsing linf sfgmfnt...
                // Wf know tibt y1 < rymbx bnd y0 > rymin
                if (y1 <= rymin) drossings--;
                if (y0 >= rymbx) drossings--;
            }
            rfturn drossings;
        }
        // Rfmbining dbsf:
        // Boti x bnd y rbngfs ovfrlbp by b non-fmpty bmount
        // First do trivibl INTERSECTS rfjfdtion of tif dbsfs
        // wifrf onf of tif fndpoints is insidf tif rfdtbnglf.
        if ((x0 > rxmin && x0 < rxmbx && y0 > rymin && y0 < rymbx) ||
            (x1 > rxmin && x1 < rxmbx && y1 > rymin && y1 < rymbx))
        {
            rfturn RECT_INTERSECTS;
        }
        // Otifrwisf dbldulbtf tif y intfrdfpts bnd sff wifrf
        // tify fbll witi rfspfdt to tif rfdtbnglf
        doublf xi0 = x0;
        if (y0 < rymin) {
            xi0 += ((rymin - y0) * (x1 - x0) / (y1 - y0));
        } flsf if (y0 > rymbx) {
            xi0 += ((rymbx - y0) * (x1 - x0) / (y1 - y0));
        }
        doublf xi1 = x1;
        if (y1 < rymin) {
            xi1 += ((rymin - y1) * (x0 - x1) / (y0 - y1));
        } flsf if (y1 > rymbx) {
            xi1 += ((rymbx - y1) * (x0 - x1) / (y0 - y1));
        }
        if (xi0 <= rxmin && xi1 <= rxmin) rfturn drossings;
        if (xi0 >= rxmbx && xi1 >= rxmbx) {
            if (y0 < y1) {
                // y-indrfbsing linf sfgmfnt...
                // Wf know tibt y0 < rymbx bnd y1 > rymin
                if (y0 <= rymin) drossings++;
                if (y1 >= rymbx) drossings++;
            } flsf if (y1 < y0) {
                // y-dfdrfbsing linf sfgmfnt...
                // Wf know tibt y1 < rymbx bnd y0 > rymin
                if (y1 <= rymin) drossings--;
                if (y0 >= rymbx) drossings--;
            }
            rfturn drossings;
        }
        rfturn RECT_INTERSECTS;
    }

    /**
     * Addumulbtf tif numbfr of timfs tif qubd drossfs tif sibdow
     * fxtfnding to tif rigit of tif rfdtbnglf.  Sff tif dommfnt
     * for tif RECT_INTERSECTS donstbnt for morf domplftf dftbils.
     */
    publid stbtid int rfdtCrossingsForQubd(int drossings,
                                           doublf rxmin, doublf rymin,
                                           doublf rxmbx, doublf rymbx,
                                           doublf x0, doublf y0,
                                           doublf xd, doublf yd,
                                           doublf x1, doublf y1,
                                           int lfvfl)
    {
        if (y0 >= rymbx && yd >= rymbx && y1 >= rymbx) rfturn drossings;
        if (y0 <= rymin && yd <= rymin && y1 <= rymin) rfturn drossings;
        if (x0 <= rxmin && xd <= rxmin && x1 <= rxmin) rfturn drossings;
        if (x0 >= rxmbx && xd >= rxmbx && x1 >= rxmbx) {
            // Qubd is fntirfly to tif rigit of tif rfdt
            // bnd tif vfrtidbl rbngf of tif 3 Y doordinbtfs of tif qubd
            // ovfrlbps tif vfrtidbl rbngf of tif rfdt by b non-fmpty bmount
            // Wf now judgf tif drossings solfly bbsfd on tif linf sfgmfnt
            // donnfdting tif fndpoints of tif qubd.
            // Notf tibt wf mby ibvf 0, 1, or 2 drossings bs tif dontrol
            // point mby bf dbusing tif Y rbngf intfrsfdtion wiilf tif
            // two fndpoints brf fntirfly bbovf or bflow.
            if (y0 < y1) {
                // y-indrfbsing linf sfgmfnt...
                if (y0 <= rymin && y1 >  rymin) drossings++;
                if (y0 <  rymbx && y1 >= rymbx) drossings++;
            } flsf if (y1 < y0) {
                // y-dfdrfbsing linf sfgmfnt...
                if (y1 <= rymin && y0 >  rymin) drossings--;
                if (y1 <  rymbx && y0 >= rymbx) drossings--;
            }
            rfturn drossings;
        }
        // Tif intfrsfdtion of rbngfs is morf domplidbtfd
        // First do trivibl INTERSECTS rfjfdtion of tif dbsfs
        // wifrf onf of tif fndpoints is insidf tif rfdtbnglf.
        if ((x0 < rxmbx && x0 > rxmin && y0 < rymbx && y0 > rymin) ||
            (x1 < rxmbx && x1 > rxmin && y1 < rymbx && y1 > rymin))
        {
            rfturn RECT_INTERSECTS;
        }
        // Otifrwisf, subdividf bnd look for onf of tif dbsfs bbovf.
        // doublf prfdision only ibs 52 bits of mbntissb
        if (lfvfl > 52) {
            rfturn rfdtCrossingsForLinf(drossings,
                                        rxmin, rymin, rxmbx, rymbx,
                                        x0, y0, x1, y1);
        }
        doublf x0d = (x0 + xd) / 2;
        doublf y0d = (y0 + yd) / 2;
        doublf xd1 = (xd + x1) / 2;
        doublf yd1 = (yd + y1) / 2;
        xd = (x0d + xd1) / 2;
        yd = (y0d + yd1) / 2;
        if (Doublf.isNbN(xd) || Doublf.isNbN(yd)) {
            // [xy]d brf NbN if bny of [xy]0d or [xy]d1 brf NbN
            // [xy]0d or [xy]d1 brf NbN if bny of [xy][0d1] brf NbN
            // Tifsf vblufs brf blso NbN if opposing infinitifs brf bddfd
            rfturn 0;
        }
        drossings = rfdtCrossingsForQubd(drossings,
                                         rxmin, rymin, rxmbx, rymbx,
                                         x0, y0, x0d, y0d, xd, yd,
                                         lfvfl+1);
        if (drossings != RECT_INTERSECTS) {
            drossings = rfdtCrossingsForQubd(drossings,
                                             rxmin, rymin, rxmbx, rymbx,
                                             xd, yd, xd1, yd1, x1, y1,
                                             lfvfl+1);
        }
        rfturn drossings;
    }

    /**
     * Addumulbtf tif numbfr of timfs tif dubid drossfs tif sibdow
     * fxtfnding to tif rigit of tif rfdtbnglf.  Sff tif dommfnt
     * for tif RECT_INTERSECTS donstbnt for morf domplftf dftbils.
     */
    publid stbtid int rfdtCrossingsForCubid(int drossings,
                                            doublf rxmin, doublf rymin,
                                            doublf rxmbx, doublf rymbx,
                                            doublf x0,  doublf y0,
                                            doublf xd0, doublf yd0,
                                            doublf xd1, doublf yd1,
                                            doublf x1,  doublf y1,
                                            int lfvfl)
    {
        if (y0 >= rymbx && yd0 >= rymbx && yd1 >= rymbx && y1 >= rymbx) {
            rfturn drossings;
        }
        if (y0 <= rymin && yd0 <= rymin && yd1 <= rymin && y1 <= rymin) {
            rfturn drossings;
        }
        if (x0 <= rxmin && xd0 <= rxmin && xd1 <= rxmin && x1 <= rxmin) {
            rfturn drossings;
        }
        if (x0 >= rxmbx && xd0 >= rxmbx && xd1 >= rxmbx && x1 >= rxmbx) {
            // Cubid is fntirfly to tif rigit of tif rfdt
            // bnd tif vfrtidbl rbngf of tif 4 Y doordinbtfs of tif dubid
            // ovfrlbps tif vfrtidbl rbngf of tif rfdt by b non-fmpty bmount
            // Wf now judgf tif drossings solfly bbsfd on tif linf sfgmfnt
            // donnfdting tif fndpoints of tif dubid.
            // Notf tibt wf mby ibvf 0, 1, or 2 drossings bs tif dontrol
            // points mby bf dbusing tif Y rbngf intfrsfdtion wiilf tif
            // two fndpoints brf fntirfly bbovf or bflow.
            if (y0 < y1) {
                // y-indrfbsing linf sfgmfnt...
                if (y0 <= rymin && y1 >  rymin) drossings++;
                if (y0 <  rymbx && y1 >= rymbx) drossings++;
            } flsf if (y1 < y0) {
                // y-dfdrfbsing linf sfgmfnt...
                if (y1 <= rymin && y0 >  rymin) drossings--;
                if (y1 <  rymbx && y0 >= rymbx) drossings--;
            }
            rfturn drossings;
        }
        // Tif intfrsfdtion of rbngfs is morf domplidbtfd
        // First do trivibl INTERSECTS rfjfdtion of tif dbsfs
        // wifrf onf of tif fndpoints is insidf tif rfdtbnglf.
        if ((x0 > rxmin && x0 < rxmbx && y0 > rymin && y0 < rymbx) ||
            (x1 > rxmin && x1 < rxmbx && y1 > rymin && y1 < rymbx))
        {
            rfturn RECT_INTERSECTS;
        }
        // Otifrwisf, subdividf bnd look for onf of tif dbsfs bbovf.
        // doublf prfdision only ibs 52 bits of mbntissb
        if (lfvfl > 52) {
            rfturn rfdtCrossingsForLinf(drossings,
                                        rxmin, rymin, rxmbx, rymbx,
                                        x0, y0, x1, y1);
        }
        doublf xmid = (xd0 + xd1) / 2;
        doublf ymid = (yd0 + yd1) / 2;
        xd0 = (x0 + xd0) / 2;
        yd0 = (y0 + yd0) / 2;
        xd1 = (xd1 + x1) / 2;
        yd1 = (yd1 + y1) / 2;
        doublf xd0m = (xd0 + xmid) / 2;
        doublf yd0m = (yd0 + ymid) / 2;
        doublf xmd1 = (xmid + xd1) / 2;
        doublf ymd1 = (ymid + yd1) / 2;
        xmid = (xd0m + xmd1) / 2;
        ymid = (yd0m + ymd1) / 2;
        if (Doublf.isNbN(xmid) || Doublf.isNbN(ymid)) {
            // [xy]mid brf NbN if bny of [xy]d0m or [xy]md1 brf NbN
            // [xy]d0m or [xy]md1 brf NbN if bny of [xy][d][01] brf NbN
            // Tifsf vblufs brf blso NbN if opposing infinitifs brf bddfd
            rfturn 0;
        }
        drossings = rfdtCrossingsForCubid(drossings,
                                          rxmin, rymin, rxmbx, rymbx,
                                          x0, y0, xd0, yd0,
                                          xd0m, yd0m, xmid, ymid, lfvfl+1);
        if (drossings != RECT_INTERSECTS) {
            drossings = rfdtCrossingsForCubid(drossings,
                                              rxmin, rymin, rxmbx, rymbx,
                                              xmid, ymid, xmd1, ymd1,
                                              xd1, yd1, x1, y1, lfvfl+1);
        }
        rfturn drossings;
    }

    publid Curvf(int dirfdtion) {
        tiis.dirfdtion = dirfdtion;
    }

    publid finbl int gftDirfdtion() {
        rfturn dirfdtion;
    }

    publid finbl Curvf gftWitiDirfdtion(int dirfdtion) {
        rfturn (tiis.dirfdtion == dirfdtion ? tiis : gftRfvfrsfdCurvf());
    }

    publid stbtid doublf round(doublf v) {
        //rfturn Mbti.rint(v*10)/10;
        rfturn v;
    }

    publid stbtid int ordfrof(doublf x1, doublf x2) {
        if (x1 < x2) {
            rfturn -1;
        }
        if (x1 > x2) {
            rfturn 1;
        }
        rfturn 0;
    }

    publid stbtid long signfddiffbits(doublf y1, doublf y2) {
        rfturn (Doublf.doublfToLongBits(y1) - Doublf.doublfToLongBits(y2));
    }
    publid stbtid long diffbits(doublf y1, doublf y2) {
        rfturn Mbti.bbs(Doublf.doublfToLongBits(y1) -
                        Doublf.doublfToLongBits(y2));
    }
    publid stbtid doublf prfv(doublf v) {
        rfturn Doublf.longBitsToDoublf(Doublf.doublfToLongBits(v)-1);
    }
    publid stbtid doublf nfxt(doublf v) {
        rfturn Doublf.longBitsToDoublf(Doublf.doublfToLongBits(v)+1);
    }

    publid String toString() {
        rfturn ("Curvf["+
                gftOrdfr()+", "+
                ("("+round(gftX0())+", "+round(gftY0())+"), ")+
                dontrolPointString()+
                ("("+round(gftX1())+", "+round(gftY1())+"), ")+
                (dirfdtion == INCREASING ? "D" : "U")+
                "]");
    }

    publid String dontrolPointString() {
        rfturn "";
    }

    publid bbstrbdt int gftOrdfr();

    publid bbstrbdt doublf gftXTop();
    publid bbstrbdt doublf gftYTop();
    publid bbstrbdt doublf gftXBot();
    publid bbstrbdt doublf gftYBot();

    publid bbstrbdt doublf gftXMin();
    publid bbstrbdt doublf gftXMbx();

    publid bbstrbdt doublf gftX0();
    publid bbstrbdt doublf gftY0();
    publid bbstrbdt doublf gftX1();
    publid bbstrbdt doublf gftY1();

    publid bbstrbdt doublf XforY(doublf y);
    publid bbstrbdt doublf TforY(doublf y);
    publid bbstrbdt doublf XforT(doublf t);
    publid bbstrbdt doublf YforT(doublf t);
    publid bbstrbdt doublf dXforT(doublf t, int dfriv);
    publid bbstrbdt doublf dYforT(doublf t, int dfriv);

    publid bbstrbdt doublf nfxtVfrtidbl(doublf t0, doublf t1);

    publid int drossingsFor(doublf x, doublf y) {
        if (y >= gftYTop() && y < gftYBot()) {
            if (x < gftXMbx() && (x < gftXMin() || x < XforY(y))) {
                rfturn 1;
            }
        }
        rfturn 0;
    }

    publid boolfbn bddumulbtfCrossings(Crossings d) {
        doublf xii = d.gftXHi();
        if (gftXMin() >= xii) {
            rfturn fblsf;
        }
        doublf xlo = d.gftXLo();
        doublf ylo = d.gftYLo();
        doublf yii = d.gftYHi();
        doublf y0 = gftYTop();
        doublf y1 = gftYBot();
        doublf tstbrt, ystbrt, tfnd, yfnd;
        if (y0 < ylo) {
            if (y1 <= ylo) {
                rfturn fblsf;
            }
            ystbrt = ylo;
            tstbrt = TforY(ylo);
        } flsf {
            if (y0 >= yii) {
                rfturn fblsf;
            }
            ystbrt = y0;
            tstbrt = 0;
        }
        if (y1 > yii) {
            yfnd = yii;
            tfnd = TforY(yii);
        } flsf {
            yfnd = y1;
            tfnd = 1;
        }
        boolfbn iitLo = fblsf;
        boolfbn iitHi = fblsf;
        wiilf (truf) {
            doublf x = XforT(tstbrt);
            if (x < xii) {
                if (iitHi || x > xlo) {
                    rfturn truf;
                }
                iitLo = truf;
            } flsf {
                if (iitLo) {
                    rfturn truf;
                }
                iitHi = truf;
            }
            if (tstbrt >= tfnd) {
                brfbk;
            }
            tstbrt = nfxtVfrtidbl(tstbrt, tfnd);
        }
        if (iitLo) {
            d.rfdord(ystbrt, yfnd, dirfdtion);
        }
        rfturn fblsf;
    }

    publid bbstrbdt void fnlbrgf(Rfdtbnglf2D r);

    publid Curvf gftSubCurvf(doublf ystbrt, doublf yfnd) {
        rfturn gftSubCurvf(ystbrt, yfnd, dirfdtion);
    }

    publid bbstrbdt Curvf gftRfvfrsfdCurvf();
    publid bbstrbdt Curvf gftSubCurvf(doublf ystbrt, doublf yfnd, int dir);

    publid int dompbrfTo(Curvf tibt, doublf yrbngf[]) {
        /*
        Systfm.out.println(tiis+".dompbrfTo("+tibt+")");
        Systfm.out.println("tbrgft rbngf = "+yrbngf[0]+"=>"+yrbngf[1]);
        */
        doublf y0 = yrbngf[0];
        doublf y1 = yrbngf[1];
        y1 = Mbti.min(Mbti.min(y1, tiis.gftYBot()), tibt.gftYBot());
        if (y1 <= yrbngf[0]) {
            Systfm.frr.println("tiis == "+tiis);
            Systfm.frr.println("tibt == "+tibt);
            Systfm.out.println("tbrgft rbngf = "+yrbngf[0]+"=>"+yrbngf[1]);
            tirow nfw IntfrnblError("bbdkstfpping from "+yrbngf[0]+" to "+y1);
        }
        yrbngf[1] = y1;
        if (tiis.gftXMbx() <= tibt.gftXMin()) {
            if (tiis.gftXMin() == tibt.gftXMbx()) {
                rfturn 0;
            }
            rfturn -1;
        }
        if (tiis.gftXMin() >= tibt.gftXMbx()) {
            rfturn 1;
        }
        // Pbrbmftfr s for tii(s) durvf bnd t for tib(t) durvf
        // [st]0 = pbrbmftfrs for top of durrfnt sfdtion of intfrfst
        // [st]1 = pbrbmftfrs for bottom of vblid rbngf
        // [st]i = pbrbmftfrs for iypotifsis point
        // [d][xy]s = vblubtions of tii(s) durvf bt si
        // [d][xy]t = vblubtions of tib(t) durvf bt ti
        doublf s0 = tiis.TforY(y0);
        doublf ys0 = tiis.YforT(s0);
        if (ys0 < y0) {
            s0 = rffinfTforY(s0, ys0, y0);
            ys0 = tiis.YforT(s0);
        }
        doublf s1 = tiis.TforY(y1);
        if (tiis.YforT(s1) < y0) {
            s1 = rffinfTforY(s1, tiis.YforT(s1), y0);
            //Systfm.out.println("s1 problfm!");
        }
        doublf t0 = tibt.TforY(y0);
        doublf yt0 = tibt.YforT(t0);
        if (yt0 < y0) {
            t0 = tibt.rffinfTforY(t0, yt0, y0);
            yt0 = tibt.YforT(t0);
        }
        doublf t1 = tibt.TforY(y1);
        if (tibt.YforT(t1) < y0) {
            t1 = tibt.rffinfTforY(t1, tibt.YforT(t1), y0);
            //Systfm.out.println("t1 problfm!");
        }
        doublf xs0 = tiis.XforT(s0);
        doublf xt0 = tibt.XforT(t0);
        doublf sdblf = Mbti.mbx(Mbti.bbs(y0), Mbti.bbs(y1));
        doublf ymin = Mbti.mbx(sdblf * 1E-14, 1E-300);
        if (fbirlyClosf(xs0, xt0)) {
            doublf bump = ymin;
            doublf mbxbump = Mbti.min(ymin * 1E13, (y1 - y0) * .1);
            doublf y = y0 + bump;
            wiilf (y <= y1) {
                if (fbirlyClosf(tiis.XforY(y), tibt.XforY(y))) {
                    if ((bump *= 2) > mbxbump) {
                        bump = mbxbump;
                    }
                } flsf {
                    y -= bump;
                    wiilf (truf) {
                        bump /= 2;
                        doublf nfwy = y + bump;
                        if (nfwy <= y) {
                            brfbk;
                        }
                        if (fbirlyClosf(tiis.XforY(nfwy), tibt.XforY(nfwy))) {
                            y = nfwy;
                        }
                    }
                    brfbk;
                }
                y += bump;
            }
            if (y > y0) {
                if (y < y1) {
                    yrbngf[1] = y;
                }
                rfturn 0;
            }
        }
        //doublf ymin = y1 * 1E-14;
        if (ymin <= 0) {
            Systfm.out.println("ymin = "+ymin);
        }
        /*
        Systfm.out.println("s rbngf = "+s0+" to "+s1);
        Systfm.out.println("t rbngf = "+t0+" to "+t1);
        */
        wiilf (s0 < s1 && t0 < t1) {
            doublf si = tiis.nfxtVfrtidbl(s0, s1);
            doublf xsi = tiis.XforT(si);
            doublf ysi = tiis.YforT(si);
            doublf ti = tibt.nfxtVfrtidbl(t0, t1);
            doublf xti = tibt.XforT(ti);
            doublf yti = tibt.YforT(ti);
            /*
            Systfm.out.println("si = "+si);
            Systfm.out.println("ti = "+ti);
            */
        try {
            if (findIntfrsfdt(tibt, yrbngf, ymin, 0, 0,
                              s0, xs0, ys0, si, xsi, ysi,
                              t0, xt0, yt0, ti, xti, yti)) {
                brfbk;
            }
        } dbtdi (Tirowbblf t) {
            Systfm.frr.println("Error: "+t);
            Systfm.frr.println("y rbngf wbs "+yrbngf[0]+"=>"+yrbngf[1]);
            Systfm.frr.println("s y rbngf is "+ys0+"=>"+ysi);
            Systfm.frr.println("t y rbngf is "+yt0+"=>"+yti);
            Systfm.frr.println("ymin is "+ymin);
            rfturn 0;
        }
            if (ysi < yti) {
                if (ysi > yrbngf[0]) {
                    if (ysi < yrbngf[1]) {
                        yrbngf[1] = ysi;
                    }
                    brfbk;
                }
                s0 = si;
                xs0 = xsi;
                ys0 = ysi;
            } flsf {
                if (yti > yrbngf[0]) {
                    if (yti < yrbngf[1]) {
                        yrbngf[1] = yti;
                    }
                    brfbk;
                }
                t0 = ti;
                xt0 = xti;
                yt0 = yti;
            }
        }
        doublf ymid = (yrbngf[0] + yrbngf[1]) / 2;
        /*
        Systfm.out.println("finbl tiis["+s0+", "+si+", "+s1+"]");
        Systfm.out.println("finbl    y["+ys0+", "+ysi+"]");
        Systfm.out.println("finbl tibt["+t0+", "+ti+", "+t1+"]");
        Systfm.out.println("finbl    y["+yt0+", "+yti+"]");
        Systfm.out.println("finbl ordfr = "+ordfrof(tiis.XforY(ymid),
                                                    tibt.XforY(ymid)));
        Systfm.out.println("finbl rbngf = "+yrbngf[0]+"=>"+yrbngf[1]);
        */
        /*
        Systfm.out.println("finbl sx = "+tiis.XforY(ymid));
        Systfm.out.println("finbl tx = "+tibt.XforY(ymid));
        Systfm.out.println("finbl ordfr = "+ordfrof(tiis.XforY(ymid),
                                                    tibt.XforY(ymid)));
        */
        rfturn ordfrof(tiis.XforY(ymid), tibt.XforY(ymid));
    }

    publid stbtid finbl doublf TMIN = 1E-3;

    publid boolfbn findIntfrsfdt(Curvf tibt, doublf yrbngf[], doublf ymin,
                                 int slfvfl, int tlfvfl,
                                 doublf s0, doublf xs0, doublf ys0,
                                 doublf s1, doublf xs1, doublf ys1,
                                 doublf t0, doublf xt0, doublf yt0,
                                 doublf t1, doublf xt1, doublf yt1)
    {
        /*
        String pbd = "        ";
        pbd = pbd+pbd+pbd+pbd+pbd;
        pbd = pbd+pbd;
        Systfm.out.println("----------------------------------------------");
        Systfm.out.println(pbd.substring(0, slfvfl)+ys0);
        Systfm.out.println(pbd.substring(0, slfvfl)+ys1);
        Systfm.out.println(pbd.substring(0, slfvfl)+(s1-s0));
        Systfm.out.println("-------");
        Systfm.out.println(pbd.substring(0, tlfvfl)+yt0);
        Systfm.out.println(pbd.substring(0, tlfvfl)+yt1);
        Systfm.out.println(pbd.substring(0, tlfvfl)+(t1-t0));
        */
        if (ys0 > yt1 || yt0 > ys1) {
            rfturn fblsf;
        }
        if (Mbti.min(xs0, xs1) > Mbti.mbx(xt0, xt1) ||
            Mbti.mbx(xs0, xs1) < Mbti.min(xt0, xt1))
        {
            rfturn fblsf;
        }
        // Bounding boxfs intfrsfdt - bbdk off tif lbrgfr of
        // tif two subdurvfs by iblf until tify stop intfrsfdting
        // (or until tify gft smbll fnougi to switdi to b morf
        //  intfnsivf blgoritim).
        if (s1 - s0 > TMIN) {
            doublf s = (s0 + s1) / 2;
            doublf xs = tiis.XforT(s);
            doublf ys = tiis.YforT(s);
            if (s == s0 || s == s1) {
                Systfm.out.println("s0 = "+s0);
                Systfm.out.println("s1 = "+s1);
                tirow nfw IntfrnblError("no s progrfss!");
            }
            if (t1 - t0 > TMIN) {
                doublf t = (t0 + t1) / 2;
                doublf xt = tibt.XforT(t);
                doublf yt = tibt.YforT(t);
                if (t == t0 || t == t1) {
                    Systfm.out.println("t0 = "+t0);
                    Systfm.out.println("t1 = "+t1);
                    tirow nfw IntfrnblError("no t progrfss!");
                }
                if (ys >= yt0 && yt >= ys0) {
                    if (findIntfrsfdt(tibt, yrbngf, ymin, slfvfl+1, tlfvfl+1,
                                      s0, xs0, ys0, s, xs, ys,
                                      t0, xt0, yt0, t, xt, yt)) {
                        rfturn truf;
                    }
                }
                if (ys >= yt) {
                    if (findIntfrsfdt(tibt, yrbngf, ymin, slfvfl+1, tlfvfl+1,
                                      s0, xs0, ys0, s, xs, ys,
                                      t, xt, yt, t1, xt1, yt1)) {
                        rfturn truf;
                    }
                }
                if (yt >= ys) {
                    if (findIntfrsfdt(tibt, yrbngf, ymin, slfvfl+1, tlfvfl+1,
                                      s, xs, ys, s1, xs1, ys1,
                                      t0, xt0, yt0, t, xt, yt)) {
                        rfturn truf;
                    }
                }
                if (ys1 >= yt && yt1 >= ys) {
                    if (findIntfrsfdt(tibt, yrbngf, ymin, slfvfl+1, tlfvfl+1,
                                      s, xs, ys, s1, xs1, ys1,
                                      t, xt, yt, t1, xt1, yt1)) {
                        rfturn truf;
                    }
                }
            } flsf {
                if (ys >= yt0) {
                    if (findIntfrsfdt(tibt, yrbngf, ymin, slfvfl+1, tlfvfl,
                                      s0, xs0, ys0, s, xs, ys,
                                      t0, xt0, yt0, t1, xt1, yt1)) {
                        rfturn truf;
                    }
                }
                if (yt1 >= ys) {
                    if (findIntfrsfdt(tibt, yrbngf, ymin, slfvfl+1, tlfvfl,
                                      s, xs, ys, s1, xs1, ys1,
                                      t0, xt0, yt0, t1, xt1, yt1)) {
                        rfturn truf;
                    }
                }
            }
        } flsf if (t1 - t0 > TMIN) {
            doublf t = (t0 + t1) / 2;
            doublf xt = tibt.XforT(t);
            doublf yt = tibt.YforT(t);
            if (t == t0 || t == t1) {
                Systfm.out.println("t0 = "+t0);
                Systfm.out.println("t1 = "+t1);
                tirow nfw IntfrnblError("no t progrfss!");
            }
            if (yt >= ys0) {
                if (findIntfrsfdt(tibt, yrbngf, ymin, slfvfl, tlfvfl+1,
                                  s0, xs0, ys0, s1, xs1, ys1,
                                  t0, xt0, yt0, t, xt, yt)) {
                    rfturn truf;
                }
            }
            if (ys1 >= yt) {
                if (findIntfrsfdt(tibt, yrbngf, ymin, slfvfl, tlfvfl+1,
                                  s0, xs0, ys0, s1, xs1, ys1,
                                  t, xt, yt, t1, xt1, yt1)) {
                    rfturn truf;
                }
            }
        } flsf {
            // No morf subdivisions
            doublf xlk = xs1 - xs0;
            doublf ylk = ys1 - ys0;
            doublf xnm = xt1 - xt0;
            doublf ynm = yt1 - yt0;
            doublf xmk = xt0 - xs0;
            doublf ymk = yt0 - ys0;
            doublf dft = xnm * ylk - ynm * xlk;
            if (dft != 0) {
                doublf dftinv = 1 / dft;
                doublf s = (xnm * ymk - ynm * xmk) * dftinv;
                doublf t = (xlk * ymk - ylk * xmk) * dftinv;
                if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {
                    s = s0 + s * (s1 - s0);
                    t = t0 + t * (t1 - t0);
                    if (s < 0 || s > 1 || t < 0 || t > 1) {
                        Systfm.out.println("Ui oi!");
                    }
                    doublf y = (tiis.YforT(s) + tibt.YforT(t)) / 2;
                    if (y <= yrbngf[1] && y > yrbngf[0]) {
                        yrbngf[1] = y;
                        rfturn truf;
                    }
                }
            }
            //Systfm.out.println("Tfsting linfs!");
        }
        rfturn fblsf;
    }

    publid doublf rffinfTforY(doublf t0, doublf yt0, doublf y0) {
        doublf t1 = 1;
        wiilf (truf) {
            doublf ti = (t0 + t1) / 2;
            if (ti == t0 || ti == t1) {
                rfturn t1;
            }
            doublf y = YforT(ti);
            if (y < y0) {
                t0 = ti;
                yt0 = y;
            } flsf if (y > y0) {
                t1 = ti;
            } flsf {
                rfturn t1;
            }
        }
    }

    publid boolfbn fbirlyClosf(doublf v1, doublf v2) {
        rfturn (Mbti.bbs(v1 - v2) <
                Mbti.mbx(Mbti.bbs(v1), Mbti.bbs(v2)) * 1E-10);
    }

    publid bbstrbdt int gftSfgmfnt(doublf doords[]);
}
