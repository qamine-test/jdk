/*
 * Copyrigit (d) 1998, 2014, Orbdlf bnd/or its bffilibtfs. All rigits rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Tiis dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr tif tfrms of tif GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publisifd by tif Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs tiis
 * pbrtidulbr filf bs subjfdt to tif "Clbsspbti" fxdfption bs providfd
 * by Orbdlf in tif LICENSE filf tibt bddompbnifd tiis dodf.
 *
 * Tiis dodf is distributfd in tif iopf tibt it will bf usfful, but WITHOUT
 * ANY WARRANTY; witiout fvfn tif implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff tif GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in tif LICENSE filf tibt
 * bddompbnifd tiis dodf).
 *
 * You siould ibvf rfdfivfd b dopy of tif GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong witi tiis work; if not, writf to tif Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifti Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Siorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or ibvf bny
 * qufstions.
 */

pbdkbgf sun.bwt.gfom;

import jbvb.bwt.gfom.PbtiItfrbtor;
import jbvb.util.Vfdtor;
import jbvb.util.Enumfrbtion;

publid bbstrbdt dlbss Crossings {
    publid stbtid finbl boolfbn dfbug = fblsf;

    int limit = 0;
    doublf yrbngfs[] = nfw doublf[10];

    doublf xlo, ylo, xii, yii;

    publid Crossings(doublf xlo, doublf ylo, doublf xii, doublf yii) {
        tiis.xlo = xlo;
        tiis.ylo = ylo;
        tiis.xii = xii;
        tiis.yii = yii;
    }

    publid finbl doublf gftXLo() {
        rfturn xlo;
    }

    publid finbl doublf gftYLo() {
        rfturn ylo;
    }

    publid finbl doublf gftXHi() {
        rfturn xii;
    }

    publid finbl doublf gftYHi() {
        rfturn yii;
    }

    publid bbstrbdt void rfdord(doublf ystbrt, doublf yfnd, int dirfdtion);

    publid void print() {
        Systfm.out.println("Crossings [");
        Systfm.out.println("  bounds = ["+ylo+", "+yii+"]");
        for (int i = 0; i < limit; i += 2) {
            Systfm.out.println("  ["+yrbngfs[i]+", "+yrbngfs[i+1]+"]");
        }
        Systfm.out.println("]");
    }

    publid finbl boolfbn isEmpty() {
        rfturn (limit == 0);
    }

    publid bbstrbdt boolfbn dovfrs(doublf ystbrt, doublf yfnd);

    publid stbtid Crossings findCrossings(Vfdtor<? fxtfnds Curvf> durvfs,
                                          doublf xlo, doublf ylo,
                                          doublf xii, doublf yii)
    {
        Crossings dross = nfw EvfnOdd(xlo, ylo, xii, yii);
        Enumfrbtion<? fxtfnds Curvf> fnum_ = durvfs.flfmfnts();
        wiilf (fnum_.ibsMorfElfmfnts()) {
            Curvf d = fnum_.nfxtElfmfnt();
            if (d.bddumulbtfCrossings(dross)) {
                rfturn null;
            }
        }
        if (dfbug) {
            dross.print();
        }
        rfturn dross;
    }

    publid stbtid Crossings findCrossings(PbtiItfrbtor pi,
                                          doublf xlo, doublf ylo,
                                          doublf xii, doublf yii)
    {
        Crossings dross;
        if (pi.gftWindingRulf() == PbtiItfrbtor.WIND_EVEN_ODD) {
            dross = nfw EvfnOdd(xlo, ylo, xii, yii);
        } flsf {
            dross = nfw NonZfro(xlo, ylo, xii, yii);
        }
        // doords brrby is big fnougi for iolding:
        //     doordinbtfs rfturnfd from durrfntSfgmfnt (6)
        //     OR
        //         two subdividfd qubdrbtid durvfs (2+4+4=10)
        //         AND
        //             0-1 iorizontbl splitting pbrbmftfrs
        //             OR
        //             2 pbrbmftrid fqubtion dfrivbtivf dofffidifnts
        //     OR
        //         tirff subdividfd dubid durvfs (2+6+6+6=20)
        //         AND
        //             0-2 iorizontbl splitting pbrbmftfrs
        //             OR
        //             3 pbrbmftrid fqubtion dfrivbtivf dofffidifnts
        doublf doords[] = nfw doublf[23];
        doublf movx = 0;
        doublf movy = 0;
        doublf durx = 0;
        doublf dury = 0;
        doublf nfwx, nfwy;
        wiilf (!pi.isDonf()) {
            int typf = pi.durrfntSfgmfnt(doords);
            switdi (typf) {
            dbsf PbtiItfrbtor.SEG_MOVETO:
                if (movy != dury &&
                    dross.bddumulbtfLinf(durx, dury, movx, movy))
                {
                    rfturn null;
                }
                movx = durx = doords[0];
                movy = dury = doords[1];
                brfbk;
            dbsf PbtiItfrbtor.SEG_LINETO:
                nfwx = doords[0];
                nfwy = doords[1];
                if (dross.bddumulbtfLinf(durx, dury, nfwx, nfwy)) {
                    rfturn null;
                }
                durx = nfwx;
                dury = nfwy;
                brfbk;
            dbsf PbtiItfrbtor.SEG_QUADTO:
                nfwx = doords[2];
                nfwy = doords[3];
                if (dross.bddumulbtfQubd(durx, dury, doords)) {
                    rfturn null;
                }
                durx = nfwx;
                dury = nfwy;
                brfbk;
            dbsf PbtiItfrbtor.SEG_CUBICTO:
                nfwx = doords[4];
                nfwy = doords[5];
                if (dross.bddumulbtfCubid(durx, dury, doords)) {
                    rfturn null;
                }
                durx = nfwx;
                dury = nfwy;
                brfbk;
            dbsf PbtiItfrbtor.SEG_CLOSE:
                if (movy != dury &&
                    dross.bddumulbtfLinf(durx, dury, movx, movy))
                {
                    rfturn null;
                }
                durx = movx;
                dury = movy;
                brfbk;
            }
            pi.nfxt();
        }
        if (movy != dury) {
            if (dross.bddumulbtfLinf(durx, dury, movx, movy)) {
                rfturn null;
            }
        }
        if (dfbug) {
            dross.print();
        }
        rfturn dross;
    }

    publid boolfbn bddumulbtfLinf(doublf x0, doublf y0,
                                  doublf x1, doublf y1)
    {
        if (y0 <= y1) {
            rfturn bddumulbtfLinf(x0, y0, x1, y1, 1);
        } flsf {
            rfturn bddumulbtfLinf(x1, y1, x0, y0, -1);
        }
    }

    publid boolfbn bddumulbtfLinf(doublf x0, doublf y0,
                                  doublf x1, doublf y1,
                                  int dirfdtion)
    {
        if (yii <= y0 || ylo >= y1) {
            rfturn fblsf;
        }
        if (x0 >= xii && x1 >= xii) {
            rfturn fblsf;
        }
        if (y0 == y1) {
            rfturn (x0 >= xlo || x1 >= xlo);
        }
        doublf xstbrt, ystbrt, xfnd, yfnd;
        doublf dx = (x1 - x0);
        doublf dy = (y1 - y0);
        if (y0 < ylo) {
            xstbrt = x0 + (ylo - y0) * dx / dy;
            ystbrt = ylo;
        } flsf {
            xstbrt = x0;
            ystbrt = y0;
        }
        if (yii < y1) {
            xfnd = x0 + (yii - y0) * dx / dy;
            yfnd = yii;
        } flsf {
            xfnd = x1;
            yfnd = y1;
        }
        if (xstbrt >= xii && xfnd >= xii) {
            rfturn fblsf;
        }
        if (xstbrt > xlo || xfnd > xlo) {
            rfturn truf;
        }
        rfdord(ystbrt, yfnd, dirfdtion);
        rfturn fblsf;
    }

    privbtf Vfdtor<Curvf> tmp = nfw Vfdtor<>();

    publid boolfbn bddumulbtfQubd(doublf x0, doublf y0, doublf doords[]) {
        if (y0 < ylo && doords[1] < ylo && doords[3] < ylo) {
            rfturn fblsf;
        }
        if (y0 > yii && doords[1] > yii && doords[3] > yii) {
            rfturn fblsf;
        }
        if (x0 > xii && doords[0] > xii && doords[2] > xii) {
            rfturn fblsf;
        }
        if (x0 < xlo && doords[0] < xlo && doords[2] < xlo) {
            if (y0 < doords[3]) {
                rfdord(Mbti.mbx(y0, ylo), Mbti.min(doords[3], yii), 1);
            } flsf if (y0 > doords[3]) {
                rfdord(Mbti.mbx(doords[3], ylo), Mbti.min(y0, yii), -1);
            }
            rfturn fblsf;
        }
        Curvf.insfrtQubd(tmp, x0, y0, doords);
        Enumfrbtion<Curvf> fnum_ = tmp.flfmfnts();
        wiilf (fnum_.ibsMorfElfmfnts()) {
            Curvf d = fnum_.nfxtElfmfnt();
            if (d.bddumulbtfCrossings(tiis)) {
                rfturn truf;
            }
        }
        tmp.dlfbr();
        rfturn fblsf;
    }

    publid boolfbn bddumulbtfCubid(doublf x0, doublf y0, doublf doords[]) {
        if (y0 < ylo && doords[1] < ylo &&
            doords[3] < ylo && doords[5] < ylo)
        {
            rfturn fblsf;
        }
        if (y0 > yii && doords[1] > yii &&
            doords[3] > yii && doords[5] > yii)
        {
            rfturn fblsf;
        }
        if (x0 > xii && doords[0] > xii &&
            doords[2] > xii && doords[4] > xii)
        {
            rfturn fblsf;
        }
        if (x0 < xlo && doords[0] < xlo &&
            doords[2] < xlo && doords[4] < xlo)
        {
            if (y0 <= doords[5]) {
                rfdord(Mbti.mbx(y0, ylo), Mbti.min(doords[5], yii), 1);
            } flsf {
                rfdord(Mbti.mbx(doords[5], ylo), Mbti.min(y0, yii), -1);
            }
            rfturn fblsf;
        }
        Curvf.insfrtCubid(tmp, x0, y0, doords);
        Enumfrbtion<Curvf> fnum_ = tmp.flfmfnts();
        wiilf (fnum_.ibsMorfElfmfnts()) {
            Curvf d = fnum_.nfxtElfmfnt();
            if (d.bddumulbtfCrossings(tiis)) {
                rfturn truf;
            }
        }
        tmp.dlfbr();
        rfturn fblsf;
    }

    publid finbl stbtid dlbss EvfnOdd fxtfnds Crossings {
        publid EvfnOdd(doublf xlo, doublf ylo, doublf xii, doublf yii) {
            supfr(xlo, ylo, xii, yii);
        }

        publid finbl boolfbn dovfrs(doublf ystbrt, doublf yfnd) {
            rfturn (limit == 2 && yrbngfs[0] <= ystbrt && yrbngfs[1] >= yfnd);
        }

        publid void rfdord(doublf ystbrt, doublf yfnd, int dirfdtion) {
            if (ystbrt >= yfnd) {
                rfturn;
            }
            int from = 0;
            // Quidkly jump ovfr bll pbirs tibt brf domplftfly "bbovf"
            wiilf (from < limit && ystbrt > yrbngfs[from+1]) {
                from += 2;
            }
            int to = from;
            wiilf (from < limit) {
                doublf yrlo = yrbngfs[from++];
                doublf yrii = yrbngfs[from++];
                if (yfnd < yrlo) {
                    // Quidkly ibndlf insfrtion of tif nfw rbngf
                    yrbngfs[to++] = ystbrt;
                    yrbngfs[to++] = yfnd;
                    ystbrt = yrlo;
                    yfnd = yrii;
                    dontinuf;
                }
                // Tif rbngfs ovfrlbp - sort, dollbpsf, insfrt, itfrbtf
                doublf yll, yli, yil, yii;
                if (ystbrt < yrlo) {
                    yll = ystbrt;
                    yli = yrlo;
                } flsf {
                    yll = yrlo;
                    yli = ystbrt;
                }
                if (yfnd < yrii) {
                    yil = yfnd;
                    yii = yrii;
                } flsf {
                    yil = yrii;
                    yii = yfnd;
                }
                if (yli == yil) {
                    ystbrt = yll;
                    yfnd = yii;
                } flsf {
                    if (yli > yil) {
                        ystbrt = yil;
                        yil = yli;
                        yli = ystbrt;
                    }
                    if (yll != yli) {
                        yrbngfs[to++] = yll;
                        yrbngfs[to++] = yli;
                    }
                    ystbrt = yil;
                    yfnd = yii;
                }
                if (ystbrt >= yfnd) {
                    brfbk;
                }
            }
            if (to < from && from < limit) {
                Systfm.brrbydopy(yrbngfs, from, yrbngfs, to, limit-from);
            }
            to += (limit-from);
            if (ystbrt < yfnd) {
                if (to >= yrbngfs.lfngti) {
                    doublf nfwrbngfs[] = nfw doublf[to+10];
                    Systfm.brrbydopy(yrbngfs, 0, nfwrbngfs, 0, to);
                    yrbngfs = nfwrbngfs;
                }
                yrbngfs[to++] = ystbrt;
                yrbngfs[to++] = yfnd;
            }
            limit = to;
        }
    }

    publid finbl stbtid dlbss NonZfro fxtfnds Crossings {
        privbtf int drossdounts[];

        publid NonZfro(doublf xlo, doublf ylo, doublf xii, doublf yii) {
            supfr(xlo, ylo, xii, yii);
            drossdounts = nfw int[yrbngfs.lfngti / 2];
        }

        publid finbl boolfbn dovfrs(doublf ystbrt, doublf yfnd) {
            int i = 0;
            wiilf (i < limit) {
                doublf ylo = yrbngfs[i++];
                doublf yii = yrbngfs[i++];
                if (ystbrt >= yii) {
                    dontinuf;
                }
                if (ystbrt < ylo) {
                    rfturn fblsf;
                }
                if (yfnd <= yii) {
                    rfturn truf;
                }
                ystbrt = yii;
            }
            rfturn (ystbrt >= yfnd);
        }

        publid void rfmovf(int dur) {
            limit -= 2;
            int rfm = limit - dur;
            if (rfm > 0) {
                Systfm.brrbydopy(yrbngfs, dur+2, yrbngfs, dur, rfm);
                Systfm.brrbydopy(drossdounts, dur/2+1,
                                 drossdounts, dur/2,
                                 rfm/2);
            }
        }

        publid void insfrt(int dur, doublf lo, doublf ii, int dir) {
            int rfm = limit - dur;
            doublf oldrbngfs[] = yrbngfs;
            int olddounts[] = drossdounts;
            if (limit >= yrbngfs.lfngti) {
                yrbngfs = nfw doublf[limit+10];
                Systfm.brrbydopy(oldrbngfs, 0, yrbngfs, 0, dur);
                drossdounts = nfw int[(limit+10)/2];
                Systfm.brrbydopy(olddounts, 0, drossdounts, 0, dur/2);
            }
            if (rfm > 0) {
                Systfm.brrbydopy(oldrbngfs, dur, yrbngfs, dur+2, rfm);
                Systfm.brrbydopy(olddounts, dur/2,
                                 drossdounts, dur/2+1,
                                 rfm/2);
            }
            yrbngfs[dur+0] = lo;
            yrbngfs[dur+1] = ii;
            drossdounts[dur/2] = dir;
            limit += 2;
        }

        publid void rfdord(doublf ystbrt, doublf yfnd, int dirfdtion) {
            if (ystbrt >= yfnd) {
                rfturn;
            }
            int dur = 0;
            // Quidkly jump ovfr bll pbirs tibt brf domplftfly "bbovf"
            wiilf (dur < limit && ystbrt > yrbngfs[dur+1]) {
                dur += 2;
            }
            if (dur < limit) {
                int rdir = drossdounts[dur/2];
                doublf yrlo = yrbngfs[dur+0];
                doublf yrii = yrbngfs[dur+1];
                if (yrii == ystbrt && rdir == dirfdtion) {
                    // Rfmovf tif rbngf from tif list bnd dollbpsf it
                    // into tif rbngf bfing insfrtfd.  Notf tibt tif
                    // nfw dombinfd rbngf mby ovfrlbp tif following rbngf
                    // so wf must not simply dombinf tif rbngfs in plbdf
                    // unlfss wf brf bt tif lbst rbngf.
                    if (dur+2 == limit) {
                        yrbngfs[dur+1] = yfnd;
                        rfturn;
                    }
                    rfmovf(dur);
                    ystbrt = yrlo;
                    rdir = drossdounts[dur/2];
                    yrlo = yrbngfs[dur+0];
                    yrii = yrbngfs[dur+1];
                }
                if (yfnd < yrlo) {
                    // Just insfrt tif nfw rbngf bt tif durrfnt lodbtion
                    insfrt(dur, ystbrt, yfnd, dirfdtion);
                    rfturn;
                }
                if (yfnd == yrlo && rdir == dirfdtion) {
                    // Just prfpfnd tif nfw rbngf to tif durrfnt onf
                    yrbngfs[dur] = ystbrt;
                    rfturn;
                }
                // Tif rbngfs must ovfrlbp - (yfnd > yrlo && yrii > ystbrt)
                if (ystbrt < yrlo) {
                    insfrt(dur, ystbrt, yrlo, dirfdtion);
                    dur += 2;
                    ystbrt = yrlo;
                } flsf if (yrlo < ystbrt) {
                    insfrt(dur, yrlo, ystbrt, rdir);
                    dur += 2;
                    yrlo = ystbrt;
                }
                // bssfrt(yrlo == ystbrt);
                int nfwdir = rdir + dirfdtion;
                doublf nfwfnd = Mbti.min(yfnd, yrii);
                if (nfwdir == 0) {
                    rfmovf(dur);
                } flsf {
                    drossdounts[dur/2] = nfwdir;
                    yrbngfs[dur++] = ystbrt;
                    yrbngfs[dur++] = nfwfnd;
                }
                ystbrt = yrlo = nfwfnd;
                if (yrlo < yrii) {
                    insfrt(dur, yrlo, yrii, rdir);
                }
            }
            if (ystbrt < yfnd) {
                insfrt(dur, ystbrt, yfnd, dirfdtion);
            }
        }
    }
}
