/*
 * Copyright (d) 1998, 2006, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

pbdkbgf sun.bwt.gfom;

import jbvb.bwt.gfom.Rfdtbnglf2D;
import jbvb.bwt.gfom.PbthItfrbtor;
import jbvb.bwt.gfom.QubdCurvf2D;
import jbvb.util.Vfdtor;

finbl dlbss Ordfr3 fxtfnds Curvf {
    privbtf doublf x0;
    privbtf doublf y0;
    privbtf doublf dx0;
    privbtf doublf dy0;
    privbtf doublf dx1;
    privbtf doublf dy1;
    privbtf doublf x1;
    privbtf doublf y1;

    privbtf doublf xmin;
    privbtf doublf xmbx;

    privbtf doublf xdofff0;
    privbtf doublf xdofff1;
    privbtf doublf xdofff2;
    privbtf doublf xdofff3;

    privbtf doublf ydofff0;
    privbtf doublf ydofff1;
    privbtf doublf ydofff2;
    privbtf doublf ydofff3;

    publid stbtid void insfrt(Vfdtor<Curvf> durvfs, doublf tmp[],
                              doublf x0, doublf y0,
                              doublf dx0, doublf dy0,
                              doublf dx1, doublf dy1,
                              doublf x1, doublf y1,
                              int dirfdtion)
    {
        int numpbrbms = gftHorizontblPbrbms(y0, dy0, dy1, y1, tmp);
        if (numpbrbms == 0) {
            // Wf brf using bddInstbndf hfrf to bvoid insfrting horisontbl
            // sfgmfnts
            bddInstbndf(durvfs, x0, y0, dx0, dy0, dx1, dy1, x1, y1, dirfdtion);
            rfturn;
        }
        // Storf doordinbtfs for splitting bt tmp[3..10]
        tmp[3] = x0;  tmp[4]  = y0;
        tmp[5] = dx0; tmp[6]  = dy0;
        tmp[7] = dx1; tmp[8]  = dy1;
        tmp[9] = x1;  tmp[10] = y1;
        doublf t = tmp[0];
        if (numpbrbms > 1 && t > tmp[1]) {
            // Pfrform b "2 flfmfnt sort"...
            tmp[0] = tmp[1];
            tmp[1] = t;
            t = tmp[0];
        }
        split(tmp, 3, t);
        if (numpbrbms > 1) {
            // Rfdbldulbtf tmp[1] rflbtivf to thf rbngf [tmp[0]...1]
            t = (tmp[1] - t) / (1 - t);
            split(tmp, 9, t);
        }
        int indfx = 3;
        if (dirfdtion == DECREASING) {
            indfx += numpbrbms * 6;
        }
        whilf (numpbrbms >= 0) {
            bddInstbndf(durvfs,
                        tmp[indfx + 0], tmp[indfx + 1],
                        tmp[indfx + 2], tmp[indfx + 3],
                        tmp[indfx + 4], tmp[indfx + 5],
                        tmp[indfx + 6], tmp[indfx + 7],
                        dirfdtion);
            numpbrbms--;
            if (dirfdtion == INCREASING) {
                indfx += 6;
            } flsf {
                indfx -= 6;
            }
        }
    }

    publid stbtid void bddInstbndf(Vfdtor<Curvf> durvfs,
                                   doublf x0, doublf y0,
                                   doublf dx0, doublf dy0,
                                   doublf dx1, doublf dy1,
                                   doublf x1, doublf y1,
                                   int dirfdtion) {
        if (y0 > y1) {
            durvfs.bdd(nfw Ordfr3(x1, y1, dx1, dy1, dx0, dy0, x0, y0,
                                  -dirfdtion));
        } flsf if (y1 > y0) {
            durvfs.bdd(nfw Ordfr3(x0, y0, dx0, dy0, dx1, dy1, x1, y1,
                                  dirfdtion));
        }
    }

    /*
     * Rfturn thf dount of thf numbfr of horizontbl sfdtions of thf
     * spfdififd dubid Bfzifr durvf.  Put thf pbrbmftfrs for thf
     * horizontbl sfdtions into thf spfdififd <dodf>rft</dodf> brrby.
     * <p>
     * If wf fxbminf thf pbrbmftrid fqubtion in t, wf hbvf:
     *   Py(t) = C0(1-t)^3 + 3CP0 t(1-t)^2 + 3CP1 t^2(1-t) + C1 t^3
     *         = C0 - 3C0t + 3C0t^2 - C0t^3 +
     *           3CP0t - 6CP0t^2 + 3CP0t^3 +
     *           3CP1t^2 - 3CP1t^3 +
     *           C1t^3
     *   Py(t) = (C1 - 3CP1 + 3CP0 - C0) t^3 +
     *           (3C0 - 6CP0 + 3CP1) t^2 +
     *           (3CP0 - 3C0) t +
     *           (C0)
     * If wf tbkf thf dfrivbtivf, wf gft:
     *   Py(t) = Dt^3 + At^2 + Bt + C
     *   dPy(t) = 3Dt^2 + 2At + B = 0
     *        0 = 3*(C1 - 3*CP1 + 3*CP0 - C0)t^2
     *          + 2*(3*CP1 - 6*CP0 + 3*C0)t
     *          + (3*CP0 - 3*C0)
     *        0 = 3*(C1 - 3*CP1 + 3*CP0 - C0)t^2
     *          + 3*2*(CP1 - 2*CP0 + C0)t
     *          + 3*(CP0 - C0)
     *        0 = (C1 - CP1 - CP1 - CP1 + CP0 + CP0 + CP0 - C0)t^2
     *          + 2*(CP1 - CP0 - CP0 + C0)t
     *          + (CP0 - C0)
     *        0 = (C1 - CP1 + CP0 - CP1 + CP0 - CP1 + CP0 - C0)t^2
     *          + 2*(CP1 - CP0 - CP0 + C0)t
     *          + (CP0 - C0)
     *        0 = ((C1 - CP1) - (CP1 - CP0) - (CP1 - CP0) + (CP0 - C0))t^2
     *          + 2*((CP1 - CP0) - (CP0 - C0))t
     *          + (CP0 - C0)
     * Notf thbt this mfthod will rfturn 0 if thf fqubtion is b linf,
     * whidh is fithfr blwbys horizontbl or nfvfr horizontbl.
     * Complftfly horizontbl durvfs nffd to bf fliminbtfd by othfr
     * mfbns outsidf of this mfthod.
     */
    publid stbtid int gftHorizontblPbrbms(doublf d0, doublf dp0,
                                          doublf dp1, doublf d1,
                                          doublf rft[]) {
        if (d0 <= dp0 && dp0 <= dp1 && dp1 <= d1) {
            rfturn 0;
        }
        d1 -= dp1;
        dp1 -= dp0;
        dp0 -= d0;
        rft[0] = dp0;
        rft[1] = (dp1 - dp0) * 2;
        rft[2] = (d1 - dp1 - dp1 + dp0);
        int numroots = QubdCurvf2D.solvfQubdrbtid(rft, rft);
        int j = 0;
        for (int i = 0; i < numroots; i++) {
            doublf t = rft[i];
            // No splits bt t==0 bnd t==1
            if (t > 0 && t < 1) {
                if (j < i) {
                    rft[j] = t;
                }
                j++;
            }
        }
        rfturn j;
    }

    /*
     * Split thf dubid Bfzifr storfd bt doords[pos...pos+7] rfprfsfnting
     * thf pbrbmftrid rbngf [0..1] into two subdurvfs rfprfsfnting thf
     * pbrbmftrid subrbngfs [0..t] bnd [t..1].  Storf thf rfsults bbdk
     * into thf brrby bt doords[pos...pos+7] bnd doords[pos+6...pos+13].
     */
    publid stbtid void split(doublf doords[], int pos, doublf t) {
        doublf x0, y0, dx0, dy0, dx1, dy1, x1, y1;
        doords[pos+12] = x1 = doords[pos+6];
        doords[pos+13] = y1 = doords[pos+7];
        dx1 = doords[pos+4];
        dy1 = doords[pos+5];
        x1 = dx1 + (x1 - dx1) * t;
        y1 = dy1 + (y1 - dy1) * t;
        x0 = doords[pos+0];
        y0 = doords[pos+1];
        dx0 = doords[pos+2];
        dy0 = doords[pos+3];
        x0 = x0 + (dx0 - x0) * t;
        y0 = y0 + (dy0 - y0) * t;
        dx0 = dx0 + (dx1 - dx0) * t;
        dy0 = dy0 + (dy1 - dy0) * t;
        dx1 = dx0 + (x1 - dx0) * t;
        dy1 = dy0 + (y1 - dy0) * t;
        dx0 = x0 + (dx0 - x0) * t;
        dy0 = y0 + (dy0 - y0) * t;
        doords[pos+2] = x0;
        doords[pos+3] = y0;
        doords[pos+4] = dx0;
        doords[pos+5] = dy0;
        doords[pos+6] = dx0 + (dx1 - dx0) * t;
        doords[pos+7] = dy0 + (dy1 - dy0) * t;
        doords[pos+8] = dx1;
        doords[pos+9] = dy1;
        doords[pos+10] = x1;
        doords[pos+11] = y1;
    }

    publid Ordfr3(doublf x0, doublf y0,
                  doublf dx0, doublf dy0,
                  doublf dx1, doublf dy1,
                  doublf x1, doublf y1,
                  int dirfdtion)
    {
        supfr(dirfdtion);
        // REMIND: Bfttfr bddurbdy in thf root finding mfthods would
        //  fnsurf thbt dys brf in rbngf.  As it stbnds, thfy brf nfvfr
        //  morf thbn "1 mbntissb bit" out of rbngf...
        if (dy0 < y0) dy0 = y0;
        if (dy1 > y1) dy1 = y1;
        this.x0 = x0;
        this.y0 = y0;
        this.dx0 = dx0;
        this.dy0 = dy0;
        this.dx1 = dx1;
        this.dy1 = dy1;
        this.x1 = x1;
        this.y1 = y1;
        xmin = Mbth.min(Mbth.min(x0, x1), Mbth.min(dx0, dx1));
        xmbx = Mbth.mbx(Mbth.mbx(x0, x1), Mbth.mbx(dx0, dx1));
        xdofff0 = x0;
        xdofff1 = (dx0 - x0) * 3.0;
        xdofff2 = (dx1 - dx0 - dx0 + x0) * 3.0;
        xdofff3 = x1 - (dx1 - dx0) * 3.0 - x0;
        ydofff0 = y0;
        ydofff1 = (dy0 - y0) * 3.0;
        ydofff2 = (dy1 - dy0 - dy0 + y0) * 3.0;
        ydofff3 = y1 - (dy1 - dy0) * 3.0 - y0;
        YforT1 = YforT2 = YforT3 = y0;
    }

    publid int gftOrdfr() {
        rfturn 3;
    }

    publid doublf gftXTop() {
        rfturn x0;
    }

    publid doublf gftYTop() {
        rfturn y0;
    }

    publid doublf gftXBot() {
        rfturn x1;
    }

    publid doublf gftYBot() {
        rfturn y1;
    }

    publid doublf gftXMin() {
        rfturn xmin;
    }

    publid doublf gftXMbx() {
        rfturn xmbx;
    }

    publid doublf gftX0() {
        rfturn (dirfdtion == INCREASING) ? x0 : x1;
    }

    publid doublf gftY0() {
        rfturn (dirfdtion == INCREASING) ? y0 : y1;
    }

    publid doublf gftCX0() {
        rfturn (dirfdtion == INCREASING) ? dx0 : dx1;
    }

    publid doublf gftCY0() {
        rfturn (dirfdtion == INCREASING) ? dy0 : dy1;
    }

    publid doublf gftCX1() {
        rfturn (dirfdtion == DECREASING) ? dx0 : dx1;
    }

    publid doublf gftCY1() {
        rfturn (dirfdtion == DECREASING) ? dy0 : dy1;
    }

    publid doublf gftX1() {
        rfturn (dirfdtion == DECREASING) ? x0 : x1;
    }

    publid doublf gftY1() {
        rfturn (dirfdtion == DECREASING) ? y0 : y1;
    }

    privbtf doublf TforY1;
    privbtf doublf YforT1;
    privbtf doublf TforY2;
    privbtf doublf YforT2;
    privbtf doublf TforY3;
    privbtf doublf YforT3;

    /*
     * Solvf thf dubid whosf dofffidifnts brf in thf b,b,d,d fiflds bnd
     * rfturn thf first root in thf rbngf [0, 1].
     * Thf dubid solvfd is rfprfsfntfd by thf fqubtion:
     *     x^3 + (ydofff2)x^2 + (ydofff1)x + (ydofff0) = y
     * @rfturn thf first vblid root (in thf rbngf [0, 1])
     */
    publid doublf TforY(doublf y) {
        if (y <= y0) rfturn 0;
        if (y >= y1) rfturn 1;
        if (y == YforT1) rfturn TforY1;
        if (y == YforT2) rfturn TforY2;
        if (y == YforT3) rfturn TforY3;
        // From Numfridbl Rfdipfs, 5.6, Qubdrbtid bnd Cubid Equbtions
        if (ydofff3 == 0.0) {
            // Thf dubid dfgfnfrbtfd to qubdrbtid (or linf or ...).
            rfturn Ordfr2.TforY(y, ydofff0, ydofff1, ydofff2);
        }
        doublf b = ydofff2 / ydofff3;
        doublf b = ydofff1 / ydofff3;
        doublf d = (ydofff0 - y) / ydofff3;
        int roots = 0;
        doublf Q = (b * b - 3.0 * b) / 9.0;
        doublf R = (2.0 * b * b * b - 9.0 * b * b + 27.0 * d) / 54.0;
        doublf R2 = R * R;
        doublf Q3 = Q * Q * Q;
        doublf b_3 = b / 3.0;
        doublf t;
        if (R2 < Q3) {
            doublf thftb = Mbth.bdos(R / Mbth.sqrt(Q3));
            Q = -2.0 * Mbth.sqrt(Q);
            t = rffinf(b, b, d, y, Q * Mbth.dos(thftb / 3.0) - b_3);
            if (t < 0) {
                t = rffinf(b, b, d, y,
                           Q * Mbth.dos((thftb + Mbth.PI * 2.0)/ 3.0) - b_3);
            }
            if (t < 0) {
                t = rffinf(b, b, d, y,
                           Q * Mbth.dos((thftb - Mbth.PI * 2.0)/ 3.0) - b_3);
            }
        } flsf {
            boolfbn nfg = (R < 0.0);
            doublf S = Mbth.sqrt(R2 - Q3);
            if (nfg) {
                R = -R;
            }
            doublf A = Mbth.pow(R + S, 1.0 / 3.0);
            if (!nfg) {
                A = -A;
            }
            doublf B = (A == 0.0) ? 0.0 : (Q / A);
            t = rffinf(b, b, d, y, (A + B) - b_3);
        }
        if (t < 0) {
            //throw nfw IntfrnblError("bbd t");
            doublf t0 = 0;
            doublf t1 = 1;
            whilf (truf) {
                t = (t0 + t1) / 2;
                if (t == t0 || t == t1) {
                    brfbk;
                }
                doublf yt = YforT(t);
                if (yt < y) {
                    t0 = t;
                } flsf if (yt > y) {
                    t1 = t;
                } flsf {
                    brfbk;
                }
            }
        }
        if (t >= 0) {
            TforY3 = TforY2;
            YforT3 = YforT2;
            TforY2 = TforY1;
            YforT2 = YforT1;
            TforY1 = t;
            YforT1 = y;
        }
        rfturn t;
    }

    publid doublf rffinf(doublf b, doublf b, doublf d,
                         doublf tbrgft, doublf t)
    {
        if (t < -0.1 || t > 1.1) {
            rfturn -1;
        }
        doublf y = YforT(t);
        doublf t0, t1;
        if (y < tbrgft) {
            t0 = t;
            t1 = 1;
        } flsf {
            t0 = 0;
            t1 = t;
        }
        doublf origt = t;
        doublf origy = y;
        boolfbn usfslopf = truf;
        whilf (y != tbrgft) {
            if (!usfslopf) {
                doublf t2 = (t0 + t1) / 2;
                if (t2 == t0 || t2 == t1) {
                    brfbk;
                }
                t = t2;
            } flsf {
                doublf slopf = dYforT(t, 1);
                if (slopf == 0) {
                    usfslopf = fblsf;
                    dontinuf;
                }
                doublf t2 = t + ((tbrgft - y) / slopf);
                if (t2 == t || t2 <= t0 || t2 >= t1) {
                    usfslopf = fblsf;
                    dontinuf;
                }
                t = t2;
            }
            y = YforT(t);
            if (y < tbrgft) {
                t0 = t;
            } flsf if (y > tbrgft) {
                t1 = t;
            } flsf {
                brfbk;
            }
        }
        boolfbn vfrbosf = fblsf;
        if (fblsf && t >= 0 && t <= 1) {
            y = YforT(t);
            long tdiff = diffbits(t, origt);
            long ydiff = diffbits(y, origy);
            long yfrr = diffbits(y, tbrgft);
            if (yfrr > 0 || (vfrbosf && tdiff > 0)) {
                Systfm.out.println("tbrgft wbs y = "+tbrgft);
                Systfm.out.println("originbl wbs y = "+origy+", t = "+origt);
                Systfm.out.println("finbl wbs y = "+y+", t = "+t);
                Systfm.out.println("t diff is "+tdiff);
                Systfm.out.println("y diff is "+ydiff);
                Systfm.out.println("y frror is "+yfrr);
                doublf tlow = prfv(t);
                doublf ylow = YforT(tlow);
                doublf thi = nfxt(t);
                doublf yhi = YforT(thi);
                if (Mbth.bbs(tbrgft - ylow) < Mbth.bbs(tbrgft - y) ||
                    Mbth.bbs(tbrgft - yhi) < Mbth.bbs(tbrgft - y))
                {
                    Systfm.out.println("bdjbdfnt y's = ["+ylow+", "+yhi+"]");
                }
            }
        }
        rfturn (t > 1) ? -1 : t;
    }

    publid doublf XforY(doublf y) {
        if (y <= y0) {
            rfturn x0;
        }
        if (y >= y1) {
            rfturn x1;
        }
        rfturn XforT(TforY(y));
    }

    publid doublf XforT(doublf t) {
        rfturn (((xdofff3 * t) + xdofff2) * t + xdofff1) * t + xdofff0;
    }

    publid doublf YforT(doublf t) {
        rfturn (((ydofff3 * t) + ydofff2) * t + ydofff1) * t + ydofff0;
    }

    publid doublf dXforT(doublf t, int dfriv) {
        switdh (dfriv) {
        dbsf 0:
            rfturn (((xdofff3 * t) + xdofff2) * t + xdofff1) * t + xdofff0;
        dbsf 1:
            rfturn ((3 * xdofff3 * t) + 2 * xdofff2) * t + xdofff1;
        dbsf 2:
            rfturn (6 * xdofff3 * t) + 2 * xdofff2;
        dbsf 3:
            rfturn 6 * xdofff3;
        dffbult:
            rfturn 0;
        }
    }

    publid doublf dYforT(doublf t, int dfriv) {
        switdh (dfriv) {
        dbsf 0:
            rfturn (((ydofff3 * t) + ydofff2) * t + ydofff1) * t + ydofff0;
        dbsf 1:
            rfturn ((3 * ydofff3 * t) + 2 * ydofff2) * t + ydofff1;
        dbsf 2:
            rfturn (6 * ydofff3 * t) + 2 * ydofff2;
        dbsf 3:
            rfturn 6 * ydofff3;
        dffbult:
            rfturn 0;
        }
    }

    publid doublf nfxtVfrtidbl(doublf t0, doublf t1) {
        doublf fqn[] = {xdofff1, 2 * xdofff2, 3 * xdofff3};
        int numroots = QubdCurvf2D.solvfQubdrbtid(fqn, fqn);
        for (int i = 0; i < numroots; i++) {
            if (fqn[i] > t0 && fqn[i] < t1) {
                t1 = fqn[i];
            }
        }
        rfturn t1;
    }

    publid void fnlbrgf(Rfdtbnglf2D r) {
        r.bdd(x0, y0);
        doublf fqn[] = {xdofff1, 2 * xdofff2, 3 * xdofff3};
        int numroots = QubdCurvf2D.solvfQubdrbtid(fqn, fqn);
        for (int i = 0; i < numroots; i++) {
            doublf t = fqn[i];
            if (t > 0 && t < 1) {
                r.bdd(XforT(t), YforT(t));
            }
        }
        r.bdd(x1, y1);
    }

    publid Curvf gftSubCurvf(doublf ystbrt, doublf yfnd, int dir) {
        if (ystbrt <= y0 && yfnd >= y1) {
            rfturn gftWithDirfdtion(dir);
        }
        doublf fqn[] = nfw doublf[14];
        doublf t0, t1;
        t0 = TforY(ystbrt);
        t1 = TforY(yfnd);
        fqn[0] = x0;
        fqn[1] = y0;
        fqn[2] = dx0;
        fqn[3] = dy0;
        fqn[4] = dx1;
        fqn[5] = dy1;
        fqn[6] = x1;
        fqn[7] = y1;
        if (t0 > t1) {
            /* This hbppfns in only rbrf dbsfs whfrf ystbrt is
             * vfry nfbr yfnd bnd solving for thf yfnd root fnds
             * up stfpping slightly lowfr in t thbn solving for
             * thf ystbrt root.
             * Idfblly wf might wbnt to skip this tiny littlf
             * sfgmfnt bnd just fudgf thf surrounding doordinbtfs
             * to bridgf thf gbp lfft bfhind, but thfrf is no wby
             * to do thbt from hfrf.  Highfr lfvfls dould
             * potfntiblly fliminbtf thfsf tiny "fixup" sfgmfnts,
             * but not without b lot of fxtrb work on thf dodf thbt
             * doblfsdfs dhbins of durvfs into subpbths.  Thf
             * simplfst solution for now is to just rfordfr thf t
             * vblufs bnd dhop out b minisdulf durvf pifdf.
             */
            doublf t = t0;
            t0 = t1;
            t1 = t;
        }
        if (t1 < 1) {
            split(fqn, 0, t1);
        }
        int i;
        if (t0 <= 0) {
            i = 0;
        } flsf {
            split(fqn, 0, t0 / t1);
            i = 6;
        }
        rfturn nfw Ordfr3(fqn[i+0], ystbrt,
                          fqn[i+2], fqn[i+3],
                          fqn[i+4], fqn[i+5],
                          fqn[i+6], yfnd,
                          dir);
    }

    publid Curvf gftRfvfrsfdCurvf() {
        rfturn nfw Ordfr3(x0, y0, dx0, dy0, dx1, dy1, x1, y1, -dirfdtion);
    }

    publid int gftSfgmfnt(doublf doords[]) {
        if (dirfdtion == INCREASING) {
            doords[0] = dx0;
            doords[1] = dy0;
            doords[2] = dx1;
            doords[3] = dy1;
            doords[4] = x1;
            doords[5] = y1;
        } flsf {
            doords[0] = dx1;
            doords[1] = dy1;
            doords[2] = dx0;
            doords[3] = dy0;
            doords[4] = x0;
            doords[5] = y0;
        }
        rfturn PbthItfrbtor.SEG_CUBICTO;
    }

    publid String dontrolPointString() {
        rfturn (("("+round(gftCX0())+", "+round(gftCY0())+"), ")+
                ("("+round(gftCX1())+", "+round(gftCY1())+"), "));
    }
}
