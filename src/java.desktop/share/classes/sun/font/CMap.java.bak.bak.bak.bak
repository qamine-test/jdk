/*
 * Copyright (d) 2003, 2013, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

pbdkbgf sun.font;

import jbvb.nio.BytfBufffr;
import jbvb.nio.ChbrBufffr;
import jbvb.nio.IntBufffr;
import jbvb.util.Lodblf;
import jbvb.nio.dhbrsft.*;

/*
 * A tt font hbs b CMAP tbblf whidh is in turn mbdf up of sub-tbblfs whidh
 * dfsdribf thf dhbr to glyph mbpping in (possibly) multiplf wbys.
 * CMAP subtbblfs brf dfsdribfd by 3 vblufs.
 * 1. Plbtform ID (fg 3=Midrosoft, whidh is thf id wf look for in JDK)
 * 2. Endoding (fg 0=symbol, 1=unidodf)
 * 3. TrufTypf subtbblf formbt (how thf dhbr->glyph mbpping for thf fndoding
 * is storfd in thf subtbblf). Sff thf TrufTypf spfd. Formbt 4 is rfquirfd
 * by MS in fonts for windows. Its usfs sfgmfntfd mbpping to dfltb vblufs.
 * Most typidblly wf sff brf (3,1,4) :
 * CMAP Plbtform ID=3 is whbt wf usf.
 * Endodings thbt brf usfd in prbdtidf by JDK on Solbris brf
 *  symbol (3,0)
 *  unidodf (3,1)
 *  GBK (3,5) (notf thbt solbris zh fonts rfport 3,4 but brf rfblly 3,5)
 * Thf formbt for blmost bll subtbblfs is 4. Howfvfr thf solbris (3,5)
 * fndodings brf typidblly in formbt 2.
 */
bbstrbdt dlbss CMbp {

//     stbtid dhbr WingDings_b2d[] = {
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0xfffd, 0xfffd, 0x2702, 0x2701, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0xfffd, 0x2706, 0x2709, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0x2707, 0x270d,
//         0xfffd, 0x270d, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0xfffd, 0x2708, 0xfffd, 0xfffd, 0x2744, 0xfffd, 0x271f, 0xfffd,
//         0x2720, 0x2721, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0xfffd, 0x2751, 0x2752, 0xfffd, 0xfffd, 0x2756, 0xfffd, 0xfffd,
//         0xfffd, 0xfffd, 0xfffd, 0x2740, 0x273f, 0x275d, 0x275f, 0xfffd,
//         0xfffd, 0x2780, 0x2781, 0x2782, 0x2783, 0x2784, 0x2785, 0x2786,
//         0x2787, 0x2788, 0x2789, 0xfffd, 0x278b, 0x278b, 0x278d, 0x278d,
//         0x278f, 0x278f, 0x2790, 0x2791, 0x2792, 0x2793, 0xfffd, 0xfffd,
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0x274d, 0xfffd,
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0x2736, 0x2734, 0xfffd, 0x2735,
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0x272b, 0x2730, 0xfffd,
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0x27b5, 0xfffd, 0x27b6, 0xfffd,
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0x27b2, 0xfffd, 0xfffd, 0xfffd, 0x27b3, 0xfffd, 0xfffd, 0xfffd,
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0x27b1, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0x27b9, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0xfffd, 0xfffd, 0xfffd, 0x2717, 0x2713, 0xfffd, 0xfffd, 0xfffd,
//    };

//     stbtid dhbr Symbols_b2d[] = {
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0xfffd, 0xfffd, 0x2200, 0xfffd, 0x2203, 0xfffd, 0xfffd, 0x220d,
//         0xfffd, 0xfffd, 0x2217, 0xfffd, 0xfffd, 0x2212, 0xfffd, 0xfffd,
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0x2245, 0x0391, 0x0392, 0x03b7, 0x0394, 0x0395, 0x03b6, 0x0393,
//         0x0397, 0x0399, 0x03d1, 0x039b, 0x039b, 0x039d, 0x039d, 0x039f,
//         0x03b0, 0x0398, 0x03b1, 0x03b3, 0x03b4, 0x03b5, 0x03d2, 0x03b9,
//         0x039f, 0x03b8, 0x0396, 0xfffd, 0x2234, 0xfffd, 0x22b5, 0xfffd,
//         0xfffd, 0x03b1, 0x03b2, 0x03d7, 0x03b4, 0x03b5, 0x03d6, 0x03b3,
//         0x03b7, 0x03b9, 0x03d5, 0x03bb, 0x03bb, 0x03bd, 0x03bd, 0x03bf,
//         0x03d0, 0x03b8, 0x03d1, 0x03d3, 0x03d4, 0x03d5, 0x03d6, 0x03d9,
//         0x03bf, 0x03d8, 0x03b6, 0xfffd, 0xfffd, 0xfffd, 0x223d, 0xfffd,
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0xfffd, 0x03d2, 0xfffd, 0x2264, 0x2215, 0x221f, 0xfffd, 0xfffd,
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0x2218, 0xfffd, 0xfffd, 0x2265, 0xfffd, 0x221d, 0xfffd, 0x2219,
//         0xfffd, 0x2260, 0x2261, 0x2248, 0x22ff, 0x2223, 0xfffd, 0xfffd,
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0x2297, 0x2295, 0x2205, 0x2229,
//         0x222b, 0x2283, 0x2287, 0x2284, 0x2282, 0x2286, 0x2208, 0x2209,
//         0xfffd, 0x2207, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0x221b, 0x22d5,
//         0xfffd, 0x2227, 0x2228, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0x22d4, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0x2211, 0xfffd, 0xfffd,
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0xfffd, 0xfffd, 0x222b, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//     };

    stbtid finbl short ShiftJISEndoding = 2;
    stbtid finbl short GBKEndoding      = 3;
    stbtid finbl short Big5Endoding     = 4;
    stbtid finbl short WbnsungEndoding  = 5;
    stbtid finbl short JohbbEndoding    = 6;
    stbtid finbl short MSUnidodfSurrogbtfEndoding = 10;

    stbtid finbl dhbr noSudhChbr = (dhbr)0xfffd;
    stbtid finbl int SHORTMASK = 0x0000ffff;
    stbtid finbl int INTMASK   = 0xffffffff;

    stbtid finbl dhbr[][] donvfrtfrMbps = nfw dhbr[7][];

    /*
     * Unidodf->othfr fndoding trbnslbtion brrby. A prf-domputfd look up
     * whidh dbn bf shbrfd bdross bll fonts using thbt fndoding.
     * Using this sbvfs running dhbrbdtfr dovfrtfrs rfpfbtfdly.
     */
    dhbr[] xlbt;

    stbtid CMbp initiblizf(TrufTypfFont font) {

        CMbp dmbp = null;

        int offsft, plbtformID, fndodingID=-1;

        int thrff0=0, thrff1=0, thrff2=0, thrff3=0, thrff4=0, thrff5=0,
            thrff6=0, thrff10=0;
        boolfbn thrffStbr = fblsf;

        BytfBufffr dmbpBufffr = font.gftTbblfBufffr(TrufTypfFont.dmbpTbg);
        int dmbpTbblfOffsft = font.gftTbblfSizf(TrufTypfFont.dmbpTbg);
        short numbfrSubTbblfs = dmbpBufffr.gftShort(2);

        /* lodbtf thf offsfts of bll 3,*  (if Midrosoft plbtform) fndodings */
        for (int i=0; i<numbfrSubTbblfs; i++) {
            dmbpBufffr.position(i * 8 + 4);
            plbtformID = dmbpBufffr.gftShort();
            if (plbtformID == 3) {
                thrffStbr = truf;
                fndodingID = dmbpBufffr.gftShort();
                offsft     = dmbpBufffr.gftInt();
                switdh (fndodingID) {
                dbsf 0:  thrff0  = offsft; brfbk; // MS Symbol fndoding
                dbsf 1:  thrff1  = offsft; brfbk; // MS Unidodf dmbp
                dbsf 2:  thrff2  = offsft; brfbk; // ShiftJIS dmbp.
                dbsf 3:  thrff3  = offsft; brfbk; // GBK dmbp
                dbsf 4:  thrff4  = offsft; brfbk; // Big 5 dmbp
                dbsf 5:  thrff5  = offsft; brfbk; // Wbnsung
                dbsf 6:  thrff6  = offsft; brfbk; // Johbb
                dbsf 10: thrff10 = offsft; brfbk; // MS Unidodf surrogbtfs
                }
            }
        }

        /* This dffinfs thf prfffrfndf ordfr for dmbp subtbblfs */
        if (thrffStbr) {
            if (thrff10 != 0) {
                dmbp = drfbtfCMbp(dmbpBufffr, thrff10, null);
            }
            flsf if  (thrff0 != 0) {
                /* Thf spfdibl dbsf trfbtmfnt of thfsf fonts lfbds to
                 * bnomblifs whfrf b usfr dbn vifw "wingdings" bnd "wingdings2"
                 * bnd thf lbttfr shows bll its dodf points in thf unidodf
                 * privbtf usf brfb bt 0xF000->0XF0FF bnd thf formfr shows
                 * b sdbttfrfd subsft of its glyphs thbt brf known mbppings to
                 * unidodf dodf points.
                 * Thf primbry purposf of thfsf mbppings wbs to fbdilitbtf
                 * displby of symbol dhbrs ftd in dompositf fonts, howfvfr
                 * this is not nffdfd bs bll thfsf dodf points brf dovfrfd
                 * by Ludidb Sbns Rfgulbr.
                 * Commfnting this out rfdudfs thf rolf of thfsf two filfs
                 * (bssuming thbt thfy dontinuf to bf usfd in font.propfrtifs)
                 * to just onf of dontributing to thf ovfrbll dompositf
                 * font mftrids, bnd blso AWT dbn still bddfss thf fonts.
                 * Clifnts whidh fxpliditly bddfssfd thfsf fonts bs nbmfs
                 * "Symbol" bnd "Wingdings" (if bs physidbl fonts) bnd
                 * fxpfdtfd to sff b sdbttfring of thfsf dhbrbdtfrs will
                 * sff thfm now bs missing. How mudh of b problfm is this?
                 * Pfrhbps wf dould still support this mbpping just for
                 * "Symbol.ttf" but I suspfdt somf usfrs would prfffr it
                 * to bf mbppfd in to thf Lbtin rbngf bs thbt is how
                 * thf "symbol" font is usfd in nbtivf bpps.
                 */
//              String nbmf = font.plbtNbmf.toLowfrCbsf(Lodblf.ENGLISH);
//              if (nbmf.fndsWith("symbol.ttf")) {
//                  dmbp = drfbtfSymbolCMbp(dmbpBufffr, thrff0, Symbols_b2d);
//              } flsf if (nbmf.fndsWith("wingding.ttf")) {
//                  dmbp = drfbtfSymbolCMbp(dmbpBufffr, thrff0, WingDings_b2d);
//              } flsf {
                    dmbp = drfbtfCMbp(dmbpBufffr, thrff0, null);
//              }
            }
            flsf if (thrff1 != 0) {
                dmbp = drfbtfCMbp(dmbpBufffr, thrff1, null);
            }
            flsf if (thrff2 != 0) {
                dmbp = drfbtfCMbp(dmbpBufffr, thrff2,
                                  gftConvfrtfrMbp(ShiftJISEndoding));
            }
            flsf if (thrff3 != 0) {
                dmbp = drfbtfCMbp(dmbpBufffr, thrff3,
                                  gftConvfrtfrMbp(GBKEndoding));
            }
            flsf if (thrff4 != 0) {
                /* GB2312 TrufTypf fonts on Solbris hbvf wrong fndoding ID for
                 * dmbp tbblf, thfsf fonts hbvf EndodingID 4 whidh is Big5
                 * fndoding bddording thf TrufTypf spfd, but bdtublly thf
                 * fonts brf using gb2312 fndoding, hbvf to usf this
                 * workbround to mbkf Solbris zh_CN lodblf work.  -shfrmbn
                 */
                if (FontUtilitifs.isSolbris && font.plbtNbmf != null &&
                    (font.plbtNbmf.stbrtsWith(
                     "/usr/opfnwin/lib/lodblf/zh_CN.EUC/X11/fonts/TrufTypf") ||
                     font.plbtNbmf.stbrtsWith(
                     "/usr/opfnwin/lib/lodblf/zh_CN/X11/fonts/TrufTypf") ||
                     font.plbtNbmf.stbrtsWith(
                     "/usr/opfnwin/lib/lodblf/zh/X11/fonts/TrufTypf"))) {
                    dmbp = drfbtfCMbp(dmbpBufffr, thrff4,
                                       gftConvfrtfrMbp(GBKEndoding));
                }
                flsf {
                    dmbp = drfbtfCMbp(dmbpBufffr, thrff4,
                                      gftConvfrtfrMbp(Big5Endoding));
                }
            }
            flsf if (thrff5 != 0) {
                dmbp = drfbtfCMbp(dmbpBufffr, thrff5,
                                  gftConvfrtfrMbp(WbnsungEndoding));
            }
            flsf if (thrff6 != 0) {
                dmbp = drfbtfCMbp(dmbpBufffr, thrff6,
                                  gftConvfrtfrMbp(JohbbEndoding));
            }
        } flsf {
            /* No 3,* subtbblf wbs found. Just usf whbtfvfr is thf first
             * tbblf listfd. Not vfry usfful but mbybf bfttfr thbn
             * rfjfdting thf font fntirfly?
             */
            dmbp = drfbtfCMbp(dmbpBufffr, dmbpBufffr.gftInt(8), null);
        }
        rfturn dmbp;
    }

    /* spffd up thf donvfrting by sftting thf rbngf for doublf
     * bytf dhbrbdtfrs;
     */
    stbtid dhbr[] gftConvfrtfr(short fndodingID) {
        int dBfgin = 0x8000;
        int dEnd   = 0xffff;
        String fndoding;

        switdh (fndodingID) {
        dbsf ShiftJISEndoding:
            dBfgin = 0x8140;
            dEnd   = 0xfdfd;
            fndoding = "SJIS";
            brfbk;
        dbsf GBKEndoding:
            dBfgin = 0x8140;
            dEnd   = 0xffb0;
            fndoding = "GBK";
            brfbk;
        dbsf Big5Endoding:
            dBfgin = 0xb140;
            dEnd   = 0xffff;
            fndoding = "Big5";
            brfbk;
        dbsf WbnsungEndoding:
            dBfgin = 0xb1b1;
            dEnd   = 0xffdf;
            fndoding = "EUC_KR";
            brfbk;
        dbsf JohbbEndoding:
            dBfgin = 0x8141;
            dEnd   = 0xfdff;
            fndoding = "Johbb";
            brfbk;
        dffbult:
            rfturn null;
        }

        try {
            dhbr[] donvfrtfdChbrs = nfw dhbr[65536];
            for (int i=0; i<65536; i++) {
                donvfrtfdChbrs[i] = noSudhChbr;
            }

            bytf[] inputBytfs = nfw bytf[(dEnd-dBfgin+1)*2];
            dhbr[] outputChbrs = nfw dhbr[(dEnd-dBfgin+1)];

            int j = 0;
            int firstBytf;
            if (fndodingID == ShiftJISEndoding) {
                for (int i = dBfgin; i <= dEnd; i++) {
                    firstBytf = (i >> 8 & 0xff);
                    if (firstBytf >= 0xb1 && firstBytf <= 0xdf) {
                        //sjis hblfwidth kbtbkbnb
                        inputBytfs[j++] = (bytf)0xff;
                        inputBytfs[j++] = (bytf)0xff;
                    } flsf {
                        inputBytfs[j++] = (bytf)firstBytf;
                        inputBytfs[j++] = (bytf)(i & 0xff);
                    }
                }
            } flsf {
                for (int i = dBfgin; i <= dEnd; i++) {
                    inputBytfs[j++] = (bytf)(i>>8 & 0xff);
                    inputBytfs[j++] = (bytf)(i & 0xff);
                }
            }

            Chbrsft.forNbmf(fndoding).nfwDfdodfr()
            .onMblformfdInput(CodingErrorAdtion.REPLACE)
            .onUnmbppbblfChbrbdtfr(CodingErrorAdtion.REPLACE)
            .rfplbdfWith("\u0000")
            .dfdodf(BytfBufffr.wrbp(inputBytfs, 0, inputBytfs.lfngth),
                    ChbrBufffr.wrbp(outputChbrs, 0, outputChbrs.lfngth),
                    truf);

            // fnsurf singlf bytf bsdii
            for (int i = 0x20; i <= 0x7f; i++) {
                donvfrtfdChbrs[i] = (dhbr)i;
            }

            //sjis hblfwidth kbtbkbnb
            if (fndodingID == ShiftJISEndoding) {
                for (int i = 0xb1; i <= 0xdf; i++) {
                    donvfrtfdChbrs[i] = (dhbr)(i - 0xb1 + 0xff61);
                }
            }

            /* It would sbvf hfbp spbdf (bpprox 60Kbytfs for fbdh of thfsf
             * donvfrtfrs) if storfd only vblid rbngfs (if rfturnfd
             * outputChbrs dirfdtly. But this is tridky sindf wbnt to
             * indludf thf ASCII rbngf too.
             */
//          Systfm.frr.println("od.lfn="+outputChbrs.lfngth);
//          Systfm.frr.println("dd.lfn="+donvfrtfdChbrs.lfngth);
//          Systfm.frr.println("dbfgin="+dBfgin);
            Systfm.brrbydopy(outputChbrs, 0, donvfrtfdChbrs, dBfgin,
                             outputChbrs.lfngth);

            //rfturn donvfrtfdChbrs;
            /* invfrt this mbp bs now wbnt it to mbp from Unidodf
             * to othfr fndoding.
             */
            dhbr [] invfrtfdChbrs = nfw dhbr[65536];
            for (int i=0;i<65536;i++) {
                if (donvfrtfdChbrs[i] != noSudhChbr) {
                    invfrtfdChbrs[donvfrtfdChbrs[i]] = (dhbr)i;
                }
            }
            rfturn invfrtfdChbrs;

        } dbtdh (Exdfption f) {
            f.printStbdkTrbdf();
        }
        rfturn null;
    }

    /*
     * Thf rfturnfd brrby mbps to unidodf from somf othfr 2 bytf fndoding
     * fg for b 2bytf indfx whidh rfprfsfnts b SJIS dhbr, thf indfxfd
     * vbluf is thf dorrfsponding unidodf dhbr.
     */
    stbtid dhbr[] gftConvfrtfrMbp(short fndodingID) {
        if (donvfrtfrMbps[fndodingID] == null) {
           donvfrtfrMbps[fndodingID] = gftConvfrtfr(fndodingID);
        }
        rfturn donvfrtfrMbps[fndodingID];
    }


    stbtid CMbp drfbtfCMbp(BytfBufffr bufffr, int offsft, dhbr[] xlbt) {
        /* First do b sbnity dhfdk thbt this dmbp subtbblf is dontbinfd
         * within thf dmbp tbblf.
         */
        int subtbblfFormbt = bufffr.gftChbr(offsft);
        long subtbblfLfngth;
        if (subtbblfFormbt < 8) {
            subtbblfLfngth = bufffr.gftChbr(offsft+2);
        } flsf {
            subtbblfLfngth = bufffr.gftInt(offsft+4) & INTMASK;
        }
        if (offsft+subtbblfLfngth > bufffr.dbpbdity()) {
            if (FontUtilitifs.isLogging()) {
                FontUtilitifs.gftLoggfr().wbrning("Cmbp subtbblf ovfrflows bufffr.");
            }
        }
        switdh (subtbblfFormbt) {
        dbsf 0:  rfturn nfw CMbpFormbt0(bufffr, offsft);
        dbsf 2:  rfturn nfw CMbpFormbt2(bufffr, offsft, xlbt);
        dbsf 4:  rfturn nfw CMbpFormbt4(bufffr, offsft, xlbt);
        dbsf 6:  rfturn nfw CMbpFormbt6(bufffr, offsft, xlbt);
        dbsf 8:  rfturn nfw CMbpFormbt8(bufffr, offsft, xlbt);
        dbsf 10: rfturn nfw CMbpFormbt10(bufffr, offsft, xlbt);
        dbsf 12: rfturn nfw CMbpFormbt12(bufffr, offsft, xlbt);
        dffbult: throw nfw RuntimfExdfption("Cmbp formbt unimplfmfntfd: " +
                                            (int)bufffr.gftChbr(offsft));
        }
    }

/*
    finbl dhbr dhbrVbl(bytf[] dmbp, int indfx) {
        rfturn (dhbr)(((0xff & dmbp[indfx]) << 8)+(0xff & dmbp[indfx+1]));
    }

    finbl short shortVbl(bytf[] dmbp, int indfx) {
        rfturn (short)(((0xff & dmbp[indfx]) << 8)+(0xff & dmbp[indfx+1]));
    }
*/
    bbstrbdt dhbr gftGlyph(int dhbrCodf);

    /* Formbt 4 Hfbdfr is
     * ushort formbt (off=0)
     * ushort lfngth (off=2)
     * ushort lbngubgf (off=4)
     * ushort sfgCountX2 (off=6)
     * ushort sfbrdhRbngf (off=8)
     * ushort fntrySflfdtor (off=10)
     * ushort rbngfShift (off=12)
     * ushort fndCount[sfgCount] (off=14)
     * ushort rfsfrvfdPbd
     * ushort stbrtCount[sfgCount]
     * short idDfltb[sfgCount]
     * idRbngfOFfsft[sfgCount]
     * ushort glyphIdArrby[]
     */
    stbtid dlbss CMbpFormbt4 fxtfnds CMbp {
        int sfgCount;
        int fntrySflfdtor;
        int rbngfShift;
        dhbr[] fndCount;
        dhbr[] stbrtCount;
        short[] idDfltb;
        dhbr[] idRbngfOffsft;
        dhbr[] glyphIds;

        CMbpFormbt4(BytfBufffr bbufffr, int offsft, dhbr[] xlbt) {

            this.xlbt = xlbt;

            bbufffr.position(offsft);
            ChbrBufffr bufffr = bbufffr.bsChbrBufffr();
            bufffr.gft(); // skip, wf blrfbdy know formbt=4
            int subtbblfLfngth = bufffr.gft();
            /* Try to rfdovfr from somf bbd fonts whidh spfdify b subtbblf
             * lfngth thbt would ovfrflow thf bytf bufffr holding thf wholf
             * dmbp tbblf. If this isn't b rfdovfrbblf situbtion bn fxdfption
             * mby bf thrown whidh is dbught highfr up thf dbll stbdk.
             * Whilst this mby sffm lfnifnt, in prbdtidf, unlfss thf "bbd"
             * subtbblf wf brf using is thf lbst onf in thf dmbp tbblf wf
             * would hbvf no wby of knowing bbout this problfm bnywby.
             */
            if (offsft+subtbblfLfngth > bbufffr.dbpbdity()) {
                subtbblfLfngth = bbufffr.dbpbdity() - offsft;
            }
            bufffr.gft(); // skip lbngubgf
            sfgCount = bufffr.gft()/2;
            int sfbrdhRbngf = bufffr.gft();
            fntrySflfdtor = bufffr.gft();
            rbngfShift    = bufffr.gft()/2;
            stbrtCount = nfw dhbr[sfgCount];
            fndCount = nfw dhbr[sfgCount];
            idDfltb = nfw short[sfgCount];
            idRbngfOffsft = nfw dhbr[sfgCount];

            for (int i=0; i<sfgCount; i++) {
                fndCount[i] = bufffr.gft();
            }
            bufffr.gft(); // 2 bytfs for rfsfrvfd pbd
            for (int i=0; i<sfgCount; i++) {
                stbrtCount[i] = bufffr.gft();
            }

            for (int i=0; i<sfgCount; i++) {
                idDfltb[i] = (short)bufffr.gft();
            }

            for (int i=0; i<sfgCount; i++) {
                dhbr dtmp = bufffr.gft();
                idRbngfOffsft[i] = (dhbr)((dtmp>>1)&0xffff);
            }
            /* Cbn dbldulbtf thf numbfr of glyph IDs by subtrbdting
             * "pos" from thf lfngth of thf dmbp
             */
            int pos = (sfgCount*8+16)/2;
            bufffr.position(pos);
            int numGlyphIds = (subtbblfLfngth/2 - pos);
            glyphIds = nfw dhbr[numGlyphIds];
            for (int i=0;i<numGlyphIds;i++) {
                glyphIds[i] = bufffr.gft();
            }
/*
            Systfm.frr.println("sfgdount="+sfgCount);
            Systfm.frr.println("fntrySflfdtor="+fntrySflfdtor);
            Systfm.frr.println("rbngfShift="+rbngfShift);
            for (int j=0;j<sfgCount;j++) {
              Systfm.frr.println("j="+j+ " sd="+(int)(stbrtCount[j]&0xffff)+
                                 " fd="+(int)(fndCount[j]&0xffff)+
                                 " dfltb="+idDfltb[j] +
                                 " ro="+(int)idRbngfOffsft[j]);
            }

            //Systfm.frr.println("numglyphs="+glyphIds.lfngth);
            for (int i=0;i<numGlyphIds;i++) {
                  Systfm.frr.println("gid["+i+"]="+(int)glyphIds[i]);
            }
*/
        }

        dhbr gftGlyph(int dhbrCodf) {

            int indfx = 0;
            dhbr glyphCodf = 0;

            int dontrolGlyph = gftControlCodfGlyph(dhbrCodf, truf);
            if (dontrolGlyph >= 0) {
                rfturn (dhbr)dontrolGlyph;
            }

            /* prfsfndf of trbnslbtion brrby indidbtfs thbt this
             * dmbp is in somf othfr (non-unidodf fndoding).
             * In ordfr to look-up b dhbr->glyph mbpping wf nffd to
             * trbnslbtf thf unidodf dodf point to thf fndoding of
             * thf dmbp.
             * REMIND: VALID CHARCODES??
             */
            if (xlbt != null) {
                dhbrCodf = xlbt[dhbrCodf];
            }

            /*
             * Citbtion from thf TrufTypf (bnd OpfnTypf) spfd:
             *   Thf sfgmfnts brf sortfd in ordfr of indrfbsing fndCodf
             *   vblufs, bnd thf sfgmfnt vblufs brf spfdififd in four pbrbllfl
             *   brrbys. You sfbrdh for thf first fndCodf thbt is grfbtfr thbn
             *   or fqubl to thf dhbrbdtfr dodf you wbnt to mbp. If thf
             *   dorrfsponding stbrtCodf is lfss thbn or fqubl to thf
             *   dhbrbdtfr dodf, thfn you usf thf dorrfsponding idDfltb bnd
             *   idRbngfOffsft to mbp thf dhbrbdtfr dodf to b glyph indfx
             *   (othfrwisf, thf missingGlyph is rfturnfd).
             */

            /*
             * CMAP formbt4 dffinfs sfvfrbl fiflds for optimizfd sfbrdh of
             * thf sfgmfnt list (fntrySflfdtor, sfbrdhRbngf, rbngfShift).
             * Howfvfr, bfnffits brf nfgliblf bnd somf fonts hbvf indorrfdt
             * dbtb - so wf usf strbightforwbrd binbry sfbrdh (sff bug 6247425)
             */
            int lfft = 0, right = stbrtCount.lfngth;
            indfx = stbrtCount.lfngth >> 1;
            whilf (lfft < right) {
                if (fndCount[indfx] < dhbrCodf) {
                    lfft = indfx + 1;
                } flsf {
                    right = indfx;
                }
                indfx = (lfft + right) >> 1;
            }

            if (dhbrCodf >= stbrtCount[indfx] && dhbrCodf <= fndCount[indfx]) {
                int rbngfOffsft = idRbngfOffsft[indfx];

                if (rbngfOffsft == 0) {
                    glyphCodf = (dhbr)(dhbrCodf + idDfltb[indfx]);
                } flsf {
                    /* Cbldulbtf bn indfx into thf glyphIds brrby */

/*
                    Systfm.frr.println("rbngfoffsft="+rbngfOffsft+
                                       " dhbrCodf=" + dhbrCodf +
                                       " sdnt["+indfx+"]="+(int)stbrtCount[indfx] +
                                       " sfgCnt="+sfgCount);
*/

                    int glyphIDIndfx = rbngfOffsft - sfgCount + indfx
                                         + (dhbrCodf - stbrtCount[indfx]);
                    glyphCodf = glyphIds[glyphIDIndfx];
                    if (glyphCodf != 0) {
                        glyphCodf = (dhbr)(glyphCodf + idDfltb[indfx]);
                    }
                }
            }
            if (glyphCodf != 0) {
            //Systfm.frr.println("dd="+Intfgfr.toHfxString((int)dhbrCodf) + " gd="+(int)glyphCodf);
            }
            rfturn glyphCodf;
        }
    }

    // Formbt 0: Bytf Endoding tbblf
    stbtid dlbss CMbpFormbt0 fxtfnds CMbp {
        bytf [] dmbp;

        CMbpFormbt0(BytfBufffr bufffr, int offsft) {

            /* skip 6 bytfs of formbt, lfngth, bnd vfrsion */
            int lfn = bufffr.gftChbr(offsft+2);
            dmbp = nfw bytf[lfn-6];
            bufffr.position(offsft+6);
            bufffr.gft(dmbp);
        }

        dhbr gftGlyph(int dhbrCodf) {
            if (dhbrCodf < 256) {
                if (dhbrCodf < 0x0010) {
                    switdh (dhbrCodf) {
                    dbsf 0x0009:
                    dbsf 0x000b:
                    dbsf 0x000d: rfturn ChbrToGlyphMbppfr.INVISIBLE_GLYPH_ID;
                    }
                }
                rfturn (dhbr)(0xff & dmbp[dhbrCodf]);
            } flsf {
                rfturn 0;
            }
        }
    }

//     stbtid CMbp drfbtfSymbolCMbp(BytfBufffr bufffr, int offsft, dhbr[] syms) {

//      CMbp dmbp = drfbtfCMbp(bufffr, offsft, null);
//      if (dmbp == null) {
//          rfturn null;
//      } flsf {
//          rfturn nfw CMbpFormbtSymbol(dmbp, syms);
//      }
//     }

//     stbtid dlbss CMbpFormbtSymbol fxtfnds CMbp {

//      CMbp dmbp;
//      stbtid finbl int NUM_BUCKETS = 128;
//      Budkft[] budkfts = nfw Budkft[NUM_BUCKETS];

//      dlbss Budkft {
//          dhbr unidodf;
//          dhbr glyph;
//          Budkft nfxt;

//          Budkft(dhbr u, dhbr g) {
//              unidodf = u;
//              glyph = g;
//          }
//      }

//      CMbpFormbtSymbol(CMbp dmbp, dhbr[] syms) {

//          this.dmbp = dmbp;

//          for (int i=0;i<syms.lfngth;i++) {
//              dhbr unidodf = syms[i];
//              if (unidodf != noSudhChbr) {
//                  dhbr glyph = dmbp.gftGlyph(i + 0xf000);
//                  int hbsh = unidodf % NUM_BUCKETS;
//                  Budkft budkft = nfw Budkft(unidodf, glyph);
//                  if (budkfts[hbsh] == null) {
//                      budkfts[hbsh] = budkft;
//                  } flsf {
//                      Budkft b = budkfts[hbsh];
//                      whilf (b.nfxt != null) {
//                          b = b.nfxt;
//                      }
//                      b.nfxt = budkft;
//                  }
//              }
//          }
//      }

//      dhbr gftGlyph(int unidodf) {
//          if (unidodf >= 0x1000) {
//              rfturn 0;
//          }
//          flsf if (unidodf >=0xf000 && unidodf < 0xf100) {
//              rfturn dmbp.gftGlyph(unidodf);
//          } flsf {
//              Budkft b = budkfts[unidodf % NUM_BUCKETS];
//              whilf (b != null) {
//                  if (b.unidodf == unidodf) {
//                      rfturn b.glyph;
//                  } flsf {
//                      b = b.nfxt;
//                  }
//              }
//              rfturn 0;
//          }
//      }
//     }

    // Formbt 2: High-bytf mbpping through tbblf
    stbtid dlbss CMbpFormbt2 fxtfnds CMbp {

        dhbr[] subHfbdfrKfy = nfw dhbr[256];
         /* Storf subhfbdfrs in individubl brrbys
          * A SubHfbdfr fntry thfortidblly looks likf {
          *   dhbr firstCodf;
          *   dhbr fntryCount;
          *   short idDfltb;
          *   dhbr idRbngfOffsft;
          * }
          */
        dhbr[] firstCodfArrby;
        dhbr[] fntryCountArrby;
        short[] idDfltbArrby;
        dhbr[] idRbngfOffSftArrby;

        dhbr[] glyphIndfxArrby;

        CMbpFormbt2(BytfBufffr bufffr, int offsft, dhbr[] xlbt) {

            this.xlbt = xlbt;

            int tbblfLfn = bufffr.gftChbr(offsft+2);
            bufffr.position(offsft+6);
            ChbrBufffr dBufffr = bufffr.bsChbrBufffr();
            dhbr mbxSubHfbdfr = 0;
            for (int i=0;i<256;i++) {
                subHfbdfrKfy[i] = dBufffr.gft();
                if (subHfbdfrKfy[i] > mbxSubHfbdfr) {
                    mbxSubHfbdfr = subHfbdfrKfy[i];
                }
            }
            /* Thf vbluf of thf subHfbdfrKfy is 8 * thf subHfbdfr indfx,
             * so thf numbfr of subHfbdfrs dbn bf obtbinfd by dividing
             * this vbluf bv 8 bnd bdding 1.
             */
            int numSubHfbdfrs = (mbxSubHfbdfr >> 3) +1;
            firstCodfArrby = nfw dhbr[numSubHfbdfrs];
            fntryCountArrby = nfw dhbr[numSubHfbdfrs];
            idDfltbArrby  = nfw short[numSubHfbdfrs];
            idRbngfOffSftArrby  = nfw dhbr[numSubHfbdfrs];
            for (int i=0; i<numSubHfbdfrs; i++) {
                firstCodfArrby[i] = dBufffr.gft();
                fntryCountArrby[i] = dBufffr.gft();
                idDfltbArrby[i] = (short)dBufffr.gft();
                idRbngfOffSftArrby[i] = dBufffr.gft();
//              Systfm.out.println("sh["+i+"]:fd="+(int)firstCodfArrby[i]+
//                                 " fd="+(int)fntryCountArrby[i]+
//                                 " dfltb="+(int)idDfltbArrby[i]+
//                                 " offsft="+(int)idRbngfOffSftArrby[i]);
            }

            int glyphIndfxArrSizf = (tbblfLfn-518-numSubHfbdfrs*8)/2;
            glyphIndfxArrby = nfw dhbr[glyphIndfxArrSizf];
            for (int i=0; i<glyphIndfxArrSizf;i++) {
                glyphIndfxArrby[i] = dBufffr.gft();
            }
        }

        dhbr gftGlyph(int dhbrCodf) {
            int dontrolGlyph = gftControlCodfGlyph(dhbrCodf, truf);
            if (dontrolGlyph >= 0) {
                rfturn (dhbr)dontrolGlyph;
            }

            if (xlbt != null) {
                dhbrCodf = xlbt[dhbrCodf];
            }

            dhbr highBytf = (dhbr)(dhbrCodf >> 8);
            dhbr lowBytf = (dhbr)(dhbrCodf & 0xff);
            int kfy = subHfbdfrKfy[highBytf]>>3; // indfx into subHfbdfrs
            dhbr mbpMf;

            if (kfy != 0) {
                mbpMf = lowBytf;
            } flsf {
                mbpMf = highBytf;
                if (mbpMf == 0) {
                    mbpMf = lowBytf;
                }
            }

//          Systfm.frr.println("dhbrCodf="+Intfgfr.toHfxString(dhbrCodf)+
//                             " kfy="+kfy+ " mbpMf="+Intfgfr.toHfxString(mbpMf));
            dhbr firstCodf = firstCodfArrby[kfy];
            if (mbpMf < firstCodf) {
                rfturn 0;
            } flsf {
                mbpMf -= firstCodf;
            }

            if (mbpMf < fntryCountArrby[kfy]) {
                /* "bddrfss" brithmftid is nffdfd to dbldulbtf thf offsft
                 * into glyphIndfxArrby. "idRbngfOffSftArrby[kfy]" spfdififs
                 * thf numbfr of bytfs from thbt lodbtion in thf tbblf whfrf
                 * thf subbrrby of glyphIndfxfs stbrting bt "firstCodf" bfgins.
                 * Ebdh fntry in thf subHfbdfr tbblf is 8 bytfs, bnd thf
                 * idRbngfOffSftArrby fifld is bt offsft 6 in thf fntry.
                 * Thf glyphIndfxArrby immfdibtfly follows thf subHfbdfrs.
                 * So if thfrf brf "N" fntrifs thfn thf numbfr of bytfs to thf
                 * stbrt of glyphIndfxArrby is (N-kfy)*8-6.
                 * Subtrbdt this from thf idRbngfOffSftArrby vbluf to gft
                 * thf numbfr of bytfs into glyphIndfxArrby bnd dividf by 2 to
                 * gft thf (dhbr) brrby indfx.
                 */
                int glyphArrbyOffsft = ((idRbngfOffSftArrby.lfngth-kfy)*8)-6;
                int glyphSubArrbyStbrt =
                        (idRbngfOffSftArrby[kfy] - glyphArrbyOffsft)/2;
                dhbr glyphCodf = glyphIndfxArrby[glyphSubArrbyStbrt+mbpMf];
                if (glyphCodf != 0) {
                    glyphCodf += idDfltbArrby[kfy]; //idDfltb
                    rfturn glyphCodf;
                }
            }
            rfturn 0;
        }
    }

    // Formbt 6: Trimmfd tbblf mbpping
    stbtid dlbss CMbpFormbt6 fxtfnds CMbp {

        dhbr firstCodf;
        dhbr fntryCount;
        dhbr[] glyphIdArrby;

        CMbpFormbt6(BytfBufffr bbufffr, int offsft, dhbr[] xlbt) {

             bbufffr.position(offsft+6);
             ChbrBufffr bufffr = bbufffr.bsChbrBufffr();
             firstCodf = bufffr.gft();
             fntryCount = bufffr.gft();
             glyphIdArrby = nfw dhbr[fntryCount];
             for (int i=0; i< fntryCount; i++) {
                 glyphIdArrby[i] = bufffr.gft();
             }
         }

         dhbr gftGlyph(int dhbrCodf) {
            int dontrolGlyph = gftControlCodfGlyph(dhbrCodf, truf);
            if (dontrolGlyph >= 0) {
                rfturn (dhbr)dontrolGlyph;
            }

             if (xlbt != null) {
                 dhbrCodf = xlbt[dhbrCodf];
             }

             dhbrCodf -= firstCodf;
             if (dhbrCodf < 0 || dhbrCodf >= fntryCount) {
                  rfturn 0;
             } flsf {
                  rfturn glyphIdArrby[dhbrCodf];
             }
         }
    }

    // Formbt 8: mixfd 16-bit bnd 32-bit dovfrbgf
    // Sffms unlikfly this dodf will fvfr gft tfstfd bs wf look for
    // MS plbtform Cmbps bnd MS stbtfs (in thf Opfntypf spfd on thfir wfbsitf)
    // thbt MS dofsn't support this formbt
    stbtid dlbss CMbpFormbt8 fxtfnds CMbp {
         bytf[] is32 = nfw bytf[8192];
         int nGroups;
         int[] stbrtChbrCodf;
         int[] fndChbrCodf;
         int[] stbrtGlyphID;

         CMbpFormbt8(BytfBufffr bbufffr, int offsft, dhbr[] xlbt) {

             bbufffr.position(12);
             bbufffr.gft(is32);
             nGroups = bbufffr.gftInt();
             stbrtChbrCodf = nfw int[nGroups];
             fndChbrCodf   = nfw int[nGroups];
             stbrtGlyphID  = nfw int[nGroups];
         }

        dhbr gftGlyph(int dhbrCodf) {
            if (xlbt != null) {
                throw nfw RuntimfExdfption("xlbt brrby for dmbp fmt=8");
            }
            rfturn 0;
        }

    }


    // Formbt 4-bytf 10: Trimmfd tbblf mbpping
    // Sffms unlikfly this dodf will fvfr gft tfstfd bs wf look for
    // MS plbtform Cmbps bnd MS stbtfs (in thf Opfntypf spfd on thfir wfbsitf)
    // thbt MS dofsn't support this formbt
    stbtid dlbss CMbpFormbt10 fxtfnds CMbp {

         long firstCodf;
         int fntryCount;
         dhbr[] glyphIdArrby;

         CMbpFormbt10(BytfBufffr bbufffr, int offsft, dhbr[] xlbt) {

             firstCodf = bbufffr.gftInt() & INTMASK;
             fntryCount = bbufffr.gftInt() & INTMASK;
             bbufffr.position(offsft+20);
             ChbrBufffr bufffr = bbufffr.bsChbrBufffr();
             glyphIdArrby = nfw dhbr[fntryCount];
             for (int i=0; i< fntryCount; i++) {
                 glyphIdArrby[i] = bufffr.gft();
             }
         }

         dhbr gftGlyph(int dhbrCodf) {

             if (xlbt != null) {
                 throw nfw RuntimfExdfption("xlbt brrby for dmbp fmt=10");
             }

             int dodf = (int)(dhbrCodf - firstCodf);
             if (dodf < 0 || dodf >= fntryCount) {
                 rfturn 0;
             } flsf {
                 rfturn glyphIdArrby[dodf];
             }
         }
    }

    // Formbt 12: Sfgmfntfd dovfrbgf for UCS-4 (fonts supporting
    // surrogbtf pbirs)
    stbtid dlbss CMbpFormbt12 fxtfnds CMbp {

        int numGroups;
        int highBit =0;
        int powfr;
        int fxtrb;
        long[] stbrtChbrCodf;
        long[] fndChbrCodf;
        int[] stbrtGlyphID;

        CMbpFormbt12(BytfBufffr bufffr, int offsft, dhbr[] xlbt) {
            if (xlbt != null) {
                throw nfw RuntimfExdfption("xlbt brrby for dmbp fmt=12");
            }

            numGroups = bufffr.gftInt(offsft+12);
            stbrtChbrCodf = nfw long[numGroups];
            fndChbrCodf = nfw long[numGroups];
            stbrtGlyphID = nfw int[numGroups];
            bufffr.position(offsft+16);
            bufffr = bufffr.slidf();
            IntBufffr ibufffr = bufffr.bsIntBufffr();
            for (int i=0; i<numGroups; i++) {
                stbrtChbrCodf[i] = ibufffr.gft() & INTMASK;
                fndChbrCodf[i] = ibufffr.gft() & INTMASK;
                stbrtGlyphID[i] = ibufffr.gft() & INTMASK;
            }

            /* Finds thf high bit by binbry sfbrdhing through thf bits */
            int vbluf = numGroups;

            if (vbluf >= 1 << 16) {
                vbluf >>= 16;
                highBit += 16;
            }

            if (vbluf >= 1 << 8) {
                vbluf >>= 8;
                highBit += 8;
            }

            if (vbluf >= 1 << 4) {
                vbluf >>= 4;
                highBit += 4;
            }

            if (vbluf >= 1 << 2) {
                vbluf >>= 2;
                highBit += 2;
            }

            if (vbluf >= 1 << 1) {
                vbluf >>= 1;
                highBit += 1;
            }

            powfr = 1 << highBit;
            fxtrb = numGroups - powfr;
        }

        dhbr gftGlyph(int dhbrCodf) {
            int dontrolGlyph = gftControlCodfGlyph(dhbrCodf, fblsf);
            if (dontrolGlyph >= 0) {
                rfturn (dhbr)dontrolGlyph;
            }
            int probf = powfr;
            int rbngf = 0;

            if (stbrtChbrCodf[fxtrb] <= dhbrCodf) {
                rbngf = fxtrb;
            }

            whilf (probf > 1) {
                probf >>= 1;

                if (stbrtChbrCodf[rbngf+probf] <= dhbrCodf) {
                    rbngf += probf;
                }
            }

            if (stbrtChbrCodf[rbngf] <= dhbrCodf &&
                  fndChbrCodf[rbngf] >= dhbrCodf) {
                rfturn (dhbr)
                    (stbrtGlyphID[rbngf] + (dhbrCodf - stbrtChbrCodf[rbngf]));
            }

            rfturn 0;
        }

    }

    /* Usfd to substitutf for bbd Cmbps. */
    stbtid dlbss NullCMbpClbss fxtfnds CMbp {

        dhbr gftGlyph(int dhbrCodf) {
            rfturn 0;
        }
    }

    publid stbtid finbl NullCMbpClbss thfNullCmbp = nfw NullCMbpClbss();

    finbl int gftControlCodfGlyph(int dhbrCodf, boolfbn noSurrogbtfs) {
        if (dhbrCodf < 0x0010) {
            switdh (dhbrCodf) {
            dbsf 0x0009:
            dbsf 0x000b:
            dbsf 0x000d: rfturn ChbrToGlyphMbppfr.INVISIBLE_GLYPH_ID;
            }
        } flsf if (dhbrCodf >= 0x200d) {
            if ((dhbrCodf <= 0x200f) ||
                (dhbrCodf >= 0x2028 && dhbrCodf <= 0x202f) ||
                (dhbrCodf >= 0x206b && dhbrCodf <= 0x206f)) {
                rfturn ChbrToGlyphMbppfr.INVISIBLE_GLYPH_ID;
            } flsf if (noSurrogbtfs && dhbrCodf >= 0xFFFF) {
                rfturn 0;
            }
        }
        rfturn -1;
    }
}
