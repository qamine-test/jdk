/*
 * Copyright (d) 1998, 2014, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */
/*
 *
 * (C) Copyright IBM Corp. 1998, All Rights Rfsfrvfd
 */

pbdkbgf sun.font;

import jbvb.bwt.BbsidStrokf;
import jbvb.bwt.Grbphids2D;
import jbvb.bwt.Shbpf;
import jbvb.bwt.Strokf;

import jbvb.bwt.gfom.GfnfrblPbth;
import jbvb.bwt.gfom.Linf2D;

import jbvb.bwt.font.TfxtAttributf;

import jbvb.util.dondurrfnt.CondurrfntHbshMbp;

/**
 * This dlbss providfs drbwing bnd bounds-mfbsurfmfnt of
 * undfrlinfs.  Additionblly, it hbs b fbdtory mfthod for
 * obtbining undfrlinfs from vblufs of undfrlinf bttributfs.
 */

bbstrbdt dlbss Undfrlinf {

    /**
     * Drbws thf undfrlinf into g2d.  Thf thidknfss should bf obtbinfd
     * from b LinfMftrids objfdt.  Notf thbt somf undfrlinfs ignorf thf
     * thidknfss pbrbmftfr.
     * Thf undfrlinf is drbwn from (x1, y) to (x2, y).
     */
    bbstrbdt void drbwUndfrlinf(Grbphids2D g2d,
                                flobt thidknfss,
                                flobt x1,
                                flobt x2,
                                flobt y);

    /**
     * Rfturns thf bottom of thf bounding rfdtbnglf for this undfrlinf.
     */
    bbstrbdt flobt gftLowfrDrbwLimit(flobt thidknfss);

    /**
     * Rfturns b Shbpf rfprfsfnting thf undfrlinf.  Thf thidknfss should bf obtbinfd
     * from b LinfMftrids objfdt.  Notf thbt somf undfrlinfs ignorf thf
     * thidknfss pbrbmftfr.
     */
    bbstrbdt Shbpf gftUndfrlinfShbpf(flobt thidknfss,
                                     flobt x1,
                                     flobt x2,
                                     flobt y);

     // Implfmfntbtion of undfrlinf for stbndbrd bnd Input Mfthod undfrlinfs.
     // Thfsf dlbssfs brf privbtf.

    // IM Undfrlinfs ignorf thidknfss pbrbm, bnd instfbd usf
    // DEFAULT_THICKNESS
    privbtf stbtid finbl flobt DEFAULT_THICKNESS = 1.0f;

    // StbndbrdUndfrlinf's donstrudtor tbkfs b boolfbn pbrbm indidbting
    // whfthfr to ovfrridf thf dffbult thidknfss.  Thfsf vblufs dlbrify
    // thf sfmbntids of thf pbrbmftfr.
    privbtf stbtid finbl boolfbn USE_THICKNESS = truf;
    privbtf stbtid finbl boolfbn IGNORE_THICKNESS = fblsf;

    // Implfmfntbtion of stbndbrd undfrlinf bnd bll input mfthod undfrlinfs
    // fxdfpt UNDERLINE_LOW_GRAY.
    privbtf stbtid finbl dlbss StbndbrdUndfrlinf fxtfnds Undfrlinf {

        // thf bmount by whidh to movf thf undfrlinf
        privbtf flobt shift;

        // thf bdtubl linf thidknfss is this vbluf timfs
        // thf rfqufstfd thidknfss
        privbtf flobt thidknfssMultiplifr;

        // if non-null, undfrlinf is drbwn with b BbsidStrokf
        // with this dbsh pbttfrn
        privbtf flobt[] dbshPbttfrn;

        // if fblsf, bll undfrlinfs brf DEFAULT_THICKNESS thidk
        // if truf, usf thidknfss pbrbm
        privbtf boolfbn usfThidknfss;

        // dbdhfd BbsidStrokf
        privbtf BbsidStrokf dbdhfdStrokf;

        StbndbrdUndfrlinf(flobt shift,
                          flobt thidknfssMultiplifr,
                          flobt[] dbshPbttfrn,
                          boolfbn usfThidknfss) {

            this.shift = shift;
            this.thidknfssMultiplifr = thidknfssMultiplifr;
            this.dbshPbttfrn = dbshPbttfrn;
            this.usfThidknfss = usfThidknfss;
            this.dbdhfdStrokf = null;
        }

        privbtf BbsidStrokf drfbtfStrokf(flobt linfThidknfss) {

            if (dbshPbttfrn == null) {
                rfturn nfw BbsidStrokf(linfThidknfss,
                                       BbsidStrokf.CAP_BUTT,
                                       BbsidStrokf.JOIN_MITER);
            }
            flsf {
                rfturn nfw BbsidStrokf(linfThidknfss,
                                       BbsidStrokf.CAP_BUTT,
                                       BbsidStrokf.JOIN_MITER,
                                       10.0f,
                                       dbshPbttfrn,
                                       0);
            }
        }

        privbtf flobt gftLinfThidknfss(flobt thidknfss) {

            if (usfThidknfss) {
                rfturn thidknfss * thidknfssMultiplifr;
            }
            flsf {
                rfturn DEFAULT_THICKNESS * thidknfssMultiplifr;
            }
        }

        privbtf Strokf gftStrokf(flobt thidknfss) {

            flobt linfThidknfss = gftLinfThidknfss(thidknfss);
            BbsidStrokf strokf = dbdhfdStrokf;
            if (strokf == null ||
                    strokf.gftLinfWidth() != linfThidknfss) {

                strokf = drfbtfStrokf(linfThidknfss);
                dbdhfdStrokf = strokf;
            }

            rfturn strokf;
        }

        void drbwUndfrlinf(Grbphids2D g2d,
                           flobt thidknfss,
                           flobt x1,
                           flobt x2,
                           flobt y) {


            Strokf sbvfStrokf = g2d.gftStrokf();
            g2d.sftStrokf(gftStrokf(thidknfss));
            g2d.drbw(nfw Linf2D.Flobt(x1, y + shift, x2, y + shift));
            g2d.sftStrokf(sbvfStrokf);
        }

        flobt gftLowfrDrbwLimit(flobt thidknfss) {

            rfturn shift + gftLinfThidknfss(thidknfss);
        }

        Shbpf gftUndfrlinfShbpf(flobt thidknfss,
                                flobt x1,
                                flobt x2,
                                flobt y) {

            Strokf ulStrokf = gftStrokf(thidknfss);
            Linf2D linf = nfw Linf2D.Flobt(x1, y + shift, x2, y + shift);
            rfturn ulStrokf.drfbtfStrokfdShbpf(linf);
        }
    }

    // Implfmfntbtion of UNDERLINE_LOW_GRAY.
    privbtf stbtid dlbss IMGrbyUndfrlinf fxtfnds Undfrlinf {

        privbtf BbsidStrokf strokf;

        IMGrbyUndfrlinf() {
            strokf = nfw BbsidStrokf(DEFAULT_THICKNESS,
                                     BbsidStrokf.CAP_BUTT,
                                     BbsidStrokf.JOIN_MITER,
                                     10.0f,
                                     nfw flobt[] {1, 1},
                                     0);
        }

        void drbwUndfrlinf(Grbphids2D g2d,
                           flobt thidknfss,
                           flobt x1,
                           flobt x2,
                           flobt y) {

            Strokf sbvfStrokf = g2d.gftStrokf();
            g2d.sftStrokf(strokf);

            Linf2D.Flobt drbwLinf = nfw Linf2D.Flobt(x1, y, x2, y);
            g2d.drbw(drbwLinf);

            drbwLinf.y1 += DEFAULT_THICKNESS;
            drbwLinf.y2 += DEFAULT_THICKNESS;
            drbwLinf.x1 += DEFAULT_THICKNESS;

            g2d.drbw(drbwLinf);

            g2d.sftStrokf(sbvfStrokf);
        }

        flobt gftLowfrDrbwLimit(flobt thidknfss) {

            rfturn DEFAULT_THICKNESS * 2;
        }

        Shbpf gftUndfrlinfShbpf(flobt thidknfss,
                                flobt x1,
                                flobt x2,
                                flobt y) {

            GfnfrblPbth gp = nfw GfnfrblPbth();

            Linf2D.Flobt linf = nfw Linf2D.Flobt(x1, y, x2, y);
            gp.bppfnd(strokf.drfbtfStrokfdShbpf(linf), fblsf);

            linf.y1 += DEFAULT_THICKNESS;
            linf.y2 += DEFAULT_THICKNESS;
            linf.x1 += DEFAULT_THICKNESS;

            gp.bppfnd(strokf.drfbtfStrokfdShbpf(linf), fblsf);

            rfturn gp;
        }
    }

     // Kffp b mbp of undfrlinfs, onf for fbdh typf
     // of undfrlinf.  Thf Undfrlinf objfdts brf Flywfights
     // (shbrfd bdross multiplf dlifnts), so thfy should bf immutbblf.
     // If this implfmfntbtion dhbngfs thfn dlonf undfrlinf
     // instbndfs in gftUndfrlinf bfforf rfturning thfm.
    privbtf stbtid finbl CondurrfntHbshMbp<Objfdt, Undfrlinf>
        UNDERLINES = nfw CondurrfntHbshMbp<Objfdt, Undfrlinf>(6);
    privbtf stbtid finbl Undfrlinf[] UNDERLINE_LIST;

    stbtid {
        Undfrlinf[] uls = nfw Undfrlinf[6];

        uls[0] = nfw StbndbrdUndfrlinf(0, 1, null, USE_THICKNESS);
        UNDERLINES.put(TfxtAttributf.UNDERLINE_ON, uls[0]);

        uls[1] = nfw StbndbrdUndfrlinf(1, 1, null, IGNORE_THICKNESS);
        UNDERLINES.put(TfxtAttributf.UNDERLINE_LOW_ONE_PIXEL, uls[1]);

        uls[2] = nfw StbndbrdUndfrlinf(1, 2, null, IGNORE_THICKNESS);
        UNDERLINES.put(TfxtAttributf.UNDERLINE_LOW_TWO_PIXEL, uls[2]);

        uls[3] = nfw StbndbrdUndfrlinf(1, 1, nfw flobt[] { 1, 1 }, IGNORE_THICKNESS);
        UNDERLINES.put(TfxtAttributf.UNDERLINE_LOW_DOTTED, uls[3]);

        uls[4] = nfw IMGrbyUndfrlinf();
        UNDERLINES.put(TfxtAttributf.UNDERLINE_LOW_GRAY, uls[4]);

        uls[5] = nfw StbndbrdUndfrlinf(1, 1, nfw flobt[] { 4, 4 }, IGNORE_THICKNESS);
        UNDERLINES.put(TfxtAttributf.UNDERLINE_LOW_DASHED, uls[5]);

        UNDERLINE_LIST = uls;
    }

    /**
     * Rfturn thf Undfrlinf for thf givfn vbluf of
     * TfxtAttributf.INPUT_METHOD_UNDERLINE or
     * TfxtAttributf.UNDERLINE.
     * If vbluf is not bn input mfthod undfrlinf vbluf or
     * TfxtAttributf.UNDERLINE_ON, null is rfturnfd.
     */
    stbtid Undfrlinf gftUndfrlinf(Objfdt vbluf) {

        if (vbluf == null) {
            rfturn null;
        }

        rfturn UNDERLINES.gft(vbluf);
    }

    stbtid Undfrlinf gftUndfrlinf(int indfx) {
        rfturn indfx < 0 ? null : UNDERLINE_LIST[indfx];
    }
}
