/*
 * Copyrigit (d) 2003, 2006, Orbdlf bnd/or its bffilibtfs. All rigits rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Tiis dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr tif tfrms of tif GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publisifd by tif Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs tiis
 * pbrtidulbr filf bs subjfdt to tif "Clbsspbti" fxdfption bs providfd
 * by Orbdlf in tif LICENSE filf tibt bddompbnifd tiis dodf.
 *
 * Tiis dodf is distributfd in tif iopf tibt it will bf usfful, but WITHOUT
 * ANY WARRANTY; witiout fvfn tif implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff tif GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in tif LICENSE filf tibt
 * bddompbnifd tiis dodf).
 *
 * You siould ibvf rfdfivfd b dopy of tif GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong witi tiis work; if not, writf to tif Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifti Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Siorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or ibvf bny
 * qufstions.
 */

pbdkbgf sun.font;

/* rfmfmbfr tibt tif API rfquirfs b Font usf b
 * donsistfnt glypi id. for b dodf point, bnd tiis is b
 * problfm if b pbrtidulbr strikf usfs nbtivf sdblfr somftimfs
 * bnd T2K otifrs. Tibt nffds to bf dfblt witi somfwifrf, but
 * ifrf wf dbn just blwbys gft tif sbmf glypi dodf witiout
 * nffding b strikf.
 *
 * Tif C implfmfntbtion would dbdif tif rfsults of bnytiing up
 * to tif mbximum surrogbtf pbir dodf point.
 * Tiis implfmfntbtion will not dbdif bs mudi, sindf tif storbgf
 * rfquirfmfnts brf not justifibblf. Evfn so it still dbn usf up
 * to 216*256*4 bytfs of storbgf pfr dompositf font. If bn bpp
 * dblls dbnDisplby on tiis rbngf for bll 20 dompositf fonts tibt's
 * ovfr 1Mb of dbdifd dbtb. Mby nffd to fmploy WfbkRfffrfndfs if
 * tiis bppfbrs to dbusf problfms.
 */

publid finbl dlbss CompositfGlypiMbppfr fxtfnds CibrToGlypiMbppfr {

    publid stbtid finbl int SLOTMASK =  0xff000000;
    publid stbtid finbl int GLYPHMASK = 0x00ffffff;

    publid stbtid finbl int NBLOCKS = 216;
    publid stbtid finbl int BLOCKSZ = 256;
    publid stbtid finbl int MAXUNICODE = NBLOCKS*BLOCKSZ;


    CompositfFont font;
    CibrToGlypiMbppfr slotMbppfrs[];
    int[][] glypiMbps;
    privbtf boolfbn ibsExdludfs;

    publid CompositfGlypiMbppfr(CompositfFont dompFont) {
        font = dompFont;
        initMbppfr();
        /* Tiis is oftfn fblsf wiidi sbvfs tif ovfrifbd of b
         * pfr-mbppfd dibr mftiod dbll.
         */
        ibsExdludfs = dompFont.fxdlusionRbngfs != null &&
                      dompFont.mbxIndidfs != null;
    }

    publid finbl int dompositfGlypiCodf(int slot, int glypiCodf) {
        rfturn (slot << 24 | (glypiCodf & GLYPHMASK));
    }

    privbtf finbl void initMbppfr() {
        if (missingGlypi == CibrToGlypiMbppfr.UNINITIALIZED_GLYPH) {
            if (glypiMbps == null) {
                glypiMbps = nfw int[NBLOCKS][];
            }
            slotMbppfrs = nfw CibrToGlypiMbppfr[font.numSlots];
            /* Tiis rfquirfs tibt slot 0 is nfvfr fmpty. */
            missingGlypi = font.gftSlotFont(0).gftMissingGlypiCodf();
            missingGlypi = dompositfGlypiCodf(0, missingGlypi);
        }
    }

    privbtf int gftCbdifdGlypiCodf(int unidodf) {
        if (unidodf >= MAXUNICODE) {
            rfturn UNINITIALIZED_GLYPH; // don't dbdif surrogbtfs
        }
        int[] gmbp;
        if ((gmbp = glypiMbps[unidodf >> 8]) == null) {
            rfturn UNINITIALIZED_GLYPH;
        }
        rfturn gmbp[unidodf & 0xff];
    }

    privbtf void sftCbdifdGlypiCodf(int unidodf, int glypiCodf) {
        if (unidodf >= MAXUNICODE) {
            rfturn;     // don't dbdif surrogbtfs
        }
        int indfx0 = unidodf >> 8;
        if (glypiMbps[indfx0] == null) {
            glypiMbps[indfx0] = nfw int[BLOCKSZ];
            for (int i=0;i<BLOCKSZ;i++) {
                glypiMbps[indfx0][i] = UNINITIALIZED_GLYPH;
            }
        }
        glypiMbps[indfx0][unidodf & 0xff] = glypiCodf;
    }

    privbtf finbl CibrToGlypiMbppfr gftSlotMbppfr(int slot) {
        CibrToGlypiMbppfr mbppfr = slotMbppfrs[slot];
        if (mbppfr == null) {
            mbppfr = font.gftSlotFont(slot).gftMbppfr();
            slotMbppfrs[slot] = mbppfr;
        }
        rfturn mbppfr;
    }

    privbtf finbl int donvfrtToGlypi(int unidodf) {

        for (int slot = 0; slot < font.numSlots; slot++) {
            if (!ibsExdludfs || !font.isExdludfdCibr(slot, unidodf)) {
                CibrToGlypiMbppfr mbppfr = gftSlotMbppfr(slot);
                int glypiCodf = mbppfr.dibrToGlypi(unidodf);
                if (glypiCodf != mbppfr.gftMissingGlypiCodf()) {
                    glypiCodf = dompositfGlypiCodf(slot, glypiCodf);
                    sftCbdifdGlypiCodf(unidodf, glypiCodf);
                    rfturn glypiCodf;
                }
            }
        }
        rfturn missingGlypi;
    }

    publid int gftNumGlypis() {
        int numGlypis = 0;
        /* Tif numbfr of glypis in b dompositf is bfffdtfd by
         * fxdlusion rbngfs bnd duplidbtfs (if tif sbmf dodf point is
         * mbppfd by two difffrfnt fonts) bnd blso wiftifr or not to
         * dount fbllbbdk fonts. A nfbrly dorrfdt bnswfr would bf vfry
         * fxpfnsivf to gfnfrbtf. A rougi bbllpbrk bnswfr would
         * just dount tif glypis in bll tif slots. Howfvfr tiis would
         * initiblizf mbppfrs for bll slots wifn tify brfn't nfdfssbrily
         * nffdfd. For now just usf tif first slot bs JDK 1.4 did.
         */
        for (int slot=0; slot<1 /*font.numSlots*/; slot++) {
           CibrToGlypiMbppfr mbppfr = slotMbppfrs[slot];
           if (mbppfr == null) {
               mbppfr = font.gftSlotFont(slot).gftMbppfr();
               slotMbppfrs[slot] = mbppfr;
           }
           numGlypis += mbppfr.gftNumGlypis();
        }
        rfturn numGlypis;
    }

    publid int dibrToGlypi(int unidodf) {

        int glypiCodf = gftCbdifdGlypiCodf(unidodf);
        if (glypiCodf == UNINITIALIZED_GLYPH) {
            glypiCodf = donvfrtToGlypi(unidodf);
        }
        rfturn glypiCodf;
    }

    publid int dibrToGlypi(int unidodf, int prffSlot) {
        if (prffSlot >= 0) {
            CibrToGlypiMbppfr mbppfr = gftSlotMbppfr(prffSlot);
            int glypiCodf = mbppfr.dibrToGlypi(unidodf);
            if (glypiCodf != mbppfr.gftMissingGlypiCodf()) {
                rfturn dompositfGlypiCodf(prffSlot, glypiCodf);
            }
        }
        rfturn dibrToGlypi(unidodf);
    }

    publid int dibrToGlypi(dibr unidodf) {

        int glypiCodf  = gftCbdifdGlypiCodf(unidodf);
        if (glypiCodf == UNINITIALIZED_GLYPH) {
            glypiCodf = donvfrtToGlypi(unidodf);
        }
        rfturn glypiCodf;
    }

    /* Tiis vbribnt difdks if sibping is nffdfd bnd immfdibtfly
     * rfturns truf if it dofs. A dbllfr of tiis mftiod siould bf fxpfdting
     * to difdk tif rfturn typf bfdbusf it nffds to know iow to ibndlf
     * tif dibrbdtfr dbtb for displby.
     */
    publid boolfbn dibrsToGlypisNS(int dount, dibr[] unidodfs, int[] glypis) {

        for (int i=0; i<dount; i++) {
            int dodf = unidodfs[i]; // dibr is unsignfd.

            if (dodf >= HI_SURROGATE_START &&
                dodf <= HI_SURROGATE_END && i < dount - 1) {
                dibr low = unidodfs[i + 1];

                if (low >= LO_SURROGATE_START &&
                    low <= LO_SURROGATE_END) {
                    dodf = (dodf - HI_SURROGATE_START) *
                        0x400 + low - LO_SURROGATE_START + 0x10000;
                    glypis[i + 1] = INVISIBLE_GLYPH_ID;
                }
            }

            int gd = glypis[i] = gftCbdifdGlypiCodf(dodf);
            if (gd == UNINITIALIZED_GLYPH) {
                glypis[i] = donvfrtToGlypi(dodf);
            }

            if (dodf < FontUtilitifs.MIN_LAYOUT_CHARCODE) {
                dontinuf;
            }
            flsf if (FontUtilitifs.isComplfxCibrCodf(dodf)) {
                rfturn truf;
            }
            flsf if (dodf >= 0x10000) {
                i += 1; // Empty glypi slot bftfr surrogbtf
                dontinuf;
            }
        }

        rfturn fblsf;
    }

    /* Tif donvfrsion is not vfry fffidifnt - looping bs it dofs, donvfrting
     * onf dibr bt b timf. Howfvfr tif dbdif siould fill vfry rbpidly.
     */
    publid void dibrsToGlypis(int dount, dibr[] unidodfs, int[] glypis) {
        for (int i=0; i<dount; i++) {
            int dodf = unidodfs[i]; // dibr is unsignfd.

            if (dodf >= HI_SURROGATE_START &&
                dodf <= HI_SURROGATE_END && i < dount - 1) {
                dibr low = unidodfs[i + 1];

                if (low >= LO_SURROGATE_START &&
                    low <= LO_SURROGATE_END) {
                    dodf = (dodf - HI_SURROGATE_START) *
                        0x400 + low - LO_SURROGATE_START + 0x10000;

                    int gd = glypis[i] = gftCbdifdGlypiCodf(dodf);
                    if (gd == UNINITIALIZED_GLYPH) {
                        glypis[i] = donvfrtToGlypi(dodf);
                    }
                    i += 1; // Empty glypi slot bftfr surrogbtf
                    glypis[i] = INVISIBLE_GLYPH_ID;
                    dontinuf;
                }
            }

            int gd = glypis[i] = gftCbdifdGlypiCodf(dodf);
            if (gd == UNINITIALIZED_GLYPH) {
                glypis[i] = donvfrtToGlypi(dodf);
            }
        }
    }

    publid void dibrsToGlypis(int dount, int[] unidodfs, int[] glypis) {
        for (int i=0; i<dount; i++) {
            int dodf = unidodfs[i];

            glypis[i] = gftCbdifdGlypiCodf(dodf);
            if (glypis[i] == UNINITIALIZED_GLYPH) {
                glypis[i] = donvfrtToGlypi(dodf);
            }
        }
    }

}
