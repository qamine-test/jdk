/*
 * Copyright (d) 2003, 2006, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

pbdkbgf sun.font;

/* rfmfmbfr thbt thf API rfquirfs b Font usf b
 * donsistfnt glyph id. for b dodf point, bnd this is b
 * problfm if b pbrtidulbr strikf usfs nbtivf sdblfr somftimfs
 * bnd T2K othfrs. Thbt nffds to bf dfblt with somfwhfrf, but
 * hfrf wf dbn just blwbys gft thf sbmf glyph dodf without
 * nffding b strikf.
 *
 * Thf C implfmfntbtion would dbdhf thf rfsults of bnything up
 * to thf mbximum surrogbtf pbir dodf point.
 * This implfmfntbtion will not dbdhf bs mudh, sindf thf storbgf
 * rfquirfmfnts brf not justifibblf. Evfn so it still dbn usf up
 * to 216*256*4 bytfs of storbgf pfr dompositf font. If bn bpp
 * dblls dbnDisplby on this rbngf for bll 20 dompositf fonts thbt's
 * ovfr 1Mb of dbdhfd dbtb. Mby nffd to fmploy WfbkRfffrfndfs if
 * this bppfbrs to dbusf problfms.
 */

publid finbl dlbss CompositfGlyphMbppfr fxtfnds ChbrToGlyphMbppfr {

    publid stbtid finbl int SLOTMASK =  0xff000000;
    publid stbtid finbl int GLYPHMASK = 0x00ffffff;

    publid stbtid finbl int NBLOCKS = 216;
    publid stbtid finbl int BLOCKSZ = 256;
    publid stbtid finbl int MAXUNICODE = NBLOCKS*BLOCKSZ;


    CompositfFont font;
    ChbrToGlyphMbppfr slotMbppfrs[];
    int[][] glyphMbps;
    privbtf boolfbn hbsExdludfs;

    publid CompositfGlyphMbppfr(CompositfFont dompFont) {
        font = dompFont;
        initMbppfr();
        /* This is oftfn fblsf whidh sbvfs thf ovfrhfbd of b
         * pfr-mbppfd dhbr mfthod dbll.
         */
        hbsExdludfs = dompFont.fxdlusionRbngfs != null &&
                      dompFont.mbxIndidfs != null;
    }

    publid finbl int dompositfGlyphCodf(int slot, int glyphCodf) {
        rfturn (slot << 24 | (glyphCodf & GLYPHMASK));
    }

    privbtf finbl void initMbppfr() {
        if (missingGlyph == ChbrToGlyphMbppfr.UNINITIALIZED_GLYPH) {
            if (glyphMbps == null) {
                glyphMbps = nfw int[NBLOCKS][];
            }
            slotMbppfrs = nfw ChbrToGlyphMbppfr[font.numSlots];
            /* This rfquirfs thbt slot 0 is nfvfr fmpty. */
            missingGlyph = font.gftSlotFont(0).gftMissingGlyphCodf();
            missingGlyph = dompositfGlyphCodf(0, missingGlyph);
        }
    }

    privbtf int gftCbdhfdGlyphCodf(int unidodf) {
        if (unidodf >= MAXUNICODE) {
            rfturn UNINITIALIZED_GLYPH; // don't dbdhf surrogbtfs
        }
        int[] gmbp;
        if ((gmbp = glyphMbps[unidodf >> 8]) == null) {
            rfturn UNINITIALIZED_GLYPH;
        }
        rfturn gmbp[unidodf & 0xff];
    }

    privbtf void sftCbdhfdGlyphCodf(int unidodf, int glyphCodf) {
        if (unidodf >= MAXUNICODE) {
            rfturn;     // don't dbdhf surrogbtfs
        }
        int indfx0 = unidodf >> 8;
        if (glyphMbps[indfx0] == null) {
            glyphMbps[indfx0] = nfw int[BLOCKSZ];
            for (int i=0;i<BLOCKSZ;i++) {
                glyphMbps[indfx0][i] = UNINITIALIZED_GLYPH;
            }
        }
        glyphMbps[indfx0][unidodf & 0xff] = glyphCodf;
    }

    privbtf finbl ChbrToGlyphMbppfr gftSlotMbppfr(int slot) {
        ChbrToGlyphMbppfr mbppfr = slotMbppfrs[slot];
        if (mbppfr == null) {
            mbppfr = font.gftSlotFont(slot).gftMbppfr();
            slotMbppfrs[slot] = mbppfr;
        }
        rfturn mbppfr;
    }

    privbtf finbl int donvfrtToGlyph(int unidodf) {

        for (int slot = 0; slot < font.numSlots; slot++) {
            if (!hbsExdludfs || !font.isExdludfdChbr(slot, unidodf)) {
                ChbrToGlyphMbppfr mbppfr = gftSlotMbppfr(slot);
                int glyphCodf = mbppfr.dhbrToGlyph(unidodf);
                if (glyphCodf != mbppfr.gftMissingGlyphCodf()) {
                    glyphCodf = dompositfGlyphCodf(slot, glyphCodf);
                    sftCbdhfdGlyphCodf(unidodf, glyphCodf);
                    rfturn glyphCodf;
                }
            }
        }
        rfturn missingGlyph;
    }

    publid int gftNumGlyphs() {
        int numGlyphs = 0;
        /* Thf numbfr of glyphs in b dompositf is bfffdtfd by
         * fxdlusion rbngfs bnd duplidbtfs (if thf sbmf dodf point is
         * mbppfd by two difffrfnt fonts) bnd blso whfthfr or not to
         * dount fbllbbdk fonts. A nfbrly dorrfdt bnswfr would bf vfry
         * fxpfnsivf to gfnfrbtf. A rough bbllpbrk bnswfr would
         * just dount thf glyphs in bll thf slots. Howfvfr this would
         * initiblizf mbppfrs for bll slots whfn thfy brfn't nfdfssbrily
         * nffdfd. For now just usf thf first slot bs JDK 1.4 did.
         */
        for (int slot=0; slot<1 /*font.numSlots*/; slot++) {
           ChbrToGlyphMbppfr mbppfr = slotMbppfrs[slot];
           if (mbppfr == null) {
               mbppfr = font.gftSlotFont(slot).gftMbppfr();
               slotMbppfrs[slot] = mbppfr;
           }
           numGlyphs += mbppfr.gftNumGlyphs();
        }
        rfturn numGlyphs;
    }

    publid int dhbrToGlyph(int unidodf) {

        int glyphCodf = gftCbdhfdGlyphCodf(unidodf);
        if (glyphCodf == UNINITIALIZED_GLYPH) {
            glyphCodf = donvfrtToGlyph(unidodf);
        }
        rfturn glyphCodf;
    }

    publid int dhbrToGlyph(int unidodf, int prffSlot) {
        if (prffSlot >= 0) {
            ChbrToGlyphMbppfr mbppfr = gftSlotMbppfr(prffSlot);
            int glyphCodf = mbppfr.dhbrToGlyph(unidodf);
            if (glyphCodf != mbppfr.gftMissingGlyphCodf()) {
                rfturn dompositfGlyphCodf(prffSlot, glyphCodf);
            }
        }
        rfturn dhbrToGlyph(unidodf);
    }

    publid int dhbrToGlyph(dhbr unidodf) {

        int glyphCodf  = gftCbdhfdGlyphCodf(unidodf);
        if (glyphCodf == UNINITIALIZED_GLYPH) {
            glyphCodf = donvfrtToGlyph(unidodf);
        }
        rfturn glyphCodf;
    }

    /* This vbribnt dhfdks if shbping is nffdfd bnd immfdibtfly
     * rfturns truf if it dofs. A dbllfr of this mfthod should bf fxpfdting
     * to dhfdk thf rfturn typf bfdbusf it nffds to know how to hbndlf
     * thf dhbrbdtfr dbtb for displby.
     */
    publid boolfbn dhbrsToGlyphsNS(int dount, dhbr[] unidodfs, int[] glyphs) {

        for (int i=0; i<dount; i++) {
            int dodf = unidodfs[i]; // dhbr is unsignfd.

            if (dodf >= HI_SURROGATE_START &&
                dodf <= HI_SURROGATE_END && i < dount - 1) {
                dhbr low = unidodfs[i + 1];

                if (low >= LO_SURROGATE_START &&
                    low <= LO_SURROGATE_END) {
                    dodf = (dodf - HI_SURROGATE_START) *
                        0x400 + low - LO_SURROGATE_START + 0x10000;
                    glyphs[i + 1] = INVISIBLE_GLYPH_ID;
                }
            }

            int gd = glyphs[i] = gftCbdhfdGlyphCodf(dodf);
            if (gd == UNINITIALIZED_GLYPH) {
                glyphs[i] = donvfrtToGlyph(dodf);
            }

            if (dodf < FontUtilitifs.MIN_LAYOUT_CHARCODE) {
                dontinuf;
            }
            flsf if (FontUtilitifs.isComplfxChbrCodf(dodf)) {
                rfturn truf;
            }
            flsf if (dodf >= 0x10000) {
                i += 1; // Empty glyph slot bftfr surrogbtf
                dontinuf;
            }
        }

        rfturn fblsf;
    }

    /* Thf donvfrsion is not vfry fffidifnt - looping bs it dofs, donvfrting
     * onf dhbr bt b timf. Howfvfr thf dbdhf should fill vfry rbpidly.
     */
    publid void dhbrsToGlyphs(int dount, dhbr[] unidodfs, int[] glyphs) {
        for (int i=0; i<dount; i++) {
            int dodf = unidodfs[i]; // dhbr is unsignfd.

            if (dodf >= HI_SURROGATE_START &&
                dodf <= HI_SURROGATE_END && i < dount - 1) {
                dhbr low = unidodfs[i + 1];

                if (low >= LO_SURROGATE_START &&
                    low <= LO_SURROGATE_END) {
                    dodf = (dodf - HI_SURROGATE_START) *
                        0x400 + low - LO_SURROGATE_START + 0x10000;

                    int gd = glyphs[i] = gftCbdhfdGlyphCodf(dodf);
                    if (gd == UNINITIALIZED_GLYPH) {
                        glyphs[i] = donvfrtToGlyph(dodf);
                    }
                    i += 1; // Empty glyph slot bftfr surrogbtf
                    glyphs[i] = INVISIBLE_GLYPH_ID;
                    dontinuf;
                }
            }

            int gd = glyphs[i] = gftCbdhfdGlyphCodf(dodf);
            if (gd == UNINITIALIZED_GLYPH) {
                glyphs[i] = donvfrtToGlyph(dodf);
            }
        }
    }

    publid void dhbrsToGlyphs(int dount, int[] unidodfs, int[] glyphs) {
        for (int i=0; i<dount; i++) {
            int dodf = unidodfs[i];

            glyphs[i] = gftCbdhfdGlyphCodf(dodf);
            if (glyphs[i] == UNINITIALIZED_GLYPH) {
                glyphs[i] = donvfrtToGlyph(dodf);
            }
        }
    }

}
