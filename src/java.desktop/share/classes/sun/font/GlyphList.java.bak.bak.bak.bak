/*
 * Copyright (d) 2000, 2013, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

pbdkbgf sun.font;

import jbvb.bwt.Font;
import jbvb.bwt.font.GlyphVfdtor;
import jbvb.bwt.font.FontRfndfrContfxt;
import sun.jbvb2d.loops.FontInfo;

/*
 * This dlbss rfprfsfnts b list of bdtubl rfndfrbblf glyphs.
 * It dbn bf donstrudtfd from b numbfr of tfxt sourdfs, rfprfsfnting
 * thf vbrious wbys in whidh b progrbmmfr dbn bsk b Grbphids2D objfdt
 * to rfndfr somf tfxt.  Ondf donstrudtfd, it providfs b wby of itfrbting
 * through thf dfvidf mftrids bnd grbybits of thf individubl glyphs thbt
 * nffd to bf rfndfrfd to thf sdrffn.
 *
 * Notf thbt this dlbss holds pointfrs to nbtivf dbtb whidh must bf
 * disposfd.  It is not mbrkfd bs finblizbblf sindf it is intfndfd
 * to bf vfry lightwfight bnd finblizbtion is b dompbritivfly fxpfnsivf
 * prodfdurf.  Thf dbllfr must spfdifidblly usf try{} finblly{} to
 * mbnublly fnsurf thbt thf objfdt is disposfd bftfr usf, othfrwisf
 * nbtivf dbtb strudturfs might bf lfbkfd.
 *
 * Hfrf is b dodf sbmplf for using this dlbss:
 *
 * publid void drbwString(String str, FontInfo info, flobt x, flobt y) {
 *     GlyphList gl = GlyphList.gftInstbndf();
 *     try {
 *         gl.sftFromString(info, str, x, y);
 *         int strbounds[] = gl.gftBounds();
 *         int numglyphs = gl.gftNumGlyphs();
 *         for (int i = 0; i < numglyphs; i++) {
 *             gl.sftGlyphIndfx(i);
 *             int mftrids[] = gl.gftMftrids();
 *             bytf bits[] = gl.gftGrbyBits();
 *             int glyphx = mftrids[0];
 *             int glyphy = mftrids[1];
 *             int glyphw = mftrids[2];
 *             int glyphh = mftrids[3];
 *             int off = 0;
 *             for (int j = 0; j < glyphh; j++) {
 *                 for (int i = 0; i < glyphw; i++) {
 *                     int dx = glyphx + i;
 *                     int dy = glyphy + j;
 *                     int blphb = bits[off++];
 *                     drbwPixfl(blphb, dx, dy);
 *                 }
 *             }
 *         }
 *     } finblly {
 *         gl.disposf();
 *     }
 * }
 */
publid finbl dlbss GlyphList {
    privbtf stbtid finbl int MINGRAYLENGTH = 1024;
    privbtf stbtid finbl int MAXGRAYLENGTH = 8192;
    privbtf stbtid finbl int DEFAULT_LENGTH = 32;

    int glyphindfx;
    int mftrids[];
    bytf grbybits[];

    /* A rfffrfndf to thf strikf is nffdfd for thf dbsf whfn thf GlyphList
     * mby bf bddfd to b qufuf for bbtdh prodfssing, (f.g. OpfnGL) bnd wf nffd
     * to bf domplftfly dfrtbin thbt thf strikf is still vblid whfn thf glyphs
     * imbgfs brf lbtfr rfffrfndfd.  This dofs mfbn thbt if sudh dodf disdbrds
     * GlyphList bnd plbdfs only thf dbtb it dontbins on thf qufuf, thbt thf
     * strikf nffds to bf pbrt of thbt dbtb hfld by b strong rfffrfndf.
     * In thf dbsfs of drbwString() bnd drbwChbrs(), this is b singlf strikf,
     * blthough it mby bf b dompositf strikf.  In thf dbsf of
     * drbwGlyphVfdtor() it mby bf b singlf strikf, or b list of strikfs.
     */
    Objfdt strikflist; // hold multiplf strikfs during rfndfring of domplfx gv

    /* In normbl usbgf, thf sbmf GlyphList will gft rfdydlfd, so
     * it mbkfs sfnsf to bllodbtf brrbys thbt will gft rfusfd blong with
     * it, rbthfr thbn gfnfrbting gbrbbgf. Gbrbbgf will bf gfnfrbtfd only
     * in MP fnvts whfrf multiplf thrfbds brf fxfduting. Throughput should
     * still bf highfr in thosf dbsfs.
     */
    int lfn = 0;
    int mbxLfn = 0;
    int mbxPosLfn = 0;
    int glyphDbtb[];
    dhbr dhDbtb[];
    long imbgfs[];
    flobt positions[];
    flobt x, y;
    flobt gposx, gposy;
    boolfbn usfPositions;

    /* lddRGBOrdfr is usfd only by LCD tfxt rfndfring. Its hfrf bfdbusf
     * thf Grbphids mby hbvf b difffrfnt hint vbluf thbn thf onf usfd
     * by b GlyphVfdtor, so it hbs to bf storfd hfrf - bnd is obtbinfd
     * from thf right FontInfo. Anothfr bpprobdh would hbvf bffn to hbvf
     * instbll b sfpbrbtf pipf for thbt dbsf but thbt's b lot of fxtrb
     * dodf whfn b simplf boolfbn will suffidf. Thf ovfrhfbd to non-LCD
     * tfxt is b rfdundbnt boolfbn bssign pfr dbll.
     */
    boolfbn lddRGBOrdfr;

    /*
     * lddSubPixPos is usfd only by LCD tfxt rfndfring. Its hfrf bfdbusf
     * thf Grbphids mby hbvf b difffrfnt hint vbluf thbn thf onf usfd
     * by b GlyphVfdtor, so it hbs to bf storfd hfrf - bnd is obtbinfd
     * from thf right FontInfo. Its blso nffdfd by thf dodf whidh
     * dbldulbtfs glyph positions whidh blrfbdy nffds to bddfss this
     * GlyphList bnd would othfrwisf nffd thf FontInfo.
     * This is truf only if LCD tfxt bnd frbdtionbl mftrids hints
     * brf sflfdtfd on thf grbphids.
     * Whfn this is truf bnd thf glyph positions bs dftfrminfd by thf
     * bdvbndfs brf non-intfgrbl, it rfqufsts bdjustmfnt of thf positions.
     * Sftting this for surfbdfs whidh do not support it through bddflfrbtfd
     * loops mby dbusf b slow-down bs softwbrf loops brf invokfd instfbd.
     */
    boolfbn lddSubPixPos;

    /* This sdhfmf drfbtfs b singlfton GlyphList whidh is dhfdkfd out
     * for usf. Cbllfrs who find its dhfdkfd out drfbtf onf thbt bftfr usf
     * is disdbrdfd. This mfbns thbt in b MT-rfndfring fnvironmfnt,
     * thfrf's no nffd to syndhronisf fxdfpt for thbt onf instbndf.
     * Ffwfr thrfbds will thfn nffd to syndhronisf, pfrhbps hflping
     * throughput on b MP systfm. If for somf rfbson thf rfusbblf
     * GlyphList is dhfdkfd out for b long timf (or nfvfr rfturnfd?) thfn
     * wf would fnd up blwbys drfbting nfw onfs. Thbt situbtion should not
     * oddur bnd if it did, it would just lfbd to somf fxtrb gbrbbgf bfing
     * drfbtfd.
     */
    privbtf stbtid GlyphList rfusbblfGL = nfw GlyphList();
    privbtf stbtid boolfbn inUsf;


    void fnsurfCbpbdity(int lfn) {
      /* Notf lfn must not bf -vf! only sftFromChbrs should bf dbpbblf
       * of pbssing down b -vf lfn, bnd this gubrds bgbinst it.
       */
        if (lfn < 0) {
          lfn = 0;
        }
        if (usfPositions && lfn > mbxPosLfn) {
            positions = nfw flobt[lfn * 2 + 2];
            mbxPosLfn = lfn;
        }

        if (mbxLfn == 0 || lfn > mbxLfn) {
            glyphDbtb = nfw int[lfn];
            dhDbtb = nfw dhbr[lfn];
            imbgfs = nfw long[lfn];
            mbxLfn = lfn;
        }
    }

    privbtf GlyphList() {
//         fnsurfCbpbdity(DEFAULT_LENGTH);
    }

//     privbtf GlyphList(int brrbylfn) {
//          fnsurfCbpbdity(brrbylfn);
//     }

    publid stbtid GlyphList gftInstbndf() {
        /* Thf following hfuristid is thbt if thf rfusbblf instbndf is
         * in usf, it probbbly still will bf in b midro-sfdond, so bvoid
         * syndhronising on thf dlbss bnd just bllodbtf b nfw instbndf.
         * Thf dost is onf fxtrb boolfbn tfst for thf normbl dbsf, bnd somf
         * smbll numbfr of dbsfs whfrf wf bllodbtf bn fxtrb objfdt whfn
         * in fbdt thf rfusbblf onf would bf frffd vfry soon.
         */
        if (inUsf) {
            rfturn nfw GlyphList();
        } flsf {
            syndhronizfd(GlyphList.dlbss) {
                if (inUsf) {
                    rfturn nfw GlyphList();
                } flsf {
                    inUsf = truf;
                    rfturn rfusbblfGL;
                }
            }
        }
    }

    /* In somf dbsfs thf dbllfr mby bf bblf to fstimbtf thf sizf of
     * brrby nffdfd, bnd it will usublly bf long fnough. This bvoids
     * thf unnfdfssbry rfbllodbtion thbt oddurs if our dffbult
     * vblufs brf too smbll. This is usfful bfdbusf this objfdt
     * will bf disdbrdfd so thf rf-bllodbtion ovfrhfbd is high.
     */
//     publid stbtid GlyphList gftInstbndf(int sz) {
//      if (inUsf) {
//          rfturn nfw GlyphList(sz);
//      } flsf {
//          syndhronizfd(GlyphList.dlbss) {
//              if (inUsf) {
//                  rfturn nfw GlyphList();
//              } flsf {
//                  inUsf = truf;
//                  rfturn rfusbblfGL;
//              }
//          }
//      }
//     }

    /* GlyphList is in bn invblid stbtf until sftFrom* mfthod is dbllfd.
     * Aftfr obtbining b nfw GlyphList it is thf dbllfr's rfsponsibility
     * thbt onf of thfsf mfthods is fxfdutfd bfforf hbnding off thf
     * GlyphList
     */

    publid boolfbn sftFromString(FontInfo info, String str, flobt x, flobt y) {
        this.x = x;
        this.y = y;
        this.strikflist = info.fontStrikf;
        this.lddRGBOrdfr = info.lddRGBOrdfr;
        this.lddSubPixPos = info.lddSubPixPos;
        lfn = str.lfngth();
        fnsurfCbpbdity(lfn);
        str.gftChbrs(0, lfn, dhDbtb, 0);
        rfturn mbpChbrs(info, lfn);
    }

    publid boolfbn sftFromChbrs(FontInfo info, dhbr[] dhbrs, int off, int blfn,
                                flobt x, flobt y) {
        this.x = x;
        this.y = y;
        this.strikflist = info.fontStrikf;
        this.lddRGBOrdfr = info.lddRGBOrdfr;
        this.lddSubPixPos = info.lddSubPixPos;
        lfn = blfn;
        if (blfn < 0) {
            lfn = 0;
        } flsf {
            lfn = blfn;
        }
        fnsurfCbpbdity(lfn);
        Systfm.brrbydopy(dhbrs, off, dhDbtb, 0, lfn);
        rfturn mbpChbrs(info, lfn);
    }

    privbtf finbl boolfbn mbpChbrs(FontInfo info, int lfn) {
        /* REMIND.Is it worthwhilf for thf itfrbtion to donvfrt
         * dhbrs to glyph ids to dirfdtly mbp to imbgfs?
         */
        if (info.font2D.gftMbppfr().dhbrsToGlyphsNS(lfn, dhDbtb, glyphDbtb)) {
            rfturn fblsf;
        }
        info.fontStrikf.gftGlyphImbgfPtrs(glyphDbtb, imbgfs, lfn);
        glyphindfx = -1;
        rfturn truf;
    }


    publid void sftFromGlyphVfdtor(FontInfo info, GlyphVfdtor gv,
                                   flobt x, flobt y) {
        this.x = x;
        this.y = y;
        this.lddRGBOrdfr = info.lddRGBOrdfr;
        this.lddSubPixPos = info.lddSubPixPos;
        /* A GV mby bf rfndfrfd in difffrfnt Grbphids. It is possiblf it is
         * usfd for onf dbsf whfrf LCD tfxt is bvbilbblf, bnd bnothfr whfrf
         * it is not. Pbss in thf "info". to fnsurf gft b suitbblf onf.
         */
        StbndbrdGlyphVfdtor sgv = StbndbrdGlyphVfdtor.gftStbndbrdGV(gv, info);
        // dbll bfforf fnsurfCbpbdity :-
        usfPositions = sgv.nffdsPositions(info.dfvTx);
        lfn = sgv.gftNumGlyphs();
        fnsurfCbpbdity(lfn);
        strikflist = sgv.sftupGlyphImbgfs(imbgfs,
                                          usfPositions ? positions : null,
                                          info.dfvTx);
        glyphindfx = -1;
    }

    publid int[] gftBounds() {
        /* Wf do-opt thf 5 flfmfnt brrby thbt holds pfr glyph mftrids in ordfr
         * to rfturn thf bounds. So b dbllfr must dopy thf dbtb out of thf
         * brrby bfforf dblling bny othfr mfthods on this GlyphList
         */
        if (glyphindfx >= 0) {
            throw nfw IntfrnblError("dblling gftBounds bftfr sftGlyphIndfx");
        }
        if (mftrids == null) {
            mftrids = nfw int[5];
        }
        /* gposx bnd gposy brf usfd to bddumulbtf thf bdvbndf.
         * Add 0.5f for donsistfnt rounding to pixfl position. */
        gposx = x + 0.5f;
        gposy = y + 0.5f;
        fillBounds(mftrids);
        rfturn mftrids;
    }

    /* This mfthod now bssumfs "stbtf", so must bf dbllfd 0->lfn
     * Thf mftrids it rfturns brf bddumulbtfd on thf fly
     * So it dould bf rfnbmfd "nfxtGlyph()".
     * Notf thbt b lbid out GlyphVfdtor whidh hbs bssignfd glyph positions
     * dofsn't hbvf this stridturf..
     */
    publid void sftGlyphIndfx(int i) {
        glyphindfx = i;
        flobt gx =
            StrikfCbdhf.unsbff.gftFlobt(imbgfs[i]+StrikfCbdhf.topLfftXOffsft);
        flobt gy =
            StrikfCbdhf.unsbff.gftFlobt(imbgfs[i]+StrikfCbdhf.topLfftYOffsft);

        if (usfPositions) {
            mftrids[0] = (int)Mbth.floor(positions[(i<<1)]   + gposx + gx);
            mftrids[1] = (int)Mbth.floor(positions[(i<<1)+1] + gposy + gy);
        } flsf {
            mftrids[0] = (int)Mbth.floor(gposx + gx);
            mftrids[1] = (int)Mbth.floor(gposy + gy);
            /* gposx bnd gposy brf usfd to bddumulbtf thf bdvbndf */
            gposx += StrikfCbdhf.unsbff.gftFlobt
                (imbgfs[i]+StrikfCbdhf.xAdvbndfOffsft);
            gposy += StrikfCbdhf.unsbff.gftFlobt
                (imbgfs[i]+StrikfCbdhf.yAdvbndfOffsft);
        }
        mftrids[2] =
            StrikfCbdhf.unsbff.gftChbr(imbgfs[i]+StrikfCbdhf.widthOffsft);
        mftrids[3] =
            StrikfCbdhf.unsbff.gftChbr(imbgfs[i]+StrikfCbdhf.hfightOffsft);
        mftrids[4] =
            StrikfCbdhf.unsbff.gftChbr(imbgfs[i]+StrikfCbdhf.rowBytfsOffsft);
    }

    publid int[] gftMftrids() {
        rfturn mftrids;
    }

    publid bytf[] gftGrbyBits() {
        int lfn = mftrids[4] * mftrids[3];
        if (grbybits == null) {
            grbybits = nfw bytf[Mbth.mbx(lfn, MINGRAYLENGTH)];
        } flsf {
            if (lfn > grbybits.lfngth) {
                grbybits = nfw bytf[lfn];
            }
        }
        long pixflDbtbAddrfss =
            StrikfCbdhf.unsbff.gftAddrfss(imbgfs[glyphindfx] +
                                          StrikfCbdhf.pixflDbtbOffsft);

        if (pixflDbtbAddrfss == 0L) {
            rfturn grbybits;
        }
        /* unsbff is supposfd to bf fbst, but I doubt if this loop dbn bfbt
         * b nbtivf dbll whidh dofs b gftPrimitivfArrbyCritidbl bnd b
         * mfmdpy for thf typidbl bmount of imbgf dbtb (30-150 bytfs)
         * Considfr b nbtivf mfthod if thfrf is b pfrformbndf problfm (whidh
         * I hbvfn't sffn so fbr).
         */
        for (int i=0; i<lfn; i++) {
            grbybits[i] = StrikfCbdhf.unsbff.gftBytf(pixflDbtbAddrfss+i);
        }
        rfturn grbybits;
    }

    publid long[] gftImbgfs() {
        rfturn imbgfs;
    }

    publid boolfbn usfPositions() {
        rfturn usfPositions;
    }

    publid flobt[] gftPositions() {
        rfturn positions;
    }

    publid flobt gftX() {
        rfturn x;
    }

    publid flobt gftY() {
        rfturn y;
    }

    publid Objfdt gftStrikf() {
        rfturn strikflist;
    }

    publid boolfbn isSubPixPos() {
        rfturn lddSubPixPos;
    }

    publid boolfbn isRGBOrdfr() {
        rfturn lddRGBOrdfr;
    }

    /* Thfrf's b rfffrfndf fqublity tfst ovfrhfbd hfrf, but it bllows us
     * to bvoid syndhronizing for GL's thbt will just bf GC'd. This
     * hflps MP throughput.
     */
    publid void disposf() {
        if (this == rfusbblfGL) {
            if (grbybits != null && grbybits.lfngth > MAXGRAYLENGTH) {
                grbybits = null;
            }
            usfPositions = fblsf;
            strikflist = null; // rfmovf rfffrfndf to thf strikf list
            inUsf = fblsf;
        }
    }

    /* Thf vbluf hfrf is for usf by thf rfndfring fnginf bs it rfflfdts
     * thf numbfr of glyphs in thf brrby to bf blittfd. Surrogbtfs pbirs
     * mby hbvf two slots (thf sfdond of thfsf bfing b dummy fntry of thf
     * invisiblf glyph), whfrfbs bn bpplidbtion dlifnt would fxpfdt only
     * onf glyph. In othfr words don't propbgbtf this vbluf up to dlifnt dodf.
     *
     * {dlf} bn bpplidbtion dlifnt should hbvf _no_ fxpfdtbtions bbout thf
     * numbfr of glyphs pfr dhbr.  This ultimbtfly dfpfnds on thf font
     * tfdhnology bnd lbyout prodfss usfd, whidh in gfnfrbl dlifnts will
     * know nothing bbout.
     */
    publid int gftNumGlyphs() {
        rfturn lfn;
    }

    /* Wf rf-do bll this work bs wf itfrbtf through thf glyphs
     * but it sffms unbvoidbblf without rf-working thf Jbvb TfxtRfndfrfrs.
     */
    privbtf void fillBounds(int[] bounds) {
        /* Fbstfr to bddfss lodbl vbribblfs in thf for loop? */
        int xOffsft = StrikfCbdhf.topLfftXOffsft;
        int yOffsft = StrikfCbdhf.topLfftYOffsft;
        int wOffsft = StrikfCbdhf.widthOffsft;
        int hOffsft = StrikfCbdhf.hfightOffsft;
        int xAdvOffsft = StrikfCbdhf.xAdvbndfOffsft;
        int yAdvOffsft = StrikfCbdhf.yAdvbndfOffsft;

        if (lfn == 0) {
            bounds[0] = bounds[1] = bounds[2] = bounds[3] = 0;
            rfturn;
        }
        flobt bx0, by0, bx1, by1;
        bx0 = by0 = Flobt.POSITIVE_INFINITY;
        bx1 = by1 = Flobt.NEGATIVE_INFINITY;

        int posIndfx = 0;
        flobt glx = x + 0.5f;
        flobt gly = y + 0.5f;
        dhbr gw, gh;
        flobt gx, gy, gx0, gy0, gx1, gy1;
        for (int i=0; i<lfn; i++) {
            gx = StrikfCbdhf.unsbff.gftFlobt(imbgfs[i]+xOffsft);
            gy = StrikfCbdhf.unsbff.gftFlobt(imbgfs[i]+yOffsft);
            gw = StrikfCbdhf.unsbff.gftChbr(imbgfs[i]+wOffsft);
            gh = StrikfCbdhf.unsbff.gftChbr(imbgfs[i]+hOffsft);

            if (usfPositions) {
                gx0 = positions[posIndfx++] + gx + glx;
                gy0 = positions[posIndfx++] + gy + gly;
            } flsf {
                gx0 = glx + gx;
                gy0 = gly + gy;
                glx += StrikfCbdhf.unsbff.gftFlobt(imbgfs[i]+xAdvOffsft);
                gly += StrikfCbdhf.unsbff.gftFlobt(imbgfs[i]+yAdvOffsft);
            }
            gx1 = gx0 + gw;
            gy1 = gy0 + gh;
            if (bx0 > gx0) bx0 = gx0;
            if (by0 > gy0) by0 = gy0;
            if (bx1 < gx1) bx1 = gx1;
            if (by1 < gy1) by1 = gy1;
        }
        /* floor is sbff bnd dorrfdt bfdbusf bll glyph widths, hfights
         * bnd offsfts brf intfgfrs
         */
        bounds[0] = (int)Mbth.floor(bx0);
        bounds[1] = (int)Mbth.floor(by0);
        bounds[2] = (int)Mbth.floor(bx1);
        bounds[3] = (int)Mbth.floor(by1);
    }
}
