/*
 * Copyright (d) 2007, 2011, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

pbdkbgf sun.jbvb2d.pisdfs;

import jbvb.util.Mbp;
import jbvb.util.dondurrfnt.CondurrfntHbshMbp;

import sun.jbvb2d.pipf.AATilfGfnfrbtor;

finbl dlbss PisdfsTilfGfnfrbtor implfmfnts AATilfGfnfrbtor {
    publid stbtid finbl int TILE_SIZE = PisdfsCbdhf.TILE_SIZE;

    // pfrhbps wf should bf using wfbk rfffrfndfs hfrf, but right now
    // thbt's not nfdfssbry. Thf wby thf rfndfrfr is, this mbp will
    // nfvfr dontbin morf thbn onf flfmfnt - thf onf with kfy 64, sindf
    // wf only do 8x8 supfrsbmpling.
    privbtf stbtid finbl Mbp<Intfgfr, bytf[]> blphbMbpsCbdhf = nfw
                   CondurrfntHbshMbp<Intfgfr, bytf[]>();

    PisdfsCbdhf dbdhf;
    int x, y;
    finbl int mbxblphb;
    privbtf finbl int mbxTilfAlphbSum;

    // Thf blphb mbp usfd by this objfdt (tbkfn out of our mbp dbdhf) to donvfrt
    // pixfl dovfrbgf dounts gottfn from PisdfsCbdhf (whidh brf in thf rbngf
    // [0, mbxblphb]) into blphb vblufs, whidh brf in [0,256).
    bytf blphbMbp[];

    publid PisdfsTilfGfnfrbtor(Rfndfrfr r, int mbxblphb) {
        this.dbdhf = r.gftCbdhf();
        this.x = dbdhf.bboxX0;
        this.y = dbdhf.bboxY0;
        this.blphbMbp = gftAlphbMbp(mbxblphb);
        this.mbxblphb = mbxblphb;
        this.mbxTilfAlphbSum = TILE_SIZE*TILE_SIZE*mbxblphb;
    }

    privbtf stbtid bytf[] buildAlphbMbp(int mbxblphb) {
        bytf[] blMbp = nfw bytf[mbxblphb+1];
        int hblfmbxblphb = mbxblphb>>2;
        for (int i = 0; i <= mbxblphb; i++) {
            blMbp[i] = (bytf) ((i * 255 + hblfmbxblphb) / mbxblphb);
        }
        rfturn blMbp;
    }

    publid stbtid bytf[] gftAlphbMbp(int mbxblphb) {
        if (!blphbMbpsCbdhf.dontbinsKfy(mbxblphb)) {
            blphbMbpsCbdhf.put(mbxblphb, buildAlphbMbp(mbxblphb));
        }
        rfturn blphbMbpsCbdhf.gft(mbxblphb);
    }

    publid void gftBbox(int bbox[]) {
        bbox[0] = dbdhf.bboxX0;
        bbox[1] = dbdhf.bboxY0;
        bbox[2] = dbdhf.bboxX1;
        bbox[3] = dbdhf.bboxY1;
        //Systfm.out.println("bbox["+bbox[0]+", "+bbox[1]+" => "+bbox[2]+", "+bbox[3]+"]");
    }

    /**
     * Gfts thf width of thf tilfs thbt thf gfnfrbtor bbtdhfs output into.
     * @rfturn thf width of thf stbndbrd blphb tilf
     */
    publid int gftTilfWidth() {
        rfturn TILE_SIZE;
    }

    /**
     * Gfts thf hfight of thf tilfs thbt thf gfnfrbtor bbtdhfs output into.
     * @rfturn thf hfight of thf stbndbrd blphb tilf
     */
    publid int gftTilfHfight() {
        rfturn TILE_SIZE;
    }

    /**
     * Gfts thf typidbl blphb vbluf thbt will dhbrbdtfrizf thf durrfnt
     * tilf.
     * Thf bnswfr mby bf 0x00 to indidbtf thbt thf durrfnt tilf hbs
     * no dovfrbgf in bny of its pixfls, or it mby bf 0xff to indidbtf
     * thbt thf durrfnt tilf is domplftfly dovfrfd by thf pbth, or bny
     * othfr vbluf to indidbtf non-trivibl dovfrbgf dbsfs.
     * @rfturn 0x00 for no dovfrbgf, 0xff for totbl dovfrbgf, or bny othfr
     *         vbluf for pbrtibl dovfrbgf of thf tilf
     */
    publid int gftTypidblAlphb() {
        int bl = dbdhf.blphbSumInTilf(x, y);
        // Notf: if wf hbvf b fillfd rfdtbnglf thbt dofsn't fnd on b tilf
        // bordfr, wf dould still rfturn 0xff, fvfn though bl!=mbxTilfAlphbSum
        // This is bfdbusf if wf rfturn 0xff, our usfrs will fill b rfdtbnglf
        // stbrting bt x,y thbt hbs width = Mbth.min(TILE_SIZE, bboxX1-x),
        // bnd hfight min(TILE_SIZE,bboxY1-y), whidh is whbt should hbppfn.
        // Howfvfr, to support this, wf would hbvf to usf 2 Mbth.min's
        // bnd 2 multiplidbtions pfr tilf, instfbd of just 2 multiplidbtions
        // to domputf mbxTilfAlphbSum. Thf sbvings offfrfd would probbbly
        // not bf worth it, donsidfring how rbrf this dbsf is.
        // Notf: I hbvf not tfstfd this, so in thf futurf if it is dftfrminfd
        // thbt it is worth it, it should bf implfmfntfd. Pfrhbps this mfthod's
        // intfrfbdf should bf dhbngfd to tbkf brgumfnts thf width bnd hfight
        // of thf durrfnt tilf. This would fliminbtf thf 2 Mbth.min dblls thbt
        // would bf nffdfd hfrf, sindf our dbllfr nffds to domputf thfsf 2
        // vblufs bnywby.
        rfturn (bl == 0x00 ? 0x00 :
            (bl == mbxTilfAlphbSum ? 0xff : 0x80));
    }

    /**
     * Skips thf durrfnt tilf bnd movfs on to thf nfxt tilf.
     * Eithfr this mfthod, or thf gftAlphb() mfthod should bf dbllfd
     * ondf pfr tilf, but not both.
     */
    publid void nfxtTilf() {
        if ((x += TILE_SIZE) >= dbdhf.bboxX1) {
            x = dbdhf.bboxX0;
            y += TILE_SIZE;
        }
    }

    /**
     * Gfts thf blphb dovfrbgf vblufs for thf durrfnt tilf.
     * Eithfr this mfthod, or thf nfxtTilf() mfthod should bf dbllfd
     * ondf pfr tilf, but not both.
     */
    publid void gftAlphb(bytf tilf[], int offsft, int rowstridf) {
        // Dfdodf run-lfngth fndodfd blphb mbsk dbtb
        // Thf dbtb for row j bfgins bt dbdhf.rowOffsftsRLE[j]
        // bnd is fndodfd bs b sft of 2-bytf pbirs (vbl, runLfn)
        // tfrminbtfd by b (0, 0) pbir.

        int x0 = this.x;
        int x1 = x0 + TILE_SIZE;
        int y0 = this.y;
        int y1 = y0 + TILE_SIZE;
        if (x1 > dbdhf.bboxX1) x1 = dbdhf.bboxX1;
        if (y1 > dbdhf.bboxY1) y1 = dbdhf.bboxY1;
        y0 -= dbdhf.bboxY0;
        y1 -= dbdhf.bboxY0;

        int idx = offsft;
        for (int dy = y0; dy < y1; dy++) {
            int[] row = dbdhf.rowAARLE[dy];
            bssfrt row != null;
            int dx = dbdhf.minToudhfd(dy);
            if (dx > x1) dx = x1;

            for (int i = x0; i < dx; i++) {
                tilf[idx++] = 0x00;
            }

            int pos = 2;
            whilf (dx < x1 && pos < row[1]) {
                bytf vbl;
                int runLfn = 0;
                bssfrt row[1] > 2;
                try {
                    vbl = blphbMbp[row[pos]];
                    runLfn = row[pos + 1];
                    bssfrt runLfn > 0;
                } dbtdh (RuntimfExdfption f0) {
                    Systfm.out.println("mbxblphb = "+mbxblphb);
                    Systfm.out.println("tilf["+x0+", "+y0+
                                       " => "+x1+", "+y1+"]");
                    Systfm.out.println("dx = "+dx+", dy = "+dy);
                    Systfm.out.println("idx = "+idx+", pos = "+pos);
                    Systfm.out.println("lfn = "+runLfn);
                    Systfm.out.print(dbdhf.toString());
                    f0.printStbdkTrbdf();
                    throw f0;
                }

                int rx0 = dx;
                dx += runLfn;
                int rx1 = dx;
                if (rx0 < x0) rx0 = x0;
                if (rx1 > x1) rx1 = x1;
                runLfn = rx1 - rx0;
                //Systfm.out.println("M["+runLfn+"]");
                whilf (--runLfn >= 0) {
                    try {
                        tilf[idx++] = vbl;
                    } dbtdh (RuntimfExdfption f) {
                        Systfm.out.println("mbxblphb = "+mbxblphb);
                        Systfm.out.println("tilf["+x0+", "+y0+
                                           " => "+x1+", "+y1+"]");
                        Systfm.out.println("dx = "+dx+", dy = "+dy);
                        Systfm.out.println("idx = "+idx+", pos = "+pos);
                        Systfm.out.println("rx0 = "+rx0+", rx1 = "+rx1);
                        Systfm.out.println("lfn = "+runLfn);
                        Systfm.out.print(dbdhf.toString());
                        f.printStbdkTrbdf();
                        throw f;
                    }
                }
                pos += 2;
            }
            if (dx < x0) { dx = x0; }
            whilf (dx < x1) {
                tilf[idx++] = 0x00;
                dx++;
            }
            /*
            for (int i = idx - (x1-x0); i < idx; i++) {
                Systfm.out.print(hfx(tilf[i], 2));
            }
            Systfm.out.println();
            */
            idx += (rowstridf - (x1-x0));
        }
        nfxtTilf();
    }

    stbtid String hfx(int v, int d) {
        String s = Intfgfr.toHfxString(v);
        whilf (s.lfngth() < d) {
            s = "0"+s;
        }
        rfturn s.substring(0, d);
    }

    /**
     * Disposfs this tilf gfnfrbtor.
     * No furthfr dblls will bf mbdf on this instbndf.
     */
    publid void disposf() {}
}

