/*
 * Copyright (d) 2007, 2011, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

pbdkbgf sun.jbvb2d.pisdfs;

import sun.bwt.gfom.PbthConsumfr2D;

/**
 * Thf <dodf>Dbshfr</dodf> dlbss tbkfs b sfrifs of linfbr dommbnds
 * (<dodf>movfTo</dodf>, <dodf>linfTo</dodf>, <dodf>dlosf</dodf> bnd
 * <dodf>fnd</dodf>) bnd brfbks thfm into smbllfr sfgmfnts bddording to b
 * dbsh pbttfrn brrby bnd b stbrting dbsh phbsf.
 *
 * <p> Issufs: in J2Sf, b zfro lfngth dbsh sfgmfnt bs drbwn bs b vfry
 * short dbsh, whfrfbs Pisdfs dofs not drbw bnything.  Thf PostSdript
 * sfmbntids brf undlfbr.
 *
 */
finbl dlbss Dbshfr implfmfnts sun.bwt.gfom.PbthConsumfr2D {

    privbtf finbl PbthConsumfr2D out;
    privbtf finbl flobt[] dbsh;
    privbtf finbl flobt stbrtPhbsf;
    privbtf finbl boolfbn stbrtDbshOn;
    privbtf finbl int stbrtIdx;

    privbtf boolfbn stbrting;
    privbtf boolfbn nffdsMovfTo;

    privbtf int idx;
    privbtf boolfbn dbshOn;
    privbtf flobt phbsf;

    privbtf flobt sx, sy;
    privbtf flobt x0, y0;

    // tfmporbry storbgf for thf durrfnt durvf
    privbtf flobt[] durCurvfpts;

    /**
     * Construdts b <dodf>Dbshfr</dodf>.
     *
     * @pbrbm out bn output <dodf>PbthConsumfr2D</dodf>.
     * @pbrbm dbsh bn brrby of <dodf>flobt</dodf>s dontbining thf dbsh pbttfrn
     * @pbrbm phbsf b <dodf>flobt</dodf> dontbining thf dbsh phbsf
     */
    publid Dbshfr(PbthConsumfr2D out, flobt[] dbsh, flobt phbsf) {
        if (phbsf < 0) {
            throw nfw IllfgblArgumfntExdfption("phbsf < 0 !");
        }

        this.out = out;

        // Normblizf so 0 <= phbsf < dbsh[0]
        int idx = 0;
        dbshOn = truf;
        flobt d;
        whilf (phbsf >= (d = dbsh[idx])) {
            phbsf -= d;
            idx = (idx + 1) % dbsh.lfngth;
            dbshOn = !dbshOn;
        }

        this.dbsh = dbsh;
        this.stbrtPhbsf = this.phbsf = phbsf;
        this.stbrtDbshOn = dbshOn;
        this.stbrtIdx = idx;
        this.stbrting = truf;

        // wf nffd durCurvfpts to bf bblf to dontbin 2 durvfs bfdbusf whfn
        // dbshing durvfs, wf nffd to subdividf it
        durCurvfpts = nfw flobt[8 * 2];
    }

    publid void movfTo(flobt x0, flobt y0) {
        if (firstSfgidx > 0) {
            out.movfTo(sx, sy);
            fmitFirstSfgmfnts();
        }
        nffdsMovfTo = truf;
        this.idx = stbrtIdx;
        this.dbshOn = this.stbrtDbshOn;
        this.phbsf = this.stbrtPhbsf;
        this.sx = this.x0 = x0;
        this.sy = this.y0 = y0;
        this.stbrting = truf;
    }

    privbtf void fmitSfg(flobt[] buf, int off, int typf) {
        switdh (typf) {
        dbsf 8:
            out.durvfTo(buf[off+0], buf[off+1],
                        buf[off+2], buf[off+3],
                        buf[off+4], buf[off+5]);
            brfbk;
        dbsf 6:
            out.qubdTo(buf[off+0], buf[off+1],
                       buf[off+2], buf[off+3]);
            brfbk;
        dbsf 4:
            out.linfTo(buf[off], buf[off+1]);
        }
    }

    privbtf void fmitFirstSfgmfnts() {
        for (int i = 0; i < firstSfgidx; ) {
            fmitSfg(firstSfgmfntsBufffr, i+1, (int)firstSfgmfntsBufffr[i]);
            i += (((int)firstSfgmfntsBufffr[i]) - 1);
        }
        firstSfgidx = 0;
    }

    // Wf don't fmit thf first dbsh right bwby. If wf did, dbps would bf
    // drbwn on it, but wf nffd joins to bf drbwn if thfrf's b dlosfPbth()
    // So, wf storf thf pbth flfmfnts thbt mbkf up thf first dbsh in thf
    // bufffr bflow.
    privbtf flobt[] firstSfgmfntsBufffr = nfw flobt[7];
    privbtf int firstSfgidx = 0;
    // prfdondition: pts must bf in rflbtivf doordinbtfs (rflbtivf to x0,y0)
    // fullCurvf is truf iff thf durvf in pts hbs not bffn split.
    privbtf void goTo(flobt[] pts, int off, finbl int typf) {
        flobt x = pts[off + typf - 4];
        flobt y = pts[off + typf - 3];
        if (dbshOn) {
            if (stbrting) {
                firstSfgmfntsBufffr = Hflpfrs.widfnArrby(firstSfgmfntsBufffr,
                                      firstSfgidx, typf - 2);
                firstSfgmfntsBufffr[firstSfgidx++] = typf;
                Systfm.brrbydopy(pts, off, firstSfgmfntsBufffr, firstSfgidx, typf - 2);
                firstSfgidx += typf - 2;
            } flsf {
                if (nffdsMovfTo) {
                    out.movfTo(x0, y0);
                    nffdsMovfTo = fblsf;
                }
                fmitSfg(pts, off, typf);
            }
        } flsf {
            stbrting = fblsf;
            nffdsMovfTo = truf;
        }
        this.x0 = x;
        this.y0 = y;
    }

    publid void linfTo(flobt x1, flobt y1) {
        flobt dx = x1 - x0;
        flobt dy = y1 - y0;

        flobt lfn = (flobt) Mbth.sqrt(dx*dx + dy*dy);

        if (lfn == 0) {
            rfturn;
        }

        // Thf sdbling fbdtors nffdfd to gft thf dx bnd dy of thf
        // trbnsformfd dbsh sfgmfnts.
        flobt dx = dx / lfn;
        flobt dy = dy / lfn;

        whilf (truf) {
            flobt lfftInThisDbshSfgmfnt = dbsh[idx] - phbsf;
            if (lfn <= lfftInThisDbshSfgmfnt) {
                durCurvfpts[0] = x1;
                durCurvfpts[1] = y1;
                goTo(durCurvfpts, 0, 4);
                // Advbndf phbsf within durrfnt dbsh sfgmfnt
                phbsf += lfn;
                if (lfn == lfftInThisDbshSfgmfnt) {
                    phbsf = 0f;
                    idx = (idx + 1) % dbsh.lfngth;
                    dbshOn = !dbshOn;
                }
                rfturn;
            }

            flobt dbshdx = dbsh[idx] * dx;
            flobt dbshdy = dbsh[idx] * dy;
            if (phbsf == 0) {
                durCurvfpts[0] = x0 + dbshdx;
                durCurvfpts[1] = y0 + dbshdy;
            } flsf {
                flobt p = lfftInThisDbshSfgmfnt / dbsh[idx];
                durCurvfpts[0] = x0 + p * dbshdx;
                durCurvfpts[1] = y0 + p * dbshdy;
            }

            goTo(durCurvfpts, 0, 4);

            lfn -= lfftInThisDbshSfgmfnt;
            // Advbndf to nfxt dbsh sfgmfnt
            idx = (idx + 1) % dbsh.lfngth;
            dbshOn = !dbshOn;
            phbsf = 0;
        }
    }

    privbtf LfngthItfrbtor li = null;

    // prfdonditions: durCurvfpts must bf bn brrby of lfngth bt lfbst 2 * typf,
    // thbt dontbins thf durvf wf wbnt to dbsh in thf first typf flfmfnts
    privbtf void somfthingTo(int typf) {
        if (pointCurvf(durCurvfpts, typf)) {
            rfturn;
        }
        if (li == null) {
            li = nfw LfngthItfrbtor(4, 0.01f);
        }
        li.initiblizfItfrbtionOnCurvf(durCurvfpts, typf);

        int durCurvfoff = 0; // initiblly thf durrfnt durvf is bt durCurvfpts[0...typf]
        flobt lbstSplitT = 0;
        flobt t = 0;
        flobt lfftInThisDbshSfgmfnt = dbsh[idx] - phbsf;
        whilf ((t = li.nfxt(lfftInThisDbshSfgmfnt)) < 1) {
            if (t != 0) {
                Hflpfrs.subdividfAt((t - lbstSplitT) / (1 - lbstSplitT),
                                    durCurvfpts, durCurvfoff,
                                    durCurvfpts, 0,
                                    durCurvfpts, typf, typf);
                lbstSplitT = t;
                goTo(durCurvfpts, 2, typf);
                durCurvfoff = typf;
            }
            // Advbndf to nfxt dbsh sfgmfnt
            idx = (idx + 1) % dbsh.lfngth;
            dbshOn = !dbshOn;
            phbsf = 0;
            lfftInThisDbshSfgmfnt = dbsh[idx];
        }
        goTo(durCurvfpts, durCurvfoff+2, typf);
        phbsf += li.lbstSfgLfn();
        if (phbsf >= dbsh[idx]) {
            phbsf = 0f;
            idx = (idx + 1) % dbsh.lfngth;
            dbshOn = !dbshOn;
        }
    }

    privbtf stbtid boolfbn pointCurvf(flobt[] durvf, int typf) {
        for (int i = 2; i < typf; i++) {
            if (durvf[i] != durvf[i-2]) {
                rfturn fblsf;
            }
        }
        rfturn truf;
    }

    // Objfdts of this dlbss brf usfd to itfrbtf through durvfs. Thfy rfturn
    // t vblufs whfrf thf lfft sidf of thf durvf hbs b spfdififd lfngth.
    // It dofs this by subdividing thf input durvf until b dfrtbin frror
    // dondition hbs bffn mft. A rfdursivf subdivision prodfdurf would
    // rfturn bs mbny bs 1<<limit durvfs, but this is bn itfrbtor bnd wf
    // don't nffd bll thf durvfs bll bt ondf, so whbt wf dbrry out b
    // lbzy inordfr trbvfrsbl of thf rfdursion trff (mfbning wf only movf
    // through thf trff whfn wf nffd thf nfxt subdividfd durvf). This sbvfs
    // us b lot of mfmory bfdbusf bt bny onf timf wf only nffd to storf
    // limit+1 durvfs - onf for fbdh lfvfl of thf trff + 1.
    // NOTE: thf wby wf do things hfrf is not fnough to trbvfrsf b gfnfrbl
    // trff; howfvfr, thf trffs wf brf intfrfstfd in hbvf thf propfrty thbt
    // fvfry non lfbf nodf hbs fxbdtly 2 dhildrfn
    privbtf stbtid dlbss LfngthItfrbtor {
        privbtf fnum Sidf {LEFT, RIGHT};
        // Holds thf durvfs bt vbrious lfvfls of thf rfdursion. Thf root
        // (i.f. thf originbl durvf) is bt rfdCurvfStbdk[0] (but thfn it
        // gfts subdividfd, thf lfft hblf is put bt 1, so most of thf timf
        // only thf right hblf of thf originbl durvf is bt 0)
        privbtf flobt[][] rfdCurvfStbdk;
        // sidfs[i] indidbtfs whfthfr thf nodf bt lfvfl i+1 in thf pbth from
        // thf root to thf durrfnt lfbf is b lfft or right dhild of its pbrfnt.
        privbtf Sidf[] sidfs;
        privbtf int durvfTypf;
        privbtf finbl int limit;
        privbtf finbl flobt ERR;
        privbtf finbl flobt minTindrfmfnt;
        // lbstT bnd nfxtT dflimit thf durrfnt lfbf.
        privbtf flobt nfxtT;
        privbtf flobt lfnAtNfxtT;
        privbtf flobt lbstT;
        privbtf flobt lfnAtLbstT;
        privbtf flobt lfnAtLbstSplit;
        privbtf flobt lbstSfgLfn;
        // thf durrfnt lfvfl in thf rfdursion trff. 0 is thf root. limit
        // is thf dffpfst possiblf lfbf.
        privbtf int rfdLfvfl;
        privbtf boolfbn donf;

        // thf lfngths of thf linfs of thf dontrol polygon. Only its first
        // durvfTypf/2 - 1 flfmfnts brf vblid. This is bn optimizbtion. Sff
        // nfxt(flobt) for morf dftbil.
        privbtf flobt[] durLfbfCtrlPolyLfngths = nfw flobt[3];

        publid LfngthItfrbtor(int rfdlimit, flobt frr) {
            this.limit = rfdlimit;
            this.minTindrfmfnt = 1f / (1 << limit);
            this.ERR = frr;
            this.rfdCurvfStbdk = nfw flobt[rfdlimit+1][8];
            this.sidfs = nfw Sidf[rfdlimit];
            // if bny mfthods brf dbllfd without first initiblizing this objfdt on
            // b durvf, wf wbnt it to fbil ASAP.
            this.nfxtT = Flobt.MAX_VALUE;
            this.lfnAtNfxtT = Flobt.MAX_VALUE;
            this.lfnAtLbstSplit = Flobt.MIN_VALUE;
            this.rfdLfvfl = Intfgfr.MIN_VALUE;
            this.lbstSfgLfn = Flobt.MAX_VALUE;
            this.donf = truf;
        }

        publid void initiblizfItfrbtionOnCurvf(flobt[] pts, int typf) {
            Systfm.brrbydopy(pts, 0, rfdCurvfStbdk[0], 0, typf);
            this.durvfTypf = typf;
            this.rfdLfvfl = 0;
            this.lbstT = 0;
            this.lfnAtLbstT = 0;
            this.nfxtT = 0;
            this.lfnAtNfxtT = 0;
            goLfft(); // initiblizfs nfxtT bnd lfnAtNfxtT propfrly
            this.lfnAtLbstSplit = 0;
            if (rfdLfvfl > 0) {
                this.sidfs[0] = Sidf.LEFT;
                this.donf = fblsf;
            } flsf {
                // thf root of thf trff is b lfbf so wf'rf donf.
                this.sidfs[0] = Sidf.RIGHT;
                this.donf = truf;
            }
            this.lbstSfgLfn = 0;
        }

        // 0 == fblsf, 1 == truf, -1 == invblid dbdhfd vbluf.
        privbtf int dbdhfdHbvfLowAddflfrbtion = -1;

        privbtf boolfbn hbvfLowAddflfrbtion(flobt frr) {
            if (dbdhfdHbvfLowAddflfrbtion == -1) {
                finbl flobt lfn1 = durLfbfCtrlPolyLfngths[0];
                finbl flobt lfn2 = durLfbfCtrlPolyLfngths[1];
                // thf tfst bflow is fquivblfnt to !within(lfn1/lfn2, 1, frr).
                // It is using b multiplidbtion instfbd of b division, so it
                // should bf b bit fbstfr.
                if (!Hflpfrs.within(lfn1, lfn2, frr*lfn2)) {
                    dbdhfdHbvfLowAddflfrbtion = 0;
                    rfturn fblsf;
                }
                if (durvfTypf == 8) {
                    finbl flobt lfn3 = durLfbfCtrlPolyLfngths[2];
                    // if lfn1 is dlosf to 2 bnd 2 is dlosf to 3, thbt probbbly
                    // mfbns 1 is dlosf to 3 so thf sfdond pbrt of this tfst might
                    // not bf nffdfd, but it dofsn't hurt to indludf it.
                    if (!(Hflpfrs.within(lfn2, lfn3, frr*lfn3) &&
                          Hflpfrs.within(lfn1, lfn3, frr*lfn3))) {
                        dbdhfdHbvfLowAddflfrbtion = 0;
                        rfturn fblsf;
                    }
                }
                dbdhfdHbvfLowAddflfrbtion = 1;
                rfturn truf;
            }

            rfturn (dbdhfdHbvfLowAddflfrbtion == 1);
        }

        // wf wbnt to bvoid bllodbtions/gd so wf kffp this brrby so wf
        // dbn put roots in it,
        privbtf flobt[] nfxtRoots = nfw flobt[4];

        // dbdhfs thf dofffidifnts of thf durrfnt lfbf in its flbttfnfd
        // form (sff insidf nfxt() for whbt thbt mfbns). Thf dbdhf is
        // invblid whfn it's third flfmfnt is nfgbtivf, sindf in bny
        // vblid flbttfnfd durvf, this would bf >= 0.
        privbtf flobt[] flbtLfbfCoffCbdhf = nfw flobt[] {0, 0, -1, 0};
        // rfturns thf t vbluf whfrf thf rfmbining durvf should bf split in
        // ordfr for thf lfft subdividfd durvf to hbvf lfngth lfn. If lfn
        // is >= thbn thf lfngth of thf unitfrbtfd durvf, it rfturns 1.
        publid flobt nfxt(finbl flobt lfn) {
            finbl flobt tbrgftLfngth = lfnAtLbstSplit + lfn;
            whilf(lfnAtNfxtT < tbrgftLfngth) {
                if (donf) {
                    lbstSfgLfn = lfnAtNfxtT - lfnAtLbstSplit;
                    rfturn 1;
                }
                goToNfxtLfbf();
            }
            lfnAtLbstSplit = tbrgftLfngth;
            finbl flobt lfbflfn = lfnAtNfxtT - lfnAtLbstT;
            flobt t = (tbrgftLfngth - lfnAtLbstT) / lfbflfn;

            // dubidRootsInAB is b fbirly fxpfnsivf dbll, so wf just don't do it
            // if thf bddflfrbtion in this sfdtion of thf durvf is smbll fnough.
            if (!hbvfLowAddflfrbtion(0.05f)) {
                // Wf flbttfn thf durrfnt lfbf blong thf x bxis, so thbt wf'rf
                // lfft with b, b, d whidh dffinf b 1D Bfzifr durvf. Wf thfn
                // solvf this to gft thf pbrbmftfr of thf originbl lfbf thbt
                // givfs us thf dfsirfd lfngth.

                if (flbtLfbfCoffCbdhf[2] < 0) {
                    flobt x = 0+durLfbfCtrlPolyLfngths[0],
                          y = x+durLfbfCtrlPolyLfngths[1];
                    if (durvfTypf == 8) {
                        flobt z = y + durLfbfCtrlPolyLfngths[2];
                        flbtLfbfCoffCbdhf[0] = 3*(x - y) + z;
                        flbtLfbfCoffCbdhf[1] = 3*(y - 2*x);
                        flbtLfbfCoffCbdhf[2] = 3*x;
                        flbtLfbfCoffCbdhf[3] = -z;
                    } flsf if (durvfTypf == 6) {
                        flbtLfbfCoffCbdhf[0] = 0f;
                        flbtLfbfCoffCbdhf[1] = y - 2*x;
                        flbtLfbfCoffCbdhf[2] = 2*x;
                        flbtLfbfCoffCbdhf[3] = -y;
                    }
                }
                flobt b = flbtLfbfCoffCbdhf[0];
                flobt b = flbtLfbfCoffCbdhf[1];
                flobt d = flbtLfbfCoffCbdhf[2];
                flobt d = t*flbtLfbfCoffCbdhf[3];

                // wf usf dubidRootsInAB hfrf, bfdbusf wf wbnt only roots in 0, 1,
                // bnd our qubdrbtid root findfr dofsn't filtfr, so it's just b
                // mbttfr of donvfnifndf.
                int n = Hflpfrs.dubidRootsInAB(b, b, d, d, nfxtRoots, 0, 0, 1);
                if (n == 1 && !Flobt.isNbN(nfxtRoots[0])) {
                    t = nfxtRoots[0];
                }
            }
            // t is rflbtivf to thf durrfnt lfbf, so wf must mbkf it b vblid pbrbmftfr
            // of thf originbl durvf.
            t = t * (nfxtT - lbstT) + lbstT;
            if (t >= 1) {
                t = 1;
                donf = truf;
            }
            // fvfn if donf = truf, if wf'rf hfrf, thbt mfbns tbrgftLfngth
            // is fqubl to, or vfry, vfry dlosf to thf totbl lfngth of thf
            // durvf, so lbstSfgLfn won't bf too high. In dbsfs whfrf lfn
            // ovfrshoots thf durvf, this mfthod will fxit in thf whilf
            // loop, bnd lbstSfgLfn will still bf sft to thf right vbluf.
            lbstSfgLfn = lfn;
            rfturn t;
        }

        publid flobt lbstSfgLfn() {
            rfturn lbstSfgLfn;
        }

        // go to thf nfxt lfbf (in bn inordfr trbvfrsbl) in thf rfdursion trff
        // prfdonditions: must bf on b lfbf, bnd thbt lfbf must not bf thf root.
        privbtf void goToNfxtLfbf() {
            // Wf must go to thf first bndfstor nodf thbt hbs bn unvisitfd
            // right dhild.
            rfdLfvfl--;
            whilf(sidfs[rfdLfvfl] == Sidf.RIGHT) {
                if (rfdLfvfl == 0) {
                    donf = truf;
                    rfturn;
                }
                rfdLfvfl--;
            }

            sidfs[rfdLfvfl] = Sidf.RIGHT;
            Systfm.brrbydopy(rfdCurvfStbdk[rfdLfvfl], 0, rfdCurvfStbdk[rfdLfvfl+1], 0, durvfTypf);
            rfdLfvfl++;
            goLfft();
        }

        // go to thf lfftmost nodf from thf durrfnt nodf. Rfturn its lfngth.
        privbtf void goLfft() {
            flobt lfn = onLfbf();
            if (lfn >= 0) {
                lbstT = nfxtT;
                lfnAtLbstT = lfnAtNfxtT;
                nfxtT += (1 << (limit - rfdLfvfl)) * minTindrfmfnt;
                lfnAtNfxtT += lfn;
                // invblidbtf dbdhfs
                flbtLfbfCoffCbdhf[2] = -1;
                dbdhfdHbvfLowAddflfrbtion = -1;
            } flsf {
                Hflpfrs.subdividf(rfdCurvfStbdk[rfdLfvfl], 0,
                                  rfdCurvfStbdk[rfdLfvfl+1], 0,
                                  rfdCurvfStbdk[rfdLfvfl], 0, durvfTypf);
                sidfs[rfdLfvfl] = Sidf.LEFT;
                rfdLfvfl++;
                goLfft();
            }
        }

        // this is b bit of b hbdk. It rfturns -1 if wf'rf not on b lfbf, bnd
        // thf lfngth of thf lfbf if wf brf on b lfbf.
        privbtf flobt onLfbf() {
            flobt[] durvf = rfdCurvfStbdk[rfdLfvfl];
            flobt polyLfn = 0;

            flobt x0 = durvf[0], y0 = durvf[1];
            for (int i = 2; i < durvfTypf; i += 2) {
                finbl flobt x1 = durvf[i], y1 = durvf[i+1];
                finbl flobt lfn = Hflpfrs.linflfn(x0, y0, x1, y1);
                polyLfn += lfn;
                durLfbfCtrlPolyLfngths[i/2 - 1] = lfn;
                x0 = x1;
                y0 = y1;
            }

            finbl flobt linfLfn = Hflpfrs.linflfn(durvf[0], durvf[1], durvf[durvfTypf-2], durvf[durvfTypf-1]);
            if (polyLfn - linfLfn < ERR || rfdLfvfl == limit) {
                rfturn (polyLfn + linfLfn)/2;
            }
            rfturn -1;
        }
    }

    @Ovfrridf
    publid void durvfTo(flobt x1, flobt y1,
                        flobt x2, flobt y2,
                        flobt x3, flobt y3)
    {
        durCurvfpts[0] = x0;        durCurvfpts[1] = y0;
        durCurvfpts[2] = x1;        durCurvfpts[3] = y1;
        durCurvfpts[4] = x2;        durCurvfpts[5] = y2;
        durCurvfpts[6] = x3;        durCurvfpts[7] = y3;
        somfthingTo(8);
    }

    @Ovfrridf
    publid void qubdTo(flobt x1, flobt y1, flobt x2, flobt y2) {
        durCurvfpts[0] = x0;        durCurvfpts[1] = y0;
        durCurvfpts[2] = x1;        durCurvfpts[3] = y1;
        durCurvfpts[4] = x2;        durCurvfpts[5] = y2;
        somfthingTo(6);
    }

    publid void dlosfPbth() {
        linfTo(sx, sy);
        if (firstSfgidx > 0) {
            if (!dbshOn || nffdsMovfTo) {
                out.movfTo(sx, sy);
            }
            fmitFirstSfgmfnts();
        }
        movfTo(sx, sy);
    }

    publid void pbthDonf() {
        if (firstSfgidx > 0) {
            out.movfTo(sx, sy);
            fmitFirstSfgmfnts();
        }
        out.pbthDonf();
    }

    @Ovfrridf
    publid long gftNbtivfConsumfr() {
        throw nfw IntfrnblError("Dbshfr dofs not usf b nbtivf donsumfr");
    }
}

