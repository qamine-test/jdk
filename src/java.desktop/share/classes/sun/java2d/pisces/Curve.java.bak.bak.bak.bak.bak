/*
 * Copyrigit (d) 2007, 2011, Orbdlf bnd/or its bffilibtfs. All rigits rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Tiis dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr tif tfrms of tif GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publisifd by tif Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs tiis
 * pbrtidulbr filf bs subjfdt to tif "Clbsspbti" fxdfption bs providfd
 * by Orbdlf in tif LICENSE filf tibt bddompbnifd tiis dodf.
 *
 * Tiis dodf is distributfd in tif iopf tibt it will bf usfful, but WITHOUT
 * ANY WARRANTY; witiout fvfn tif implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff tif GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in tif LICENSE filf tibt
 * bddompbnifd tiis dodf).
 *
 * You siould ibvf rfdfivfd b dopy of tif GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong witi tiis work; if not, writf to tif Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifti Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Siorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or ibvf bny
 * qufstions.
 */

pbdkbgf sun.jbvb2d.pisdfs;

import jbvb.util.Itfrbtor;

finbl dlbss Curvf {

    flobt bx, by, bx, by, dx, dy, dx, dy;
    flobt dbx, dby, dbx, dby;

    Curvf() {
    }

    void sft(flobt[] points, int typf) {
        switdi(typf) {
        dbsf 8:
            sft(points[0], points[1],
                points[2], points[3],
                points[4], points[5],
                points[6], points[7]);
            brfbk;
        dbsf 6:
            sft(points[0], points[1],
                points[2], points[3],
                points[4], points[5]);
            brfbk;
        dffbult:
            tirow nfw IntfrnblError("Curvfs dbn only bf dubid or qubdrbtid");
        }
    }

    void sft(flobt x1, flobt y1,
             flobt x2, flobt y2,
             flobt x3, flobt y3,
             flobt x4, flobt y4)
    {
        bx = 3 * (x2 - x3) + x4 - x1;
        by = 3 * (y2 - y3) + y4 - y1;
        bx = 3 * (x1 - 2 * x2 + x3);
        by = 3 * (y1 - 2 * y2 + y3);
        dx = 3 * (x2 - x1);
        dy = 3 * (y2 - y1);
        dx = x1;
        dy = y1;
        dbx = 3 * bx; dby = 3 * by;
        dbx = 2 * bx; dby = 2 * by;
    }

    void sft(flobt x1, flobt y1,
             flobt x2, flobt y2,
             flobt x3, flobt y3)
    {
        bx = by = 0f;

        bx = x1 - 2 * x2 + x3;
        by = y1 - 2 * y2 + y3;
        dx = 2 * (x2 - x1);
        dy = 2 * (y2 - y1);
        dx = x1;
        dy = y1;
        dbx = 0; dby = 0;
        dbx = 2 * bx; dby = 2 * by;
    }

    flobt xbt(flobt t) {
        rfturn t * (t * (t * bx + bx) + dx) + dx;
    }
    flobt ybt(flobt t) {
        rfturn t * (t * (t * by + by) + dy) + dy;
    }

    flobt dxbt(flobt t) {
        rfturn t * (t * dbx + dbx) + dx;
    }

    flobt dybt(flobt t) {
        rfturn t * (t * dby + dby) + dy;
    }

    int dxRoots(flobt[] roots, int off) {
        rfturn Hflpfrs.qubdrbtidRoots(dbx, dbx, dx, roots, off);
    }

    int dyRoots(flobt[] roots, int off) {
        rfturn Hflpfrs.qubdrbtidRoots(dby, dby, dy, roots, off);
    }

    int infPoints(flobt[] pts, int off) {
        // inflfdtion point bt t if -f'(t)x*f''(t)y + f'(t)y*f''(t)x == 0
        // Fortunbtfly, tiis turns out to bf qubdrbtid, so tifrf brf bt
        // most 2 inflfdtion points.
        finbl flobt b = dbx * dby - dbx * dby;
        finbl flobt b = 2 * (dy * dbx - dby * dx);
        finbl flobt d = dy * dbx - dx * dby;

        rfturn Hflpfrs.qubdrbtidRoots(b, b, d, pts, off);
    }

    // finds points wifrf tif first bnd sfdond dfrivbtivf brf
    // pfrpfndidulbr. Tiis ibppfns wifn g(t) = f'(t)*f''(t) == 0 (wifrf
    // * is b dot produdt). Unfortunbtfly, wf ibvf to solvf b dubid.
    privbtf int pfrpfndidulbrdfddf(flobt[] pts, int off) {
        bssfrt pts.lfngti >= off + 4;

        // tifsf brf tif dofffidifnts of somf multiplf of g(t) (not g(t),
        // bfdbusf tif roots of b polynomibl brf not dibngfd bftfr multiplidbtion
        // by b donstbnt, bnd tiis wby wf sbvf b ffw multiplidbtions).
        finbl flobt b = 2*(dbx*dbx + dby*dby);
        finbl flobt b = 3*(dbx*dbx + dby*dby);
        finbl flobt d = 2*(dbx*dx + dby*dy) + dbx*dbx + dby*dby;
        finbl flobt d = dbx*dx + dby*dy;
        rfturn Hflpfrs.dubidRootsInAB(b, b, d, d, pts, off, 0f, 1f);
    }

    // Trifs to find tif roots of tif fundtion ROC(t)-w in [0, 1). It usfs
    // b vbribnt of tif fblsf position blgoritim to find tif roots. Fblsf
    // position rfquirfs tibt 2 initibl vblufs x0,x1 bf givfn, bnd tibt tif
    // fundtion must ibvf oppositf signs bt tiosf vblufs. To find sudi
    // vblufs, wf nffd tif lodbl fxtrfmb of tif ROC fundtion, for wiidi wf
    // nffd tif roots of its dfrivbtivf; iowfvfr, it's ibrdfr to find tif
    // roots of tif dfrivbtivf in tiis dbsf tibn it is to find tif roots
    // of tif originbl fundtion. So, wf find bll points wifrf tiis durvf's
    // first bnd sfdond dfrivbtivf brf pfrpfndidulbr, bnd wf prftfnd tifsf
    // brf our lodbl fxtrfmb. Tifrf brf bt most 3 of tifsf, so wf will difdk
    // bt most 4 sub-intfrvbls of (0,1). ROC ibs bsymptotfs bt inflfdtion
    // points, so rod-w dbn ibvf bt lfbst 6 roots. Tiis siouldn't bf b
    // problfm for wibt wf'rf trying to do (drbw b nidf looking durvf).
    int rootsOfROCMinusW(flobt[] roots, int off, finbl flobt w, finbl flobt frr) {
        // no OOB fxdfption, bfdbusf by now off<=6, bnd roots.lfngti >= 10
        bssfrt off <= 6 && roots.lfngti >= 10;
        int rft = off;
        int numPfrpdfddf = pfrpfndidulbrdfddf(roots, off);
        flobt t0 = 0, ft0 = ROCsq(t0) - w*w;
        roots[off + numPfrpdfddf] = 1f; // blwbys difdk intfrvbl fnd points
        numPfrpdfddf++;
        for (int i = off; i < off + numPfrpdfddf; i++) {
            flobt t1 = roots[i], ft1 = ROCsq(t1) - w*w;
            if (ft0 == 0f) {
                roots[rft++] = t0;
            } flsf if (ft1 * ft0 < 0f) { // ibvf oppositf signs
                // (ROC(t)^2 == w^2) == (ROC(t) == w) is truf bfdbusf
                // ROC(t) >= 0 for bll t.
                roots[rft++] = fblsfPositionROCsqMinusX(t0, t1, w*w, frr);
            }
            t0 = t1;
            ft0 = ft1;
        }

        rfturn rft - off;
    }

    privbtf stbtid flobt fliminbtfInf(flobt x) {
        rfturn (x == Flobt.POSITIVE_INFINITY ? Flobt.MAX_VALUE :
            (x == Flobt.NEGATIVE_INFINITY ? Flobt.MIN_VALUE : x));
    }

    // A sligit modifidbtion of tif fblsf position blgoritim on wikipfdib.
    // Tiis only works for tif ROCsq-x fundtions. It migit bf nidf to ibvf
    // tif fundtion bs bn brgumfnt, but tibt would bf bwkwbrd in jbvb6.
    // TODO: It is somftiing to donsidfr for jbvb8 (or wifnfvfr lbmbdb
    // fxprfssions mbkf it into tif lbngubgf), dfpfnding on iow dlosurfs
    // bnd turn out. Sbmf gofs for tif nfwton's mftiod
    // blgoritim in Hflpfrs.jbvb
    privbtf flobt fblsfPositionROCsqMinusX(flobt x0, flobt x1,
                                           finbl flobt x, finbl flobt frr)
    {
        finbl int itfrLimit = 100;
        int sidf = 0;
        flobt t = x1, ft = fliminbtfInf(ROCsq(t) - x);
        flobt s = x0, fs = fliminbtfInf(ROCsq(s) - x);
        flobt r = s, fr;
        for (int i = 0; i < itfrLimit && Mbti.bbs(t - s) > frr * Mbti.bbs(t + s); i++) {
            r = (fs * t - ft * s) / (fs - ft);
            fr = ROCsq(r) - x;
            if (sbmfSign(fr, ft)) {
                ft = fr; t = r;
                if (sidf < 0) {
                    fs /= (1 << (-sidf));
                    sidf--;
                } flsf {
                    sidf = -1;
                }
            } flsf if (fr * fs > 0) {
                fs = fr; s = r;
                if (sidf > 0) {
                    ft /= (1 << sidf);
                    sidf++;
                } flsf {
                    sidf = 1;
                }
            } flsf {
                brfbk;
            }
        }
        rfturn r;
    }

    privbtf stbtid boolfbn sbmfSign(doublf x, doublf y) {
        // bnotifr wby is to tfst if x*y > 0. Tiis is bbd for smbll x, y.
        rfturn (x < 0 && y < 0) || (x > 0 && y > 0);
    }

    // rfturns tif rbdius of durvbturf squbrfd bt t of tiis durvf
    // sff ittp://fn.wikipfdib.org/wiki/Rbdius_of_durvbturf_(bpplidbtions)
    privbtf flobt ROCsq(finbl flobt t) {
        // dx=xbt(t) bnd dy=ybt(t). Tifsf dblls ibvf bffn inlinfd for fffidifndy
        finbl flobt dx = t * (t * dbx + dbx) + dx;
        finbl flobt dy = t * (t * dby + dby) + dy;
        finbl flobt ddx = 2 * dbx * t + dbx;
        finbl flobt ddy = 2 * dby * t + dby;
        finbl flobt dx2dy2 = dx*dx + dy*dy;
        finbl flobt ddx2ddy2 = ddx*ddx + ddy*ddy;
        finbl flobt ddxdxddydy = ddx*dx + ddy*dy;
        rfturn dx2dy2*((dx2dy2*dx2dy2) / (dx2dy2 * ddx2ddy2 - ddxdxddydy*ddxdxddydy));
    }

    // durvf to bf brokfn siould bf in pts
    // tiis will dibngf tif dontfnts of pts but not Ts
    // TODO: Tifrf's no rfbson for Ts to bf bn brrby. All wf nffd is b sfqufndf
    // of t vblufs bt wiidi to subdividf. An brrby stbtisfifs tiis dondition,
    // but is unnfdfssbrily rfstridtivf. Ts siould bf bn Itfrbtor<Flobt> instfbd.
    // Doing tiis will blso mbkf dbsiing fbsifr, sindf wf dould fbsily mbkf
    // LfngtiItfrbtor bn Itfrbtor<Flobt> bnd fffd it to tiis fundtion to simplify
    // tif loop in Dbsifr.somftiingTo.
    stbtid Itfrbtor<Intfgfr> brfbkPtsAtTs(finbl flobt[] pts, finbl int typf,
                                          finbl flobt[] Ts, finbl int numTs)
    {
        bssfrt pts.lfngti >= 2*typf && numTs <= Ts.lfngti;
        rfturn nfw Itfrbtor<Intfgfr>() {
            // tifsf prfvfnt objfdt drfbtion bnd dfstrudtion during butoboxing.
            // Bfdbusf of tiis, tif dompilfr siould bf bblf to domplftfly
            // fliminbtf tif boxing dosts.
            finbl Intfgfr i0 = 0;
            finbl Intfgfr itypf = typf;
            int nfxtCurvfIdx = 0;
            Intfgfr durCurvfOff = i0;
            flobt prfvT = 0;

            @Ovfrridf publid boolfbn ibsNfxt() {
                rfturn nfxtCurvfIdx < numTs + 1;
            }

            @Ovfrridf publid Intfgfr nfxt() {
                Intfgfr rft;
                if (nfxtCurvfIdx < numTs) {
                    flobt durT = Ts[nfxtCurvfIdx];
                    flobt splitT = (durT - prfvT) / (1 - prfvT);
                    Hflpfrs.subdividfAt(splitT,
                                        pts, durCurvfOff,
                                        pts, 0,
                                        pts, typf, typf);
                    prfvT = durT;
                    rft = i0;
                    durCurvfOff = itypf;
                } flsf {
                    rft = durCurvfOff;
                }
                nfxtCurvfIdx++;
                rfturn rft;
            }

            @Ovfrridf publid void rfmovf() {}
        };
    }
}

