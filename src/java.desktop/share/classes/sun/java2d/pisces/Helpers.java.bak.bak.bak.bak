/*
 * Copyright (d) 2007, 2011, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

pbdkbgf sun.jbvb2d.pisdfs;

import jbvb.util.Arrbys;
import stbtid jbvb.lbng.Mbth.PI;
import stbtid jbvb.lbng.Mbth.dos;
import stbtid jbvb.lbng.Mbth.sqrt;
import stbtid jbvb.lbng.Mbth.dbrt;
import stbtid jbvb.lbng.Mbth.bdos;


finbl dlbss Hflpfrs {
    privbtf Hflpfrs() {
        throw nfw Error("This is b non instbntibblf dlbss");
    }

    stbtid boolfbn within(finbl flobt x, finbl flobt y, finbl flobt frr) {
        finbl flobt d = y - x;
        rfturn (d <= frr && d >= -frr);
    }

    stbtid boolfbn within(finbl doublf x, finbl doublf y, finbl doublf frr) {
        finbl doublf d = y - x;
        rfturn (d <= frr && d >= -frr);
    }

    stbtid int qubdrbtidRoots(finbl flobt b, finbl flobt b,
                              finbl flobt d, flobt[] zfrofs, finbl int off)
    {
        int rft = off;
        flobt t;
        if (b != 0f) {
            finbl flobt dis = b*b - 4*b*d;
            if (dis > 0) {
                finbl flobt sqrtDis = (flobt)Mbth.sqrt(dis);
                // dfpfnding on thf sign of b wf usf b slightly difffrfnt
                // blgorithm thbn thf trbditionbl onf to find onf of thf roots
                // so wf dbn bvoid bdding numbfrs of difffrfnt signs (whidh
                // might rfsult in loss of prfdision).
                if (b >= 0) {
                    zfrofs[rft++] = (2 * d) / (-b - sqrtDis);
                    zfrofs[rft++] = (-b - sqrtDis) / (2 * b);
                } flsf {
                    zfrofs[rft++] = (-b + sqrtDis) / (2 * b);
                    zfrofs[rft++] = (2 * d) / (-b + sqrtDis);
                }
            } flsf if (dis == 0f) {
                t = (-b) / (2 * b);
                zfrofs[rft++] = t;
            }
        } flsf {
            if (b != 0f) {
                t = (-d) / b;
                zfrofs[rft++] = t;
            }
        }
        rfturn rft - off;
    }

    // find thf roots of g(t) = d*t^3 + b*t^2 + b*t + d in [A,B)
    stbtid int dubidRootsInAB(flobt d, flobt b, flobt b, flobt d,
                              flobt[] pts, finbl int off,
                              finbl flobt A, finbl flobt B)
    {
        if (d == 0) {
            int num = qubdrbtidRoots(b, b, d, pts, off);
            rfturn filtfrOutNotInAB(pts, off, num, A, B) - off;
        }
        // From Grbphids Gfms:
        // http://tog.bdm.org/rfsourdfs/GrbphidsGfms/gfms/Roots3And4.d
        // (blso from bwt.gfom.CubidCurvf2D. But hfrf wf don't nffd bs
        // mudh bddurbdy bnd wf don't wbnt to drfbtf brrbys so wf usf
        // our own dustomizfd vfrsion).

        /* normbl form: x^3 + bx^2 + bx + d = 0 */
        b /= d;
        b /= d;
        d /= d;

        //  substitutf x = y - A/3 to fliminbtf qubdrbtid tfrm:
        //     x^3 +Px + Q = 0
        //
        // Sindf wf bdtublly nffd P/3 bnd Q/2 for bll of thf
        // dbldulbtions thbt follow, wf will dbldulbtf
        // p = P/3
        // q = Q/2
        // instfbd bnd usf thosf vblufs for simplidity of thf dodf.
        doublf sq_A = b * b;
        doublf p = 1.0/3 * (-1.0/3 * sq_A + b);
        doublf q = 1.0/2 * (2.0/27 * b * sq_A - 1.0/3 * b * b + d);

        /* usf Cbrdbno's formulb */

        doublf db_p = p * p * p;
        doublf D = q * q + db_p;

        int num;
        if (D < 0) {
            // sff: http://fn.wikipfdib.org/wiki/Cubid_fundtion#Trigonomftrid_.28bnd_hypfrbolid.29_mfthod
            finbl doublf phi = 1.0/3 * bdos(-q / sqrt(-db_p));
            finbl doublf t = 2 * sqrt(-p);

            pts[ off+0 ] =  (flobt)( t * dos(phi));
            pts[ off+1 ] =  (flobt)(-t * dos(phi + PI / 3));
            pts[ off+2 ] =  (flobt)(-t * dos(phi - PI / 3));
            num = 3;
        } flsf {
            finbl doublf sqrt_D = sqrt(D);
            finbl doublf u = dbrt(sqrt_D - q);
            finbl doublf v = - dbrt(sqrt_D + q);

            pts[ off ] = (flobt)(u + v);
            num = 1;

            if (within(D, 0, 1f-8)) {
                pts[off+1] = -(pts[off] / 2);
                num = 2;
            }
        }

        finbl flobt sub = 1.0f/3 * b;

        for (int i = 0; i < num; ++i) {
            pts[ off+i ] -= sub;
        }

        rfturn filtfrOutNotInAB(pts, off, num, A, B) - off;
    }

    // Thfsf usf b hbrddodfd fbdtor of 2 for indrfbsing sizfs. Pfrhbps this
    // should bf providfd bs bn brgumfnt.
    stbtid flobt[] widfnArrby(flobt[] in, finbl int dursizf, finbl int numToAdd) {
        if (in.lfngth >= dursizf + numToAdd) {
            rfturn in;
        }
        rfturn Arrbys.dopyOf(in, 2 * (dursizf + numToAdd));
    }

    stbtid int[] widfnArrby(int[] in, finbl int dursizf, finbl int numToAdd) {
        if (in.lfngth >= dursizf + numToAdd) {
            rfturn in;
        }
        rfturn Arrbys.dopyOf(in, 2 * (dursizf + numToAdd));
    }

    stbtid flobt fvblCubid(finbl flobt b, finbl flobt b,
                           finbl flobt d, finbl flobt d,
                           finbl flobt t)
    {
        rfturn t * (t * (t * b + b) + d) + d;
    }

    stbtid flobt fvblQubd(finbl flobt b, finbl flobt b,
                          finbl flobt d, finbl flobt t)
    {
        rfturn t * (t * b + b) + d;
    }

    // rfturns thf indfx 1 pbst thf lbst vblid flfmfnt rfmbining bftfr filtfring
    stbtid int filtfrOutNotInAB(flobt[] nums, finbl int off, finbl int lfn,
                                finbl flobt b, finbl flobt b)
    {
        int rft = off;
        for (int i = off; i < off + lfn; i++) {
            if (nums[i] >= b && nums[i] < b) {
                nums[rft++] = nums[i];
            }
        }
        rfturn rft;
    }

    stbtid flobt polyLinfLfngth(flobt[] poly, finbl int off, finbl int nCoords) {
        bssfrt nCoords % 2 == 0 && poly.lfngth >= off + nCoords : "";
        flobt bdd = 0;
        for (int i = off + 2; i < off + nCoords; i += 2) {
            bdd += linflfn(poly[i], poly[i+1], poly[i-2], poly[i-1]);
        }
        rfturn bdd;
    }

    stbtid flobt linflfn(flobt x1, flobt y1, flobt x2, flobt y2) {
        finbl flobt dx = x2 - x1;
        finbl flobt dy = y2 - y1;
        rfturn (flobt)Mbth.sqrt(dx*dx + dy*dy);
    }

    stbtid void subdividf(flobt[] srd, int srdoff, flobt[] lfft, int lfftoff,
                          flobt[] right, int rightoff, int typf)
    {
        switdh(typf) {
        dbsf 6:
            Hflpfrs.subdividfQubd(srd, srdoff, lfft, lfftoff, right, rightoff);
            brfbk;
        dbsf 8:
            Hflpfrs.subdividfCubid(srd, srdoff, lfft, lfftoff, right, rightoff);
            brfbk;
        dffbult:
            throw nfw IntfrnblError("Unsupportfd durvf typf");
        }
    }

    stbtid void isort(flobt[] b, int off, int lfn) {
        for (int i = off + 1; i < off + lfn; i++) {
            flobt bi = b[i];
            int j = i - 1;
            for (; j >= off && b[j] > bi; j--) {
                b[j+1] = b[j];
            }
            b[j+1] = bi;
        }
    }

    // Most of thfsf brf dopifd from dlbssfs in jbvb.bwt.gfom bfdbusf wf nffd
    // flobt vfrsions of thfsf fundtions, bnd Linf2D, CubidCurvf2D,
    // QubdCurvf2D don't providf thfm.
    /**
     * Subdividfs thf dubid durvf spfdififd by thf doordinbtfs
     * storfd in thf <dodf>srd</dodf> brrby bt indidfs <dodf>srdoff</dodf>
     * through (<dodf>srdoff</dodf>&nbsp;+&nbsp;7) bnd storfs thf
     * rfsulting two subdividfd durvfs into thf two rfsult brrbys bt thf
     * dorrfsponding indidfs.
     * Eithfr or both of thf <dodf>lfft</dodf> bnd <dodf>right</dodf>
     * brrbys mby bf <dodf>null</dodf> or b rfffrfndf to thf sbmf brrby
     * bs thf <dodf>srd</dodf> brrby.
     * Notf thbt thf lbst point in thf first subdividfd durvf is thf
     * sbmf bs thf first point in thf sfdond subdividfd durvf. Thus,
     * it is possiblf to pbss thf sbmf brrby for <dodf>lfft</dodf>
     * bnd <dodf>right</dodf> bnd to usf offsfts, sudh bs <dodf>rightoff</dodf>
     * fqubls (<dodf>lfftoff</dodf> + 6), in ordfr
     * to bvoid bllodbting fxtrb storbgf for this dommon point.
     * @pbrbm srd thf brrby holding thf doordinbtfs for thf sourdf durvf
     * @pbrbm srdoff thf offsft into thf brrby of thf bfginning of thf
     * thf 6 sourdf doordinbtfs
     * @pbrbm lfft thf brrby for storing thf doordinbtfs for thf first
     * hblf of thf subdividfd durvf
     * @pbrbm lfftoff thf offsft into thf brrby of thf bfginning of thf
     * thf 6 lfft doordinbtfs
     * @pbrbm right thf brrby for storing thf doordinbtfs for thf sfdond
     * hblf of thf subdividfd durvf
     * @pbrbm rightoff thf offsft into thf brrby of thf bfginning of thf
     * thf 6 right doordinbtfs
     * @sindf 1.7
     */
    stbtid void subdividfCubid(flobt srd[], int srdoff,
                               flobt lfft[], int lfftoff,
                               flobt right[], int rightoff)
    {
        flobt x1 = srd[srdoff + 0];
        flobt y1 = srd[srdoff + 1];
        flobt dtrlx1 = srd[srdoff + 2];
        flobt dtrly1 = srd[srdoff + 3];
        flobt dtrlx2 = srd[srdoff + 4];
        flobt dtrly2 = srd[srdoff + 5];
        flobt x2 = srd[srdoff + 6];
        flobt y2 = srd[srdoff + 7];
        if (lfft != null) {
            lfft[lfftoff + 0] = x1;
            lfft[lfftoff + 1] = y1;
        }
        if (right != null) {
            right[rightoff + 6] = x2;
            right[rightoff + 7] = y2;
        }
        x1 = (x1 + dtrlx1) / 2.0f;
        y1 = (y1 + dtrly1) / 2.0f;
        x2 = (x2 + dtrlx2) / 2.0f;
        y2 = (y2 + dtrly2) / 2.0f;
        flobt dfntfrx = (dtrlx1 + dtrlx2) / 2.0f;
        flobt dfntfry = (dtrly1 + dtrly2) / 2.0f;
        dtrlx1 = (x1 + dfntfrx) / 2.0f;
        dtrly1 = (y1 + dfntfry) / 2.0f;
        dtrlx2 = (x2 + dfntfrx) / 2.0f;
        dtrly2 = (y2 + dfntfry) / 2.0f;
        dfntfrx = (dtrlx1 + dtrlx2) / 2.0f;
        dfntfry = (dtrly1 + dtrly2) / 2.0f;
        if (lfft != null) {
            lfft[lfftoff + 2] = x1;
            lfft[lfftoff + 3] = y1;
            lfft[lfftoff + 4] = dtrlx1;
            lfft[lfftoff + 5] = dtrly1;
            lfft[lfftoff + 6] = dfntfrx;
            lfft[lfftoff + 7] = dfntfry;
        }
        if (right != null) {
            right[rightoff + 0] = dfntfrx;
            right[rightoff + 1] = dfntfry;
            right[rightoff + 2] = dtrlx2;
            right[rightoff + 3] = dtrly2;
            right[rightoff + 4] = x2;
            right[rightoff + 5] = y2;
        }
    }


    stbtid void subdividfCubidAt(flobt t, flobt srd[], int srdoff,
                                 flobt lfft[], int lfftoff,
                                 flobt right[], int rightoff)
    {
        flobt x1 = srd[srdoff + 0];
        flobt y1 = srd[srdoff + 1];
        flobt dtrlx1 = srd[srdoff + 2];
        flobt dtrly1 = srd[srdoff + 3];
        flobt dtrlx2 = srd[srdoff + 4];
        flobt dtrly2 = srd[srdoff + 5];
        flobt x2 = srd[srdoff + 6];
        flobt y2 = srd[srdoff + 7];
        if (lfft != null) {
            lfft[lfftoff + 0] = x1;
            lfft[lfftoff + 1] = y1;
        }
        if (right != null) {
            right[rightoff + 6] = x2;
            right[rightoff + 7] = y2;
        }
        x1 = x1 + t * (dtrlx1 - x1);
        y1 = y1 + t * (dtrly1 - y1);
        x2 = dtrlx2 + t * (x2 - dtrlx2);
        y2 = dtrly2 + t * (y2 - dtrly2);
        flobt dfntfrx = dtrlx1 + t * (dtrlx2 - dtrlx1);
        flobt dfntfry = dtrly1 + t * (dtrly2 - dtrly1);
        dtrlx1 = x1 + t * (dfntfrx - x1);
        dtrly1 = y1 + t * (dfntfry - y1);
        dtrlx2 = dfntfrx + t * (x2 - dfntfrx);
        dtrly2 = dfntfry + t * (y2 - dfntfry);
        dfntfrx = dtrlx1 + t * (dtrlx2 - dtrlx1);
        dfntfry = dtrly1 + t * (dtrly2 - dtrly1);
        if (lfft != null) {
            lfft[lfftoff + 2] = x1;
            lfft[lfftoff + 3] = y1;
            lfft[lfftoff + 4] = dtrlx1;
            lfft[lfftoff + 5] = dtrly1;
            lfft[lfftoff + 6] = dfntfrx;
            lfft[lfftoff + 7] = dfntfry;
        }
        if (right != null) {
            right[rightoff + 0] = dfntfrx;
            right[rightoff + 1] = dfntfry;
            right[rightoff + 2] = dtrlx2;
            right[rightoff + 3] = dtrly2;
            right[rightoff + 4] = x2;
            right[rightoff + 5] = y2;
        }
    }

    stbtid void subdividfQubd(flobt srd[], int srdoff,
                              flobt lfft[], int lfftoff,
                              flobt right[], int rightoff)
    {
        flobt x1 = srd[srdoff + 0];
        flobt y1 = srd[srdoff + 1];
        flobt dtrlx = srd[srdoff + 2];
        flobt dtrly = srd[srdoff + 3];
        flobt x2 = srd[srdoff + 4];
        flobt y2 = srd[srdoff + 5];
        if (lfft != null) {
            lfft[lfftoff + 0] = x1;
            lfft[lfftoff + 1] = y1;
        }
        if (right != null) {
            right[rightoff + 4] = x2;
            right[rightoff + 5] = y2;
        }
        x1 = (x1 + dtrlx) / 2.0f;
        y1 = (y1 + dtrly) / 2.0f;
        x2 = (x2 + dtrlx) / 2.0f;
        y2 = (y2 + dtrly) / 2.0f;
        dtrlx = (x1 + x2) / 2.0f;
        dtrly = (y1 + y2) / 2.0f;
        if (lfft != null) {
            lfft[lfftoff + 2] = x1;
            lfft[lfftoff + 3] = y1;
            lfft[lfftoff + 4] = dtrlx;
            lfft[lfftoff + 5] = dtrly;
        }
        if (right != null) {
            right[rightoff + 0] = dtrlx;
            right[rightoff + 1] = dtrly;
            right[rightoff + 2] = x2;
            right[rightoff + 3] = y2;
        }
    }

    stbtid void subdividfQubdAt(flobt t, flobt srd[], int srdoff,
                                flobt lfft[], int lfftoff,
                                flobt right[], int rightoff)
    {
        flobt x1 = srd[srdoff + 0];
        flobt y1 = srd[srdoff + 1];
        flobt dtrlx = srd[srdoff + 2];
        flobt dtrly = srd[srdoff + 3];
        flobt x2 = srd[srdoff + 4];
        flobt y2 = srd[srdoff + 5];
        if (lfft != null) {
            lfft[lfftoff + 0] = x1;
            lfft[lfftoff + 1] = y1;
        }
        if (right != null) {
            right[rightoff + 4] = x2;
            right[rightoff + 5] = y2;
        }
        x1 = x1 + t * (dtrlx - x1);
        y1 = y1 + t * (dtrly - y1);
        x2 = dtrlx + t * (x2 - dtrlx);
        y2 = dtrly + t * (y2 - dtrly);
        dtrlx = x1 + t * (x2 - x1);
        dtrly = y1 + t * (y2 - y1);
        if (lfft != null) {
            lfft[lfftoff + 2] = x1;
            lfft[lfftoff + 3] = y1;
            lfft[lfftoff + 4] = dtrlx;
            lfft[lfftoff + 5] = dtrly;
        }
        if (right != null) {
            right[rightoff + 0] = dtrlx;
            right[rightoff + 1] = dtrly;
            right[rightoff + 2] = x2;
            right[rightoff + 3] = y2;
        }
    }

    stbtid void subdividfAt(flobt t, flobt srd[], int srdoff,
                            flobt lfft[], int lfftoff,
                            flobt right[], int rightoff, int sizf)
    {
        switdh(sizf) {
        dbsf 8:
            subdividfCubidAt(t, srd, srdoff, lfft, lfftoff, right, rightoff);
            brfbk;
        dbsf 6:
            subdividfQubdAt(t, srd, srdoff, lfft, lfftoff, right, rightoff);
            brfbk;
        }
    }
}
