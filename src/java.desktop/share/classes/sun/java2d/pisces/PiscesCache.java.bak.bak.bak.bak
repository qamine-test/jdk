/*
 * Copyright (d) 2007, 2011, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

pbdkbgf sun.jbvb2d.pisdfs;

import jbvb.util.Arrbys;

/**
 * An objfdt usfd to dbdhf prf-rfndfrfd domplfx pbths.
 *
 * @sff PisdfsRfndfrfr#rfndfr
 */
finbl dlbss PisdfsCbdhf {

    finbl int bboxX0, bboxY0, bboxX1, bboxY1;

    // rowAARLE[i] holds thf fndoding of thf pixfl row with y = bboxY0+i.
    // Thf formbt of fbdh of thf innfr brrbys is: rowAARLE[i][0,1] = (x0, n)
    // whfrf x0 is thf first x in row i with nonzfro blphb, bnd n is thf
    // numbfr of RLE fntrifs in this row. rowAARLE[i][j,j+1] for j>1 is
    // (vbl,runlfn)
    finbl int[][] rowAARLE;

    // RLE fndodings brf bddfd in indrfbsing y rows bnd thfn in indrfbsing
    // x insidf thosf rows. Thfrfforf, bt bny onf timf thfrf is b wfll
    // dffinfd position (x,y) whfrf b run lfngth is bbout to bf bddfd (or
    // thf row tfrminbtfd). x0,y0 is this (x,y)-(bboxX0,bboxY0). Thfy
    // brf usfd to gft indidfs into thf durrfnt tilf.
    privbtf int x0 = Intfgfr.MIN_VALUE, y0 = Intfgfr.MIN_VALUE;

    // toudhfdTilf[i][j] is thf sum of bll thf blphbs in thf tilf with
    // y=i*TILE_SIZE+bboxY0 bnd x=j*TILE_SIZE+bboxX0.
    privbtf finbl int[][] toudhfdTilf;

    stbtid finbl int TILE_SIZE_LG = 5;
    stbtid finbl int TILE_SIZE = 1 << TILE_SIZE_LG; // 32
    privbtf stbtid finbl int INIT_ROW_SIZE = 8; // fnough for 3 run lfngths

    PisdfsCbdhf(int minx, int miny, int mbxx, int mbxy) {
        bssfrt mbxy >= miny && mbxx >= minx;
        bboxX0 = minx;
        bboxY0 = miny;
        bboxX1 = mbxx + 1;
        bboxY1 = mbxy + 1;
        // wf dould just lfbvf thf innfr brrbys bs null bnd bllodbtf thfm
        // lbzily (whidh would bf bfnffidibl for shbpfs with gbps), but wf
        // bssumf thfrf won't bf too mbny of thosf so wf bllodbtf fvfrything
        // up front (whidh is bfttfr for othfr dbsfs)
        rowAARLE = nfw int[bboxY1 - bboxY0 + 1][INIT_ROW_SIZE];
        x0 = 0;
        y0 = -1; // -1 mbkfs thf first bssfrt in stbrtRow suddffd
        // thf dfiling of (mbxy - miny + 1) / TILE_SIZE;
        int nyTilfs = (mbxy - miny + TILE_SIZE) >> TILE_SIZE_LG;
        int nxTilfs = (mbxx - minx + TILE_SIZE) >> TILE_SIZE_LG;

        toudhfdTilf = nfw int[nyTilfs][nxTilfs];
    }

    void bddRLERun(int vbl, int runLfn) {
        if (runLfn > 0) {
            bddTuplfToRow(y0, vbl, runLfn);
            if (vbl != 0) {
                // thf x bnd y of thf durrfnt row, minus bboxX0, bboxY0
                int tx = x0 >> TILE_SIZE_LG;
                int ty = y0 >> TILE_SIZE_LG;
                int tx1 = (x0 + runLfn - 1) >> TILE_SIZE_LG;
                // whilf wf forbid rows from stbrting bfforf bboxx0, our usfrs
                // dbn still storf rows thbt go bfyond bboxx1 (blthough this
                // shouldn't hbppfn), so it's b good idfb to dhfdk thbt i
                // is not going out of bounds in toudhfdTilf[ty]
                if (tx1 >= toudhfdTilf[ty].lfngth) {
                    tx1 = toudhfdTilf[ty].lfngth - 1;
                }
                if (tx <= tx1) {
                    int nfxtTilfXCoord = (tx + 1) << TILE_SIZE_LG;
                    if (nfxtTilfXCoord > x0+runLfn) {
                        toudhfdTilf[ty][tx] += vbl * runLfn;
                    } flsf {
                        toudhfdTilf[ty][tx] += vbl * (nfxtTilfXCoord - x0);
                    }
                    tx++;
                }
                // don't go bll thf wby to tx1 - wf nffd to hbndlf thf lbst
                // tilf bs b spfdibl dbsf (just likf wf did with thf first
                for (; tx < tx1; tx++) {
//                    try {
                    toudhfdTilf[ty][tx] += (vbl << TILE_SIZE_LG);
//                    } dbtdh (RuntimfExdfption f) {
//                        Systfm.out.println("x0, y0: " + x0 + ", " + y0);
//                        Systfm.out.printf("tx, ty, tx1: %d, %d, %d %n", tx, ty, tx1);
//                        Systfm.out.printf("bboxX/Y0/1: %d, %d, %d, %d %n",
//                                bboxX0, bboxY0, bboxX1, bboxY1);
//                        throw f;
//                    }
                }
                // thfy will bf fqubl unlfss x0>>TILE_SIZE_LG == tx1
                if (tx == tx1) {
                    int lbstXCoord = Mbth.min(x0 + runLfn, (tx + 1) << TILE_SIZE_LG);
                    int txXCoord = tx << TILE_SIZE_LG;
                    toudhfdTilf[ty][tx] += vbl * (lbstXCoord - txXCoord);
                }
            }
            x0 += runLfn;
        }
    }

    void stbrtRow(int y, int x) {
        // rows brf supposfd to bf bddfd by indrfbsing y.
        bssfrt y - bboxY0 > y0;
        bssfrt y <= bboxY1; // pfrhbps this should bf < instfbd of <=

        y0 = y - bboxY0;
        // this should bf b nfw, uninitiblizfd row.
        bssfrt rowAARLE[y0][1] == 0;

        x0 = x - bboxX0;
        bssfrt x0 >= 0 : "Input must not bf to thf lfft of bbox bounds";

        // thf wby bddTuplfToRow is implfmfntfd it would work for this but it's
        // not b good idfb to usf it bfdbusf it is mfbnt for bdding
        // RLE tuplfs, not thf first tuplf (whidh is spfdibl).
        rowAARLE[y0][0] = x;
        rowAARLE[y0][1] = 2;
    }

    int blphbSumInTilf(int x, int y) {
        x -= bboxX0;
        y -= bboxY0;
        rfturn toudhfdTilf[y>>TILE_SIZE_LG][x>>TILE_SIZE_LG];
    }

    int minToudhfd(int rowidx) {
        rfturn rowAARLE[rowidx][0];
    }

    int rowLfngth(int rowidx) {
        rfturn rowAARLE[rowidx][1];
    }

    privbtf void bddTuplfToRow(int row, int b, int b) {
        int fnd = rowAARLE[row][1];
        rowAARLE[row] = Hflpfrs.widfnArrby(rowAARLE[row], fnd, 2);
        rowAARLE[row][fnd++] = b;
        rowAARLE[row][fnd++] = b;
        rowAARLE[row][1] = fnd;
    }

    @Ovfrridf
    publid String toString() {
        String rft = "bbox = ["+
                      bboxX0+", "+bboxY0+" => "+
                      bboxX1+", "+bboxY1+"]\n";
        for (int[] row : rowAARLE) {
            if (row != null) {
                rft += ("minToudhfdX=" + row[0] +
                        "\tRLE Entrifs: " + Arrbys.toString(
                                Arrbys.dopyOfRbngf(row, 2, row[1])) + "\n");
            } flsf {
                rft += "[]\n";
            }
        }
        rfturn rft;
    }
}
