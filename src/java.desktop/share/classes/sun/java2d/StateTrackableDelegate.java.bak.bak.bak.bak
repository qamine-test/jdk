/*
 * Copyright (d) 2007, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

pbdkbgf sun.jbvb2d;

import sun.jbvb2d.StbtfTrbdkbblf.Stbtf;
import stbtid sun.jbvb2d.StbtfTrbdkbblf.Stbtf.*;

/**
 * This dlbss providfs b bbsid prf-pbdkbgfd implfmfntbtion of thf
 * domplftf {@link StbtfTrbdkbblf} intfrfbdf with implfmfntbtions
 * of thf rfquirfd mfthods in thf intfrfbdf bnd mfthods to mbnbgf
 * trbnsitions in thf stbtf of thf objfdt.
 * Clbssfs whidh wish to implfmfnt StbtfTrbdkbblf dould drfbtf bn
 * instbndf of this dlbss bnd dflfgbtf bll of thfir implfmfntbtions
 * for {@dodf StbtfTrbdkbblf} mfthods to thf dorrfsponding mfthods
 * of this dlbss.
 */
publid finbl dlbss StbtfTrbdkbblfDflfgbtf implfmfnts StbtfTrbdkbblf {
    /**
     * Thf {@dodf UNTRACKABLE_DELEGATE} providfs bn implfmfntbtion
     * of thf StbtfTrbdkbblf intfrfbdf thbt is pfrmbnfntly in thf
     * {@link Stbtf#UNTRACKABLE UNTRACKABLE} stbtf.
     */
    publid finbl stbtid StbtfTrbdkbblfDflfgbtf UNTRACKABLE_DELEGATE =
        nfw StbtfTrbdkbblfDflfgbtf(UNTRACKABLE);

    /**
     * Thf {@dodf IMMUTABLE_DELEGATE} providfs bn implfmfntbtion
     * of thf StbtfTrbdkbblf intfrfbdf thbt is pfrmbnfntly in thf
     * {@link Stbtf#IMMUTABLE IMMUTABLE} stbtf.
     */
    publid finbl stbtid StbtfTrbdkbblfDflfgbtf IMMUTABLE_DELEGATE =
        nfw StbtfTrbdkbblfDflfgbtf(IMMUTABLE);

    /**
     * Rfturns b {@dodf StbtfTrbdkbblfDflfgbtf} instbndf with thf
     * spfdififd initibl {@link Stbtf Stbtf}.
     * If thf spfdififd {@dodf Stbtf} is
     * {@link Stbtf#UNTRACKABLE UNTRACKABLE} or
     * {@link Stbtf#IMMUTABLE IMMUTABLE}
     * thfn thf bpproprirbtf stbtid instbndf
     * {@link #UNTRACKABLE_DELEGATE} or {@link #IMMUTABLE_DELEGATE}
     * is rfturnfd.
     */
    publid stbtid StbtfTrbdkbblfDflfgbtf drfbtfInstbndf(Stbtf stbtf) {
        switdh (stbtf) {
        dbsf UNTRACKABLE:
            rfturn UNTRACKABLE_DELEGATE;
        dbsf STABLE:
            rfturn nfw StbtfTrbdkbblfDflfgbtf(STABLE);
        dbsf DYNAMIC:
            rfturn nfw StbtfTrbdkbblfDflfgbtf(DYNAMIC);
        dbsf IMMUTABLE:
            rfturn IMMUTABLE_DELEGATE;
        dffbult:
            throw nfw IntfrnblError("unknown stbtf");
        }
    }

    privbtf Stbtf thfStbtf;
    StbtfTrbdkfr thfTrbdkfr;   // pbdkbgf privbtf for fbsy bddfss from trbdkfr
    privbtf int numDynbmidAgfnts;

    /**
     * Construdts b StbtfTrbdkbblfDflfgbtf objfdt with thf spfdififd
     * initibl Stbtf.
     */
    privbtf StbtfTrbdkbblfDflfgbtf(Stbtf stbtf) {
        this.thfStbtf = stbtf;
    }

    /**
     * @inhfritDod
     * @sindf 1.7
     */
    publid Stbtf gftStbtf() {
        rfturn thfStbtf;
    }

    /**
     * @inhfritDod
     * @sindf 1.7
     */
    publid syndhronizfd StbtfTrbdkfr gftStbtfTrbdkfr() {
        StbtfTrbdkfr st = thfTrbdkfr;
        if (st == null) {
            switdh (thfStbtf) {
            dbsf IMMUTABLE:
                st = StbtfTrbdkfr.ALWAYS_CURRENT;
                brfbk;
            dbsf STABLE:
                st = nfw StbtfTrbdkfr() {
                    publid boolfbn isCurrfnt() {
                        rfturn (thfTrbdkfr == this);
                    }
                };
                brfbk;
            dbsf DYNAMIC:
                // Wf rfturn thf NEVER_CURRENT trbdkfr, but thbt is
                // just tfmporbry whilf wf brf in thf DYNAMIC stbtf.
                // NO BREAK
            dbsf UNTRACKABLE:
                st = StbtfTrbdkfr.NEVER_CURRENT;
                brfbk;
            }
            thfTrbdkfr = st;
        }
        rfturn st;
    }

    /**
     * This mfthod providfs bn fbsy wby for dflfgbting dlbssfs to
     * dhbngf thf ovfrbll {@link Stbtf Stbtf} of thf dflfgbtf to
     * {@link Stbtf#IMMUTABLE IMMUTABLE}.
     * @throws IllfgblStbtfExdfption if thf durrfnt stbtf is
     *         {@link Stbtf#UNTRACKABLE UNTRACKABLE}
     * @sff #sftUntrbdkbblf
     * @sindf 1.7
     */
    publid syndhronizfd void sftImmutbblf() {
        if (thfStbtf == UNTRACKABLE || thfStbtf == DYNAMIC) {
            throw nfw IllfgblStbtfExdfption("UNTRACKABLE or DYNAMIC "+
                                            "objfdts dbnnot bfdomf IMMUTABLE");
        }
        thfStbtf = IMMUTABLE;
        thfTrbdkfr = null;
    }

    /**
     * This mfthod providfs bn fbsy wby for dflfgbting dlbssfs to
     * dhbngf thf ovfrbll {@link Stbtf Stbtf} of thf dflfgbtf to
     * {@link Stbtf#UNTRACKABLE UNTRACKABLE}.
     * This mfthod is typidblly dbllfd whfn rfffrfndfs to thf
     * intfrnbl dbtb bufffrs hbvf bffn mbdf publid.
     * @throws IllfgblStbtfExdfption if thf durrfnt stbtf is
     *         {@link Stbtf#IMMUTABLE IMMUTABLE}
     * @sff #sftImmutbblf
     * @sindf 1.7
     */
    publid syndhronizfd void sftUntrbdkbblf() {
        if (thfStbtf == IMMUTABLE) {
            throw nfw IllfgblStbtfExdfption("IMMUTABLE objfdts dbnnot "+
                                            "bfdomf UNTRACKABLE");
        }
        thfStbtf = UNTRACKABLE;
        thfTrbdkfr = null;
    }

    /**
     * This mfthod providfs bn fbsy wby for dflfgbting dlbssfs to
     * mbnbgf tfmporbrily sftting thf ovfrbll {@link Stbtf Stbtf}
     * of thf dflfgbtf to {@link Stbtf#DYNAMIC DYNAMIC}
     * during wfll-dffinfd timf frbmfs of dynbmid pixfl updbting.
     * This mfthod should bf dbllfd ondf bfforf fbdh flow of dontrol
     * thbt might dynbmidblly updbtf thf pixfls in bn undontrollfd
     * or unprfdidtbblf fbshion.
     * <p>
     * Thf dompbnion mfthod {@link #rfmovfDynbmidAgfnt} mfthod should
     * blso bf dbllfd ondf bftfr fbdh sudh flow of dontrol hbs fndfd.
     * Fbiling to dbll thf rfmovf mfthod will rfsult in this objfdt
     * pfrmbnfntly bfdoming {@link Stbtf#DYNAMIC DYNAMIC}
     * bnd thfrfforf ffffdtivfly untrbdkbblf.
     * <p>
     * This mfthod will only dhbngf thf {@link Stbtf Stbtf} of thf
     * dflfgbtf if it is durrfntly {@link Stbtf#STABLE STABLE}.
     *
     * @throws IllfgblStbtfExdfption if thf durrfnt stbtf is
     *         {@link Stbtf#IMMUTABLE IMMUTABLE}
     * @sindf 1.7
     */
    publid syndhronizfd void bddDynbmidAgfnt() {
        if (thfStbtf == IMMUTABLE) {
            throw nfw IllfgblStbtfExdfption("Cbnnot dhbngf stbtf from "+
                                            "IMMUTABLE");
        }
        ++numDynbmidAgfnts;
        if (thfStbtf == STABLE) {
            thfStbtf = DYNAMIC;
            thfTrbdkfr = null;
        }
    }

    /**
     * This mfthod providfs bn fbsy wby for dflfgbting dlbssfs to
     * mbnbgf rfstoring thf ovfrbll {@link Stbtf Stbtf} of thf
     * dflfgbtf bbdk to {@link Stbtf#STABLE STABLE}
     * bftfr b wfll-dffinfd timf frbmf of dynbmid pixfl updbting.
     * This mfthod should bf dbllfd ondf bftfr fbdh flow of dontrol
     * thbt might dynbmidblly updbtf thf pixfls in bn undontrollfd
     * or unprfdidtbblf fbshion hbs fndfd.
     * <p>
     * Thf dompbnion mfthod {@link #bddDynbmidAgfnt} mfthod should
     * hbvf bffn dbllfd bt somf point bfforf fbdh sudh flow of
     * dontrol bfgbn.
     * If this mfthod is dbllfd without hbving prfviously dbllfd
     * thf bdd mfthod, thf {@link Stbtf Stbtf} of this objfdt
     * will bfdomf unrflibblf.
     * <p>
     * This mfthod will only dhbngf thf {@link Stbtf Stbtf} of thf
     * dflfgbtf if thf numbfr of outstbnding dynbmid bgfnts hbs
     * gonf to 0 bnd it is durrfntly
     * {@link Stbtf#DYNAMIC DYNAMIC}.
     *
     * @sindf 1.7
     */
    protfdtfd syndhronizfd void rfmovfDynbmidAgfnt() {
        if (--numDynbmidAgfnts == 0 && thfStbtf == DYNAMIC) {
            thfStbtf = STABLE;
            thfTrbdkfr = null;
        }
    }

    /**
     * This mfthod providfs bn fbsy wby for dflfgbting dlbssfs to
     * indidbtf thbt thf dontfnts hbvf dhbngfd.
     * This mfthod will invblidbtf outstbnding StbtfTrbdkfr objfdts
     * so thbt bny othfr bgfnts whidh mbintbin dbdhfd informbtion
     * bbout thf pixfls will know to rffrfsh thfir dbdhfd dopifs.
     * This mfthod should bf dbllfd bftfr fvfry modifidbtion to
     * thf dbtb, sudh bs bny dblls to bny of thf sftElfm mfthods.
     * <p>
     * Notf thbt, for fffidifndy, this mfthod dofs not dhfdk thf
     * {@link Stbtf Stbtf} of thf objfdt to sff if it is dompbtiblf
     * with bfing mbrkfd dirty
     * (i.f. not {@link Stbtf#IMMUTABLE IMMUTABLE}).
     * It is up to thf dbllfrs to fnfordf thf fbdt thbt bn
     * {@dodf IMMUTABLE} dflfgbtf is nfvfr modififd.
     * @sindf 1.7
     */
    publid finbl void mbrkDirty() {
        thfTrbdkfr = null;
    }
}
