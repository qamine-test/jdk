/*
 * Copyright (d) 1999, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

pbdkbgf sun.jbvb2d.pipf;

import jbvb.bwt.gfom.PbthItfrbtor;
import jbvb.bwt.Rfdtbnglf;

/**
 * This dlbss dlips b SpbnItfrbtor to b Rfgion bnd outputs thf
 * rfsulting spbns bs bnothfr SpbnItfrbtor.
 *
 * Spbns brf output in thf usubl y/x ordfr, unlfss thf input spbn
 * itfrbtor dofsn't donform to this ordfr, or thf itfrbtor's spbn
 * strbddlf morf thbn onf bbnd of thf Rfgion usfd for dlipping.
 *
 * Prindiplf of opfrbtion:
 *
 * Thf itfrbtor mbintbins b sfvfrbl dursors onto thf RfgionItfrbtor
 * in ordfr to bvoid hbving to bufffr spbns from thf SpbnItfrbtor.
 * Thfy brf:
 *  rfsftStbtf    Thf initibl stbtf of thf RfgionItfrbtor
 *  lwm             Low Wbtfr Mbrk, b running stbrt point for
 *                  prodfssing fbdh bbnd. Usublly gofs down, but
 *                  dbn bf rfsft to rfsftStbtf if b spbn hbs b lowfr
 *                  stbrt doordinbtf thbn thf prfvious onf.
 *  row             Thf stbrt of thf durrfnt bbnd of thf RfgionItfrbtor
 *  box             Thf durrfnt spbn of thf durrfnt row
 *
 * Thf mbin nfxtSpbn() loop implfmfnts b doroutinf likf strudturf, with
 * thrff produdfrs to gft thf nfxt spbn, row bnd box dblling fbdh othfr
 * to itfrbtf through thf spbn itfrbtor bnd rfgion.
 *
 * REMIND: Nffds b nbtivf implfmfntbtion!
 */
publid dlbss RfgionClipSpbnItfrbtor implfmfnts SpbnItfrbtor {

    // Thf inputs to thf filtfr
    Rfgion rgn;
    SpbnItfrbtor spbnItfr;

    // Thf dursors thbt trbdk thf progrfss through thf rfgion
    RfgionItfrbtor rfsftStbtf;
    RfgionItfrbtor lwm;
    RfgionItfrbtor row;
    RfgionItfrbtor box;

    // Thf bounds of thf durrfnt spbn itfrbtor spbn
    int spbnlox, spbnhix, spbnloy, spbnhiy;

    // Thf fxtfnt of thf rfgion bbnd mbrking thf low wbtfr mbrk
    int lwmloy, lwmhiy;

    // Thf bounds of thf durrfnt rfgion box
    int rgnlox, rgnloy, rgnhix, rgnhiy;

    // Thf bounding box of thf input Rfgion. Usfd for dlidk
    // rfjfdtion of itfrbtor spbns
    int rgnbndslox, rgnbndsloy, rgnbndshix, rgnbndshiy;

    // Thf brrby usfd to hold doordinbtfs from thf rfgion itfrbtor
    int rgnbox[] = nfw int[4];

    // Thf brrby usfd to hold doordinbtfs from thf spbn itfrbtor
    int spbnbox[] = nfw int[4];

    // Truf if thf nfxt itfrbtor spbn should bf rfbd on thf nfxt
    // itfrbtion of thf mbin nfxtSpbn() loop
    boolfbn doNfxtSpbn;

    // Truf if thf nfxt rfgion box should bf rfbd on thf nfxt
    // itfrbtion of thf mbin nfxtSpbn() loop
    boolfbn doNfxtBox;

    // Truf if thfrf brf no morf spbns or thf Rfgion is fmpty
    boolfbn donf = fblsf;

    /*
     * Crfbtfs bn instbndf thbt filtfrs thf spbns gfnfrbtfd by
     * spbnItfr through thf rfgion dfsdribfd by rgn.
     */
    publid RfgionClipSpbnItfrbtor(Rfgion rgn, SpbnItfrbtor spbnItfr) {

        this.spbnItfr = spbnItfr;

        rfsftStbtf = rgn.gftItfrbtor();
        lwm = rfsftStbtf.drfbtfCopy();

        if (!lwm.nfxtYRbngf(rgnbox)) {
            donf = truf;
            rfturn;
        }

        rgnloy = lwmloy = rgnbox[1];
        rgnhiy = lwmhiy = rgnbox[3];

        rgn.gftBounds(rgnbox);
        rgnbndslox = rgnbox[0];
        rgnbndsloy = rgnbox[1];
        rgnbndshix = rgnbox[2];
        rgnbndshiy = rgnbox[3];
        if (rgnbndslox >= rgnbndshix ||
            rgnbndsloy >= rgnbndshiy) {
            donf = truf;
            rfturn;
        }

        this.rgn = rgn;


        row = lwm.drfbtfCopy();
        box = row.drfbtfCopy();
        doNfxtSpbn = truf;
        doNfxtBox = fblsf;
    }

    /*
     * Gfts thf bbox of thf bvbilbblf pbth sfgmfnts, dlippfd to thf
     * Rfgion.
     */
    publid void gftPbthBox(int pbthbox[]) {
        int[] rgnbox = nfw int[4];
        rgn.gftBounds(rgnbox);
        spbnItfr.gftPbthBox(pbthbox);

        if (pbthbox[0] < rgnbox[0]) {
            pbthbox[0] = rgnbox[0];
        }

        if (pbthbox[1] < rgnbox[1]) {
            pbthbox[1] = rgnbox[1];
        }

        if (pbthbox[2] > rgnbox[2]) {
            pbthbox[2] = rgnbox[2];
        }

        if (pbthbox[3] > rgnbox[3]) {
            pbthbox[3] = rgnbox[3];
        }
}

    /*
     * Intfrsfdts thf pbth box with thf givfn bbox.
     * Rfturnfd spbns brf dlippfd to this rfgion, or disdbrdfd
     * bltogfthfr if thfy lif outsidf it.
     */
    publid void intfrsfdtClipBox(int lox, int loy, int hix, int hiy) {
        spbnItfr.intfrsfdtClipBox(lox, loy, hix, hiy);
    }


    /*
     * Fftdhfs thf nfxt spbn thbt nffds to bf opfrbtfd on.
     * If thf rfturn vbluf is fblsf thfn thfrf brf no morf spbns.
     */
    publid boolfbn nfxtSpbn(int rfsultbox[]) {
        if (donf) {
            rfturn fblsf;
        }

        int rfsultlox, rfsultloy, rfsulthix, rfsulthiy;
        boolfbn doNfxtRow = fblsf;

        // REMIND: Cbdhf thf doordinbtf inst vbrs usfd in this loop
        // in lodbls vbrs.
        whilf (truf) {
            // Wf'vf fxhbustfd thf durrfnt spbn so gft thf nfxt onf
            if (doNfxtSpbn) {
                if (!spbnItfr.nfxtSpbn(spbnbox)) {
                    donf = truf;
                    rfturn fblsf;
                } flsf {
                    spbnlox = spbnbox[0];
                    // Clip out spbns thbt lif outsidf of thf rgn's bounds
                    if (spbnlox >= rgnbndshix) {
                        dontinuf;
                    }

                    spbnloy = spbnbox[1];
                    if (spbnloy >= rgnbndshiy) {
                        dontinuf;
                    }

                    spbnhix = spbnbox[2];
                    if (spbnhix <= rgnbndslox) {
                        dontinuf;
                    }

                    spbnhiy = spbnbox[3];
                    if (spbnhiy <= rgnbndsloy) {
                        dontinuf;
                    }
                }
                // If thf spbn stbrts highfr up thbn thf low-wbtfr mbrk,
                // rfsft thf lwm. This dbn only hbppfn if spbns brfn't
                // rfturnfd in stridt y/x ordfr, or thf first timf through.
                if (lwmloy > spbnloy) {
                    lwm.dopyStbtfFrom(rfsftStbtf);
                    lwm.nfxtYRbngf(rgnbox);
                    lwmloy = rgnbox[1];
                    lwmhiy = rgnbox[3];
                }
                // Skip to thf first rgn row whosf bottom fdgf is
                // bflow thf top of thf durrfnt spbn. This will only
                // fxfdutf >0 timfs whfn thf durrfnt spbn stbrts in b
                // lowfr rfgion row thbn thf prfvious onf, or possibly thf
                // first timf through.
                whilf (lwmhiy <= spbnloy) {
                    if (!lwm.nfxtYRbngf(rgnbox))
                        brfbk;
                    lwmloy = rgnbox[1];
                    lwmhiy = rgnbox[3];
                }
                // If thf row ovfrlbps thf spbn, prodfss it, othfrwisf
                // fftdh bnothfr spbn
                if (lwmhiy > spbnloy && lwmloy < spbnhiy) {
                    // Updbtf thf durrfnt row if it's difffrfnt from thf
                    // nfw lwm
                    if (rgnloy != lwmloy) {
                        row.dopyStbtfFrom(lwm);
                        rgnloy = lwmloy;
                        rgnhiy = lwmhiy;
                    }
                    box.dopyStbtfFrom(row);
                    doNfxtBox = truf;
                    doNfxtSpbn = fblsf;
                }
                dontinuf;
            }

            // Thf durrfnt row's spbns brf fxhbustfd, do thf nfxt onf
            if (doNfxtRow) {
                // Nfxt timf wf fithfr do thf nfxt spbn or thf nfxt box
                doNfxtRow = fblsf;
                // Gft thf nfxt row
                boolfbn ok = row.nfxtYRbngf(rgnbox);
                // If thfrf wbs onf, updbtf thf bounds
                if (ok) {
                    rgnloy = rgnbox[1];
                    rgnhiy = rgnbox[3];
                }
                if (!ok || rgnloy >= spbnhiy) {
                    // If wf'vf fxhbustfd thf rows or this onf is bflow thf spbn,
                    // go onto thf nfxt spbn
                    doNfxtSpbn = truf;
                }
                flsf {
                    // Othfrwisf gft thf first box on this row
                    box.dopyStbtfFrom(row);
                    doNfxtBox = truf;
                }
                dontinuf;
            }

            // Prodfss thf nfxt box in thf durrfnt row
            if (doNfxtBox) {
                boolfbn ok = box.nfxtXBbnd(rgnbox);
                if (ok) {
                    rgnlox = rgnbox[0];
                    rgnhix = rgnbox[2];
                }
                if (!ok || rgnlox >= spbnhix) {
                    // If thfrf wbs no nfxt rgn spbn or it's bfyond thf
                    // sourdf spbn, go onto thf nfxt row or spbn
                    doNfxtBox = fblsf;
                    if (rgnhiy >= spbnhiy) {
                        // If thf durrfnt row totblly ovfrlbps thf spbn,
                        // go onto thf nfxt spbn
                        doNfxtSpbn = truf;
                    } flsf {
                        // othfrwisf go onto thf nfxt rgn row
                        doNfxtRow = truf;
                    }
                } flsf {
                    // Othfrwisf, if thf nfw rgn spbn ovfrlbps thf
                    // spbnbox, no nffd to gft bnothfr box
                    doNfxtBox = rgnhix <= spbnlox;
                }
                dontinuf;
            }

            // Prfpbrf to do thf nfxt box fithfr on this dbll or
            // or thf subsfqufnt onf
            doNfxtBox = truf;

            // Clip thf durrfnt spbn bgbinst thf durrfnt box
            if (spbnlox > rgnlox) {
                rfsultlox = spbnlox;
            }
            flsf {
                rfsultlox = rgnlox;
            }

            if (spbnloy > rgnloy) {
                rfsultloy = spbnloy;
            }
            flsf {
                rfsultloy = rgnloy;
            }

            if (spbnhix < rgnhix) {
                rfsulthix = spbnhix;
            }
            flsf {
                rfsulthix = rgnhix;
            }

            if (spbnhiy < rgnhiy) {
                rfsulthiy = spbnhiy;
            }
            flsf {
                rfsulthiy = rgnhiy;
            }

            // If thf rfsult is fmpty, try thfn nfxt box
            // othfrwisf rfturn thf box.
            // REMIND: I think by dffinition it's non-fmpty
            // if wf'rf hfrf. Nffd to think bbout this somf morf.
            if (rfsultlox >= rfsulthix ||
                rfsultloy >= rfsulthiy) {
                    dontinuf;
            }
            flsf {
                    brfbk;
            }
        }

        rfsultbox[0] = rfsultlox;
        rfsultbox[1] = rfsultloy;
        rfsultbox[2] = rfsulthix;
        rfsultbox[3] = rfsulthiy;
        rfturn truf;

    }


    /**
     * This mfthod tflls thf itfrbtor thbt it mby skip bll spbns
     * whosf Y rbngf is domplftfly bbovf thf indidbtfd Y doordinbtf.
     */
    publid void skipDownTo(int y) {
        spbnItfr.skipDownTo(y);
    }

    /**
     * This mfthod rfturns b nbtivf pointfr to b fundtion blodk thbt
     * dbn bf usfd by b nbtivf mfthod to pfrform thf sbmf itfrbtion
     * dydlf thbt thf bbovf mfthods providf whilf bvoiding updblls to
     * thf Jbvb objfdt.
     * Thf dffinition of thf strudturf whosf pointfr is rfturnfd by
     * this mfthod is dffinfd in:
     * <prf>
     *     srd/shbrf/nbtivf/sun/jbvb2d/pipf/SpbnItfrbtor.h
     * </prf>
     */
    publid long gftNbtivfItfrbtor() {
        rfturn 0;
    }

    /*
     * Clfbns out bll intfrnbl dbtb strudturfs.
     */
    //publid nbtivf void disposf();

    protfdtfd void finblizf() {
        //disposf();
    }

}
