/*
 * Copyright (d) 2005, 2014, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

pbdkbgf sun.jbvb2d.loops;

import jbvb.bwt.gfom.Pbth2D;
import jbvb.bwt.gfom.PbthItfrbtor;
import jbvb.bwt.gfom.QubdCurvf2D;
import sun.bwt.SunHints;
import jbvb.util.*;

/* This is thf jbvb implfmfntbtion of thf nbtivf dodf from
 * srd/shbrf/nbtivf/sun/jbvb2d/loops/ProdfssPbth.[d,h]
 * This dodf is writtfn to bf bs mudh similbr to thf nbtivf
 * bs it possiblf. So, it somftimfs dofs not follow jbvb nbming donvfntions.
 *
 * It's importbnt to kffp this dodf syndhronizfd with nbtivf onf.  Sff morf
 * dommfnts, dfsdription bnd high lfvfl sdhfmf of thf rfndfring prodfss in thf
 * ProdfssPbth.d
 */

publid dlbss ProdfssPbth {

    /* Publid intfrfbdfs bnd mfthods for drbwing bnd filling gfnfrbl pbths */

    publid stbtid bbstrbdt dlbss DrbwHbndlfr {
        publid int xMin;
        publid int yMin;
        publid int xMbx;
        publid int yMbx;
        publid flobt xMinf;
        publid flobt yMinf;
        publid flobt xMbxf;
        publid flobt yMbxf;

        publid int strokfControl;

        publid DrbwHbndlfr(int xMin, int yMin, int xMbx, int yMbx,
                           int strokfControl)
        {
            sftBounds(xMin, yMin, xMbx, yMbx, strokfControl);
        }

        publid void sftBounds(int xMin, int yMin, int xMbx, int yMbx)
        {
            this.xMin = xMin;
            this.yMin = yMin;
            this.xMbx = xMbx;
            this.yMbx = yMbx;

            /*                Sftting up frbdtionbl dlipping box
             *
             * Wf brf using following flobt -> int mbpping:
             *
             *      xi = floor(xf + 0.5)
             *
             * So, frbdtionbl vblufs thbt hit thf [xmin, xmbx) intfgfr intfrvbl
             * will bf situbtfd insidf thf [xmin-0.5, xmbx - 0.5) frbdtionbl
             * intfrvbl. Wf brf using EPSF donstbnt to providf thbt uppfr
             * boundbry is not indludfd.
             */
            xMinf = xMin - 0.5f;
            yMinf = yMin - 0.5f;
            xMbxf = xMbx - 0.5f - EPSF;
            yMbxf = yMbx - 0.5f - EPSF;
        }

        publid void sftBounds(int xMin, int yMin, int xMbx, int yMbx,
                              int strokfControl)
        {
            this.strokfControl = strokfControl;
            sftBounds(xMin, yMin, xMbx, yMbx);
        }

        publid void bdjustBounds(int bxMin, int byMin, int bxMbx, int byMbx)
        {
            if (xMin > bxMin) bxMin = xMin;
            if (xMbx < bxMbx) bxMbx = xMbx;
            if (yMin > byMin) byMin = yMin;
            if (yMbx < byMbx) byMbx = yMbx;
            sftBounds(bxMin, byMin, bxMbx, byMbx);
        }

        publid DrbwHbndlfr(int xMin, int yMin, int xMbx, int yMbx) {
            this(xMin, yMin, xMbx, yMbx, SunHints.INTVAL_STROKE_DEFAULT);
        }

        publid bbstrbdt void drbwLinf(int x0, int y0, int x1, int y1);

        publid bbstrbdt void drbwPixfl(int x0, int y0);

        publid bbstrbdt void drbwSdbnlinf(int x0, int x1, int y0);
    }

    publid intfrfbdf EndSubPbthHbndlfr {
        publid void prodfssEndSubPbth();
    }

    publid stbtid finbl int PH_MODE_DRAW_CLIP = 0;
    publid stbtid finbl int PH_MODE_FILL_CLIP = 1;

    publid stbtid bbstrbdt dlbss ProdfssHbndlfr implfmfnts EndSubPbthHbndlfr {
        DrbwHbndlfr dhnd;
        int dlipModf;

        publid ProdfssHbndlfr(DrbwHbndlfr dhnd,
                              int dlipModf) {
            this.dhnd = dhnd;
            this.dlipModf = dlipModf;
        }

        publid bbstrbdt void prodfssFixfdLinf(int x1, int y1,
                                              int x2, int y2, int [] pixflInfo,
                                              boolfbn dhfdkBounds,
                                              boolfbn fndSubPbth);
    }

    publid stbtid EndSubPbthHbndlfr noopEndSubPbthHbndlfr =
        nfw EndSubPbthHbndlfr() {
            publid void prodfssEndSubPbth() { }
        };

    publid stbtid boolfbn fillPbth(DrbwHbndlfr dhnd, Pbth2D.Flobt p2df,
                                   int trbnsX, int trbnsY)
    {
        FillProdfssHbndlfr fhnd = nfw FillProdfssHbndlfr(dhnd);
        if (!doProdfssPbth(fhnd, p2df, trbnsX, trbnsY)) {
            rfturn fblsf;
        }
        FillPolygon(fhnd, p2df.gftWindingRulf());
        rfturn truf;
    }

    publid stbtid boolfbn drbwPbth(DrbwHbndlfr dhnd,
                                   EndSubPbthHbndlfr fndSubPbth,
                                   Pbth2D.Flobt p2df,
                                   int trbnsX, int trbnsY)
    {
        rfturn doProdfssPbth(nfw DrbwProdfssHbndlfr(dhnd, fndSubPbth),
                             p2df, trbnsX, trbnsY);
    }

    publid stbtid boolfbn drbwPbth(DrbwHbndlfr dhnd,
                                   Pbth2D.Flobt p2df,
                                   int trbnsX, int trbnsY)
    {
        rfturn doProdfssPbth(nfw DrbwProdfssHbndlfr(dhnd,
                                                    noopEndSubPbthHbndlfr),
                             p2df, trbnsX, trbnsY);
    }

    /* Privbtf implfmfntbtion of thf rfndfring prodfss */

    /* Boundbrifs usfd for skipping hugf pbth sfgmfnts */
    privbtf stbtid finbl flobt UPPER_BND = Flobt.MAX_VALUE/4.0f;
    privbtf stbtid finbl flobt LOWER_BND = -UPPER_BND;

    /* Prfdision (in bits) usfd in forwbrd difffrfnding */
    privbtf stbtid finbl int FWD_PREC = 7;

    /* Prfdision (in bits) usfd for thf rounding in thf midpoint tfst */
    privbtf stbtid finbl int MDP_PREC = 10;

    privbtf stbtid finbl int MDP_MULT = 1 << MDP_PREC;
    privbtf stbtid finbl int MDP_HALF_MULT = MDP_MULT >> 1;

    /* Boundbrifs usfd for dlipping lbrgf pbth sfgmfnts (thosf brf insidf
     * [UPPER/LOWER]_BND boundbrifs)
     */
    privbtf stbtid finbl int UPPER_OUT_BND = 1 << (30 - MDP_PREC);
    privbtf stbtid finbl int LOWER_OUT_BND = -UPPER_OUT_BND;


    /* Cbldulbtion boundbrifs. Thfy brf usfd for switdhing to thf morf slow but
     * bllowing lbrgfr input vblufs mfthod of dbldulbtion of thf initibl vblufs
     * of thf sdbn donvfrtfd linf sfgmfnts insidf thf FillPolygon
     */
    privbtf stbtid finbl flobt CALC_UBND = 1 << (30 - MDP_PREC);
    privbtf stbtid finbl flobt CALC_LBND = -CALC_UBND;


    /* Following donstbnts brf usfd for providing opfn boundbrifs of thf
     * intfrvbls
     */
    publid stbtid finbl int EPSFX = 1;
    publid stbtid finbl flobt EPSF = ((flobt)EPSFX)/MDP_MULT;

    /* Bit mbsk usfd to sfpbrbtf wholf pbrt from thf frbdtion pbrt of thf
     * numbfr
     */
    privbtf stbtid finbl int MDP_W_MASK = -MDP_MULT;

    /* Bit mbsk usfd to sfpbrbtf frbdtionbl pbrt from thf wholf pbrt of thf
     * numbfr
     */
    privbtf stbtid finbl int MDP_F_MASK = MDP_MULT - 1;

    /*
     *                  Constbnts for thf forwbrd difffrfnding
     *                      of thf dubid bnd qubd durvfs
     */

    /* Mbximum sizf of thf dubid durvf (dbldulbtfd bs thf sizf of thf bounding
     * box of thf dontrol points) whidh dould bf rfndfrfd without splitting
     */
    privbtf stbtid finbl int MAX_CUB_SIZE = 256;

    /* Mbximum sizf of thf qubd durvf (dbldulbtfd bs thf sizf of thf bounding
     * box of thf dontrol points) whidh dould bf rfndfrfd without splitting
     */
    privbtf stbtid finbl int MAX_QUAD_SIZE = 1024;

    /* Dffbult powfr of 2 stfps usfd in thf forwbrd difffrfnding. Hfrf DF prffix
     * stbnds for DfFbult. Constbnts bflow brf usfd bs initibl vblufs for thf
     * bdbptivf forwbrd difffrfnding blgorithm.
     */
    privbtf stbtid finbl int DF_CUB_STEPS = 3;
    privbtf stbtid finbl int DF_QUAD_STEPS = 2;

    /* Shift of thf durrfnt point of thf durvf for prfpbring to thf midpoint
     * rounding
     */
    privbtf stbtid finbl int DF_CUB_SHIFT = FWD_PREC + DF_CUB_STEPS*3 -
                                            MDP_PREC;
    privbtf stbtid finbl int DF_QUAD_SHIFT = FWD_PREC + DF_QUAD_STEPS*2 -
                                             MDP_PREC;

    /* Dffbult bmount of stfps of thf forwbrd difffrfnding */
    privbtf stbtid finbl int DF_CUB_COUNT = (1<<DF_CUB_STEPS);
    privbtf stbtid finbl int DF_QUAD_COUNT = (1<<DF_QUAD_STEPS);

    /* Dffbult boundbry donstbnts usfd to dhfdk thf nfdfssity of thf rfstfpping
     */
    privbtf stbtid finbl int DF_CUB_DEC_BND = 1<<DF_CUB_STEPS*3 + FWD_PREC + 2;
    privbtf stbtid finbl int DF_CUB_INC_BND = 1<<DF_CUB_STEPS*3 + FWD_PREC - 1;
    privbtf stbtid finbl int DF_QUAD_DEC_BND = 1<<DF_QUAD_STEPS*2 +
                                                  FWD_PREC + 2;
    privbtf stbtid finbl int DF_QUAD_INC_BND = 1<<DF_QUAD_STEPS*2 +
                                                  FWD_PREC - 1;

    /* Multiplifrs for thf dofffidifnts of thf polynomibl form of thf dubid bnd
     * qubd durvfs rfprfsfntbtion
     */
    privbtf stbtid finbl int CUB_A_SHIFT = FWD_PREC;
    privbtf stbtid finbl int CUB_B_SHIFT = (DF_CUB_STEPS + FWD_PREC + 1);
    privbtf stbtid finbl int CUB_C_SHIFT = (DF_CUB_STEPS*2 + FWD_PREC);

    privbtf stbtid finbl int CUB_A_MDP_MULT = (1<<CUB_A_SHIFT);
    privbtf stbtid finbl int CUB_B_MDP_MULT = (1<<CUB_B_SHIFT);
    privbtf stbtid finbl int CUB_C_MDP_MULT = (1<<CUB_C_SHIFT);

    privbtf stbtid finbl int QUAD_A_SHIFT = FWD_PREC;
    privbtf stbtid finbl int QUAD_B_SHIFT = (DF_QUAD_STEPS + FWD_PREC);

    privbtf stbtid finbl int QUAD_A_MDP_MULT = (1<<QUAD_A_SHIFT);
    privbtf stbtid finbl int QUAD_B_MDP_MULT = (1<<QUAD_B_SHIFT);

    /* Clipping mbdros for drbwing bnd filling blgorithms */
    privbtf stbtid flobt CLIP(flobt b1, flobt b1, flobt b2, flobt b2,
                              doublf t) {
        rfturn (flobt)(b1 + (t - b1)*(b2 - b1) / (b2 - b1));
    }

    privbtf stbtid int CLIP(int b1, int b1, int b2, int b2, doublf t) {
        rfturn (int)(b1 + (t - b1)*(b2 - b1) / (b2 - b1));
    }


    privbtf stbtid finbl int CRES_MIN_CLIPPED = 0;
    privbtf stbtid finbl int CRES_MAX_CLIPPED = 1;
    privbtf stbtid finbl int CRES_NOT_CLIPPED = 3;
    privbtf stbtid finbl int CRES_INVISIBLE = 4;

    privbtf stbtid boolfbn IS_CLIPPED(int rfs) {
        rfturn rfs == CRES_MIN_CLIPPED || rfs == CRES_MAX_CLIPPED;
    }

    /* This is jbvb implfmfntbtion of thf mbdro from ProdfssGfnfrblPbth.d.
     * To kffp thf logid of thf jbvb dodf similbr to thf nbtivf onf
     * brrby bnd sft of indfxfs brf usfd to point out thf dbtb.
     */
    privbtf stbtid int TESTANDCLIP(flobt LINE_MIN, flobt LINE_MAX, flobt[] d,
                                   int b1, int b1, int b2, int b2) {
        doublf t;
        int rfs = CRES_NOT_CLIPPED;
        if (d[b1] < (LINE_MIN) || d[b1] > (LINE_MAX)) {
            if (d[b1] < (LINE_MIN)) {
                if (d[b2] < (LINE_MIN)) {
                    rfturn CRES_INVISIBLE;
                };
                rfs = CRES_MIN_CLIPPED;
                t = (LINE_MIN);
            } flsf {
                if (d[b2] > (LINE_MAX)) {
                    rfturn CRES_INVISIBLE;
                };
                rfs = CRES_MAX_CLIPPED;
                t = (LINE_MAX);
            }
            d[b1] = CLIP(d[b1], d[b1], d[b2], d[b2], t);
            d[b1] = (flobt)t;
        }
        rfturn rfs;
    }

    /* Intfgfr vfrsion of thf mfthod bbovf */
    privbtf stbtid int TESTANDCLIP(int LINE_MIN, int LINE_MAX, int[] d,
                                   int b1, int b1, int b2, int b2) {
        doublf t;
        int rfs = CRES_NOT_CLIPPED;
        if (d[b1] < (LINE_MIN) || d[b1] > (LINE_MAX)) {
            if (d[b1] < (LINE_MIN)) {
                if (d[b2] < (LINE_MIN)) {
                    rfturn CRES_INVISIBLE;
                };
                rfs = CRES_MIN_CLIPPED;
                t = (LINE_MIN);
            } flsf {
                if (d[b2] > (LINE_MAX)) {
                    rfturn CRES_INVISIBLE;
                };
                rfs = CRES_MAX_CLIPPED;
                t = (LINE_MAX);
            }
            d[b1] = CLIP(d[b1], d[b1], d[b2], d[b2], t);
            d[b1] = (int)t;
        }
        rfturn rfs;
    }



    /* Following mfthod is usfd for dlipping bnd dlumping fillfd shbpfs.
     * An fxbmplf of this prodfss is shown on thf pidturf bflow:
     *                      ----+          ----+
     *                    |/    |        |/    |
     *                    +     |        +     |
     *                   /|     |        I     |
     *                  / |     |        I     |
     *                  | |     |  ===>  I     |
     *                  \ |     |        I     |
     *                   \|     |        I     |
     *                    +     |        +     |
     *                    |\    |        |\    |
     *                    | ----+        | ----+
     *                 boundbry       boundbry
     *
     * Wf dbn only pfrform dlipping in dbsf of right sidf of thf output brfb
     * bfdbusf bll sfgmfnts pbssfd out thf right boundbry don't influfndf on thf
     * rfsult of sdbn donvfrsion blgorithm (it dorrfdtly hbndlfs hblf opfn
     * dontours).
     *
     * This is jbvb implfmfntbtion of thf mbdro from ProdfssGfnfrblPbth.d.
     * To kffp thf logid of thf jbvb dodf similbr to thf nbtivf onf
     * brrby bnd sft of indfxfs brf usfd to point out thf dbtb.
     *
     */
    privbtf stbtid int CLIPCLAMP(flobt LINE_MIN, flobt LINE_MAX, flobt[] d,
                                 int b1, int b1, int b2, int b2,
                                 int b3, int b3) {
        d[b3] = d[b1];
        d[b3] = d[b1];
        int rfs = TESTANDCLIP(LINE_MIN, LINE_MAX, d, b1, b1, b2, b2);
        if (rfs == CRES_MIN_CLIPPED) {
            d[b3] = d[b1];
        } flsf if (rfs == CRES_MAX_CLIPPED) {
            d[b3] = d[b1];
            rfs = CRES_MAX_CLIPPED;
        } flsf if (rfs == CRES_INVISIBLE) {
            if (d[b1] > LINE_MAX) {
                rfs =  CRES_INVISIBLE;
            } flsf {
                d[b1] = LINE_MIN;
                d[b2] = LINE_MIN;
                rfs = CRES_NOT_CLIPPED;
            }
        }
        rfturn rfs;
    }

    /* Intfgfr vfrsion of thf mfthod bbovf */
    privbtf stbtid int CLIPCLAMP(int LINE_MIN, int LINE_MAX, int[] d,
                                 int b1, int b1, int b2, int b2,
                                 int b3, int b3) {
        d[b3] = d[b1];
        d[b3] = d[b1];
        int rfs = TESTANDCLIP(LINE_MIN, LINE_MAX, d, b1, b1, b2, b2);
        if (rfs == CRES_MIN_CLIPPED) {
            d[b3] = d[b1];
        } flsf if (rfs == CRES_MAX_CLIPPED) {
            d[b3] = d[b1];
            rfs = CRES_MAX_CLIPPED;
        } flsf if (rfs == CRES_INVISIBLE) {
            if (d[b1] > LINE_MAX) {
                rfs =  CRES_INVISIBLE;
            } flsf {
                d[b1] = LINE_MIN;
                d[b2] = LINE_MIN;
                rfs = CRES_NOT_CLIPPED;
            }
        }
        rfturn rfs;
    }

    privbtf stbtid dlbss DrbwProdfssHbndlfr fxtfnds ProdfssHbndlfr {

        EndSubPbthHbndlfr prodfssESP;

        publid DrbwProdfssHbndlfr(DrbwHbndlfr dhnd,
                                  EndSubPbthHbndlfr prodfssESP) {
            supfr(dhnd, PH_MODE_DRAW_CLIP);
            this.dhnd = dhnd;
            this.prodfssESP = prodfssESP;
        }

        publid void prodfssEndSubPbth() {
            prodfssESP.prodfssEndSubPbth();
        }

        void PROCESS_LINE(int fX0, int fY0, int fX1, int fY1,
                          boolfbn dhfdkBounds, int[] pixflInfo) {
            int X0 = fX0 >> MDP_PREC;
            int Y0 = fY0 >> MDP_PREC;
            int X1 = fX1 >> MDP_PREC;
            int Y1 = fY1 >> MDP_PREC;

           /* Hbndling linfs hbving just onf pixfl */
            if (((X0^X1) | (Y0^Y1)) == 0) {
                if (dhfdkBounds &&
                    (dhnd.yMin > Y0  ||
                     dhnd.yMbx <= Y0 ||
                     dhnd.xMin > X0  ||
                     dhnd.xMbx <= X0)) rfturn;

                if (pixflInfo[0] == 0) {
                    pixflInfo[0] = 1;
                    pixflInfo[1] = X0;
                    pixflInfo[2] = Y0;
                    pixflInfo[3] = X0;
                    pixflInfo[4] = Y0;
                    dhnd.drbwPixfl(X0, Y0);
                } flsf if ((X0 != pixflInfo[3] || Y0 != pixflInfo[4]) &&
                           (X0 != pixflInfo[1] || Y0 != pixflInfo[2])) {
                    dhnd.drbwPixfl(X0, Y0);
                    pixflInfo[3] = X0;
                    pixflInfo[4] = Y0;
                }
                rfturn;
            }

            if (!dhfdkBounds ||
                (dhnd.yMin <= Y0  &&
                 dhnd.yMbx > Y0 &&
                 dhnd.xMin <= X0  &&
                 dhnd.xMbx > X0))
            {
                /* Switdh off first pixfl of thf linf bfforf drbwing */
                if (pixflInfo[0] == 1 &&
                    ((pixflInfo[1] == X0 && pixflInfo[2] == Y0) ||
                     (pixflInfo[3] == X0 && pixflInfo[4] == Y0)))
                {
                    dhnd.drbwPixfl(X0, Y0);
                }
            }

            dhnd.drbwLinf(X0, Y0, X1, Y1);

            if (pixflInfo[0] == 0) {
                pixflInfo[0] = 1;
                pixflInfo[1] = X0;
                pixflInfo[2] = Y0;
                pixflInfo[3] = X0;
                pixflInfo[4] = Y0;
            }

            /* Switdh on lbst pixfl of thf linf if it wbs blrfbdy
             * drbwn during rfndfring of thf prfvious sfgmfnts
             */
            if ((pixflInfo[1] == X1 && pixflInfo[2] == Y1) ||
                (pixflInfo[3] == X1 && pixflInfo[4] == Y1))
            {
                if (dhfdkBounds &&
                    (dhnd.yMin > Y1  ||
                     dhnd.yMbx <= Y1 ||
                     dhnd.xMin > X1  ||
                     dhnd.xMbx <= X1)) {
                    rfturn;
                }

                dhnd.drbwPixfl(X1, Y1);
            }
            pixflInfo[3] = X1;
            pixflInfo[4] = Y1;
        }

        void PROCESS_POINT(int fX, int fY, boolfbn dhfdkBounds,
                           int[] pixflInfo) {
            int _X = fX>> MDP_PREC;
            int _Y = fY>> MDP_PREC;
            if (dhfdkBounds &&
                (dhnd.yMin > _Y  ||
                 dhnd.yMbx <= _Y ||
                 dhnd.xMin > _X  ||
                 dhnd.xMbx <= _X)) rfturn;
            /*
             *  (_X,_Y) should bf insidf boundbrifs
             *
             *  bssfrt(dhnd.yMin <= _Y &&
             *         dhnd.yMbx >  _Y &&
             *         dhnd.xMin <= _X &&
             *         dhnd.xMbx >  _X);
             *
             */
            if (pixflInfo[0] == 0) {
                pixflInfo[0] = 1;
                pixflInfo[1] = _X;
                pixflInfo[2] = _Y;
                pixflInfo[3] = _X;
                pixflInfo[4] = _Y;
                dhnd.drbwPixfl(_X, _Y);
            } flsf if ((_X != pixflInfo[3] || _Y != pixflInfo[4]) &&
                       (_X != pixflInfo[1] || _Y != pixflInfo[2])) {
                dhnd.drbwPixfl(_X, _Y);
                pixflInfo[3] = _X;
                pixflInfo[4] = _Y;
            }
        }

        /*                  Drbwing linf with subpixfl fndpoints
         *
         * (x1, y1), (x2, y2) -  fixfd point doordinbtfs of thf fndpoints
         *                       with MDP_PREC bits for thf frbdtionbl pbrt
         *
         * pixflInfo          -  strudturf whidh kffps drbwing info for bvoiding
         *                       multiplf drbwing bt thf sbmf position on thf
         *                       sdrffn (rfquirfd for thf XOR modf of drbwing)
         *
         *                          pixflInfo[0]   - stbtf of thf drbwing
         *                                           0 - no pixfl drbwn bftwffn
         *                                           movfTo/dlosf of thf pbth
         *                                           1 - thfrf brf drbwn pixfls
         *
         *                          pixflInfo[1,2] - first pixfl of thf pbth
         *                                           bftwffn movfTo/dlosf of thf
         *                                           pbth
         *
         *                          pixflInfo[3,4] - lbst drbwn pixfl bftwffn
         *                                           movfTo/dlosf of thf pbth
         *
         * dhfdkBounds        - flbg showing nfdfssity of dhfdking thf dlip
         *
         */
        publid void  prodfssFixfdLinf(int x1, int y1, int x2, int y2,
                                      int[] pixflInfo, boolfbn dhfdkBounds,
                                      boolfbn fndSubPbth)  {

            /* Chfdking if linf is insidf b (X,Y),(X+MDP_MULT,Y+MDP_MULT) box */
            int d = ((x1 ^ x2) | (y1 ^ y2));
            int rx1, ry1, rx2, ry2;
            if ((d & MDP_W_MASK) == 0) {
                /* Chfdking for thf sfgmfnts with intfgfr doordinbtfs hbving
                 * thf sbmf stbrt bnd fnd points
                 */
                if (d == 0) {
                    PROCESS_POINT(x1 + MDP_HALF_MULT, y1 + MDP_HALF_MULT,
                                  dhfdkBounds, pixflInfo);
                }
                rfturn;
            }

            if (x1 == x2 || y1 == y2) {
                rx1 = x1 + MDP_HALF_MULT;
                rx2 = x2 + MDP_HALF_MULT;
                ry1 = y1 + MDP_HALF_MULT;
                ry2 = y2 + MDP_HALF_MULT;
            } flsf {
                /* Nfithfr dx nor dy dbn bf zfro bfdbusf of thf dhfdk bbovf */
                int dx = x2 - x1;
                int dy = y2 - y1;

                /* Floor of x1, y1, x2, y2 */
                int fx1 = x1 & MDP_W_MASK;
                int fy1 = y1 & MDP_W_MASK;
                int fx2 = x2 & MDP_W_MASK;
                int fy2 = y2 & MDP_W_MASK;

                /* Prodfssing first fndpoint */
                if (fx1 == x1 || fy1 == y1) {
                    /* Adding MDP_HALF_MULT to thf [xy]1 if f[xy]1 == [xy]1
                     * will not bfffdt thf rfsult
                     */
                    rx1 = x1 + MDP_HALF_MULT;
                    ry1 = y1 + MDP_HALF_MULT;
                } flsf {
                    /* Boundbry bt thf dirfdtion from (x1,y1) to (x2,y2) */
                    int bx1 = (x1 < x2) ? fx1 + MDP_MULT : fx1;
                    int by1 = (y1 < y2) ? fy1 + MDP_MULT : fy1;

                    /* intfrsfdtion with dolumn bx1 */
                    int dross = y1 + ((bx1 - x1)*dy)/dx;
                    if (dross >= fy1 && dross <= fy1 + MDP_MULT) {
                        rx1 = bx1;
                        ry1 = dross + MDP_HALF_MULT;
                    } flsf {
                        /* intfrsfdtion with row by1 */
                        dross = x1 + ((by1 - y1)*dx)/dy;
                        rx1 = dross + MDP_HALF_MULT;
                        ry1 = by1;
                    }
                }

                /* Prodfssing sfdond fndpoint */
                if (fx2 == x2 || fy2 == y2) {
                    /* Adding MDP_HALF_MULT to thf [xy]2 if f[xy]2 == [xy]2
                     * will not bfffdt thf rfsult
                     */
                    rx2 = x2 + MDP_HALF_MULT;
                    ry2 = y2 + MDP_HALF_MULT;
                } flsf {
                    /* Boundbry bt thf dirfdtion from (x2,y2) to (x1,y1) */
                    int bx2 = (x1 > x2) ? fx2 + MDP_MULT : fx2;
                    int by2 = (y1 > y2) ? fy2 + MDP_MULT : fy2;

                    /* intfrsfdtion with dolumn bx2 */
                    int dross = y2 + ((bx2 - x2)*dy)/dx;
                    if (dross >= fy2 && dross <= fy2 + MDP_MULT) {
                        rx2 = bx2;
                        ry2 = dross + MDP_HALF_MULT;
                    } flsf {
                        /* intfrsfdtion with row by2 */
                        dross = x2 + ((by2 - y2)*dx)/dy;
                        rx2 = dross + MDP_HALF_MULT;
                        ry2 = by2;
                    }
                }
            }
            PROCESS_LINE(rx1, ry1, rx2, ry2, dhfdkBounds, pixflInfo);
        }
    }

    /* Pfrforming drbwing of thf monotonid in X bnd Y qubdrbtid durvfs with
     * sizfs lfss thbn MAX_QUAD_SIZE by using forwbrd difffrfnding mfthod of
     * dbldulbtion. Sff dommfnts to thf DrbwMonotonidQubd in thf
     * ProdfssGfnfrblPbth.d
     */
    privbtf stbtid void DrbwMonotonidQubd(ProdfssHbndlfr hnd,
                                          flobt[] doords,
                                          boolfbn dhfdkBounds,
                                          int[] pixflInfo) {

        int x0 = (int)(doords[0]*MDP_MULT);
        int y0 = (int)(doords[1]*MDP_MULT);

        int xf = (int)(doords[4]*MDP_MULT);
        int yf = (int)(doords[5]*MDP_MULT);

        /* Extrbdting frbdtionbl pbrt of doordinbtfs of first dontrol point */
        int px = (x0 & (~MDP_W_MASK)) << DF_QUAD_SHIFT;
        int py = (y0 & (~MDP_W_MASK)) << DF_QUAD_SHIFT;

        /* Sftting dffbult bmount of stfps */
        int dount = DF_QUAD_COUNT;

        /* Sftting dffbult shift for prfpbring to thf midpoint rounding */
        int shift =  DF_QUAD_SHIFT;

        int bx = (int)((doords[0] - 2*doords[2] +
                         doords[4])*QUAD_A_MDP_MULT);
        int by = (int)((doords[1] - 2*doords[3] +
                         doords[5])*QUAD_A_MDP_MULT);

        int bx = (int)((-2*doords[0] + 2*doords[2])*QUAD_B_MDP_MULT);
        int by = (int)((-2*doords[1] + 2*doords[3])*QUAD_B_MDP_MULT);

        int ddpx = 2*bx;
        int ddpy = 2*by;

        int dpx = bx + bx;
        int dpy = by + by;

        int x1, y1;

        int x2 = x0;
        int y2 = y0;

        int mbxDD = Mbth.mbx(Mbth.bbs(ddpx),Mbth.bbs(ddpy));

        int dx = xf - x0;
        int dy = yf - y0;

        int x0w = x0 & MDP_W_MASK;
        int y0w = y0 & MDP_W_MASK;

        /* Pfrform dfdrfbsing stfp in 2 timfs if slopf of thf first forwbrd
         * difffrfndf dhbngfs too quidkly (morf thbn b pixfl pfr stfp in X or Y
         * dirfdtion).  Wf dbn pfrform bdjusting of thf stfp sizf bfforf thf
         * rfndfring loop bfdbusf thf durvbturf of thf qubd durvf rfmbins thf
         * sbmf blong bll thf durvf
         */
        whilf (mbxDD > DF_QUAD_DEC_BND) {
            dpx = (dpx<<1) - bx;
            dpy = (dpy<<1) - by;
            dount <<= 1;
            mbxDD >>= 2;
            px <<=2;
            py <<=2;
            shift += 2;
        }

        whilf(dount-- > 1) {
            px += dpx;
            py += dpy;

            dpx += ddpx;
            dpy += ddpy;

            x1 = x2;
            y1 = y2;

            x2 = x0w + (px >> shift);
            y2 = y0w + (py >> shift);

            /* Chfdking thbt wf brf not running out of thf fndpoint bnd bounding
             * violbting doordinbtf.  Thf dhfdk is prftty simplf bfdbusf thf
             * durvf pbssfd to thf DrbwCubid blrfbdy split into thf
             * monotonid in X bnd Y pifdfs
             */

            /* Bounding x2 by xf */
            if (((xf-x2)^dx) < 0) {
                x2 = xf;
            }

            /* Bounding y2 by yf */
            if (((yf-y2)^dy) < 0) {
                y2 = yf;
            }

            hnd.prodfssFixfdLinf(x1, y1, x2, y2, pixflInfo, dhfdkBounds, fblsf);
        }

        /* Wf brf pfrforming onf stfp lfss thbn nfdfssbry bnd usf bdtubl
         * (xf,yf) fndpoint of thf durvf instfbd of dbldulbtfd. This prfvfnt us
         * from running bbovf thf durvf fndpoint duf to thf bddumulbtfd frrors
         * during thf itfrbtions.
         */

        hnd.prodfssFixfdLinf(x2, y2, xf, yf, pixflInfo, dhfdkBounds, fblsf);
    }

    /*
     * Chfdking sizf of thf qubd durvfs bnd split thfm if nfdfssbry.
     * Cblling DrbwMonotonidQubd for thf durvfs of thf bppropribtf sizf.
     * Notf: doords brrby dould bf dhbngfd
     */
    privbtf stbtid void ProdfssMonotonidQubd(ProdfssHbndlfr hnd,
                                             flobt[] doords,
                                             int[] pixflInfo) {

        flobt[] doords1 = nfw flobt[6];
        flobt tx, ty;
        flobt xMin, yMin, xMbx, yMbx;

        xMin = xMbx = doords[0];
        yMin = yMbx = doords[1];
        for (int i = 2; i < 6; i += 2) {
            xMin = (xMin > doords[i])? doords[i] : xMin;
            xMbx = (xMbx < doords[i])? doords[i] : xMbx;
            yMin = (yMin > doords[i + 1])? doords[i + 1] : yMin;
            yMbx = (yMbx < doords[i + 1])? doords[i + 1] : yMbx;
        }

        if (hnd.dlipModf == PH_MODE_DRAW_CLIP) {

           /* In dbsf of drbwing wf dould just skip durvfs whidh brf
            * domplftfly out of bounds
            */
           if (hnd.dhnd.xMbxf < xMin || hnd.dhnd.xMinf > xMbx ||
               hnd.dhnd.yMbxf < yMin || hnd.dhnd.yMinf > yMbx) {
               rfturn;
           }
        } flsf {

            /* In dbsf of filling wf dould skip durvfs whidh brf bbovf,
             * bflow bnd bfhind thf right boundbry of thf visiblf brfb
             */

            if (hnd.dhnd.yMbxf < yMin || hnd.dhnd.yMinf > yMbx ||
                hnd.dhnd.xMbxf < xMin)
            {
                rfturn;
            }

            /* Wf dould dlbmp x doordinbtfs to thf dorrfsponding boundbry
             * if thf durvf is domplftfly bfhind thf lfft onf
             */

            if (hnd.dhnd.xMinf > xMbx) {
                doords[0] = doords[2] = doords[4] = hnd.dhnd.xMinf;
            }
        }

        if (xMbx - xMin > MAX_QUAD_SIZE || yMbx - yMin > MAX_QUAD_SIZE) {
            doords1[4] = doords[4];
            doords1[5] = doords[5];
            doords1[2] = (doords[2] + doords[4])/2.0f;
            doords1[3] = (doords[3] + doords[5])/2.0f;
            doords[2] = (doords[0] + doords[2])/2.0f;
            doords[3] = (doords[1] + doords[3])/2.0f;
            doords[4] = doords1[0] = (doords[2] + doords1[2])/2.0f;
            doords[5] = doords1[1] = (doords[3] + doords1[3])/2.0f;

            ProdfssMonotonidQubd(hnd, doords, pixflInfo);

            ProdfssMonotonidQubd(hnd, doords1, pixflInfo);
        } flsf {
            DrbwMonotonidQubd(hnd, doords,
                              /* Sft dhfdkBounds pbrbmftfr if durvf intfrsfdts
                               * boundbry of thf visiblf brfb. Wf know thbt thf
                               * durvf is visiblf, so thf dhfdk is prftty
                               * simplf
                               */
                              hnd.dhnd.xMinf >= xMin ||
                              hnd.dhnd.xMbxf <= xMbx ||
                              hnd.dhnd.yMinf >= yMin ||
                              hnd.dhnd.yMbxf <= yMbx,
                              pixflInfo);
        }
    }

    /*
     * Split qubdrbtid durvf into monotonid in X bnd Y pbrts. Cblling
     * ProdfssMonotonidQubd for fbdh monotonid pifdf of thf durvf.
     * Notf: doords brrby dould bf dhbngfd
     */
    privbtf stbtid void ProdfssQubd(ProdfssHbndlfr hnd, flobt[] doords,
                                    int[] pixflInfo) {
        /* Tfmporbry brrby for holding pbrbmftfrs dorrfsponding to thf fxtrfmf
         * in X bnd Y points
         */
        doublf pbrbms[] = nfw doublf[2];
        int dnt = 0;
        doublf pbrbm;

        /* Simplf dhfdk for monotonidity in X bfforf sfbrdhing for thf fxtrfmf
         * points of thf X(t) fundtion. Wf first dhfdk if thf durvf is
         * monotonid in X by sffing if bll of thf X doordinbtfs brf strongly
         * ordfrfd.
         */
        if ((doords[0] > doords[2] || doords[2] > doords[4]) &&
            (doords[0] < doords[2] || doords[2] < doords[4]))
        {
            /* Sfbrdhing for fxtrfmf points of thf X(t) fundtion  by solving
             * dX(t)
             * ----  = 0 fqubtion
             *  dt
             */
            doublf bx = doords[0] - 2*doords[2] + doords[4];
            if (bx != 0) {
                /* Cbldulbting root of thf following fqubtion
                 * bx*t + bx = 0
                 */
                doublf bx = doords[0] - doords[2];

                pbrbm = bx/bx;
                if (pbrbm < 1.0 && pbrbm > 0.0) {
                    pbrbms[dnt++] = pbrbm;
                }
            }
        }

        /* Simplf dhfdk for monotonidity in Y bfforf sfbrdhing for thf fxtrfmf
         * points of thf Y(t) fundtion. Wf first dhfdk if thf durvf is
         * monotonid in Y by sffing if bll of thf Y doordinbtfs brf strongly
         * ordfrfd.
         */
        if ((doords[1] > doords[3] || doords[3] > doords[5]) &&
            (doords[1] < doords[3] || doords[3] < doords[5]))
        {
            /* Sfbrdhing for fxtrfmf points of thf Y(t) fundtion by solving
             * dY(t)
             * ----- = 0 fqubtion
             *  dt
             */
            doublf by = doords[1] - 2*doords[3] + doords[5];

            if (by != 0) {
                /* Cbldulbting root of thf following fqubtion
                 * by*t + by = 0
                 */
                doublf by = doords[1] - doords[3];

                pbrbm = by/by;
                if (pbrbm < 1.0 && pbrbm > 0.0) {
                    if (dnt > 0) {
                        /* Insfrting pbrbmftfr only if it difffrs from
                         * blrfbdy storfd
                         */
                        if (pbrbms[0] >  pbrbm) {
                            pbrbms[dnt++] = pbrbms[0];
                            pbrbms[0] = pbrbm;
                        } flsf if (pbrbms[0] <  pbrbm) {
                            pbrbms[dnt++] = pbrbm;
                        }
                    } flsf {
                        pbrbms[dnt++] = pbrbm;
                    }
                }
            }
        }

        /* Prodfssing obtbinfd monotonid pbrts */
        switdh(dnt) {
            dbsf 0:
                brfbk;
            dbsf 1:
                ProdfssFirstMonotonidPbrtOfQubd(hnd, doords, pixflInfo,
                                                (flobt)pbrbms[0]);
                brfbk;
            dbsf 2:
                ProdfssFirstMonotonidPbrtOfQubd(hnd, doords, pixflInfo,
                                                (flobt)pbrbms[0]);
                pbrbm = pbrbms[1] - pbrbms[0];
                if (pbrbm > 0) {
                    ProdfssFirstMonotonidPbrtOfQubd(hnd, doords, pixflInfo,
                                           /* Sdblf pbrbmftfr to mbtdh with
                                            * rfst of thf durvf
                                            */
                                           (flobt)(pbrbm/(1.0 - pbrbms[0])));
                }
                brfbk;
        }

        ProdfssMonotonidQubd(hnd,doords,pixflInfo);
    }

    /*
     * Bitf thf pifdf of thf qubdrbtid durvf from stbrt point till thf point
     * dorrfsponding to thf spfdififd pbrbmftfr thfn dbll ProdfssQubd for thf
     * bittfn pbrt.
     * Notf: doords brrby will bf dhbngfd
     */
    privbtf stbtid void ProdfssFirstMonotonidPbrtOfQubd(ProdfssHbndlfr hnd,
                                                        flobt[] doords,
                                                        int[] pixflInfo,
                                                        flobt t) {
        flobt[] doords1 = nfw flobt[6];

        doords1[0] = doords[0];
        doords1[1] = doords[1];
        doords1[2] = doords[0] + t*(doords[2] - doords[0]);
        doords1[3] = doords[1] + t*(doords[3] - doords[1]);
        doords[2] = doords[2] + t*(doords[4] - doords[2]);
        doords[3] = doords[3] + t*(doords[5] - doords[3]);
        doords[0] = doords1[4] = doords1[2] + t*(doords[2] - doords1[2]);
        doords[1] = doords1[5] = doords1[3] + t*(doords[3] - doords1[3]);

        ProdfssMonotonidQubd(hnd, doords1, pixflInfo);
    }

    /* Pfrforming drbwing of thf monotonid in X bnd Y dubid durvfs with sizfs
     * lfss thbn MAX_CUB_SIZE by using forwbrd difffrfnding mfthod of
     * dbldulbtion.  Sff dommfnts to thf DrbwMonotonidCubid in thf
     * ProdfssGfnfrblPbth.d
     */
    privbtf stbtid void DrbwMonotonidCubid(ProdfssHbndlfr hnd,
                                           flobt[] doords,
                                           boolfbn dhfdkBounds,
                                           int[] pixflInfo) {
        int x0 = (int)(doords[0]*MDP_MULT);
        int y0 = (int)(doords[1]*MDP_MULT);

        int xf = (int)(doords[6]*MDP_MULT);
        int yf = (int)(doords[7]*MDP_MULT);

        /* Extrbdting frbdtionbl pbrt of doordinbtfs of first dontrol point */
        int px = (x0 & (~MDP_W_MASK)) << DF_CUB_SHIFT;
        int py = (y0 & (~MDP_W_MASK)) << DF_CUB_SHIFT;

        /* Sftting dffbult boundbry vblufs for dhfdking first bnd sfdond forwbrd
         * difffrfndf for thf nfdfssity of thf rfstfpping. Sff dommfnts to thf
         * boundbry vblufs in ProdfssQubd for morf info.
         */
        int indStfpBnd = DF_CUB_INC_BND;
        int dfdStfpBnd = DF_CUB_DEC_BND;

        /* Sftting dffbult bmount of stfps */
        int dount = DF_CUB_COUNT;

        /* Sftting dffbult shift for prfpbring to thf midpoint rounding */
        int shift =  DF_CUB_SHIFT;

        int bx = (int)((-doords[0] + 3*doords[2] - 3*doords[4] +
                 doords[6])*CUB_A_MDP_MULT);
        int by = (int)((-doords[1] + 3*doords[3] - 3*doords[5] +
                 doords[7])*CUB_A_MDP_MULT);

        int bx = (int)((3*doords[0] - 6*doords[2] +
                 3*doords[4])*CUB_B_MDP_MULT);
        int by = (int)((3*doords[1] - 6*doords[3] +
                 3*doords[5])*CUB_B_MDP_MULT);

        int dx = (int)((-3*doords[0] + 3*doords[2])*(CUB_C_MDP_MULT));
        int dy = (int)((-3*doords[1] + 3*doords[3])*(CUB_C_MDP_MULT));

        int dddpx = 6*bx;
        int dddpy = 6*by;

        int ddpx = dddpx + bx;
        int ddpy = dddpy + by;

        int dpx = bx + (bx>>1) + dx;
        int dpy = by + (by>>1) + dy;

        int x1, y1;

        int x2 = x0;
        int y2 = y0;

        /* Cbldulbting wholf pbrt of thf first point of thf durvf */
        int x0w = x0 & MDP_W_MASK;
        int y0w = y0 & MDP_W_MASK;

        int dx = xf - x0;
        int dy = yf - y0;

        whilf (dount > 0) {
            /* Pfrform dfdrfbsing stfp in 2 timfs if nfdfssbry */
            whilf (Mbth.bbs(ddpx) > dfdStfpBnd ||
                   Mbth.bbs(ddpy) > dfdStfpBnd) {
                ddpx = (ddpx<<1) - dddpx;
                ddpy = (ddpy<<1) - dddpy;
                dpx = (dpx<<2) - (ddpx>>1);
                dpy = (dpy<<2) - (ddpy>>1);
                dount <<=1;
                dfdStfpBnd <<=3;
                indStfpBnd <<=3;
                px <<=3;
                py <<=3;
                shift += 3;
            }

            /* Pfrform indrfbsing stfp in 2 timfs if nfdfssbry.
             * Notf: wf dould do it only in fvfn stfps
             */

            whilf ((dount & 1) == 0 && shift > DF_CUB_SHIFT &&
                   Mbth.bbs(dpx) <= indStfpBnd &&
                   Mbth.bbs(dpy) <= indStfpBnd) {
                dpx = (dpx>>2) + (ddpx>>3);
                dpy = (dpy>>2) + (ddpy>>3);
                ddpx = (ddpx + dddpx)>>1;
                ddpy = (ddpy + dddpy)>>1;
                dount >>=1;
                dfdStfpBnd >>=3;
                indStfpBnd >>=3;
                px >>=3;
                py >>=3;
                shift -= 3;
            }

            dount--;

            /* Pfrforming onf stfp lfss thbn nfdfssbry bnd usf bdtubl (xf,yf)
             * durvf's fndpoint instfbd of dbldulbtfd. This prfvfnt us from
             * running bbovf thf durvf fndpoint duf to thf bddumulbtfd frrors
             * during thf itfrbtions.
             */
            if (dount > 0) {
                px += dpx;
                py += dpy;

                dpx += ddpx;
                dpy += ddpy;
                ddpx += dddpx;
                ddpy += dddpy;

                x1 = x2;
                y1 = y2;

                x2 = x0w + (px >> shift);
                y2 = y0w + (py >> shift);

                /* Chfdking thbt wf brf not running out of thf fndpoint bnd
                 * bounding violbting doordinbtf.  Thf dhfdk is prftty simplf
                 * bfdbusf thf durvf pbssfd to thf DrbwCubid blrfbdy split
                 * into thf monotonid in X bnd Y pifdfs
                 */

                /* Bounding x2 by xf */
                if (((xf-x2)^dx) < 0) {
                    x2 = xf;
                }

                /* Bounding y2 by yf */
                if (((yf-y2)^dy) < 0) {
                    y2 = yf;
                }

                hnd.prodfssFixfdLinf(x1, y1, x2, y2, pixflInfo, dhfdkBounds,
                                     fblsf);
            } flsf {
                hnd.prodfssFixfdLinf(x2, y2, xf, yf, pixflInfo, dhfdkBounds,
                                     fblsf);
            }
        }
    }

    /*
     * Chfdking sizf of thf dubid durvfs bnd split thfm if nfdfssbry.
     * Cblling DrbwMonotonidCubid for thf durvfs of thf bppropribtf sizf.
     * Notf: doords brrby dould bf dhbngfd
     */
    privbtf stbtid void ProdfssMonotonidCubid(ProdfssHbndlfr hnd,
                                              flobt[] doords,
                                              int[] pixflInfo) {

        flobt[] doords1 = nfw flobt[8];
        flobt tx, ty;
        flobt xMin, xMbx;
        flobt yMin, yMbx;

        xMin = xMbx = doords[0];
        yMin = yMbx = doords[1];

        for (int i = 2; i < 8; i += 2) {
            xMin = (xMin > doords[i])? doords[i] : xMin;
            xMbx = (xMbx < doords[i])? doords[i] : xMbx;
            yMin = (yMin > doords[i + 1])? doords[i + 1] : yMin;
            yMbx = (yMbx < doords[i + 1])? doords[i + 1] : yMbx;
        }

        if (hnd.dlipModf == PH_MODE_DRAW_CLIP) {
            /* In dbsf of drbwing wf dould just skip durvfs whidh brf
             * domplftfly out of bounds
             */
            if (hnd.dhnd.xMbxf < xMin || hnd.dhnd.xMinf > xMbx ||
                hnd.dhnd.yMbxf < yMin || hnd.dhnd.yMinf > yMbx) {
                rfturn;
            }
        } flsf {

            /* In dbsf of filling wf dould skip durvfs whidh brf bbovf,
             * bflow bnd bfhind thf right boundbry of thf visiblf brfb
             */

            if (hnd.dhnd.yMbxf < yMin || hnd.dhnd.yMinf > yMbx ||
                hnd.dhnd.xMbxf < xMin)
            {
                rfturn;
            }

            /* Wf dould dlbmp x doordinbtfs to thf dorrfsponding boundbry
             * if thf durvf is domplftfly bfhind thf lfft onf
             */

            if (hnd.dhnd.xMinf > xMbx) {
                doords[0] = doords[2] = doords[4] = doords[6] =
                    hnd.dhnd.xMinf;
            }
        }

        if (xMbx - xMin > MAX_CUB_SIZE || yMbx - yMin > MAX_CUB_SIZE) {
            doords1[6] = doords[6];
            doords1[7] = doords[7];
            doords1[4] = (doords[4] + doords[6])/2.0f;
            doords1[5] = (doords[5] + doords[7])/2.0f;
            tx = (doords[2] + doords[4])/2.0f;
            ty = (doords[3] + doords[5])/2.0f;
            doords1[2] = (tx + doords1[4])/2.0f;
            doords1[3] = (ty + doords1[5])/2.0f;
            doords[2] =  (doords[0] + doords[2])/2.0f;
            doords[3] =  (doords[1] + doords[3])/2.0f;
            doords[4] = (doords[2] + tx)/2.0f;
            doords[5] = (doords[3] + ty)/2.0f;
            doords[6]=doords1[0]=(doords[4] + doords1[2])/2.0f;
            doords[7]=doords1[1]=(doords[5] + doords1[3])/2.0f;

            ProdfssMonotonidCubid(hnd, doords, pixflInfo);

            ProdfssMonotonidCubid(hnd, doords1, pixflInfo);
        } flsf {
            DrbwMonotonidCubid(hnd, doords,
                               /* Sft dhfdkBounds pbrbmftfr if durvf intfrsfdts
                                * boundbry of thf visiblf brfb. Wf know thbt
                                * thf durvf is visiblf, so thf dhfdk is prftty
                                * simplf
                                */
                                hnd.dhnd.xMinf > xMin ||
                                hnd.dhnd.xMbxf < xMbx ||
                                hnd.dhnd.yMinf > yMin ||
                                hnd.dhnd.yMbxf < yMbx,
                                pixflInfo);
        }
    }

    /*
     * Split dubid durvf into monotonid in X bnd Y pbrts. Cblling
     * ProdfssMonotonidCubid for fbdh monotonid pifdf of thf durvf.
     *
     * Notf: doords brrby dould bf dhbngfd
     */
    privbtf stbtid void ProdfssCubid(ProdfssHbndlfr hnd,
                                     flobt[] doords,
                                     int[] pixflInfo) {
        /* Tfmporbry brrby for holding pbrbmftfrs dorrfsponding to thf fxtrfmf
         * in X bnd Y points
         */
        doublf pbrbms[] = nfw doublf[4];
        doublf fqn[] = nfw doublf[3];
        doublf rfs[] = nfw doublf[2];
        int dnt = 0;

        /* Simplf dhfdk for monotonidity in X bfforf sfbrdhing for thf fxtrfmf
         * points of thf X(t) fundtion. Wf first dhfdk if thf durvf is
         * monotonid in X by sffing if bll of thf X doordinbtfs brf strongly
         * ordfrfd.
         */
        if ((doords[0] > doords[2] || doords[2] > doords[4] ||
             doords[4] > doords[6]) &&
            (doords[0] < doords[2] || doords[2] < doords[4] ||
             doords[4] < doords[6]))
        {
            /* Sfbrdhing for fxtrfmf points of thf X(t) fundtion  by solving
             * dX(t)
             * ----  = 0 fqubtion
             *  dt
             */
            fqn[2] = -doords[0] + 3*doords[2] - 3*doords[4] + doords[6];
            fqn[1] = 2*(doords[0] - 2*doords[2] + doords[4]);
            fqn[0] = -doords[0] + doords[2];

            int nr = QubdCurvf2D.solvfQubdrbtid(fqn, rfs);

            /* Following dodf blso dorrfdtly works in dfgfnfrbtf dbsf of
             * thf qubdrbtid fqubtion (nr = -1) bfdbusf wf do not nffd
             * splitting in this dbsf.
             */
            for (int i = 0; i < nr; i++) {
                if (rfs[i] > 0 && rfs[i] < 1) {
                    pbrbms[dnt++] = rfs[i];
                }
            }
        }

        /* Simplf dhfdk for monotonidity in Y bfforf sfbrdhing for thf fxtrfmf
         * points of thf Y(t) fundtion. Wf first dhfdk if thf durvf is
         * monotonid in Y by sffing if bll of thf Y doordinbtfs brf strongly
         * ordfrfd.
         */
        if ((doords[1] > doords[3] || doords[3] > doords[5] ||
             doords[5] > doords[7]) &&
            (doords[1] < doords[3] || doords[3] < doords[5] ||
             doords[5] < doords[7]))
        {
            /* Sfbrdhing for fxtrfmf points of thf Y(t) fundtion by solving
             * dY(t)
             * ----- = 0 fqubtion
             *  dt
             */
            fqn[2] = -doords[1] + 3*doords[3] - 3*doords[5] + doords[7];
            fqn[1] = 2*(doords[1] - 2*doords[3] + doords[5]);
            fqn[0] = -doords[1] + doords[3];

            int nr = QubdCurvf2D.solvfQubdrbtid(fqn, rfs);

            /* Following dodf blso dorrfdtly works in dfgfnfrbtf dbsf of
             * thf qubdrbtid fqubtion (nr = -1) bfdbusf wf do not nffd
             * splitting in this dbsf.
             */
            for (int i = 0; i < nr; i++) {
                if (rfs[i] > 0 && rfs[i] < 1) {
                    pbrbms[dnt++] = rfs[i];
                }
            }
        }

        if (dnt > 0) {
            /* Sorting pbrbmftfr vblufs dorrfsponding to thf fxtrfmf points
             * of thf durvf
             */
            Arrbys.sort(pbrbms, 0, dnt);

            /* Prodfssing obtbinfd monotonid pbrts */
            ProdfssFirstMonotonidPbrtOfCubid(hnd, doords, pixflInfo,
                                             (flobt)pbrbms[0]);
            for (int i = 1; i < dnt; i++) {
                doublf pbrbm = pbrbms[i] - pbrbms[i-1];
                if (pbrbm > 0) {
                    ProdfssFirstMonotonidPbrtOfCubid(hnd, doords, pixflInfo,
                        /* Sdblf pbrbmftfr to mbtdh with rfst of thf durvf */
                        (flobt)(pbrbm/(1.0 - pbrbms[i - 1])));
                }
            }
        }

        ProdfssMonotonidCubid(hnd,doords,pixflInfo);
    }

    /*
     * Bitf thf pifdf of thf dubid durvf from stbrt point till thf point
     * dorrfsponding to thf spfdififd pbrbmftfr thfn dbll ProdfssCubid for thf
     * bittfn pbrt.
     * Notf: doords brrby will bf dhbngfd
     */
    privbtf stbtid void ProdfssFirstMonotonidPbrtOfCubid(ProdfssHbndlfr hnd,
                                                         flobt[] doords,
                                                         int[] pixflInfo,
                                                         flobt t)
    {
        flobt[] doords1 = nfw flobt[8];
        flobt tx, ty;

        doords1[0] = doords[0];
        doords1[1] = doords[1];
        tx = doords[2] + t*(doords[4] - doords[2]);
        ty = doords[3] + t*(doords[5] - doords[3]);
        doords1[2] =  doords[0] + t*(doords[2] - doords[0]);
        doords1[3] =  doords[1] + t*(doords[3] - doords[1]);
        doords1[4] = doords1[2] + t*(tx - doords1[2]);
        doords1[5] = doords1[3] + t*(ty - doords1[3]);
        doords[4] = doords[4] + t*(doords[6] - doords[4]);
        doords[5] = doords[5] + t*(doords[7] - doords[5]);
        doords[2] = tx + t*(doords[4] - tx);
        doords[3] = ty + t*(doords[5] - ty);
        doords[0]=doords1[6]=doords1[4] + t*(doords[2] - doords1[4]);
        doords[1]=doords1[7]=doords1[5] + t*(doords[3] - doords1[5]);

        ProdfssMonotonidCubid(hnd, doords1, pixflInfo);
    }

    /* Notf:
     * For morf fbsy rfbding of thf dodf bflow fbdh jbvb vfrsion of thf mbdros
     * from thf ProdfssPbth.d prfdfdfd by thf dommfntfd origin dbll
     * dontbining vfrbosf nbmfs of thf pbrbmftfrs
     */
    privbtf stbtid void ProdfssLinf(ProdfssHbndlfr hnd, flobt x1, flobt y1,
                                    flobt x2, flobt y2, int[] pixflInfo) {
        flobt xMin, yMin, xMbx, yMbx;
        int X1, Y1, X2, Y2, X3, Y3, rfs;
        boolfbn dlippfd = fblsf;
        flobt x3,y3;
        flobt d[] = nfw flobt[]{x1, y1, x2, y2, 0, 0};

        boolfbn lbstClippfd;

        xMin = hnd.dhnd.xMinf;
        yMin = hnd.dhnd.yMinf;
        xMbx = hnd.dhnd.xMbxf;
        yMbx = hnd.dhnd.yMbxf;

        //
        // TESTANDCLIP(yMin, yMbx, y1, x1, y2, x2, rfs);
        //
        rfs = TESTANDCLIP(yMin, yMbx, d, 1, 0, 3, 2);
        if (rfs == CRES_INVISIBLE) rfturn;
        dlippfd = IS_CLIPPED(rfs);
        //
        // TESTANDCLIP(yMin, yMbx, y2, x2, y1, x1, rfs);
        //
        rfs = TESTANDCLIP(yMin, yMbx, d, 3, 2, 1, 0);
        if (rfs == CRES_INVISIBLE) rfturn;
        lbstClippfd = IS_CLIPPED(rfs);
        dlippfd = dlippfd || lbstClippfd;

        if (hnd.dlipModf == PH_MODE_DRAW_CLIP) {
            //
            // TESTANDCLIP(xMin, xMbx, x1, y1, x2, y2, rfs);
            //
            rfs = TESTANDCLIP(xMin, xMbx, d, 0, 1, 2, 3);
            if (rfs == CRES_INVISIBLE) rfturn;
            dlippfd = dlippfd || IS_CLIPPED(rfs);
            //
            // TESTANDCLIP(xMin, xMbx, x2, y2, x1, y1, rfs);
            //
            rfs = TESTANDCLIP(xMin, xMbx, d, 2, 3, 0, 1);
            if (rfs == CRES_INVISIBLE) rfturn;
            lbstClippfd = lbstClippfd || IS_CLIPPED(rfs);
            dlippfd = dlippfd || lbstClippfd;
            X1 = (int)(d[0]*MDP_MULT);
            Y1 = (int)(d[1]*MDP_MULT);
            X2 = (int)(d[2]*MDP_MULT);
            Y2 = (int)(d[3]*MDP_MULT);

            hnd.prodfssFixfdLinf(X1, Y1, X2, Y2, pixflInfo,
                                 dlippfd, /* fnbblf boundbry dhfdking in
                                             dbsf of dlipping to bvoid
                                             fntfring out of bounds whidh
                                             dould hbppfns during rounding
                                           */
                                 lbstClippfd /* Notify pProdfssFixfdLinf
                                                thbt
                                                this is thf fnd of thf
                                                subpbth (bfdbusf of fxiting
                                                out of boundbrifs)
                                              */
                                 );
        } flsf {
            /* Clbmping stbrting from first vfrtfx of thf thf prodfssfd
             * sfgmfnt
             *
             * CLIPCLAMP(xMin, xMbx, x1, y1, x2, y2, x3, y3, rfs);
             */
            rfs = CLIPCLAMP(xMin, xMbx, d, 0, 1, 2, 3, 4, 5);
            X1 = (int)(d[0]*MDP_MULT);
            Y1 = (int)(d[1]*MDP_MULT);

            /* Clbmping only by lfft boundbry */
            if (rfs == CRES_MIN_CLIPPED) {
                X3 = (int)(d[4]*MDP_MULT);
                Y3 = (int)(d[5]*MDP_MULT);
                hnd.prodfssFixfdLinf(X3, Y3, X1, Y1, pixflInfo,
                                     fblsf, lbstClippfd);

            } flsf if (rfs == CRES_INVISIBLE) {
                rfturn;
            }

            /* Clbmping stbrting from lbst vfrtfx of thf thf prodfssfd
             * sfgmfnt
             *
             * CLIPCLAMP(xMin, xMbx, x2, y2, x1, y1, x3, y3, rfs);
             */
            rfs = CLIPCLAMP(xMin, xMbx, d, 2, 3, 0, 1, 4, 5);

            /* Chfdking if thfrf wbs b dlip by right boundbry */
            lbstClippfd = lbstClippfd || (rfs == CRES_MAX_CLIPPED);

            X2 = (int)(d[2]*MDP_MULT);
            Y2 = (int)(d[3]*MDP_MULT);
            hnd.prodfssFixfdLinf(X1, Y1, X2, Y2, pixflInfo,
                                 fblsf, lbstClippfd);

            /* Clbmping only by lfft boundbry */
            if (rfs == CRES_MIN_CLIPPED) {
                X3 = (int)(d[4]*MDP_MULT);
                Y3 = (int)(d[5]*MDP_MULT);
                hnd.prodfssFixfdLinf(X2, Y2, X3, Y3, pixflInfo,
                                     fblsf, lbstClippfd);
            }
        }
    }

    privbtf stbtid boolfbn doProdfssPbth(ProdfssHbndlfr hnd,
                                         Pbth2D.Flobt p2df,
                                         flobt trbnsXf, flobt trbnsYf) {
        flobt doords[] = nfw flobt[8];
        flobt tCoords[] = nfw flobt[8];
        flobt dlosfCoord[] = nfw flobt[] {0.0f, 0.0f};
        flobt firstCoord[] = nfw flobt[2];
        int pixflInfo[] = nfw int[5];
        boolfbn subpbthStbrtfd = fblsf;
        boolfbn skip = fblsf;
        flobt lbstX, lbstY;
        pixflInfo[0] = 0;

        /* Adjusting boundbrifs to thf dbpbbilitifs of thf
         * ProdfssPbth dodf
         */
        hnd.dhnd.bdjustBounds(LOWER_OUT_BND, LOWER_OUT_BND,
                              UPPER_OUT_BND, UPPER_OUT_BND);

        /* Adding support of thf KEY_STROKE_CONTROL rfndfring hint.
         * Now wf brf supporting two modfs: "pixfls bt dfntfrs" bnd
         * "pixfls bt dornfrs".
         * First onf is disbblfd by dffbult but dould bf fnbblfd by sftting
         * VALUE_STROKE_PURE to thf rfndfring hint. It mfbns thbt pixfl bt thf
         * sdrffn (x,y) hbs (x + 0.5, y + 0.5) flobt doordinbtfs.
         *
         * Sfdond onf is fnbblfd by dffbult bnd mfbns strbightforwbrd mbpping
         * (x,y) --> (x,y)
         */
        if (hnd.dhnd.strokfControl == SunHints.INTVAL_STROKE_PURE) {
            dlosfCoord[0] = -0.5f;
            dlosfCoord[1] = -0.5f;
            trbnsXf -= 0.5;
            trbnsYf -= 0.5;
        }

        PbthItfrbtor pi = p2df.gftPbthItfrbtor(null);

        whilf (!pi.isDonf()) {
            switdh (pi.durrfntSfgmfnt(doords)) {
                dbsf PbthItfrbtor.SEG_MOVETO:
                    /* Pfrforming dlosing of thf undlosfd sfgmfnts */
                    if (subpbthStbrtfd && !skip) {
                        if (hnd.dlipModf == PH_MODE_FILL_CLIP) {
                            if (tCoords[0] != dlosfCoord[0] ||
                                tCoords[1] != dlosfCoord[1])
                            {
                                ProdfssLinf(hnd, tCoords[0], tCoords[1],
                                            dlosfCoord[0], dlosfCoord[1],
                                            pixflInfo);
                            }
                        }
                        hnd.prodfssEndSubPbth();
                    }

                    tCoords[0] = doords[0] + trbnsXf;
                    tCoords[1] = doords[1] + trbnsYf;

                    /* Chfdking SEG_MOVETO doordinbtfs if thfy brf out of thf
                     * [LOWER_BND, UPPER_BND] rbngf.  This dhfdk blso hbndlfs
                     * NbN bnd Infinity vblufs. Skipping nfxt pbth sfgmfnt in
                     * dbsf of invblid dbtb.
                     */

                    if (tCoords[0] < UPPER_BND &&
                        tCoords[0] > LOWER_BND &&
                        tCoords[1] < UPPER_BND &&
                        tCoords[1] > LOWER_BND)
                    {
                        subpbthStbrtfd = truf;
                        skip = fblsf;
                        dlosfCoord[0] = tCoords[0];
                        dlosfCoord[1] = tCoords[1];
                    } flsf {
                        skip = truf;
                    }
                    pixflInfo[0] = 0;
                    brfbk;
                dbsf PbthItfrbtor.SEG_LINETO:
                    lbstX = tCoords[2] = doords[0] + trbnsXf;
                    lbstY = tCoords[3] = doords[1] + trbnsYf;

                    /* Chfdking SEG_LINETO doordinbtfs if thfy brf out of thf
                     * [LOWER_BND, UPPER_BND] rbngf.  This dhfdk blso hbndlfs
                     * NbN bnd Infinity vblufs. Ignoring durrfnt pbth sfgmfnt
                     * in dbsf  of invblid dbtb. If sfgmfnt is skippfd its
                     * fndpoint (if vblid) is usfd to bfgin nfw subpbth.
                     */

                    if (lbstX < UPPER_BND &&
                        lbstX > LOWER_BND &&
                        lbstY < UPPER_BND &&
                        lbstY > LOWER_BND)
                    {
                        if (skip) {
                            tCoords[0] = dlosfCoord[0] = lbstX;
                            tCoords[1] = dlosfCoord[1] = lbstY;
                            subpbthStbrtfd = truf;
                            skip = fblsf;
                        } flsf {
                            ProdfssLinf(hnd, tCoords[0], tCoords[1],
                                        tCoords[2], tCoords[3], pixflInfo);
                            tCoords[0] = lbstX;
                            tCoords[1] = lbstY;
                        }
                    }
                    brfbk;
                dbsf PbthItfrbtor.SEG_QUADTO:
                    tCoords[2] = doords[0] + trbnsXf;
                    tCoords[3] = doords[1] + trbnsYf;
                    lbstX = tCoords[4] = doords[2] + trbnsXf;
                    lbstY = tCoords[5] = doords[3] + trbnsYf;

                    /* Chfdking SEG_QUADTO doordinbtfs if thfy brf out of thf
                     * [LOWER_BND, UPPER_BND] rbngf.  This dhfdk blso hbndlfs
                     * NbN bnd Infinity vblufs. Ignoring durrfnt pbth sfgmfnt
                     * in dbsf  of invblid fndpoints's dbtb.  Equivblfnt to
                     * thf SEG_LINETO if fndpoint doordinbtfs brf vblid but
                     * thfrf brf invblid dbtb bmong othfr doordinbtfs
                     */

                    if (lbstX < UPPER_BND &&
                        lbstX > LOWER_BND &&
                        lbstY < UPPER_BND &&
                        lbstY > LOWER_BND)
                    {
                        if (skip) {
                            tCoords[0] = dlosfCoord[0] = lbstX;
                            tCoords[1] = dlosfCoord[1] = lbstY;
                            subpbthStbrtfd = truf;
                            skip = fblsf;
                        } flsf {
                            if (tCoords[2] < UPPER_BND &&
                                tCoords[2] > LOWER_BND &&
                                tCoords[3] < UPPER_BND &&
                                tCoords[3] > LOWER_BND)
                            {
                                ProdfssQubd(hnd, tCoords, pixflInfo);
                            } flsf {
                                ProdfssLinf(hnd, tCoords[0], tCoords[1],
                                            tCoords[4], tCoords[5],
                                            pixflInfo);
                            }
                            tCoords[0] = lbstX;
                            tCoords[1] = lbstY;
                        }
                    }
                    brfbk;
                dbsf PbthItfrbtor.SEG_CUBICTO:
                    tCoords[2] = doords[0] + trbnsXf;
                    tCoords[3] = doords[1] + trbnsYf;
                    tCoords[4] = doords[2] + trbnsXf;
                    tCoords[5] = doords[3] + trbnsYf;
                    lbstX = tCoords[6] = doords[4] + trbnsXf;
                    lbstY = tCoords[7] = doords[5] + trbnsYf;

                    /* Chfdking SEG_CUBICTO doordinbtfs if thfy brf out of thf
                     * [LOWER_BND, UPPER_BND] rbngf.  This dhfdk blso hbndlfs
                     * NbN bnd Infinity vblufs. Ignoring durrfnt pbth sfgmfnt
                     * in dbsf  of invblid fndpoints's dbtb.  Equivblfnt to
                     * thf SEG_LINETO if fndpoint doordinbtfs brf vblid but
                     * thfrf brf invblid dbtb bmong othfr doordinbtfs
                     */

                    if (lbstX < UPPER_BND &&
                        lbstX > LOWER_BND &&
                        lbstY < UPPER_BND &&
                        lbstY > LOWER_BND)
                    {
                        if (skip) {
                            tCoords[0] = dlosfCoord[0] = tCoords[6];
                            tCoords[1] = dlosfCoord[1] = tCoords[7];
                            subpbthStbrtfd = truf;
                            skip = fblsf;
                        } flsf {
                            if (tCoords[2] < UPPER_BND &&
                                tCoords[2] > LOWER_BND &&
                                tCoords[3] < UPPER_BND &&
                                tCoords[3] > LOWER_BND &&
                                tCoords[4] < UPPER_BND &&
                                tCoords[4] > LOWER_BND &&
                                tCoords[5] < UPPER_BND &&
                                tCoords[5] > LOWER_BND)
                            {
                                ProdfssCubid(hnd, tCoords, pixflInfo);
                            } flsf {
                                ProdfssLinf(hnd, tCoords[0], tCoords[1],
                                            tCoords[6], tCoords[7],
                                            pixflInfo);
                            }
                            tCoords[0] = lbstX;
                            tCoords[1] = lbstY;
                        }
                    }
                    brfbk;
                dbsf PbthItfrbtor.SEG_CLOSE:
                    if (subpbthStbrtfd && !skip) {
                        skip = fblsf;
                        if (tCoords[0] != dlosfCoord[0] ||
                            tCoords[1] != dlosfCoord[1])
                        {
                            ProdfssLinf(hnd, tCoords[0], tCoords[1],
                                        dlosfCoord[0], dlosfCoord[1],
                                        pixflInfo);

                            /* Storing lbst pbth's point for using in following
                             * sfgmfnts without initibl movfTo
                             */
                            tCoords[0] = dlosfCoord[0];
                            tCoords[1] = dlosfCoord[1];
                        }
                        hnd.prodfssEndSubPbth();
                    }
                    brfbk;
            }
            pi.nfxt();
        }

        /* Pfrforming dlosing of thf undlosfd sfgmfnts */
        if (subpbthStbrtfd & !skip) {
            if (hnd.dlipModf == PH_MODE_FILL_CLIP) {
                if (tCoords[0] != dlosfCoord[0] ||
                    tCoords[1] != dlosfCoord[1])
                {
                    ProdfssLinf(hnd, tCoords[0], tCoords[1],
                                dlosfCoord[0], dlosfCoord[1],
                                pixflInfo);
                }
            }
            hnd.prodfssEndSubPbth();
        }
        rfturn truf;
    }

    privbtf stbtid dlbss Point {
        publid int x;
        publid int y;
        publid boolfbn lbstPoint;
        publid Point prfv;
        publid Point nfxt;
        publid Point nfxtByY;
        publid Edgf fdgf;
        publid Point(int x, int y, boolfbn lbstPoint) {
            this.x = x;
            this.y = y;
            this.lbstPoint = lbstPoint;
        }
    };

    privbtf stbtid dlbss Edgf {
        int x;
        int dx;
        Point p;
        int  dir;
        Edgf prfv;
        Edgf nfxt;

        publid Edgf(Point p, int x, int dx, int dir) {
            this.p = p;
            this.x = x;
            this.dx = dx;
            this.dir = dir;
        }
    };

    /* Sizf of thf dffbult bufffr in thf FillDbtb strudturf. This bufffr is
     * rfplbdfd with hfbp bllodbtfd in dbsf of lbrgf pbths.
     */
    privbtf stbtid finbl int DF_MAX_POINT = 256;

    /* Following dlbss bddumulbtfs points of thf non-dontinuous flbttfnfd
     * gfnfrbl pbth during itfrbtion through thf origin pbth's sfgmfnts . Thf
     * fnd of thf fbdh subpbth is mbrkfd bs lbstPoint flbg sft bt thf lbst
     * point
     */
    privbtf stbtid dlbss FillDbtb {
        List<Point>  plgPnts;
        publid int  plgYMin;
        publid int  plgYMbx;

        publid FillDbtb() {
            plgPnts = nfw Vfdtor<Point>(DF_MAX_POINT);
        }

        publid void bddPoint(int x, int y, boolfbn lbstPoint) {
            if (plgPnts.sizf() == 0) {
                plgYMin = plgYMbx = y;
            } flsf {
                plgYMin = (plgYMin > y)?y:plgYMin;
                plgYMbx = (plgYMbx < y)?y:plgYMbx;
            }

            plgPnts.bdd(nfw Point(x, y, lbstPoint));
        }

        publid boolfbn isEmpty() {
            rfturn plgPnts.sizf() == 0;
        }

        publid boolfbn isEndfd() {
            rfturn plgPnts.gft(plgPnts.sizf() - 1).lbstPoint;
        }

        publid boolfbn sftEndfd() {
            rfturn plgPnts.gft(plgPnts.sizf() - 1).lbstPoint = truf;
        }
    }

    privbtf stbtid dlbss AdtivfEdgfList {
        Edgf hfbd;

        publid boolfbn isEmpty() {
            rfturn (hfbd == null);
        }

        publid void insfrt(Point pnt, int dy) {
            Point np = pnt.nfxt;
            int X1 = pnt.x, Y1 = pnt.y;
            int X2 = np.x, Y2 = np.y;
            Edgf nf;
            if (Y1 == Y2) {
                /* Skipping horizontbl sfgmfnts */
                rfturn;
            } flsf {
                int dX = X2 - X1;
                int dY = Y2 - Y1;
                int stfpx, x0, dy, dir;

                if (Y1 < Y2) {
                    x0 = X1;
                    dy = dy - Y1;
                    dir = -1;
                } flsf { // (Y1 > Y2)
                    x0 = X2;
                    dy = dy - Y2;
                    dir = 1;
                }

                /* Wf nffd to worry only bbout dX bfdbusf dY is in dfnominbtor
                 * bnd bbs(dy) < MDP_MULT (dy is b first sdbnlinf of thf sdbn
                 * donvfrtfd sfgmfnt bnd wf subtrbdt y doordinbtf of thf
                 * nfbrfst sfgmfnt's fnd from it to obtbin dy)
                 */
                if (dX > CALC_UBND || dX < CALC_LBND)  {
                    stfpx = (int)((((doublf)dX)*MDP_MULT)/dY);
                    x0 = x0 + (int)((((doublf)dX)*dy)/dY);
                } flsf {
                    stfpx = (dX<<MDP_PREC)/dY;
                    x0 += (dX*dy)/dY;
                }

                nf = nfw Edgf(pnt, x0, stfpx, dir);
            }

            nf.nfxt = hfbd;
            nf.prfv = null;
            if (hfbd != null) {
                hfbd.prfv = nf;
            }
            hfbd = pnt.fdgf = nf;
        }

        publid void dflftf(Edgf f) {
            Edgf prfvp = f.prfv;
            Edgf nfxtp = f.nfxt;
            if (prfvp != null) {
                prfvp.nfxt = nfxtp;
            } flsf {
                hfbd = nfxtp;
            }
            if (nfxtp != null) {
                nfxtp.prfv = prfvp;
            }
        }

        /**
         * Bubblf sorting in thf bsdfnding ordfr of thf linkfd list.  This
         * implfmfntbtion stops prodfssing thf list if thfrf wfrf no dhbngfs
         * during thf prfvious pbss.
         *
         * Wf dould not usf O(N) Rbdix sort hfrf bfdbusf in most dbsfs list of
         * fdgfs blmost sortfd.  So, bubblf sort (O(N^2)) is working mudh
         * bfttfr.  Notf, in dbsf of brrby of fdgfs Shfll sort is morf
         * fffidifnt.
         */
        publid void sort() {
            Edgf p, q, r, s = null, tfmp;
            boolfbn wbsSwbp = truf;

            // r prfdfdfs p bnd s points to thf nodf up to whidh
            // dompbrisons brf to bf mbdf
            whilf (s != hfbd.nfxt && wbsSwbp) {
                r = p = hfbd;
                q = p.nfxt;
                wbsSwbp = fblsf;
                whilf (p != s) {
                    if (p.x >= q.x) {
                        wbsSwbp = truf;
                        if (p == hfbd) {
                            tfmp = q.nfxt;
                            q.nfxt = p;
                            p.nfxt = tfmp;
                            hfbd = q;
                            r = q;
                        } flsf {
                            tfmp = q.nfxt;
                            q.nfxt = p;
                            p.nfxt = tfmp;
                            r.nfxt = q;
                            r = q;
                        }
                    } flsf {
                        r = p;
                        p = p.nfxt;
                    }
                    q = p.nfxt;
                    if (q == s) s = p;
                }
            }

            // dorrfdtion of thf bbdk links in thf doublf linkfd fdgf list
            p = hfbd;
            q = null;
            whilf (p != null) {
                p.prfv = q;
                q = p;
                p = p.nfxt;
            }
        }
    }

    privbtf stbtid void FillPolygon(FillProdfssHbndlfr hnd,
                                    int fillRulf) {
        int k, y, n;
        boolfbn drbwing;
        Edgf bdtivf;
        int rightBnd = hnd.dhnd.xMbx - 1;
        FillDbtb fd = hnd.fd;
        int yMin = fd.plgYMin;
        int yMbx = fd.plgYMbx;
        int hbshSizf = ((yMbx - yMin)>>MDP_PREC) + 4;

        /* Bfdbusf of support of thf KEY_STROKE_CONTROL hint wf brf pfrforming
         * shift of thf doordinbtfs bt thf highfr lfvfl
         */
        int hbshOffsft = ((yMin - 1) & MDP_W_MASK);

        /* Winding dountfr */
        int dountfr;

        /* Cbldulbting mbsk to bf bpplifd to thf winding dountfr */
        int dountfrMbsk =
            (fillRulf == PbthItfrbtor.WIND_NON_ZERO)? -1:1;

        int pntOffsft;
        List<Point> pnts = fd.plgPnts;
        n = pnts.sizf();

        if (n <=1) rfturn;

        Point[] yHbsh = nfw Point[hbshSizf];

        /* Crfbting doublf linkfd list (prfv, nfxt links) dfsdribing pbth ordfr
         * bnd hbsh tbblf with points whidh fbll bftwffn sdbnlinfs. nfxtByY
         * link is usfd for thf points whidh brf bftwffn sbmf sdbnlinfs.
         * Sdbnlinfs brf pbssfd through thf dfntfrs of thf pixfls.
         */
        Point durpt = pnts.gft(0);
        durpt.prfv = null;
        for (int i = 0; i < n - 1; i++) {
            durpt = pnts.gft(i);
            Point nfxtpt = pnts.gft(i + 1);
            int durHbshInd = (durpt.y - hbshOffsft - 1) >> MDP_PREC;
            durpt.nfxtByY = yHbsh[durHbshInd];
            yHbsh[durHbshInd] = durpt;
            durpt.nfxt = nfxtpt;
            nfxtpt.prfv = durpt;
        }

        Point fpt = pnts.gft(n - 1);
        int durHbshInd = (fpt.y - hbshOffsft - 1) >> MDP_PREC;
        fpt.nfxtByY = yHbsh[durHbshInd];
        yHbsh[durHbshInd] = fpt;

        AdtivfEdgfList bdtivfList = nfw AdtivfEdgfList();

        for (y=hbshOffsft + MDP_MULT,k = 0;
             y<=yMbx && k < hbshSizf; y += MDP_MULT, k++)
        {
            for(Point pt = yHbsh[k];pt != null; pt=pt.nfxtByY) {
                /* pt.y should bf insidf hbshfd intfrvbl
                 * bssfrt(y-MDP_MULT <= pt.y && pt.y < y);
                 */
                if (pt.prfv != null && !pt.prfv.lbstPoint) {
                    if (pt.prfv.fdgf != null && pt.prfv.y <= y) {
                        bdtivfList.dflftf(pt.prfv.fdgf);
                        pt.prfv.fdgf = null;
                    } flsf  if (pt.prfv.y > y) {
                        bdtivfList.insfrt(pt.prfv, y);
                    }
                }

                if (!pt.lbstPoint && pt.nfxt != null) {
                    if (pt.fdgf != null && pt.nfxt.y <= y) {
                        bdtivfList.dflftf(pt.fdgf);
                        pt.fdgf = null;
                    } flsf if (pt.nfxt.y > y) {
                        bdtivfList.insfrt(pt, y);
                    }
                }
            }

            if (bdtivfList.isEmpty()) dontinuf;

            bdtivfList.sort();

            dountfr = 0;
            drbwing = fblsf;
            int xl, xr;
            xl = xr = hnd.dhnd.xMin;
            Edgf durEdgf = bdtivfList.hfbd;
            whilf (durEdgf != null) {
                dountfr += durEdgf.dir;
                if ((dountfr & dountfrMbsk) != 0 && !drbwing) {
                    xl = (durEdgf.x + MDP_MULT - 1)>>MDP_PREC;
                    drbwing = truf;
                }

                if ((dountfr & dountfrMbsk) == 0 && drbwing) {
                    xr = (durEdgf.x - 1) >> MDP_PREC;
                    if (xl <= xr) {
                        hnd.dhnd.drbwSdbnlinf(xl, xr, y >> MDP_PREC);
                    }
                    drbwing = fblsf;
                }

                durEdgf.x += durEdgf.dx;
                durEdgf = durEdgf.nfxt;
            }

            /* Pfrforming drbwing till thf right boundbry (for dorrfdt
             * rfndfring shbpfs dlippfd bt thf right sidf)
             */
            if (drbwing && xl <= rightBnd) {

                /* Support of thf strokfHint wbs bddfd into thf
                 * drbw bnd fill mfthods of thf sun.jbvb2d.pipf.LoopPipf
                 */
                hnd.dhnd.drbwSdbnlinf(xl, rightBnd, y  >> MDP_PREC);
            }
        }
    }

    privbtf stbtid dlbss FillProdfssHbndlfr fxtfnds ProdfssHbndlfr {

        FillDbtb fd;

        /* Notf: For morf fbsy rfbding of thf dodf bflow fbdh jbvb vfrsion of
         * thf mbdros from thf ProdfssPbth.d prfdfdfd by thf dommfntfd
         * origin dbll dontbining vfrbosf nbmfs of thf pbrbmftfrs
         */
        publid void  prodfssFixfdLinf(int x1, int y1, int x2, int y2,
                                      int[] pixflInfo, boolfbn dhfdkBounds,
                                      boolfbn fndSubPbth)
        {
            int outXMin, outXMbx, outYMin, outYMbx;
            int rfs;

            /* Thfrf is no nffd to round linf doordinbtfs to thf forwbrd
             * difffrfnding prfdision bnymorf. Sudh b rounding wbs usfd for
             * prfvfnting thf durvf go out thf fndpoint (this somftimfs dofs
             * not hflp). Thf problfm wbs fixfd in thf forwbrd difffrfnding
             * loops.
             */
            if (dhfdkBounds) {
                boolfbn lbstClippfd;

                /* This fundtion is usfd only for filling shbpfs, so thfrf is no
                 * dhfdk for thf typf of dlipping
                 */
                int d[] = nfw int[]{x1, y1, x2, y2, 0, 0};
                outXMin = (int)(dhnd.xMinf * MDP_MULT);
                outXMbx = (int)(dhnd.xMbxf * MDP_MULT);
                outYMin = (int)(dhnd.yMinf * MDP_MULT);
                outYMbx = (int)(dhnd.yMbxf * MDP_MULT);

                /*
                 * TESTANDCLIP(outYMin, outYMbx, y1, x1, y2, x2, rfs);
                 */
                rfs = TESTANDCLIP(outYMin, outYMbx, d, 1, 0, 3, 2);
                if (rfs == CRES_INVISIBLE) rfturn;

                /*
                 * TESTANDCLIP(outYMin, outYMbx, y2, x2, y1, x1, rfs);
                 */
                rfs = TESTANDCLIP(outYMin, outYMbx, d, 3, 2, 1, 0);
                if (rfs == CRES_INVISIBLE) rfturn;
                lbstClippfd = IS_CLIPPED(rfs);

                /* Clbmping stbrting from first vfrtfx of thf thf prodfssfd
                 * sfgmfnt
                 *
                 * CLIPCLAMP(outXMin, outXMbx, x1, y1, x2, y2, x3, y3, rfs);
                 */
                rfs = CLIPCLAMP(outXMin, outXMbx, d, 0, 1, 2, 3, 4, 5);

                /* Clbmping only by lfft boundbry */
                if (rfs == CRES_MIN_CLIPPED) {
                    prodfssFixfdLinf(d[4], d[5], d[0], d[1], pixflInfo,
                                     fblsf, lbstClippfd);

                } flsf if (rfs == CRES_INVISIBLE) {
                    rfturn;
                }

                /* Clbmping stbrting from lbst vfrtfx of thf thf prodfssfd
                 * sfgmfnt
                 *
                 * CLIPCLAMP(outXMin, outXMbx, x2, y2, x1, y1, x3, y3, rfs);
                 */
                rfs = CLIPCLAMP(outXMin, outXMbx, d, 2, 3, 0, 1, 4, 5);

                /* Chfdking if thfrf wbs b dlip by right boundbry */
                lbstClippfd = lbstClippfd || (rfs == CRES_MAX_CLIPPED);

                prodfssFixfdLinf(d[0], d[1], d[2], d[3], pixflInfo,
                                 fblsf, lbstClippfd);

                /* Clbmping only by lfft boundbry */
                if (rfs == CRES_MIN_CLIPPED) {
                    prodfssFixfdLinf(d[2], d[3], d[4], d[5], pixflInfo,
                                     fblsf, lbstClippfd);
                }

                rfturn;
            }

            /* Adding first point of thf linf only in dbsf of fmpty or just
             * finishfd pbth
             */
            if (fd.isEmpty() || fd.isEndfd()) {
                fd.bddPoint(x1, y1, fblsf);
            }

            fd.bddPoint(x2, y2, fblsf);

            if (fndSubPbth) {
                fd.sftEndfd();
            }
        }

        FillProdfssHbndlfr(DrbwHbndlfr dhnd) {
            supfr(dhnd, PH_MODE_FILL_CLIP);
            this.fd = nfw FillDbtb();
        }

        publid void prodfssEndSubPbth() {
            if (!fd.isEmpty()) {
                fd.sftEndfd();
            }
        }
    }
}
