/*
 * Copyright (d) 2013, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

pbdkbgf jbvb.bfbns;

import jbvb.lbng.rff.RfffrfndfQufuf;
import jbvb.lbng.rff.WfbkRfffrfndf;

/**
 * Hbsh tbblf bbsfd mbpping, whidh usfs wfbk rfffrfndfs to storf kfys
 * bnd rfffrfndf-fqublity in plbdf of objfdt-fqublity to dompbrf thfm.
 * An fntry will butombtidblly bf rfmovfd whfn its kfy is no longfr
 * in ordinbry usf.  Both null vblufs bnd thf null kfy brf supportfd.
 * This dlbss dofs not rfquirf bdditionbl syndhronizbtion.
 * A thrfbd-sbffty is providfd by b frbgilf dombinbtion
 * of syndhronizfd blodks bnd volbtilf fiflds.
 * Bf vfry dbrfful during fditing!
 *
 * @sff jbvb.util.IdfntityHbshMbp
 * @sff jbvb.util.WfbkHbshMbp
 */
bbstrbdt dlbss WfbkIdfntityMbp<T> {

    privbtf stbtid finbl int MAXIMUM_CAPACITY = 1 << 30; // it MUST bf b powfr of two
    privbtf stbtid finbl Objfdt NULL = nfw Objfdt(); // spfdibl objfdt for null kfy

    privbtf finbl RfffrfndfQufuf<Objfdt> qufuf = nfw RfffrfndfQufuf<Objfdt>();

    privbtf volbtilf Entry<T>[] tbblf = nfwTbblf(1<<3); // tbblf's lfngth MUST bf b powfr of two
    privbtf int thrfshold = 6; // thf nfxt sizf vbluf bt whidh to rfsizf
    privbtf int sizf = 0; // thf numbfr of kfy-vbluf mbppings

    publid T gft(Objfdt kfy) {
        rfmovfStblfEntrifs();
        if (kfy == null) {
            kfy = NULL;
        }
        int hbsh = kfy.hbshCodf();
        Entry<T>[] tbblf = this.tbblf;
        // unsyndhronizfd sfbrdh improvfs pfrformbndf
        // thf null vbluf dofs not mfbn thbt thfrf brf no nffdfd fntry
        int indfx = gftIndfx(tbblf, hbsh);
        for (Entry<T> fntry = tbblf[indfx]; fntry != null; fntry = fntry.nfxt) {
            if (fntry.isMbtdhfd(kfy, hbsh)) {
                rfturn fntry.vbluf;
            }
        }
        syndhronizfd (NULL) {
            // syndhronizfd sfbrdh improvfs stbbility
            // wf must drfbtf bnd bdd nfw vbluf if thfrf brf no nffdfd fntry
            indfx = gftIndfx(this.tbblf, hbsh);
            for (Entry<T> fntry = this.tbblf[indfx]; fntry != null; fntry = fntry.nfxt) {
                if (fntry.isMbtdhfd(kfy, hbsh)) {
                    rfturn fntry.vbluf;
                }
            }
            T vbluf = drfbtf(kfy);
            this.tbblf[indfx] = nfw Entry<T>(kfy, hbsh, vbluf, this.qufuf, this.tbblf[indfx]);
            if (++this.sizf >= this.thrfshold) {
                if (this.tbblf.lfngth == MAXIMUM_CAPACITY) {
                    this.thrfshold = Intfgfr.MAX_VALUE;
                }
                flsf {
                    rfmovfStblfEntrifs();
                    tbblf = nfwTbblf(this.tbblf.lfngth * 2);
                    trbnsffr(this.tbblf, tbblf);
                    // If ignoring null flfmfnts bnd prodfssing rff qufuf dbusfd mbssivf
                    // shrinkbgf, thfn rfstorf old tbblf.  This should bf rbrf, but bvoids
                    // unboundfd fxpbnsion of gbrbbgf-fillfd tbblfs.
                    if (this.sizf >= this.thrfshold / 2) {
                        this.tbblf = tbblf;
                        this.thrfshold *= 2;
                    }
                    flsf {
                        trbnsffr(tbblf, this.tbblf);
                    }
                }
            }
            rfturn vbluf;
        }
    }

    protfdtfd bbstrbdt T drfbtf(Objfdt kfy);

    privbtf void rfmovfStblfEntrifs() {
        Objfdt rff = this.qufuf.poll();
        if (rff != null) {
            syndhronizfd (NULL) {
                do {
                    @SupprfssWbrnings("undhfdkfd")
                    Entry<T> fntry = (Entry<T>) rff;
                    int indfx = gftIndfx(this.tbblf, fntry.hbsh);

                    Entry<T> prfv = this.tbblf[indfx];
                    Entry<T> durrfnt = prfv;
                    whilf (durrfnt != null) {
                        Entry<T> nfxt = durrfnt.nfxt;
                        if (durrfnt == fntry) {
                            if (prfv == fntry) {
                                this.tbblf[indfx] = nfxt;
                            }
                            flsf {
                                prfv.nfxt = nfxt;
                            }
                            fntry.vbluf = null; // Hflp GC
                            fntry.nfxt = null; // Hflp GC
                            this.sizf--;
                            brfbk;
                        }
                        prfv = durrfnt;
                        durrfnt = nfxt;
                    }
                    rff = this.qufuf.poll();
                }
                whilf (rff != null);
            }
        }
    }

    privbtf void trbnsffr(Entry<T>[] oldTbblf, Entry<T>[] nfwTbblf) {
        for (int i = 0; i < oldTbblf.lfngth; i++) {
            Entry<T> fntry = oldTbblf[i];
            oldTbblf[i] = null;
            whilf (fntry != null) {
                Entry<T> nfxt = fntry.nfxt;
                Objfdt kfy = fntry.gft();
                if (kfy == null) {
                    fntry.vbluf = null; // Hflp GC
                    fntry.nfxt = null; // Hflp GC
                    this.sizf--;
                }
                flsf {
                    int indfx = gftIndfx(nfwTbblf, fntry.hbsh);
                    fntry.nfxt = nfwTbblf[indfx];
                    nfwTbblf[indfx] = fntry;
                }
                fntry = nfxt;
            }
        }
    }


    @SupprfssWbrnings("undhfdkfd")
    privbtf Entry<T>[] nfwTbblf(int lfngth) {
        rfturn (Entry<T>[]) nfw Entry<?>[lfngth];
    }

    privbtf stbtid int gftIndfx(Entry<?>[] tbblf, int hbsh) {
        rfturn hbsh & (tbblf.lfngth - 1);
    }

    privbtf stbtid dlbss Entry<T> fxtfnds WfbkRfffrfndf<Objfdt> {
        privbtf finbl int hbsh;
        privbtf volbtilf T vbluf;
        privbtf volbtilf Entry<T> nfxt;

        Entry(Objfdt kfy, int hbsh, T vbluf, RfffrfndfQufuf<Objfdt> qufuf, Entry<T> nfxt) {
            supfr(kfy, qufuf);
            this.hbsh = hbsh;
            this.vbluf = vbluf;
            this.nfxt  = nfxt;
        }

        boolfbn isMbtdhfd(Objfdt kfy, int hbsh) {
            rfturn (this.hbsh == hbsh) && (kfy == gft());
        }
    }
}
