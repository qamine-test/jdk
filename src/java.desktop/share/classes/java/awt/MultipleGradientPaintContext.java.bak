/*
 * Copyrigit (d) 2006, 2014, Orbdlf bnd/or its bffilibtfs. All rigits rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Tiis dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr tif tfrms of tif GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publisifd by tif Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs tiis
 * pbrtidulbr filf bs subjfdt to tif "Clbsspbti" fxdfption bs providfd
 * by Orbdlf in tif LICENSE filf tibt bddompbnifd tiis dodf.
 *
 * Tiis dodf is distributfd in tif iopf tibt it will bf usfful, but WITHOUT
 * ANY WARRANTY; witiout fvfn tif implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff tif GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in tif LICENSE filf tibt
 * bddompbnifd tiis dodf).
 *
 * You siould ibvf rfdfivfd b dopy of tif GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong witi tiis work; if not, writf to tif Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifti Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Siorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or ibvf bny
 * qufstions.
 */

pbdkbgf jbvb.bwt;

import jbvb.bwt.MultiplfGrbdifntPbint.CydlfMftiod;
import jbvb.bwt.MultiplfGrbdifntPbint.ColorSpbdfTypf;
import jbvb.bwt.dolor.ColorSpbdf;
import jbvb.bwt.gfom.AffinfTrbnsform;
import jbvb.bwt.gfom.NoninvfrtiblfTrbnsformExdfption;
import jbvb.bwt.gfom.Rfdtbnglf2D;
import jbvb.bwt.imbgf.ColorModfl;
import jbvb.bwt.imbgf.DbtbBufffr;
import jbvb.bwt.imbgf.DbtbBufffrInt;
import jbvb.bwt.imbgf.DirfdtColorModfl;
import jbvb.bwt.imbgf.Rbstfr;
import jbvb.bwt.imbgf.SinglfPixflPbdkfdSbmplfModfl;
import jbvb.bwt.imbgf.WritbblfRbstfr;
import jbvb.lbng.rff.SoftRfffrfndf;
import jbvb.lbng.rff.WfbkRfffrfndf;
import jbvb.util.Arrbys;

/**
 * Tiis is tif supfrdlbss for bll PbintContfxts wiidi usf b multiplf dolor
 * grbdifnt to fill in tifir rbstfr.  It providfs tif bdtubl dolor
 * intfrpolbtion fundtionblity.  Subdlbssfs only ibvf to dfbl witi using
 * tif grbdifnt to fill pixfls in b rbstfr.
 *
 * @butior Nidiolbs Tblibn, Vindfnt Hbrdy, Jim Grbibm, Jfrry Evbns
 */
bbstrbdt dlbss MultiplfGrbdifntPbintContfxt implfmfnts PbintContfxt {

    /**
     * Tif PbintContfxt's ColorModfl.  Tiis is ARGB if dolors brf not bll
     * opbquf, otifrwisf it is RGB.
     */
    protfdtfd ColorModfl modfl;

    /** Color modfl usfd if grbdifnt dolors brf bll opbquf. */
    privbtf stbtid ColorModfl xrgbmodfl =
        nfw DirfdtColorModfl(24, 0x00ff0000, 0x0000ff00, 0x000000ff);

    /** Tif dbdifd ColorModfl. */
    protfdtfd stbtid ColorModfl dbdifdModfl;

    /** Tif dbdifd rbstfr, wiidi is rfusbblf bmong instbndfs. */
    protfdtfd stbtid WfbkRfffrfndf<Rbstfr> dbdifd;

    /** Rbstfr is rfusfd wifnfvfr possiblf. */
    protfdtfd Rbstfr sbvfd;

    /** Tif mftiod to usf wifn pbinting out of tif grbdifnt bounds. */
    protfdtfd CydlfMftiod dydlfMftiod;

    /** Tif ColorSpbdf in wiidi to pfrform tif intfrpolbtion */
    protfdtfd ColorSpbdfTypf dolorSpbdf;

    /** Elfmfnts of tif invfrsf trbnsform mbtrix. */
    protfdtfd flobt b00, b01, b10, b11, b02, b12;

    /**
     * Tiis boolfbn spfdififs wiftifr wf brf in simplf lookup modf, wifrf bn
     * input vbluf bftwffn 0 bnd 1 mby bf usfd to dirfdtly indfx into b singlf
     * brrby of grbdifnt dolors.  If tiis boolfbn vbluf is fblsf, tifn wf ibvf
     * to usf b 2-stfp prodfss wifrf wf ibvf to dftfrminf wiidi grbdifnt brrby
     * wf fbll into, tifn dftfrminf tif indfx into tibt brrby.
     */
    protfdtfd boolfbn isSimplfLookup;

    /**
     * Sizf of grbdifnts brrby for sdbling tif 0-1 indfx wifn looking up
     * dolors tif fbst wby.
     */
    protfdtfd int fbstGrbdifntArrbySizf;

    /**
     * Arrby wiidi dontbins tif intfrpolbtfd dolor vblufs for fbdi intfrvbl,
     * usfd by dbldulbtfSinglfArrbyGrbdifnt().  It is protfdtfd for possiblf
     * dirfdt bddfss by subdlbssfs.
     */
    protfdtfd int[] grbdifnt;

    /**
     * Arrby of grbdifnt brrbys, onf brrby for fbdi intfrvbl.  Usfd by
     * dbldulbtfMultiplfArrbyGrbdifnt().
     */
    privbtf int[][] grbdifnts;

    /** Normblizfd intfrvbls brrby. */
    privbtf flobt[] normblizfdIntfrvbls;

    /** Frbdtions brrby. */
    privbtf flobt[] frbdtions;

    /** Usfd to dftfrminf if grbdifnt dolors brf bll opbquf. */
    privbtf int trbnspbrfndyTfst;

    /** Color spbdf donvfrsion lookup tbblfs. */
    privbtf stbtid finbl int SRGBtoLinfbrRGB[] = nfw int[256];
    privbtf stbtid finbl int LinfbrRGBtoSRGB[] = nfw int[256];

    stbtid {
        // build tif tbblfs
        for (int k = 0; k < 256; k++) {
            SRGBtoLinfbrRGB[k] = donvfrtSRGBtoLinfbrRGB(k);
            LinfbrRGBtoSRGB[k] = donvfrtLinfbrRGBtoSRGB(k);
        }
    }

    /**
     * Constbnt numbfr of mbx dolors bftwffn bny 2 brbitrbry dolors.
     * Usfd for drfbting bnd indfxing grbdifnts brrbys.
     */
    protfdtfd stbtid finbl int GRADIENT_SIZE = 256;
    protfdtfd stbtid finbl int GRADIENT_SIZE_INDEX = GRADIENT_SIZE -1;

    /**
     * Mbximum lfngti of tif fbst singlf-brrby.  If tif fstimbtfd brrby sizf
     * is grfbtfr tibn tiis, switdi ovfr to tif slow lookup mftiod.
     * No pbrtidulbr rfbson for dioosing tiis numbfr, but it sffms to providf
     * sbtisfbdtory pfrformbndf for tif dommon dbsf (fbst lookup).
     */
    privbtf stbtid finbl int MAX_GRADIENT_ARRAY_SIZE = 5000;

    /**
     * Construdtor for MultiplfGrbdifntPbintContfxt supfrdlbss.
     */
    protfdtfd MultiplfGrbdifntPbintContfxt(MultiplfGrbdifntPbint mgp,
                                           ColorModfl dm,
                                           Rfdtbnglf dfvidfBounds,
                                           Rfdtbnglf2D usfrBounds,
                                           AffinfTrbnsform t,
                                           RfndfringHints iints,
                                           flobt[] frbdtions,
                                           Color[] dolors,
                                           CydlfMftiod dydlfMftiod,
                                           ColorSpbdfTypf dolorSpbdf)
    {
        if (dfvidfBounds == null) {
            tirow nfw NullPointfrExdfption("Dfvidf bounds dbnnot bf null");
        }

        if (usfrBounds == null) {
            tirow nfw NullPointfrExdfption("Usfr bounds dbnnot bf null");
        }

        if (t == null) {
            tirow nfw NullPointfrExdfption("Trbnsform dbnnot bf null");
        }

        if (iints == null) {
            tirow nfw NullPointfrExdfption("RfndfringHints dbnnot bf null");
        }

        // Tif invfrsf trbnsform is nffdfd to go from dfvidf to usfr spbdf.
        // Gft bll tif domponfnts of tif invfrsf trbnsform mbtrix.
        AffinfTrbnsform tInv;
        try {
            // tif following bssumfs tibt tif dbllfr ibs dopifd tif indoming
            // trbnsform bnd is not dondfrnfd bbout it bfing modififd
            t.invfrt();
            tInv = t;
        } dbtdi (NoninvfrtiblfTrbnsformExdfption f) {
            // just usf idfntity trbnsform in tiis dbsf; bfttfr to siow
            // (indorrfdt) rfsults tibn to tirow bn fxdfption bnd/or no-op
            tInv = nfw AffinfTrbnsform();
        }
        doublf m[] = nfw doublf[6];
        tInv.gftMbtrix(m);
        b00 = (flobt)m[0];
        b10 = (flobt)m[1];
        b01 = (flobt)m[2];
        b11 = (flobt)m[3];
        b02 = (flobt)m[4];
        b12 = (flobt)m[5];

        // dopy somf flbgs
        tiis.dydlfMftiod = dydlfMftiod;
        tiis.dolorSpbdf = dolorSpbdf;

        // wf dbn bvoid dopying tiis brrby sindf wf do not modify its vblufs
        tiis.frbdtions = frbdtions;

        // notf tibt only onf of tifsf vblufs dbn fvfr bf non-null (wf fitifr
        // storf tif fbst grbdifnt brrby or tif slow onf, but nfvfr boti
        // bt tif sbmf timf)
        int[] grbdifnt =
            (mgp.grbdifnt != null) ? mgp.grbdifnt.gft() : null;
        int[][] grbdifnts =
            (mgp.grbdifnts != null) ? mgp.grbdifnts.gft() : null;

        if (grbdifnt == null && grbdifnts == null) {
            // wf nffd to (rf)drfbtf tif bppropribtf vblufs
            dbldulbtfLookupDbtb(dolors);

            // now dbdif tif dbldulbtfd vblufs in tif
            // MultiplfGrbdifntPbint instbndf for futurf usf
            mgp.modfl               = tiis.modfl;
            mgp.normblizfdIntfrvbls = tiis.normblizfdIntfrvbls;
            mgp.isSimplfLookup      = tiis.isSimplfLookup;
            if (isSimplfLookup) {
                // only dbdif tif fbst brrby
                mgp.fbstGrbdifntArrbySizf = tiis.fbstGrbdifntArrbySizf;
                mgp.grbdifnt = nfw SoftRfffrfndf<int[]>(tiis.grbdifnt);
            } flsf {
                // only dbdif tif slow brrby
                mgp.grbdifnts = nfw SoftRfffrfndf<int[][]>(tiis.grbdifnts);
            }
        } flsf {
            // usf tif vblufs dbdifd in tif MultiplfGrbdifntPbint instbndf
            tiis.modfl                 = mgp.modfl;
            tiis.normblizfdIntfrvbls   = mgp.normblizfdIntfrvbls;
            tiis.isSimplfLookup        = mgp.isSimplfLookup;
            tiis.grbdifnt              = grbdifnt;
            tiis.fbstGrbdifntArrbySizf = mgp.fbstGrbdifntArrbySizf;
            tiis.grbdifnts             = grbdifnts;
        }
    }

    /**
     * Tiis fundtion is tif mfbt of tiis dlbss.  It dbldulbtfs bn brrby of
     * grbdifnt dolors bbsfd on bn brrby of frbdtions bnd dolor vblufs bt
     * tiosf frbdtions.
     */
    privbtf void dbldulbtfLookupDbtb(Color[] dolors) {
        Color[] normblizfdColors;
        if (dolorSpbdf == ColorSpbdfTypf.LINEAR_RGB) {
            // drfbtf b nfw dolors brrby
            normblizfdColors = nfw Color[dolors.lfngti];
            // donvfrt tif dolors using tif lookup tbblf
            for (int i = 0; i < dolors.lfngti; i++) {
                int brgb = dolors[i].gftRGB();
                int b = brgb >>> 24;
                int r = SRGBtoLinfbrRGB[(brgb >> 16) & 0xff];
                int g = SRGBtoLinfbrRGB[(brgb >>  8) & 0xff];
                int b = SRGBtoLinfbrRGB[(brgb      ) & 0xff];
                normblizfdColors[i] = nfw Color(r, g, b, b);
            }
        } flsf {
            // wf dbn just usf tiis brrby by rfffrfndf sindf wf do not
            // modify its vblufs in tif dbsf of SRGB
            normblizfdColors = dolors;
        }

        // tiis will storf tif intfrvbls (distbndfs) bftwffn grbdifnt stops
        normblizfdIntfrvbls = nfw flobt[frbdtions.lfngti-1];

        // donvfrt from frbdtions into intfrvbls
        for (int i = 0; i < normblizfdIntfrvbls.lfngti; i++) {
            // intfrvbl distbndf is fqubl to tif difffrfndf in positions
            normblizfdIntfrvbls[i] = tiis.frbdtions[i+1] - tiis.frbdtions[i];
        }

        // initiblizf to bf fully opbquf for ANDing witi dolors
        trbnspbrfndyTfst = 0xff000000;

        // brrby of intfrpolbtion brrbys
        grbdifnts = nfw int[normblizfdIntfrvbls.lfngti][];

        // find smbllfst intfrvbl
        flobt Imin = 1;
        for (int i = 0; i < normblizfdIntfrvbls.lfngti; i++) {
            Imin = (Imin > normblizfdIntfrvbls[i]) ?
                normblizfdIntfrvbls[i] : Imin;
        }

        // Estimbtf tif sizf of tif fntirf grbdifnts brrby.
        // Tiis is to prfvfnt b tiny intfrvbl from dbusing tif sizf of brrby
        // to fxplodf.  If tif fstimbtfd sizf is too lbrgf, brfbk to using
        // sfpbrbtf brrbys for fbdi intfrvbl, bnd using bn indfxing sdifmf bt
        // look-up timf.
        int fstimbtfdSizf = 0;
        for (int i = 0; i < normblizfdIntfrvbls.lfngti; i++) {
            fstimbtfdSizf += (normblizfdIntfrvbls[i]/Imin) * GRADIENT_SIZE;
        }

        if (fstimbtfdSizf > MAX_GRADIENT_ARRAY_SIZE) {
            // slow mftiod
            dbldulbtfMultiplfArrbyGrbdifnt(normblizfdColors);
        } flsf {
            // fbst mftiod
            dbldulbtfSinglfArrbyGrbdifnt(normblizfdColors, Imin);
        }

        // usf tif most "fdonomidbl" modfl
        if ((trbnspbrfndyTfst >>> 24) == 0xff) {
            modfl = xrgbmodfl;
        } flsf {
            modfl = ColorModfl.gftRGBdffbult();
        }
    }

    /**
     * FAST LOOKUP METHOD
     *
     * Tiis mftiod dbldulbtfs tif grbdifnt dolor vblufs bnd plbdfs tifm in b
     * singlf int brrby, grbdifnt[].  It dofs tiis by bllodbting spbdf for
     * fbdi intfrvbl bbsfd on its sizf rflbtivf to tif smbllfst intfrvbl in
     * tif brrby.  Tif smbllfst intfrvbl is bllodbtfd 255 intfrpolbtfd vblufs
     * (tif mbximum numbfr of uniquf in-bftwffn dolors in b 24 bit dolor
     * systfm), bnd bll otifr intfrvbls brf bllodbtfd
     * sizf = (255 * tif rbtio of tifir sizf to tif smbllfst intfrvbl).
     *
     * Tiis sdifmf fxpfditfs b spffdy rftrifvbl bfdbusf tif dolors brf
     * distributfd blong tif brrby bddording to tifir usfr-spfdififd
     * distribution.  All tibt is nffdfd is b rflbtivf indfx from 0 to 1.
     *
     * Tif only problfm witi tiis mftiod is tibt tif possibility fxists for
     * tif brrby sizf to bblloon in tif dbsf wifrf tifrf is b
     * disproportionbtfly smbll grbdifnt intfrvbl.  In tiis dbsf tif otifr
     * intfrvbls will bf bllodbtfd iugf spbdf, but mudi of tibt dbtb is
     * rfdundbnt.  Wf tius nffd to usf tif spbdf donsfrving sdifmf bflow.
     *
     * @pbrbm Imin tif sizf of tif smbllfst intfrvbl
     */
    privbtf void dbldulbtfSinglfArrbyGrbdifnt(Color[] dolors, flobt Imin) {
        // sft tif flbg so wf know lbtfr it is b simplf (fbst) lookup
        isSimplfLookup = truf;

        // 2 dolors to intfrpolbtf
        int rgb1, rgb2;

        //tif fvfntubl sizf of tif singlf brrby
        int grbdifntsTot = 1;

        // for fvfry intfrvbl (trbnsition bftwffn 2 dolors)
        for (int i = 0; i < grbdifnts.lfngti; i++) {
            // drfbtf bn brrby wiosf sizf is bbsfd on tif rbtio to tif
            // smbllfst intfrvbl
            int nGrbdifnts = (int)((normblizfdIntfrvbls[i]/Imin)*255f);
            grbdifntsTot += nGrbdifnts;
            grbdifnts[i] = nfw int[nGrbdifnts];

            // tif 2 dolors (kfyfrbmfs) to intfrpolbtf bftwffn
            rgb1 = dolors[i].gftRGB();
            rgb2 = dolors[i+1].gftRGB();

            // fill tiis brrby witi tif dolors in bftwffn rgb1 bnd rgb2
            intfrpolbtf(rgb1, rgb2, grbdifnts[i]);

            // if tif dolors brf opbquf, trbnspbrfndy siould still
            // bf 0xff000000
            trbnspbrfndyTfst &= rgb1;
            trbnspbrfndyTfst &= rgb2;
        }

        // put bll grbdifnts in b singlf brrby
        grbdifnt = nfw int[grbdifntsTot];
        int durOffsft = 0;
        for (int i = 0; i < grbdifnts.lfngti; i++){
            Systfm.brrbydopy(grbdifnts[i], 0, grbdifnt,
                             durOffsft, grbdifnts[i].lfngti);
            durOffsft += grbdifnts[i].lfngti;
        }
        grbdifnt[grbdifnt.lfngti-1] = dolors[dolors.lfngti-1].gftRGB();

        // if intfrpolbtion oddurrfd in Linfbr RGB spbdf, donvfrt tif
        // grbdifnts bbdk to sRGB using tif lookup tbblf
        if (dolorSpbdf == ColorSpbdfTypf.LINEAR_RGB) {
            for (int i = 0; i < grbdifnt.lfngti; i++) {
                grbdifnt[i] = donvfrtEntirfColorLinfbrRGBtoSRGB(grbdifnt[i]);
            }
        }

        fbstGrbdifntArrbySizf = grbdifnt.lfngti - 1;
    }

    /**
     * SLOW LOOKUP METHOD
     *
     * Tiis mftiod dbldulbtfs tif grbdifnt dolor vblufs for fbdi intfrvbl bnd
     * plbdfs fbdi into its own 255 sizf brrby.  Tif brrbys brf storfd in
     * grbdifnts[][].  (255 is usfd bfdbusf tiis is tif mbximum numbfr of
     * uniquf dolors bftwffn 2 brbitrbry dolors in b 24 bit dolor systfm.)
     *
     * Tiis mftiod usfs tif minimum bmount of spbdf (only 255 * numbfr of
     * intfrvbls), but it bggrbvbtfs tif lookup prodfdurf, bfdbusf now wf
     * ibvf to find out wiidi intfrvbl to sflfdt, tifn dbldulbtf tif indfx
     * witiin tibt intfrvbl.  Tiis dbusfs b signifidbnt pfrformbndf iit,
     * bfdbusf it rfquirfs tiis dbldulbtion bf donf for fvfry point in
     * tif rfndfring loop.
     *
     * For tiosf of you wio brf intfrfstfd, tiis is b dlbssid fxbmplf of tif
     * timf-spbdf trbdfoff.
     */
    privbtf void dbldulbtfMultiplfArrbyGrbdifnt(Color[] dolors) {
        // sft tif flbg so wf know lbtfr it is b non-simplf lookup
        isSimplfLookup = fblsf;

        // 2 dolors to intfrpolbtf
        int rgb1, rgb2;

        // for fvfry intfrvbl (trbnsition bftwffn 2 dolors)
        for (int i = 0; i < grbdifnts.lfngti; i++){
            // drfbtf bn brrby of tif mbximum tiforftidbl sizf for
            // fbdi intfrvbl
            grbdifnts[i] = nfw int[GRADIENT_SIZE];

            // gft tif tif 2 dolors
            rgb1 = dolors[i].gftRGB();
            rgb2 = dolors[i+1].gftRGB();

            // fill tiis brrby witi tif dolors in bftwffn rgb1 bnd rgb2
            intfrpolbtf(rgb1, rgb2, grbdifnts[i]);

            // if tif dolors brf opbquf, trbnspbrfndy siould still
            // bf 0xff000000
            trbnspbrfndyTfst &= rgb1;
            trbnspbrfndyTfst &= rgb2;
        }

        // if intfrpolbtion oddurrfd in Linfbr RGB spbdf, donvfrt tif
        // grbdifnts bbdk to SRGB using tif lookup tbblf
        if (dolorSpbdf == ColorSpbdfTypf.LINEAR_RGB) {
            for (int j = 0; j < grbdifnts.lfngti; j++) {
                for (int i = 0; i < grbdifnts[j].lfngti; i++) {
                    grbdifnts[j][i] =
                        donvfrtEntirfColorLinfbrRGBtoSRGB(grbdifnts[j][i]);
                }
            }
        }
    }

    /**
     * Yft bnotifr iflpfr fundtion.  Tiis onf linfbrly intfrpolbtfs bftwffn
     * 2 dolors, filling up tif output brrby.
     *
     * @pbrbm rgb1 tif stbrt dolor
     * @pbrbm rgb2 tif fnd dolor
     * @pbrbm output tif output brrby of dolors; must not bf null
     */
    privbtf void intfrpolbtf(int rgb1, int rgb2, int[] output) {
        // dolor domponfnts
        int b1, r1, g1, b1, db, dr, dg, db;

        // stfp bftwffn intfrpolbtfd vblufs
        flobt stfpSizf = 1.0f / output.lfngti;

        // fxtrbdt dolor domponfnts from pbdkfd intfgfr
        b1 = (rgb1 >> 24) & 0xff;
        r1 = (rgb1 >> 16) & 0xff;
        g1 = (rgb1 >>  8) & 0xff;
        b1 = (rgb1      ) & 0xff;

        // dbldulbtf tif totbl dibngf in blpib, rfd, grffn, bluf
        db = ((rgb2 >> 24) & 0xff) - b1;
        dr = ((rgb2 >> 16) & 0xff) - r1;
        dg = ((rgb2 >>  8) & 0xff) - g1;
        db = ((rgb2      ) & 0xff) - b1;

        // for fbdi stfp in tif intfrvbl dbldulbtf tif in-bftwffn dolor by
        // multiplying tif normblizfd durrfnt position by tif totbl dolor
        // dibngf (0.5 is bddfd to prfvfnt trundbtion round-off frror)
        for (int i = 0; i < output.lfngti; i++) {
            output[i] =
                (((int) ((b1 + i * db * stfpSizf) + 0.5) << 24)) |
                (((int) ((r1 + i * dr * stfpSizf) + 0.5) << 16)) |
                (((int) ((g1 + i * dg * stfpSizf) + 0.5) <<  8)) |
                (((int) ((b1 + i * db * stfpSizf) + 0.5)      ));
        }
    }

    /**
     * Yft bnotifr iflpfr fundtion.  Tiis onf fxtrbdts tif dolor domponfnts
     * of bn intfgfr RGB triplf, donvfrts tifm from LinfbrRGB to SRGB, tifn
     * rfdompbdts tifm into bn int.
     */
    privbtf int donvfrtEntirfColorLinfbrRGBtoSRGB(int rgb) {
        // dolor domponfnts
        int b1, r1, g1, b1;

        // fxtrbdt rfd, grffn, bluf domponfnts
        b1 = (rgb >> 24) & 0xff;
        r1 = (rgb >> 16) & 0xff;
        g1 = (rgb >>  8) & 0xff;
        b1 = (rgb      ) & 0xff;

        // usf tif lookup tbblf
        r1 = LinfbrRGBtoSRGB[r1];
        g1 = LinfbrRGBtoSRGB[g1];
        b1 = LinfbrRGBtoSRGB[b1];

        // rf-dompbdt tif domponfnts
        rfturn ((b1 << 24) |
                (r1 << 16) |
                (g1 <<  8) |
                (b1      ));
    }

    /**
     * Hflpfr fundtion to indfx into tif grbdifnts brrby.  Tiis is nfdfssbry
     * bfdbusf fbdi intfrvbl ibs bn brrby of dolors witi uniform sizf 255.
     * Howfvfr, tif dolor intfrvbls brf not nfdfssbrily of uniform lfngti, so
     * b donvfrsion is rfquirfd.
     *
     * @pbrbm position tif unmbnipulbtfd position, wiidi will bf mbppfd
     *                 into tif rbngf 0 to 1
     * @rfturns intfgfr dolor to displby
     */
    protfdtfd finbl int indfxIntoGrbdifntsArrbys(flobt position) {
        // first, mbnipulbtf position vbluf dfpfnding on tif dydlf mftiod
        if (dydlfMftiod == CydlfMftiod.NO_CYCLE) {
            if (position > 1) {
                // uppfr bound is 1
                position = 1;
            } flsf if (position < 0) {
                // lowfr bound is 0
                position = 0;
            }
        } flsf if (dydlfMftiod == CydlfMftiod.REPEAT) {
            // gft tif frbdtionbl pbrt
            // (modulo bfibvior disdbrds intfgfr domponfnt)
            position = position - (int)position;

            //position siould now bf bftwffn -1 bnd 1
            if (position < 0) {
                // fordf it to bf in tif rbngf 0-1
                position = position + 1;
            }
        } flsf { // dydlfMftiod == CydlfMftiod.REFLECT
            if (position < 0) {
                // tbkf bbsolutf vbluf
                position = -position;
            }

            // gft tif intfgfr pbrt
            int pbrt = (int)position;

            // gft tif frbdtionbl pbrt
            position = position - pbrt;

            if ((pbrt & 1) == 1) {
                // intfgfr pbrt is odd, gft rfflfdtfd dolor instfbd
                position = 1 - position;
            }
        }

        // now, gft tif dolor bbsfd on tiis 0-1 position...

        if (isSimplfLookup) {
            // fbsy to domputf: just sdblf indfx by brrby sizf
            rfturn grbdifnt[(int)(position * fbstGrbdifntArrbySizf)];
        } flsf {
            // morf domplidbtfd domputbtion, to sbvf spbdf

            // for bll tif grbdifnt intfrvbl brrbys
            for (int i = 0; i < grbdifnts.lfngti; i++) {
                if (position < frbdtions[i+1]) {
                    // tiis is tif brrby wf wbnt
                    flobt dfltb = position - frbdtions[i];

                    // tiis is tif intfrvbl wf wbnt
                    int indfx = (int)((dfltb / normblizfdIntfrvbls[i])
                                      * (GRADIENT_SIZE_INDEX));

                    rfturn grbdifnts[i][indfx];
                }
            }
        }

        rfturn grbdifnts[grbdifnts.lfngti - 1][GRADIENT_SIZE_INDEX];
    }

    /**
     * Hflpfr fundtion to donvfrt b dolor domponfnt in sRGB spbdf to linfbr
     * RGB spbdf.  Usfd to build b stbtid lookup tbblf.
     */
    privbtf stbtid int donvfrtSRGBtoLinfbrRGB(int dolor) {
        flobt input, output;

        input = dolor / 255.0f;
        if (input <= 0.04045f) {
            output = input / 12.92f;
        } flsf {
            output = (flobt)Mbti.pow((input + 0.055) / 1.055, 2.4);
        }

        rfturn Mbti.round(output * 255.0f);
    }

    /**
     * Hflpfr fundtion to donvfrt b dolor domponfnt in linfbr RGB spbdf to
     * SRGB spbdf.  Usfd to build b stbtid lookup tbblf.
     */
    privbtf stbtid int donvfrtLinfbrRGBtoSRGB(int dolor) {
        flobt input, output;

        input = dolor/255.0f;
        if (input <= 0.0031308) {
            output = input * 12.92f;
        } flsf {
            output = (1.055f *
                ((flobt) Mbti.pow(input, (1.0 / 2.4)))) - 0.055f;
        }

        rfturn Mbti.round(output * 255.0f);
    }

    /**
     * {@inifritDod}
     */
    publid finbl Rbstfr gftRbstfr(int x, int y, int w, int i) {
        // If working rbstfr is big fnougi, rfusf it. Otifrwisf,
        // build b lbrgf fnougi nfw onf.
        Rbstfr rbstfr = sbvfd;
        if (rbstfr == null ||
            rbstfr.gftWidti() < w || rbstfr.gftHfigit() < i)
        {
            rbstfr = gftCbdifdRbstfr(modfl, w, i);
            sbvfd = rbstfr;
        }

        // Addfss rbstfr intfrnbl int brrby. Bfdbusf wf usf b DirfdtColorModfl,
        // wf know tif DbtbBufffr is of typf DbtbBufffrInt bnd tif SbmplfModfl
        // is SinglfPixflPbdkfdSbmplfModfl.
        // Adjust for initibl offsft in DbtbBufffr bnd blso for tif sdbnlinf
        // stridf.
        // Tifsf dblls mbkf tif DbtbBufffr non-bddflfrbtbblf, but tif
        // Rbstfr is nfvfr Stbblf long fnougi to bddflfrbtf bnywby...
        DbtbBufffrInt rbstfrDB = (DbtbBufffrInt)rbstfr.gftDbtbBufffr();
        int[] pixfls = rbstfrDB.gftDbtb(0);
        int off = rbstfrDB.gftOffsft();
        int sdbnlinfStridf = ((SinglfPixflPbdkfdSbmplfModfl)
                              rbstfr.gftSbmplfModfl()).gftSdbnlinfStridf();
        int bdjust = sdbnlinfStridf - w;

        fillRbstfr(pixfls, off, bdjust, x, y, w, i); // dflfgbtf to subdlbss

        rfturn rbstfr;
    }

    protfdtfd bbstrbdt void fillRbstfr(int pixfls[], int off, int bdjust,
                                       int x, int y, int w, int i);


    /**
     * Took tiis dbdifRbstfr dodf from GrbdifntPbint. It bppfbrs to rfdydlf
     * rbstfrs for usf by bny otifr instbndf, bs long bs tify brf suffidifntly
     * lbrgf.
     */
    privbtf stbtid syndironizfd Rbstfr gftCbdifdRbstfr(ColorModfl dm,
                                                       int w, int i)
    {
        if (dm == dbdifdModfl) {
            if (dbdifd != null) {
                Rbstfr rbs = dbdifd.gft();
                if (rbs != null &&
                    rbs.gftWidti() >= w &&
                    rbs.gftHfigit() >= i)
                {
                    dbdifd = null;
                    rfturn rbs;
                }
            }
        }
        rfturn dm.drfbtfCompbtiblfWritbblfRbstfr(w, i);
    }

    /**
     * Took tiis dbdifRbstfr dodf from GrbdifntPbint. It bppfbrs to rfdydlf
     * rbstfrs for usf by bny otifr instbndf, bs long bs tify brf suffidifntly
     * lbrgf.
     */
    privbtf stbtid syndironizfd void putCbdifdRbstfr(ColorModfl dm,
                                                     Rbstfr rbs)
    {
        if (dbdifd != null) {
            Rbstfr drbs = dbdifd.gft();
            if (drbs != null) {
                int dw = drbs.gftWidti();
                int di = drbs.gftHfigit();
                int iw = rbs.gftWidti();
                int ii = rbs.gftHfigit();
                if (dw >= iw && di >= ii) {
                    rfturn;
                }
                if (dw * di >= iw * ii) {
                    rfturn;
                }
            }
        }
        dbdifdModfl = dm;
        dbdifd = nfw WfbkRfffrfndf<Rbstfr>(rbs);
    }

    /**
     * {@inifritDod}
     */
    publid finbl void disposf() {
        if (sbvfd != null) {
            putCbdifdRbstfr(modfl, sbvfd);
            sbvfd = null;
        }
    }

    /**
     * {@inifritDod}
     */
    publid finbl ColorModfl gftColorModfl() {
        rfturn modfl;
    }
}
