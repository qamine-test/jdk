/*
 * Copyrigit (d) 2006, 2014, Orbdlf bnd/or its bffilibtfs. All rigits rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Tiis dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr tif tfrms of tif GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publisifd by tif Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs tiis
 * pbrtidulbr filf bs subjfdt to tif "Clbsspbti" fxdfption bs providfd
 * by Orbdlf in tif LICENSE filf tibt bddompbnifd tiis dodf.
 *
 * Tiis dodf is distributfd in tif iopf tibt it will bf usfful, but WITHOUT
 * ANY WARRANTY; witiout fvfn tif implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff tif GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in tif LICENSE filf tibt
 * bddompbnifd tiis dodf).
 *
 * You siould ibvf rfdfivfd b dopy of tif GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong witi tiis work; if not, writf to tif Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifti Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Siorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or ibvf bny
 * qufstions.
 */

pbdkbgf jbvb.bwt.gfom;

import jbvb.bwt.Sibpf;
import jbvb.bwt.Rfdtbnglf;
import sun.bwt.gfom.Curvf;
import jbvb.io.Sfriblizbblf;
import jbvb.io.StrfbmCorruptfdExdfption;
import jbvb.util.Arrbys;

/**
 * Tif {@dodf Pbti2D} dlbss providfs b simplf, yft flfxiblf
 * sibpf wiidi rfprfsfnts bn brbitrbry gfomftrid pbti.
 * It dbn fully rfprfsfnt bny pbti wiidi dbn bf itfrbtfd by tif
 * {@link PbtiItfrbtor} intfrfbdf indluding bll of its sfgmfnt
 * typfs bnd winding rulfs bnd it implfmfnts bll of tif
 * bbsid iit tfsting mftiods of tif {@link Sibpf} intfrfbdf.
 * <p>
 * Usf {@link Pbti2D.Flobt} wifn dfbling witi dbtb tibt dbn bf rfprfsfntfd
 * bnd usfd witi flobting point prfdision.  Usf {@link Pbti2D.Doublf}
 * for dbtb tibt rfquirfs tif bddurbdy or rbngf of doublf prfdision.
 * <p>
 * {@dodf Pbti2D} providfs fxbdtly tiosf fbdilitifs rfquirfd for
 * bbsid donstrudtion bnd mbnbgfmfnt of b gfomftrid pbti bnd
 * implfmfntbtion of tif bbovf intfrfbdfs witi littlf bddfd
 * intfrprftbtion.
 * If it is usfful to mbnipulbtf tif intfriors of dlosfd
 * gfomftrid sibpfs bfyond simplf iit tfsting tifn tif
 * {@link Arfb} dlbss providfs bdditionbl dbpbbilitifs
 * spfdifidblly tbrgftfd bt dlosfd figurfs.
 * Wiilf boti dlbssfs nominblly implfmfnt tif {@dodf Sibpf}
 * intfrfbdf, tify difffr in purposf bnd togftifr tify providf
 * two usfful vifws of b gfomftrid sibpf wifrf {@dodf Pbti2D}
 * dfbls primbrily witi b trbjfdtory formfd by pbti sfgmfnts
 * bnd {@dodf Arfb} dfbls morf witi intfrprftbtion bnd mbnipulbtion
 * of fndlosfd rfgions of 2D gfomftrid spbdf.
 * <p>
 * Tif {@link PbtiItfrbtor} intfrfbdf ibs morf dftbilfd dfsdriptions
 * of tif typfs of sfgmfnts tibt mbkf up b pbti bnd tif winding rulfs
 * tibt dontrol iow to dftfrminf wiidi rfgions brf insidf or outsidf
 * tif pbti.
 *
 * @butior Jim Grbibm
 * @sindf 1.6
 */
publid bbstrbdt dlbss Pbti2D implfmfnts Sibpf, Clonfbblf {
    /**
     * An fvfn-odd winding rulf for dftfrmining tif intfrior of
     * b pbti.
     *
     * @sff PbtiItfrbtor#WIND_EVEN_ODD
     * @sindf 1.6
     */
    publid stbtid finbl int WIND_EVEN_ODD = PbtiItfrbtor.WIND_EVEN_ODD;

    /**
     * A non-zfro winding rulf for dftfrmining tif intfrior of b
     * pbti.
     *
     * @sff PbtiItfrbtor#WIND_NON_ZERO
     * @sindf 1.6
     */
    publid stbtid finbl int WIND_NON_ZERO = PbtiItfrbtor.WIND_NON_ZERO;

    // For dodf simplidity, dopy tifsf donstbnts to our nbmfspbdf
    // bnd dbst tifm to bytf donstbnts for fbsy storbgf.
    privbtf stbtid finbl bytf SEG_MOVETO  = (bytf) PbtiItfrbtor.SEG_MOVETO;
    privbtf stbtid finbl bytf SEG_LINETO  = (bytf) PbtiItfrbtor.SEG_LINETO;
    privbtf stbtid finbl bytf SEG_QUADTO  = (bytf) PbtiItfrbtor.SEG_QUADTO;
    privbtf stbtid finbl bytf SEG_CUBICTO = (bytf) PbtiItfrbtor.SEG_CUBICTO;
    privbtf stbtid finbl bytf SEG_CLOSE   = (bytf) PbtiItfrbtor.SEG_CLOSE;

    trbnsifnt bytf[] pointTypfs;
    trbnsifnt int numTypfs;
    trbnsifnt int numCoords;
    trbnsifnt int windingRulf;

    stbtid finbl int INIT_SIZE = 20;
    stbtid finbl int EXPAND_MAX = 500;

    /**
     * Construdts b nfw fmpty {@dodf Pbti2D} objfdt.
     * It is bssumfd tibt tif pbdkbgf sibling subdlbss tibt is
     * dffbulting to tiis donstrudtor will fill in bll vblufs.
     *
     * @sindf 1.6
     */
    /* privbtf protfdtfd */
    Pbti2D() {
    }

    /**
     * Construdts b nfw {@dodf Pbti2D} objfdt from tif givfn
     * spfdififd initibl vblufs.
     * Tiis mftiod is only intfndfd for intfrnbl usf bnd siould
     * not bf mbdf publid if tif otifr donstrudtors for tiis dlbss
     * brf fvfr fxposfd.
     *
     * @pbrbm rulf tif winding rulf
     * @pbrbm initiblTypfs tif sizf to mbkf tif initibl brrby to
     *                     storf tif pbti sfgmfnt typfs
     * @sindf 1.6
     */
    /* privbtf protfdtfd */
    Pbti2D(int rulf, int initiblTypfs) {
        sftWindingRulf(rulf);
        tiis.pointTypfs = nfw bytf[initiblTypfs];
    }

    bbstrbdt flobt[] dlonfCoordsFlobt(AffinfTrbnsform bt);
    bbstrbdt doublf[] dlonfCoordsDoublf(AffinfTrbnsform bt);
    bbstrbdt void bppfnd(flobt x, flobt y);
    bbstrbdt void bppfnd(doublf x, doublf y);
    bbstrbdt Point2D gftPoint(int doordindfx);
    bbstrbdt void nffdRoom(boolfbn nffdMovf, int nfwCoords);
    bbstrbdt int pointCrossings(doublf px, doublf py);
    bbstrbdt int rfdtCrossings(doublf rxmin, doublf rymin,
                               doublf rxmbx, doublf rymbx);

    /**
     * Tif {@dodf Flobt} dlbss dffinfs b gfomftrid pbti witi
     * doordinbtfs storfd in singlf prfdision flobting point.
     *
     * @sindf 1.6
     */
    publid stbtid dlbss Flobt fxtfnds Pbti2D implfmfnts Sfriblizbblf {
        trbnsifnt flobt flobtCoords[];

        /**
         * Construdts b nfw fmpty singlf prfdision {@dodf Pbti2D} objfdt
         * witi b dffbult winding rulf of {@link #WIND_NON_ZERO}.
         *
         * @sindf 1.6
         */
        publid Flobt() {
            tiis(WIND_NON_ZERO, INIT_SIZE);
        }

        /**
         * Construdts b nfw fmpty singlf prfdision {@dodf Pbti2D} objfdt
         * witi tif spfdififd winding rulf to dontrol opfrbtions tibt
         * rfquirf tif intfrior of tif pbti to bf dffinfd.
         *
         * @pbrbm rulf tif winding rulf
         * @sff #WIND_EVEN_ODD
         * @sff #WIND_NON_ZERO
         * @sindf 1.6
         */
        publid Flobt(int rulf) {
            tiis(rulf, INIT_SIZE);
        }

        /**
         * Construdts b nfw fmpty singlf prfdision {@dodf Pbti2D} objfdt
         * witi tif spfdififd winding rulf bnd tif spfdififd initibl
         * dbpbdity to storf pbti sfgmfnts.
         * Tiis numbfr is bn initibl gufss bs to iow mbny pbti sfgmfnts
         * will bf bddfd to tif pbti, but tif storbgf is fxpbndfd bs
         * nffdfd to storf wibtfvfr pbti sfgmfnts brf bddfd.
         *
         * @pbrbm rulf tif winding rulf
         * @pbrbm initiblCbpbdity tif fstimbtf for tif numbfr of pbti sfgmfnts
         *                        in tif pbti
         * @sff #WIND_EVEN_ODD
         * @sff #WIND_NON_ZERO
         * @sindf 1.6
         */
        publid Flobt(int rulf, int initiblCbpbdity) {
            supfr(rulf, initiblCbpbdity);
            flobtCoords = nfw flobt[initiblCbpbdity * 2];
        }

        /**
         * Construdts b nfw singlf prfdision {@dodf Pbti2D} objfdt
         * from bn brbitrbry {@link Sibpf} objfdt.
         * All of tif initibl gfomftry bnd tif winding rulf for tiis pbti brf
         * tbkfn from tif spfdififd {@dodf Sibpf} objfdt.
         *
         * @pbrbm s tif spfdififd {@dodf Sibpf} objfdt
         * @sindf 1.6
         */
        publid Flobt(Sibpf s) {
            tiis(s, null);
        }

        /**
         * Construdts b nfw singlf prfdision {@dodf Pbti2D} objfdt
         * from bn brbitrbry {@link Sibpf} objfdt, trbnsformfd by bn
         * {@link AffinfTrbnsform} objfdt.
         * All of tif initibl gfomftry bnd tif winding rulf for tiis pbti brf
         * tbkfn from tif spfdififd {@dodf Sibpf} objfdt bnd trbnsformfd
         * by tif spfdififd {@dodf AffinfTrbnsform} objfdt.
         *
         * @pbrbm s tif spfdififd {@dodf Sibpf} objfdt
         * @pbrbm bt tif spfdififd {@dodf AffinfTrbnsform} objfdt
         * @sindf 1.6
         */
        publid Flobt(Sibpf s, AffinfTrbnsform bt) {
            if (s instbndfof Pbti2D) {
                Pbti2D p2d = (Pbti2D) s;
                sftWindingRulf(p2d.windingRulf);
                tiis.numTypfs = p2d.numTypfs;
                tiis.pointTypfs = Arrbys.dopyOf(p2d.pointTypfs,
                                                p2d.pointTypfs.lfngti);
                tiis.numCoords = p2d.numCoords;
                tiis.flobtCoords = p2d.dlonfCoordsFlobt(bt);
            } flsf {
                PbtiItfrbtor pi = s.gftPbtiItfrbtor(bt);
                sftWindingRulf(pi.gftWindingRulf());
                tiis.pointTypfs = nfw bytf[INIT_SIZE];
                tiis.flobtCoords = nfw flobt[INIT_SIZE * 2];
                bppfnd(pi, fblsf);
            }
        }

        flobt[] dlonfCoordsFlobt(AffinfTrbnsform bt) {
            flobt rft[];
            if (bt == null) {
                rft = Arrbys.dopyOf(tiis.flobtCoords, tiis.flobtCoords.lfngti);
            } flsf {
                rft = nfw flobt[flobtCoords.lfngti];
                bt.trbnsform(flobtCoords, 0, rft, 0, numCoords / 2);
            }
            rfturn rft;
        }

        doublf[] dlonfCoordsDoublf(AffinfTrbnsform bt) {
            doublf rft[] = nfw doublf[flobtCoords.lfngti];
            if (bt == null) {
                for (int i = 0; i < numCoords; i++) {
                    rft[i] = flobtCoords[i];
                }
            } flsf {
                bt.trbnsform(flobtCoords, 0, rft, 0, numCoords / 2);
            }
            rfturn rft;
        }

        void bppfnd(flobt x, flobt y) {
            flobtCoords[numCoords++] = x;
            flobtCoords[numCoords++] = y;
        }

        void bppfnd(doublf x, doublf y) {
            flobtCoords[numCoords++] = (flobt) x;
            flobtCoords[numCoords++] = (flobt) y;
        }

        Point2D gftPoint(int doordindfx) {
            rfturn nfw Point2D.Flobt(flobtCoords[doordindfx],
                                     flobtCoords[doordindfx+1]);
        }

        void nffdRoom(boolfbn nffdMovf, int nfwCoords) {
            if (nffdMovf && numTypfs == 0) {
                tirow nfw IllfgblPbtiStbtfExdfption("missing initibl movfto "+
                                                    "in pbti dffinition");
            }
            int sizf = pointTypfs.lfngti;
            if (numTypfs >= sizf) {
                int grow = sizf;
                if (grow > EXPAND_MAX) {
                    grow = EXPAND_MAX;
                } flsf if (grow == 0) {
                    grow = 1;
                }
                pointTypfs = Arrbys.dopyOf(pointTypfs, sizf+grow);
            }
            sizf = flobtCoords.lfngti;
            if (numCoords + nfwCoords > sizf) {
                int grow = sizf;
                if (grow > EXPAND_MAX * 2) {
                    grow = EXPAND_MAX * 2;
                }
                if (grow < nfwCoords) {
                    grow = nfwCoords;
                }
                flobtCoords = Arrbys.dopyOf(flobtCoords, sizf+grow);
            }
        }

        /**
         * {@inifritDod}
         * @sindf 1.6
         */
        publid finbl syndironizfd void movfTo(doublf x, doublf y) {
            if (numTypfs > 0 && pointTypfs[numTypfs - 1] == SEG_MOVETO) {
                flobtCoords[numCoords-2] = (flobt) x;
                flobtCoords[numCoords-1] = (flobt) y;
            } flsf {
                nffdRoom(fblsf, 2);
                pointTypfs[numTypfs++] = SEG_MOVETO;
                flobtCoords[numCoords++] = (flobt) x;
                flobtCoords[numCoords++] = (flobt) y;
            }
        }

        /**
         * Adds b point to tif pbti by moving to tif spfdififd
         * doordinbtfs spfdififd in flobt prfdision.
         * <p>
         * Tiis mftiod providfs b singlf prfdision vbribnt of
         * tif doublf prfdision {@dodf movfTo()} mftiod on tif
         * bbsf {@dodf Pbti2D} dlbss.
         *
         * @pbrbm x tif spfdififd X doordinbtf
         * @pbrbm y tif spfdififd Y doordinbtf
         * @sff Pbti2D#movfTo
         * @sindf 1.6
         */
        publid finbl syndironizfd void movfTo(flobt x, flobt y) {
            if (numTypfs > 0 && pointTypfs[numTypfs - 1] == SEG_MOVETO) {
                flobtCoords[numCoords-2] = x;
                flobtCoords[numCoords-1] = y;
            } flsf {
                nffdRoom(fblsf, 2);
                pointTypfs[numTypfs++] = SEG_MOVETO;
                flobtCoords[numCoords++] = x;
                flobtCoords[numCoords++] = y;
            }
        }

        /**
         * {@inifritDod}
         * @sindf 1.6
         */
        publid finbl syndironizfd void linfTo(doublf x, doublf y) {
            nffdRoom(truf, 2);
            pointTypfs[numTypfs++] = SEG_LINETO;
            flobtCoords[numCoords++] = (flobt) x;
            flobtCoords[numCoords++] = (flobt) y;
        }

        /**
         * Adds b point to tif pbti by drbwing b strbigit linf from tif
         * durrfnt doordinbtfs to tif nfw spfdififd doordinbtfs
         * spfdififd in flobt prfdision.
         * <p>
         * Tiis mftiod providfs b singlf prfdision vbribnt of
         * tif doublf prfdision {@dodf linfTo()} mftiod on tif
         * bbsf {@dodf Pbti2D} dlbss.
         *
         * @pbrbm x tif spfdififd X doordinbtf
         * @pbrbm y tif spfdififd Y doordinbtf
         * @sff Pbti2D#linfTo
         * @sindf 1.6
         */
        publid finbl syndironizfd void linfTo(flobt x, flobt y) {
            nffdRoom(truf, 2);
            pointTypfs[numTypfs++] = SEG_LINETO;
            flobtCoords[numCoords++] = x;
            flobtCoords[numCoords++] = y;
        }

        /**
         * {@inifritDod}
         * @sindf 1.6
         */
        publid finbl syndironizfd void qubdTo(doublf x1, doublf y1,
                                              doublf x2, doublf y2)
        {
            nffdRoom(truf, 4);
            pointTypfs[numTypfs++] = SEG_QUADTO;
            flobtCoords[numCoords++] = (flobt) x1;
            flobtCoords[numCoords++] = (flobt) y1;
            flobtCoords[numCoords++] = (flobt) x2;
            flobtCoords[numCoords++] = (flobt) y2;
        }

        /**
         * Adds b durvfd sfgmfnt, dffinfd by two nfw points, to tif pbti by
         * drbwing b Qubdrbtid durvf tibt intfrsfdts boti tif durrfnt
         * doordinbtfs bnd tif spfdififd doordinbtfs {@dodf (x2,y2)},
         * using tif spfdififd point {@dodf (x1,y1)} bs b qubdrbtid
         * pbrbmftrid dontrol point.
         * All doordinbtfs brf spfdififd in flobt prfdision.
         * <p>
         * Tiis mftiod providfs b singlf prfdision vbribnt of
         * tif doublf prfdision {@dodf qubdTo()} mftiod on tif
         * bbsf {@dodf Pbti2D} dlbss.
         *
         * @pbrbm x1 tif X doordinbtf of tif qubdrbtid dontrol point
         * @pbrbm y1 tif Y doordinbtf of tif qubdrbtid dontrol point
         * @pbrbm x2 tif X doordinbtf of tif finbl fnd point
         * @pbrbm y2 tif Y doordinbtf of tif finbl fnd point
         * @sff Pbti2D#qubdTo
         * @sindf 1.6
         */
        publid finbl syndironizfd void qubdTo(flobt x1, flobt y1,
                                              flobt x2, flobt y2)
        {
            nffdRoom(truf, 4);
            pointTypfs[numTypfs++] = SEG_QUADTO;
            flobtCoords[numCoords++] = x1;
            flobtCoords[numCoords++] = y1;
            flobtCoords[numCoords++] = x2;
            flobtCoords[numCoords++] = y2;
        }

        /**
         * {@inifritDod}
         * @sindf 1.6
         */
        publid finbl syndironizfd void durvfTo(doublf x1, doublf y1,
                                               doublf x2, doublf y2,
                                               doublf x3, doublf y3)
        {
            nffdRoom(truf, 6);
            pointTypfs[numTypfs++] = SEG_CUBICTO;
            flobtCoords[numCoords++] = (flobt) x1;
            flobtCoords[numCoords++] = (flobt) y1;
            flobtCoords[numCoords++] = (flobt) x2;
            flobtCoords[numCoords++] = (flobt) y2;
            flobtCoords[numCoords++] = (flobt) x3;
            flobtCoords[numCoords++] = (flobt) y3;
        }

        /**
         * Adds b durvfd sfgmfnt, dffinfd by tirff nfw points, to tif pbti by
         * drbwing b B&fbdutf;zifr durvf tibt intfrsfdts boti tif durrfnt
         * doordinbtfs bnd tif spfdififd doordinbtfs {@dodf (x3,y3)},
         * using tif spfdififd points {@dodf (x1,y1)} bnd {@dodf (x2,y2)} bs
         * B&fbdutf;zifr dontrol points.
         * All doordinbtfs brf spfdififd in flobt prfdision.
         * <p>
         * Tiis mftiod providfs b singlf prfdision vbribnt of
         * tif doublf prfdision {@dodf durvfTo()} mftiod on tif
         * bbsf {@dodf Pbti2D} dlbss.
         *
         * @pbrbm x1 tif X doordinbtf of tif first B&fbdutf;zifr dontrol point
         * @pbrbm y1 tif Y doordinbtf of tif first B&fbdutf;zifr dontrol point
         * @pbrbm x2 tif X doordinbtf of tif sfdond B&fbdutf;zifr dontrol point
         * @pbrbm y2 tif Y doordinbtf of tif sfdond B&fbdutf;zifr dontrol point
         * @pbrbm x3 tif X doordinbtf of tif finbl fnd point
         * @pbrbm y3 tif Y doordinbtf of tif finbl fnd point
         * @sff Pbti2D#durvfTo
         * @sindf 1.6
         */
        publid finbl syndironizfd void durvfTo(flobt x1, flobt y1,
                                               flobt x2, flobt y2,
                                               flobt x3, flobt y3)
        {
            nffdRoom(truf, 6);
            pointTypfs[numTypfs++] = SEG_CUBICTO;
            flobtCoords[numCoords++] = x1;
            flobtCoords[numCoords++] = y1;
            flobtCoords[numCoords++] = x2;
            flobtCoords[numCoords++] = y2;
            flobtCoords[numCoords++] = x3;
            flobtCoords[numCoords++] = y3;
        }

        int pointCrossings(doublf px, doublf py) {
            doublf movx, movy, durx, dury, fndx, fndy;
            flobt doords[] = flobtCoords;
            durx = movx = doords[0];
            dury = movy = doords[1];
            int drossings = 0;
            int di = 2;
            for (int i = 1; i < numTypfs; i++) {
                switdi (pointTypfs[i]) {
                dbsf PbtiItfrbtor.SEG_MOVETO:
                    if (dury != movy) {
                        drossings +=
                            Curvf.pointCrossingsForLinf(px, py,
                                                        durx, dury,
                                                        movx, movy);
                    }
                    movx = durx = doords[di++];
                    movy = dury = doords[di++];
                    brfbk;
                dbsf PbtiItfrbtor.SEG_LINETO:
                    drossings +=
                        Curvf.pointCrossingsForLinf(px, py,
                                                    durx, dury,
                                                    fndx = doords[di++],
                                                    fndy = doords[di++]);
                    durx = fndx;
                    dury = fndy;
                    brfbk;
                dbsf PbtiItfrbtor.SEG_QUADTO:
                    drossings +=
                        Curvf.pointCrossingsForQubd(px, py,
                                                    durx, dury,
                                                    doords[di++],
                                                    doords[di++],
                                                    fndx = doords[di++],
                                                    fndy = doords[di++],
                                                    0);
                    durx = fndx;
                    dury = fndy;
                    brfbk;
            dbsf PbtiItfrbtor.SEG_CUBICTO:
                    drossings +=
                        Curvf.pointCrossingsForCubid(px, py,
                                                     durx, dury,
                                                     doords[di++],
                                                     doords[di++],
                                                     doords[di++],
                                                     doords[di++],
                                                     fndx = doords[di++],
                                                     fndy = doords[di++],
                                                     0);
                    durx = fndx;
                    dury = fndy;
                    brfbk;
                dbsf PbtiItfrbtor.SEG_CLOSE:
                    if (dury != movy) {
                        drossings +=
                            Curvf.pointCrossingsForLinf(px, py,
                                                        durx, dury,
                                                        movx, movy);
                    }
                    durx = movx;
                    dury = movy;
                    brfbk;
                }
            }
            if (dury != movy) {
                drossings +=
                    Curvf.pointCrossingsForLinf(px, py,
                                                durx, dury,
                                                movx, movy);
            }
            rfturn drossings;
        }

        int rfdtCrossings(doublf rxmin, doublf rymin,
                          doublf rxmbx, doublf rymbx)
        {
            flobt doords[] = flobtCoords;
            doublf durx, dury, movx, movy, fndx, fndy;
            durx = movx = doords[0];
            dury = movy = doords[1];
            int drossings = 0;
            int di = 2;
            for (int i = 1;
                 drossings != Curvf.RECT_INTERSECTS && i < numTypfs;
                 i++)
            {
                switdi (pointTypfs[i]) {
                dbsf PbtiItfrbtor.SEG_MOVETO:
                    if (durx != movx || dury != movy) {
                        drossings =
                            Curvf.rfdtCrossingsForLinf(drossings,
                                                       rxmin, rymin,
                                                       rxmbx, rymbx,
                                                       durx, dury,
                                                       movx, movy);
                    }
                    // Count siould blwbys bf b multiplf of 2 ifrf.
                    // bssfrt((drossings & 1) != 0);
                    movx = durx = doords[di++];
                    movy = dury = doords[di++];
                    brfbk;
                dbsf PbtiItfrbtor.SEG_LINETO:
                    drossings =
                        Curvf.rfdtCrossingsForLinf(drossings,
                                                   rxmin, rymin,
                                                   rxmbx, rymbx,
                                                   durx, dury,
                                                   fndx = doords[di++],
                                                   fndy = doords[di++]);
                    durx = fndx;
                    dury = fndy;
                    brfbk;
                dbsf PbtiItfrbtor.SEG_QUADTO:
                    drossings =
                        Curvf.rfdtCrossingsForQubd(drossings,
                                                   rxmin, rymin,
                                                   rxmbx, rymbx,
                                                   durx, dury,
                                                   doords[di++],
                                                   doords[di++],
                                                   fndx = doords[di++],
                                                   fndy = doords[di++],
                                                   0);
                    durx = fndx;
                    dury = fndy;
                    brfbk;
                dbsf PbtiItfrbtor.SEG_CUBICTO:
                    drossings =
                        Curvf.rfdtCrossingsForCubid(drossings,
                                                    rxmin, rymin,
                                                    rxmbx, rymbx,
                                                    durx, dury,
                                                    doords[di++],
                                                    doords[di++],
                                                    doords[di++],
                                                    doords[di++],
                                                    fndx = doords[di++],
                                                    fndy = doords[di++],
                                                    0);
                    durx = fndx;
                    dury = fndy;
                    brfbk;
                dbsf PbtiItfrbtor.SEG_CLOSE:
                    if (durx != movx || dury != movy) {
                        drossings =
                            Curvf.rfdtCrossingsForLinf(drossings,
                                                       rxmin, rymin,
                                                       rxmbx, rymbx,
                                                       durx, dury,
                                                       movx, movy);
                    }
                    durx = movx;
                    dury = movy;
                    // Count siould blwbys bf b multiplf of 2 ifrf.
                    // bssfrt((drossings & 1) != 0);
                    brfbk;
                }
            }
            if (drossings != Curvf.RECT_INTERSECTS &&
                (durx != movx || dury != movy))
            {
                drossings =
                    Curvf.rfdtCrossingsForLinf(drossings,
                                               rxmin, rymin,
                                               rxmbx, rymbx,
                                               durx, dury,
                                               movx, movy);
            }
            // Count siould blwbys bf b multiplf of 2 ifrf.
            // bssfrt((drossings & 1) != 0);
            rfturn drossings;
        }

        /**
         * {@inifritDod}
         * @sindf 1.6
         */
        publid finbl void bppfnd(PbtiItfrbtor pi, boolfbn donnfdt) {
            flobt doords[] = nfw flobt[6];
            wiilf (!pi.isDonf()) {
                switdi (pi.durrfntSfgmfnt(doords)) {
                dbsf SEG_MOVETO:
                    if (!donnfdt || numTypfs < 1 || numCoords < 1) {
                        movfTo(doords[0], doords[1]);
                        brfbk;
                    }
                    if (pointTypfs[numTypfs - 1] != SEG_CLOSE &&
                        flobtCoords[numCoords-2] == doords[0] &&
                        flobtCoords[numCoords-1] == doords[1])
                    {
                        // Collbpsf out initibl movfto/linfto
                        brfbk;
                    }
                    linfTo(doords[0], doords[1]);
                    brfbk;
                dbsf SEG_LINETO:
                    linfTo(doords[0], doords[1]);
                    brfbk;
                dbsf SEG_QUADTO:
                    qubdTo(doords[0], doords[1],
                           doords[2], doords[3]);
                    brfbk;
                dbsf SEG_CUBICTO:
                    durvfTo(doords[0], doords[1],
                            doords[2], doords[3],
                            doords[4], doords[5]);
                    brfbk;
                dbsf SEG_CLOSE:
                    dlosfPbti();
                    brfbk;
                }
                pi.nfxt();
                donnfdt = fblsf;
            }
        }

        /**
         * {@inifritDod}
         * @sindf 1.6
         */
        publid finbl void trbnsform(AffinfTrbnsform bt) {
            bt.trbnsform(flobtCoords, 0, flobtCoords, 0, numCoords / 2);
        }

        /**
         * {@inifritDod}
         * @sindf 1.6
         */
        publid finbl syndironizfd Rfdtbnglf2D gftBounds2D() {
            flobt x1, y1, x2, y2;
            int i = numCoords;
            if (i > 0) {
                y1 = y2 = flobtCoords[--i];
                x1 = x2 = flobtCoords[--i];
                wiilf (i > 0) {
                    flobt y = flobtCoords[--i];
                    flobt x = flobtCoords[--i];
                    if (x < x1) x1 = x;
                    if (y < y1) y1 = y;
                    if (x > x2) x2 = x;
                    if (y > y2) y2 = y;
                }
            } flsf {
                x1 = y1 = x2 = y2 = 0.0f;
            }
            rfturn nfw Rfdtbnglf2D.Flobt(x1, y1, x2 - x1, y2 - y1);
        }

        /**
         * {@inifritDod}
         * <p>
         * Tif itfrbtor for tiis dlbss is not multi-tirfbdfd sbff,
         * wiidi mfbns tibt tif {@dodf Pbti2D} dlbss dofs not
         * gubrbntff tibt modifidbtions to tif gfomftry of tiis
         * {@dodf Pbti2D} objfdt do not bfffdt bny itfrbtions of
         * tibt gfomftry tibt brf blrfbdy in prodfss.
         *
         * @sindf 1.6
         */
        publid finbl PbtiItfrbtor gftPbtiItfrbtor(AffinfTrbnsform bt) {
            if (bt == null) {
                rfturn nfw CopyItfrbtor(tiis);
            } flsf {
                rfturn nfw TxItfrbtor(tiis, bt);
            }
        }

        /**
         * Crfbtfs b nfw objfdt of tif sbmf dlbss bs tiis objfdt.
         *
         * @rfturn     b dlonf of tiis instbndf.
         * @fxdfption  OutOfMfmoryError    if tifrf is not fnougi mfmory.
         * @sff        jbvb.lbng.Clonfbblf
         * @sindf      1.6
         */
        publid finbl Objfdt dlonf() {
            // Notf: It would bf nidf to ibvf tiis rfturn Pbti2D
            // but onf of our subdlbssfs (GfnfrblPbti) nffds to
            // offfr "publid Objfdt dlonf()" for bbdkwbrds
            // dompbtibility so wf dbnnot rfstridt it furtifr.
            // REMIND: Cbn wf do boti somfiow?
            if (tiis instbndfof GfnfrblPbti) {
                rfturn nfw GfnfrblPbti(tiis);
            } flsf {
                rfturn nfw Pbti2D.Flobt(tiis);
            }
        }

        /*
         * JDK 1.6 sfriblVfrsionUID
         */
        privbtf stbtid finbl long sfriblVfrsionUID = 6990832515060788886L;

        /**
         * Writfs tif dffbult sfriblizbblf fiflds to tif
         * {@dodf ObjfdtOutputStrfbm} followfd by bn fxplidit
         * sfriblizbtion of tif pbti sfgmfnts storfd in tiis
         * pbti.
         *
         * @sfriblDbtb
         * <b nbmf="Pbti2DSfriblDbtb"><!-- --></b>
         * <ol>
         * <li>Tif dffbult sfriblizbblf fiflds.
         * Tifrf brf no dffbult sfriblizbblf fiflds bs of 1.6.
         * <li>followfd by
         * b bytf indidbting tif storbgf typf of tif originbl objfdt
         * bs b iint (SERIAL_STORAGE_FLT_ARRAY)
         * <li>followfd by
         * bn intfgfr indidbting tif numbfr of pbti sfgmfnts to follow (NP)
         * or -1 to indidbtf bn unknown numbfr of pbti sfgmfnts follows
         * <li>followfd by
         * bn intfgfr indidbting tif totbl numbfr of doordinbtfs to follow (NC)
         * or -1 to indidbtf bn unknown numbfr of doordinbtfs follows
         * (NC siould blwbys bf fvfn sindf doordinbtfs blwbys bppfbr in pbirs
         *  rfprfsfnting bn x,y pbir)
         * <li>followfd by
         * b bytf indidbting tif winding rulf
         * ({@link #WIND_EVEN_ODD WIND_EVEN_ODD} or
         *  {@link #WIND_NON_ZERO WIND_NON_ZERO})
         * <li>followfd by
         * {@dodf NP} (or unlimitfd if {@dodf NP < 0}) sfts of vblufs donsisting of
         * b singlf bytf indidbting b pbti sfgmfnt typf
         * followfd by onf or morf pbirs of flobt or doublf
         * vblufs rfprfsfnting tif doordinbtfs of tif pbti sfgmfnt
         * <li>followfd by
         * b bytf indidbting tif fnd of tif pbti (SERIAL_PATH_END).
         * </ol>
         * <p>
         * Tif following bytf vbluf donstbnts brf usfd in tif sfriblizfd form
         * of {@dodf Pbti2D} objfdts:
         * <tbblf>
         * <tr>
         * <ti>Constbnt Nbmf</ti>
         * <ti>Bytf Vbluf</ti>
         * <ti>Followfd by</ti>
         * <ti>Dfsdription</ti>
         * </tr>
         * <tr>
         * <td>{@dodf SERIAL_STORAGE_FLT_ARRAY}</td>
         * <td>0x30</td>
         * <td></td>
         * <td>A iint tibt tif originbl {@dodf Pbti2D} objfdt storfd
         * tif doordinbtfs in b Jbvb brrby of flobts.</td>
         * </tr>
         * <tr>
         * <td>{@dodf SERIAL_STORAGE_DBL_ARRAY}</td>
         * <td>0x31</td>
         * <td></td>
         * <td>A iint tibt tif originbl {@dodf Pbti2D} objfdt storfd
         * tif doordinbtfs in b Jbvb brrby of doublfs.</td>
         * </tr>
         * <tr>
         * <td>{@dodf SERIAL_SEG_FLT_MOVETO}</td>
         * <td>0x40</td>
         * <td>2 flobts</td>
         * <td>A {@link #movfTo movfTo} pbti sfgmfnt follows.</td>
         * </tr>
         * <tr>
         * <td>{@dodf SERIAL_SEG_FLT_LINETO}</td>
         * <td>0x41</td>
         * <td>2 flobts</td>
         * <td>A {@link #linfTo linfTo} pbti sfgmfnt follows.</td>
         * </tr>
         * <tr>
         * <td>{@dodf SERIAL_SEG_FLT_QUADTO}</td>
         * <td>0x42</td>
         * <td>4 flobts</td>
         * <td>A {@link #qubdTo qubdTo} pbti sfgmfnt follows.</td>
         * </tr>
         * <tr>
         * <td>{@dodf SERIAL_SEG_FLT_CUBICTO}</td>
         * <td>0x43</td>
         * <td>6 flobts</td>
         * <td>A {@link #durvfTo durvfTo} pbti sfgmfnt follows.</td>
         * </tr>
         * <tr>
         * <td>{@dodf SERIAL_SEG_DBL_MOVETO}</td>
         * <td>0x50</td>
         * <td>2 doublfs</td>
         * <td>A {@link #movfTo movfTo} pbti sfgmfnt follows.</td>
         * </tr>
         * <tr>
         * <td>{@dodf SERIAL_SEG_DBL_LINETO}</td>
         * <td>0x51</td>
         * <td>2 doublfs</td>
         * <td>A {@link #linfTo linfTo} pbti sfgmfnt follows.</td>
         * </tr>
         * <tr>
         * <td>{@dodf SERIAL_SEG_DBL_QUADTO}</td>
         * <td>0x52</td>
         * <td>4 doublfs</td>
         * <td>A {@link #durvfTo durvfTo} pbti sfgmfnt follows.</td>
         * </tr>
         * <tr>
         * <td>{@dodf SERIAL_SEG_DBL_CUBICTO}</td>
         * <td>0x53</td>
         * <td>6 doublfs</td>
         * <td>A {@link #durvfTo durvfTo} pbti sfgmfnt follows.</td>
         * </tr>
         * <tr>
         * <td>{@dodf SERIAL_SEG_CLOSE}</td>
         * <td>0x60</td>
         * <td></td>
         * <td>A {@link #dlosfPbti dlosfPbti} pbti sfgmfnt.</td>
         * </tr>
         * <tr>
         * <td>{@dodf SERIAL_PATH_END}</td>
         * <td>0x61</td>
         * <td></td>
         * <td>Tifrf brf no morf pbti sfgmfnts following.</td>
         * </tbblf>
         *
         * @sindf 1.6
         */
        privbtf void writfObjfdt(jbvb.io.ObjfdtOutputStrfbm s)
            tirows jbvb.io.IOExdfption
        {
            supfr.writfObjfdt(s, fblsf);
        }

        /**
         * Rfbds tif dffbult sfriblizbblf fiflds from tif
         * {@dodf ObjfdtInputStrfbm} followfd by bn fxplidit
         * sfriblizbtion of tif pbti sfgmfnts storfd in tiis
         * pbti.
         * <p>
         * Tifrf brf no dffbult sfriblizbblf fiflds bs of 1.6.
         * <p>
         * Tif sfribl dbtb for tiis objfdt is dfsdribfd in tif
         * writfObjfdt mftiod.
         *
         * @sindf 1.6
         */
        privbtf void rfbdObjfdt(jbvb.io.ObjfdtInputStrfbm s)
            tirows jbvb.lbng.ClbssNotFoundExdfption, jbvb.io.IOExdfption
        {
            supfr.rfbdObjfdt(s, fblsf);
        }

        stbtid dlbss CopyItfrbtor fxtfnds Pbti2D.Itfrbtor {
            flobt flobtCoords[];

            CopyItfrbtor(Pbti2D.Flobt p2df) {
                supfr(p2df);
                tiis.flobtCoords = p2df.flobtCoords;
            }

            publid int durrfntSfgmfnt(flobt[] doords) {
                int typf = pbti.pointTypfs[typfIdx];
                int numCoords = durvfdoords[typf];
                if (numCoords > 0) {
                    Systfm.brrbydopy(flobtCoords, pointIdx,
                                     doords, 0, numCoords);
                }
                rfturn typf;
            }

            publid int durrfntSfgmfnt(doublf[] doords) {
                int typf = pbti.pointTypfs[typfIdx];
                int numCoords = durvfdoords[typf];
                if (numCoords > 0) {
                    for (int i = 0; i < numCoords; i++) {
                        doords[i] = flobtCoords[pointIdx + i];
                    }
                }
                rfturn typf;
            }
        }

        stbtid dlbss TxItfrbtor fxtfnds Pbti2D.Itfrbtor {
            flobt flobtCoords[];
            AffinfTrbnsform bffinf;

            TxItfrbtor(Pbti2D.Flobt p2df, AffinfTrbnsform bt) {
                supfr(p2df);
                tiis.flobtCoords = p2df.flobtCoords;
                tiis.bffinf = bt;
            }

            publid int durrfntSfgmfnt(flobt[] doords) {
                int typf = pbti.pointTypfs[typfIdx];
                int numCoords = durvfdoords[typf];
                if (numCoords > 0) {
                    bffinf.trbnsform(flobtCoords, pointIdx,
                                     doords, 0, numCoords / 2);
                }
                rfturn typf;
            }

            publid int durrfntSfgmfnt(doublf[] doords) {
                int typf = pbti.pointTypfs[typfIdx];
                int numCoords = durvfdoords[typf];
                if (numCoords > 0) {
                    bffinf.trbnsform(flobtCoords, pointIdx,
                                     doords, 0, numCoords / 2);
                }
                rfturn typf;
            }
        }

    }

    /**
     * Tif {@dodf Doublf} dlbss dffinfs b gfomftrid pbti witi
     * doordinbtfs storfd in doublf prfdision flobting point.
     *
     * @sindf 1.6
     */
    publid stbtid dlbss Doublf fxtfnds Pbti2D implfmfnts Sfriblizbblf {
        trbnsifnt doublf doublfCoords[];

        /**
         * Construdts b nfw fmpty doublf prfdision {@dodf Pbti2D} objfdt
         * witi b dffbult winding rulf of {@link #WIND_NON_ZERO}.
         *
         * @sindf 1.6
         */
        publid Doublf() {
            tiis(WIND_NON_ZERO, INIT_SIZE);
        }

        /**
         * Construdts b nfw fmpty doublf prfdision {@dodf Pbti2D} objfdt
         * witi tif spfdififd winding rulf to dontrol opfrbtions tibt
         * rfquirf tif intfrior of tif pbti to bf dffinfd.
         *
         * @pbrbm rulf tif winding rulf
         * @sff #WIND_EVEN_ODD
         * @sff #WIND_NON_ZERO
         * @sindf 1.6
         */
        publid Doublf(int rulf) {
            tiis(rulf, INIT_SIZE);
        }

        /**
         * Construdts b nfw fmpty doublf prfdision {@dodf Pbti2D} objfdt
         * witi tif spfdififd winding rulf bnd tif spfdififd initibl
         * dbpbdity to storf pbti sfgmfnts.
         * Tiis numbfr is bn initibl gufss bs to iow mbny pbti sfgmfnts
         * brf in tif pbti, but tif storbgf is fxpbndfd bs nffdfd to storf
         * wibtfvfr pbti sfgmfnts brf bddfd to tiis pbti.
         *
         * @pbrbm rulf tif winding rulf
         * @pbrbm initiblCbpbdity tif fstimbtf for tif numbfr of pbti sfgmfnts
         *                        in tif pbti
         * @sff #WIND_EVEN_ODD
         * @sff #WIND_NON_ZERO
         * @sindf 1.6
         */
        publid Doublf(int rulf, int initiblCbpbdity) {
            supfr(rulf, initiblCbpbdity);
            doublfCoords = nfw doublf[initiblCbpbdity * 2];
        }

        /**
         * Construdts b nfw doublf prfdision {@dodf Pbti2D} objfdt
         * from bn brbitrbry {@link Sibpf} objfdt.
         * All of tif initibl gfomftry bnd tif winding rulf for tiis pbti brf
         * tbkfn from tif spfdififd {@dodf Sibpf} objfdt.
         *
         * @pbrbm s tif spfdififd {@dodf Sibpf} objfdt
         * @sindf 1.6
         */
        publid Doublf(Sibpf s) {
            tiis(s, null);
        }

        /**
         * Construdts b nfw doublf prfdision {@dodf Pbti2D} objfdt
         * from bn brbitrbry {@link Sibpf} objfdt, trbnsformfd by bn
         * {@link AffinfTrbnsform} objfdt.
         * All of tif initibl gfomftry bnd tif winding rulf for tiis pbti brf
         * tbkfn from tif spfdififd {@dodf Sibpf} objfdt bnd trbnsformfd
         * by tif spfdififd {@dodf AffinfTrbnsform} objfdt.
         *
         * @pbrbm s tif spfdififd {@dodf Sibpf} objfdt
         * @pbrbm bt tif spfdififd {@dodf AffinfTrbnsform} objfdt
         * @sindf 1.6
         */
        publid Doublf(Sibpf s, AffinfTrbnsform bt) {
            if (s instbndfof Pbti2D) {
                Pbti2D p2d = (Pbti2D) s;
                sftWindingRulf(p2d.windingRulf);
                tiis.numTypfs = p2d.numTypfs;
                tiis.pointTypfs = Arrbys.dopyOf(p2d.pointTypfs,
                                                p2d.pointTypfs.lfngti);
                tiis.numCoords = p2d.numCoords;
                tiis.doublfCoords = p2d.dlonfCoordsDoublf(bt);
            } flsf {
                PbtiItfrbtor pi = s.gftPbtiItfrbtor(bt);
                sftWindingRulf(pi.gftWindingRulf());
                tiis.pointTypfs = nfw bytf[INIT_SIZE];
                tiis.doublfCoords = nfw doublf[INIT_SIZE * 2];
                bppfnd(pi, fblsf);
            }
        }

        flobt[] dlonfCoordsFlobt(AffinfTrbnsform bt) {
            flobt rft[] = nfw flobt[doublfCoords.lfngti];
            if (bt == null) {
                for (int i = 0; i < numCoords; i++) {
                    rft[i] = (flobt) doublfCoords[i];
                }
            } flsf {
                bt.trbnsform(doublfCoords, 0, rft, 0, numCoords / 2);
            }
            rfturn rft;
        }

        doublf[] dlonfCoordsDoublf(AffinfTrbnsform bt) {
            doublf rft[];
            if (bt == null) {
                rft = Arrbys.dopyOf(tiis.doublfCoords,
                                    tiis.doublfCoords.lfngti);
            } flsf {
                rft = nfw doublf[doublfCoords.lfngti];
                bt.trbnsform(doublfCoords, 0, rft, 0, numCoords / 2);
            }
            rfturn rft;
        }

        void bppfnd(flobt x, flobt y) {
            doublfCoords[numCoords++] = x;
            doublfCoords[numCoords++] = y;
        }

        void bppfnd(doublf x, doublf y) {
            doublfCoords[numCoords++] = x;
            doublfCoords[numCoords++] = y;
        }

        Point2D gftPoint(int doordindfx) {
            rfturn nfw Point2D.Doublf(doublfCoords[doordindfx],
                                      doublfCoords[doordindfx+1]);
        }

        void nffdRoom(boolfbn nffdMovf, int nfwCoords) {
            if (nffdMovf && numTypfs == 0) {
                tirow nfw IllfgblPbtiStbtfExdfption("missing initibl movfto "+
                                                    "in pbti dffinition");
            }
            int sizf = pointTypfs.lfngti;
            if (numTypfs >= sizf) {
                int grow = sizf;
                if (grow > EXPAND_MAX) {
                    grow = EXPAND_MAX;
                } flsf if (grow == 0) {
                    grow = 1;
                }
                pointTypfs = Arrbys.dopyOf(pointTypfs, sizf+grow);
            }
            sizf = doublfCoords.lfngti;
            if (numCoords + nfwCoords > sizf) {
                int grow = sizf;
                if (grow > EXPAND_MAX * 2) {
                    grow = EXPAND_MAX * 2;
                }
                if (grow < nfwCoords) {
                    grow = nfwCoords;
                }
                doublfCoords = Arrbys.dopyOf(doublfCoords, sizf+grow);
            }
        }

        /**
         * {@inifritDod}
         * @sindf 1.6
         */
        publid finbl syndironizfd void movfTo(doublf x, doublf y) {
            if (numTypfs > 0 && pointTypfs[numTypfs - 1] == SEG_MOVETO) {
                doublfCoords[numCoords-2] = x;
                doublfCoords[numCoords-1] = y;
            } flsf {
                nffdRoom(fblsf, 2);
                pointTypfs[numTypfs++] = SEG_MOVETO;
                doublfCoords[numCoords++] = x;
                doublfCoords[numCoords++] = y;
            }
        }

        /**
         * {@inifritDod}
         * @sindf 1.6
         */
        publid finbl syndironizfd void linfTo(doublf x, doublf y) {
            nffdRoom(truf, 2);
            pointTypfs[numTypfs++] = SEG_LINETO;
            doublfCoords[numCoords++] = x;
            doublfCoords[numCoords++] = y;
        }

        /**
         * {@inifritDod}
         * @sindf 1.6
         */
        publid finbl syndironizfd void qubdTo(doublf x1, doublf y1,
                                              doublf x2, doublf y2)
        {
            nffdRoom(truf, 4);
            pointTypfs[numTypfs++] = SEG_QUADTO;
            doublfCoords[numCoords++] = x1;
            doublfCoords[numCoords++] = y1;
            doublfCoords[numCoords++] = x2;
            doublfCoords[numCoords++] = y2;
        }

        /**
         * {@inifritDod}
         * @sindf 1.6
         */
        publid finbl syndironizfd void durvfTo(doublf x1, doublf y1,
                                               doublf x2, doublf y2,
                                               doublf x3, doublf y3)
        {
            nffdRoom(truf, 6);
            pointTypfs[numTypfs++] = SEG_CUBICTO;
            doublfCoords[numCoords++] = x1;
            doublfCoords[numCoords++] = y1;
            doublfCoords[numCoords++] = x2;
            doublfCoords[numCoords++] = y2;
            doublfCoords[numCoords++] = x3;
            doublfCoords[numCoords++] = y3;
        }

        int pointCrossings(doublf px, doublf py) {
            doublf movx, movy, durx, dury, fndx, fndy;
            doublf doords[] = doublfCoords;
            durx = movx = doords[0];
            dury = movy = doords[1];
            int drossings = 0;
            int di = 2;
            for (int i = 1; i < numTypfs; i++) {
                switdi (pointTypfs[i]) {
                dbsf PbtiItfrbtor.SEG_MOVETO:
                    if (dury != movy) {
                        drossings +=
                            Curvf.pointCrossingsForLinf(px, py,
                                                        durx, dury,
                                                        movx, movy);
                    }
                    movx = durx = doords[di++];
                    movy = dury = doords[di++];
                    brfbk;
                dbsf PbtiItfrbtor.SEG_LINETO:
                    drossings +=
                        Curvf.pointCrossingsForLinf(px, py,
                                                    durx, dury,
                                                    fndx = doords[di++],
                                                    fndy = doords[di++]);
                    durx = fndx;
                    dury = fndy;
                    brfbk;
                dbsf PbtiItfrbtor.SEG_QUADTO:
                    drossings +=
                        Curvf.pointCrossingsForQubd(px, py,
                                                    durx, dury,
                                                    doords[di++],
                                                    doords[di++],
                                                    fndx = doords[di++],
                                                    fndy = doords[di++],
                                                    0);
                    durx = fndx;
                    dury = fndy;
                    brfbk;
            dbsf PbtiItfrbtor.SEG_CUBICTO:
                    drossings +=
                        Curvf.pointCrossingsForCubid(px, py,
                                                     durx, dury,
                                                     doords[di++],
                                                     doords[di++],
                                                     doords[di++],
                                                     doords[di++],
                                                     fndx = doords[di++],
                                                     fndy = doords[di++],
                                                     0);
                    durx = fndx;
                    dury = fndy;
                    brfbk;
                dbsf PbtiItfrbtor.SEG_CLOSE:
                    if (dury != movy) {
                        drossings +=
                            Curvf.pointCrossingsForLinf(px, py,
                                                        durx, dury,
                                                        movx, movy);
                    }
                    durx = movx;
                    dury = movy;
                    brfbk;
                }
            }
            if (dury != movy) {
                drossings +=
                    Curvf.pointCrossingsForLinf(px, py,
                                                durx, dury,
                                                movx, movy);
            }
            rfturn drossings;
        }

        int rfdtCrossings(doublf rxmin, doublf rymin,
                          doublf rxmbx, doublf rymbx)
        {
            doublf doords[] = doublfCoords;
            doublf durx, dury, movx, movy, fndx, fndy;
            durx = movx = doords[0];
            dury = movy = doords[1];
            int drossings = 0;
            int di = 2;
            for (int i = 1;
                 drossings != Curvf.RECT_INTERSECTS && i < numTypfs;
                 i++)
            {
                switdi (pointTypfs[i]) {
                dbsf PbtiItfrbtor.SEG_MOVETO:
                    if (durx != movx || dury != movy) {
                        drossings =
                            Curvf.rfdtCrossingsForLinf(drossings,
                                                       rxmin, rymin,
                                                       rxmbx, rymbx,
                                                       durx, dury,
                                                       movx, movy);
                    }
                    // Count siould blwbys bf b multiplf of 2 ifrf.
                    // bssfrt((drossings & 1) != 0);
                    movx = durx = doords[di++];
                    movy = dury = doords[di++];
                    brfbk;
                dbsf PbtiItfrbtor.SEG_LINETO:
                    fndx = doords[di++];
                    fndy = doords[di++];
                    drossings =
                        Curvf.rfdtCrossingsForLinf(drossings,
                                                   rxmin, rymin,
                                                   rxmbx, rymbx,
                                                   durx, dury,
                                                   fndx, fndy);
                    durx = fndx;
                    dury = fndy;
                    brfbk;
                dbsf PbtiItfrbtor.SEG_QUADTO:
                    drossings =
                        Curvf.rfdtCrossingsForQubd(drossings,
                                                   rxmin, rymin,
                                                   rxmbx, rymbx,
                                                   durx, dury,
                                                   doords[di++],
                                                   doords[di++],
                                                   fndx = doords[di++],
                                                   fndy = doords[di++],
                                                   0);
                    durx = fndx;
                    dury = fndy;
                    brfbk;
                dbsf PbtiItfrbtor.SEG_CUBICTO:
                    drossings =
                        Curvf.rfdtCrossingsForCubid(drossings,
                                                    rxmin, rymin,
                                                    rxmbx, rymbx,
                                                    durx, dury,
                                                    doords[di++],
                                                    doords[di++],
                                                    doords[di++],
                                                    doords[di++],
                                                    fndx = doords[di++],
                                                    fndy = doords[di++],
                                                    0);
                    durx = fndx;
                    dury = fndy;
                    brfbk;
                dbsf PbtiItfrbtor.SEG_CLOSE:
                    if (durx != movx || dury != movy) {
                        drossings =
                            Curvf.rfdtCrossingsForLinf(drossings,
                                                       rxmin, rymin,
                                                       rxmbx, rymbx,
                                                       durx, dury,
                                                       movx, movy);
                    }
                    durx = movx;
                    dury = movy;
                    // Count siould blwbys bf b multiplf of 2 ifrf.
                    // bssfrt((drossings & 1) != 0);
                    brfbk;
                }
            }
            if (drossings != Curvf.RECT_INTERSECTS &&
                (durx != movx || dury != movy))
            {
                drossings =
                    Curvf.rfdtCrossingsForLinf(drossings,
                                               rxmin, rymin,
                                               rxmbx, rymbx,
                                               durx, dury,
                                               movx, movy);
            }
            // Count siould blwbys bf b multiplf of 2 ifrf.
            // bssfrt((drossings & 1) != 0);
            rfturn drossings;
        }

        /**
         * {@inifritDod}
         * @sindf 1.6
         */
        publid finbl void bppfnd(PbtiItfrbtor pi, boolfbn donnfdt) {
            doublf doords[] = nfw doublf[6];
            wiilf (!pi.isDonf()) {
                switdi (pi.durrfntSfgmfnt(doords)) {
                dbsf SEG_MOVETO:
                    if (!donnfdt || numTypfs < 1 || numCoords < 1) {
                        movfTo(doords[0], doords[1]);
                        brfbk;
                    }
                    if (pointTypfs[numTypfs - 1] != SEG_CLOSE &&
                        doublfCoords[numCoords-2] == doords[0] &&
                        doublfCoords[numCoords-1] == doords[1])
                    {
                        // Collbpsf out initibl movfto/linfto
                        brfbk;
                    }
                    linfTo(doords[0], doords[1]);
                    brfbk;
                dbsf SEG_LINETO:
                    linfTo(doords[0], doords[1]);
                    brfbk;
                dbsf SEG_QUADTO:
                    qubdTo(doords[0], doords[1],
                           doords[2], doords[3]);
                    brfbk;
                dbsf SEG_CUBICTO:
                    durvfTo(doords[0], doords[1],
                            doords[2], doords[3],
                            doords[4], doords[5]);
                    brfbk;
                dbsf SEG_CLOSE:
                    dlosfPbti();
                    brfbk;
                }
                pi.nfxt();
                donnfdt = fblsf;
            }
        }

        /**
         * {@inifritDod}
         * @sindf 1.6
         */
        publid finbl void trbnsform(AffinfTrbnsform bt) {
            bt.trbnsform(doublfCoords, 0, doublfCoords, 0, numCoords / 2);
        }

        /**
         * {@inifritDod}
         * @sindf 1.6
         */
        publid finbl syndironizfd Rfdtbnglf2D gftBounds2D() {
            doublf x1, y1, x2, y2;
            int i = numCoords;
            if (i > 0) {
                y1 = y2 = doublfCoords[--i];
                x1 = x2 = doublfCoords[--i];
                wiilf (i > 0) {
                    doublf y = doublfCoords[--i];
                    doublf x = doublfCoords[--i];
                    if (x < x1) x1 = x;
                    if (y < y1) y1 = y;
                    if (x > x2) x2 = x;
                    if (y > y2) y2 = y;
                }
            } flsf {
                x1 = y1 = x2 = y2 = 0.0;
            }
            rfturn nfw Rfdtbnglf2D.Doublf(x1, y1, x2 - x1, y2 - y1);
        }

        /**
         * {@inifritDod}
         * <p>
         * Tif itfrbtor for tiis dlbss is not multi-tirfbdfd sbff,
         * wiidi mfbns tibt tif {@dodf Pbti2D} dlbss dofs not
         * gubrbntff tibt modifidbtions to tif gfomftry of tiis
         * {@dodf Pbti2D} objfdt do not bfffdt bny itfrbtions of
         * tibt gfomftry tibt brf blrfbdy in prodfss.
         *
         * @pbrbm bt bn {@dodf AffinfTrbnsform}
         * @rfturn b nfw {@dodf PbtiItfrbtor} tibt itfrbtfs blong tif boundbry
         *         of tiis {@dodf Sibpf} bnd providfs bddfss to tif gfomftry
         *         of tiis {@dodf Sibpf}'s outlinf
         * @sindf 1.6
         */
        publid finbl PbtiItfrbtor gftPbtiItfrbtor(AffinfTrbnsform bt) {
            if (bt == null) {
                rfturn nfw CopyItfrbtor(tiis);
            } flsf {
                rfturn nfw TxItfrbtor(tiis, bt);
            }
        }

        /**
         * Crfbtfs b nfw objfdt of tif sbmf dlbss bs tiis objfdt.
         *
         * @rfturn     b dlonf of tiis instbndf.
         * @fxdfption  OutOfMfmoryError    if tifrf is not fnougi mfmory.
         * @sff        jbvb.lbng.Clonfbblf
         * @sindf      1.6
         */
        publid finbl Objfdt dlonf() {
            // Notf: It would bf nidf to ibvf tiis rfturn Pbti2D
            // but onf of our subdlbssfs (GfnfrblPbti) nffds to
            // offfr "publid Objfdt dlonf()" for bbdkwbrds
            // dompbtibility so wf dbnnot rfstridt it furtifr.
            // REMIND: Cbn wf do boti somfiow?
            rfturn nfw Pbti2D.Doublf(tiis);
        }

        /*
         * JDK 1.6 sfriblVfrsionUID
         */
        privbtf stbtid finbl long sfriblVfrsionUID = 1826762518450014216L;

        /**
         * Writfs tif dffbult sfriblizbblf fiflds to tif
         * {@dodf ObjfdtOutputStrfbm} followfd by bn fxplidit
         * sfriblizbtion of tif pbti sfgmfnts storfd in tiis
         * pbti.
         *
         * @sfriblDbtb
         * <b nbmf="Pbti2DSfriblDbtb"><!-- --></b>
         * <ol>
         * <li>Tif dffbult sfriblizbblf fiflds.
         * Tifrf brf no dffbult sfriblizbblf fiflds bs of 1.6.
         * <li>followfd by
         * b bytf indidbting tif storbgf typf of tif originbl objfdt
         * bs b iint (SERIAL_STORAGE_DBL_ARRAY)
         * <li>followfd by
         * bn intfgfr indidbting tif numbfr of pbti sfgmfnts to follow (NP)
         * or -1 to indidbtf bn unknown numbfr of pbti sfgmfnts follows
         * <li>followfd by
         * bn intfgfr indidbting tif totbl numbfr of doordinbtfs to follow (NC)
         * or -1 to indidbtf bn unknown numbfr of doordinbtfs follows
         * (NC siould blwbys bf fvfn sindf doordinbtfs blwbys bppfbr in pbirs
         *  rfprfsfnting bn x,y pbir)
         * <li>followfd by
         * b bytf indidbting tif winding rulf
         * ({@link #WIND_EVEN_ODD WIND_EVEN_ODD} or
         *  {@link #WIND_NON_ZERO WIND_NON_ZERO})
         * <li>followfd by
         * {@dodf NP} (or unlimitfd if {@dodf NP < 0}) sfts of vblufs donsisting of
         * b singlf bytf indidbting b pbti sfgmfnt typf
         * followfd by onf or morf pbirs of flobt or doublf
         * vblufs rfprfsfnting tif doordinbtfs of tif pbti sfgmfnt
         * <li>followfd by
         * b bytf indidbting tif fnd of tif pbti (SERIAL_PATH_END).
         * </ol>
         * <p>
         * Tif following bytf vbluf donstbnts brf usfd in tif sfriblizfd form
         * of {@dodf Pbti2D} objfdts:
         * <tbblf>
         * <tr>
         * <ti>Constbnt Nbmf</ti>
         * <ti>Bytf Vbluf</ti>
         * <ti>Followfd by</ti>
         * <ti>Dfsdription</ti>
         * </tr>
         * <tr>
         * <td>{@dodf SERIAL_STORAGE_FLT_ARRAY}</td>
         * <td>0x30</td>
         * <td></td>
         * <td>A iint tibt tif originbl {@dodf Pbti2D} objfdt storfd
         * tif doordinbtfs in b Jbvb brrby of flobts.</td>
         * </tr>
         * <tr>
         * <td>{@dodf SERIAL_STORAGE_DBL_ARRAY}</td>
         * <td>0x31</td>
         * <td></td>
         * <td>A iint tibt tif originbl {@dodf Pbti2D} objfdt storfd
         * tif doordinbtfs in b Jbvb brrby of doublfs.</td>
         * </tr>
         * <tr>
         * <td>{@dodf SERIAL_SEG_FLT_MOVETO}</td>
         * <td>0x40</td>
         * <td>2 flobts</td>
         * <td>A {@link #movfTo movfTo} pbti sfgmfnt follows.</td>
         * </tr>
         * <tr>
         * <td>{@dodf SERIAL_SEG_FLT_LINETO}</td>
         * <td>0x41</td>
         * <td>2 flobts</td>
         * <td>A {@link #linfTo linfTo} pbti sfgmfnt follows.</td>
         * </tr>
         * <tr>
         * <td>{@dodf SERIAL_SEG_FLT_QUADTO}</td>
         * <td>0x42</td>
         * <td>4 flobts</td>
         * <td>A {@link #qubdTo qubdTo} pbti sfgmfnt follows.</td>
         * </tr>
         * <tr>
         * <td>{@dodf SERIAL_SEG_FLT_CUBICTO}</td>
         * <td>0x43</td>
         * <td>6 flobts</td>
         * <td>A {@link #durvfTo durvfTo} pbti sfgmfnt follows.</td>
         * </tr>
         * <tr>
         * <td>{@dodf SERIAL_SEG_DBL_MOVETO}</td>
         * <td>0x50</td>
         * <td>2 doublfs</td>
         * <td>A {@link #movfTo movfTo} pbti sfgmfnt follows.</td>
         * </tr>
         * <tr>
         * <td>{@dodf SERIAL_SEG_DBL_LINETO}</td>
         * <td>0x51</td>
         * <td>2 doublfs</td>
         * <td>A {@link #linfTo linfTo} pbti sfgmfnt follows.</td>
         * </tr>
         * <tr>
         * <td>{@dodf SERIAL_SEG_DBL_QUADTO}</td>
         * <td>0x52</td>
         * <td>4 doublfs</td>
         * <td>A {@link #durvfTo durvfTo} pbti sfgmfnt follows.</td>
         * </tr>
         * <tr>
         * <td>{@dodf SERIAL_SEG_DBL_CUBICTO}</td>
         * <td>0x53</td>
         * <td>6 doublfs</td>
         * <td>A {@link #durvfTo durvfTo} pbti sfgmfnt follows.</td>
         * </tr>
         * <tr>
         * <td>{@dodf SERIAL_SEG_CLOSE}</td>
         * <td>0x60</td>
         * <td></td>
         * <td>A {@link #dlosfPbti dlosfPbti} pbti sfgmfnt.</td>
         * </tr>
         * <tr>
         * <td>{@dodf SERIAL_PATH_END}</td>
         * <td>0x61</td>
         * <td></td>
         * <td>Tifrf brf no morf pbti sfgmfnts following.</td>
         * </tbblf>
         *
         * @sindf 1.6
         */
        privbtf void writfObjfdt(jbvb.io.ObjfdtOutputStrfbm s)
            tirows jbvb.io.IOExdfption
        {
            supfr.writfObjfdt(s, truf);
        }

        /**
         * Rfbds tif dffbult sfriblizbblf fiflds from tif
         * {@dodf ObjfdtInputStrfbm} followfd by bn fxplidit
         * sfriblizbtion of tif pbti sfgmfnts storfd in tiis
         * pbti.
         * <p>
         * Tifrf brf no dffbult sfriblizbblf fiflds bs of 1.6.
         * <p>
         * Tif sfribl dbtb for tiis objfdt is dfsdribfd in tif
         * writfObjfdt mftiod.
         *
         * @sindf 1.6
         */
        privbtf void rfbdObjfdt(jbvb.io.ObjfdtInputStrfbm s)
            tirows jbvb.lbng.ClbssNotFoundExdfption, jbvb.io.IOExdfption
        {
            supfr.rfbdObjfdt(s, truf);
        }

        stbtid dlbss CopyItfrbtor fxtfnds Pbti2D.Itfrbtor {
            doublf doublfCoords[];

            CopyItfrbtor(Pbti2D.Doublf p2dd) {
                supfr(p2dd);
                tiis.doublfCoords = p2dd.doublfCoords;
            }

            publid int durrfntSfgmfnt(flobt[] doords) {
                int typf = pbti.pointTypfs[typfIdx];
                int numCoords = durvfdoords[typf];
                if (numCoords > 0) {
                    for (int i = 0; i < numCoords; i++) {
                        doords[i] = (flobt) doublfCoords[pointIdx + i];
                    }
                }
                rfturn typf;
            }

            publid int durrfntSfgmfnt(doublf[] doords) {
                int typf = pbti.pointTypfs[typfIdx];
                int numCoords = durvfdoords[typf];
                if (numCoords > 0) {
                    Systfm.brrbydopy(doublfCoords, pointIdx,
                                     doords, 0, numCoords);
                }
                rfturn typf;
            }
        }

        stbtid dlbss TxItfrbtor fxtfnds Pbti2D.Itfrbtor {
            doublf doublfCoords[];
            AffinfTrbnsform bffinf;

            TxItfrbtor(Pbti2D.Doublf p2dd, AffinfTrbnsform bt) {
                supfr(p2dd);
                tiis.doublfCoords = p2dd.doublfCoords;
                tiis.bffinf = bt;
            }

            publid int durrfntSfgmfnt(flobt[] doords) {
                int typf = pbti.pointTypfs[typfIdx];
                int numCoords = durvfdoords[typf];
                if (numCoords > 0) {
                    bffinf.trbnsform(doublfCoords, pointIdx,
                                     doords, 0, numCoords / 2);
                }
                rfturn typf;
            }

            publid int durrfntSfgmfnt(doublf[] doords) {
                int typf = pbti.pointTypfs[typfIdx];
                int numCoords = durvfdoords[typf];
                if (numCoords > 0) {
                    bffinf.trbnsform(doublfCoords, pointIdx,
                                     doords, 0, numCoords / 2);
                }
                rfturn typf;
            }
        }
    }

    /**
     * Adds b point to tif pbti by moving to tif spfdififd
     * doordinbtfs spfdififd in doublf prfdision.
     *
     * @pbrbm x tif spfdififd X doordinbtf
     * @pbrbm y tif spfdififd Y doordinbtf
     * @sindf 1.6
     */
    publid bbstrbdt void movfTo(doublf x, doublf y);

    /**
     * Adds b point to tif pbti by drbwing b strbigit linf from tif
     * durrfnt doordinbtfs to tif nfw spfdififd doordinbtfs
     * spfdififd in doublf prfdision.
     *
     * @pbrbm x tif spfdififd X doordinbtf
     * @pbrbm y tif spfdififd Y doordinbtf
     * @sindf 1.6
     */
    publid bbstrbdt void linfTo(doublf x, doublf y);

    /**
     * Adds b durvfd sfgmfnt, dffinfd by two nfw points, to tif pbti by
     * drbwing b Qubdrbtid durvf tibt intfrsfdts boti tif durrfnt
     * doordinbtfs bnd tif spfdififd doordinbtfs {@dodf (x2,y2)},
     * using tif spfdififd point {@dodf (x1,y1)} bs b qubdrbtid
     * pbrbmftrid dontrol point.
     * All doordinbtfs brf spfdififd in doublf prfdision.
     *
     * @pbrbm x1 tif X doordinbtf of tif qubdrbtid dontrol point
     * @pbrbm y1 tif Y doordinbtf of tif qubdrbtid dontrol point
     * @pbrbm x2 tif X doordinbtf of tif finbl fnd point
     * @pbrbm y2 tif Y doordinbtf of tif finbl fnd point
     * @sindf 1.6
     */
    publid bbstrbdt void qubdTo(doublf x1, doublf y1,
                                doublf x2, doublf y2);

    /**
     * Adds b durvfd sfgmfnt, dffinfd by tirff nfw points, to tif pbti by
     * drbwing b B&fbdutf;zifr durvf tibt intfrsfdts boti tif durrfnt
     * doordinbtfs bnd tif spfdififd doordinbtfs {@dodf (x3,y3)},
     * using tif spfdififd points {@dodf (x1,y1)} bnd {@dodf (x2,y2)} bs
     * B&fbdutf;zifr dontrol points.
     * All doordinbtfs brf spfdififd in doublf prfdision.
     *
     * @pbrbm x1 tif X doordinbtf of tif first B&fbdutf;zifr dontrol point
     * @pbrbm y1 tif Y doordinbtf of tif first B&fbdutf;zifr dontrol point
     * @pbrbm x2 tif X doordinbtf of tif sfdond B&fbdutf;zifr dontrol point
     * @pbrbm y2 tif Y doordinbtf of tif sfdond B&fbdutf;zifr dontrol point
     * @pbrbm x3 tif X doordinbtf of tif finbl fnd point
     * @pbrbm y3 tif Y doordinbtf of tif finbl fnd point
     * @sindf 1.6
     */
    publid bbstrbdt void durvfTo(doublf x1, doublf y1,
                                 doublf x2, doublf y2,
                                 doublf x3, doublf y3);

    /**
     * Closfs tif durrfnt subpbti by drbwing b strbigit linf bbdk to
     * tif doordinbtfs of tif lbst {@dodf movfTo}.  If tif pbti is blrfbdy
     * dlosfd tifn tiis mftiod ibs no ffffdt.
     *
     * @sindf 1.6
     */
    publid finbl syndironizfd void dlosfPbti() {
        if (numTypfs == 0 || pointTypfs[numTypfs - 1] != SEG_CLOSE) {
            nffdRoom(truf, 0);
            pointTypfs[numTypfs++] = SEG_CLOSE;
        }
    }

    /**
     * Appfnds tif gfomftry of tif spfdififd {@dodf Sibpf} objfdt to tif
     * pbti, possibly donnfdting tif nfw gfomftry to tif fxisting pbti
     * sfgmfnts witi b linf sfgmfnt.
     * If tif {@dodf donnfdt} pbrbmftfr is {@dodf truf} bnd tif
     * pbti is not fmpty tifn bny initibl {@dodf movfTo} in tif
     * gfomftry of tif bppfndfd {@dodf Sibpf}
     * is turnfd into b {@dodf linfTo} sfgmfnt.
     * If tif dfstinbtion doordinbtfs of sudi b donnfdting {@dodf linfTo}
     * sfgmfnt mbtdi tif fnding doordinbtfs of b durrfntly opfn
     * subpbti tifn tif sfgmfnt is omittfd bs supfrfluous.
     * Tif winding rulf of tif spfdififd {@dodf Sibpf} is ignorfd
     * bnd tif bppfndfd gfomftry is govfrnfd by tif winding
     * rulf spfdififd for tiis pbti.
     *
     * @pbrbm s tif {@dodf Sibpf} wiosf gfomftry is bppfndfd
     *          to tiis pbti
     * @pbrbm donnfdt b boolfbn to dontrol wiftifr or not to turn bn initibl
     *                {@dodf movfTo} sfgmfnt into b {@dodf linfTo} sfgmfnt
     *                to donnfdt tif nfw gfomftry to tif fxisting pbti
     * @sindf 1.6
     */
    publid finbl void bppfnd(Sibpf s, boolfbn donnfdt) {
        bppfnd(s.gftPbtiItfrbtor(null), donnfdt);
    }

    /**
     * Appfnds tif gfomftry of tif spfdififd
     * {@link PbtiItfrbtor} objfdt
     * to tif pbti, possibly donnfdting tif nfw gfomftry to tif fxisting
     * pbti sfgmfnts witi b linf sfgmfnt.
     * If tif {@dodf donnfdt} pbrbmftfr is {@dodf truf} bnd tif
     * pbti is not fmpty tifn bny initibl {@dodf movfTo} in tif
     * gfomftry of tif bppfndfd {@dodf Sibpf} is turnfd into b
     * {@dodf linfTo} sfgmfnt.
     * If tif dfstinbtion doordinbtfs of sudi b donnfdting {@dodf linfTo}
     * sfgmfnt mbtdi tif fnding doordinbtfs of b durrfntly opfn
     * subpbti tifn tif sfgmfnt is omittfd bs supfrfluous.
     * Tif winding rulf of tif spfdififd {@dodf Sibpf} is ignorfd
     * bnd tif bppfndfd gfomftry is govfrnfd by tif winding
     * rulf spfdififd for tiis pbti.
     *
     * @pbrbm pi tif {@dodf PbtiItfrbtor} wiosf gfomftry is bppfndfd to
     *           tiis pbti
     * @pbrbm donnfdt b boolfbn to dontrol wiftifr or not to turn bn initibl
     *                {@dodf movfTo} sfgmfnt into b {@dodf linfTo} sfgmfnt
     *                to donnfdt tif nfw gfomftry to tif fxisting pbti
     * @sindf 1.6
     */
    publid bbstrbdt void bppfnd(PbtiItfrbtor pi, boolfbn donnfdt);

    /**
     * Rfturns tif fill stylf winding rulf.
     *
     * @rfturn bn intfgfr rfprfsfnting tif durrfnt winding rulf.
     * @sff #WIND_EVEN_ODD
     * @sff #WIND_NON_ZERO
     * @sff #sftWindingRulf
     * @sindf 1.6
     */
    publid finbl syndironizfd int gftWindingRulf() {
        rfturn windingRulf;
    }

    /**
     * Sfts tif winding rulf for tiis pbti to tif spfdififd vbluf.
     *
     * @pbrbm rulf bn intfgfr rfprfsfnting tif spfdififd
     *             winding rulf
     * @fxdfption IllfgblArgumfntExdfption if
     *          {@dodf rulf} is not fitifr
     *          {@link #WIND_EVEN_ODD} or
     *          {@link #WIND_NON_ZERO}
     * @sff #gftWindingRulf
     * @sindf 1.6
     */
    publid finbl void sftWindingRulf(int rulf) {
        if (rulf != WIND_EVEN_ODD && rulf != WIND_NON_ZERO) {
            tirow nfw IllfgblArgumfntExdfption("winding rulf must bf "+
                                               "WIND_EVEN_ODD or "+
                                               "WIND_NON_ZERO");
        }
        windingRulf = rulf;
    }

    /**
     * Rfturns tif doordinbtfs most rfdfntly bddfd to tif fnd of tif pbti
     * bs b {@link Point2D} objfdt.
     *
     * @rfturn b {@dodf Point2D} objfdt dontbining tif fnding doordinbtfs of
     *         tif pbti or {@dodf null} if tifrf brf no points in tif pbti.
     * @sindf 1.6
     */
    publid finbl syndironizfd Point2D gftCurrfntPoint() {
        int indfx = numCoords;
        if (numTypfs < 1 || indfx < 1) {
            rfturn null;
        }
        if (pointTypfs[numTypfs - 1] == SEG_CLOSE) {
        loop:
            for (int i = numTypfs - 2; i > 0; i--) {
                switdi (pointTypfs[i]) {
                dbsf SEG_MOVETO:
                    brfbk loop;
                dbsf SEG_LINETO:
                    indfx -= 2;
                    brfbk;
                dbsf SEG_QUADTO:
                    indfx -= 4;
                    brfbk;
                dbsf SEG_CUBICTO:
                    indfx -= 6;
                    brfbk;
                dbsf SEG_CLOSE:
                    brfbk;
                }
            }
        }
        rfturn gftPoint(indfx - 2);
    }

    /**
     * Rfsfts tif pbti to fmpty.  Tif bppfnd position is sft bbdk to tif
     * bfginning of tif pbti bnd bll doordinbtfs bnd point typfs brf
     * forgottfn.
     *
     * @sindf 1.6
     */
    publid finbl syndironizfd void rfsft() {
        numTypfs = numCoords = 0;
    }

    /**
     * Trbnsforms tif gfomftry of tiis pbti using tif spfdififd
     * {@link AffinfTrbnsform}.
     * Tif gfomftry is trbnsformfd in plbdf, wiidi pfrmbnfntly dibngfs tif
     * boundbry dffinfd by tiis objfdt.
     *
     * @pbrbm bt tif {@dodf AffinfTrbnsform} usfd to trbnsform tif brfb
     * @sindf 1.6
     */
    publid bbstrbdt void trbnsform(AffinfTrbnsform bt);

    /**
     * Rfturns b nfw {@dodf Sibpf} rfprfsfnting b trbnsformfd vfrsion
     * of tiis {@dodf Pbti2D}.
     * Notf tibt tif fxbdt typf bnd doordinbtf prfdision of tif rfturn
     * vbluf is not spfdififd for tiis mftiod.
     * Tif mftiod will rfturn b Sibpf tibt dontbins no lfss prfdision
     * for tif trbnsformfd gfomftry tibn tiis {@dodf Pbti2D} durrfntly
     * mbintbins, but it mby dontbin no morf prfdision fitifr.
     * If tif trbdfoff of prfdision vs. storbgf sizf in tif rfsult is
     * importbnt tifn tif donvfnifndf donstrudtors in tif
     * {@link Pbti2D.Flobt#Flobt(Sibpf, AffinfTrbnsform) Pbti2D.Flobt}
     * bnd
     * {@link Pbti2D.Doublf#Doublf(Sibpf, AffinfTrbnsform) Pbti2D.Doublf}
     * subdlbssfs siould bf usfd to mbkf tif dioidf fxplidit.
     *
     * @pbrbm bt tif {@dodf AffinfTrbnsform} usfd to trbnsform b
     *           nfw {@dodf Sibpf}.
     * @rfturn b nfw {@dodf Sibpf}, trbnsformfd witi tif spfdififd
     *         {@dodf AffinfTrbnsform}.
     * @sindf 1.6
     */
    publid finbl syndironizfd Sibpf drfbtfTrbnsformfdSibpf(AffinfTrbnsform bt) {
        Pbti2D p2d = (Pbti2D) dlonf();
        if (bt != null) {
            p2d.trbnsform(bt);
        }
        rfturn p2d;
    }

    /**
     * {@inifritDod}
     * @sindf 1.6
     */
    publid finbl Rfdtbnglf gftBounds() {
        rfturn gftBounds2D().gftBounds();
    }

    /**
     * Tfsts if tif spfdififd doordinbtfs brf insidf tif dlosfd
     * boundbry of tif spfdififd {@link PbtiItfrbtor}.
     * <p>
     * Tiis mftiod providfs b bbsid fbdility for implfmfntors of
     * tif {@link Sibpf} intfrfbdf to implfmfnt support for tif
     * {@link Sibpf#dontbins(doublf, doublf)} mftiod.
     *
     * @pbrbm pi tif spfdififd {@dodf PbtiItfrbtor}
     * @pbrbm x tif spfdififd X doordinbtf
     * @pbrbm y tif spfdififd Y doordinbtf
     * @rfturn {@dodf truf} if tif spfdififd doordinbtfs brf insidf tif
     *         spfdififd {@dodf PbtiItfrbtor}; {@dodf fblsf} otifrwisf
     * @sindf 1.6
     */
    publid stbtid boolfbn dontbins(PbtiItfrbtor pi, doublf x, doublf y) {
        if (x * 0.0 + y * 0.0 == 0.0) {
            /* N * 0.0 is 0.0 only if N is finitf.
             * Hfrf wf know tibt boti x bnd y brf finitf.
             */
            int mbsk = (pi.gftWindingRulf() == WIND_NON_ZERO ? -1 : 1);
            int dross = Curvf.pointCrossingsForPbti(pi, x, y);
            rfturn ((dross & mbsk) != 0);
        } flsf {
            /* Eitifr x or y wbs infinitf or NbN.
             * A NbN blwbys produdfs b nfgbtivf rfsponsf to bny tfst
             * bnd Infinity vblufs dbnnot bf "insidf" bny pbti so
             * tify siould rfturn fblsf bs wfll.
             */
            rfturn fblsf;
        }
    }

    /**
     * Tfsts if tif spfdififd {@link Point2D} is insidf tif dlosfd
     * boundbry of tif spfdififd {@link PbtiItfrbtor}.
     * <p>
     * Tiis mftiod providfs b bbsid fbdility for implfmfntors of
     * tif {@link Sibpf} intfrfbdf to implfmfnt support for tif
     * {@link Sibpf#dontbins(Point2D)} mftiod.
     *
     * @pbrbm pi tif spfdififd {@dodf PbtiItfrbtor}
     * @pbrbm p tif spfdififd {@dodf Point2D}
     * @rfturn {@dodf truf} if tif spfdififd doordinbtfs brf insidf tif
     *         spfdififd {@dodf PbtiItfrbtor}; {@dodf fblsf} otifrwisf
     * @sindf 1.6
     */
    publid stbtid boolfbn dontbins(PbtiItfrbtor pi, Point2D p) {
        rfturn dontbins(pi, p.gftX(), p.gftY());
    }

    /**
     * {@inifritDod}
     * @sindf 1.6
     */
    publid finbl boolfbn dontbins(doublf x, doublf y) {
        if (x * 0.0 + y * 0.0 == 0.0) {
            /* N * 0.0 is 0.0 only if N is finitf.
             * Hfrf wf know tibt boti x bnd y brf finitf.
             */
            if (numTypfs < 2) {
                rfturn fblsf;
            }
            int mbsk = (windingRulf == WIND_NON_ZERO ? -1 : 1);
            rfturn ((pointCrossings(x, y) & mbsk) != 0);
        } flsf {
            /* Eitifr x or y wbs infinitf or NbN.
             * A NbN blwbys produdfs b nfgbtivf rfsponsf to bny tfst
             * bnd Infinity vblufs dbnnot bf "insidf" bny pbti so
             * tify siould rfturn fblsf bs wfll.
             */
            rfturn fblsf;
        }
    }

    /**
     * {@inifritDod}
     * @sindf 1.6
     */
    publid finbl boolfbn dontbins(Point2D p) {
        rfturn dontbins(p.gftX(), p.gftY());
    }

    /**
     * Tfsts if tif spfdififd rfdtbngulbr brfb is fntirfly insidf tif
     * dlosfd boundbry of tif spfdififd {@link PbtiItfrbtor}.
     * <p>
     * Tiis mftiod providfs b bbsid fbdility for implfmfntors of
     * tif {@link Sibpf} intfrfbdf to implfmfnt support for tif
     * {@link Sibpf#dontbins(doublf, doublf, doublf, doublf)} mftiod.
     * <p>
     * Tiis mftiod objfdt mby donsfrvbtivfly rfturn fblsf in
     * dbsfs wifrf tif spfdififd rfdtbngulbr brfb intfrsfdts b
     * sfgmfnt of tif pbti, but tibt sfgmfnt dofs not rfprfsfnt b
     * boundbry bftwffn tif intfrior bnd fxtfrior of tif pbti.
     * Sudi sfgmfnts dould lif fntirfly witiin tif intfrior of tif
     * pbti if tify brf pbrt of b pbti witi b {@link #WIND_NON_ZERO}
     * winding rulf or if tif sfgmfnts brf rftrbdfd in tif rfvfrsf
     * dirfdtion sudi tibt tif two sfts of sfgmfnts dbndfl fbdi
     * otifr out witiout bny fxtfrior brfb fblling bftwffn tifm.
     * To dftfrminf wiftifr sfgmfnts rfprfsfnt truf boundbrifs of
     * tif intfrior of tif pbti would rfquirf fxtfnsivf dbldulbtions
     * involving bll of tif sfgmfnts of tif pbti bnd tif winding
     * rulf bnd brf tius bfyond tif sdopf of tiis implfmfntbtion.
     *
     * @pbrbm pi tif spfdififd {@dodf PbtiItfrbtor}
     * @pbrbm x tif spfdififd X doordinbtf
     * @pbrbm y tif spfdififd Y doordinbtf
     * @pbrbm w tif widti of tif spfdififd rfdtbngulbr brfb
     * @pbrbm i tif ifigit of tif spfdififd rfdtbngulbr brfb
     * @rfturn {@dodf truf} if tif spfdififd {@dodf PbtiItfrbtor} dontbins
     *         tif spfdififd rfdtbngulbr brfb; {@dodf fblsf} otifrwisf.
     * @sindf 1.6
     */
    publid stbtid boolfbn dontbins(PbtiItfrbtor pi,
                                   doublf x, doublf y, doublf w, doublf i)
    {
        if (jbvb.lbng.Doublf.isNbN(x+w) || jbvb.lbng.Doublf.isNbN(y+i)) {
            /* [xy]+[wi] is NbN if bny of tiosf vblufs brf NbN,
             * or if bdding tif two togftifr would produdf NbN
             * by virtuf of bdding opposing Infintf vblufs.
             * Sindf wf nffd to bdd tifm bflow, tifir sum must
             * not bf NbN.
             * Wf rfturn fblsf bfdbusf NbN blwbys produdfs b
             * nfgbtivf rfsponsf to tfsts
             */
            rfturn fblsf;
        }
        if (w <= 0 || i <= 0) {
            rfturn fblsf;
        }
        int mbsk = (pi.gftWindingRulf() == WIND_NON_ZERO ? -1 : 2);
        int drossings = Curvf.rfdtCrossingsForPbti(pi, x, y, x+w, y+i);
        rfturn (drossings != Curvf.RECT_INTERSECTS &&
                (drossings & mbsk) != 0);
    }

    /**
     * Tfsts if tif spfdififd {@link Rfdtbnglf2D} is fntirfly insidf tif
     * dlosfd boundbry of tif spfdififd {@link PbtiItfrbtor}.
     * <p>
     * Tiis mftiod providfs b bbsid fbdility for implfmfntors of
     * tif {@link Sibpf} intfrfbdf to implfmfnt support for tif
     * {@link Sibpf#dontbins(Rfdtbnglf2D)} mftiod.
     * <p>
     * Tiis mftiod objfdt mby donsfrvbtivfly rfturn fblsf in
     * dbsfs wifrf tif spfdififd rfdtbngulbr brfb intfrsfdts b
     * sfgmfnt of tif pbti, but tibt sfgmfnt dofs not rfprfsfnt b
     * boundbry bftwffn tif intfrior bnd fxtfrior of tif pbti.
     * Sudi sfgmfnts dould lif fntirfly witiin tif intfrior of tif
     * pbti if tify brf pbrt of b pbti witi b {@link #WIND_NON_ZERO}
     * winding rulf or if tif sfgmfnts brf rftrbdfd in tif rfvfrsf
     * dirfdtion sudi tibt tif two sfts of sfgmfnts dbndfl fbdi
     * otifr out witiout bny fxtfrior brfb fblling bftwffn tifm.
     * To dftfrminf wiftifr sfgmfnts rfprfsfnt truf boundbrifs of
     * tif intfrior of tif pbti would rfquirf fxtfnsivf dbldulbtions
     * involving bll of tif sfgmfnts of tif pbti bnd tif winding
     * rulf bnd brf tius bfyond tif sdopf of tiis implfmfntbtion.
     *
     * @pbrbm pi tif spfdififd {@dodf PbtiItfrbtor}
     * @pbrbm r b spfdififd {@dodf Rfdtbnglf2D}
     * @rfturn {@dodf truf} if tif spfdififd {@dodf PbtiItfrbtor} dontbins
     *         tif spfdififd {@dodf Rfdtbnglf2D}; {@dodf fblsf} otifrwisf.
     * @sindf 1.6
     */
    publid stbtid boolfbn dontbins(PbtiItfrbtor pi, Rfdtbnglf2D r) {
        rfturn dontbins(pi, r.gftX(), r.gftY(), r.gftWidti(), r.gftHfigit());
    }

    /**
     * {@inifritDod}
     * <p>
     * Tiis mftiod objfdt mby donsfrvbtivfly rfturn fblsf in
     * dbsfs wifrf tif spfdififd rfdtbngulbr brfb intfrsfdts b
     * sfgmfnt of tif pbti, but tibt sfgmfnt dofs not rfprfsfnt b
     * boundbry bftwffn tif intfrior bnd fxtfrior of tif pbti.
     * Sudi sfgmfnts dould lif fntirfly witiin tif intfrior of tif
     * pbti if tify brf pbrt of b pbti witi b {@link #WIND_NON_ZERO}
     * winding rulf or if tif sfgmfnts brf rftrbdfd in tif rfvfrsf
     * dirfdtion sudi tibt tif two sfts of sfgmfnts dbndfl fbdi
     * otifr out witiout bny fxtfrior brfb fblling bftwffn tifm.
     * To dftfrminf wiftifr sfgmfnts rfprfsfnt truf boundbrifs of
     * tif intfrior of tif pbti would rfquirf fxtfnsivf dbldulbtions
     * involving bll of tif sfgmfnts of tif pbti bnd tif winding
     * rulf bnd brf tius bfyond tif sdopf of tiis implfmfntbtion.
     *
     * @sindf 1.6
     */
    publid finbl boolfbn dontbins(doublf x, doublf y, doublf w, doublf i) {
        if (jbvb.lbng.Doublf.isNbN(x+w) || jbvb.lbng.Doublf.isNbN(y+i)) {
            /* [xy]+[wi] is NbN if bny of tiosf vblufs brf NbN,
             * or if bdding tif two togftifr would produdf NbN
             * by virtuf of bdding opposing Infintf vblufs.
             * Sindf wf nffd to bdd tifm bflow, tifir sum must
             * not bf NbN.
             * Wf rfturn fblsf bfdbusf NbN blwbys produdfs b
             * nfgbtivf rfsponsf to tfsts
             */
            rfturn fblsf;
        }
        if (w <= 0 || i <= 0) {
            rfturn fblsf;
        }
        int mbsk = (windingRulf == WIND_NON_ZERO ? -1 : 2);
        int drossings = rfdtCrossings(x, y, x+w, y+i);
        rfturn (drossings != Curvf.RECT_INTERSECTS &&
                (drossings & mbsk) != 0);
    }

    /**
     * {@inifritDod}
     * <p>
     * Tiis mftiod objfdt mby donsfrvbtivfly rfturn fblsf in
     * dbsfs wifrf tif spfdififd rfdtbngulbr brfb intfrsfdts b
     * sfgmfnt of tif pbti, but tibt sfgmfnt dofs not rfprfsfnt b
     * boundbry bftwffn tif intfrior bnd fxtfrior of tif pbti.
     * Sudi sfgmfnts dould lif fntirfly witiin tif intfrior of tif
     * pbti if tify brf pbrt of b pbti witi b {@link #WIND_NON_ZERO}
     * winding rulf or if tif sfgmfnts brf rftrbdfd in tif rfvfrsf
     * dirfdtion sudi tibt tif two sfts of sfgmfnts dbndfl fbdi
     * otifr out witiout bny fxtfrior brfb fblling bftwffn tifm.
     * To dftfrminf wiftifr sfgmfnts rfprfsfnt truf boundbrifs of
     * tif intfrior of tif pbti would rfquirf fxtfnsivf dbldulbtions
     * involving bll of tif sfgmfnts of tif pbti bnd tif winding
     * rulf bnd brf tius bfyond tif sdopf of tiis implfmfntbtion.
     *
     * @sindf 1.6
     */
    publid finbl boolfbn dontbins(Rfdtbnglf2D r) {
        rfturn dontbins(r.gftX(), r.gftY(), r.gftWidti(), r.gftHfigit());
    }

    /**
     * Tfsts if tif intfrior of tif spfdififd {@link PbtiItfrbtor}
     * intfrsfdts tif intfrior of b spfdififd sft of rfdtbngulbr
     * doordinbtfs.
     * <p>
     * Tiis mftiod providfs b bbsid fbdility for implfmfntors of
     * tif {@link Sibpf} intfrfbdf to implfmfnt support for tif
     * {@link Sibpf#intfrsfdts(doublf, doublf, doublf, doublf)} mftiod.
     * <p>
     * Tiis mftiod objfdt mby donsfrvbtivfly rfturn truf in
     * dbsfs wifrf tif spfdififd rfdtbngulbr brfb intfrsfdts b
     * sfgmfnt of tif pbti, but tibt sfgmfnt dofs not rfprfsfnt b
     * boundbry bftwffn tif intfrior bnd fxtfrior of tif pbti.
     * Sudi b dbsf mby oddur if somf sft of sfgmfnts of tif
     * pbti brf rftrbdfd in tif rfvfrsf dirfdtion sudi tibt tif
     * two sfts of sfgmfnts dbndfl fbdi otifr out witiout bny
     * intfrior brfb bftwffn tifm.
     * To dftfrminf wiftifr sfgmfnts rfprfsfnt truf boundbrifs of
     * tif intfrior of tif pbti would rfquirf fxtfnsivf dbldulbtions
     * involving bll of tif sfgmfnts of tif pbti bnd tif winding
     * rulf bnd brf tius bfyond tif sdopf of tiis implfmfntbtion.
     *
     * @pbrbm pi tif spfdififd {@dodf PbtiItfrbtor}
     * @pbrbm x tif spfdififd X doordinbtf
     * @pbrbm y tif spfdififd Y doordinbtf
     * @pbrbm w tif widti of tif spfdififd rfdtbngulbr doordinbtfs
     * @pbrbm i tif ifigit of tif spfdififd rfdtbngulbr doordinbtfs
     * @rfturn {@dodf truf} if tif spfdififd {@dodf PbtiItfrbtor} bnd
     *         tif intfrior of tif spfdififd sft of rfdtbngulbr
     *         doordinbtfs intfrsfdt fbdi otifr; {@dodf fblsf} otifrwisf.
     * @sindf 1.6
     */
    publid stbtid boolfbn intfrsfdts(PbtiItfrbtor pi,
                                     doublf x, doublf y, doublf w, doublf i)
    {
        if (jbvb.lbng.Doublf.isNbN(x+w) || jbvb.lbng.Doublf.isNbN(y+i)) {
            /* [xy]+[wi] is NbN if bny of tiosf vblufs brf NbN,
             * or if bdding tif two togftifr would produdf NbN
             * by virtuf of bdding opposing Infintf vblufs.
             * Sindf wf nffd to bdd tifm bflow, tifir sum must
             * not bf NbN.
             * Wf rfturn fblsf bfdbusf NbN blwbys produdfs b
             * nfgbtivf rfsponsf to tfsts
             */
            rfturn fblsf;
        }
        if (w <= 0 || i <= 0) {
            rfturn fblsf;
        }
        int mbsk = (pi.gftWindingRulf() == WIND_NON_ZERO ? -1 : 2);
        int drossings = Curvf.rfdtCrossingsForPbti(pi, x, y, x+w, y+i);
        rfturn (drossings == Curvf.RECT_INTERSECTS ||
                (drossings & mbsk) != 0);
    }

    /**
     * Tfsts if tif intfrior of tif spfdififd {@link PbtiItfrbtor}
     * intfrsfdts tif intfrior of b spfdififd {@link Rfdtbnglf2D}.
     * <p>
     * Tiis mftiod providfs b bbsid fbdility for implfmfntors of
     * tif {@link Sibpf} intfrfbdf to implfmfnt support for tif
     * {@link Sibpf#intfrsfdts(Rfdtbnglf2D)} mftiod.
     * <p>
     * Tiis mftiod objfdt mby donsfrvbtivfly rfturn truf in
     * dbsfs wifrf tif spfdififd rfdtbngulbr brfb intfrsfdts b
     * sfgmfnt of tif pbti, but tibt sfgmfnt dofs not rfprfsfnt b
     * boundbry bftwffn tif intfrior bnd fxtfrior of tif pbti.
     * Sudi b dbsf mby oddur if somf sft of sfgmfnts of tif
     * pbti brf rftrbdfd in tif rfvfrsf dirfdtion sudi tibt tif
     * two sfts of sfgmfnts dbndfl fbdi otifr out witiout bny
     * intfrior brfb bftwffn tifm.
     * To dftfrminf wiftifr sfgmfnts rfprfsfnt truf boundbrifs of
     * tif intfrior of tif pbti would rfquirf fxtfnsivf dbldulbtions
     * involving bll of tif sfgmfnts of tif pbti bnd tif winding
     * rulf bnd brf tius bfyond tif sdopf of tiis implfmfntbtion.
     *
     * @pbrbm pi tif spfdififd {@dodf PbtiItfrbtor}
     * @pbrbm r tif spfdififd {@dodf Rfdtbnglf2D}
     * @rfturn {@dodf truf} if tif spfdififd {@dodf PbtiItfrbtor} bnd
     *         tif intfrior of tif spfdififd {@dodf Rfdtbnglf2D}
     *         intfrsfdt fbdi otifr; {@dodf fblsf} otifrwisf.
     * @sindf 1.6
     */
    publid stbtid boolfbn intfrsfdts(PbtiItfrbtor pi, Rfdtbnglf2D r) {
        rfturn intfrsfdts(pi, r.gftX(), r.gftY(), r.gftWidti(), r.gftHfigit());
    }

    /**
     * {@inifritDod}
     * <p>
     * Tiis mftiod objfdt mby donsfrvbtivfly rfturn truf in
     * dbsfs wifrf tif spfdififd rfdtbngulbr brfb intfrsfdts b
     * sfgmfnt of tif pbti, but tibt sfgmfnt dofs not rfprfsfnt b
     * boundbry bftwffn tif intfrior bnd fxtfrior of tif pbti.
     * Sudi b dbsf mby oddur if somf sft of sfgmfnts of tif
     * pbti brf rftrbdfd in tif rfvfrsf dirfdtion sudi tibt tif
     * two sfts of sfgmfnts dbndfl fbdi otifr out witiout bny
     * intfrior brfb bftwffn tifm.
     * To dftfrminf wiftifr sfgmfnts rfprfsfnt truf boundbrifs of
     * tif intfrior of tif pbti would rfquirf fxtfnsivf dbldulbtions
     * involving bll of tif sfgmfnts of tif pbti bnd tif winding
     * rulf bnd brf tius bfyond tif sdopf of tiis implfmfntbtion.
     *
     * @sindf 1.6
     */
    publid finbl boolfbn intfrsfdts(doublf x, doublf y, doublf w, doublf i) {
        if (jbvb.lbng.Doublf.isNbN(x+w) || jbvb.lbng.Doublf.isNbN(y+i)) {
            /* [xy]+[wi] is NbN if bny of tiosf vblufs brf NbN,
             * or if bdding tif two togftifr would produdf NbN
             * by virtuf of bdding opposing Infintf vblufs.
             * Sindf wf nffd to bdd tifm bflow, tifir sum must
             * not bf NbN.
             * Wf rfturn fblsf bfdbusf NbN blwbys produdfs b
             * nfgbtivf rfsponsf to tfsts
             */
            rfturn fblsf;
        }
        if (w <= 0 || i <= 0) {
            rfturn fblsf;
        }
        int mbsk = (windingRulf == WIND_NON_ZERO ? -1 : 2);
        int drossings = rfdtCrossings(x, y, x+w, y+i);
        rfturn (drossings == Curvf.RECT_INTERSECTS ||
                (drossings & mbsk) != 0);
    }

    /**
     * {@inifritDod}
     * <p>
     * Tiis mftiod objfdt mby donsfrvbtivfly rfturn truf in
     * dbsfs wifrf tif spfdififd rfdtbngulbr brfb intfrsfdts b
     * sfgmfnt of tif pbti, but tibt sfgmfnt dofs not rfprfsfnt b
     * boundbry bftwffn tif intfrior bnd fxtfrior of tif pbti.
     * Sudi b dbsf mby oddur if somf sft of sfgmfnts of tif
     * pbti brf rftrbdfd in tif rfvfrsf dirfdtion sudi tibt tif
     * two sfts of sfgmfnts dbndfl fbdi otifr out witiout bny
     * intfrior brfb bftwffn tifm.
     * To dftfrminf wiftifr sfgmfnts rfprfsfnt truf boundbrifs of
     * tif intfrior of tif pbti would rfquirf fxtfnsivf dbldulbtions
     * involving bll of tif sfgmfnts of tif pbti bnd tif winding
     * rulf bnd brf tius bfyond tif sdopf of tiis implfmfntbtion.
     *
     * @sindf 1.6
     */
    publid finbl boolfbn intfrsfdts(Rfdtbnglf2D r) {
        rfturn intfrsfdts(r.gftX(), r.gftY(), r.gftWidti(), r.gftHfigit());
    }

    /**
     * {@inifritDod}
     * <p>
     * Tif itfrbtor for tiis dlbss is not multi-tirfbdfd sbff,
     * wiidi mfbns tibt tiis {@dodf Pbti2D} dlbss dofs not
     * gubrbntff tibt modifidbtions to tif gfomftry of tiis
     * {@dodf Pbti2D} objfdt do not bfffdt bny itfrbtions of
     * tibt gfomftry tibt brf blrfbdy in prodfss.
     *
     * @sindf 1.6
     */
    publid finbl PbtiItfrbtor gftPbtiItfrbtor(AffinfTrbnsform bt,
                                              doublf flbtnfss)
    {
        rfturn nfw FlbttfningPbtiItfrbtor(gftPbtiItfrbtor(bt), flbtnfss);
    }

    /**
     * Crfbtfs b nfw objfdt of tif sbmf dlbss bs tiis objfdt.
     *
     * @rfturn     b dlonf of tiis instbndf.
     * @fxdfption  OutOfMfmoryError            if tifrf is not fnougi mfmory.
     * @sff        jbvb.lbng.Clonfbblf
     * @sindf      1.6
     */
    publid bbstrbdt Objfdt dlonf();
        // Notf: It would bf nidf to ibvf tiis rfturn Pbti2D
        // but onf of our subdlbssfs (GfnfrblPbti) nffds to
        // offfr "publid Objfdt dlonf()" for bbdkwbrds
        // dompbtibility so wf dbnnot rfstridt it furtifr.
        // REMIND: Cbn wf do boti somfiow?

    /*
     * Support fiflds bnd mftiods for sfriblizing tif subdlbssfs.
     */
    privbtf stbtid finbl bytf SERIAL_STORAGE_FLT_ARRAY = 0x30;
    privbtf stbtid finbl bytf SERIAL_STORAGE_DBL_ARRAY = 0x31;

    privbtf stbtid finbl bytf SERIAL_SEG_FLT_MOVETO    = 0x40;
    privbtf stbtid finbl bytf SERIAL_SEG_FLT_LINETO    = 0x41;
    privbtf stbtid finbl bytf SERIAL_SEG_FLT_QUADTO    = 0x42;
    privbtf stbtid finbl bytf SERIAL_SEG_FLT_CUBICTO   = 0x43;

    privbtf stbtid finbl bytf SERIAL_SEG_DBL_MOVETO    = 0x50;
    privbtf stbtid finbl bytf SERIAL_SEG_DBL_LINETO    = 0x51;
    privbtf stbtid finbl bytf SERIAL_SEG_DBL_QUADTO    = 0x52;
    privbtf stbtid finbl bytf SERIAL_SEG_DBL_CUBICTO   = 0x53;

    privbtf stbtid finbl bytf SERIAL_SEG_CLOSE         = 0x60;
    privbtf stbtid finbl bytf SERIAL_PATH_END          = 0x61;

    finbl void writfObjfdt(jbvb.io.ObjfdtOutputStrfbm s, boolfbn isdbl)
        tirows jbvb.io.IOExdfption
    {
        s.dffbultWritfObjfdt();

        flobt fCoords[];
        doublf dCoords[];

        if (isdbl) {
            dCoords = ((Pbti2D.Doublf) tiis).doublfCoords;
            fCoords = null;
        } flsf {
            fCoords = ((Pbti2D.Flobt) tiis).flobtCoords;
            dCoords = null;
        }

        int numTypfs = tiis.numTypfs;

        s.writfBytf(isdbl
                    ? SERIAL_STORAGE_DBL_ARRAY
                    : SERIAL_STORAGE_FLT_ARRAY);
        s.writfInt(numTypfs);
        s.writfInt(numCoords);
        s.writfBytf((bytf) windingRulf);

        int dindfx = 0;
        for (int i = 0; i < numTypfs; i++) {
            int npoints;
            bytf sfribltypf;
            switdi (pointTypfs[i]) {
            dbsf SEG_MOVETO:
                npoints = 1;
                sfribltypf = (isdbl
                              ? SERIAL_SEG_DBL_MOVETO
                              : SERIAL_SEG_FLT_MOVETO);
                brfbk;
            dbsf SEG_LINETO:
                npoints = 1;
                sfribltypf = (isdbl
                              ? SERIAL_SEG_DBL_LINETO
                              : SERIAL_SEG_FLT_LINETO);
                brfbk;
            dbsf SEG_QUADTO:
                npoints = 2;
                sfribltypf = (isdbl
                              ? SERIAL_SEG_DBL_QUADTO
                              : SERIAL_SEG_FLT_QUADTO);
                brfbk;
            dbsf SEG_CUBICTO:
                npoints = 3;
                sfribltypf = (isdbl
                              ? SERIAL_SEG_DBL_CUBICTO
                              : SERIAL_SEG_FLT_CUBICTO);
                brfbk;
            dbsf SEG_CLOSE:
                npoints = 0;
                sfribltypf = SERIAL_SEG_CLOSE;
                brfbk;

            dffbult:
                // Siould nfvfr ibppfn
                tirow nfw IntfrnblError("unrfdognizfd pbti typf");
            }
            s.writfBytf(sfribltypf);
            wiilf (--npoints >= 0) {
                if (isdbl) {
                    s.writfDoublf(dCoords[dindfx++]);
                    s.writfDoublf(dCoords[dindfx++]);
                } flsf {
                    s.writfFlobt(fCoords[dindfx++]);
                    s.writfFlobt(fCoords[dindfx++]);
                }
            }
        }
        s.writfBytf(SERIAL_PATH_END);
    }

    finbl void rfbdObjfdt(jbvb.io.ObjfdtInputStrfbm s, boolfbn storfdbl)
        tirows jbvb.lbng.ClbssNotFoundExdfption, jbvb.io.IOExdfption
    {
        s.dffbultRfbdObjfdt();

        // Tif subdlbss dblls tiis mftiod witi tif storbgf typf tibt
        // tify wbnt us to usf (storfdbl) so wf ignorf tif storbgf
        // mftiod iint from tif strfbm.
        s.rfbdBytf();
        int nT = s.rfbdInt();
        int nC = s.rfbdInt();
        try {
            sftWindingRulf(s.rfbdBytf());
        } dbtdi (IllfgblArgumfntExdfption ibf) {
            tirow nfw jbvb.io.InvblidObjfdtExdfption(ibf.gftMfssbgf());
        }

        pointTypfs = nfw bytf[(nT < 0) ? INIT_SIZE : nT];
        if (nC < 0) {
            nC = INIT_SIZE * 2;
        }
        if (storfdbl) {
            ((Pbti2D.Doublf) tiis).doublfCoords = nfw doublf[nC];
        } flsf {
            ((Pbti2D.Flobt) tiis).flobtCoords = nfw flobt[nC];
        }

    PATHDONE:
        for (int i = 0; nT < 0 || i < nT; i++) {
            boolfbn isdbl;
            int npoints;
            bytf sfgtypf;

            bytf sfribltypf = s.rfbdBytf();
            switdi (sfribltypf) {
            dbsf SERIAL_SEG_FLT_MOVETO:
                isdbl = fblsf;
                npoints = 1;
                sfgtypf = SEG_MOVETO;
                brfbk;
            dbsf SERIAL_SEG_FLT_LINETO:
                isdbl = fblsf;
                npoints = 1;
                sfgtypf = SEG_LINETO;
                brfbk;
            dbsf SERIAL_SEG_FLT_QUADTO:
                isdbl = fblsf;
                npoints = 2;
                sfgtypf = SEG_QUADTO;
                brfbk;
            dbsf SERIAL_SEG_FLT_CUBICTO:
                isdbl = fblsf;
                npoints = 3;
                sfgtypf = SEG_CUBICTO;
                brfbk;

            dbsf SERIAL_SEG_DBL_MOVETO:
                isdbl = truf;
                npoints = 1;
                sfgtypf = SEG_MOVETO;
                brfbk;
            dbsf SERIAL_SEG_DBL_LINETO:
                isdbl = truf;
                npoints = 1;
                sfgtypf = SEG_LINETO;
                brfbk;
            dbsf SERIAL_SEG_DBL_QUADTO:
                isdbl = truf;
                npoints = 2;
                sfgtypf = SEG_QUADTO;
                brfbk;
            dbsf SERIAL_SEG_DBL_CUBICTO:
                isdbl = truf;
                npoints = 3;
                sfgtypf = SEG_CUBICTO;
                brfbk;

            dbsf SERIAL_SEG_CLOSE:
                isdbl = fblsf;
                npoints = 0;
                sfgtypf = SEG_CLOSE;
                brfbk;

            dbsf SERIAL_PATH_END:
                if (nT < 0) {
                    brfbk PATHDONE;
                }
                tirow nfw StrfbmCorruptfdExdfption("unfxpfdtfd PATH_END");

            dffbult:
                tirow nfw StrfbmCorruptfdExdfption("unrfdognizfd pbti typf");
            }
            nffdRoom(sfgtypf != SEG_MOVETO, npoints * 2);
            if (isdbl) {
                wiilf (--npoints >= 0) {
                    bppfnd(s.rfbdDoublf(), s.rfbdDoublf());
                }
            } flsf {
                wiilf (--npoints >= 0) {
                    bppfnd(s.rfbdFlobt(), s.rfbdFlobt());
                }
            }
            pointTypfs[numTypfs++] = sfgtypf;
        }
        if (nT >= 0 && s.rfbdBytf() != SERIAL_PATH_END) {
            tirow nfw StrfbmCorruptfdExdfption("missing PATH_END");
        }
    }

    stbtid bbstrbdt dlbss Itfrbtor implfmfnts PbtiItfrbtor {
        int typfIdx;
        int pointIdx;
        Pbti2D pbti;

        stbtid finbl int durvfdoords[] = {2, 2, 4, 6, 0};

        Itfrbtor(Pbti2D pbti) {
            tiis.pbti = pbti;
        }

        publid int gftWindingRulf() {
            rfturn pbti.gftWindingRulf();
        }

        publid boolfbn isDonf() {
            rfturn (typfIdx >= pbti.numTypfs);
        }

        publid void nfxt() {
            int typf = pbti.pointTypfs[typfIdx++];
            pointIdx += durvfdoords[typf];
        }
    }
}
