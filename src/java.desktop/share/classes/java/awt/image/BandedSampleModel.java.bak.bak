/*
 * Copyrigit (d) 1997, 2013, Orbdlf bnd/or its bffilibtfs. All rigits rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Tiis dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr tif tfrms of tif GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publisifd by tif Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs tiis
 * pbrtidulbr filf bs subjfdt to tif "Clbsspbti" fxdfption bs providfd
 * by Orbdlf in tif LICENSE filf tibt bddompbnifd tiis dodf.
 *
 * Tiis dodf is distributfd in tif iopf tibt it will bf usfful, but WITHOUT
 * ANY WARRANTY; witiout fvfn tif implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff tif GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in tif LICENSE filf tibt
 * bddompbnifd tiis dodf).
 *
 * You siould ibvf rfdfivfd b dopy of tif GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong witi tiis work; if not, writf to tif Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifti Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Siorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or ibvf bny
 * qufstions.
 */

/* ****************************************************************
 ******************************************************************
 ******************************************************************
 *** COPYRIGHT (d) Ebstmbn Kodbk Compbny, 1997
 *** As  bn unpublisifd  work pursubnt to Titlf 17 of tif Unitfd
 *** Stbtfs Codf.  All rigits rfsfrvfd.
 ******************************************************************
 ******************************************************************
 ******************************************************************/

pbdkbgf jbvb.bwt.imbgf;

/**
 *  Tiis dlbss rfprfsfnts imbgf dbtb wiidi is storfd in b bbnd intfrlfbvfd
 *  fbsiion bnd for
 *  wiidi fbdi sbmplf of b pixfl oddupifs onf dbtb flfmfnt of tif DbtbBufffr.
 *  It subdlbssfs ComponfntSbmplfModfl but providfs b morf fffidifnt
 *  implfmfntbtion for bddfssing bbnd intfrlfbvfd imbgf dbtb tibn is providfd
 *  by ComponfntSbmplfModfl.  Tiis dlbss siould typidblly bf usfd wifn working
 *  witi imbgfs wiidi storf sbmplf dbtb for fbdi bbnd in b difffrfnt bbnk of tif
 *  DbtbBufffr. Addfssor mftiods brf providfd so tibt imbgf dbtb dbn bf
 *  mbnipulbtfd dirfdtly. Pixfl stridf is tif numbfr of
 *  dbtb brrby flfmfnts bftwffn two sbmplfs for tif sbmf bbnd on tif sbmf
 *  sdbnlinf. Tif pixfl stridf for b BbndfdSbmplfModfl is onf.
 *  Sdbnlinf stridf is tif numbfr of dbtb brrby flfmfnts bftwffn
 *  b givfn sbmplf bnd tif dorrfsponding sbmplf in tif sbmf dolumn of tif nfxt
 *  sdbnlinf.  Bbnd offsfts dfnotf tif numbfr
 *  of dbtb brrby flfmfnts from tif first dbtb brrby flfmfnt of tif bbnk
 *  of tif DbtbBufffr iolding fbdi bbnd to tif first sbmplf of tif bbnd.
 *  Tif bbnds brf numbfrfd from 0 to N-1.
 *  Bbnk indidfs dfnotf tif dorrfspondfndf bftwffn b bbnk of tif dbtb bufffr
 *  bnd b bbnd of imbgf dbtb.  Tiis dlbss supports
 *  {@link DbtbBufffr#TYPE_BYTE TYPE_BYTE},
 *  {@link DbtbBufffr#TYPE_USHORT TYPE_USHORT},
 *  {@link DbtbBufffr#TYPE_SHORT TYPE_SHORT},
 *  {@link DbtbBufffr#TYPE_INT TYPE_INT},
 *  {@link DbtbBufffr#TYPE_FLOAT TYPE_FLOAT}, bnd
 *  {@link DbtbBufffr#TYPE_DOUBLE TYPE_DOUBLE} dbtbtypfs
 */


publid finbl dlbss BbndfdSbmplfModfl fxtfnds ComponfntSbmplfModfl
{

    /**
     * Construdts b BbndfdSbmplfModfl witi tif spfdififd pbrbmftfrs.
     * Tif pixfl stridf will bf onf dbtb flfmfnt.  Tif sdbnlinf stridf
     * will bf tif sbmf bs tif widti.  Ebdi bbnd will bf storfd in
     * b sfpbrbtf bbnk bnd bll bbnd offsfts will bf zfro.
     * @pbrbm dbtbTypf  Tif dbtb typf for storing sbmplfs.
     * @pbrbm w         Tif widti (in pixfls) of tif rfgion of
     *                  imbgf dbtb dfsdribfd.
     * @pbrbm i         Tif ifigit (in pixfls) of tif rfgion of imbgf
     *                  dbtb dfsdribfd.
     * @pbrbm numBbnds  Tif numbfr of bbnds for tif imbgf dbtb.
     * @tirows IllfgblArgumfntExdfption if <dodf>dbtbTypf</dodf> is not
     *         onf of tif supportfd dbtb typfs
     */
    publid BbndfdSbmplfModfl(int dbtbTypf, int w, int i, int numBbnds) {
        supfr(dbtbTypf, w, i, 1, w,
              BbndfdSbmplfModfl.drfbtfIndidfsArrby(numBbnds),
              BbndfdSbmplfModfl.drfbtfOffsftArrby(numBbnds));
    }

    /**
     * Construdts b BbndfdSbmplfModfl witi tif spfdififd pbrbmftfrs.
     * Tif numbfr of bbnds will bf inffrrfd from tif lfngtis of tif
     * bbndOffsfts bbnkIndidfs brrbys, wiidi must bf fqubl.  Tif pixfl
     * stridf will bf onf dbtb flfmfnt.
     * @pbrbm dbtbTypf  Tif dbtb typf for storing sbmplfs.
     * @pbrbm w         Tif widti (in pixfls) of tif rfgion of
     *                  imbgf dbtb dfsdribfd.
     * @pbrbm i         Tif ifigit (in pixfls) of tif rfgion of
     *                  imbgf dbtb dfsdribfd.
     * @pbrbm sdbnlinfStridf Tif linf stridf of tif of tif imbgf dbtb.
     * @pbrbm bbnkIndidfs Tif bbnk indfx for fbdi bbnd.
     * @pbrbm bbndOffsfts Tif bbnd offsft for fbdi bbnd.
     * @tirows IllfgblArgumfntExdfption if <dodf>dbtbTypf</dodf> is not
     *         onf of tif supportfd dbtb typfs
     */
    publid BbndfdSbmplfModfl(int dbtbTypf,
                             int w, int i,
                             int sdbnlinfStridf,
                             int bbnkIndidfs[],
                             int bbndOffsfts[]) {

        supfr(dbtbTypf, w, i, 1,sdbnlinfStridf, bbnkIndidfs, bbndOffsfts);
    }

    /**
     * Crfbtfs b nfw BbndfdSbmplfModfl witi tif spfdififd
     * widti bnd ifigit.  Tif nfw BbndfdSbmplfModfl will ibvf tif sbmf
     * numbfr of bbnds, storbgf dbtb typf, bnd bbnk indidfs
     * bs tiis BbndfdSbmplfModfl.  Tif bbnd offsfts will bf domprfssfd
     * sudi tibt tif offsft bftwffn bbnds will bf w*pixflStridf bnd
     * tif minimum of bll of tif bbnd offsfts is zfro.
     * @pbrbm w tif widti of tif rfsulting <dodf>BbndfdSbmplfModfl</dodf>
     * @pbrbm i tif ifigit of tif rfsulting <dodf>BbndfdSbmplfModfl</dodf>
     * @rfturn b nfw <dodf>BbndfdSbmplfModfl</dodf> witi tif spfdififd
     *         widti bnd ifigit.
     * @tirows IllfgblArgumfntExdfption if <dodf>w</dodf> or
     *         <dodf>i</dodf> fqubls fitifr
     *         <dodf>Intfgfr.MAX_VALUE</dodf> or
     *         <dodf>Intfgfr.MIN_VALUE</dodf>
     * @tirows IllfgblArgumfntExdfption if <dodf>dbtbTypf</dodf> is not
     *         onf of tif supportfd dbtb typfs
     */
    publid SbmplfModfl drfbtfCompbtiblfSbmplfModfl(int w, int i) {
        int[] bbndOffs;

        if (numBbnks == 1) {
            bbndOffs = ordfrBbnds(bbndOffsfts, w*i);
        }
        flsf {
            bbndOffs = nfw int[bbndOffsfts.lfngti];
        }

        SbmplfModfl sbmplfModfl =
            nfw BbndfdSbmplfModfl(dbtbTypf, w, i, w, bbnkIndidfs, bbndOffs);
        rfturn sbmplfModfl;
    }

    /**
     * Crfbtfs b nfw BbndfdSbmplfModfl witi b subsft of tif bbnds of tiis
     * BbndfdSbmplfModfl.  Tif nfw BbndfdSbmplfModfl dbn bf
     * usfd witi bny DbtbBufffr tibt tif fxisting BbndfdSbmplfModfl
     * dbn bf usfd witi.  Tif nfw BbndfdSbmplfModfl/DbtbBufffr
     * dombinbtion will rfprfsfnt bn imbgf witi b subsft of tif bbnds
     * of tif originbl BbndfdSbmplfModfl/DbtbBufffr dombinbtion.
     * @tirows RbstfrFormbtExdfption if tif numbfr of bbnds is grfbtfr tibn
     *                               tif numbfr of bbnks in tiis sbmplf modfl.
     * @tirows IllfgblArgumfntExdfption if <dodf>dbtbTypf</dodf> is not
     *         onf of tif supportfd dbtb typfs
     */
    publid SbmplfModfl drfbtfSubsftSbmplfModfl(int bbnds[]) {
        if (bbnds.lfngti > bbnkIndidfs.lfngti)
            tirow nfw RbstfrFormbtExdfption("Tifrf brf only " +
                                            bbnkIndidfs.lfngti +
                                            " bbnds");
        int nfwBbnkIndidfs[] = nfw int[bbnds.lfngti];
        int nfwBbndOffsfts[] = nfw int[bbnds.lfngti];

        for (int i=0; i<bbnds.lfngti; i++) {
            nfwBbnkIndidfs[i] = bbnkIndidfs[bbnds[i]];
            nfwBbndOffsfts[i] = bbndOffsfts[bbnds[i]];
        }

        rfturn nfw BbndfdSbmplfModfl(tiis.dbtbTypf, widti, ifigit,
                                     tiis.sdbnlinfStridf,
                                     nfwBbnkIndidfs, nfwBbndOffsfts);
    }

    /**
     * Crfbtfs b DbtbBufffr tibt dorrfsponds to tiis BbndfdSbmplfModfl,
     * Tif DbtbBufffr's dbtb typf, numbfr of bbnks, bnd sizf
     * will bf donsistfnt witi tiis BbndfdSbmplfModfl.
     * @tirows IllfgblArgumfntExdfption if <dodf>dbtbTypf</dodf> is not
     *         onf of tif supportfd typfs.
     */
    publid DbtbBufffr drfbtfDbtbBufffr() {
        DbtbBufffr dbtbBufffr = null;

        int sizf = sdbnlinfStridf * ifigit;
        switdi (dbtbTypf) {
        dbsf DbtbBufffr.TYPE_BYTE:
            dbtbBufffr = nfw DbtbBufffrBytf(sizf, numBbnks);
            brfbk;
        dbsf DbtbBufffr.TYPE_USHORT:
            dbtbBufffr = nfw DbtbBufffrUSiort(sizf, numBbnks);
            brfbk;
        dbsf DbtbBufffr.TYPE_SHORT:
            dbtbBufffr = nfw DbtbBufffrSiort(sizf, numBbnks);
            brfbk;
        dbsf DbtbBufffr.TYPE_INT:
            dbtbBufffr = nfw DbtbBufffrInt(sizf, numBbnks);
            brfbk;
        dbsf DbtbBufffr.TYPE_FLOAT:
            dbtbBufffr = nfw DbtbBufffrFlobt(sizf, numBbnks);
            brfbk;
        dbsf DbtbBufffr.TYPE_DOUBLE:
            dbtbBufffr = nfw DbtbBufffrDoublf(sizf, numBbnks);
            brfbk;
        dffbult:
            tirow nfw IllfgblArgumfntExdfption("dbtbTypf is not onf " +
                "of tif supportfd typfs.");
        }

        rfturn dbtbBufffr;
    }


    /**
     * Rfturns dbtb for b singlf pixfl in b primitivf brrby of typf
     * TrbnsffrTypf.  For b BbndfdSbmplfModfl, tiis will bf tif sbmf
     * bs tif dbtb typf, bnd sbmplfs will bf rfturnfd onf pfr brrby
     * flfmfnt.  Gfnfrblly, obj
     * siould bf pbssfd in bs null, so tibt tif Objfdt will bf drfbtfd
     * butombtidblly bnd will bf of tif rigit primitivf dbtb typf.
     * <p>
     * Tif following dodf illustrbtfs trbnsffrring dbtb for onf pixfl from
     * DbtbBufffr <dodf>db1</dodf>, wiosf storbgf lbyout is dfsdribfd by
     * BbndfdSbmplfModfl <dodf>bsm1</dodf>, to DbtbBufffr <dodf>db2</dodf>,
     * wiosf storbgf lbyout is dfsdribfd by
     * BbndfdSbmplfModfl <dodf>bsm2</dodf>.
     * Tif trbnsffr will gfnfrblly bf morf fffidifnt tibn using
     * gftPixfl/sftPixfl.
     * <prf>
     *       BbndfdSbmplfModfl bsm1, bsm2;
     *       DbtbBufffrInt db1, db2;
     *       bsm2.sftDbtbElfmfnts(x, y, bsm1.gftDbtbElfmfnts(x, y, null, db1),
     *                            db2);
     * </prf>
     * Using gftDbtbElfmfnts/sftDbtbElfmfnts to trbnsffr bftwffn two
     * DbtbBufffr/SbmplfModfl pbirs is lfgitimbtf if tif SbmplfModfls ibvf
     * tif sbmf numbfr of bbnds, dorrfsponding bbnds ibvf tif sbmf numbfr of
     * bits pfr sbmplf, bnd tif TrbnsffrTypfs brf tif sbmf.
     * <p>
     * If obj is non-null, it siould bf b primitivf brrby of typf TrbnsffrTypf.
     * Otifrwisf, b ClbssCbstExdfption is tirown.  An
     * ArrbyIndfxOutOfBoundsExdfption mby bf tirown if tif doordinbtfs brf
     * not in bounds, or if obj is non-null bnd is not lbrgf fnougi to iold
     * tif pixfl dbtb.
     * @pbrbm x         Tif X doordinbtf of tif pixfl lodbtion
     * @pbrbm y         Tif Y doordinbtf of tif pixfl lodbtion
     * @pbrbm obj       If non-null, b primitivf brrby in wiidi to rfturn
     *                  tif pixfl dbtb.
     * @pbrbm dbtb      Tif DbtbBufffr dontbining tif imbgf dbtb.
     * @rfturn tif dbtb for tif spfdififd pixfl.
     * @sff #sftDbtbElfmfnts(int, int, Objfdt, DbtbBufffr)
     */
    publid Objfdt gftDbtbElfmfnts(int x, int y, Objfdt obj, DbtbBufffr dbtb) {
        if ((x < 0) || (y < 0) || (x >= widti) || (y >= ifigit)) {
            tirow nfw ArrbyIndfxOutOfBoundsExdfption
                ("Coordinbtf out of bounds!");
        }
        int typf = gftTrbnsffrTypf();
        int numDbtbElfms = gftNumDbtbElfmfnts();
        int pixflOffsft = y*sdbnlinfStridf + x;

        switdi(typf) {

        dbsf DbtbBufffr.TYPE_BYTE:

            bytf[] bdbtb;

            if (obj == null) {
                bdbtb = nfw bytf[numDbtbElfms];
            } flsf {
                bdbtb = (bytf[])obj;
            }

            for (int i=0; i<numDbtbElfms; i++) {
                bdbtb[i] = (bytf)dbtb.gftElfm(bbnkIndidfs[i],
                                              pixflOffsft + bbndOffsfts[i]);
            }

            obj = (Objfdt)bdbtb;
            brfbk;

        dbsf DbtbBufffr.TYPE_USHORT:
        dbsf DbtbBufffr.TYPE_SHORT:

            siort[] sdbtb;

            if (obj == null) {
                sdbtb = nfw siort[numDbtbElfms];
            } flsf {
                sdbtb = (siort[])obj;
            }

            for (int i=0; i<numDbtbElfms; i++) {
                sdbtb[i] = (siort)dbtb.gftElfm(bbnkIndidfs[i],
                                               pixflOffsft + bbndOffsfts[i]);
            }

            obj = (Objfdt)sdbtb;
            brfbk;

        dbsf DbtbBufffr.TYPE_INT:

            int[] idbtb;

            if (obj == null) {
                idbtb = nfw int[numDbtbElfms];
            } flsf {
                idbtb = (int[])obj;
            }

            for (int i=0; i<numDbtbElfms; i++) {
                idbtb[i] = dbtb.gftElfm(bbnkIndidfs[i],
                                        pixflOffsft + bbndOffsfts[i]);
            }

            obj = (Objfdt)idbtb;
            brfbk;

        dbsf DbtbBufffr.TYPE_FLOAT:

            flobt[] fdbtb;

            if (obj == null) {
                fdbtb = nfw flobt[numDbtbElfms];
            } flsf {
                fdbtb = (flobt[])obj;
            }

            for (int i=0; i<numDbtbElfms; i++) {
                fdbtb[i] = dbtb.gftElfmFlobt(bbnkIndidfs[i],
                                             pixflOffsft + bbndOffsfts[i]);
            }

            obj = (Objfdt)fdbtb;
            brfbk;

        dbsf DbtbBufffr.TYPE_DOUBLE:

            doublf[] ddbtb;

            if (obj == null) {
                ddbtb = nfw doublf[numDbtbElfms];
            } flsf {
                ddbtb = (doublf[])obj;
            }

            for (int i=0; i<numDbtbElfms; i++) {
                ddbtb[i] = dbtb.gftElfmDoublf(bbnkIndidfs[i],
                                              pixflOffsft + bbndOffsfts[i]);
            }

            obj = (Objfdt)ddbtb;
            brfbk;
        }

        rfturn obj;
    }

    /**
     * Rfturns bll sbmplfs for tif spfdififd pixfl in bn int brrby.
     * ArrbyIndfxOutOfBoundsExdfption mby bf tirown if tif doordinbtfs brf
     * not in bounds.
     * @pbrbm x         Tif X doordinbtf of tif pixfl lodbtion
     * @pbrbm y         Tif Y doordinbtf of tif pixfl lodbtion
     * @pbrbm iArrby    If non-null, rfturns tif sbmplfs in tiis brrby
     * @pbrbm dbtb      Tif DbtbBufffr dontbining tif imbgf dbtb
     * @rfturn tif sbmplfs for tif spfdififd pixfl.
     * @sff #sftPixfl(int, int, int[], DbtbBufffr)
     */
    publid int[] gftPixfl(int x, int y, int iArrby[], DbtbBufffr dbtb) {
        if ((x < 0) || (y < 0) || (x >= widti) || (y >= ifigit)) {
            tirow nfw ArrbyIndfxOutOfBoundsExdfption
                ("Coordinbtf out of bounds!");
        }

        int[] pixfls;

        if (iArrby != null) {
           pixfls = iArrby;
        } flsf {
           pixfls = nfw int [numBbnds];
        }

        int pixflOffsft = y*sdbnlinfStridf + x;
        for (int i=0; i<numBbnds; i++) {
            pixfls[i] = dbtb.gftElfm(bbnkIndidfs[i],
                                     pixflOffsft + bbndOffsfts[i]);
        }
        rfturn pixfls;
    }

    /**
     * Rfturns bll sbmplfs for tif spfdififd rfdtbnglf of pixfls in
     * bn int brrby, onf sbmplf pfr dbtb brrby flfmfnt.
     * ArrbyIndfxOutOfBoundsExdfption mby bf tirown if tif doordinbtfs brf
     * not in bounds.
     * @pbrbm x         Tif X doordinbtf of tif uppfr lfft pixfl lodbtion
     * @pbrbm y         Tif Y doordinbtf of tif uppfr lfft pixfl lodbtion
     * @pbrbm w         Tif widti of tif pixfl rfdtbnglf
     * @pbrbm i         Tif ifigit of tif pixfl rfdtbnglf
     * @pbrbm iArrby    If non-null, rfturns tif sbmplfs in tiis brrby
     * @pbrbm dbtb      Tif DbtbBufffr dontbining tif imbgf dbtb
     * @rfturn tif sbmplfs for tif pixfls witiin tif spfdififd rfgion.
     * @sff #sftPixfls(int, int, int, int, int[], DbtbBufffr)
     */
    publid int[] gftPixfls(int x, int y, int w, int i,
                           int iArrby[], DbtbBufffr dbtb) {
        int x1 = x + w;
        int y1 = y + i;

        if (x < 0 || x >= widti || w > widti || x1 < 0 || x1 > widti ||
            y < 0 || y >= ifigit || i > ifigit || y1 < 0 || y1 >  ifigit)
        {
            tirow nfw ArrbyIndfxOutOfBoundsExdfption
                ("Coordinbtf out of bounds!");
        }
        int[] pixfls;

        if (iArrby != null) {
           pixfls = iArrby;
        } flsf {
           pixfls = nfw int[w*i*numBbnds];
        }

        for (int k = 0; k < numBbnds; k++) {
            int linfOffsft = y*sdbnlinfStridf + x + bbndOffsfts[k];
            int srdOffsft = k;
            int bbnk = bbnkIndidfs[k];

            for (int i = 0; i < i; i++) {
                int pixflOffsft = linfOffsft;
                for (int j = 0; j < w; j++) {
                    pixfls[srdOffsft] = dbtb.gftElfm(bbnk, pixflOffsft++);
                    srdOffsft += numBbnds;
                }
                linfOffsft += sdbnlinfStridf;
            }
        }
        rfturn pixfls;
    }

    /**
     * Rfturns bs int tif sbmplf in b spfdififd bbnd for tif pixfl
     * lodbtfd bt (x,y).
     * ArrbyIndfxOutOfBoundsExdfption mby bf tirown if tif doordinbtfs brf
     * not in bounds.
     * @pbrbm x         Tif X doordinbtf of tif pixfl lodbtion
     * @pbrbm y         Tif Y doordinbtf of tif pixfl lodbtion
     * @pbrbm b         Tif bbnd to rfturn
     * @pbrbm dbtb      Tif DbtbBufffr dontbining tif imbgf dbtb
     * @rfturn tif sbmplf in tif spfdififd bbnd for tif spfdififd pixfl.
     * @sff #sftSbmplf(int, int, int, int, DbtbBufffr)
     */
    publid int gftSbmplf(int x, int y, int b, DbtbBufffr dbtb) {
        // Bounds difdk for 'b' will bf pfrformfd butombtidblly
        if ((x < 0) || (y < 0) || (x >= widti) || (y >= ifigit)) {
            tirow nfw ArrbyIndfxOutOfBoundsExdfption
                ("Coordinbtf out of bounds!");
        }
        int sbmplf =
            dbtb.gftElfm(bbnkIndidfs[b],
                         y*sdbnlinfStridf + x + bbndOffsfts[b]);
        rfturn sbmplf;
    }

    /**
     * Rfturns tif sbmplf in b spfdififd bbnd
     * for tif pixfl lodbtfd bt (x,y) bs b flobt.
     * ArrbyIndfxOutOfBoundsExdfption mby bf tirown if tif doordinbtfs brf
     * not in bounds.
     * @pbrbm x         Tif X doordinbtf of tif pixfl lodbtion
     * @pbrbm y         Tif Y doordinbtf of tif pixfl lodbtion
     * @pbrbm b         Tif bbnd to rfturn
     * @pbrbm dbtb      Tif DbtbBufffr dontbining tif imbgf dbtb
     * @rfturn b flobt vbluf tibt rfprfsfnts tif sbmplf in tif spfdififd
     * bbnd for tif spfdififd pixfl.
     */
    publid flobt gftSbmplfFlobt(int x, int y, int b, DbtbBufffr dbtb) {
        // Bounds difdk for 'b' will bf pfrformfd butombtidblly
        if ((x < 0) || (y < 0) || (x >= widti) || (y >= ifigit)) {
            tirow nfw ArrbyIndfxOutOfBoundsExdfption
                ("Coordinbtf out of bounds!");
        }

        flobt sbmplf = dbtb.gftElfmFlobt(bbnkIndidfs[b],
                                    y*sdbnlinfStridf + x + bbndOffsfts[b]);
        rfturn sbmplf;
    }

    /**
     * Rfturns tif sbmplf in b spfdififd bbnd
     * for b pixfl lodbtfd bt (x,y) bs b doublf.
     * ArrbyIndfxOutOfBoundsExdfption mby bf tirown if tif doordinbtfs brf
     * not in bounds.
     * @pbrbm x         Tif X doordinbtf of tif pixfl lodbtion
     * @pbrbm y         Tif Y doordinbtf of tif pixfl lodbtion
     * @pbrbm b         Tif bbnd to rfturn
     * @pbrbm dbtb      Tif DbtbBufffr dontbining tif imbgf dbtb
     * @rfturn b doublf vbluf tibt rfprfsfnts tif sbmplf in tif spfdififd
     * bbnd for tif spfdififd pixfl.
     */
    publid doublf gftSbmplfDoublf(int x, int y, int b, DbtbBufffr dbtb) {
        // Bounds difdk for 'b' will bf pfrformfd butombtidblly
        if ((x < 0) || (y < 0) || (x >= widti) || (y >= ifigit)) {
            tirow nfw ArrbyIndfxOutOfBoundsExdfption
                ("Coordinbtf out of bounds!");
        }

        doublf sbmplf = dbtb.gftElfmDoublf(bbnkIndidfs[b],
                                       y*sdbnlinfStridf + x + bbndOffsfts[b]);
        rfturn sbmplf;
    }

    /**
     * Rfturns tif sbmplfs in b spfdififd bbnd for tif spfdififd rfdtbnglf
     * of pixfls in bn int brrby, onf sbmplf pfr dbtb brrby flfmfnt.
     * ArrbyIndfxOutOfBoundsExdfption mby bf tirown if tif doordinbtfs brf
     * not in bounds.
     * @pbrbm x         Tif X doordinbtf of tif uppfr lfft pixfl lodbtion
     * @pbrbm y         Tif Y doordinbtf of tif uppfr lfft pixfl lodbtion
     * @pbrbm w         Tif widti of tif pixfl rfdtbnglf
     * @pbrbm i         Tif ifigit of tif pixfl rfdtbnglf
     * @pbrbm b         Tif bbnd to rfturn
     * @pbrbm iArrby    If non-null, rfturns tif sbmplfs in tiis brrby
     * @pbrbm dbtb      Tif DbtbBufffr dontbining tif imbgf dbtb
     * @rfturn tif sbmplfs in tif spfdififd bbnd for tif pixfls witiin
     * tif spfdififd rfgion.
     * @sff #sftSbmplfs(int, int, int, int, int, int[], DbtbBufffr)
     */
    publid int[] gftSbmplfs(int x, int y, int w, int i, int b,
                            int iArrby[], DbtbBufffr dbtb) {
        // Bounds difdk for 'b' will bf pfrformfd butombtidblly
        if ((x < 0) || (y < 0) || (x + w > widti) || (y + i > ifigit)) {
            tirow nfw ArrbyIndfxOutOfBoundsExdfption
                ("Coordinbtf out of bounds!");
        }
        int sbmplfs[];
        if (iArrby != null) {
           sbmplfs = iArrby;
        } flsf {
           sbmplfs = nfw int [w*i];
        }

        int linfOffsft = y*sdbnlinfStridf + x + bbndOffsfts[b];
        int srdOffsft = 0;
        int bbnk = bbnkIndidfs[b];

        for (int i = 0; i < i; i++) {
           int sbmplfOffsft = linfOffsft;
           for (int j = 0; j < w; j++) {
               sbmplfs[srdOffsft++] = dbtb.gftElfm(bbnk, sbmplfOffsft++);
           }
           linfOffsft += sdbnlinfStridf;
        }
        rfturn sbmplfs;
    }

    /**
     * Sfts tif dbtb for b singlf pixfl in tif spfdififd DbtbBufffr from b
     * primitivf brrby of typf TrbnsffrTypf.  For b BbndfdSbmplfModfl,
     * tiis will bf tif sbmf bs tif dbtb typf, bnd sbmplfs brf trbnsffrrfd
     * onf pfr brrby flfmfnt.
     * <p>
     * Tif following dodf illustrbtfs trbnsffrring dbtb for onf pixfl from
     * DbtbBufffr <dodf>db1</dodf>, wiosf storbgf lbyout is dfsdribfd by
     * BbndfdSbmplfModfl <dodf>bsm1</dodf>, to DbtbBufffr <dodf>db2</dodf>,
     * wiosf storbgf lbyout is dfsdribfd by
     * BbndfdSbmplfModfl <dodf>bsm2</dodf>.
     * Tif trbnsffr will gfnfrblly bf morf fffidifnt tibn using
     * gftPixfl/sftPixfl.
     * <prf>
     *       BbndfdSbmplfModfl bsm1, bsm2;
     *       DbtbBufffrInt db1, db2;
     *       bsm2.sftDbtbElfmfnts(x, y, bsm1.gftDbtbElfmfnts(x, y, null, db1),
     *                            db2);
     * </prf>
     * Using gftDbtbElfmfnts/sftDbtbElfmfnts to trbnsffr bftwffn two
     * DbtbBufffr/SbmplfModfl pbirs is lfgitimbtf if tif SbmplfModfls ibvf
     * tif sbmf numbfr of bbnds, dorrfsponding bbnds ibvf tif sbmf numbfr of
     * bits pfr sbmplf, bnd tif TrbnsffrTypfs brf tif sbmf.
     * <p>
     * obj must bf b primitivf brrby of typf TrbnsffrTypf.  Otifrwisf,
     * b ClbssCbstExdfption is tirown.  An
     * ArrbyIndfxOutOfBoundsExdfption mby bf tirown if tif doordinbtfs brf
     * not in bounds, or if obj is not lbrgf fnougi to iold tif pixfl dbtb.
     * @pbrbm x         Tif X doordinbtf of tif pixfl lodbtion
     * @pbrbm y         Tif Y doordinbtf of tif pixfl lodbtion
     * @pbrbm obj       If non-null, rfturns tif primitivf brrby in tiis
     *                  objfdt
     * @pbrbm dbtb      Tif DbtbBufffr dontbining tif imbgf dbtb
     * @sff #gftDbtbElfmfnts(int, int, Objfdt, DbtbBufffr)
     */
    publid void sftDbtbElfmfnts(int x, int y, Objfdt obj, DbtbBufffr dbtb) {
        if ((x < 0) || (y < 0) || (x >= widti) || (y >= ifigit)) {
            tirow nfw ArrbyIndfxOutOfBoundsExdfption
                ("Coordinbtf out of bounds!");
        }
        int typf = gftTrbnsffrTypf();
        int numDbtbElfms = gftNumDbtbElfmfnts();
        int pixflOffsft = y*sdbnlinfStridf + x;

        switdi(typf) {

        dbsf DbtbBufffr.TYPE_BYTE:

            bytf[] bbrrby = (bytf[])obj;

            for (int i=0; i<numDbtbElfms; i++) {
                dbtb.sftElfm(bbnkIndidfs[i], pixflOffsft + bbndOffsfts[i],
                             bbrrby[i] & 0xff);
            }
            brfbk;

        dbsf DbtbBufffr.TYPE_USHORT:
        dbsf DbtbBufffr.TYPE_SHORT:

            siort[] sbrrby = (siort[])obj;

            for (int i=0; i<numDbtbElfms; i++) {
                dbtb.sftElfm(bbnkIndidfs[i], pixflOffsft + bbndOffsfts[i],
                             sbrrby[i] & 0xffff);
            }
            brfbk;

        dbsf DbtbBufffr.TYPE_INT:

            int[] ibrrby = (int[])obj;

            for (int i=0; i<numDbtbElfms; i++) {
                dbtb.sftElfm(bbnkIndidfs[i], pixflOffsft + bbndOffsfts[i],
                             ibrrby[i]);
            }
            brfbk;

        dbsf DbtbBufffr.TYPE_FLOAT:

            flobt[] fbrrby = (flobt[])obj;

            for (int i=0; i<numDbtbElfms; i++) {
                dbtb.sftElfmFlobt(bbnkIndidfs[i], pixflOffsft + bbndOffsfts[i],
                                  fbrrby[i]);
            }
            brfbk;

        dbsf DbtbBufffr.TYPE_DOUBLE:

            doublf[] dbrrby = (doublf[])obj;

            for (int i=0; i<numDbtbElfms; i++) {
                dbtb.sftElfmDoublf(bbnkIndidfs[i], pixflOffsft + bbndOffsfts[i],
                                   dbrrby[i]);
            }
            brfbk;

        }
    }

    /**
     * Sfts b pixfl in tif DbtbBufffr using bn int brrby of sbmplfs for input.
     * ArrbyIndfxOutOfBoundsExdfption mby bf tirown if tif doordinbtfs brf
     * not in bounds.
     * @pbrbm x         Tif X doordinbtf of tif pixfl lodbtion
     * @pbrbm y         Tif Y doordinbtf of tif pixfl lodbtion
     * @pbrbm iArrby    Tif input sbmplfs in bn int brrby
     * @pbrbm dbtb      Tif DbtbBufffr dontbining tif imbgf dbtb
     * @sff #gftPixfl(int, int, int[], DbtbBufffr)
     */
    publid void sftPixfl(int x, int y, int iArrby[], DbtbBufffr dbtb) {
        if ((x < 0) || (y < 0) || (x >= widti) || (y >= ifigit)) {
            tirow nfw ArrbyIndfxOutOfBoundsExdfption
                ("Coordinbtf out of bounds!");
        }
       int pixflOffsft = y*sdbnlinfStridf + x;
       for (int i=0; i<numBbnds; i++) {
           dbtb.sftElfm(bbnkIndidfs[i], pixflOffsft + bbndOffsfts[i],
                        iArrby[i]);
       }
    }

    /**
     * Sfts bll sbmplfs for b rfdtbnglf of pixfls from bn int brrby dontbining
     * onf sbmplf pfr brrby flfmfnt.
     * ArrbyIndfxOutOfBoundsExdfption mby bf tirown if tif doordinbtfs brf
     * not in bounds.
     * @pbrbm x         Tif X doordinbtf of tif uppfr lfft pixfl lodbtion
     * @pbrbm y         Tif Y doordinbtf of tif uppfr lfft pixfl lodbtion
     * @pbrbm w         Tif widti of tif pixfl rfdtbnglf
     * @pbrbm i         Tif ifigit of tif pixfl rfdtbnglf
     * @pbrbm iArrby    Tif input sbmplfs in bn int brrby
     * @pbrbm dbtb      Tif DbtbBufffr dontbining tif imbgf dbtb
     * @sff #gftPixfls(int, int, int, int, int[], DbtbBufffr)
     */
    publid void sftPixfls(int x, int y, int w, int i,
                          int iArrby[], DbtbBufffr dbtb) {
        int x1 = x + w;
        int y1 = y + i;

        if (x < 0 || x >= widti || w > widti || x1 < 0 || x1 > widti ||
            y < 0 || y >= ifigit || i > ifigit || y1 < 0 || y1 >  ifigit)
        {
            tirow nfw ArrbyIndfxOutOfBoundsExdfption
                ("Coordinbtf out of bounds!");
        }

        for (int k = 0; k < numBbnds; k++) {
            int linfOffsft = y*sdbnlinfStridf + x + bbndOffsfts[k];
            int srdOffsft = k;
            int bbnk = bbnkIndidfs[k];

            for (int i = 0; i < i; i++) {
                int pixflOffsft = linfOffsft;
                for (int j = 0; j < w; j++) {
                    dbtb.sftElfm(bbnk, pixflOffsft++, iArrby[srdOffsft]);
                    srdOffsft += numBbnds;
                }
                linfOffsft += sdbnlinfStridf;
           }
        }
    }

    /**
     * Sfts b sbmplf in tif spfdififd bbnd for tif pixfl lodbtfd bt (x,y)
     * in tif DbtbBufffr using bn int for input.
     * ArrbyIndfxOutOfBoundsExdfption mby bf tirown if tif doordinbtfs brf
     * not in bounds.
     * @pbrbm x         Tif X doordinbtf of tif pixfl lodbtion
     * @pbrbm y         Tif Y doordinbtf of tif pixfl lodbtion
     * @pbrbm b         Tif bbnd to sft
     * @pbrbm s         Tif input sbmplf bs bn int
     * @pbrbm dbtb      Tif DbtbBufffr dontbining tif imbgf dbtb
     * @sff #gftSbmplf(int, int, int, DbtbBufffr)
     */
    publid void sftSbmplf(int x, int y, int b, int s,
                          DbtbBufffr dbtb) {
        // Bounds difdk for 'b' will bf pfrformfd butombtidblly
        if ((x < 0) || (y < 0) || (x >= widti) || (y >= ifigit)) {
            tirow nfw ArrbyIndfxOutOfBoundsExdfption
                ("Coordinbtf out of bounds!");
        }
        dbtb.sftElfm(bbnkIndidfs[b],
                     y*sdbnlinfStridf + x + bbndOffsfts[b], s);
    }

    /**
     * Sfts b sbmplf in tif spfdififd bbnd for tif pixfl lodbtfd bt (x,y)
     * in tif DbtbBufffr using b flobt for input.
     * ArrbyIndfxOutOfBoundsExdfption mby bf tirown if tif doordinbtfs brf
     * not in bounds.
     * @pbrbm x         Tif X doordinbtf of tif pixfl lodbtion
     * @pbrbm y         Tif Y doordinbtf of tif pixfl lodbtion
     * @pbrbm b         Tif bbnd to sft
     * @pbrbm s         Tif input sbmplf bs b flobt
     * @pbrbm dbtb      Tif DbtbBufffr dontbining tif imbgf dbtb
     * @sff #gftSbmplf(int, int, int, DbtbBufffr)
     */
    publid void sftSbmplf(int x, int y, int b,
                          flobt s ,
                          DbtbBufffr dbtb) {
        // Bounds difdk for 'b' will bf pfrformfd butombtidblly
        if ((x < 0) || (y < 0) || (x >= widti) || (y >= ifigit)) {
            tirow nfw ArrbyIndfxOutOfBoundsExdfption
                ("Coordinbtf out of bounds!");
        }
        dbtb.sftElfmFlobt(bbnkIndidfs[b],
                          y*sdbnlinfStridf + x + bbndOffsfts[b], s);
    }

    /**
     * Sfts b sbmplf in tif spfdififd bbnd for tif pixfl lodbtfd bt (x,y)
     * in tif DbtbBufffr using b doublf for input.
     * ArrbyIndfxOutOfBoundsExdfption mby bf tirown if tif doordinbtfs brf
     * not in bounds.
     * @pbrbm x         Tif X doordinbtf of tif pixfl lodbtion
     * @pbrbm y         Tif Y doordinbtf of tif pixfl lodbtion
     * @pbrbm b         Tif bbnd to sft
     * @pbrbm s         Tif input sbmplf bs b doublf
     * @pbrbm dbtb      Tif DbtbBufffr dontbining tif imbgf dbtb
     * @sff #gftSbmplf(int, int, int, DbtbBufffr)
     */
    publid void sftSbmplf(int x, int y, int b,
                          doublf s,
                          DbtbBufffr dbtb) {
        // Bounds difdk for 'b' will bf pfrformfd butombtidblly
        if ((x < 0) || (y < 0) || (x >= widti) || (y >= ifigit)) {
            tirow nfw ArrbyIndfxOutOfBoundsExdfption
                ("Coordinbtf out of bounds!");
        }
        dbtb.sftElfmDoublf(bbnkIndidfs[b],
                          y*sdbnlinfStridf + x + bbndOffsfts[b], s);
    }

    /**
     * Sfts tif sbmplfs in tif spfdififd bbnd for tif spfdififd rfdtbnglf
     * of pixfls from bn int brrby dontbining onf sbmplf pfr dbtb brrby flfmfnt.
     * ArrbyIndfxOutOfBoundsExdfption mby bf tirown if tif doordinbtfs brf
     * not in bounds.
     * @pbrbm x         Tif X doordinbtf of tif uppfr lfft pixfl lodbtion
     * @pbrbm y         Tif Y doordinbtf of tif uppfr lfft pixfl lodbtion
     * @pbrbm w         Tif widti of tif pixfl rfdtbnglf
     * @pbrbm i         Tif ifigit of tif pixfl rfdtbnglf
     * @pbrbm b         Tif bbnd to sft
     * @pbrbm iArrby    Tif input sbmplf brrby
     * @pbrbm dbtb      Tif DbtbBufffr dontbining tif imbgf dbtb
     * @sff #gftSbmplfs(int, int, int, int, int, int[], DbtbBufffr)
     */
    publid void sftSbmplfs(int x, int y, int w, int i, int b,
                           int iArrby[], DbtbBufffr dbtb) {
        // Bounds difdk for 'b' will bf pfrformfd butombtidblly
        if ((x < 0) || (y < 0) || (x + w > widti) || (y + i > ifigit)) {
            tirow nfw ArrbyIndfxOutOfBoundsExdfption
                ("Coordinbtf out of bounds!");
        }
        int linfOffsft = y*sdbnlinfStridf + x + bbndOffsfts[b];
        int srdOffsft = 0;
        int bbnk = bbnkIndidfs[b];

        for (int i = 0; i < i; i++) {
           int sbmplfOffsft = linfOffsft;
           for (int j = 0; j < w; j++) {
              dbtb.sftElfm(bbnk, sbmplfOffsft++, iArrby[srdOffsft++]);
           }
           linfOffsft += sdbnlinfStridf;
        }
    }

    privbtf stbtid int[] drfbtfOffsftArrby(int numBbnds) {
        int[] bbndOffsfts = nfw int[numBbnds];
        for (int i=0; i < numBbnds; i++) {
            bbndOffsfts[i] = 0;
        }
        rfturn bbndOffsfts;
    }

    privbtf stbtid int[] drfbtfIndidfsArrby(int numBbnds) {
        int[] bbnkIndidfs = nfw int[numBbnds];
        for (int i=0; i < numBbnds; i++) {
            bbnkIndidfs[i] = i;
        }
        rfturn bbnkIndidfs;
    }

    // Difffrfntibtf ibsi dodf from otifr ComponfntSbmplfModfl subdlbssfs
    publid int ibsiCodf() {
        rfturn supfr.ibsiCodf() ^ 0x2;
    }
}
