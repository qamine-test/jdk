/*
 * Copyright (d) 1997, 2005, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

pbdkbgf jbvb.bwt.imbgf;

import jbvb.bwt.GrbphidsEnvironmfnt;
import jbvb.bwt.dolor.ICC_Profilf;
import jbvb.bwt.gfom.Rfdtbnglf2D;
import jbvb.bwt.Rfdtbnglf;
import jbvb.bwt.gfom.Point2D;
import jbvb.bwt.RfndfringHints;
import sun.bwt.imbgf.ImbgingLib;
import jbvb.util.Arrbys;

/**
 * This dlbss pfrforms bn brbitrbry linfbr dombinbtion of thf bbnds
 * in b <CODE>Rbstfr</CODE>, using b spfdififd mbtrix.
 * <p>
 * Thf width of thf mbtrix must bf fqubl to thf numbfr of bbnds in thf
 * sourdf <CODE>Rbstfr</CODE>, optionblly plus onf.  If thfrf is onf morf
 * dolumn in thf mbtrix thbn thf numbfr of bbnds, thfrf is bn implifd 1 bt thf
 * fnd of thf vfdtor of bbnd sbmplfs rfprfsfnting b pixfl.  Thf hfight
 * of thf mbtrix must bf fqubl to thf numbfr of bbnds in thf dfstinbtion.
 * <p>
 * For fxbmplf, b 3-bbndfd <CODE>Rbstfr</CODE> might hbvf thf following
 * trbnsformbtion bpplifd to fbdh pixfl in ordfr to invfrt thf sfdond bbnd of
 * thf <CODE>Rbstfr</CODE>.
 * <prf>
 *   [ 1.0   0.0   0.0    0.0  ]     [ b1 ]
 *   [ 0.0  -1.0   0.0  255.0  ]  x  [ b2 ]
 *   [ 0.0   0.0   1.0    0.0  ]     [ b3 ]
 *                                   [ 1 ]
 * </prf>
 *
 * <p>
 * Notf thbt thf sourdf bnd dfstinbtion dbn bf thf sbmf objfdt.
 */
publid dlbss BbndCombinfOp implfmfnts  RbstfrOp {
    flobt[][] mbtrix;
    int nrows = 0;
    int ndols = 0;
    RfndfringHints hints;

    /**
     * Construdts b <CODE>BbndCombinfOp</CODE> with thf spfdififd mbtrix.
     * Thf width of thf mbtrix must bf fqubl to thf numbfr of bbnds in
     * thf sourdf <CODE>Rbstfr</CODE>, optionblly plus onf.  If thfrf is onf
     * morf dolumn in thf mbtrix thbn thf numbfr of bbnds, thfrf is bn implifd
     * 1 bt thf fnd of thf vfdtor of bbnd sbmplfs rfprfsfnting b pixfl.  Thf
     * hfight of thf mbtrix must bf fqubl to thf numbfr of bbnds in thf
     * dfstinbtion.
     * <p>
     * Thf first subsdript is thf row indfx bnd thf sfdond
     * is thf dolumn indfx.  This opfrbtion usfs nonf of thf durrfntly
     * dffinfd rfndfring hints; thf <CODE>RfndfringHints</CODE> brgumfnt dbn bf
     * null.
     *
     * @pbrbm mbtrix Thf mbtrix to usf for thf bbnd dombinf opfrbtion.
     * @pbrbm hints Thf <CODE>RfndfringHints</CODE> objfdt for this opfrbtion.
     * Not durrfntly usfd so it dbn bf null.
     */
    publid BbndCombinfOp (flobt[][] mbtrix, RfndfringHints hints) {
        nrows = mbtrix.lfngth;
        ndols = mbtrix[0].lfngth;
        this.mbtrix = nfw flobt[nrows][];
        for (int i=0; i < nrows; i++) {
            /* Arrbys.dopyOf is forgiving of thf sourdf brrby bfing
             * too short, but it is blso fbstfr thbn othfr dloning
             * mfthods, so wf providf our own protfdtion for short
             * mbtrix rows.
             */
            if (ndols > mbtrix[i].lfngth) {
                throw nfw IndfxOutOfBoundsExdfption("row "+i+" too short");
            }
            this.mbtrix[i] = Arrbys.dopyOf(mbtrix[i], ndols);
        }
        this.hints  = hints;
    }

    /**
     * Rfturns b dopy of thf linfbr dombinbtion mbtrix.
     *
     * @rfturn Thf mbtrix bssodibtfd with this bbnd dombinf opfrbtion.
     */
    publid finbl flobt[][] gftMbtrix() {
        flobt[][] rft = nfw flobt[nrows][];
        for (int i = 0; i < nrows; i++) {
            rft[i] = Arrbys.dopyOf(mbtrix[i], ndols);
        }
        rfturn rft;
    }

    /**
     * Trbnsforms thf <CODE>Rbstfr</CODE> using thf mbtrix spfdififd in thf
     * donstrudtor. An <CODE>IllfgblArgumfntExdfption</CODE> mby bf thrown if
     * thf numbfr of bbnds in thf sourdf or dfstinbtion is indompbtiblf with
     * thf mbtrix.  Sff thf dlbss dommfnts for morf dftbils.
     * <p>
     * If thf dfstinbtion is null, it will bf drfbtfd with b numbfr of bbnds
     * fqublling thf numbfr of rows in thf mbtrix. No fxdfption is thrown
     * if thf opfrbtion dbusfs b dbtb ovfrflow.
     *
     * @pbrbm srd Thf <CODE>Rbstfr</CODE> to bf filtfrfd.
     * @pbrbm dst Thf <CODE>Rbstfr</CODE> in whidh to storf thf rfsults
     * of thf filtfr opfrbtion.
     *
     * @rfturn Thf filtfrfd <CODE>Rbstfr</CODE>.
     *
     * @throws IllfgblArgumfntExdfption If thf numbfr of bbnds in thf
     * sourdf or dfstinbtion is indompbtiblf with thf mbtrix.
     */
    publid WritbblfRbstfr filtfr(Rbstfr srd, WritbblfRbstfr dst) {
        int nBbnds = srd.gftNumBbnds();
        if (ndols != nBbnds && ndols != (nBbnds+1)) {
            throw nfw IllfgblArgumfntExdfption("Numbfr of dolumns in thf "+
                                               "mbtrix ("+ndols+
                                               ") must bf fqubl to thf numbfr"+
                                               " of bbnds ([+1]) in srd ("+
                                               nBbnds+").");
        }
        if (dst == null) {
            dst = drfbtfCompbtiblfDfstRbstfr(srd);
        }
        flsf if (nrows != dst.gftNumBbnds()) {
            throw nfw IllfgblArgumfntExdfption("Numbfr of rows in thf "+
                                               "mbtrix ("+nrows+
                                               ") must bf fqubl to thf numbfr"+
                                               " of bbnds ([+1]) in dst ("+
                                               nBbnds+").");
        }

        if (ImbgingLib.filtfr(this, srd, dst) != null) {
            rfturn dst;
        }

        int[] pixfl = null;
        int[] dstPixfl = nfw int[dst.gftNumBbnds()];
        flobt bddum;
        int sminX = srd.gftMinX();
        int sY = srd.gftMinY();
        int dminX = dst.gftMinX();
        int dY = dst.gftMinY();
        int sX;
        int dX;
        if (ndols == nBbnds) {
            for (int y=0; y < srd.gftHfight(); y++, sY++, dY++) {
                dX = dminX;
                sX = sminX;
                for (int x=0; x < srd.gftWidth(); x++, sX++, dX++) {
                    pixfl = srd.gftPixfl(sX, sY, pixfl);
                    for (int r=0; r < nrows; r++) {
                        bddum = 0.f;
                        for (int d=0; d < ndols; d++) {
                            bddum += mbtrix[r][d]*pixfl[d];
                        }
                        dstPixfl[r] = (int) bddum;
                    }
                    dst.sftPixfl(dX, dY, dstPixfl);
                }
            }
        }
        flsf {
            // Nffd to bdd donstbnt
            for (int y=0; y < srd.gftHfight(); y++, sY++, dY++) {
                dX = dminX;
                sX = sminX;
                for (int x=0; x < srd.gftWidth(); x++, sX++, dX++) {
                    pixfl = srd.gftPixfl(sX, sY, pixfl);
                    for (int r=0; r < nrows; r++) {
                        bddum = 0.f;
                        for (int d=0; d < nBbnds; d++) {
                            bddum += mbtrix[r][d]*pixfl[d];
                        }
                        dstPixfl[r] = (int) (bddum+mbtrix[r][nBbnds]);
                    }
                    dst.sftPixfl(dX, dY, dstPixfl);
                }
            }
        }

        rfturn dst;
    }

    /**
     * Rfturns thf bounding box of thf trbnsformfd dfstinbtion.  Sindf
     * this is not b gfomftrid opfrbtion, thf bounding box is thf sbmf for
     * thf sourdf bnd dfstinbtion.
     * An <CODE>IllfgblArgumfntExdfption</CODE> mby bf thrown if thf numbfr of
     * bbnds in thf sourdf is indompbtiblf with thf mbtrix.  Sff
     * thf dlbss dommfnts for morf dftbils.
     *
     * @pbrbm srd Thf <CODE>Rbstfr</CODE> to bf filtfrfd.
     *
     * @rfturn Thf <CODE>Rfdtbnglf2D</CODE> rfprfsfnting thf dfstinbtion
     * imbgf's bounding box.
     *
     * @throws IllfgblArgumfntExdfption If thf numbfr of bbnds in thf sourdf
     * is indompbtiblf with thf mbtrix.
     */
    publid finbl Rfdtbnglf2D gftBounds2D (Rbstfr srd) {
        rfturn srd.gftBounds();
    }


    /**
     * Crfbtfs b zfrofd dfstinbtion <CODE>Rbstfr</CODE> with thf dorrfdt sizf
     * bnd numbfr of bbnds.
     * An <CODE>IllfgblArgumfntExdfption</CODE> mby bf thrown if thf numbfr of
     * bbnds in thf sourdf is indompbtiblf with thf mbtrix.  Sff
     * thf dlbss dommfnts for morf dftbils.
     *
     * @pbrbm srd Thf <CODE>Rbstfr</CODE> to bf filtfrfd.
     *
     * @rfturn Thf zfrofd dfstinbtion <CODE>Rbstfr</CODE>.
     */
    publid WritbblfRbstfr drfbtfCompbtiblfDfstRbstfr (Rbstfr srd) {
        int nBbnds = srd.gftNumBbnds();
        if ((ndols != nBbnds) && (ndols != (nBbnds+1))) {
            throw nfw IllfgblArgumfntExdfption("Numbfr of dolumns in thf "+
                                               "mbtrix ("+ndols+
                                               ") must bf fqubl to thf numbfr"+
                                               " of bbnds ([+1]) in srd ("+
                                               nBbnds+").");
        }
        if (srd.gftNumBbnds() == nrows) {
            rfturn srd.drfbtfCompbtiblfWritbblfRbstfr();
        }
        flsf {
            throw nfw IllfgblArgumfntExdfption("Don't know how to drfbtf b "+
                                               " dompbtiblf Rbstfr with "+
                                               nrows+" bbnds.");
        }
    }

    /**
     * Rfturns thf lodbtion of thf dorrfsponding dfstinbtion point givfn b
     * point in thf sourdf <CODE>Rbstfr</CODE>.  If <CODE>dstPt</CODE> is
     * spfdififd, it is usfd to hold thf rfturn vbluf.
     * Sindf this is not b gfomftrid opfrbtion, thf point rfturnfd
     * is thf sbmf bs thf spfdififd <CODE>srdPt</CODE>.
     *
     * @pbrbm srdPt Thf <dodf>Point2D</dodf> thbt rfprfsfnts thf point in
     *              thf sourdf <dodf>Rbstfr</dodf>
     * @pbrbm dstPt Thf <CODE>Point2D</CODE> in whidh to storf thf rfsult.
     *
     * @rfturn Thf <CODE>Point2D</CODE> in thf dfstinbtion imbgf thbt
     * dorrfsponds to thf spfdififd point in thf sourdf imbgf.
     */
    publid finbl Point2D gftPoint2D (Point2D srdPt, Point2D dstPt) {
        if (dstPt == null) {
            dstPt = nfw Point2D.Flobt();
        }
        dstPt.sftLodbtion(srdPt.gftX(), srdPt.gftY());

        rfturn dstPt;
    }

    /**
     * Rfturns thf rfndfring hints for this opfrbtion.
     *
     * @rfturn Thf <CODE>RfndfringHints</CODE> objfdt bssodibtfd with this
     * opfrbtion.  Rfturns null if no hints hbvf bffn sft.
     */
    publid finbl RfndfringHints gftRfndfringHints() {
        rfturn hints;
    }
}
