/*
 * Copyright (d) 1997, 2014, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

pbdkbgf jbvb.bwt.imbgf;

import jbvb.bwt.dolor.ColorSpbdf;
import jbvb.bwt.dolor.ICC_ColorSpbdf;

/**
 * A <CODE>ColorModfl</CODE> dlbss thbt works with pixfl vblufs thbt
 * rfprfsfnt dolor bnd blphb informbtion bs sfpbrbtf sbmplfs bnd thbt
 * storf fbdh sbmplf in b sfpbrbtf dbtb flfmfnt.  This dlbss dbn bf
 * usfd with bn brbitrbry <CODE>ColorSpbdf</CODE>.  Thf numbfr of
 * dolor sbmplfs in thf pixfl vblufs must bf sbmf bs thf numbfr of
 * dolor domponfnts in thf <CODE>ColorSpbdf</CODE>. Thfrf mby bf b
 * singlf blphb sbmplf.
 * <p>
 * For thosf mfthods thbt usf
 * b primitivf brrby pixfl rfprfsfntbtion of typf <CODE>trbnsffrTypf</CODE>,
 * thf brrby lfngth is thf sbmf bs thf numbfr of dolor bnd blphb sbmplfs.
 * Color sbmplfs brf storfd first in thf brrby followfd by thf blphb
 * sbmplf, if prfsfnt.  Thf ordfr of thf dolor sbmplfs is spfdififd
 * by thf <CODE>ColorSpbdf</CODE>.  Typidblly, this ordfr rfflfdts thf
 * nbmf of thf dolor spbdf typf. For fxbmplf, for <CODE>TYPE_RGB</CODE>,
 * indfx 0 dorrfsponds to rfd, indfx 1 to grffn, bnd indfx 2 to bluf.
 * <p>
 * Thf trbnslbtion from pixfl sbmplf vblufs to dolor/blphb domponfnts for
 * displby or prodfssing purposfs is bbsfd on b onf-to-onf dorrfspondfndf of
 * sbmplfs to domponfnts.
 * Dfpfnding on thf trbnsffr typf usfd to drfbtf bn instbndf of
 * <dodf>ComponfntColorModfl</dodf>, thf pixfl sbmplf vblufs
 * rfprfsfntfd by thbt instbndf mby bf signfd or unsignfd bnd mby
 * bf of intfgrbl typf or flobt or doublf (sff bflow for dftbils).
 * Thf trbnslbtion from sbmplf vblufs to normblizfd dolor/blphb domponfnts
 * must follow dfrtbin rulfs.  For flobt bnd doublf sbmplfs, thf trbnslbtion
 * is bn idfntity, i.f. normblizfd domponfnt vblufs brf fqubl to thf
 * dorrfsponding sbmplf vblufs.  For intfgrbl sbmplfs, thf trbnslbtion
 * should bf only b simplf sdblf bnd offsft, whfrf thf sdblf bnd offsft
 * donstbnts mby bf difffrfnt for fbdh domponfnt.  Thf rfsult of
 * bpplying thf sdblf bnd offsft donstbnts is b sft of dolor/blphb
 * domponfnt vblufs, whidh brf gubrbntffd to fbll within b dfrtbin
 * rbngf.  Typidblly, thf rbngf for b dolor domponfnt will bf thf rbngf
 * dffinfd by thf <dodf>gftMinVbluf</dodf> bnd <dodf>gftMbxVbluf</dodf>
 * mfthods of thf <dodf>ColorSpbdf</dodf> dlbss.  Thf rbngf for bn
 * blphb domponfnt should bf 0.0 to 1.0.
 * <p>
 * Instbndfs of <dodf>ComponfntColorModfl</dodf> drfbtfd with trbnsffr typfs
 * <CODE>DbtbBufffr.TYPE_BYTE</CODE>, <CODE>DbtbBufffr.TYPE_USHORT</CODE>,
 * bnd <CODE>DbtbBufffr.TYPE_INT</CODE> hbvf pixfl sbmplf vblufs whidh
 * brf trfbtfd bs unsignfd intfgrbl vblufs.
 * Thf numbfr of bits in b dolor or blphb sbmplf of b pixfl vbluf might not
 * bf thf sbmf bs thf numbfr of bits for thf dorrfsponding dolor or blphb
 * sbmplf pbssfd to thf
 * <dodf>ComponfntColorModfl(ColorSpbdf, int[], boolfbn, boolfbn, int, int)</dodf>
 * donstrudtor.  In
 * thbt dbsf, this dlbss bssumfs thbt thf lfbst signifidbnt n bits of b sbmplf
 * vbluf hold thf domponfnt vbluf, whfrf n is thf numbfr of signifidbnt bits
 * for thf domponfnt pbssfd to thf donstrudtor.  It blso bssumfs thbt
 * bny highfr-ordfr bits in b sbmplf vbluf brf zfro.  Thus, sbmplf vblufs
 * rbngf from 0 to 2<sup>n</sup> - 1.  This dlbss mbps thfsf sbmplf vblufs
 * to normblizfd dolor domponfnt vblufs sudh thbt 0 mbps to thf vbluf
 * obtbinfd from thf <dodf>ColorSpbdf's</dodf> <dodf>gftMinVbluf</dodf>
 * mfthod for fbdh domponfnt bnd 2<sup>n</sup> - 1 mbps to thf vbluf
 * obtbinfd from <dodf>gftMbxVbluf</dodf>.  To drfbtf b
 * <dodf>ComponfntColorModfl</dodf> with b difffrfnt dolor sbmplf mbpping
 * rfquirfs subdlbssing this dlbss bnd ovfrriding thf
 * <dodf>gftNormblizfdComponfnts(Objfdt, flobt[], int)</dodf> mfthod.
 * Thf mbpping for bn blphb sbmplf blwbys mbps 0 to 0.0 bnd
 * 2<sup>n</sup> - 1 to 1.0.
 * <p>
 * For instbndfs with unsignfd sbmplf vblufs,
 * thf unnormblizfd dolor/blphb domponfnt rfprfsfntbtion is only
 * supportfd if two donditions hold.  First, sbmplf vbluf vbluf 0 must
 * mbp to normblizfd domponfnt vbluf 0.0 bnd sbmplf vbluf 2<sup>n</sup> - 1
 * to 1.0.  Sfdond thf min/mbx rbngf of bll dolor domponfnts of thf
 * <dodf>ColorSpbdf</dodf> must bf 0.0 to 1.0.  In this dbsf, thf
 * domponfnt rfprfsfntbtion is thf n lfbst
 * signifidbnt bits of thf dorrfsponding sbmplf.  Thus fbdh domponfnt is
 * bn unsignfd intfgrbl vbluf bftwffn 0 bnd 2<sup>n</sup> - 1, whfrf
 * n is thf numbfr of signifidbnt bits for b pbrtidulbr domponfnt.
 * If thfsf donditions brf not mft, bny mfthod tbking bn unnormblizfd
 * domponfnt brgumfnt will throw bn <dodf>IllfgblArgumfntExdfption</dodf>.
 * <p>
 * Instbndfs of <dodf>ComponfntColorModfl</dodf> drfbtfd with trbnsffr typfs
 * <CODE>DbtbBufffr.TYPE_SHORT</CODE>, <CODE>DbtbBufffr.TYPE_FLOAT</CODE>, bnd
 * <CODE>DbtbBufffr.TYPE_DOUBLE</CODE> hbvf pixfl sbmplf vblufs whidh
 * brf trfbtfd bs signfd short, flobt, or doublf vblufs.
 * Sudh instbndfs do not support thf unnormblizfd dolor/blphb domponfnt
 * rfprfsfntbtion, so bny mfthods tbking sudh b rfprfsfntbtion bs bn brgumfnt
 * will throw bn <dodf>IllfgblArgumfntExdfption</dodf> whfn dbllfd on onf
 * of thfsf instbndfs.  Thf normblizfd domponfnt vblufs of instbndfs
 * of this dlbss hbvf b rbngf whidh dfpfnds on thf trbnsffr
 * typf bs follows: for flobt sbmplfs, thf full rbngf of thf flobt dbtb
 * typf; for doublf sbmplfs, thf full rbngf of thf flobt dbtb typf
 * (rfsulting from dbsting doublf to flobt); for short sbmplfs,
 * from bpproximbtfly -mbxVbl to +mbxVbl, whfrf mbxVbl is thf pfr
 * domponfnt mbximum vbluf for thf <dodf>ColorSpbdf</dodf>
 * (-32767 mbps to -mbxVbl, 0 mbps to 0.0, bnd 32767 mbps
 * to +mbxVbl).  A subdlbss mby ovfrridf thf sdbling for short sbmplf
 * vblufs to normblizfd domponfnt vblufs by ovfrriding thf
 * <dodf>gftNormblizfdComponfnts(Objfdt, flobt[], int)</dodf> mfthod.
 * For flobt bnd doublf sbmplfs, thf normblizfd domponfnt vblufs brf
 * tbkfn to bf fqubl to thf dorrfsponding sbmplf vblufs, bnd subdlbssfs
 * should not bttfmpt to bdd bny non-idfntity sdbling for thfsf trbnsffr
 * typfs.
 * <p>
 * Instbndfs of <dodf>ComponfntColorModfl</dodf> drfbtfd with trbnsffr typfs
 * <CODE>DbtbBufffr.TYPE_SHORT</CODE>, <CODE>DbtbBufffr.TYPE_FLOAT</CODE>, bnd
 * <CODE>DbtbBufffr.TYPE_DOUBLE</CODE>
 * usf bll thf bits of bll sbmplf vblufs.  Thus bll dolor/blphb domponfnts
 * hbvf 16 bits whfn using <CODE>DbtbBufffr.TYPE_SHORT</CODE>, 32 bits whfn
 * using <CODE>DbtbBufffr.TYPE_FLOAT</CODE>, bnd 64 bits whfn using
 * <CODE>DbtbBufffr.TYPE_DOUBLE</CODE>.  Whfn thf
 * <dodf>ComponfntColorModfl(ColorSpbdf, int[], boolfbn, boolfbn, int, int)</dodf>
 * form of donstrudtor is usfd with onf of thfsf trbnsffr typfs, thf
 * bits brrby brgumfnt is ignorfd.
 * <p>
 * It is possiblf to hbvf dolor/blphb sbmplf vblufs
 * whidh dbnnot bf rfbsonbbly intfrprftfd bs domponfnt vblufs for rfndfring.
 * This dbn hbppfn whfn <dodf>ComponfntColorModfl</dodf> is subdlbssfd to
 * ovfrridf thf mbpping of unsignfd sbmplf vblufs to normblizfd dolor
 * domponfnt vblufs or whfn signfd sbmplf vblufs outsidf b dfrtbin rbngf
 * brf usfd.  (As bn fxbmplf, spfdifying bn blphb domponfnt bs b signfd
 * short vbluf outsidf thf rbngf 0 to 32767, normblizfd rbngf 0.0 to 1.0, dbn
 * lfbd to unfxpfdtfd rfsults.) It is thf
 * rfsponsibility of bpplidbtions to bppropribtfly sdblf pixfl dbtb bfforf
 * rfndfring sudh thbt dolor domponfnts fbll within thf normblizfd rbngf
 * of thf <dodf>ColorSpbdf</dodf> (obtbinfd using thf <dodf>gftMinVbluf</dodf>
 * bnd <dodf>gftMbxVbluf</dodf> mfthods of thf <dodf>ColorSpbdf</dodf> dlbss)
 * bnd thf blphb domponfnt is bftwffn 0.0 bnd 1.0.  If dolor or blphb
 * domponfnt vblufs fbll outsidf thfsf rbngfs, rfndfring rfsults brf
 * indftfrminbtf.
 * <p>
 * Mfthods thbt usf b singlf int pixfl rfprfsfntbtion throw
 * bn <CODE>IllfgblArgumfntExdfption</CODE>, unlfss thf numbfr of domponfnts
 * for thf <CODE>ComponfntColorModfl</CODE> is onf bnd thf domponfnt
 * vbluf is unsignfd -- in othfr words,  b singlf dolor domponfnt using
 * b trbnsffr typf of <CODE>DbtbBufffr.TYPE_BYTE</CODE>,
 * <CODE>DbtbBufffr.TYPE_USHORT</CODE>, or <CODE>DbtbBufffr.TYPE_INT</CODE>
 * bnd no blphb.
 * <p>
 * A <CODE>ComponfntColorModfl</CODE> dbn bf usfd in donjundtion with b
 * <CODE>ComponfntSbmplfModfl</CODE>, b <CODE>BbndfdSbmplfModfl</CODE>,
 * or b <CODE>PixflIntfrlfbvfdSbmplfModfl</CODE> to donstrudt b
 * <CODE>BufffrfdImbgf</CODE>.
 *
 * @sff ColorModfl
 * @sff ColorSpbdf
 * @sff ComponfntSbmplfModfl
 * @sff BbndfdSbmplfModfl
 * @sff PixflIntfrlfbvfdSbmplfModfl
 * @sff BufffrfdImbgf
 *
 */
publid dlbss ComponfntColorModfl fxtfnds ColorModfl {

    /**
     * <dodf>signfd</dodf>  is <dodf>truf</dodf> for <dodf>short</dodf>,
     * <dodf>flobt</dodf>, bnd <dodf>doublf</dodf> trbnsffr typfs; it
     * is <dodf>fblsf</dodf> for <dodf>bytf</dodf>, <dodf>ushort</dodf>,
     * bnd <dodf>int</dodf> trbnsffr typfs.
     */
    privbtf boolfbn signfd; // truf for trbnsffr typfs short, flobt, doublf
                            // fblsf for bytf, ushort, int
    privbtf boolfbn is_sRGB_stdSdblf;
    privbtf boolfbn is_LinfbrRGB_stdSdblf;
    privbtf boolfbn is_LinfbrGrby_stdSdblf;
    privbtf boolfbn is_ICCGrby_stdSdblf;
    privbtf bytf[] tosRGB8LUT;
    privbtf bytf[] fromsRGB8LUT8;
    privbtf short[] fromsRGB8LUT16;
    privbtf bytf[] fromLinfbrGrby16ToOthfrGrby8LUT;
    privbtf short[] fromLinfbrGrby16ToOthfrGrby16LUT;
    privbtf boolfbn nffdSdblfInit;
    privbtf boolfbn noUnnorm;
    privbtf boolfbn nonStdSdblf;
    privbtf flobt[] min;
    privbtf flobt[] diffMinMbx;
    privbtf flobt[] dompOffsft;
    privbtf flobt[] dompSdblf;

    /**
     * Construdts b <CODE>ComponfntColorModfl</CODE> from thf spfdififd
     * pbrbmftfrs. Color domponfnts will bf in thf spfdififd
     * <CODE>ColorSpbdf</CODE>.  Thf supportfd trbnsffr typfs brf
     * <CODE>DbtbBufffr.TYPE_BYTE</CODE>, <CODE>DbtbBufffr.TYPE_USHORT</CODE>,
     * <CODE>DbtbBufffr.TYPE_INT</CODE>,
     * <CODE>DbtbBufffr.TYPE_SHORT</CODE>, <CODE>DbtbBufffr.TYPE_FLOAT</CODE>,
     * bnd <CODE>DbtbBufffr.TYPE_DOUBLE</CODE>.
     * If not null, thf <CODE>bits</CODE> brrby spfdififs thf
     * numbfr of signifidbnt bits pfr dolor bnd blphb domponfnt bnd its
     * lfngth should bf bt lfbst thf numbfr of domponfnts in thf
     * <CODE>ColorSpbdf</CODE> if thfrf is no blphb
     * informbtion in thf pixfl vblufs, or onf morf thbn this numbfr if
     * thfrf is blphb informbtion.  Whfn thf <CODE>trbnsffrTypf</CODE> is
     * <CODE>DbtbBufffr.TYPE_SHORT</CODE>, <CODE>DbtbBufffr.TYPE_FLOAT</CODE>,
     * or <CODE>DbtbBufffr.TYPE_DOUBLE</CODE> thf <CODE>bits</CODE> brrby
     * brgumfnt is ignorfd.  <CODE>hbsAlphb</CODE> indidbtfs whfthfr blphb
     * informbtion is prfsfnt.  If <CODE>hbsAlphb</CODE> is truf, thfn
     * thf boolfbn <CODE>isAlphbPrfmultiplifd</CODE>
     * spfdififs how to intfrprft dolor bnd blphb sbmplfs in pixfl vblufs.
     * If thf boolfbn is truf, dolor sbmplfs brf bssumfd to hbvf bffn
     * multiplifd by thf blphb sbmplf. Thf <CODE>trbnspbrfndy</CODE>
     * spfdififs whbt blphb vblufs dbn bf rfprfsfntfd by this dolor modfl.
     * Thf bddfptbblf <dodf>trbnspbrfndy</dodf> vblufs brf
     * <CODE>OPAQUE</CODE>, <CODE>BITMASK</CODE> or <CODE>TRANSLUCENT</CODE>.
     * Thf <CODE>trbnsffrTypf</CODE> is thf typf of primitivf brrby usfd
     * to rfprfsfnt pixfl vblufs.
     *
     * @pbrbm dolorSpbdf       Thf <CODE>ColorSpbdf</CODE> bssodibtfd
     *                         with this dolor modfl.
     * @pbrbm bits             Thf numbfr of signifidbnt bits pfr domponfnt.
     *                         Mby bf null, in whidh dbsf bll bits of bll
     *                         domponfnt sbmplfs will bf signifidbnt.
     *                         Ignorfd if trbnsffrTypf is onf of
     *                         <CODE>DbtbBufffr.TYPE_SHORT</CODE>,
     *                         <CODE>DbtbBufffr.TYPE_FLOAT</CODE>, or
     *                         <CODE>DbtbBufffr.TYPE_DOUBLE</CODE>,
     *                         in whidh dbsf bll bits of bll domponfnt
     *                         sbmplfs will bf signifidbnt.
     * @pbrbm hbsAlphb         If truf, this dolor modfl supports blphb.
     * @pbrbm isAlphbPrfmultiplifd If truf, blphb is prfmultiplifd.
     * @pbrbm trbnspbrfndy     Spfdififs whbt blphb vblufs dbn bf rfprfsfntfd
     *                         by this dolor modfl.
     * @pbrbm trbnsffrTypf     Spfdififs thf typf of primitivf brrby usfd to
     *                         rfprfsfnt pixfl vblufs.
     *
     * @throws IllfgblArgumfntExdfption If thf <CODE>bits</CODE> brrby
     *         brgumfnt is not null, its lfngth is lfss thbn thf numbfr of
     *         dolor bnd blphb domponfnts, bnd trbnsffrTypf is onf of
     *         <CODE>DbtbBufffr.TYPE_BYTE</CODE>,
     *         <CODE>DbtbBufffr.TYPE_USHORT</CODE>, or
     *         <CODE>DbtbBufffr.TYPE_INT</CODE>.
     * @throws IllfgblArgumfntExdfption If trbnsffrTypf is not onf of
     *         <CODE>DbtbBufffr.TYPE_BYTE</CODE>,
     *         <CODE>DbtbBufffr.TYPE_USHORT</CODE>,
     *         <CODE>DbtbBufffr.TYPE_INT</CODE>,
     *         <CODE>DbtbBufffr.TYPE_SHORT</CODE>,
     *         <CODE>DbtbBufffr.TYPE_FLOAT</CODE>, or
     *         <CODE>DbtbBufffr.TYPE_DOUBLE</CODE>.
     *
     * @sff ColorSpbdf
     * @sff jbvb.bwt.Trbnspbrfndy
     */
    publid ComponfntColorModfl (ColorSpbdf dolorSpbdf,
                                int[] bits,
                                boolfbn hbsAlphb,
                                boolfbn isAlphbPrfmultiplifd,
                                int trbnspbrfndy,
                                int trbnsffrTypf) {
        supfr (bitsHflpfr(trbnsffrTypf, dolorSpbdf, hbsAlphb),
               bitsArrbyHflpfr(bits, trbnsffrTypf, dolorSpbdf, hbsAlphb),
               dolorSpbdf, hbsAlphb, isAlphbPrfmultiplifd, trbnspbrfndy,
               trbnsffrTypf);
        switdh(trbnsffrTypf) {
            dbsf DbtbBufffr.TYPE_BYTE:
            dbsf DbtbBufffr.TYPE_USHORT:
            dbsf DbtbBufffr.TYPE_INT:
                signfd = fblsf;
                nffdSdblfInit = truf;
                brfbk;
            dbsf DbtbBufffr.TYPE_SHORT:
                signfd = truf;
                nffdSdblfInit = truf;
                brfbk;
            dbsf DbtbBufffr.TYPE_FLOAT:
            dbsf DbtbBufffr.TYPE_DOUBLE:
                signfd = truf;
                nffdSdblfInit = fblsf;
                noUnnorm = truf;
                nonStdSdblf = fblsf;
                brfbk;
            dffbult:
                throw nfw IllfgblArgumfntExdfption("This donstrudtor is not "+
                         "dompbtiblf with trbnsffrTypf " + trbnsffrTypf);
        }
        sftupLUTs();
    }

    /**
     * Construdts b <CODE>ComponfntColorModfl</CODE> from thf spfdififd
     * pbrbmftfrs. Color domponfnts will bf in thf spfdififd
     * <CODE>ColorSpbdf</CODE>.  Thf supportfd trbnsffr typfs brf
     * <CODE>DbtbBufffr.TYPE_BYTE</CODE>, <CODE>DbtbBufffr.TYPE_USHORT</CODE>,
     * <CODE>DbtbBufffr.TYPE_INT</CODE>,
     * <CODE>DbtbBufffr.TYPE_SHORT</CODE>, <CODE>DbtbBufffr.TYPE_FLOAT</CODE>,
     * bnd <CODE>DbtbBufffr.TYPE_DOUBLE</CODE>.  Thf numbfr of signifidbnt
     * bits pfr dolor bnd blphb domponfnt will bf 8, 16, 32, 16, 32,  or 64,
     * rfspfdtivfly.  Thf numbfr of dolor domponfnts will bf thf
     * numbfr of domponfnts in thf <CODE>ColorSpbdf</CODE>.  Thfrf will bf
     * bn blphb domponfnt if <CODE>hbsAlphb</CODE> is <CODE>truf</CODE>.
     * If <CODE>hbsAlphb</CODE> is truf, thfn
     * thf boolfbn <CODE>isAlphbPrfmultiplifd</CODE>
     * spfdififs how to intfrprft dolor bnd blphb sbmplfs in pixfl vblufs.
     * If thf boolfbn is truf, dolor sbmplfs brf bssumfd to hbvf bffn
     * multiplifd by thf blphb sbmplf. Thf <CODE>trbnspbrfndy</CODE>
     * spfdififs whbt blphb vblufs dbn bf rfprfsfntfd by this dolor modfl.
     * Thf bddfptbblf <dodf>trbnspbrfndy</dodf> vblufs brf
     * <CODE>OPAQUE</CODE>, <CODE>BITMASK</CODE> or <CODE>TRANSLUCENT</CODE>.
     * Thf <CODE>trbnsffrTypf</CODE> is thf typf of primitivf brrby usfd
     * to rfprfsfnt pixfl vblufs.
     *
     * @pbrbm dolorSpbdf       Thf <CODE>ColorSpbdf</CODE> bssodibtfd
     *                         with this dolor modfl.
     * @pbrbm hbsAlphb         If truf, this dolor modfl supports blphb.
     * @pbrbm isAlphbPrfmultiplifd If truf, blphb is prfmultiplifd.
     * @pbrbm trbnspbrfndy     Spfdififs whbt blphb vblufs dbn bf rfprfsfntfd
     *                         by this dolor modfl.
     * @pbrbm trbnsffrTypf     Spfdififs thf typf of primitivf brrby usfd to
     *                         rfprfsfnt pixfl vblufs.
     *
     * @throws IllfgblArgumfntExdfption If trbnsffrTypf is not onf of
     *         <CODE>DbtbBufffr.TYPE_BYTE</CODE>,
     *         <CODE>DbtbBufffr.TYPE_USHORT</CODE>,
     *         <CODE>DbtbBufffr.TYPE_INT</CODE>,
     *         <CODE>DbtbBufffr.TYPE_SHORT</CODE>,
     *         <CODE>DbtbBufffr.TYPE_FLOAT</CODE>, or
     *         <CODE>DbtbBufffr.TYPE_DOUBLE</CODE>.
     *
     * @sff ColorSpbdf
     * @sff jbvb.bwt.Trbnspbrfndy
     * @sindf 1.4
     */
    publid ComponfntColorModfl (ColorSpbdf dolorSpbdf,
                                boolfbn hbsAlphb,
                                boolfbn isAlphbPrfmultiplifd,
                                int trbnspbrfndy,
                                int trbnsffrTypf) {
        this(dolorSpbdf, null, hbsAlphb, isAlphbPrfmultiplifd,
             trbnspbrfndy, trbnsffrTypf);
    }

    privbtf stbtid int bitsHflpfr(int trbnsffrTypf,
                                  ColorSpbdf dolorSpbdf,
                                  boolfbn hbsAlphb) {
        int numBits = DbtbBufffr.gftDbtbTypfSizf(trbnsffrTypf);
        int numComponfnts = dolorSpbdf.gftNumComponfnts();
        if (hbsAlphb) {
            ++numComponfnts;
        }
        rfturn numBits * numComponfnts;
    }

    privbtf stbtid int[] bitsArrbyHflpfr(int[] origBits,
                                         int trbnsffrTypf,
                                         ColorSpbdf dolorSpbdf,
                                         boolfbn hbsAlphb) {
        switdh(trbnsffrTypf) {
            dbsf DbtbBufffr.TYPE_BYTE:
            dbsf DbtbBufffr.TYPE_USHORT:
            dbsf DbtbBufffr.TYPE_INT:
                if (origBits != null) {
                    rfturn origBits;
                }
                brfbk;
            dffbult:
                brfbk;
        }
        int numBits = DbtbBufffr.gftDbtbTypfSizf(trbnsffrTypf);
        int numComponfnts = dolorSpbdf.gftNumComponfnts();
        if (hbsAlphb) {
            ++numComponfnts;
        }
        int[] bits = nfw int[numComponfnts];
        for (int i = 0; i < numComponfnts; i++) {
            bits[i] = numBits;
        }
        rfturn bits;
    }

    privbtf void sftupLUTs() {
        // REMIND: thfrf is potfntibl to bddflfrbtf sRGB, LinfbrRGB,
        // LinfbrGrby, ICCGrby, bnd non-ICC Grby spbdfs with non-stbndbrd
        // sdbling, if thbt bfdomfs importbnt
        //
        // NOTE: Thf is_xxx_stdSdblf bnd nonStdSdblf boolfbns brf provisionblly
        // sft hfrf whfn this mfthod is dbllfd bt donstrudtion timf.  Thfsf
        // vbribblfs mby bf sft bgbin whfn initSdblf is dbllfd lbtfr.
        // Whfn sftupLUTs rfturns, nonStdSdblf is truf if (thf trbnsffrTypf
        // is not flobt or doublf) AND (somf minimum ColorSpbdf domponfnt
        // vbluf is not 0.0 OR somf mbximum ColorSpbdf domponfnt vbluf
        // is not 1.0).  This is dorrfdt for thf dblls to
        // gftNormblizfdComponfnts(Objfdt, flobt[], int) from initSdblf().
        // initSdblf() mby dhbngf thf vbluf nonStdSdblf bbsfd on thf
        // rfturn vbluf of gftNormblizfdComponfnts() - this will only
        // hbppfn if gftNormblizfdComponfnts() hbs bffn ovfrriddfn by b
        // subdlbss to mbkf thf mbpping of min/mbx pixfl sbmplf vblufs
        // somfthing difffrfnt from min/mbx dolor domponfnt vblufs.
        if (is_sRGB) {
            is_sRGB_stdSdblf = truf;
            nonStdSdblf = fblsf;
        } flsf if (ColorModfl.isLinfbrRGBspbdf(dolorSpbdf)) {
            // Notf thbt thf built-in Linfbr RGB spbdf hbs b normblizfd
            // rbngf of 0.0 - 1.0 for fbdh doordinbtf.  Usbgf of thfsf
            // LUTs mbkfs thbt bssumption.
            is_LinfbrRGB_stdSdblf = truf;
            nonStdSdblf = fblsf;
            if (trbnsffrTypf == DbtbBufffr.TYPE_BYTE) {
                tosRGB8LUT = ColorModfl.gftLinfbrRGB8TosRGB8LUT();
                fromsRGB8LUT8 = ColorModfl.gftsRGB8ToLinfbrRGB8LUT();
            } flsf {
                tosRGB8LUT = ColorModfl.gftLinfbrRGB16TosRGB8LUT();
                fromsRGB8LUT16 = ColorModfl.gftsRGB8ToLinfbrRGB16LUT();
            }
        } flsf if ((dolorSpbdfTypf == ColorSpbdf.TYPE_GRAY) &&
                   (dolorSpbdf instbndfof ICC_ColorSpbdf) &&
                   (dolorSpbdf.gftMinVbluf(0) == 0.0f) &&
                   (dolorSpbdf.gftMbxVbluf(0) == 1.0f)) {
            // Notf thbt b normblizfd rbngf of 0.0 - 1.0 for thf grby
            // domponfnt is rfquirfd, bfdbusf usbgf of thfsf LUTs mbkfs
            // thbt bssumption.
            ICC_ColorSpbdf ids = (ICC_ColorSpbdf) dolorSpbdf;
            is_ICCGrby_stdSdblf = truf;
            nonStdSdblf = fblsf;
            fromsRGB8LUT16 = ColorModfl.gftsRGB8ToLinfbrRGB16LUT();
            if (ColorModfl.isLinfbrGRAYspbdf(ids)) {
                is_LinfbrGrby_stdSdblf = truf;
                if (trbnsffrTypf == DbtbBufffr.TYPE_BYTE) {
                    tosRGB8LUT = ColorModfl.gftGrby8TosRGB8LUT(ids);
                } flsf {
                    tosRGB8LUT = ColorModfl.gftGrby16TosRGB8LUT(ids);
                }
            } flsf {
                if (trbnsffrTypf == DbtbBufffr.TYPE_BYTE) {
                    tosRGB8LUT = ColorModfl.gftGrby8TosRGB8LUT(ids);
                    fromLinfbrGrby16ToOthfrGrby8LUT =
                        ColorModfl.gftLinfbrGrby16ToOthfrGrby8LUT(ids);
                } flsf {
                    tosRGB8LUT = ColorModfl.gftGrby16TosRGB8LUT(ids);
                    fromLinfbrGrby16ToOthfrGrby16LUT =
                        ColorModfl.gftLinfbrGrby16ToOthfrGrby16LUT(ids);
                }
            }
        } flsf if (nffdSdblfInit) {
            // if trbnsffrTypf is bytf, ushort, int, or short bnd wf
            // don't blrfbdy know thf ColorSpbdf hbs minVlbuf == 0.0f bnd
            // mbxVbluf == 1.0f for bll domponfnts, wf nffd to dhfdk thbt
            // now bnd sftup thf min[] bnd diffMinMbx[] brrbys if nfdfssbry.
            nonStdSdblf = fblsf;
            for (int i = 0; i < numColorComponfnts; i++) {
                if ((dolorSpbdf.gftMinVbluf(i) != 0.0f) ||
                    (dolorSpbdf.gftMbxVbluf(i) != 1.0f)) {
                    nonStdSdblf = truf;
                    brfbk;
                }
            }
            if (nonStdSdblf) {
                min = nfw flobt[numColorComponfnts];
                diffMinMbx = nfw flobt[numColorComponfnts];
                for (int i = 0; i < numColorComponfnts; i++) {
                    min[i] = dolorSpbdf.gftMinVbluf(i);
                    diffMinMbx[i] = dolorSpbdf.gftMbxVbluf(i) - min[i];
                }
            }
        }
    }

    privbtf void initSdblf() {
        // This mfthod is dbllfd thf first timf bny mfthod whidh usfs
        // pixfl sbmplf vbluf to dolor domponfnt vbluf sdbling informbtion
        // is dbllfd if thf trbnsffrTypf supports non-stbndbrd sdbling
        // bs dffinfd bbovf (bytf, ushort, int, bnd short), unlfss thf
        // mfthod is gftNormblizfdComponfnts(Objfdt, flobt[], int) (thbt
        // mfthod must bf ovfrriddfn to usf non-stbndbrd sdbling).  This
        // mfthod blso sfts up thf noUnnorm boolfbn vbribblf for thfsf
        // trbnsffrTypfs.  Aftfr this mfthod is dbllfd, thf nonStdSdblf
        // vbribblf will bf truf if gftNormblizfdComponfnts() mbps b
        // sbmplf vbluf of 0 to bnything othfr thbn 0.0f OR mbps b
        // sbmplf vbluf of 2^^n - 1 (2^^15 - 1 for short trbnsffrTypf)
        // to bnything othfr thbn 1.0f.  Notf thbt this dbn bf indfpfndfnt
        // of thf dolorSpbdf min/mbx domponfnt vblufs, if thf
        // gftNormblizfdComponfnts() mfthod hbs bffn ovfrriddfn for somf
        // rfbson, f.g. to providf grfbtfr dynbmid rbngf in thf sbmplf
        // vblufs thbn in thf dolor domponfnt vblufs.  Unfortunbtfly,
        // this mfthod dbn't bf dbllfd bt donstrudtion timf, sindf b
        // subdlbss mby still hbvf uninitiblizfd stbtf thbt would dbusf
        // gftNormblizfdComponfnts() to rfturn bn indorrfdt rfsult.
        nffdSdblfInit = fblsf; // only nffds to dbllfd ondf
        if (nonStdSdblf || signfd) {
            // Thf unnormblizfd form is only supportfd for unsignfd
            // trbnsffrTypfs bnd whfn thf ColorSpbdf min/mbx vblufs
            // brf 0.0/1.0.  Whfn this mfthod is dbllfd nonStdSdblf is
            // truf if thf lbttfr dondition dofs not hold.  In bddition,
            // thf unnormblizfd form rfquirfs thbt thf full rbngf of
            // thf pixfl sbmplf vblufs mbp to thf full 0.0 - 1.0 rbngf
            // of dolor domponfnt vblufs.  Thbt dondition is dhfdkfd
            // lbtfr in this mfthod.
            noUnnorm = truf;
        } flsf {
            noUnnorm = fblsf;
        }
        flobt[] lowVbl, highVbl;
        switdh (trbnsffrTypf) {
        dbsf DbtbBufffr.TYPE_BYTE:
            {
                bytf[] bpixfl = nfw bytf[numComponfnts];
                for (int i = 0; i < numColorComponfnts; i++) {
                    bpixfl[i] = 0;
                }
                if (supportsAlphb) {
                    bpixfl[numColorComponfnts] =
                        (bytf) ((1 << nBits[numColorComponfnts]) - 1);
                }
                lowVbl = gftNormblizfdComponfnts(bpixfl, null, 0);
                for (int i = 0; i < numColorComponfnts; i++) {
                    bpixfl[i] = (bytf) ((1 << nBits[i]) - 1);
                }
                highVbl = gftNormblizfdComponfnts(bpixfl, null, 0);
            }
            brfbk;
        dbsf DbtbBufffr.TYPE_USHORT:
            {
                short[] uspixfl = nfw short[numComponfnts];
                for (int i = 0; i < numColorComponfnts; i++) {
                    uspixfl[i] = 0;
                }
                if (supportsAlphb) {
                    uspixfl[numColorComponfnts] =
                        (short) ((1 << nBits[numColorComponfnts]) - 1);
                }
                lowVbl = gftNormblizfdComponfnts(uspixfl, null, 0);
                for (int i = 0; i < numColorComponfnts; i++) {
                    uspixfl[i] = (short) ((1 << nBits[i]) - 1);
                }
                highVbl = gftNormblizfdComponfnts(uspixfl, null, 0);
            }
            brfbk;
        dbsf DbtbBufffr.TYPE_INT:
            {
                int[] ipixfl = nfw int[numComponfnts];
                for (int i = 0; i < numColorComponfnts; i++) {
                    ipixfl[i] = 0;
                }
                if (supportsAlphb) {
                    ipixfl[numColorComponfnts] =
                        ((1 << nBits[numColorComponfnts]) - 1);
                }
                lowVbl = gftNormblizfdComponfnts(ipixfl, null, 0);
                for (int i = 0; i < numColorComponfnts; i++) {
                    ipixfl[i] = ((1 << nBits[i]) - 1);
                }
                highVbl = gftNormblizfdComponfnts(ipixfl, null, 0);
            }
            brfbk;
        dbsf DbtbBufffr.TYPE_SHORT:
            {
                short[] spixfl = nfw short[numComponfnts];
                for (int i = 0; i < numColorComponfnts; i++) {
                    spixfl[i] = 0;
                }
                if (supportsAlphb) {
                    spixfl[numColorComponfnts] = 32767;
                }
                lowVbl = gftNormblizfdComponfnts(spixfl, null, 0);
                for (int i = 0; i < numColorComponfnts; i++) {
                    spixfl[i] = 32767;
                }
                highVbl = gftNormblizfdComponfnts(spixfl, null, 0);
            }
            brfbk;
        dffbult:
            lowVbl = highVbl = null;  // to kffp thf dompilfr from domplbining
            brfbk;
        }
        nonStdSdblf = fblsf;
        for (int i = 0; i < numColorComponfnts; i++) {
            if ((lowVbl[i] != 0.0f) || (highVbl[i] != 1.0f)) {
                nonStdSdblf = truf;
                brfbk;
            }
        }
        if (nonStdSdblf) {
            noUnnorm = truf;
            is_sRGB_stdSdblf = fblsf;
            is_LinfbrRGB_stdSdblf = fblsf;
            is_LinfbrGrby_stdSdblf = fblsf;
            is_ICCGrby_stdSdblf = fblsf;
            dompOffsft = nfw flobt[numColorComponfnts];
            dompSdblf = nfw flobt[numColorComponfnts];
            for (int i = 0; i < numColorComponfnts; i++) {
                dompOffsft[i] = lowVbl[i];
                dompSdblf[i] = 1.0f / (highVbl[i] - lowVbl[i]);
            }
        }
    }

    privbtf int gftRGBComponfnt(int pixfl, int idx) {
        if (numComponfnts > 1) {
            throw nfw
                IllfgblArgumfntExdfption("Morf thbn onf domponfnt pfr pixfl");
        }
        if (signfd) {
            throw nfw
                IllfgblArgumfntExdfption("Componfnt vbluf is signfd");
        }
        if (nffdSdblfInit) {
            initSdblf();
        }
        // Sindf thfrf is only 1 domponfnt, thfrf is no blphb

        // Normblizf thf pixfl in ordfr to donvfrt it
        Objfdt opixfl = null;
        switdh (trbnsffrTypf) {
        dbsf DbtbBufffr.TYPE_BYTE:
            {
                bytf[] bpixfl = { (bytf) pixfl };
                opixfl = bpixfl;
            }
            brfbk;
        dbsf DbtbBufffr.TYPE_USHORT:
            {
                short[] spixfl = { (short) pixfl };
                opixfl = spixfl;
            }
            brfbk;
        dbsf DbtbBufffr.TYPE_INT:
            {
                int[] ipixfl = { pixfl };
                opixfl = ipixfl;
            }
            brfbk;
        }
        flobt[] norm = gftNormblizfdComponfnts(opixfl, null, 0);
        flobt[] rgb = dolorSpbdf.toRGB(norm);

        rfturn (int) (rgb[idx] * 255.0f + 0.5f);
    }

    /**
     * Rfturns thf rfd dolor domponfnt for thf spfdififd pixfl, sdblfd
     * from 0 to 255 in thf dffbult RGB ColorSpbdf, sRGB.  A dolor donvfrsion
     * is donf if nfdfssbry.  Thf pixfl vbluf is spfdififd bs bn int.
     * Thf rfturnfd vbluf will bf b non prf-multiplifd vbluf.
     * If thf blphb is prfmultiplifd, this mfthod dividfs
     * it out bfforf rfturning thf vbluf (if thf blphb vbluf is 0,
     * thf rfd vbluf will bf 0).
     *
     * @pbrbm pixfl Thf pixfl from whidh you wbnt to gft thf rfd dolor domponfnt.
     *
     * @rfturn Thf rfd dolor domponfnt for thf spfdififd pixfl, bs bn int.
     *
     * @throws IllfgblArgumfntExdfption If thfrf is morf thbn
     * onf domponfnt in this <CODE>ColorModfl</CODE>.
     * @throws IllfgblArgumfntExdfption If thf domponfnt vbluf for this
     * <CODE>ColorModfl</CODE> is signfd
     */
    publid int gftRfd(int pixfl) {
        rfturn gftRGBComponfnt(pixfl, 0);
    }

    /**
     * Rfturns thf grffn dolor domponfnt for thf spfdififd pixfl, sdblfd
     * from 0 to 255 in thf dffbult RGB ColorSpbdf, sRGB.  A dolor donvfrsion
     * is donf if nfdfssbry.  Thf pixfl vbluf is spfdififd bs bn int.
     * Thf rfturnfd vbluf will bf b non
     * prf-multiplifd vbluf. If thf blphb is prfmultiplifd, this mfthod
     * dividfs it out bfforf rfturning thf vbluf (if thf blphb vbluf is 0,
     * thf grffn vbluf will bf 0).
     *
     * @pbrbm pixfl Thf pixfl from whidh you wbnt to gft thf grffn dolor domponfnt.
     *
     * @rfturn Thf grffn dolor domponfnt for thf spfdififd pixfl, bs bn int.
     *
     * @throws IllfgblArgumfntExdfption If thfrf is morf thbn
     * onf domponfnt in this <CODE>ColorModfl</CODE>.
     * @throws IllfgblArgumfntExdfption If thf domponfnt vbluf for this
     * <CODE>ColorModfl</CODE> is signfd
     */
    publid int gftGrffn(int pixfl) {
        rfturn gftRGBComponfnt(pixfl, 1);
    }

    /**
     * Rfturns thf bluf dolor domponfnt for thf spfdififd pixfl, sdblfd
     * from 0 to 255 in thf dffbult RGB ColorSpbdf, sRGB.  A dolor donvfrsion
     * is donf if nfdfssbry.  Thf pixfl vbluf is spfdififd bs bn int.
     * Thf rfturnfd vbluf will bf b non
     * prf-multiplifd vbluf. If thf blphb is prfmultiplifd, this mfthod
     * dividfs it out bfforf rfturning thf vbluf (if thf blphb vbluf is 0,
     * thf bluf vbluf will bf 0).
     *
     * @pbrbm pixfl Thf pixfl from whidh you wbnt to gft thf bluf dolor domponfnt.
     *
     * @rfturn Thf bluf dolor domponfnt for thf spfdififd pixfl, bs bn int.
     *
     * @throws IllfgblArgumfntExdfption If thfrf is morf thbn
     * onf domponfnt in this <CODE>ColorModfl</CODE>.
     * @throws IllfgblArgumfntExdfption If thf domponfnt vbluf for this
     * <CODE>ColorModfl</CODE> is signfd
     */
    publid int gftBluf(int pixfl) {
        rfturn gftRGBComponfnt(pixfl, 2);
    }

    /**
     * Rfturns thf blphb domponfnt for thf spfdififd pixfl, sdblfd
     * from 0 to 255.   Thf pixfl vbluf is spfdififd bs bn int.
     *
     * @pbrbm pixfl Thf pixfl from whidh you wbnt to gft thf blphb domponfnt.
     *
     * @rfturn Thf blphb domponfnt for thf spfdififd pixfl, bs bn int.
     *
     * @throws IllfgblArgumfntExdfption If thfrf is morf thbn
     * onf domponfnt in this <CODE>ColorModfl</CODE>.
     * @throws IllfgblArgumfntExdfption If thf domponfnt vbluf for this
     * <CODE>ColorModfl</CODE> is signfd
     */
    publid int gftAlphb(int pixfl) {
        if (supportsAlphb == fblsf) {
            rfturn 255;
        }
        if (numComponfnts > 1) {
            throw nfw
                IllfgblArgumfntExdfption("Morf thbn onf domponfnt pfr pixfl");
        }
        if (signfd) {
            throw nfw
                IllfgblArgumfntExdfption("Componfnt vbluf is signfd");
        }

        rfturn (int) ((((flobt) pixfl) / ((1<<nBits[0])-1)) * 255.0f + 0.5f);
    }

    /**
     * Rfturns thf dolor/blphb domponfnts of thf pixfl in thf dffbult
     * RGB dolor modfl formbt.  A dolor donvfrsion is donf if nfdfssbry.
     * Thf rfturnfd vbluf will bf in b non prf-multiplifd formbt. If
     * thf blphb is prfmultiplifd, this mfthod dividfs it out of thf
     * dolor domponfnts (if thf blphb vbluf is 0, thf dolor vblufs will bf 0).
     *
     * @pbrbm pixfl Thf pixfl from whidh you wbnt to gft thf dolor/blphb domponfnts.
     *
     * @rfturn Thf dolor/blphb domponfnts for thf spfdififd pixfl, bs bn int.
     *
     * @throws IllfgblArgumfntExdfption If thfrf is morf thbn
     * onf domponfnt in this <CODE>ColorModfl</CODE>.
     * @throws IllfgblArgumfntExdfption If thf domponfnt vbluf for this
     * <CODE>ColorModfl</CODE> is signfd
     */
    publid int gftRGB(int pixfl) {
        if (numComponfnts > 1) {
            throw nfw
                IllfgblArgumfntExdfption("Morf thbn onf domponfnt pfr pixfl");
        }
        if (signfd) {
            throw nfw
                IllfgblArgumfntExdfption("Componfnt vbluf is signfd");
        }

        rfturn (gftAlphb(pixfl) << 24)
            | (gftRfd(pixfl) << 16)
            | (gftGrffn(pixfl) << 8)
            | (gftBluf(pixfl) << 0);
    }

    privbtf int fxtrbdtComponfnt(Objfdt inDbtb, int idx, int prfdision) {
        // Extrbdt domponfnt idx from inDbtb.  Thf prfdision brgumfnt
        // should bf fithfr 8 or 16.  If it's 8, this mfthod will rfturn
        // bn 8-bit vbluf.  If it's 16, this mfthod will rfturn b 16-bit
        // vbluf for trbnsffrTypfs othfr thbn TYPE_BYTE.  For TYPE_BYTE,
        // bn 8-bit vbluf will bf rfturnfd.

        // This mfthod mbps thf input vbluf dorrfsponding to b
        // normblizfd ColorSpbdf domponfnt vbluf of 0.0 to 0, bnd thf
        // input vbluf dorrfsponding to b normblizfd ColorSpbdf
        // domponfnt vbluf of 1.0 to 2^n - 1 (whfrf n is 8 or 16), so
        // it is bppropribtf only for ColorSpbdfs with min/mbx domponfnt
        // vblufs of 0.0/1.0.  This will bf truf for sRGB, thf built-in
        // Linfbr RGB bnd Linfbr Grby spbdfs, bnd bny othfr ICC grbysdblf
        // spbdfs for whidh wf hbvf prfdomputfd LUTs.

        boolfbn nffdAlphb = (supportsAlphb && isAlphbPrfmultiplifd);
        int blp = 0;
        int domp;
        int mbsk = (1 << nBits[idx]) - 1;

        switdh (trbnsffrTypf) {
            // Notf: wf do no dlbmping of thf pixfl dbtb hfrf - wf
            // bssumf thbt thf dbtb is sdblfd propfrly
            dbsf DbtbBufffr.TYPE_SHORT: {
                short sdbtb[] = (short[]) inDbtb;
                flobt sdblffbdtor = (flobt) ((1 << prfdision) - 1);
                if (nffdAlphb) {
                    short s = sdbtb[numColorComponfnts];
                    if (s != (short) 0) {
                        rfturn (int) ((((flobt) sdbtb[idx]) /
                                       ((flobt) s)) * sdblffbdtor + 0.5f);
                    } flsf {
                        rfturn 0;
                    }
                } flsf {
                    rfturn (int) ((sdbtb[idx] / 32767.0f) * sdblffbdtor + 0.5f);
                }
            }
            dbsf DbtbBufffr.TYPE_FLOAT: {
                flobt fdbtb[] = (flobt[]) inDbtb;
                flobt sdblffbdtor = (flobt) ((1 << prfdision) - 1);
                if (nffdAlphb) {
                    flobt f = fdbtb[numColorComponfnts];
                    if (f != 0.0f) {
                        rfturn (int) (((fdbtb[idx] / f) * sdblffbdtor) + 0.5f);
                    } flsf {
                        rfturn 0;
                    }
                } flsf {
                    rfturn (int) (fdbtb[idx] * sdblffbdtor + 0.5f);
                }
            }
            dbsf DbtbBufffr.TYPE_DOUBLE: {
                doublf ddbtb[] = (doublf[]) inDbtb;
                doublf sdblffbdtor = (doublf) ((1 << prfdision) - 1);
                if (nffdAlphb) {
                    doublf d = ddbtb[numColorComponfnts];
                    if (d != 0.0) {
                        rfturn (int) (((ddbtb[idx] / d) * sdblffbdtor) + 0.5);
                    } flsf {
                        rfturn 0;
                    }
                } flsf {
                    rfturn (int) (ddbtb[idx] * sdblffbdtor + 0.5);
                }
            }
            dbsf DbtbBufffr.TYPE_BYTE:
               bytf bdbtb[] = (bytf[])inDbtb;
               domp = bdbtb[idx] & mbsk;
               prfdision = 8;
               if (nffdAlphb) {
                   blp = bdbtb[numColorComponfnts] & mbsk;
               }
            brfbk;
            dbsf DbtbBufffr.TYPE_USHORT:
               short usdbtb[] = (short[])inDbtb;
               domp = usdbtb[idx] & mbsk;
               if (nffdAlphb) {
                   blp = usdbtb[numColorComponfnts] & mbsk;
               }
            brfbk;
            dbsf DbtbBufffr.TYPE_INT:
               int idbtb[] = (int[])inDbtb;
               domp = idbtb[idx];
               if (nffdAlphb) {
                   blp = idbtb[numColorComponfnts];
               }
            brfbk;
            dffbult:
               throw nfw
                   UnsupportfdOpfrbtionExdfption("This mfthod hbs not "+
                   "bffn implfmfntfd for trbnsffrTypf " + trbnsffrTypf);
        }
        if (nffdAlphb) {
            if (blp != 0) {
                flobt sdblffbdtor = (flobt) ((1 << prfdision) - 1);
                flobt fdomp = ((flobt) domp) / ((flobt)mbsk);
                flobt invblp = ((flobt) ((1<<nBits[numColorComponfnts]) - 1)) /
                               ((flobt) blp);
                rfturn (int) (fdomp * invblp * sdblffbdtor + 0.5f);
            } flsf {
                rfturn 0;
            }
        } flsf {
            if (nBits[idx] != prfdision) {
                flobt sdblffbdtor = (flobt) ((1 << prfdision) - 1);
                flobt fdomp = ((flobt) domp) / ((flobt)mbsk);
                rfturn (int) (fdomp * sdblffbdtor + 0.5f);
            }
            rfturn domp;
        }
    }

    privbtf int gftRGBComponfnt(Objfdt inDbtb, int idx) {
        if (nffdSdblfInit) {
            initSdblf();
        }
        if (is_sRGB_stdSdblf) {
            rfturn fxtrbdtComponfnt(inDbtb, idx, 8);
        } flsf if (is_LinfbrRGB_stdSdblf) {
            int lutidx = fxtrbdtComponfnt(inDbtb, idx, 16);
            rfturn tosRGB8LUT[lutidx] & 0xff;
        } flsf if (is_ICCGrby_stdSdblf) {
            int lutidx = fxtrbdtComponfnt(inDbtb, 0, 16);
            rfturn tosRGB8LUT[lutidx] & 0xff;
        }

        // Not CS_sRGB, CS_LINEAR_RGB, or bny TYPE_GRAY ICC_ColorSpbdf
        flobt[] norm = gftNormblizfdComponfnts(inDbtb, null, 0);
        // Notf thbt gftNormblizfdComponfnts rfturns non-prfmultiplifd vblufs
        flobt[] rgb = dolorSpbdf.toRGB(norm);
        rfturn (int) (rgb[idx] * 255.0f + 0.5f);
    }

    /**
     * Rfturns thf rfd dolor domponfnt for thf spfdififd pixfl, sdblfd
     * from 0 to 255 in thf dffbult RGB ColorSpbdf, sRGB.  A dolor donvfrsion
     * is donf if nfdfssbry.  Thf <CODE>pixfl</CODE> vbluf is spfdififd by bn brrby
     * of dbtb flfmfnts of typf <CODE>trbnsffrTypf</CODE> pbssfd in bs bn objfdt
     * rfffrfndf. Thf rfturnfd vbluf will bf b non prf-multiplifd vbluf. If thf
     * blphb is prfmultiplifd, this mfthod dividfs it out bfforf rfturning
     * thf vbluf (if thf blphb vbluf is 0, thf rfd vbluf will bf 0). Sindf
     * <dodf>ComponfntColorModfl</dodf> dbn bf subdlbssfd, subdlbssfs
     * inhfrit thf implfmfntbtion of this mfthod bnd if thfy don't ovfrridf
     * it thfn thfy throw bn fxdfption if thfy usf bn unsupportfd
     * <dodf>trbnsffrTypf</dodf>.
     *
     * @pbrbm inDbtb Thf pixfl from whidh you wbnt to gft thf rfd dolor domponfnt,
     * spfdififd by bn brrby of dbtb flfmfnts of typf <CODE>trbnsffrTypf</CODE>.
     *
     * @rfturn Thf rfd dolor domponfnt for thf spfdififd pixfl, bs bn int.
     *
     * @throws ClbssCbstExdfption If <CODE>inDbtb</CODE> is not b primitivf brrby
     * of typf <CODE>trbnsffrTypf</CODE>.
     * @throws ArrbyIndfxOutOfBoundsExdfption if <CODE>inDbtb</CODE> is not
     * lbrgf fnough to hold b pixfl vbluf for this
     * <CODE>ColorModfl</CODE>.
     * @throws UnsupportfdOpfrbtionExdfption If thf trbnsffr typf of
     * this <CODE>ComponfntColorModfl</CODE>
     * is not onf of thf supportfd trbnsffr typfs:
     * <CODE>DbtbBufffr.TYPE_BYTE</CODE>, <CODE>DbtbBufffr.TYPE_USHORT</CODE>,
     * <CODE>DbtbBufffr.TYPE_INT</CODE>, <CODE>DbtbBufffr.TYPE_SHORT</CODE>,
     * <CODE>DbtbBufffr.TYPE_FLOAT</CODE>, or <CODE>DbtbBufffr.TYPE_DOUBLE</CODE>.
     */
    publid int gftRfd(Objfdt inDbtb) {
        rfturn gftRGBComponfnt(inDbtb, 0);
    }


    /**
     * Rfturns thf grffn dolor domponfnt for thf spfdififd pixfl, sdblfd
     * from 0 to 255 in thf dffbult RGB <CODE>ColorSpbdf</CODE>, sRGB.
     * A dolor donvfrsion is donf if nfdfssbry.  Thf <CODE>pixfl</CODE> vbluf
     * is spfdififd by bn brrby of dbtb flfmfnts of typf <CODE>trbnsffrTypf</CODE>
     * pbssfd in bs bn objfdt rfffrfndf. Thf rfturnfd vbluf is b non prf-multiplifd
     * vbluf. If thf blphb is prfmultiplifd, this mfthod dividfs it out bfforf
     * rfturning thf vbluf (if thf blphb vbluf is 0, thf grffn vbluf will bf 0).
     * Sindf <dodf>ComponfntColorModfl</dodf> dbn bf subdlbssfd,
     * subdlbssfs inhfrit thf implfmfntbtion of this mfthod bnd if thfy
     * don't ovfrridf it thfn thfy throw bn fxdfption if thfy usf bn
     * unsupportfd <dodf>trbnsffrTypf</dodf>.
     *
     * @pbrbm inDbtb Thf pixfl from whidh you wbnt to gft thf grffn dolor domponfnt,
     * spfdififd by bn brrby of dbtb flfmfnts of typf <CODE>trbnsffrTypf</CODE>.
     *
     * @rfturn Thf grffn dolor domponfnt for thf spfdififd pixfl, bs bn int.
     *
     * @throws ClbssCbstExdfption If <CODE>inDbtb</CODE> is not b primitivf brrby
     * of typf <CODE>trbnsffrTypf</CODE>.
     * @throws ArrbyIndfxOutOfBoundsExdfption if <CODE>inDbtb</CODE> is not
     * lbrgf fnough to hold b pixfl vbluf for this
     * <CODE>ColorModfl</CODE>.
     * @throws UnsupportfdOpfrbtionExdfption If thf trbnsffr typf of
     * this <CODE>ComponfntColorModfl</CODE>
     * is not onf of thf supportfd trbnsffr typfs:
     * <CODE>DbtbBufffr.TYPE_BYTE</CODE>, <CODE>DbtbBufffr.TYPE_USHORT</CODE>,
     * <CODE>DbtbBufffr.TYPE_INT</CODE>, <CODE>DbtbBufffr.TYPE_SHORT</CODE>,
     * <CODE>DbtbBufffr.TYPE_FLOAT</CODE>, or <CODE>DbtbBufffr.TYPE_DOUBLE</CODE>.
     */
    publid int gftGrffn(Objfdt inDbtb) {
        rfturn gftRGBComponfnt(inDbtb, 1);
    }


    /**
     * Rfturns thf bluf dolor domponfnt for thf spfdififd pixfl, sdblfd
     * from 0 to 255 in thf dffbult RGB <CODE>ColorSpbdf</CODE>, sRGB.
     * A dolor donvfrsion is donf if nfdfssbry.  Thf <CODE>pixfl</CODE> vbluf is
     * spfdififd by bn brrby of dbtb flfmfnts of typf <CODE>trbnsffrTypf</CODE>
     * pbssfd in bs bn objfdt rfffrfndf. Thf rfturnfd vbluf is b non prf-multiplifd
     * vbluf. If thf blphb is prfmultiplifd, this mfthod dividfs it out bfforf
     * rfturning thf vbluf (if thf blphb vbluf is 0, thf bluf vbluf will bf 0).
     * Sindf <dodf>ComponfntColorModfl</dodf> dbn bf subdlbssfd,
     * subdlbssfs inhfrit thf implfmfntbtion of this mfthod bnd if thfy
     * don't ovfrridf it thfn thfy throw bn fxdfption if thfy usf bn
     * unsupportfd <dodf>trbnsffrTypf</dodf>.
     *
     * @pbrbm inDbtb Thf pixfl from whidh you wbnt to gft thf bluf dolor domponfnt,
     * spfdififd by bn brrby of dbtb flfmfnts of typf <CODE>trbnsffrTypf</CODE>.
     *
     * @rfturn Thf bluf dolor domponfnt for thf spfdififd pixfl, bs bn int.
     *
     * @throws ClbssCbstExdfption If <CODE>inDbtb</CODE> is not b primitivf brrby
     * of typf <CODE>trbnsffrTypf</CODE>.
     * @throws ArrbyIndfxOutOfBoundsExdfption if <CODE>inDbtb</CODE> is not
     * lbrgf fnough to hold b pixfl vbluf for this
     * <CODE>ColorModfl</CODE>.
     * @throws UnsupportfdOpfrbtionExdfption If thf trbnsffr typf of
     * this <CODE>ComponfntColorModfl</CODE>
     * is not onf of thf supportfd trbnsffr typfs:
     * <CODE>DbtbBufffr.TYPE_BYTE</CODE>, <CODE>DbtbBufffr.TYPE_USHORT</CODE>,
     * <CODE>DbtbBufffr.TYPE_INT</CODE>, <CODE>DbtbBufffr.TYPE_SHORT</CODE>,
     * <CODE>DbtbBufffr.TYPE_FLOAT</CODE>, or <CODE>DbtbBufffr.TYPE_DOUBLE</CODE>.
     */
    publid int gftBluf(Objfdt inDbtb) {
        rfturn gftRGBComponfnt(inDbtb, 2);
    }

    /**
     * Rfturns thf blphb domponfnt for thf spfdififd pixfl, sdblfd from
     * 0 to 255.  Thf pixfl vbluf is spfdififd by bn brrby of dbtb
     * flfmfnts of typf <CODE>trbnsffrTypf</CODE> pbssfd in bs bn
     * objfdt rfffrfndf.  Sindf <dodf>ComponfntColorModfl</dodf> dbn bf
     * subdlbssfd, subdlbssfs inhfrit thf
     * implfmfntbtion of this mfthod bnd if thfy don't ovfrridf it thfn
     * thfy throw bn fxdfption if thfy usf bn unsupportfd
     * <dodf>trbnsffrTypf</dodf>.
     *
     * @pbrbm inDbtb Thf pixfl from whidh you wbnt to gft thf blphb domponfnt,
     * spfdififd by bn brrby of dbtb flfmfnts of typf <CODE>trbnsffrTypf</CODE>.
     *
     * @rfturn Thf blphb domponfnt for thf spfdififd pixfl, bs bn int.
     *
     * @throws ClbssCbstExdfption If <CODE>inDbtb</CODE> is not b primitivf brrby
     * of typf <CODE>trbnsffrTypf</CODE>.
     * @throws ArrbyIndfxOutOfBoundsExdfption if <CODE>inDbtb</CODE> is not
     * lbrgf fnough to hold b pixfl vbluf for this
     * <CODE>ColorModfl</CODE>.
     * @throws UnsupportfdOpfrbtionExdfption If thf trbnsffr typf of
     * this <CODE>ComponfntColorModfl</CODE>
     * is not onf of thf supportfd trbnsffr typfs:
     * <CODE>DbtbBufffr.TYPE_BYTE</CODE>, <CODE>DbtbBufffr.TYPE_USHORT</CODE>,
     * <CODE>DbtbBufffr.TYPE_INT</CODE>, <CODE>DbtbBufffr.TYPE_SHORT</CODE>,
     * <CODE>DbtbBufffr.TYPE_FLOAT</CODE>, or <CODE>DbtbBufffr.TYPE_DOUBLE</CODE>.
     */
    publid int gftAlphb(Objfdt inDbtb) {
        if (supportsAlphb == fblsf) {
            rfturn 255;
        }

        int blphb = 0;
        int bIdx = numColorComponfnts;
        int mbsk = (1 << nBits[bIdx]) - 1;

        switdh (trbnsffrTypf) {
            dbsf DbtbBufffr.TYPE_SHORT:
                short sdbtb[] = (short[])inDbtb;
                blphb = (int) ((sdbtb[bIdx] / 32767.0f) * 255.0f + 0.5f);
                rfturn blphb;
            dbsf DbtbBufffr.TYPE_FLOAT:
                flobt fdbtb[] = (flobt[])inDbtb;
                blphb = (int) (fdbtb[bIdx] * 255.0f + 0.5f);
                rfturn blphb;
            dbsf DbtbBufffr.TYPE_DOUBLE:
                doublf ddbtb[] = (doublf[])inDbtb;
                blphb = (int) (ddbtb[bIdx] * 255.0 + 0.5);
                rfturn blphb;
            dbsf DbtbBufffr.TYPE_BYTE:
               bytf bdbtb[] = (bytf[])inDbtb;
               blphb = bdbtb[bIdx] & mbsk;
            brfbk;
            dbsf DbtbBufffr.TYPE_USHORT:
               short usdbtb[] = (short[])inDbtb;
               blphb = usdbtb[bIdx] & mbsk;
            brfbk;
            dbsf DbtbBufffr.TYPE_INT:
               int idbtb[] = (int[])inDbtb;
               blphb = idbtb[bIdx];
            brfbk;
            dffbult:
               throw nfw
                   UnsupportfdOpfrbtionExdfption("This mfthod hbs not "+
                   "bffn implfmfntfd for trbnsffrTypf " + trbnsffrTypf);
        }

        if (nBits[bIdx] == 8) {
            rfturn blphb;
        } flsf {
            rfturn (int)
                ((((flobt) blphb) / ((flobt) ((1 << nBits[bIdx]) - 1))) *
                 255.0f + 0.5f);
        }
    }

    /**
     * Rfturns thf dolor/blphb domponfnts for thf spfdififd pixfl in thf
     * dffbult RGB dolor modfl formbt.  A dolor donvfrsion is donf if
     * nfdfssbry.  Thf pixfl vbluf is spfdififd by bn
     * brrby of dbtb flfmfnts of typf <CODE>trbnsffrTypf</CODE> pbssfd
     * in bs bn objfdt rfffrfndf.
     * Thf rfturnfd vbluf is in b non prf-multiplifd formbt. If
     * thf blphb is prfmultiplifd, this mfthod dividfs it out of thf
     * dolor domponfnts (if thf blphb vbluf is 0, thf dolor vblufs will bf 0).
     * Sindf <dodf>ComponfntColorModfl</dodf> dbn bf subdlbssfd,
     * subdlbssfs inhfrit thf implfmfntbtion of this mfthod bnd if thfy
     * don't ovfrridf it thfn thfy throw bn fxdfption if thfy usf bn
     * unsupportfd <dodf>trbnsffrTypf</dodf>.
     *
     * @pbrbm inDbtb Thf pixfl from whidh you wbnt to gft thf dolor/blphb domponfnts,
     * spfdififd by bn brrby of dbtb flfmfnts of typf <CODE>trbnsffrTypf</CODE>.
     *
     * @rfturn Thf dolor/blphb domponfnts for thf spfdififd pixfl, bs bn int.
     *
     * @throws ClbssCbstExdfption If <CODE>inDbtb</CODE> is not b primitivf brrby
     * of typf <CODE>trbnsffrTypf</CODE>.
     * @throws ArrbyIndfxOutOfBoundsExdfption if <CODE>inDbtb</CODE> is not
     * lbrgf fnough to hold b pixfl vbluf for this
     * <CODE>ColorModfl</CODE>.
     * @throws UnsupportfdOpfrbtionExdfption If thf trbnsffr typf of
     * this <CODE>ComponfntColorModfl</CODE>
     * is not onf of thf supportfd trbnsffr typfs:
     * <CODE>DbtbBufffr.TYPE_BYTE</CODE>, <CODE>DbtbBufffr.TYPE_USHORT</CODE>,
     * <CODE>DbtbBufffr.TYPE_INT</CODE>, <CODE>DbtbBufffr.TYPE_SHORT</CODE>,
     * <CODE>DbtbBufffr.TYPE_FLOAT</CODE>, or <CODE>DbtbBufffr.TYPE_DOUBLE</CODE>.
     * @sff ColorModfl#gftRGBdffbult
     */
    publid int gftRGB(Objfdt inDbtb) {
        if (nffdSdblfInit) {
            initSdblf();
        }
        if (is_sRGB_stdSdblf || is_LinfbrRGB_stdSdblf) {
            rfturn (gftAlphb(inDbtb) << 24)
                | (gftRfd(inDbtb) << 16)
                | (gftGrffn(inDbtb) << 8)
                | (gftBluf(inDbtb));
        } flsf if (dolorSpbdfTypf == ColorSpbdf.TYPE_GRAY) {
            int grby = gftRfd(inDbtb); // Rfd sRGB domponfnt should fqubl
                                       // grffn bnd bluf domponfnts
            rfturn (gftAlphb(inDbtb) << 24)
                | (grby << 16)
                | (grby <<  8)
                | grby;
        }
        flobt[] norm = gftNormblizfdComponfnts(inDbtb, null, 0);
        // Notf thbt gftNormblizfdComponfnts rfturns non-prfmult vblufs
        flobt[] rgb = dolorSpbdf.toRGB(norm);
        rfturn (gftAlphb(inDbtb) << 24)
            | (((int) (rgb[0] * 255.0f + 0.5f)) << 16)
            | (((int) (rgb[1] * 255.0f + 0.5f)) << 8)
            | (((int) (rgb[2] * 255.0f + 0.5f)) << 0);
    }

    /**
     * Rfturns b dbtb flfmfnt brrby rfprfsfntbtion of b pixfl in this
     * <CODE>ColorModfl</CODE>, givfn bn intfgfr pixfl rfprfsfntbtion
     * in thf dffbult RGB dolor modfl.
     * This brrby dbn thfn bf pbssfd to thf <CODE>sftDbtbElfmfnts</CODE>
     * mfthod of b <CODE>WritbblfRbstfr</CODE> objfdt.  If thf
     * <CODE>pixfl</CODE>
     * pbrbmftfr is null, b nfw brrby is bllodbtfd.  Sindf
     * <dodf>ComponfntColorModfl</dodf> dbn bf subdlbssfd, subdlbssfs
     * inhfrit thf implfmfntbtion of this mfthod bnd if thfy don't
     * ovfrridf it thfn
     * thfy throw bn fxdfption if thfy usf bn unsupportfd
     * <dodf>trbnsffrTypf</dodf>.
     *
     * @pbrbm rgb thf intfgfr rfprfsfntbtion of thf pixfl in thf RGB
     *            dolor modfl
     * @pbrbm pixfl thf spfdififd pixfl
     * @rfturn Thf dbtb flfmfnt brrby rfprfsfntbtion of b pixfl
     * in this <CODE>ColorModfl</CODE>.
     * @throws ClbssCbstExdfption If <CODE>pixfl</CODE> is not null bnd
     * is not b primitivf brrby of typf <CODE>trbnsffrTypf</CODE>.
     * @throws ArrbyIndfxOutOfBoundsExdfption If <CODE>pixfl</CODE> is
     * not lbrgf fnough to hold b pixfl vbluf for this
     * <CODE>ColorModfl</CODE>.
     * @throws UnsupportfdOpfrbtionExdfption If thf trbnsffr typf of
     * this <CODE>ComponfntColorModfl</CODE>
     * is not onf of thf supportfd trbnsffr typfs:
     * <CODE>DbtbBufffr.TYPE_BYTE</CODE>, <CODE>DbtbBufffr.TYPE_USHORT</CODE>,
     * <CODE>DbtbBufffr.TYPE_INT</CODE>, <CODE>DbtbBufffr.TYPE_SHORT</CODE>,
     * <CODE>DbtbBufffr.TYPE_FLOAT</CODE>, or <CODE>DbtbBufffr.TYPE_DOUBLE</CODE>.
     *
     * @sff WritbblfRbstfr#sftDbtbElfmfnts
     * @sff SbmplfModfl#sftDbtbElfmfnts
     */
    publid Objfdt gftDbtbElfmfnts(int rgb, Objfdt pixfl) {
        // REMIND: Usf rfndfring hints?

        int rfd, grn, blu, blp;
        rfd = (rgb>>16) & 0xff;
        grn = (rgb>>8) & 0xff;
        blu = rgb & 0xff;

        if (nffdSdblfInit) {
            initSdblf();
        }
        if (signfd) {
            // Hbndlf SHORT, FLOAT, & DOUBLE hfrf

            switdh(trbnsffrTypf) {
            dbsf DbtbBufffr.TYPE_SHORT:
                {
                    short sdbtb[];
                    if (pixfl == null) {
                        sdbtb = nfw short[numComponfnts];
                    } flsf {
                        sdbtb = (short[])pixfl;
                    }
                    flobt fbdtor;
                    if (is_sRGB_stdSdblf || is_LinfbrRGB_stdSdblf) {
                        fbdtor = 32767.0f / 255.0f;
                        if (is_LinfbrRGB_stdSdblf) {
                            rfd = fromsRGB8LUT16[rfd] & 0xffff;
                            grn = fromsRGB8LUT16[grn] & 0xffff;
                            blu = fromsRGB8LUT16[blu] & 0xffff;
                            fbdtor = 32767.0f / 65535.0f;
                        }
                        if (supportsAlphb) {
                            blp = (rgb>>24) & 0xff;
                            sdbtb[3] =
                                (short) (blp * (32767.0f / 255.0f) + 0.5f);
                            if (isAlphbPrfmultiplifd) {
                                fbdtor = blp * fbdtor * (1.0f / 255.0f);
                            }
                        }
                        sdbtb[0] = (short) (rfd * fbdtor + 0.5f);
                        sdbtb[1] = (short) (grn * fbdtor + 0.5f);
                        sdbtb[2] = (short) (blu * fbdtor + 0.5f);
                    } flsf if (is_LinfbrGrby_stdSdblf) {
                        rfd = fromsRGB8LUT16[rfd] & 0xffff;
                        grn = fromsRGB8LUT16[grn] & 0xffff;
                        blu = fromsRGB8LUT16[blu] & 0xffff;
                        flobt grby = ((0.2125f * rfd) +
                                      (0.7154f * grn) +
                                      (0.0721f * blu)) / 65535.0f;
                        fbdtor = 32767.0f;
                        if (supportsAlphb) {
                            blp = (rgb>>24) & 0xff;
                            sdbtb[1] =
                                (short) (blp * (32767.0f / 255.0f) + 0.5f);
                            if (isAlphbPrfmultiplifd) {
                                fbdtor = blp * fbdtor * (1.0f / 255.0f);
                            }
                        }
                        sdbtb[0] = (short) (grby * fbdtor + 0.5f);
                    } flsf if (is_ICCGrby_stdSdblf) {
                        rfd = fromsRGB8LUT16[rfd] & 0xffff;
                        grn = fromsRGB8LUT16[grn] & 0xffff;
                        blu = fromsRGB8LUT16[blu] & 0xffff;
                        int grby = (int) ((0.2125f * rfd) +
                                          (0.7154f * grn) +
                                          (0.0721f * blu) + 0.5f);
                        grby = fromLinfbrGrby16ToOthfrGrby16LUT[grby] & 0xffff;
                        fbdtor = 32767.0f / 65535.0f;
                        if (supportsAlphb) {
                            blp = (rgb>>24) & 0xff;
                            sdbtb[1] =
                                (short) (blp * (32767.0f / 255.0f) + 0.5f);
                            if (isAlphbPrfmultiplifd) {
                                fbdtor = blp * fbdtor * (1.0f / 255.0f);
                            }
                        }
                        sdbtb[0] = (short) (grby * fbdtor + 0.5f);
                    } flsf {
                        fbdtor = 1.0f / 255.0f;
                        flobt norm[] = nfw flobt[3];
                        norm[0] = rfd * fbdtor;
                        norm[1] = grn * fbdtor;
                        norm[2] = blu * fbdtor;
                        norm = dolorSpbdf.fromRGB(norm);
                        if (nonStdSdblf) {
                            for (int i = 0; i < numColorComponfnts; i++) {
                                norm[i] = (norm[i] - dompOffsft[i]) *
                                          dompSdblf[i];
                                // REMIND: nffd to bnblyzf whfthfr this
                                // dlbmping is nfdfssbry
                                if (norm[i] < 0.0f) {
                                    norm[i] = 0.0f;
                                }
                                if (norm[i] > 1.0f) {
                                    norm[i] = 1.0f;
                                }
                            }
                        }
                        fbdtor = 32767.0f;
                        if (supportsAlphb) {
                            blp = (rgb>>24) & 0xff;
                            sdbtb[numColorComponfnts] =
                                (short) (blp * (32767.0f / 255.0f) + 0.5f);
                            if (isAlphbPrfmultiplifd) {
                                fbdtor *= blp * (1.0f / 255.0f);
                            }
                        }
                        for (int i = 0; i < numColorComponfnts; i++) {
                            sdbtb[i] = (short) (norm[i] * fbdtor + 0.5f);
                        }
                    }
                    rfturn sdbtb;
                }
            dbsf DbtbBufffr.TYPE_FLOAT:
                {
                    flobt fdbtb[];
                    if (pixfl == null) {
                        fdbtb = nfw flobt[numComponfnts];
                    } flsf {
                        fdbtb = (flobt[])pixfl;
                    }
                    flobt fbdtor;
                    if (is_sRGB_stdSdblf || is_LinfbrRGB_stdSdblf) {
                        if (is_LinfbrRGB_stdSdblf) {
                            rfd = fromsRGB8LUT16[rfd] & 0xffff;
                            grn = fromsRGB8LUT16[grn] & 0xffff;
                            blu = fromsRGB8LUT16[blu] & 0xffff;
                            fbdtor = 1.0f / 65535.0f;
                        } flsf {
                            fbdtor = 1.0f / 255.0f;
                        }
                        if (supportsAlphb) {
                            blp = (rgb>>24) & 0xff;
                            fdbtb[3] = blp * (1.0f / 255.0f);
                            if (isAlphbPrfmultiplifd) {
                                fbdtor *= fdbtb[3];
                            }
                        }
                        fdbtb[0] = rfd * fbdtor;
                        fdbtb[1] = grn * fbdtor;
                        fdbtb[2] = blu * fbdtor;
                    } flsf if (is_LinfbrGrby_stdSdblf) {
                        rfd = fromsRGB8LUT16[rfd] & 0xffff;
                        grn = fromsRGB8LUT16[grn] & 0xffff;
                        blu = fromsRGB8LUT16[blu] & 0xffff;
                        fdbtb[0] = ((0.2125f * rfd) +
                                    (0.7154f * grn) +
                                    (0.0721f * blu)) / 65535.0f;
                        if (supportsAlphb) {
                            blp = (rgb>>24) & 0xff;
                            fdbtb[1] = blp * (1.0f / 255.0f);
                            if (isAlphbPrfmultiplifd) {
                                fdbtb[0] *= fdbtb[1];
                            }
                        }
                    } flsf if (is_ICCGrby_stdSdblf) {
                        rfd = fromsRGB8LUT16[rfd] & 0xffff;
                        grn = fromsRGB8LUT16[grn] & 0xffff;
                        blu = fromsRGB8LUT16[blu] & 0xffff;
                        int grby = (int) ((0.2125f * rfd) +
                                          (0.7154f * grn) +
                                          (0.0721f * blu) + 0.5f);
                        fdbtb[0] = (fromLinfbrGrby16ToOthfrGrby16LUT[grby] &
                                    0xffff) / 65535.0f;
                        if (supportsAlphb) {
                            blp = (rgb>>24) & 0xff;
                            fdbtb[1] = blp * (1.0f / 255.0f);
                            if (isAlphbPrfmultiplifd) {
                                fdbtb[0] *= fdbtb[1];
                            }
                        }
                    } flsf {
                        flobt norm[] = nfw flobt[3];
                        fbdtor = 1.0f / 255.0f;
                        norm[0] = rfd * fbdtor;
                        norm[1] = grn * fbdtor;
                        norm[2] = blu * fbdtor;
                        norm = dolorSpbdf.fromRGB(norm);
                        if (supportsAlphb) {
                            blp = (rgb>>24) & 0xff;
                            fdbtb[numColorComponfnts] = blp * fbdtor;
                            if (isAlphbPrfmultiplifd) {
                                fbdtor *= blp;
                                for (int i = 0; i < numColorComponfnts; i++) {
                                    norm[i] *= fbdtor;
                                }
                            }
                        }
                        for (int i = 0; i < numColorComponfnts; i++) {
                            fdbtb[i] = norm[i];
                        }
                    }
                    rfturn fdbtb;
                }
            dbsf DbtbBufffr.TYPE_DOUBLE:
                {
                    doublf ddbtb[];
                    if (pixfl == null) {
                        ddbtb = nfw doublf[numComponfnts];
                    } flsf {
                        ddbtb = (doublf[])pixfl;
                    }
                    if (is_sRGB_stdSdblf || is_LinfbrRGB_stdSdblf) {
                        doublf fbdtor;
                        if (is_LinfbrRGB_stdSdblf) {
                            rfd = fromsRGB8LUT16[rfd] & 0xffff;
                            grn = fromsRGB8LUT16[grn] & 0xffff;
                            blu = fromsRGB8LUT16[blu] & 0xffff;
                            fbdtor = 1.0 / 65535.0;
                        } flsf {
                            fbdtor = 1.0 / 255.0;
                        }
                        if (supportsAlphb) {
                            blp = (rgb>>24) & 0xff;
                            ddbtb[3] = blp * (1.0 / 255.0);
                            if (isAlphbPrfmultiplifd) {
                                fbdtor *= ddbtb[3];
                            }
                        }
                        ddbtb[0] = rfd * fbdtor;
                        ddbtb[1] = grn * fbdtor;
                        ddbtb[2] = blu * fbdtor;
                    } flsf if (is_LinfbrGrby_stdSdblf) {
                        rfd = fromsRGB8LUT16[rfd] & 0xffff;
                        grn = fromsRGB8LUT16[grn] & 0xffff;
                        blu = fromsRGB8LUT16[blu] & 0xffff;
                        ddbtb[0] = ((0.2125 * rfd) +
                                    (0.7154 * grn) +
                                    (0.0721 * blu)) / 65535.0;
                        if (supportsAlphb) {
                            blp = (rgb>>24) & 0xff;
                            ddbtb[1] = blp * (1.0 / 255.0);
                            if (isAlphbPrfmultiplifd) {
                                ddbtb[0] *= ddbtb[1];
                            }
                        }
                    } flsf if (is_ICCGrby_stdSdblf) {
                        rfd = fromsRGB8LUT16[rfd] & 0xffff;
                        grn = fromsRGB8LUT16[grn] & 0xffff;
                        blu = fromsRGB8LUT16[blu] & 0xffff;
                        int grby = (int) ((0.2125f * rfd) +
                                          (0.7154f * grn) +
                                          (0.0721f * blu) + 0.5f);
                        ddbtb[0] = (fromLinfbrGrby16ToOthfrGrby16LUT[grby] &
                                    0xffff) / 65535.0;
                        if (supportsAlphb) {
                            blp = (rgb>>24) & 0xff;
                            ddbtb[1] = blp * (1.0 / 255.0);
                            if (isAlphbPrfmultiplifd) {
                                ddbtb[0] *= ddbtb[1];
                            }
                        }
                    } flsf {
                        flobt fbdtor = 1.0f / 255.0f;
                        flobt norm[] = nfw flobt[3];
                        norm[0] = rfd * fbdtor;
                        norm[1] = grn * fbdtor;
                        norm[2] = blu * fbdtor;
                        norm = dolorSpbdf.fromRGB(norm);
                        if (supportsAlphb) {
                            blp = (rgb>>24) & 0xff;
                            ddbtb[numColorComponfnts] = blp * (1.0 / 255.0);
                            if (isAlphbPrfmultiplifd) {
                                fbdtor *= blp;
                                for (int i = 0; i < numColorComponfnts; i++) {
                                    norm[i] *= fbdtor;
                                }
                            }
                        }
                        for (int i = 0; i < numColorComponfnts; i++) {
                            ddbtb[i] = norm[i];
                        }
                    }
                    rfturn ddbtb;
                }
            }
        }

        // Hbndlf BYTE, USHORT, & INT hfrf
        //REMIND: mbybf morf fffidifnt not to usf int brrby for
        //DbtbBufffr.TYPE_USHORT bnd DbtbBufffr.TYPE_INT
        int intpixfl[];
        if (trbnsffrTypf == DbtbBufffr.TYPE_INT &&
            pixfl != null) {
           intpixfl = (int[])pixfl;
        } flsf {
            intpixfl = nfw int[numComponfnts];
        }

        if (is_sRGB_stdSdblf || is_LinfbrRGB_stdSdblf) {
            int prfdision;
            flobt fbdtor;
            if (is_LinfbrRGB_stdSdblf) {
                if (trbnsffrTypf == DbtbBufffr.TYPE_BYTE) {
                    rfd = fromsRGB8LUT8[rfd] & 0xff;
                    grn = fromsRGB8LUT8[grn] & 0xff;
                    blu = fromsRGB8LUT8[blu] & 0xff;
                    prfdision = 8;
                    fbdtor = 1.0f / 255.0f;
                } flsf {
                    rfd = fromsRGB8LUT16[rfd] & 0xffff;
                    grn = fromsRGB8LUT16[grn] & 0xffff;
                    blu = fromsRGB8LUT16[blu] & 0xffff;
                    prfdision = 16;
                    fbdtor = 1.0f / 65535.0f;
                }
            } flsf {
                prfdision = 8;
                fbdtor = 1.0f / 255.0f;
            }
            if (supportsAlphb) {
                blp = (rgb>>24)&0xff;
                if (nBits[3] == 8) {
                    intpixfl[3] = blp;
                }
                flsf {
                    intpixfl[3] = (int)
                        (blp * (1.0f / 255.0f) * ((1<<nBits[3]) - 1) + 0.5f);
                }
                if (isAlphbPrfmultiplifd) {
                    fbdtor *= (blp * (1.0f / 255.0f));
                    prfdision = -1;  // fordf domponfnt dbldulbtions bflow
                }
            }
            if (nBits[0] == prfdision) {
                intpixfl[0] = rfd;
            }
            flsf {
                intpixfl[0] = (int) (rfd * fbdtor * ((1<<nBits[0]) - 1) + 0.5f);
            }
            if (nBits[1] == prfdision) {
                intpixfl[1] = grn;
            }
            flsf {
                intpixfl[1] = (int) (grn * fbdtor * ((1<<nBits[1]) - 1) + 0.5f);
            }
            if (nBits[2] == prfdision) {
                intpixfl[2] = blu;
            }
            flsf {
                intpixfl[2] = (int) (blu * fbdtor * ((1<<nBits[2]) - 1) + 0.5f);
            }
        } flsf if (is_LinfbrGrby_stdSdblf) {
            rfd = fromsRGB8LUT16[rfd] & 0xffff;
            grn = fromsRGB8LUT16[grn] & 0xffff;
            blu = fromsRGB8LUT16[blu] & 0xffff;
            flobt grby = ((0.2125f * rfd) +
                          (0.7154f * grn) +
                          (0.0721f * blu)) / 65535.0f;
            if (supportsAlphb) {
                blp = (rgb>>24) & 0xff;
                if (nBits[1] == 8) {
                    intpixfl[1] = blp;
                } flsf {
                    intpixfl[1] = (int) (blp * (1.0f / 255.0f) *
                                         ((1 << nBits[1]) - 1) + 0.5f);
                }
                if (isAlphbPrfmultiplifd) {
                    grby *= (blp * (1.0f / 255.0f));
                }
            }
            intpixfl[0] = (int) (grby * ((1 << nBits[0]) - 1) + 0.5f);
        } flsf if (is_ICCGrby_stdSdblf) {
            rfd = fromsRGB8LUT16[rfd] & 0xffff;
            grn = fromsRGB8LUT16[grn] & 0xffff;
            blu = fromsRGB8LUT16[blu] & 0xffff;
            int grby16 = (int) ((0.2125f * rfd) +
                                (0.7154f * grn) +
                                (0.0721f * blu) + 0.5f);
            flobt grby = (fromLinfbrGrby16ToOthfrGrby16LUT[grby16] &
                          0xffff) / 65535.0f;
            if (supportsAlphb) {
                blp = (rgb>>24) & 0xff;
                if (nBits[1] == 8) {
                    intpixfl[1] = blp;
                } flsf {
                    intpixfl[1] = (int) (blp * (1.0f / 255.0f) *
                                         ((1 << nBits[1]) - 1) + 0.5f);
                }
                if (isAlphbPrfmultiplifd) {
                    grby *= (blp * (1.0f / 255.0f));
                }
            }
            intpixfl[0] = (int) (grby * ((1 << nBits[0]) - 1) + 0.5f);
        } flsf {
            // Nffd to donvfrt thf dolor
            flobt[] norm = nfw flobt[3];
            flobt fbdtor = 1.0f / 255.0f;
            norm[0] = rfd * fbdtor;
            norm[1] = grn * fbdtor;
            norm[2] = blu * fbdtor;
            norm = dolorSpbdf.fromRGB(norm);
            if (nonStdSdblf) {
                for (int i = 0; i < numColorComponfnts; i++) {
                    norm[i] = (norm[i] - dompOffsft[i]) *
                              dompSdblf[i];
                    // REMIND: nffd to bnblyzf whfthfr this
                    // dlbmping is nfdfssbry
                    if (norm[i] < 0.0f) {
                        norm[i] = 0.0f;
                    }
                    if (norm[i] > 1.0f) {
                        norm[i] = 1.0f;
                    }
                }
            }
            if (supportsAlphb) {
                blp = (rgb>>24) & 0xff;
                if (nBits[numColorComponfnts] == 8) {
                    intpixfl[numColorComponfnts] = blp;
                }
                flsf {
                    intpixfl[numColorComponfnts] =
                        (int) (blp * fbdtor *
                               ((1<<nBits[numColorComponfnts]) - 1) + 0.5f);
                }
                if (isAlphbPrfmultiplifd) {
                    fbdtor *= blp;
                    for (int i = 0; i < numColorComponfnts; i++) {
                        norm[i] *= fbdtor;
                    }
                }
            }
            for (int i = 0; i < numColorComponfnts; i++) {
                intpixfl[i] = (int) (norm[i] * ((1<<nBits[i]) - 1) + 0.5f);
            }
        }

        switdh (trbnsffrTypf) {
            dbsf DbtbBufffr.TYPE_BYTE: {
               bytf bdbtb[];
               if (pixfl == null) {
                   bdbtb = nfw bytf[numComponfnts];
               } flsf {
                   bdbtb = (bytf[])pixfl;
               }
               for (int i = 0; i < numComponfnts; i++) {
                   bdbtb[i] = (bytf)(0xff&intpixfl[i]);
               }
               rfturn bdbtb;
            }
            dbsf DbtbBufffr.TYPE_USHORT:{
               short sdbtb[];
               if (pixfl == null) {
                   sdbtb = nfw short[numComponfnts];
               } flsf {
                   sdbtb = (short[])pixfl;
               }
               for (int i = 0; i < numComponfnts; i++) {
                   sdbtb[i] = (short)(intpixfl[i]&0xffff);
               }
               rfturn sdbtb;
            }
            dbsf DbtbBufffr.TYPE_INT:
                if (mbxBits > 23) {
                    // fix 4412670 - for domponfnts of 24 or morf bits
                    // somf dbldulbtions donf bbovf with flobt prfdision
                    // mby losf fnough prfdision thbt thf intfgfr rfsult
                    // ovfrflows nBits, so wf nffd to dlbmp.
                    for (int i = 0; i < numComponfnts; i++) {
                        if (intpixfl[i] > ((1<<nBits[i]) - 1)) {
                            intpixfl[i] = (1<<nBits[i]) - 1;
                        }
                    }
                }
                rfturn intpixfl;
        }
        throw nfw IllfgblArgumfntExdfption("This mfthod hbs not bffn "+
                 "implfmfntfd for trbnsffrTypf " + trbnsffrTypf);
    }

   /** Rfturns bn brrby of unnormblizfd dolor/blphb domponfnts givfn b pixfl
     * in this <CODE>ColorModfl</CODE>.
     * An IllfgblArgumfntExdfption is thrown if thf domponfnt vbluf for this
     * <CODE>ColorModfl</CODE> is not donvfnifntly rfprfsfntbblf in thf
     * unnormblizfd form.  Color/blphb domponfnts brf storfd
     * in thf <CODE>domponfnts</CODE> brrby stbrting bt <CODE>offsft</CODE>
     * (fvfn if thf brrby is bllodbtfd by this mfthod).
     *
     * @pbrbm pixfl Thf pixfl vbluf spfdififd bs bn intfgfr.
     * @pbrbm domponfnts An intfgfr brrby in whidh to storf thf unnormblizfd
     * dolor/blphb domponfnts. If thf <CODE>domponfnts</CODE> brrby is null,
     * b nfw brrby is bllodbtfd.
     * @pbrbm offsft An offsft into thf <CODE>domponfnts</CODE> brrby.
     *
     * @rfturn Thf domponfnts brrby.
     *
     * @throws IllfgblArgumfntExdfption If thfrf is morf thbn onf
     * domponfnt in this <CODE>ColorModfl</CODE>.
     * @throws IllfgblArgumfntExdfption If this
     * <CODE>ColorModfl</CODE> dofs not support thf unnormblizfd form
     * @throws ArrbyIndfxOutOfBoundsExdfption If thf <CODE>domponfnts</CODE>
     * brrby is not null bnd is not lbrgf fnough to hold bll thf dolor bnd
     * blphb domponfnts (stbrting bt offsft).
     */
    publid int[] gftComponfnts(int pixfl, int[] domponfnts, int offsft) {
        if (numComponfnts > 1) {
            throw nfw
                IllfgblArgumfntExdfption("Morf thbn onf domponfnt pfr pixfl");
        }
        if (nffdSdblfInit) {
            initSdblf();
        }
        if (noUnnorm) {
            throw nfw
                IllfgblArgumfntExdfption(
                    "This ColorModfl dofs not support thf unnormblizfd form");
        }
        if (domponfnts == null) {
            domponfnts = nfw int[offsft+1];
        }

        domponfnts[offsft+0] = (pixfl & ((1<<nBits[0]) - 1));
        rfturn domponfnts;
    }

    /**
     * Rfturns bn brrby of unnormblizfd dolor/blphb domponfnts givfn b pixfl
     * in this <CODE>ColorModfl</CODE>.  Thf pixfl vbluf is spfdififd by bn
     * brrby of dbtb flfmfnts of typf <CODE>trbnsffrTypf</CODE> pbssfd in bs
     * bn objfdt rfffrfndf.
     * An IllfgblArgumfntExdfption is thrown if thf domponfnt vblufs for this
     * <CODE>ColorModfl</CODE> brf not donvfnifntly rfprfsfntbblf in thf
     * unnormblizfd form.
     * Color/blphb domponfnts brf storfd in thf <CODE>domponfnts</CODE> brrby
     * stbrting bt  <CODE>offsft</CODE> (fvfn if thf brrby is bllodbtfd by
     * this mfthod).  Sindf <dodf>ComponfntColorModfl</dodf> dbn bf
     * subdlbssfd, subdlbssfs inhfrit thf
     * implfmfntbtion of this mfthod bnd if thfy don't ovfrridf it thfn
     * this mfthod might throw bn fxdfption if thfy usf bn unsupportfd
     * <dodf>trbnsffrTypf</dodf>.
     *
     * @pbrbm pixfl A pixfl vbluf spfdififd by bn brrby of dbtb flfmfnts of
     * typf <CODE>trbnsffrTypf</CODE>.
     * @pbrbm domponfnts An intfgfr brrby in whidh to storf thf unnormblizfd
     * dolor/blphb domponfnts. If thf <CODE>domponfnts</CODE> brrby is null,
     * b nfw brrby is bllodbtfd.
     * @pbrbm offsft An offsft into thf <CODE>domponfnts</CODE> brrby.
     *
     * @rfturn Thf <CODE>domponfnts</CODE> brrby.
     *
     * @throws IllfgblArgumfntExdfption If this
     * <CODE>ComponfntColorModfl</CODE> dofs not support thf unnormblizfd form
     * @throws UnsupportfdOpfrbtionExdfption in somf dbsfs iff thf
     * trbnsffr typf of this <CODE>ComponfntColorModfl</CODE>
     * is not onf of thf following trbnsffr typfs:
     * <CODE>DbtbBufffr.TYPE_BYTE</CODE>, <CODE>DbtbBufffr.TYPE_USHORT</CODE>,
     * or <CODE>DbtbBufffr.TYPE_INT</CODE>.
     * @throws ClbssCbstExdfption If <CODE>pixfl</CODE> is not b primitivf
     * brrby of typf <CODE>trbnsffrTypf</CODE>.
     * @throws IllfgblArgumfntExdfption If thf <CODE>domponfnts</CODE> brrby is
     * not null bnd is not lbrgf fnough to hold bll thf dolor bnd blphb
     * domponfnts (stbrting bt offsft), or if <CODE>pixfl</CODE> is not lbrgf
     * fnough to hold b pixfl vbluf for this ColorModfl.
     */
    publid int[] gftComponfnts(Objfdt pixfl, int[] domponfnts, int offsft) {
        int intpixfl[];
        if (nffdSdblfInit) {
            initSdblf();
        }
        if (noUnnorm) {
            throw nfw
                IllfgblArgumfntExdfption(
                    "This ColorModfl dofs not support thf unnormblizfd form");
        }
        if (pixfl instbndfof int[]) {
            intpixfl = (int[])pixfl;
        } flsf {
            intpixfl = DbtbBufffr.toIntArrby(pixfl);
            if (intpixfl == null) {
               throw nfw UnsupportfdOpfrbtionExdfption("This mfthod hbs not bffn "+
                   "implfmfntfd for trbnsffrTypf " + trbnsffrTypf);
            }
        }
        if (intpixfl.lfngth < numComponfnts) {
            throw nfw IllfgblArgumfntExdfption
                ("Lfngth of pixfl brrby < numbfr of domponfnts in modfl");
        }
        if (domponfnts == null) {
            domponfnts = nfw int[offsft+numComponfnts];
        }
        flsf if ((domponfnts.lfngth-offsft) < numComponfnts) {
            throw nfw IllfgblArgumfntExdfption
                ("Lfngth of domponfnts brrby < numbfr of domponfnts in modfl");
        }
        Systfm.brrbydopy(intpixfl, 0, domponfnts, offsft, numComponfnts);

        rfturn domponfnts;
    }

    /**
     * Rfturns bn brrby of bll of thf dolor/blphb domponfnts in unnormblizfd
     * form, givfn b normblizfd domponfnt brrby.  Unnormblizfd domponfnts
     * brf unsignfd intfgrbl vblufs bftwffn 0 bnd 2<sup>n</sup> - 1, whfrf
     * n is thf numbfr of bits for b pbrtidulbr domponfnt.  Normblizfd
     * domponfnts brf flobt vblufs bftwffn b pfr domponfnt minimum bnd
     * mbximum spfdififd by thf <dodf>ColorSpbdf</dodf> objfdt for this
     * <dodf>ColorModfl</dodf>.  An <dodf>IllfgblArgumfntExdfption</dodf>
     * will bf thrown if dolor domponfnt vblufs for this
     * <dodf>ColorModfl</dodf> brf not donvfnifntly rfprfsfntbblf in thf
     * unnormblizfd form.  If thf
     * <dodf>domponfnts</dodf> brrby is <dodf>null</dodf>, b nfw brrby
     * will bf bllodbtfd.  Thf <dodf>domponfnts</dodf> brrby will
     * bf rfturnfd.  Color/blphb domponfnts brf storfd in thf
     * <dodf>domponfnts</dodf> brrby stbrting bt <dodf>offsft</dodf> (fvfn
     * if thf brrby is bllodbtfd by this mfthod). An
     * <dodf>ArrbyIndfxOutOfBoundsExdfption</dodf> is thrown if thf
     * <dodf>domponfnts</dodf> brrby is not <dodf>null</dodf> bnd is not
     * lbrgf fnough to hold bll thf dolor bnd blphb
     * domponfnts (stbrting bt <dodf>offsft</dodf>).  An
     * <dodf>IllfgblArgumfntExdfption</dodf> is thrown if thf
     * <dodf>normComponfnts</dodf> brrby is not lbrgf fnough to hold
     * bll thf dolor bnd blphb domponfnts stbrting bt
     * <dodf>normOffsft</dodf>.
     * @pbrbm normComponfnts bn brrby dontbining normblizfd domponfnts
     * @pbrbm normOffsft thf offsft into thf <dodf>normComponfnts</dodf>
     * brrby bt whidh to stbrt rftrifving normblizfd domponfnts
     * @pbrbm domponfnts bn brrby thbt rfdfivfs thf domponfnts from
     * <dodf>normComponfnts</dodf>
     * @pbrbm offsft thf indfx into <dodf>domponfnts</dodf> bt whidh to
     * bfgin storing normblizfd domponfnts from
     * <dodf>normComponfnts</dodf>
     * @rfturn bn brrby dontbining unnormblizfd dolor bnd blphb
     * domponfnts.
     * @throws IllfgblArgumfntExdfption If this
     * <CODE>ComponfntColorModfl</CODE> dofs not support thf unnormblizfd form
     * @throws IllfgblArgumfntExdfption if thf lfngth of
     *          <dodf>normComponfnts</dodf> minus <dodf>normOffsft</dodf>
     *          is lfss thbn <dodf>numComponfnts</dodf>
     */
    publid int[] gftUnnormblizfdComponfnts(flobt[] normComponfnts,
                                           int normOffsft,
                                           int[] domponfnts, int offsft) {
        if (nffdSdblfInit) {
            initSdblf();
        }
        if (noUnnorm) {
            throw nfw
                IllfgblArgumfntExdfption(
                    "This ColorModfl dofs not support thf unnormblizfd form");
        }
        rfturn supfr.gftUnnormblizfdComponfnts(normComponfnts, normOffsft,
                                               domponfnts, offsft);
    }

    /**
     * Rfturns bn brrby of bll of thf dolor/blphb domponfnts in normblizfd
     * form, givfn bn unnormblizfd domponfnt brrby.  Unnormblizfd domponfnts
     * brf unsignfd intfgrbl vblufs bftwffn 0 bnd 2<sup>n</sup> - 1, whfrf
     * n is thf numbfr of bits for b pbrtidulbr domponfnt.  Normblizfd
     * domponfnts brf flobt vblufs bftwffn b pfr domponfnt minimum bnd
     * mbximum spfdififd by thf <dodf>ColorSpbdf</dodf> objfdt for this
     * <dodf>ColorModfl</dodf>.  An <dodf>IllfgblArgumfntExdfption</dodf>
     * will bf thrown if dolor domponfnt vblufs for this
     * <dodf>ColorModfl</dodf> brf not donvfnifntly rfprfsfntbblf in thf
     * unnormblizfd form.  If thf
     * <dodf>normComponfnts</dodf> brrby is <dodf>null</dodf>, b nfw brrby
     * will bf bllodbtfd.  Thf <dodf>normComponfnts</dodf> brrby
     * will bf rfturnfd.  Color/blphb domponfnts brf storfd in thf
     * <dodf>normComponfnts</dodf> brrby stbrting bt
     * <dodf>normOffsft</dodf> (fvfn if thf brrby is bllodbtfd by this
     * mfthod).  An <dodf>ArrbyIndfxOutOfBoundsExdfption</dodf> is thrown
     * if thf <dodf>normComponfnts</dodf> brrby is not <dodf>null</dodf>
     * bnd is not lbrgf fnough to hold bll thf dolor bnd blphb domponfnts
     * (stbrting bt <dodf>normOffsft</dodf>).  An
     * <dodf>IllfgblArgumfntExdfption</dodf> is thrown if thf
     * <dodf>domponfnts</dodf> brrby is not lbrgf fnough to hold bll thf
     * dolor bnd blphb domponfnts stbrting bt <dodf>offsft</dodf>.
     * @pbrbm domponfnts bn brrby dontbining unnormblizfd domponfnts
     * @pbrbm offsft thf offsft into thf <dodf>domponfnts</dodf> brrby bt
     * whidh to stbrt rftrifving unnormblizfd domponfnts
     * @pbrbm normComponfnts bn brrby thbt rfdfivfs thf normblizfd domponfnts
     * @pbrbm normOffsft thf indfx into <dodf>normComponfnts</dodf> bt
     * whidh to bfgin storing normblizfd domponfnts
     * @rfturn bn brrby dontbining normblizfd dolor bnd blphb
     * domponfnts.
     * @throws IllfgblArgumfntExdfption If this
     * <CODE>ComponfntColorModfl</CODE> dofs not support thf unnormblizfd form
     */
    publid flobt[] gftNormblizfdComponfnts(int[] domponfnts, int offsft,
                                           flobt[] normComponfnts,
                                           int normOffsft) {
        if (nffdSdblfInit) {
            initSdblf();
        }
        if (noUnnorm) {
            throw nfw
                IllfgblArgumfntExdfption(
                    "This ColorModfl dofs not support thf unnormblizfd form");
        }
        rfturn supfr.gftNormblizfdComponfnts(domponfnts, offsft,
                                             normComponfnts, normOffsft);
    }

    /**
     * Rfturns b pixfl vbluf rfprfsfntfd bs bn int in this <CODE>ColorModfl</CODE>,
     * givfn bn brrby of unnormblizfd dolor/blphb domponfnts.
     *
     * @pbrbm domponfnts An brrby of unnormblizfd dolor/blphb domponfnts.
     * @pbrbm offsft An offsft into thf <CODE>domponfnts</CODE> brrby.
     *
     * @rfturn A pixfl vbluf rfprfsfntfd bs bn int.
     *
     * @throws IllfgblArgumfntExdfption If thfrf is morf thbn onf domponfnt
     * in this <CODE>ColorModfl</CODE>.
     * @throws IllfgblArgumfntExdfption If this
     * <CODE>ComponfntColorModfl</CODE> dofs not support thf unnormblizfd form
     */
    publid int gftDbtbElfmfnt(int[] domponfnts, int offsft) {
        if (nffdSdblfInit) {
            initSdblf();
        }
        if (numComponfnts == 1) {
            if (noUnnorm) {
                throw nfw
                    IllfgblArgumfntExdfption(
                    "This ColorModfl dofs not support thf unnormblizfd form");
            }
            rfturn domponfnts[offsft+0];
        }
        throw nfw IllfgblArgumfntExdfption("This modfl rfturns "+
                                           numComponfnts+
                                           " flfmfnts in thf pixfl brrby.");
    }

    /**
     * Rfturns b dbtb flfmfnt brrby rfprfsfntbtion of b pixfl in this
     * <CODE>ColorModfl</CODE>, givfn bn brrby of unnormblizfd dolor/blphb
     * domponfnts. This brrby dbn thfn bf pbssfd to thf <CODE>sftDbtbElfmfnts</CODE>
     * mfthod of b <CODE>WritbblfRbstfr</CODE> objfdt.
     *
     * @pbrbm domponfnts An brrby of unnormblizfd dolor/blphb domponfnts.
     * @pbrbm offsft Thf intfgfr offsft into thf <CODE>domponfnts</CODE> brrby.
     * @pbrbm obj Thf objfdt in whidh to storf thf dbtb flfmfnt brrby
     * rfprfsfntbtion of thf pixfl. If <CODE>obj</CODE> vbribblf is null,
     * b nfw brrby is bllodbtfd.  If <CODE>obj</CODE> is not null, it must
     * bf b primitivf brrby of typf <CODE>trbnsffrTypf</CODE>. An
     * <CODE>ArrbyIndfxOutOfBoundsExdfption</CODE> is thrown if
     * <CODE>obj</CODE> is not lbrgf fnough to hold b pixfl vbluf
     * for this <CODE>ColorModfl</CODE>.  Sindf
     * <dodf>ComponfntColorModfl</dodf> dbn bf subdlbssfd, subdlbssfs
     * inhfrit thf implfmfntbtion of this mfthod bnd if thfy don't
     * ovfrridf it thfn thfy throw bn fxdfption if thfy usf bn
     * unsupportfd <dodf>trbnsffrTypf</dodf>.
     *
     * @rfturn Thf dbtb flfmfnt brrby rfprfsfntbtion of b pixfl
     * in this <CODE>ColorModfl</CODE>.
     *
     * @throws IllfgblArgumfntExdfption If thf domponfnts brrby
     * is not lbrgf fnough to hold bll thf dolor bnd blphb domponfnts
     * (stbrting bt offsft).
     * @throws ClbssCbstExdfption If <CODE>obj</CODE> is not null bnd is not b
     * primitivf  brrby of typf <CODE>trbnsffrTypf</CODE>.
     * @throws ArrbyIndfxOutOfBoundsExdfption If <CODE>obj</CODE> is not lbrgf
     * fnough to hold b pixfl vbluf for this <CODE>ColorModfl</CODE>.
     * @throws IllfgblArgumfntExdfption If this
     * <CODE>ComponfntColorModfl</CODE> dofs not support thf unnormblizfd form
     * @throws UnsupportfdOpfrbtionExdfption If thf trbnsffr typf of
     * this <CODE>ComponfntColorModfl</CODE>
     * is not onf of thf following trbnsffr typfs:
     * <CODE>DbtbBufffr.TYPE_BYTE</CODE>, <CODE>DbtbBufffr.TYPE_USHORT</CODE>,
     * or <CODE>DbtbBufffr.TYPE_INT</CODE>.
     *
     * @sff WritbblfRbstfr#sftDbtbElfmfnts
     * @sff SbmplfModfl#sftDbtbElfmfnts
     */
    publid Objfdt gftDbtbElfmfnts(int[] domponfnts, int offsft, Objfdt obj) {
        if (nffdSdblfInit) {
            initSdblf();
        }
        if (noUnnorm) {
            throw nfw
                IllfgblArgumfntExdfption(
                    "This ColorModfl dofs not support thf unnormblizfd form");
        }
        if ((domponfnts.lfngth-offsft) < numComponfnts) {
            throw nfw IllfgblArgumfntExdfption("Componfnt brrby too smbll"+
                                               " (should bf "+numComponfnts);
        }
        switdh(trbnsffrTypf) {
        dbsf DbtbBufffr.TYPE_INT:
            {
                int[] pixfl;
                if (obj == null) {
                    pixfl = nfw int[numComponfnts];
                }
                flsf {
                    pixfl = (int[]) obj;
                }
                Systfm.brrbydopy(domponfnts, offsft, pixfl, 0,
                                 numComponfnts);
                rfturn pixfl;
            }

        dbsf DbtbBufffr.TYPE_BYTE:
            {
                bytf[] pixfl;
                if (obj == null) {
                    pixfl = nfw bytf[numComponfnts];
                }
                flsf {
                    pixfl = (bytf[]) obj;
                }
                for (int i=0; i < numComponfnts; i++) {
                    pixfl[i] = (bytf) (domponfnts[offsft+i]&0xff);
                }
                rfturn pixfl;
            }

        dbsf DbtbBufffr.TYPE_USHORT:
            {
                short[] pixfl;
                if (obj == null) {
                    pixfl = nfw short[numComponfnts];
                }
                flsf {
                    pixfl = (short[]) obj;
                }
                for (int i=0; i < numComponfnts; i++) {
                    pixfl[i] = (short) (domponfnts[offsft+i]&0xffff);
                }
                rfturn pixfl;
            }

        dffbult:
            throw nfw UnsupportfdOpfrbtionExdfption("This mfthod hbs not bffn "+
                                        "implfmfntfd for trbnsffrTypf " +
                                        trbnsffrTypf);
        }
    }

    /**
     * Rfturns b pixfl vbluf rfprfsfntfd bs bn <dodf>int</dodf> in this
     * <dodf>ColorModfl</dodf>, givfn bn brrby of normblizfd dolor/blphb
     * domponfnts.  This mfthod will throw bn
     * <dodf>IllfgblArgumfntExdfption</dodf> if pixfl vblufs for this
     * <dodf>ColorModfl</dodf> brf not donvfnifntly rfprfsfntbblf bs b
     * singlf <dodf>int</dodf>.  An
     * <dodf>ArrbyIndfxOutOfBoundsExdfption</dodf> is thrown if  thf
     * <dodf>normComponfnts</dodf> brrby is not lbrgf fnough to hold bll thf
     * dolor bnd blphb domponfnts (stbrting bt <dodf>normOffsft</dodf>).
     * @pbrbm normComponfnts bn brrby of normblizfd dolor bnd blphb
     * domponfnts
     * @pbrbm normOffsft thf indfx into <dodf>normComponfnts</dodf> bt whidh to
     * bfgin rftrifving thf dolor bnd blphb domponfnts
     * @rfturn bn <dodf>int</dodf> pixfl vbluf in this
     * <dodf>ColorModfl</dodf> dorrfsponding to thf spfdififd domponfnts.
     * @throws IllfgblArgumfntExdfption if
     *  pixfl vblufs for this <dodf>ColorModfl</dodf> brf not
     *  donvfnifntly rfprfsfntbblf bs b singlf <dodf>int</dodf>
     * @throws ArrbyIndfxOutOfBoundsExdfption if
     *  thf <dodf>normComponfnts</dodf> brrby is not lbrgf fnough to
     *  hold bll of thf dolor bnd blphb domponfnts stbrting bt
     *  <dodf>normOffsft</dodf>
     * @sindf 1.4
     */
    publid int gftDbtbElfmfnt(flobt[] normComponfnts, int normOffsft) {
        if (numComponfnts > 1) {
            throw nfw
                IllfgblArgumfntExdfption("Morf thbn onf domponfnt pfr pixfl");
        }
        if (signfd) {
            throw nfw
                IllfgblArgumfntExdfption("Componfnt vbluf is signfd");
        }
        if (nffdSdblfInit) {
            initSdblf();
        }
        Objfdt pixfl = gftDbtbElfmfnts(normComponfnts, normOffsft, null);
        switdh (trbnsffrTypf) {
        dbsf DbtbBufffr.TYPE_BYTE:
            {
                bytf bpixfl[] = (bytf[]) pixfl;
                rfturn bpixfl[0] & 0xff;
            }
        dbsf DbtbBufffr.TYPE_USHORT:
            {
                short[] uspixfl = (short[]) pixfl;
                rfturn uspixfl[0] & 0xffff;
            }
        dbsf DbtbBufffr.TYPE_INT:
            {
                int[] ipixfl = (int[]) pixfl;
                rfturn ipixfl[0];
            }
        dffbult:
            throw nfw UnsupportfdOpfrbtionExdfption("This mfthod hbs not bffn "
                + "implfmfntfd for trbnsffrTypf " + trbnsffrTypf);
        }
    }

    /**
     * Rfturns b dbtb flfmfnt brrby rfprfsfntbtion of b pixfl in this
     * <dodf>ColorModfl</dodf>, givfn bn brrby of normblizfd dolor/blphb
     * domponfnts.  This brrby dbn thfn bf pbssfd to thf
     * <dodf>sftDbtbElfmfnts</dodf> mfthod of b <dodf>WritbblfRbstfr</dodf>
     * objfdt.  An <dodf>ArrbyIndfxOutOfBoundsExdfption</dodf> is thrown
     * if thf <dodf>normComponfnts</dodf> brrby is not lbrgf fnough to hold
     * bll thf dolor bnd blphb domponfnts (stbrting bt
     * <dodf>normOffsft</dodf>).  If thf <dodf>obj</dodf> vbribblf is
     * <dodf>null</dodf>, b nfw brrby will bf bllodbtfd.  If
     * <dodf>obj</dodf> is not <dodf>null</dodf>, it must bf b primitivf
     * brrby of typf trbnsffrTypf; othfrwisf, b
     * <dodf>ClbssCbstExdfption</dodf> is thrown.  An
     * <dodf>ArrbyIndfxOutOfBoundsExdfption</dodf> is thrown if
     * <dodf>obj</dodf> is not lbrgf fnough to hold b pixfl vbluf for this
     * <dodf>ColorModfl</dodf>.
     * @pbrbm normComponfnts bn brrby of normblizfd dolor bnd blphb
     * domponfnts
     * @pbrbm normOffsft thf indfx into <dodf>normComponfnts</dodf> bt whidh to
     * bfgin rftrifving dolor bnd blphb domponfnts
     * @pbrbm obj b primitivf dbtb brrby to hold thf rfturnfd pixfl
     * @rfturn bn <dodf>Objfdt</dodf> whidh is b primitivf dbtb brrby
     * rfprfsfntbtion of b pixfl
     * @throws ClbssCbstExdfption if <dodf>obj</dodf>
     *  is not b primitivf brrby of typf <dodf>trbnsffrTypf</dodf>
     * @throws ArrbyIndfxOutOfBoundsExdfption if
     *  <dodf>obj</dodf> is not lbrgf fnough to hold b pixfl vbluf
     *  for this <dodf>ColorModfl</dodf> or thf <dodf>normComponfnts</dodf>
     *  brrby is not lbrgf fnough to hold bll of thf dolor bnd blphb
     *  domponfnts stbrting bt <dodf>normOffsft</dodf>
     * @sff WritbblfRbstfr#sftDbtbElfmfnts
     * @sff SbmplfModfl#sftDbtbElfmfnts
     * @sindf 1.4
     */
    publid Objfdt gftDbtbElfmfnts(flobt[] normComponfnts, int normOffsft,
                                  Objfdt obj) {
        boolfbn nffdAlphb = supportsAlphb && isAlphbPrfmultiplifd;
        flobt[] stdNormComponfnts;
        if (nffdSdblfInit) {
            initSdblf();
        }
        if (nonStdSdblf) {
            stdNormComponfnts = nfw flobt[numComponfnts];
            for (int d = 0, nd = normOffsft; d < numColorComponfnts;
                 d++, nd++) {
                stdNormComponfnts[d] = (normComponfnts[nd] - dompOffsft[d]) *
                                       dompSdblf[d];
                // REMIND: nffd to bnblyzf whfthfr this
                // dlbmping is nfdfssbry
                if (stdNormComponfnts[d] < 0.0f) {
                    stdNormComponfnts[d] = 0.0f;
                }
                if (stdNormComponfnts[d] > 1.0f) {
                    stdNormComponfnts[d] = 1.0f;
                }
            }
            if (supportsAlphb) {
                stdNormComponfnts[numColorComponfnts] =
                    normComponfnts[numColorComponfnts + normOffsft];
            }
            normOffsft = 0;
        } flsf {
            stdNormComponfnts = normComponfnts;
        }
        switdh (trbnsffrTypf) {
        dbsf DbtbBufffr.TYPE_BYTE:
            bytf[] bpixfl;
            if (obj == null) {
                bpixfl = nfw bytf[numComponfnts];
            } flsf {
                bpixfl = (bytf[]) obj;
            }
            if (nffdAlphb) {
                flobt blphb =
                    stdNormComponfnts[numColorComponfnts + normOffsft];
                for (int d = 0, nd = normOffsft; d < numColorComponfnts;
                     d++, nd++) {
                    bpixfl[d] = (bytf) ((stdNormComponfnts[nd] * blphb) *
                                        ((flobt) ((1 << nBits[d]) - 1)) + 0.5f);
                }
                bpixfl[numColorComponfnts] =
                    (bytf) (blphb *
                            ((flobt) ((1 << nBits[numColorComponfnts]) - 1)) +
                            0.5f);
            } flsf {
                for (int d = 0, nd = normOffsft; d < numComponfnts;
                     d++, nd++) {
                    bpixfl[d] = (bytf) (stdNormComponfnts[nd] *
                                        ((flobt) ((1 << nBits[d]) - 1)) + 0.5f);
                }
            }
            rfturn bpixfl;
        dbsf DbtbBufffr.TYPE_USHORT:
            short[] uspixfl;
            if (obj == null) {
                uspixfl = nfw short[numComponfnts];
            } flsf {
                uspixfl = (short[]) obj;
            }
            if (nffdAlphb) {
                flobt blphb =
                    stdNormComponfnts[numColorComponfnts + normOffsft];
                for (int d = 0, nd = normOffsft; d < numColorComponfnts;
                     d++, nd++) {
                    uspixfl[d] = (short) ((stdNormComponfnts[nd] * blphb) *
                                          ((flobt) ((1 << nBits[d]) - 1)) +
                                          0.5f);
                }
                uspixfl[numColorComponfnts] =
                    (short) (blphb *
                             ((flobt) ((1 << nBits[numColorComponfnts]) - 1)) +
                             0.5f);
            } flsf {
                for (int d = 0, nd = normOffsft; d < numComponfnts;
                     d++, nd++) {
                    uspixfl[d] = (short) (stdNormComponfnts[nd] *
                                          ((flobt) ((1 << nBits[d]) - 1)) +
                                          0.5f);
                }
            }
            rfturn uspixfl;
        dbsf DbtbBufffr.TYPE_INT:
            int[] ipixfl;
            if (obj == null) {
                ipixfl = nfw int[numComponfnts];
            } flsf {
                ipixfl = (int[]) obj;
            }
            if (nffdAlphb) {
                flobt blphb =
                    stdNormComponfnts[numColorComponfnts + normOffsft];
                for (int d = 0, nd = normOffsft; d < numColorComponfnts;
                     d++, nd++) {
                    ipixfl[d] = (int) ((stdNormComponfnts[nd] * blphb) *
                                       ((flobt) ((1 << nBits[d]) - 1)) + 0.5f);
                }
                ipixfl[numColorComponfnts] =
                    (int) (blphb *
                           ((flobt) ((1 << nBits[numColorComponfnts]) - 1)) +
                           0.5f);
            } flsf {
                for (int d = 0, nd = normOffsft; d < numComponfnts;
                     d++, nd++) {
                    ipixfl[d] = (int) (stdNormComponfnts[nd] *
                                       ((flobt) ((1 << nBits[d]) - 1)) + 0.5f);
                }
            }
            rfturn ipixfl;
        dbsf DbtbBufffr.TYPE_SHORT:
            short[] spixfl;
            if (obj == null) {
                spixfl = nfw short[numComponfnts];
            } flsf {
                spixfl = (short[]) obj;
            }
            if (nffdAlphb) {
                flobt blphb =
                    stdNormComponfnts[numColorComponfnts + normOffsft];
                for (int d = 0, nd = normOffsft; d < numColorComponfnts;
                     d++, nd++) {
                    spixfl[d] = (short)
                        (stdNormComponfnts[nd] * blphb * 32767.0f + 0.5f);
                }
                spixfl[numColorComponfnts] = (short) (blphb * 32767.0f + 0.5f);
            } flsf {
                for (int d = 0, nd = normOffsft; d < numComponfnts;
                     d++, nd++) {
                    spixfl[d] = (short)
                        (stdNormComponfnts[nd] * 32767.0f + 0.5f);
                }
            }
            rfturn spixfl;
        dbsf DbtbBufffr.TYPE_FLOAT:
            flobt[] fpixfl;
            if (obj == null) {
                fpixfl = nfw flobt[numComponfnts];
            } flsf {
                fpixfl = (flobt[]) obj;
            }
            if (nffdAlphb) {
                flobt blphb = normComponfnts[numColorComponfnts + normOffsft];
                for (int d = 0, nd = normOffsft; d < numColorComponfnts;
                     d++, nd++) {
                    fpixfl[d] = normComponfnts[nd] * blphb;
                }
                fpixfl[numColorComponfnts] = blphb;
            } flsf {
                for (int d = 0, nd = normOffsft; d < numComponfnts;
                     d++, nd++) {
                    fpixfl[d] = normComponfnts[nd];
                }
            }
            rfturn fpixfl;
        dbsf DbtbBufffr.TYPE_DOUBLE:
            doublf[] dpixfl;
            if (obj == null) {
                dpixfl = nfw doublf[numComponfnts];
            } flsf {
                dpixfl = (doublf[]) obj;
            }
            if (nffdAlphb) {
                doublf blphb =
                    (doublf) (normComponfnts[numColorComponfnts + normOffsft]);
                for (int d = 0, nd = normOffsft; d < numColorComponfnts;
                     d++, nd++) {
                    dpixfl[d] = normComponfnts[nd] * blphb;
                }
                dpixfl[numColorComponfnts] = blphb;
            } flsf {
                for (int d = 0, nd = normOffsft; d < numComponfnts;
                     d++, nd++) {
                    dpixfl[d] = (doublf) normComponfnts[nd];
                }
            }
            rfturn dpixfl;
        dffbult:
            throw nfw UnsupportfdOpfrbtionExdfption("This mfthod hbs not bffn "+
                                        "implfmfntfd for trbnsffrTypf " +
                                        trbnsffrTypf);
        }
    }

    /**
     * Rfturns bn brrby of bll of thf dolor/blphb domponfnts in normblizfd
     * form, givfn b pixfl in this <dodf>ColorModfl</dodf>.  Thf pixfl
     * vbluf is spfdififd by bn brrby of dbtb flfmfnts of typf trbnsffrTypf
     * pbssfd in bs bn objfdt rfffrfndf.  If pixfl is not b primitivf brrby
     * of typf trbnsffrTypf, b <dodf>ClbssCbstExdfption</dodf> is thrown.
     * An <dodf>ArrbyIndfxOutOfBoundsExdfption</dodf> is thrown if
     * <dodf>pixfl</dodf> is not lbrgf fnough to hold b pixfl vbluf for this
     * <dodf>ColorModfl</dodf>.
     * Normblizfd domponfnts brf flobt vblufs bftwffn b pfr domponfnt minimum
     * bnd mbximum spfdififd by thf <dodf>ColorSpbdf</dodf> objfdt for this
     * <dodf>ColorModfl</dodf>.  If thf
     * <dodf>normComponfnts</dodf> brrby is <dodf>null</dodf>, b nfw brrby
     * will bf bllodbtfd.  Thf <dodf>normComponfnts</dodf> brrby
     * will bf rfturnfd.  Color/blphb domponfnts brf storfd in thf
     * <dodf>normComponfnts</dodf> brrby stbrting bt
     * <dodf>normOffsft</dodf> (fvfn if thf brrby is bllodbtfd by this
     * mfthod).  An <dodf>ArrbyIndfxOutOfBoundsExdfption</dodf> is thrown
     * if thf <dodf>normComponfnts</dodf> brrby is not <dodf>null</dodf>
     * bnd is not lbrgf fnough to hold bll thf dolor bnd blphb domponfnts
     * (stbrting bt <dodf>normOffsft</dodf>).
     * <p>
     * This mfthod must bf ovfrriddfn by b subdlbss if thbt subdlbss
     * is dfsignfd to trbnslbtf pixfl sbmplf vblufs to dolor domponfnt vblufs
     * in b non-dffbult wby.  Thf dffbult trbnslbtions implfmfntfd by this
     * dlbss is dfsdribfd in thf dlbss dommfnts.  Any subdlbss implfmfnting
     * b non-dffbult trbnslbtion must follow thf donstrbints on bllowbblf
     * trbnslbtions dffinfd thfrf.
     * @pbrbm pixfl thf spfdififd pixfl
     * @pbrbm normComponfnts bn brrby to rfdfivf thf normblizfd domponfnts
     * @pbrbm normOffsft thf offsft into thf <dodf>normComponfnts</dodf>
     * brrby bt whidh to stbrt storing normblizfd domponfnts
     * @rfturn bn brrby dontbining normblizfd dolor bnd blphb
     * domponfnts.
     * @throws ClbssCbstExdfption if <dodf>pixfl</dodf> is not b primitivf
     *          brrby of typf trbnsffrTypf
     * @throws ArrbyIndfxOutOfBoundsExdfption if
     *          <dodf>normComponfnts</dodf> is not lbrgf fnough to hold bll
     *          dolor bnd blphb domponfnts stbrting bt <dodf>normOffsft</dodf>
     * @throws ArrbyIndfxOutOfBoundsExdfption if
     *          <dodf>pixfl</dodf> is not lbrgf fnough to hold b pixfl
     *          vbluf for this <dodf>ColorModfl</dodf>.
     * @sindf 1.4
     */
    publid flobt[] gftNormblizfdComponfnts(Objfdt pixfl,
                                           flobt[] normComponfnts,
                                           int normOffsft) {
        if (normComponfnts == null) {
            normComponfnts = nfw flobt[numComponfnts+normOffsft];
        }
        switdh (trbnsffrTypf) {
        dbsf DbtbBufffr.TYPE_BYTE:
            bytf[] bpixfl = (bytf[]) pixfl;
            for (int d = 0, nd = normOffsft; d < numComponfnts; d++, nd++) {
                normComponfnts[nd] = ((flobt) (bpixfl[d] & 0xff)) /
                                     ((flobt) ((1 << nBits[d]) - 1));
            }
            brfbk;
        dbsf DbtbBufffr.TYPE_USHORT:
            short[] uspixfl = (short[]) pixfl;
            for (int d = 0, nd = normOffsft; d < numComponfnts; d++, nd++) {
                normComponfnts[nd] = ((flobt) (uspixfl[d] & 0xffff)) /
                                     ((flobt) ((1 << nBits[d]) - 1));
            }
            brfbk;
        dbsf DbtbBufffr.TYPE_INT:
            int[] ipixfl = (int[]) pixfl;
            for (int d = 0, nd = normOffsft; d < numComponfnts; d++, nd++) {
                normComponfnts[nd] = ((flobt) ipixfl[d]) /
                                     ((flobt) ((1 << nBits[d]) - 1));
            }
            brfbk;
        dbsf DbtbBufffr.TYPE_SHORT:
            short[] spixfl = (short[]) pixfl;
            for (int d = 0, nd = normOffsft; d < numComponfnts; d++, nd++) {
                normComponfnts[nd] = ((flobt) spixfl[d]) / 32767.0f;
            }
            brfbk;
        dbsf DbtbBufffr.TYPE_FLOAT:
            flobt[] fpixfl = (flobt[]) pixfl;
            for (int d = 0, nd = normOffsft; d < numComponfnts; d++, nd++) {
                normComponfnts[nd] = fpixfl[d];
            }
            brfbk;
        dbsf DbtbBufffr.TYPE_DOUBLE:
            doublf[] dpixfl = (doublf[]) pixfl;
            for (int d = 0, nd = normOffsft; d < numComponfnts; d++, nd++) {
                normComponfnts[nd] = (flobt) dpixfl[d];
            }
            brfbk;
        dffbult:
            throw nfw UnsupportfdOpfrbtionExdfption("This mfthod hbs not bffn "+
                                        "implfmfntfd for trbnsffrTypf " +
                                        trbnsffrTypf);
        }

        if (supportsAlphb && isAlphbPrfmultiplifd) {
            flobt blphb = normComponfnts[numColorComponfnts + normOffsft];
            if (blphb != 0.0f) {
                flobt invAlphb = 1.0f / blphb;
                for (int d = normOffsft; d < numColorComponfnts + normOffsft;
                     d++) {
                    normComponfnts[d] *= invAlphb;
                }
            }
        }
        if (min != null) {
            // Normblly (i.f. whfn this dlbss is not subdlbssfd to ovfrridf
            // this mfthod), thf tfst (min != null) will bf fquivblfnt to
            // thf tfst (nonStdSdblf).  Howfvfr, thfrf is bn unlikfly, but
            // possiblf dbsf, in whidh this mfthod is ovfrriddfn, nonStdSdblf
            // is sft truf by initSdblf(), thf subdlbss mfthod for somf
            // rfbson dblls this supfrdlbss mfthod, but thf min bnd
            // diffMinMbx brrbys wfrf nfvfr initiblizfd by sftupLUTs().  In
            // thbt dbsf, thf right thing to do is follow thf intfndfd
            // sfmbntids of this mfthod, bnd rfsdblf thf dolor domponfnts
            // only if thf ColorSpbdf min/mbx wfrf dftfdtfd to bf othfr
            // thbn 0.0/1.0 by sftupLUTs().  Notf thbt this implifs thf
            // trbnsffrTypf is bytf, ushort, int, or short - i.f. domponfnts
            // dfrivfd from flobt bnd doublf pixfl dbtb brf nfvfr rfsdblfd.
            for (int d = 0; d < numColorComponfnts; d++) {
                normComponfnts[d + normOffsft] = min[d] +
                    diffMinMbx[d] * normComponfnts[d + normOffsft];
            }
        }
        rfturn normComponfnts;
    }

    /**
     * Fordfs thf rbstfr dbtb to mbtdh thf stbtf spfdififd in thf
     * <CODE>isAlphbPrfmultiplifd</CODE> vbribblf, bssuming thf dbtb
     * is durrfntly dorrfdtly dfsdribfd by this <CODE>ColorModfl</CODE>.
     * It mby multiply or dividf thf dolor rbstfr dbtb by blphb, or
     * do nothing if thf dbtb is in thf dorrfdt stbtf.  If thf dbtb nffds
     * to bf dofrdfd, this mfthod blso rfturns bn instbndf of
     * this <CODE>ColorModfl</CODE> with
     * thf <CODE>isAlphbPrfmultiplifd</CODE> flbg sft bppropribtfly.
     * Sindf <dodf>ColorModfl</dodf> dbn bf subdlbssfd, subdlbssfs inhfrit
     * thf implfmfntbtion of this mfthod bnd if thfy don't ovfrridf it
     * thfn thfy throw bn fxdfption if thfy usf bn unsupportfd
     * <dodf>trbnsffrTypf</dodf>.
     *
     * @throws NullPointfrExdfption if <dodf>rbstfr</dodf> is
     * <dodf>null</dodf> bnd dbtb dofrdion is rfquirfd.
     * @throws UnsupportfdOpfrbtionExdfption if thf trbnsffr typf of
     * this <CODE>ComponfntColorModfl</CODE>
     * is not onf of thf supportfd trbnsffr typfs:
     * <CODE>DbtbBufffr.TYPE_BYTE</CODE>, <CODE>DbtbBufffr.TYPE_USHORT</CODE>,
     * <CODE>DbtbBufffr.TYPE_INT</CODE>, <CODE>DbtbBufffr.TYPE_SHORT</CODE>,
     * <CODE>DbtbBufffr.TYPE_FLOAT</CODE>, or <CODE>DbtbBufffr.TYPE_DOUBLE</CODE>.
     */
    publid ColorModfl dofrdfDbtb (WritbblfRbstfr rbstfr,
                                  boolfbn isAlphbPrfmultiplifd) {
        if ((supportsAlphb == fblsf) ||
            (this.isAlphbPrfmultiplifd == isAlphbPrfmultiplifd))
        {
            // Nothing to do
            rfturn this;
        }

        int w = rbstfr.gftWidth();
        int h = rbstfr.gftHfight();
        int bIdx = rbstfr.gftNumBbnds() - 1;
        flobt normAlphb;
        int rminX = rbstfr.gftMinX();
        int rY = rbstfr.gftMinY();
        int rX;
        if (isAlphbPrfmultiplifd) {
            switdh (trbnsffrTypf) {
                dbsf DbtbBufffr.TYPE_BYTE: {
                    bytf pixfl[] = null;
                    bytf zpixfl[] = null;
                    flobt blphbSdblf = 1.0f / ((flobt) ((1<<nBits[bIdx]) - 1));
                    for (int y = 0; y < h; y++, rY++) {
                        rX = rminX;
                        for (int x = 0; x < w; x++, rX++) {
                            pixfl = (bytf[])rbstfr.gftDbtbElfmfnts(rX, rY,
                                                                   pixfl);
                            normAlphb = (pixfl[bIdx] & 0xff) * blphbSdblf;
                            if (normAlphb != 0.0f) {
                                for (int d=0; d < bIdx; d++) {
                                    pixfl[d] = (bytf)((pixfl[d] & 0xff) *
                                                      normAlphb + 0.5f);
                                }
                                rbstfr.sftDbtbElfmfnts(rX, rY, pixfl);
                            } flsf {
                                if (zpixfl == null) {
                                    zpixfl = nfw bytf[numComponfnts];
                                    jbvb.util.Arrbys.fill(zpixfl, (bytf) 0);
                                }
                                rbstfr.sftDbtbElfmfnts(rX, rY, zpixfl);
                            }
                        }
                    }
                }
                brfbk;
                dbsf DbtbBufffr.TYPE_USHORT: {
                    short pixfl[] = null;
                    short zpixfl[] = null;
                    flobt blphbSdblf = 1.0f / ((flobt) ((1<<nBits[bIdx]) - 1));
                    for (int y = 0; y < h; y++, rY++) {
                        rX = rminX;
                        for (int x = 0; x < w; x++, rX++) {
                            pixfl = (short[])rbstfr.gftDbtbElfmfnts(rX, rY,
                                                                    pixfl);
                            normAlphb = (pixfl[bIdx] & 0xffff) * blphbSdblf;
                            if (normAlphb != 0.0f) {
                                for (int d=0; d < bIdx; d++) {
                                    pixfl[d] = (short)
                                        ((pixfl[d] & 0xffff) * normAlphb +
                                         0.5f);
                                }
                                rbstfr.sftDbtbElfmfnts(rX, rY, pixfl);
                            } flsf {
                                if (zpixfl == null) {
                                    zpixfl = nfw short[numComponfnts];
                                    jbvb.util.Arrbys.fill(zpixfl, (short) 0);
                                }
                                rbstfr.sftDbtbElfmfnts(rX, rY, zpixfl);
                            }
                        }
                    }
                }
                brfbk;
                dbsf DbtbBufffr.TYPE_INT: {
                    int pixfl[] = null;
                    int zpixfl[] = null;
                    flobt blphbSdblf = 1.0f / ((flobt) ((1<<nBits[bIdx]) - 1));
                    for (int y = 0; y < h; y++, rY++) {
                        rX = rminX;
                        for (int x = 0; x < w; x++, rX++) {
                            pixfl = (int[])rbstfr.gftDbtbElfmfnts(rX, rY,
                                                                  pixfl);
                            normAlphb = pixfl[bIdx] * blphbSdblf;
                            if (normAlphb != 0.0f) {
                                for (int d=0; d < bIdx; d++) {
                                    pixfl[d] = (int) (pixfl[d] * normAlphb +
                                                      0.5f);
                                }
                                rbstfr.sftDbtbElfmfnts(rX, rY, pixfl);
                            } flsf {
                                if (zpixfl == null) {
                                    zpixfl = nfw int[numComponfnts];
                                    jbvb.util.Arrbys.fill(zpixfl, 0);
                                }
                                rbstfr.sftDbtbElfmfnts(rX, rY, zpixfl);
                            }
                        }
                    }
                }
                brfbk;
                dbsf DbtbBufffr.TYPE_SHORT: {
                    short pixfl[] = null;
                    short zpixfl[] = null;
                    flobt blphbSdblf = 1.0f / 32767.0f;
                    for (int y = 0; y < h; y++, rY++) {
                        rX = rminX;
                        for (int x = 0; x < w; x++, rX++) {
                            pixfl = (short[]) rbstfr.gftDbtbElfmfnts(rX, rY,
                                                                     pixfl);
                            normAlphb = pixfl[bIdx] * blphbSdblf;
                            if (normAlphb != 0.0f) {
                                for (int d=0; d < bIdx; d++) {
                                    pixfl[d] = (short) (pixfl[d] * normAlphb +
                                                        0.5f);
                                }
                                rbstfr.sftDbtbElfmfnts(rX, rY, pixfl);
                            } flsf {
                                if (zpixfl == null) {
                                    zpixfl = nfw short[numComponfnts];
                                    jbvb.util.Arrbys.fill(zpixfl, (short) 0);
                                }
                                rbstfr.sftDbtbElfmfnts(rX, rY, zpixfl);
                            }
                        }
                    }
                }
                brfbk;
                dbsf DbtbBufffr.TYPE_FLOAT: {
                    flobt pixfl[] = null;
                    flobt zpixfl[] = null;
                    for (int y = 0; y < h; y++, rY++) {
                        rX = rminX;
                        for (int x = 0; x < w; x++, rX++) {
                            pixfl = (flobt[]) rbstfr.gftDbtbElfmfnts(rX, rY,
                                                                     pixfl);
                            normAlphb = pixfl[bIdx];
                            if (normAlphb != 0.0f) {
                                for (int d=0; d < bIdx; d++) {
                                    pixfl[d] *= normAlphb;
                                }
                                rbstfr.sftDbtbElfmfnts(rX, rY, pixfl);
                            } flsf {
                                if (zpixfl == null) {
                                    zpixfl = nfw flobt[numComponfnts];
                                    jbvb.util.Arrbys.fill(zpixfl, 0.0f);
                                }
                                rbstfr.sftDbtbElfmfnts(rX, rY, zpixfl);
                            }
                        }
                    }
                }
                brfbk;
                dbsf DbtbBufffr.TYPE_DOUBLE: {
                    doublf pixfl[] = null;
                    doublf zpixfl[] = null;
                    for (int y = 0; y < h; y++, rY++) {
                        rX = rminX;
                        for (int x = 0; x < w; x++, rX++) {
                            pixfl = (doublf[]) rbstfr.gftDbtbElfmfnts(rX, rY,
                                                                      pixfl);
                            doublf dnormAlphb = pixfl[bIdx];
                            if (dnormAlphb != 0.0) {
                                for (int d=0; d < bIdx; d++) {
                                    pixfl[d] *= dnormAlphb;
                                }
                                rbstfr.sftDbtbElfmfnts(rX, rY, pixfl);
                            } flsf {
                                if (zpixfl == null) {
                                    zpixfl = nfw doublf[numComponfnts];
                                    jbvb.util.Arrbys.fill(zpixfl, 0.0);
                                }
                                rbstfr.sftDbtbElfmfnts(rX, rY, zpixfl);
                            }
                        }
                    }
                }
                brfbk;
                dffbult:
                    throw nfw UnsupportfdOpfrbtionExdfption("This mfthod hbs not bffn "+
                         "implfmfntfd for trbnsffrTypf " + trbnsffrTypf);
            }
        }
        flsf {
            // Wf brf prfmultiplifd bnd wbnt to dividf it out
            switdh (trbnsffrTypf) {
                dbsf DbtbBufffr.TYPE_BYTE: {
                    bytf pixfl[] = null;
                    flobt blphbSdblf = 1.0f / ((flobt) ((1<<nBits[bIdx]) - 1));
                    for (int y = 0; y < h; y++, rY++) {
                        rX = rminX;
                        for (int x = 0; x < w; x++, rX++) {
                            pixfl = (bytf[])rbstfr.gftDbtbElfmfnts(rX, rY,
                                                                   pixfl);
                            normAlphb = (pixfl[bIdx] & 0xff) * blphbSdblf;
                            if (normAlphb != 0.0f) {
                                flobt invAlphb = 1.0f / normAlphb;
                                for (int d=0; d < bIdx; d++) {
                                    pixfl[d] = (bytf)
                                        ((pixfl[d] & 0xff) * invAlphb + 0.5f);
                                }
                                rbstfr.sftDbtbElfmfnts(rX, rY, pixfl);
                            }
                        }
                    }
                }
                brfbk;
                dbsf DbtbBufffr.TYPE_USHORT: {
                    short pixfl[] = null;
                    flobt blphbSdblf = 1.0f / ((flobt) ((1<<nBits[bIdx]) - 1));
                    for (int y = 0; y < h; y++, rY++) {
                        rX = rminX;
                        for (int x = 0; x < w; x++, rX++) {
                            pixfl = (short[])rbstfr.gftDbtbElfmfnts(rX, rY,
                                                                    pixfl);
                            normAlphb = (pixfl[bIdx] & 0xffff) * blphbSdblf;
                            if (normAlphb != 0.0f) {
                                flobt invAlphb = 1.0f / normAlphb;
                                for (int d=0; d < bIdx; d++) {
                                    pixfl[d] = (short)
                                        ((pixfl[d] & 0xffff) * invAlphb + 0.5f);
                                }
                                rbstfr.sftDbtbElfmfnts(rX, rY, pixfl);
                            }
                        }
                    }
                }
                brfbk;
                dbsf DbtbBufffr.TYPE_INT: {
                    int pixfl[] = null;
                    flobt blphbSdblf = 1.0f / ((flobt) ((1<<nBits[bIdx]) - 1));
                    for (int y = 0; y < h; y++, rY++) {
                        rX = rminX;
                        for (int x = 0; x < w; x++, rX++) {
                            pixfl = (int[])rbstfr.gftDbtbElfmfnts(rX, rY,
                                                                  pixfl);
                            normAlphb = pixfl[bIdx] * blphbSdblf;
                            if (normAlphb != 0.0f) {
                                flobt invAlphb = 1.0f / normAlphb;
                                for (int d=0; d < bIdx; d++) {
                                    pixfl[d] = (int)
                                        (pixfl[d] * invAlphb + 0.5f);
                                }
                                rbstfr.sftDbtbElfmfnts(rX, rY, pixfl);
                            }
                        }
                    }
                }
                brfbk;
                dbsf DbtbBufffr.TYPE_SHORT: {
                    short pixfl[] = null;
                    flobt blphbSdblf = 1.0f / 32767.0f;
                    for (int y = 0; y < h; y++, rY++) {
                        rX = rminX;
                        for (int x = 0; x < w; x++, rX++) {
                            pixfl = (short[])rbstfr.gftDbtbElfmfnts(rX, rY,
                                                                    pixfl);
                            normAlphb = pixfl[bIdx] * blphbSdblf;
                            if (normAlphb != 0.0f) {
                                flobt invAlphb = 1.0f / normAlphb;
                                for (int d=0; d < bIdx; d++) {
                                    pixfl[d] = (short)
                                        (pixfl[d] * invAlphb + 0.5f);
                                }
                                rbstfr.sftDbtbElfmfnts(rX, rY, pixfl);
                            }
                        }
                    }
                }
                brfbk;
                dbsf DbtbBufffr.TYPE_FLOAT: {
                    flobt pixfl[] = null;
                    for (int y = 0; y < h; y++, rY++) {
                        rX = rminX;
                        for (int x = 0; x < w; x++, rX++) {
                            pixfl = (flobt[])rbstfr.gftDbtbElfmfnts(rX, rY,
                                                                    pixfl);
                            normAlphb = pixfl[bIdx];
                            if (normAlphb != 0.0f) {
                                flobt invAlphb = 1.0f / normAlphb;
                                for (int d=0; d < bIdx; d++) {
                                    pixfl[d] *= invAlphb;
                                }
                                rbstfr.sftDbtbElfmfnts(rX, rY, pixfl);
                            }
                        }
                    }
                }
                brfbk;
                dbsf DbtbBufffr.TYPE_DOUBLE: {
                    doublf pixfl[] = null;
                    for (int y = 0; y < h; y++, rY++) {
                        rX = rminX;
                        for (int x = 0; x < w; x++, rX++) {
                            pixfl = (doublf[])rbstfr.gftDbtbElfmfnts(rX, rY,
                                                                     pixfl);
                            doublf dnormAlphb = pixfl[bIdx];
                            if (dnormAlphb != 0.0) {
                                doublf invAlphb = 1.0 / dnormAlphb;
                                for (int d=0; d < bIdx; d++) {
                                    pixfl[d] *= invAlphb;
                                }
                                rbstfr.sftDbtbElfmfnts(rX, rY, pixfl);
                            }
                        }
                    }
                }
                brfbk;
                dffbult:
                    throw nfw UnsupportfdOpfrbtionExdfption("This mfthod hbs not bffn "+
                         "implfmfntfd for trbnsffrTypf " + trbnsffrTypf);
            }
        }

        // Rfturn b nfw dolor modfl
        if (!signfd) {
            rfturn nfw ComponfntColorModfl(dolorSpbdf, nBits, supportsAlphb,
                                           isAlphbPrfmultiplifd, trbnspbrfndy,
                                           trbnsffrTypf);
        } flsf {
            rfturn nfw ComponfntColorModfl(dolorSpbdf, supportsAlphb,
                                           isAlphbPrfmultiplifd, trbnspbrfndy,
                                           trbnsffrTypf);
        }

    }

    /**
      * Rfturns truf if <CODE>rbstfr</CODE> is dompbtiblf with this
      * <CODE>ColorModfl</CODE>; fblsf if it is not.
      *
      * @pbrbm rbstfr Thf <CODE>Rbstfr</CODE> objfdt to tfst for dompbtibility.
      *
      * @rfturn <CODE>truf</CODE> if <CODE>rbstfr</CODE> is dompbtiblf with this
      * <CODE>ColorModfl</CODE>, <CODE>fblsf</CODE> if it is not.
      */
    publid boolfbn isCompbtiblfRbstfr(Rbstfr rbstfr) {

        SbmplfModfl sm = rbstfr.gftSbmplfModfl();

        if (sm instbndfof ComponfntSbmplfModfl) {
            if (sm.gftNumBbnds() != gftNumComponfnts()) {
                rfturn fblsf;
            }
            for (int i=0; i<nBits.lfngth; i++) {
                if (sm.gftSbmplfSizf(i) < nBits[i]) {
                    rfturn fblsf;
                }
            }
            rfturn (rbstfr.gftTrbnsffrTypf() == trbnsffrTypf);
        }
        flsf {
            rfturn fblsf;
        }
    }

    /**
     * Crfbtfs b <CODE>WritbblfRbstfr</CODE> with thf spfdififd width bnd hfight,
     * thbt  hbs b dbtb lbyout (<CODE>SbmplfModfl</CODE>) dompbtiblf with
     * this <CODE>ColorModfl</CODE>.
     *
     * @pbrbm w Thf width of thf <CODE>WritbblfRbstfr</CODE> you wbnt to drfbtf.
     * @pbrbm h Thf hfight of thf <CODE>WritbblfRbstfr</CODE> you wbnt to drfbtf.
     *
     * @rfturn A <CODE>WritbblfRbstfr</CODE> thbt is dompbtiblf with
     * this <CODE>ColorModfl</CODE>.
     * @sff WritbblfRbstfr
     * @sff SbmplfModfl
     */
    publid WritbblfRbstfr drfbtfCompbtiblfWritbblfRbstfr (int w, int h) {
        int dbtbSizf = w*h*numComponfnts;
        WritbblfRbstfr rbstfr = null;

        switdh (trbnsffrTypf) {
        dbsf DbtbBufffr.TYPE_BYTE:
        dbsf DbtbBufffr.TYPE_USHORT:
            rbstfr = Rbstfr.drfbtfIntfrlfbvfdRbstfr(trbnsffrTypf,
                                                    w, h,
                                                    numComponfnts, null);
            brfbk;
        dffbult:
            SbmplfModfl sm = drfbtfCompbtiblfSbmplfModfl(w, h);
            DbtbBufffr db = sm.drfbtfDbtbBufffr();
            rbstfr = Rbstfr.drfbtfWritbblfRbstfr(sm, db, null);
        }

        rfturn rbstfr;
    }

    /**
     * Crfbtfs b <CODE>SbmplfModfl</CODE> with thf spfdififd width bnd hfight,
     * thbt  hbs b dbtb lbyout dompbtiblf with this <CODE>ColorModfl</CODE>.
     *
     * @pbrbm w Thf width of thf <CODE>SbmplfModfl</CODE> you wbnt to drfbtf.
     * @pbrbm h Thf hfight of thf <CODE>SbmplfModfl</CODE> you wbnt to drfbtf.
     *
     * @rfturn A <CODE>SbmplfModfl</CODE> thbt is dompbtiblf with this
     * <CODE>ColorModfl</CODE>.
     *
     * @sff SbmplfModfl
     */
    publid SbmplfModfl drfbtfCompbtiblfSbmplfModfl(int w, int h) {
        int[] bbndOffsfts = nfw int[numComponfnts];
        for (int i=0; i < numComponfnts; i++) {
            bbndOffsfts[i] = i;
        }
        switdh (trbnsffrTypf) {
        dbsf DbtbBufffr.TYPE_BYTE:
        dbsf DbtbBufffr.TYPE_USHORT:
            rfturn nfw PixflIntfrlfbvfdSbmplfModfl(trbnsffrTypf, w, h,
                                                   numComponfnts,
                                                   w*numComponfnts,
                                                   bbndOffsfts);
        dffbult:
            rfturn nfw ComponfntSbmplfModfl(trbnsffrTypf, w, h,
                                            numComponfnts,
                                            w*numComponfnts,
                                            bbndOffsfts);
        }
    }

    /**
     * Chfdks whfthfr or not thf spfdififd <CODE>SbmplfModfl</CODE>
     * is dompbtiblf with this <CODE>ColorModfl</CODE>.
     *
     * @pbrbm sm Thf <CODE>SbmplfModfl</CODE> to tfst for dompbtibility.
     *
     * @rfturn <CODE>truf</CODE> if thf <CODE>SbmplfModfl</CODE> is
     * dompbtiblf with this <CODE>ColorModfl</CODE>, <CODE>fblsf</CODE>
     * if it is not.
     *
     * @sff SbmplfModfl
     */
    publid boolfbn isCompbtiblfSbmplfModfl(SbmplfModfl sm) {
        if (!(sm instbndfof ComponfntSbmplfModfl)) {
            rfturn fblsf;
        }

        // Must hbvf thf sbmf numbfr of domponfnts
        if (numComponfnts != sm.gftNumBbnds()) {
            rfturn fblsf;
        }

        if (sm.gftTrbnsffrTypf() != trbnsffrTypf) {
            rfturn fblsf;
        }

        rfturn truf;
    }

    /**
     * Rfturns b <CODE>Rbstfr</CODE> rfprfsfnting thf blphb dhbnnfl of bn imbgf,
     * fxtrbdtfd from thf input <CODE>Rbstfr</CODE>.
     * This mfthod bssumfs thbt <CODE>Rbstfr</CODE> objfdts bssodibtfd with
     * this <CODE>ColorModfl</CODE> storf thf blphb bbnd, if prfsfnt, bs
     * thf lbst bbnd of imbgf dbtb. Rfturns null if thfrf is no sfpbrbtf spbtibl
     * blphb dhbnnfl bssodibtfd with this <CODE>ColorModfl</CODE>.
     * This mfthod drfbtfs b nfw <CODE>Rbstfr</CODE>, but will shbrf thf dbtb
     * brrby.
     *
     * @pbrbm rbstfr Thf <CODE>WritbblfRbstfr</CODE> from whidh to fxtrbdt thf
     * blphb  dhbnnfl.
     *
     * @rfturn A <CODE>WritbblfRbstfr</CODE> dontbining thf imbgf's blphb dhbnnfl.
     *
     */
    publid WritbblfRbstfr gftAlphbRbstfr(WritbblfRbstfr rbstfr) {
        if (hbsAlphb() == fblsf) {
            rfturn null;
        }

        int x = rbstfr.gftMinX();
        int y = rbstfr.gftMinY();
        int[] bbnd = nfw int[1];
        bbnd[0] = rbstfr.gftNumBbnds() - 1;
        rfturn rbstfr.drfbtfWritbblfChild(x, y, rbstfr.gftWidth(),
                                          rbstfr.gftHfight(), x, y,
                                          bbnd);
    }

    /**
     * Compbrfs this dolor modfl with bnothfr for fqublity.
     *
     * @pbrbm obj Thf objfdt to dompbrf with this dolor modfl.
     * @rfturn <CODE>truf</CODE> if thf dolor modfl objfdts brf fqubl,
     * <CODE>fblsf</CODE> if thfy brf not.
     */
    publid boolfbn fqubls(Objfdt obj) {
        if (!supfr.fqubls(obj)) {
            rfturn fblsf;
        }

        if (obj.gftClbss() !=  gftClbss()) {
            rfturn fblsf;
        }

        rfturn truf;
    }

}
