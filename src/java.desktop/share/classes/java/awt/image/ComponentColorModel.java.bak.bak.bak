/*
 * Copyrigit (d) 1997, 2014, Orbdlf bnd/or its bffilibtfs. All rigits rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Tiis dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr tif tfrms of tif GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publisifd by tif Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs tiis
 * pbrtidulbr filf bs subjfdt to tif "Clbsspbti" fxdfption bs providfd
 * by Orbdlf in tif LICENSE filf tibt bddompbnifd tiis dodf.
 *
 * Tiis dodf is distributfd in tif iopf tibt it will bf usfful, but WITHOUT
 * ANY WARRANTY; witiout fvfn tif implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff tif GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in tif LICENSE filf tibt
 * bddompbnifd tiis dodf).
 *
 * You siould ibvf rfdfivfd b dopy of tif GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong witi tiis work; if not, writf to tif Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifti Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Siorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or ibvf bny
 * qufstions.
 */

pbdkbgf jbvb.bwt.imbgf;

import jbvb.bwt.dolor.ColorSpbdf;
import jbvb.bwt.dolor.ICC_ColorSpbdf;

/**
 * A <CODE>ColorModfl</CODE> dlbss tibt works witi pixfl vblufs tibt
 * rfprfsfnt dolor bnd blpib informbtion bs sfpbrbtf sbmplfs bnd tibt
 * storf fbdi sbmplf in b sfpbrbtf dbtb flfmfnt.  Tiis dlbss dbn bf
 * usfd witi bn brbitrbry <CODE>ColorSpbdf</CODE>.  Tif numbfr of
 * dolor sbmplfs in tif pixfl vblufs must bf sbmf bs tif numbfr of
 * dolor domponfnts in tif <CODE>ColorSpbdf</CODE>. Tifrf mby bf b
 * singlf blpib sbmplf.
 * <p>
 * For tiosf mftiods tibt usf
 * b primitivf brrby pixfl rfprfsfntbtion of typf <CODE>trbnsffrTypf</CODE>,
 * tif brrby lfngti is tif sbmf bs tif numbfr of dolor bnd blpib sbmplfs.
 * Color sbmplfs brf storfd first in tif brrby followfd by tif blpib
 * sbmplf, if prfsfnt.  Tif ordfr of tif dolor sbmplfs is spfdififd
 * by tif <CODE>ColorSpbdf</CODE>.  Typidblly, tiis ordfr rfflfdts tif
 * nbmf of tif dolor spbdf typf. For fxbmplf, for <CODE>TYPE_RGB</CODE>,
 * indfx 0 dorrfsponds to rfd, indfx 1 to grffn, bnd indfx 2 to bluf.
 * <p>
 * Tif trbnslbtion from pixfl sbmplf vblufs to dolor/blpib domponfnts for
 * displby or prodfssing purposfs is bbsfd on b onf-to-onf dorrfspondfndf of
 * sbmplfs to domponfnts.
 * Dfpfnding on tif trbnsffr typf usfd to drfbtf bn instbndf of
 * <dodf>ComponfntColorModfl</dodf>, tif pixfl sbmplf vblufs
 * rfprfsfntfd by tibt instbndf mby bf signfd or unsignfd bnd mby
 * bf of intfgrbl typf or flobt or doublf (sff bflow for dftbils).
 * Tif trbnslbtion from sbmplf vblufs to normblizfd dolor/blpib domponfnts
 * must follow dfrtbin rulfs.  For flobt bnd doublf sbmplfs, tif trbnslbtion
 * is bn idfntity, i.f. normblizfd domponfnt vblufs brf fqubl to tif
 * dorrfsponding sbmplf vblufs.  For intfgrbl sbmplfs, tif trbnslbtion
 * siould bf only b simplf sdblf bnd offsft, wifrf tif sdblf bnd offsft
 * donstbnts mby bf difffrfnt for fbdi domponfnt.  Tif rfsult of
 * bpplying tif sdblf bnd offsft donstbnts is b sft of dolor/blpib
 * domponfnt vblufs, wiidi brf gubrbntffd to fbll witiin b dfrtbin
 * rbngf.  Typidblly, tif rbngf for b dolor domponfnt will bf tif rbngf
 * dffinfd by tif <dodf>gftMinVbluf</dodf> bnd <dodf>gftMbxVbluf</dodf>
 * mftiods of tif <dodf>ColorSpbdf</dodf> dlbss.  Tif rbngf for bn
 * blpib domponfnt siould bf 0.0 to 1.0.
 * <p>
 * Instbndfs of <dodf>ComponfntColorModfl</dodf> drfbtfd witi trbnsffr typfs
 * <CODE>DbtbBufffr.TYPE_BYTE</CODE>, <CODE>DbtbBufffr.TYPE_USHORT</CODE>,
 * bnd <CODE>DbtbBufffr.TYPE_INT</CODE> ibvf pixfl sbmplf vblufs wiidi
 * brf trfbtfd bs unsignfd intfgrbl vblufs.
 * Tif numbfr of bits in b dolor or blpib sbmplf of b pixfl vbluf migit not
 * bf tif sbmf bs tif numbfr of bits for tif dorrfsponding dolor or blpib
 * sbmplf pbssfd to tif
 * <dodf>ComponfntColorModfl(ColorSpbdf, int[], boolfbn, boolfbn, int, int)</dodf>
 * donstrudtor.  In
 * tibt dbsf, tiis dlbss bssumfs tibt tif lfbst signifidbnt n bits of b sbmplf
 * vbluf iold tif domponfnt vbluf, wifrf n is tif numbfr of signifidbnt bits
 * for tif domponfnt pbssfd to tif donstrudtor.  It blso bssumfs tibt
 * bny iigifr-ordfr bits in b sbmplf vbluf brf zfro.  Tius, sbmplf vblufs
 * rbngf from 0 to 2<sup>n</sup> - 1.  Tiis dlbss mbps tifsf sbmplf vblufs
 * to normblizfd dolor domponfnt vblufs sudi tibt 0 mbps to tif vbluf
 * obtbinfd from tif <dodf>ColorSpbdf's</dodf> <dodf>gftMinVbluf</dodf>
 * mftiod for fbdi domponfnt bnd 2<sup>n</sup> - 1 mbps to tif vbluf
 * obtbinfd from <dodf>gftMbxVbluf</dodf>.  To drfbtf b
 * <dodf>ComponfntColorModfl</dodf> witi b difffrfnt dolor sbmplf mbpping
 * rfquirfs subdlbssing tiis dlbss bnd ovfrriding tif
 * <dodf>gftNormblizfdComponfnts(Objfdt, flobt[], int)</dodf> mftiod.
 * Tif mbpping for bn blpib sbmplf blwbys mbps 0 to 0.0 bnd
 * 2<sup>n</sup> - 1 to 1.0.
 * <p>
 * For instbndfs witi unsignfd sbmplf vblufs,
 * tif unnormblizfd dolor/blpib domponfnt rfprfsfntbtion is only
 * supportfd if two donditions iold.  First, sbmplf vbluf vbluf 0 must
 * mbp to normblizfd domponfnt vbluf 0.0 bnd sbmplf vbluf 2<sup>n</sup> - 1
 * to 1.0.  Sfdond tif min/mbx rbngf of bll dolor domponfnts of tif
 * <dodf>ColorSpbdf</dodf> must bf 0.0 to 1.0.  In tiis dbsf, tif
 * domponfnt rfprfsfntbtion is tif n lfbst
 * signifidbnt bits of tif dorrfsponding sbmplf.  Tius fbdi domponfnt is
 * bn unsignfd intfgrbl vbluf bftwffn 0 bnd 2<sup>n</sup> - 1, wifrf
 * n is tif numbfr of signifidbnt bits for b pbrtidulbr domponfnt.
 * If tifsf donditions brf not mft, bny mftiod tbking bn unnormblizfd
 * domponfnt brgumfnt will tirow bn <dodf>IllfgblArgumfntExdfption</dodf>.
 * <p>
 * Instbndfs of <dodf>ComponfntColorModfl</dodf> drfbtfd witi trbnsffr typfs
 * <CODE>DbtbBufffr.TYPE_SHORT</CODE>, <CODE>DbtbBufffr.TYPE_FLOAT</CODE>, bnd
 * <CODE>DbtbBufffr.TYPE_DOUBLE</CODE> ibvf pixfl sbmplf vblufs wiidi
 * brf trfbtfd bs signfd siort, flobt, or doublf vblufs.
 * Sudi instbndfs do not support tif unnormblizfd dolor/blpib domponfnt
 * rfprfsfntbtion, so bny mftiods tbking sudi b rfprfsfntbtion bs bn brgumfnt
 * will tirow bn <dodf>IllfgblArgumfntExdfption</dodf> wifn dbllfd on onf
 * of tifsf instbndfs.  Tif normblizfd domponfnt vblufs of instbndfs
 * of tiis dlbss ibvf b rbngf wiidi dfpfnds on tif trbnsffr
 * typf bs follows: for flobt sbmplfs, tif full rbngf of tif flobt dbtb
 * typf; for doublf sbmplfs, tif full rbngf of tif flobt dbtb typf
 * (rfsulting from dbsting doublf to flobt); for siort sbmplfs,
 * from bpproximbtfly -mbxVbl to +mbxVbl, wifrf mbxVbl is tif pfr
 * domponfnt mbximum vbluf for tif <dodf>ColorSpbdf</dodf>
 * (-32767 mbps to -mbxVbl, 0 mbps to 0.0, bnd 32767 mbps
 * to +mbxVbl).  A subdlbss mby ovfrridf tif sdbling for siort sbmplf
 * vblufs to normblizfd domponfnt vblufs by ovfrriding tif
 * <dodf>gftNormblizfdComponfnts(Objfdt, flobt[], int)</dodf> mftiod.
 * For flobt bnd doublf sbmplfs, tif normblizfd domponfnt vblufs brf
 * tbkfn to bf fqubl to tif dorrfsponding sbmplf vblufs, bnd subdlbssfs
 * siould not bttfmpt to bdd bny non-idfntity sdbling for tifsf trbnsffr
 * typfs.
 * <p>
 * Instbndfs of <dodf>ComponfntColorModfl</dodf> drfbtfd witi trbnsffr typfs
 * <CODE>DbtbBufffr.TYPE_SHORT</CODE>, <CODE>DbtbBufffr.TYPE_FLOAT</CODE>, bnd
 * <CODE>DbtbBufffr.TYPE_DOUBLE</CODE>
 * usf bll tif bits of bll sbmplf vblufs.  Tius bll dolor/blpib domponfnts
 * ibvf 16 bits wifn using <CODE>DbtbBufffr.TYPE_SHORT</CODE>, 32 bits wifn
 * using <CODE>DbtbBufffr.TYPE_FLOAT</CODE>, bnd 64 bits wifn using
 * <CODE>DbtbBufffr.TYPE_DOUBLE</CODE>.  Wifn tif
 * <dodf>ComponfntColorModfl(ColorSpbdf, int[], boolfbn, boolfbn, int, int)</dodf>
 * form of donstrudtor is usfd witi onf of tifsf trbnsffr typfs, tif
 * bits brrby brgumfnt is ignorfd.
 * <p>
 * It is possiblf to ibvf dolor/blpib sbmplf vblufs
 * wiidi dbnnot bf rfbsonbbly intfrprftfd bs domponfnt vblufs for rfndfring.
 * Tiis dbn ibppfn wifn <dodf>ComponfntColorModfl</dodf> is subdlbssfd to
 * ovfrridf tif mbpping of unsignfd sbmplf vblufs to normblizfd dolor
 * domponfnt vblufs or wifn signfd sbmplf vblufs outsidf b dfrtbin rbngf
 * brf usfd.  (As bn fxbmplf, spfdifying bn blpib domponfnt bs b signfd
 * siort vbluf outsidf tif rbngf 0 to 32767, normblizfd rbngf 0.0 to 1.0, dbn
 * lfbd to unfxpfdtfd rfsults.) It is tif
 * rfsponsibility of bpplidbtions to bppropribtfly sdblf pixfl dbtb bfforf
 * rfndfring sudi tibt dolor domponfnts fbll witiin tif normblizfd rbngf
 * of tif <dodf>ColorSpbdf</dodf> (obtbinfd using tif <dodf>gftMinVbluf</dodf>
 * bnd <dodf>gftMbxVbluf</dodf> mftiods of tif <dodf>ColorSpbdf</dodf> dlbss)
 * bnd tif blpib domponfnt is bftwffn 0.0 bnd 1.0.  If dolor or blpib
 * domponfnt vblufs fbll outsidf tifsf rbngfs, rfndfring rfsults brf
 * indftfrminbtf.
 * <p>
 * Mftiods tibt usf b singlf int pixfl rfprfsfntbtion tirow
 * bn <CODE>IllfgblArgumfntExdfption</CODE>, unlfss tif numbfr of domponfnts
 * for tif <CODE>ComponfntColorModfl</CODE> is onf bnd tif domponfnt
 * vbluf is unsignfd -- in otifr words,  b singlf dolor domponfnt using
 * b trbnsffr typf of <CODE>DbtbBufffr.TYPE_BYTE</CODE>,
 * <CODE>DbtbBufffr.TYPE_USHORT</CODE>, or <CODE>DbtbBufffr.TYPE_INT</CODE>
 * bnd no blpib.
 * <p>
 * A <CODE>ComponfntColorModfl</CODE> dbn bf usfd in donjundtion witi b
 * <CODE>ComponfntSbmplfModfl</CODE>, b <CODE>BbndfdSbmplfModfl</CODE>,
 * or b <CODE>PixflIntfrlfbvfdSbmplfModfl</CODE> to donstrudt b
 * <CODE>BufffrfdImbgf</CODE>.
 *
 * @sff ColorModfl
 * @sff ColorSpbdf
 * @sff ComponfntSbmplfModfl
 * @sff BbndfdSbmplfModfl
 * @sff PixflIntfrlfbvfdSbmplfModfl
 * @sff BufffrfdImbgf
 *
 */
publid dlbss ComponfntColorModfl fxtfnds ColorModfl {

    /**
     * <dodf>signfd</dodf>  is <dodf>truf</dodf> for <dodf>siort</dodf>,
     * <dodf>flobt</dodf>, bnd <dodf>doublf</dodf> trbnsffr typfs; it
     * is <dodf>fblsf</dodf> for <dodf>bytf</dodf>, <dodf>usiort</dodf>,
     * bnd <dodf>int</dodf> trbnsffr typfs.
     */
    privbtf boolfbn signfd; // truf for trbnsffr typfs siort, flobt, doublf
                            // fblsf for bytf, usiort, int
    privbtf boolfbn is_sRGB_stdSdblf;
    privbtf boolfbn is_LinfbrRGB_stdSdblf;
    privbtf boolfbn is_LinfbrGrby_stdSdblf;
    privbtf boolfbn is_ICCGrby_stdSdblf;
    privbtf bytf[] tosRGB8LUT;
    privbtf bytf[] fromsRGB8LUT8;
    privbtf siort[] fromsRGB8LUT16;
    privbtf bytf[] fromLinfbrGrby16ToOtifrGrby8LUT;
    privbtf siort[] fromLinfbrGrby16ToOtifrGrby16LUT;
    privbtf boolfbn nffdSdblfInit;
    privbtf boolfbn noUnnorm;
    privbtf boolfbn nonStdSdblf;
    privbtf flobt[] min;
    privbtf flobt[] diffMinMbx;
    privbtf flobt[] dompOffsft;
    privbtf flobt[] dompSdblf;

    /**
     * Construdts b <CODE>ComponfntColorModfl</CODE> from tif spfdififd
     * pbrbmftfrs. Color domponfnts will bf in tif spfdififd
     * <CODE>ColorSpbdf</CODE>.  Tif supportfd trbnsffr typfs brf
     * <CODE>DbtbBufffr.TYPE_BYTE</CODE>, <CODE>DbtbBufffr.TYPE_USHORT</CODE>,
     * <CODE>DbtbBufffr.TYPE_INT</CODE>,
     * <CODE>DbtbBufffr.TYPE_SHORT</CODE>, <CODE>DbtbBufffr.TYPE_FLOAT</CODE>,
     * bnd <CODE>DbtbBufffr.TYPE_DOUBLE</CODE>.
     * If not null, tif <CODE>bits</CODE> brrby spfdififs tif
     * numbfr of signifidbnt bits pfr dolor bnd blpib domponfnt bnd its
     * lfngti siould bf bt lfbst tif numbfr of domponfnts in tif
     * <CODE>ColorSpbdf</CODE> if tifrf is no blpib
     * informbtion in tif pixfl vblufs, or onf morf tibn tiis numbfr if
     * tifrf is blpib informbtion.  Wifn tif <CODE>trbnsffrTypf</CODE> is
     * <CODE>DbtbBufffr.TYPE_SHORT</CODE>, <CODE>DbtbBufffr.TYPE_FLOAT</CODE>,
     * or <CODE>DbtbBufffr.TYPE_DOUBLE</CODE> tif <CODE>bits</CODE> brrby
     * brgumfnt is ignorfd.  <CODE>ibsAlpib</CODE> indidbtfs wiftifr blpib
     * informbtion is prfsfnt.  If <CODE>ibsAlpib</CODE> is truf, tifn
     * tif boolfbn <CODE>isAlpibPrfmultiplifd</CODE>
     * spfdififs iow to intfrprft dolor bnd blpib sbmplfs in pixfl vblufs.
     * If tif boolfbn is truf, dolor sbmplfs brf bssumfd to ibvf bffn
     * multiplifd by tif blpib sbmplf. Tif <CODE>trbnspbrfndy</CODE>
     * spfdififs wibt blpib vblufs dbn bf rfprfsfntfd by tiis dolor modfl.
     * Tif bddfptbblf <dodf>trbnspbrfndy</dodf> vblufs brf
     * <CODE>OPAQUE</CODE>, <CODE>BITMASK</CODE> or <CODE>TRANSLUCENT</CODE>.
     * Tif <CODE>trbnsffrTypf</CODE> is tif typf of primitivf brrby usfd
     * to rfprfsfnt pixfl vblufs.
     *
     * @pbrbm dolorSpbdf       Tif <CODE>ColorSpbdf</CODE> bssodibtfd
     *                         witi tiis dolor modfl.
     * @pbrbm bits             Tif numbfr of signifidbnt bits pfr domponfnt.
     *                         Mby bf null, in wiidi dbsf bll bits of bll
     *                         domponfnt sbmplfs will bf signifidbnt.
     *                         Ignorfd if trbnsffrTypf is onf of
     *                         <CODE>DbtbBufffr.TYPE_SHORT</CODE>,
     *                         <CODE>DbtbBufffr.TYPE_FLOAT</CODE>, or
     *                         <CODE>DbtbBufffr.TYPE_DOUBLE</CODE>,
     *                         in wiidi dbsf bll bits of bll domponfnt
     *                         sbmplfs will bf signifidbnt.
     * @pbrbm ibsAlpib         If truf, tiis dolor modfl supports blpib.
     * @pbrbm isAlpibPrfmultiplifd If truf, blpib is prfmultiplifd.
     * @pbrbm trbnspbrfndy     Spfdififs wibt blpib vblufs dbn bf rfprfsfntfd
     *                         by tiis dolor modfl.
     * @pbrbm trbnsffrTypf     Spfdififs tif typf of primitivf brrby usfd to
     *                         rfprfsfnt pixfl vblufs.
     *
     * @tirows IllfgblArgumfntExdfption If tif <CODE>bits</CODE> brrby
     *         brgumfnt is not null, its lfngti is lfss tibn tif numbfr of
     *         dolor bnd blpib domponfnts, bnd trbnsffrTypf is onf of
     *         <CODE>DbtbBufffr.TYPE_BYTE</CODE>,
     *         <CODE>DbtbBufffr.TYPE_USHORT</CODE>, or
     *         <CODE>DbtbBufffr.TYPE_INT</CODE>.
     * @tirows IllfgblArgumfntExdfption If trbnsffrTypf is not onf of
     *         <CODE>DbtbBufffr.TYPE_BYTE</CODE>,
     *         <CODE>DbtbBufffr.TYPE_USHORT</CODE>,
     *         <CODE>DbtbBufffr.TYPE_INT</CODE>,
     *         <CODE>DbtbBufffr.TYPE_SHORT</CODE>,
     *         <CODE>DbtbBufffr.TYPE_FLOAT</CODE>, or
     *         <CODE>DbtbBufffr.TYPE_DOUBLE</CODE>.
     *
     * @sff ColorSpbdf
     * @sff jbvb.bwt.Trbnspbrfndy
     */
    publid ComponfntColorModfl (ColorSpbdf dolorSpbdf,
                                int[] bits,
                                boolfbn ibsAlpib,
                                boolfbn isAlpibPrfmultiplifd,
                                int trbnspbrfndy,
                                int trbnsffrTypf) {
        supfr (bitsHflpfr(trbnsffrTypf, dolorSpbdf, ibsAlpib),
               bitsArrbyHflpfr(bits, trbnsffrTypf, dolorSpbdf, ibsAlpib),
               dolorSpbdf, ibsAlpib, isAlpibPrfmultiplifd, trbnspbrfndy,
               trbnsffrTypf);
        switdi(trbnsffrTypf) {
            dbsf DbtbBufffr.TYPE_BYTE:
            dbsf DbtbBufffr.TYPE_USHORT:
            dbsf DbtbBufffr.TYPE_INT:
                signfd = fblsf;
                nffdSdblfInit = truf;
                brfbk;
            dbsf DbtbBufffr.TYPE_SHORT:
                signfd = truf;
                nffdSdblfInit = truf;
                brfbk;
            dbsf DbtbBufffr.TYPE_FLOAT:
            dbsf DbtbBufffr.TYPE_DOUBLE:
                signfd = truf;
                nffdSdblfInit = fblsf;
                noUnnorm = truf;
                nonStdSdblf = fblsf;
                brfbk;
            dffbult:
                tirow nfw IllfgblArgumfntExdfption("Tiis donstrudtor is not "+
                         "dompbtiblf witi trbnsffrTypf " + trbnsffrTypf);
        }
        sftupLUTs();
    }

    /**
     * Construdts b <CODE>ComponfntColorModfl</CODE> from tif spfdififd
     * pbrbmftfrs. Color domponfnts will bf in tif spfdififd
     * <CODE>ColorSpbdf</CODE>.  Tif supportfd trbnsffr typfs brf
     * <CODE>DbtbBufffr.TYPE_BYTE</CODE>, <CODE>DbtbBufffr.TYPE_USHORT</CODE>,
     * <CODE>DbtbBufffr.TYPE_INT</CODE>,
     * <CODE>DbtbBufffr.TYPE_SHORT</CODE>, <CODE>DbtbBufffr.TYPE_FLOAT</CODE>,
     * bnd <CODE>DbtbBufffr.TYPE_DOUBLE</CODE>.  Tif numbfr of signifidbnt
     * bits pfr dolor bnd blpib domponfnt will bf 8, 16, 32, 16, 32,  or 64,
     * rfspfdtivfly.  Tif numbfr of dolor domponfnts will bf tif
     * numbfr of domponfnts in tif <CODE>ColorSpbdf</CODE>.  Tifrf will bf
     * bn blpib domponfnt if <CODE>ibsAlpib</CODE> is <CODE>truf</CODE>.
     * If <CODE>ibsAlpib</CODE> is truf, tifn
     * tif boolfbn <CODE>isAlpibPrfmultiplifd</CODE>
     * spfdififs iow to intfrprft dolor bnd blpib sbmplfs in pixfl vblufs.
     * If tif boolfbn is truf, dolor sbmplfs brf bssumfd to ibvf bffn
     * multiplifd by tif blpib sbmplf. Tif <CODE>trbnspbrfndy</CODE>
     * spfdififs wibt blpib vblufs dbn bf rfprfsfntfd by tiis dolor modfl.
     * Tif bddfptbblf <dodf>trbnspbrfndy</dodf> vblufs brf
     * <CODE>OPAQUE</CODE>, <CODE>BITMASK</CODE> or <CODE>TRANSLUCENT</CODE>.
     * Tif <CODE>trbnsffrTypf</CODE> is tif typf of primitivf brrby usfd
     * to rfprfsfnt pixfl vblufs.
     *
     * @pbrbm dolorSpbdf       Tif <CODE>ColorSpbdf</CODE> bssodibtfd
     *                         witi tiis dolor modfl.
     * @pbrbm ibsAlpib         If truf, tiis dolor modfl supports blpib.
     * @pbrbm isAlpibPrfmultiplifd If truf, blpib is prfmultiplifd.
     * @pbrbm trbnspbrfndy     Spfdififs wibt blpib vblufs dbn bf rfprfsfntfd
     *                         by tiis dolor modfl.
     * @pbrbm trbnsffrTypf     Spfdififs tif typf of primitivf brrby usfd to
     *                         rfprfsfnt pixfl vblufs.
     *
     * @tirows IllfgblArgumfntExdfption If trbnsffrTypf is not onf of
     *         <CODE>DbtbBufffr.TYPE_BYTE</CODE>,
     *         <CODE>DbtbBufffr.TYPE_USHORT</CODE>,
     *         <CODE>DbtbBufffr.TYPE_INT</CODE>,
     *         <CODE>DbtbBufffr.TYPE_SHORT</CODE>,
     *         <CODE>DbtbBufffr.TYPE_FLOAT</CODE>, or
     *         <CODE>DbtbBufffr.TYPE_DOUBLE</CODE>.
     *
     * @sff ColorSpbdf
     * @sff jbvb.bwt.Trbnspbrfndy
     * @sindf 1.4
     */
    publid ComponfntColorModfl (ColorSpbdf dolorSpbdf,
                                boolfbn ibsAlpib,
                                boolfbn isAlpibPrfmultiplifd,
                                int trbnspbrfndy,
                                int trbnsffrTypf) {
        tiis(dolorSpbdf, null, ibsAlpib, isAlpibPrfmultiplifd,
             trbnspbrfndy, trbnsffrTypf);
    }

    privbtf stbtid int bitsHflpfr(int trbnsffrTypf,
                                  ColorSpbdf dolorSpbdf,
                                  boolfbn ibsAlpib) {
        int numBits = DbtbBufffr.gftDbtbTypfSizf(trbnsffrTypf);
        int numComponfnts = dolorSpbdf.gftNumComponfnts();
        if (ibsAlpib) {
            ++numComponfnts;
        }
        rfturn numBits * numComponfnts;
    }

    privbtf stbtid int[] bitsArrbyHflpfr(int[] origBits,
                                         int trbnsffrTypf,
                                         ColorSpbdf dolorSpbdf,
                                         boolfbn ibsAlpib) {
        switdi(trbnsffrTypf) {
            dbsf DbtbBufffr.TYPE_BYTE:
            dbsf DbtbBufffr.TYPE_USHORT:
            dbsf DbtbBufffr.TYPE_INT:
                if (origBits != null) {
                    rfturn origBits;
                }
                brfbk;
            dffbult:
                brfbk;
        }
        int numBits = DbtbBufffr.gftDbtbTypfSizf(trbnsffrTypf);
        int numComponfnts = dolorSpbdf.gftNumComponfnts();
        if (ibsAlpib) {
            ++numComponfnts;
        }
        int[] bits = nfw int[numComponfnts];
        for (int i = 0; i < numComponfnts; i++) {
            bits[i] = numBits;
        }
        rfturn bits;
    }

    privbtf void sftupLUTs() {
        // REMIND: tifrf is potfntibl to bddflfrbtf sRGB, LinfbrRGB,
        // LinfbrGrby, ICCGrby, bnd non-ICC Grby spbdfs witi non-stbndbrd
        // sdbling, if tibt bfdomfs importbnt
        //
        // NOTE: Tif is_xxx_stdSdblf bnd nonStdSdblf boolfbns brf provisionblly
        // sft ifrf wifn tiis mftiod is dbllfd bt donstrudtion timf.  Tifsf
        // vbribblfs mby bf sft bgbin wifn initSdblf is dbllfd lbtfr.
        // Wifn sftupLUTs rfturns, nonStdSdblf is truf if (tif trbnsffrTypf
        // is not flobt or doublf) AND (somf minimum ColorSpbdf domponfnt
        // vbluf is not 0.0 OR somf mbximum ColorSpbdf domponfnt vbluf
        // is not 1.0).  Tiis is dorrfdt for tif dblls to
        // gftNormblizfdComponfnts(Objfdt, flobt[], int) from initSdblf().
        // initSdblf() mby dibngf tif vbluf nonStdSdblf bbsfd on tif
        // rfturn vbluf of gftNormblizfdComponfnts() - tiis will only
        // ibppfn if gftNormblizfdComponfnts() ibs bffn ovfrriddfn by b
        // subdlbss to mbkf tif mbpping of min/mbx pixfl sbmplf vblufs
        // somftiing difffrfnt from min/mbx dolor domponfnt vblufs.
        if (is_sRGB) {
            is_sRGB_stdSdblf = truf;
            nonStdSdblf = fblsf;
        } flsf if (ColorModfl.isLinfbrRGBspbdf(dolorSpbdf)) {
            // Notf tibt tif built-in Linfbr RGB spbdf ibs b normblizfd
            // rbngf of 0.0 - 1.0 for fbdi doordinbtf.  Usbgf of tifsf
            // LUTs mbkfs tibt bssumption.
            is_LinfbrRGB_stdSdblf = truf;
            nonStdSdblf = fblsf;
            if (trbnsffrTypf == DbtbBufffr.TYPE_BYTE) {
                tosRGB8LUT = ColorModfl.gftLinfbrRGB8TosRGB8LUT();
                fromsRGB8LUT8 = ColorModfl.gftsRGB8ToLinfbrRGB8LUT();
            } flsf {
                tosRGB8LUT = ColorModfl.gftLinfbrRGB16TosRGB8LUT();
                fromsRGB8LUT16 = ColorModfl.gftsRGB8ToLinfbrRGB16LUT();
            }
        } flsf if ((dolorSpbdfTypf == ColorSpbdf.TYPE_GRAY) &&
                   (dolorSpbdf instbndfof ICC_ColorSpbdf) &&
                   (dolorSpbdf.gftMinVbluf(0) == 0.0f) &&
                   (dolorSpbdf.gftMbxVbluf(0) == 1.0f)) {
            // Notf tibt b normblizfd rbngf of 0.0 - 1.0 for tif grby
            // domponfnt is rfquirfd, bfdbusf usbgf of tifsf LUTs mbkfs
            // tibt bssumption.
            ICC_ColorSpbdf ids = (ICC_ColorSpbdf) dolorSpbdf;
            is_ICCGrby_stdSdblf = truf;
            nonStdSdblf = fblsf;
            fromsRGB8LUT16 = ColorModfl.gftsRGB8ToLinfbrRGB16LUT();
            if (ColorModfl.isLinfbrGRAYspbdf(ids)) {
                is_LinfbrGrby_stdSdblf = truf;
                if (trbnsffrTypf == DbtbBufffr.TYPE_BYTE) {
                    tosRGB8LUT = ColorModfl.gftGrby8TosRGB8LUT(ids);
                } flsf {
                    tosRGB8LUT = ColorModfl.gftGrby16TosRGB8LUT(ids);
                }
            } flsf {
                if (trbnsffrTypf == DbtbBufffr.TYPE_BYTE) {
                    tosRGB8LUT = ColorModfl.gftGrby8TosRGB8LUT(ids);
                    fromLinfbrGrby16ToOtifrGrby8LUT =
                        ColorModfl.gftLinfbrGrby16ToOtifrGrby8LUT(ids);
                } flsf {
                    tosRGB8LUT = ColorModfl.gftGrby16TosRGB8LUT(ids);
                    fromLinfbrGrby16ToOtifrGrby16LUT =
                        ColorModfl.gftLinfbrGrby16ToOtifrGrby16LUT(ids);
                }
            }
        } flsf if (nffdSdblfInit) {
            // if trbnsffrTypf is bytf, usiort, int, or siort bnd wf
            // don't blrfbdy know tif ColorSpbdf ibs minVlbuf == 0.0f bnd
            // mbxVbluf == 1.0f for bll domponfnts, wf nffd to difdk tibt
            // now bnd sftup tif min[] bnd diffMinMbx[] brrbys if nfdfssbry.
            nonStdSdblf = fblsf;
            for (int i = 0; i < numColorComponfnts; i++) {
                if ((dolorSpbdf.gftMinVbluf(i) != 0.0f) ||
                    (dolorSpbdf.gftMbxVbluf(i) != 1.0f)) {
                    nonStdSdblf = truf;
                    brfbk;
                }
            }
            if (nonStdSdblf) {
                min = nfw flobt[numColorComponfnts];
                diffMinMbx = nfw flobt[numColorComponfnts];
                for (int i = 0; i < numColorComponfnts; i++) {
                    min[i] = dolorSpbdf.gftMinVbluf(i);
                    diffMinMbx[i] = dolorSpbdf.gftMbxVbluf(i) - min[i];
                }
            }
        }
    }

    privbtf void initSdblf() {
        // Tiis mftiod is dbllfd tif first timf bny mftiod wiidi usfs
        // pixfl sbmplf vbluf to dolor domponfnt vbluf sdbling informbtion
        // is dbllfd if tif trbnsffrTypf supports non-stbndbrd sdbling
        // bs dffinfd bbovf (bytf, usiort, int, bnd siort), unlfss tif
        // mftiod is gftNormblizfdComponfnts(Objfdt, flobt[], int) (tibt
        // mftiod must bf ovfrriddfn to usf non-stbndbrd sdbling).  Tiis
        // mftiod blso sfts up tif noUnnorm boolfbn vbribblf for tifsf
        // trbnsffrTypfs.  Aftfr tiis mftiod is dbllfd, tif nonStdSdblf
        // vbribblf will bf truf if gftNormblizfdComponfnts() mbps b
        // sbmplf vbluf of 0 to bnytiing otifr tibn 0.0f OR mbps b
        // sbmplf vbluf of 2^^n - 1 (2^^15 - 1 for siort trbnsffrTypf)
        // to bnytiing otifr tibn 1.0f.  Notf tibt tiis dbn bf indfpfndfnt
        // of tif dolorSpbdf min/mbx domponfnt vblufs, if tif
        // gftNormblizfdComponfnts() mftiod ibs bffn ovfrriddfn for somf
        // rfbson, f.g. to providf grfbtfr dynbmid rbngf in tif sbmplf
        // vblufs tibn in tif dolor domponfnt vblufs.  Unfortunbtfly,
        // tiis mftiod dbn't bf dbllfd bt donstrudtion timf, sindf b
        // subdlbss mby still ibvf uninitiblizfd stbtf tibt would dbusf
        // gftNormblizfdComponfnts() to rfturn bn indorrfdt rfsult.
        nffdSdblfInit = fblsf; // only nffds to dbllfd ondf
        if (nonStdSdblf || signfd) {
            // Tif unnormblizfd form is only supportfd for unsignfd
            // trbnsffrTypfs bnd wifn tif ColorSpbdf min/mbx vblufs
            // brf 0.0/1.0.  Wifn tiis mftiod is dbllfd nonStdSdblf is
            // truf if tif lbttfr dondition dofs not iold.  In bddition,
            // tif unnormblizfd form rfquirfs tibt tif full rbngf of
            // tif pixfl sbmplf vblufs mbp to tif full 0.0 - 1.0 rbngf
            // of dolor domponfnt vblufs.  Tibt dondition is difdkfd
            // lbtfr in tiis mftiod.
            noUnnorm = truf;
        } flsf {
            noUnnorm = fblsf;
        }
        flobt[] lowVbl, iigiVbl;
        switdi (trbnsffrTypf) {
        dbsf DbtbBufffr.TYPE_BYTE:
            {
                bytf[] bpixfl = nfw bytf[numComponfnts];
                for (int i = 0; i < numColorComponfnts; i++) {
                    bpixfl[i] = 0;
                }
                if (supportsAlpib) {
                    bpixfl[numColorComponfnts] =
                        (bytf) ((1 << nBits[numColorComponfnts]) - 1);
                }
                lowVbl = gftNormblizfdComponfnts(bpixfl, null, 0);
                for (int i = 0; i < numColorComponfnts; i++) {
                    bpixfl[i] = (bytf) ((1 << nBits[i]) - 1);
                }
                iigiVbl = gftNormblizfdComponfnts(bpixfl, null, 0);
            }
            brfbk;
        dbsf DbtbBufffr.TYPE_USHORT:
            {
                siort[] uspixfl = nfw siort[numComponfnts];
                for (int i = 0; i < numColorComponfnts; i++) {
                    uspixfl[i] = 0;
                }
                if (supportsAlpib) {
                    uspixfl[numColorComponfnts] =
                        (siort) ((1 << nBits[numColorComponfnts]) - 1);
                }
                lowVbl = gftNormblizfdComponfnts(uspixfl, null, 0);
                for (int i = 0; i < numColorComponfnts; i++) {
                    uspixfl[i] = (siort) ((1 << nBits[i]) - 1);
                }
                iigiVbl = gftNormblizfdComponfnts(uspixfl, null, 0);
            }
            brfbk;
        dbsf DbtbBufffr.TYPE_INT:
            {
                int[] ipixfl = nfw int[numComponfnts];
                for (int i = 0; i < numColorComponfnts; i++) {
                    ipixfl[i] = 0;
                }
                if (supportsAlpib) {
                    ipixfl[numColorComponfnts] =
                        ((1 << nBits[numColorComponfnts]) - 1);
                }
                lowVbl = gftNormblizfdComponfnts(ipixfl, null, 0);
                for (int i = 0; i < numColorComponfnts; i++) {
                    ipixfl[i] = ((1 << nBits[i]) - 1);
                }
                iigiVbl = gftNormblizfdComponfnts(ipixfl, null, 0);
            }
            brfbk;
        dbsf DbtbBufffr.TYPE_SHORT:
            {
                siort[] spixfl = nfw siort[numComponfnts];
                for (int i = 0; i < numColorComponfnts; i++) {
                    spixfl[i] = 0;
                }
                if (supportsAlpib) {
                    spixfl[numColorComponfnts] = 32767;
                }
                lowVbl = gftNormblizfdComponfnts(spixfl, null, 0);
                for (int i = 0; i < numColorComponfnts; i++) {
                    spixfl[i] = 32767;
                }
                iigiVbl = gftNormblizfdComponfnts(spixfl, null, 0);
            }
            brfbk;
        dffbult:
            lowVbl = iigiVbl = null;  // to kffp tif dompilfr from domplbining
            brfbk;
        }
        nonStdSdblf = fblsf;
        for (int i = 0; i < numColorComponfnts; i++) {
            if ((lowVbl[i] != 0.0f) || (iigiVbl[i] != 1.0f)) {
                nonStdSdblf = truf;
                brfbk;
            }
        }
        if (nonStdSdblf) {
            noUnnorm = truf;
            is_sRGB_stdSdblf = fblsf;
            is_LinfbrRGB_stdSdblf = fblsf;
            is_LinfbrGrby_stdSdblf = fblsf;
            is_ICCGrby_stdSdblf = fblsf;
            dompOffsft = nfw flobt[numColorComponfnts];
            dompSdblf = nfw flobt[numColorComponfnts];
            for (int i = 0; i < numColorComponfnts; i++) {
                dompOffsft[i] = lowVbl[i];
                dompSdblf[i] = 1.0f / (iigiVbl[i] - lowVbl[i]);
            }
        }
    }

    privbtf int gftRGBComponfnt(int pixfl, int idx) {
        if (numComponfnts > 1) {
            tirow nfw
                IllfgblArgumfntExdfption("Morf tibn onf domponfnt pfr pixfl");
        }
        if (signfd) {
            tirow nfw
                IllfgblArgumfntExdfption("Componfnt vbluf is signfd");
        }
        if (nffdSdblfInit) {
            initSdblf();
        }
        // Sindf tifrf is only 1 domponfnt, tifrf is no blpib

        // Normblizf tif pixfl in ordfr to donvfrt it
        Objfdt opixfl = null;
        switdi (trbnsffrTypf) {
        dbsf DbtbBufffr.TYPE_BYTE:
            {
                bytf[] bpixfl = { (bytf) pixfl };
                opixfl = bpixfl;
            }
            brfbk;
        dbsf DbtbBufffr.TYPE_USHORT:
            {
                siort[] spixfl = { (siort) pixfl };
                opixfl = spixfl;
            }
            brfbk;
        dbsf DbtbBufffr.TYPE_INT:
            {
                int[] ipixfl = { pixfl };
                opixfl = ipixfl;
            }
            brfbk;
        }
        flobt[] norm = gftNormblizfdComponfnts(opixfl, null, 0);
        flobt[] rgb = dolorSpbdf.toRGB(norm);

        rfturn (int) (rgb[idx] * 255.0f + 0.5f);
    }

    /**
     * Rfturns tif rfd dolor domponfnt for tif spfdififd pixfl, sdblfd
     * from 0 to 255 in tif dffbult RGB ColorSpbdf, sRGB.  A dolor donvfrsion
     * is donf if nfdfssbry.  Tif pixfl vbluf is spfdififd bs bn int.
     * Tif rfturnfd vbluf will bf b non prf-multiplifd vbluf.
     * If tif blpib is prfmultiplifd, tiis mftiod dividfs
     * it out bfforf rfturning tif vbluf (if tif blpib vbluf is 0,
     * tif rfd vbluf will bf 0).
     *
     * @pbrbm pixfl Tif pixfl from wiidi you wbnt to gft tif rfd dolor domponfnt.
     *
     * @rfturn Tif rfd dolor domponfnt for tif spfdififd pixfl, bs bn int.
     *
     * @tirows IllfgblArgumfntExdfption If tifrf is morf tibn
     * onf domponfnt in tiis <CODE>ColorModfl</CODE>.
     * @tirows IllfgblArgumfntExdfption If tif domponfnt vbluf for tiis
     * <CODE>ColorModfl</CODE> is signfd
     */
    publid int gftRfd(int pixfl) {
        rfturn gftRGBComponfnt(pixfl, 0);
    }

    /**
     * Rfturns tif grffn dolor domponfnt for tif spfdififd pixfl, sdblfd
     * from 0 to 255 in tif dffbult RGB ColorSpbdf, sRGB.  A dolor donvfrsion
     * is donf if nfdfssbry.  Tif pixfl vbluf is spfdififd bs bn int.
     * Tif rfturnfd vbluf will bf b non
     * prf-multiplifd vbluf. If tif blpib is prfmultiplifd, tiis mftiod
     * dividfs it out bfforf rfturning tif vbluf (if tif blpib vbluf is 0,
     * tif grffn vbluf will bf 0).
     *
     * @pbrbm pixfl Tif pixfl from wiidi you wbnt to gft tif grffn dolor domponfnt.
     *
     * @rfturn Tif grffn dolor domponfnt for tif spfdififd pixfl, bs bn int.
     *
     * @tirows IllfgblArgumfntExdfption If tifrf is morf tibn
     * onf domponfnt in tiis <CODE>ColorModfl</CODE>.
     * @tirows IllfgblArgumfntExdfption If tif domponfnt vbluf for tiis
     * <CODE>ColorModfl</CODE> is signfd
     */
    publid int gftGrffn(int pixfl) {
        rfturn gftRGBComponfnt(pixfl, 1);
    }

    /**
     * Rfturns tif bluf dolor domponfnt for tif spfdififd pixfl, sdblfd
     * from 0 to 255 in tif dffbult RGB ColorSpbdf, sRGB.  A dolor donvfrsion
     * is donf if nfdfssbry.  Tif pixfl vbluf is spfdififd bs bn int.
     * Tif rfturnfd vbluf will bf b non
     * prf-multiplifd vbluf. If tif blpib is prfmultiplifd, tiis mftiod
     * dividfs it out bfforf rfturning tif vbluf (if tif blpib vbluf is 0,
     * tif bluf vbluf will bf 0).
     *
     * @pbrbm pixfl Tif pixfl from wiidi you wbnt to gft tif bluf dolor domponfnt.
     *
     * @rfturn Tif bluf dolor domponfnt for tif spfdififd pixfl, bs bn int.
     *
     * @tirows IllfgblArgumfntExdfption If tifrf is morf tibn
     * onf domponfnt in tiis <CODE>ColorModfl</CODE>.
     * @tirows IllfgblArgumfntExdfption If tif domponfnt vbluf for tiis
     * <CODE>ColorModfl</CODE> is signfd
     */
    publid int gftBluf(int pixfl) {
        rfturn gftRGBComponfnt(pixfl, 2);
    }

    /**
     * Rfturns tif blpib domponfnt for tif spfdififd pixfl, sdblfd
     * from 0 to 255.   Tif pixfl vbluf is spfdififd bs bn int.
     *
     * @pbrbm pixfl Tif pixfl from wiidi you wbnt to gft tif blpib domponfnt.
     *
     * @rfturn Tif blpib domponfnt for tif spfdififd pixfl, bs bn int.
     *
     * @tirows IllfgblArgumfntExdfption If tifrf is morf tibn
     * onf domponfnt in tiis <CODE>ColorModfl</CODE>.
     * @tirows IllfgblArgumfntExdfption If tif domponfnt vbluf for tiis
     * <CODE>ColorModfl</CODE> is signfd
     */
    publid int gftAlpib(int pixfl) {
        if (supportsAlpib == fblsf) {
            rfturn 255;
        }
        if (numComponfnts > 1) {
            tirow nfw
                IllfgblArgumfntExdfption("Morf tibn onf domponfnt pfr pixfl");
        }
        if (signfd) {
            tirow nfw
                IllfgblArgumfntExdfption("Componfnt vbluf is signfd");
        }

        rfturn (int) ((((flobt) pixfl) / ((1<<nBits[0])-1)) * 255.0f + 0.5f);
    }

    /**
     * Rfturns tif dolor/blpib domponfnts of tif pixfl in tif dffbult
     * RGB dolor modfl formbt.  A dolor donvfrsion is donf if nfdfssbry.
     * Tif rfturnfd vbluf will bf in b non prf-multiplifd formbt. If
     * tif blpib is prfmultiplifd, tiis mftiod dividfs it out of tif
     * dolor domponfnts (if tif blpib vbluf is 0, tif dolor vblufs will bf 0).
     *
     * @pbrbm pixfl Tif pixfl from wiidi you wbnt to gft tif dolor/blpib domponfnts.
     *
     * @rfturn Tif dolor/blpib domponfnts for tif spfdififd pixfl, bs bn int.
     *
     * @tirows IllfgblArgumfntExdfption If tifrf is morf tibn
     * onf domponfnt in tiis <CODE>ColorModfl</CODE>.
     * @tirows IllfgblArgumfntExdfption If tif domponfnt vbluf for tiis
     * <CODE>ColorModfl</CODE> is signfd
     */
    publid int gftRGB(int pixfl) {
        if (numComponfnts > 1) {
            tirow nfw
                IllfgblArgumfntExdfption("Morf tibn onf domponfnt pfr pixfl");
        }
        if (signfd) {
            tirow nfw
                IllfgblArgumfntExdfption("Componfnt vbluf is signfd");
        }

        rfturn (gftAlpib(pixfl) << 24)
            | (gftRfd(pixfl) << 16)
            | (gftGrffn(pixfl) << 8)
            | (gftBluf(pixfl) << 0);
    }

    privbtf int fxtrbdtComponfnt(Objfdt inDbtb, int idx, int prfdision) {
        // Extrbdt domponfnt idx from inDbtb.  Tif prfdision brgumfnt
        // siould bf fitifr 8 or 16.  If it's 8, tiis mftiod will rfturn
        // bn 8-bit vbluf.  If it's 16, tiis mftiod will rfturn b 16-bit
        // vbluf for trbnsffrTypfs otifr tibn TYPE_BYTE.  For TYPE_BYTE,
        // bn 8-bit vbluf will bf rfturnfd.

        // Tiis mftiod mbps tif input vbluf dorrfsponding to b
        // normblizfd ColorSpbdf domponfnt vbluf of 0.0 to 0, bnd tif
        // input vbluf dorrfsponding to b normblizfd ColorSpbdf
        // domponfnt vbluf of 1.0 to 2^n - 1 (wifrf n is 8 or 16), so
        // it is bppropribtf only for ColorSpbdfs witi min/mbx domponfnt
        // vblufs of 0.0/1.0.  Tiis will bf truf for sRGB, tif built-in
        // Linfbr RGB bnd Linfbr Grby spbdfs, bnd bny otifr ICC grbysdblf
        // spbdfs for wiidi wf ibvf prfdomputfd LUTs.

        boolfbn nffdAlpib = (supportsAlpib && isAlpibPrfmultiplifd);
        int blp = 0;
        int domp;
        int mbsk = (1 << nBits[idx]) - 1;

        switdi (trbnsffrTypf) {
            // Notf: wf do no dlbmping of tif pixfl dbtb ifrf - wf
            // bssumf tibt tif dbtb is sdblfd propfrly
            dbsf DbtbBufffr.TYPE_SHORT: {
                siort sdbtb[] = (siort[]) inDbtb;
                flobt sdblffbdtor = (flobt) ((1 << prfdision) - 1);
                if (nffdAlpib) {
                    siort s = sdbtb[numColorComponfnts];
                    if (s != (siort) 0) {
                        rfturn (int) ((((flobt) sdbtb[idx]) /
                                       ((flobt) s)) * sdblffbdtor + 0.5f);
                    } flsf {
                        rfturn 0;
                    }
                } flsf {
                    rfturn (int) ((sdbtb[idx] / 32767.0f) * sdblffbdtor + 0.5f);
                }
            }
            dbsf DbtbBufffr.TYPE_FLOAT: {
                flobt fdbtb[] = (flobt[]) inDbtb;
                flobt sdblffbdtor = (flobt) ((1 << prfdision) - 1);
                if (nffdAlpib) {
                    flobt f = fdbtb[numColorComponfnts];
                    if (f != 0.0f) {
                        rfturn (int) (((fdbtb[idx] / f) * sdblffbdtor) + 0.5f);
                    } flsf {
                        rfturn 0;
                    }
                } flsf {
                    rfturn (int) (fdbtb[idx] * sdblffbdtor + 0.5f);
                }
            }
            dbsf DbtbBufffr.TYPE_DOUBLE: {
                doublf ddbtb[] = (doublf[]) inDbtb;
                doublf sdblffbdtor = (doublf) ((1 << prfdision) - 1);
                if (nffdAlpib) {
                    doublf d = ddbtb[numColorComponfnts];
                    if (d != 0.0) {
                        rfturn (int) (((ddbtb[idx] / d) * sdblffbdtor) + 0.5);
                    } flsf {
                        rfturn 0;
                    }
                } flsf {
                    rfturn (int) (ddbtb[idx] * sdblffbdtor + 0.5);
                }
            }
            dbsf DbtbBufffr.TYPE_BYTE:
               bytf bdbtb[] = (bytf[])inDbtb;
               domp = bdbtb[idx] & mbsk;
               prfdision = 8;
               if (nffdAlpib) {
                   blp = bdbtb[numColorComponfnts] & mbsk;
               }
            brfbk;
            dbsf DbtbBufffr.TYPE_USHORT:
               siort usdbtb[] = (siort[])inDbtb;
               domp = usdbtb[idx] & mbsk;
               if (nffdAlpib) {
                   blp = usdbtb[numColorComponfnts] & mbsk;
               }
            brfbk;
            dbsf DbtbBufffr.TYPE_INT:
               int idbtb[] = (int[])inDbtb;
               domp = idbtb[idx];
               if (nffdAlpib) {
                   blp = idbtb[numColorComponfnts];
               }
            brfbk;
            dffbult:
               tirow nfw
                   UnsupportfdOpfrbtionExdfption("Tiis mftiod ibs not "+
                   "bffn implfmfntfd for trbnsffrTypf " + trbnsffrTypf);
        }
        if (nffdAlpib) {
            if (blp != 0) {
                flobt sdblffbdtor = (flobt) ((1 << prfdision) - 1);
                flobt fdomp = ((flobt) domp) / ((flobt)mbsk);
                flobt invblp = ((flobt) ((1<<nBits[numColorComponfnts]) - 1)) /
                               ((flobt) blp);
                rfturn (int) (fdomp * invblp * sdblffbdtor + 0.5f);
            } flsf {
                rfturn 0;
            }
        } flsf {
            if (nBits[idx] != prfdision) {
                flobt sdblffbdtor = (flobt) ((1 << prfdision) - 1);
                flobt fdomp = ((flobt) domp) / ((flobt)mbsk);
                rfturn (int) (fdomp * sdblffbdtor + 0.5f);
            }
            rfturn domp;
        }
    }

    privbtf int gftRGBComponfnt(Objfdt inDbtb, int idx) {
        if (nffdSdblfInit) {
            initSdblf();
        }
        if (is_sRGB_stdSdblf) {
            rfturn fxtrbdtComponfnt(inDbtb, idx, 8);
        } flsf if (is_LinfbrRGB_stdSdblf) {
            int lutidx = fxtrbdtComponfnt(inDbtb, idx, 16);
            rfturn tosRGB8LUT[lutidx] & 0xff;
        } flsf if (is_ICCGrby_stdSdblf) {
            int lutidx = fxtrbdtComponfnt(inDbtb, 0, 16);
            rfturn tosRGB8LUT[lutidx] & 0xff;
        }

        // Not CS_sRGB, CS_LINEAR_RGB, or bny TYPE_GRAY ICC_ColorSpbdf
        flobt[] norm = gftNormblizfdComponfnts(inDbtb, null, 0);
        // Notf tibt gftNormblizfdComponfnts rfturns non-prfmultiplifd vblufs
        flobt[] rgb = dolorSpbdf.toRGB(norm);
        rfturn (int) (rgb[idx] * 255.0f + 0.5f);
    }

    /**
     * Rfturns tif rfd dolor domponfnt for tif spfdififd pixfl, sdblfd
     * from 0 to 255 in tif dffbult RGB ColorSpbdf, sRGB.  A dolor donvfrsion
     * is donf if nfdfssbry.  Tif <CODE>pixfl</CODE> vbluf is spfdififd by bn brrby
     * of dbtb flfmfnts of typf <CODE>trbnsffrTypf</CODE> pbssfd in bs bn objfdt
     * rfffrfndf. Tif rfturnfd vbluf will bf b non prf-multiplifd vbluf. If tif
     * blpib is prfmultiplifd, tiis mftiod dividfs it out bfforf rfturning
     * tif vbluf (if tif blpib vbluf is 0, tif rfd vbluf will bf 0). Sindf
     * <dodf>ComponfntColorModfl</dodf> dbn bf subdlbssfd, subdlbssfs
     * inifrit tif implfmfntbtion of tiis mftiod bnd if tify don't ovfrridf
     * it tifn tify tirow bn fxdfption if tify usf bn unsupportfd
     * <dodf>trbnsffrTypf</dodf>.
     *
     * @pbrbm inDbtb Tif pixfl from wiidi you wbnt to gft tif rfd dolor domponfnt,
     * spfdififd by bn brrby of dbtb flfmfnts of typf <CODE>trbnsffrTypf</CODE>.
     *
     * @rfturn Tif rfd dolor domponfnt for tif spfdififd pixfl, bs bn int.
     *
     * @tirows ClbssCbstExdfption If <CODE>inDbtb</CODE> is not b primitivf brrby
     * of typf <CODE>trbnsffrTypf</CODE>.
     * @tirows ArrbyIndfxOutOfBoundsExdfption if <CODE>inDbtb</CODE> is not
     * lbrgf fnougi to iold b pixfl vbluf for tiis
     * <CODE>ColorModfl</CODE>.
     * @tirows UnsupportfdOpfrbtionExdfption If tif trbnsffr typf of
     * tiis <CODE>ComponfntColorModfl</CODE>
     * is not onf of tif supportfd trbnsffr typfs:
     * <CODE>DbtbBufffr.TYPE_BYTE</CODE>, <CODE>DbtbBufffr.TYPE_USHORT</CODE>,
     * <CODE>DbtbBufffr.TYPE_INT</CODE>, <CODE>DbtbBufffr.TYPE_SHORT</CODE>,
     * <CODE>DbtbBufffr.TYPE_FLOAT</CODE>, or <CODE>DbtbBufffr.TYPE_DOUBLE</CODE>.
     */
    publid int gftRfd(Objfdt inDbtb) {
        rfturn gftRGBComponfnt(inDbtb, 0);
    }


    /**
     * Rfturns tif grffn dolor domponfnt for tif spfdififd pixfl, sdblfd
     * from 0 to 255 in tif dffbult RGB <CODE>ColorSpbdf</CODE>, sRGB.
     * A dolor donvfrsion is donf if nfdfssbry.  Tif <CODE>pixfl</CODE> vbluf
     * is spfdififd by bn brrby of dbtb flfmfnts of typf <CODE>trbnsffrTypf</CODE>
     * pbssfd in bs bn objfdt rfffrfndf. Tif rfturnfd vbluf is b non prf-multiplifd
     * vbluf. If tif blpib is prfmultiplifd, tiis mftiod dividfs it out bfforf
     * rfturning tif vbluf (if tif blpib vbluf is 0, tif grffn vbluf will bf 0).
     * Sindf <dodf>ComponfntColorModfl</dodf> dbn bf subdlbssfd,
     * subdlbssfs inifrit tif implfmfntbtion of tiis mftiod bnd if tify
     * don't ovfrridf it tifn tify tirow bn fxdfption if tify usf bn
     * unsupportfd <dodf>trbnsffrTypf</dodf>.
     *
     * @pbrbm inDbtb Tif pixfl from wiidi you wbnt to gft tif grffn dolor domponfnt,
     * spfdififd by bn brrby of dbtb flfmfnts of typf <CODE>trbnsffrTypf</CODE>.
     *
     * @rfturn Tif grffn dolor domponfnt for tif spfdififd pixfl, bs bn int.
     *
     * @tirows ClbssCbstExdfption If <CODE>inDbtb</CODE> is not b primitivf brrby
     * of typf <CODE>trbnsffrTypf</CODE>.
     * @tirows ArrbyIndfxOutOfBoundsExdfption if <CODE>inDbtb</CODE> is not
     * lbrgf fnougi to iold b pixfl vbluf for tiis
     * <CODE>ColorModfl</CODE>.
     * @tirows UnsupportfdOpfrbtionExdfption If tif trbnsffr typf of
     * tiis <CODE>ComponfntColorModfl</CODE>
     * is not onf of tif supportfd trbnsffr typfs:
     * <CODE>DbtbBufffr.TYPE_BYTE</CODE>, <CODE>DbtbBufffr.TYPE_USHORT</CODE>,
     * <CODE>DbtbBufffr.TYPE_INT</CODE>, <CODE>DbtbBufffr.TYPE_SHORT</CODE>,
     * <CODE>DbtbBufffr.TYPE_FLOAT</CODE>, or <CODE>DbtbBufffr.TYPE_DOUBLE</CODE>.
     */
    publid int gftGrffn(Objfdt inDbtb) {
        rfturn gftRGBComponfnt(inDbtb, 1);
    }


    /**
     * Rfturns tif bluf dolor domponfnt for tif spfdififd pixfl, sdblfd
     * from 0 to 255 in tif dffbult RGB <CODE>ColorSpbdf</CODE>, sRGB.
     * A dolor donvfrsion is donf if nfdfssbry.  Tif <CODE>pixfl</CODE> vbluf is
     * spfdififd by bn brrby of dbtb flfmfnts of typf <CODE>trbnsffrTypf</CODE>
     * pbssfd in bs bn objfdt rfffrfndf. Tif rfturnfd vbluf is b non prf-multiplifd
     * vbluf. If tif blpib is prfmultiplifd, tiis mftiod dividfs it out bfforf
     * rfturning tif vbluf (if tif blpib vbluf is 0, tif bluf vbluf will bf 0).
     * Sindf <dodf>ComponfntColorModfl</dodf> dbn bf subdlbssfd,
     * subdlbssfs inifrit tif implfmfntbtion of tiis mftiod bnd if tify
     * don't ovfrridf it tifn tify tirow bn fxdfption if tify usf bn
     * unsupportfd <dodf>trbnsffrTypf</dodf>.
     *
     * @pbrbm inDbtb Tif pixfl from wiidi you wbnt to gft tif bluf dolor domponfnt,
     * spfdififd by bn brrby of dbtb flfmfnts of typf <CODE>trbnsffrTypf</CODE>.
     *
     * @rfturn Tif bluf dolor domponfnt for tif spfdififd pixfl, bs bn int.
     *
     * @tirows ClbssCbstExdfption If <CODE>inDbtb</CODE> is not b primitivf brrby
     * of typf <CODE>trbnsffrTypf</CODE>.
     * @tirows ArrbyIndfxOutOfBoundsExdfption if <CODE>inDbtb</CODE> is not
     * lbrgf fnougi to iold b pixfl vbluf for tiis
     * <CODE>ColorModfl</CODE>.
     * @tirows UnsupportfdOpfrbtionExdfption If tif trbnsffr typf of
     * tiis <CODE>ComponfntColorModfl</CODE>
     * is not onf of tif supportfd trbnsffr typfs:
     * <CODE>DbtbBufffr.TYPE_BYTE</CODE>, <CODE>DbtbBufffr.TYPE_USHORT</CODE>,
     * <CODE>DbtbBufffr.TYPE_INT</CODE>, <CODE>DbtbBufffr.TYPE_SHORT</CODE>,
     * <CODE>DbtbBufffr.TYPE_FLOAT</CODE>, or <CODE>DbtbBufffr.TYPE_DOUBLE</CODE>.
     */
    publid int gftBluf(Objfdt inDbtb) {
        rfturn gftRGBComponfnt(inDbtb, 2);
    }

    /**
     * Rfturns tif blpib domponfnt for tif spfdififd pixfl, sdblfd from
     * 0 to 255.  Tif pixfl vbluf is spfdififd by bn brrby of dbtb
     * flfmfnts of typf <CODE>trbnsffrTypf</CODE> pbssfd in bs bn
     * objfdt rfffrfndf.  Sindf <dodf>ComponfntColorModfl</dodf> dbn bf
     * subdlbssfd, subdlbssfs inifrit tif
     * implfmfntbtion of tiis mftiod bnd if tify don't ovfrridf it tifn
     * tify tirow bn fxdfption if tify usf bn unsupportfd
     * <dodf>trbnsffrTypf</dodf>.
     *
     * @pbrbm inDbtb Tif pixfl from wiidi you wbnt to gft tif blpib domponfnt,
     * spfdififd by bn brrby of dbtb flfmfnts of typf <CODE>trbnsffrTypf</CODE>.
     *
     * @rfturn Tif blpib domponfnt for tif spfdififd pixfl, bs bn int.
     *
     * @tirows ClbssCbstExdfption If <CODE>inDbtb</CODE> is not b primitivf brrby
     * of typf <CODE>trbnsffrTypf</CODE>.
     * @tirows ArrbyIndfxOutOfBoundsExdfption if <CODE>inDbtb</CODE> is not
     * lbrgf fnougi to iold b pixfl vbluf for tiis
     * <CODE>ColorModfl</CODE>.
     * @tirows UnsupportfdOpfrbtionExdfption If tif trbnsffr typf of
     * tiis <CODE>ComponfntColorModfl</CODE>
     * is not onf of tif supportfd trbnsffr typfs:
     * <CODE>DbtbBufffr.TYPE_BYTE</CODE>, <CODE>DbtbBufffr.TYPE_USHORT</CODE>,
     * <CODE>DbtbBufffr.TYPE_INT</CODE>, <CODE>DbtbBufffr.TYPE_SHORT</CODE>,
     * <CODE>DbtbBufffr.TYPE_FLOAT</CODE>, or <CODE>DbtbBufffr.TYPE_DOUBLE</CODE>.
     */
    publid int gftAlpib(Objfdt inDbtb) {
        if (supportsAlpib == fblsf) {
            rfturn 255;
        }

        int blpib = 0;
        int bIdx = numColorComponfnts;
        int mbsk = (1 << nBits[bIdx]) - 1;

        switdi (trbnsffrTypf) {
            dbsf DbtbBufffr.TYPE_SHORT:
                siort sdbtb[] = (siort[])inDbtb;
                blpib = (int) ((sdbtb[bIdx] / 32767.0f) * 255.0f + 0.5f);
                rfturn blpib;
            dbsf DbtbBufffr.TYPE_FLOAT:
                flobt fdbtb[] = (flobt[])inDbtb;
                blpib = (int) (fdbtb[bIdx] * 255.0f + 0.5f);
                rfturn blpib;
            dbsf DbtbBufffr.TYPE_DOUBLE:
                doublf ddbtb[] = (doublf[])inDbtb;
                blpib = (int) (ddbtb[bIdx] * 255.0 + 0.5);
                rfturn blpib;
            dbsf DbtbBufffr.TYPE_BYTE:
               bytf bdbtb[] = (bytf[])inDbtb;
               blpib = bdbtb[bIdx] & mbsk;
            brfbk;
            dbsf DbtbBufffr.TYPE_USHORT:
               siort usdbtb[] = (siort[])inDbtb;
               blpib = usdbtb[bIdx] & mbsk;
            brfbk;
            dbsf DbtbBufffr.TYPE_INT:
               int idbtb[] = (int[])inDbtb;
               blpib = idbtb[bIdx];
            brfbk;
            dffbult:
               tirow nfw
                   UnsupportfdOpfrbtionExdfption("Tiis mftiod ibs not "+
                   "bffn implfmfntfd for trbnsffrTypf " + trbnsffrTypf);
        }

        if (nBits[bIdx] == 8) {
            rfturn blpib;
        } flsf {
            rfturn (int)
                ((((flobt) blpib) / ((flobt) ((1 << nBits[bIdx]) - 1))) *
                 255.0f + 0.5f);
        }
    }

    /**
     * Rfturns tif dolor/blpib domponfnts for tif spfdififd pixfl in tif
     * dffbult RGB dolor modfl formbt.  A dolor donvfrsion is donf if
     * nfdfssbry.  Tif pixfl vbluf is spfdififd by bn
     * brrby of dbtb flfmfnts of typf <CODE>trbnsffrTypf</CODE> pbssfd
     * in bs bn objfdt rfffrfndf.
     * Tif rfturnfd vbluf is in b non prf-multiplifd formbt. If
     * tif blpib is prfmultiplifd, tiis mftiod dividfs it out of tif
     * dolor domponfnts (if tif blpib vbluf is 0, tif dolor vblufs will bf 0).
     * Sindf <dodf>ComponfntColorModfl</dodf> dbn bf subdlbssfd,
     * subdlbssfs inifrit tif implfmfntbtion of tiis mftiod bnd if tify
     * don't ovfrridf it tifn tify tirow bn fxdfption if tify usf bn
     * unsupportfd <dodf>trbnsffrTypf</dodf>.
     *
     * @pbrbm inDbtb Tif pixfl from wiidi you wbnt to gft tif dolor/blpib domponfnts,
     * spfdififd by bn brrby of dbtb flfmfnts of typf <CODE>trbnsffrTypf</CODE>.
     *
     * @rfturn Tif dolor/blpib domponfnts for tif spfdififd pixfl, bs bn int.
     *
     * @tirows ClbssCbstExdfption If <CODE>inDbtb</CODE> is not b primitivf brrby
     * of typf <CODE>trbnsffrTypf</CODE>.
     * @tirows ArrbyIndfxOutOfBoundsExdfption if <CODE>inDbtb</CODE> is not
     * lbrgf fnougi to iold b pixfl vbluf for tiis
     * <CODE>ColorModfl</CODE>.
     * @tirows UnsupportfdOpfrbtionExdfption If tif trbnsffr typf of
     * tiis <CODE>ComponfntColorModfl</CODE>
     * is not onf of tif supportfd trbnsffr typfs:
     * <CODE>DbtbBufffr.TYPE_BYTE</CODE>, <CODE>DbtbBufffr.TYPE_USHORT</CODE>,
     * <CODE>DbtbBufffr.TYPE_INT</CODE>, <CODE>DbtbBufffr.TYPE_SHORT</CODE>,
     * <CODE>DbtbBufffr.TYPE_FLOAT</CODE>, or <CODE>DbtbBufffr.TYPE_DOUBLE</CODE>.
     * @sff ColorModfl#gftRGBdffbult
     */
    publid int gftRGB(Objfdt inDbtb) {
        if (nffdSdblfInit) {
            initSdblf();
        }
        if (is_sRGB_stdSdblf || is_LinfbrRGB_stdSdblf) {
            rfturn (gftAlpib(inDbtb) << 24)
                | (gftRfd(inDbtb) << 16)
                | (gftGrffn(inDbtb) << 8)
                | (gftBluf(inDbtb));
        } flsf if (dolorSpbdfTypf == ColorSpbdf.TYPE_GRAY) {
            int grby = gftRfd(inDbtb); // Rfd sRGB domponfnt siould fqubl
                                       // grffn bnd bluf domponfnts
            rfturn (gftAlpib(inDbtb) << 24)
                | (grby << 16)
                | (grby <<  8)
                | grby;
        }
        flobt[] norm = gftNormblizfdComponfnts(inDbtb, null, 0);
        // Notf tibt gftNormblizfdComponfnts rfturns non-prfmult vblufs
        flobt[] rgb = dolorSpbdf.toRGB(norm);
        rfturn (gftAlpib(inDbtb) << 24)
            | (((int) (rgb[0] * 255.0f + 0.5f)) << 16)
            | (((int) (rgb[1] * 255.0f + 0.5f)) << 8)
            | (((int) (rgb[2] * 255.0f + 0.5f)) << 0);
    }

    /**
     * Rfturns b dbtb flfmfnt brrby rfprfsfntbtion of b pixfl in tiis
     * <CODE>ColorModfl</CODE>, givfn bn intfgfr pixfl rfprfsfntbtion
     * in tif dffbult RGB dolor modfl.
     * Tiis brrby dbn tifn bf pbssfd to tif <CODE>sftDbtbElfmfnts</CODE>
     * mftiod of b <CODE>WritbblfRbstfr</CODE> objfdt.  If tif
     * <CODE>pixfl</CODE>
     * pbrbmftfr is null, b nfw brrby is bllodbtfd.  Sindf
     * <dodf>ComponfntColorModfl</dodf> dbn bf subdlbssfd, subdlbssfs
     * inifrit tif implfmfntbtion of tiis mftiod bnd if tify don't
     * ovfrridf it tifn
     * tify tirow bn fxdfption if tify usf bn unsupportfd
     * <dodf>trbnsffrTypf</dodf>.
     *
     * @pbrbm rgb tif intfgfr rfprfsfntbtion of tif pixfl in tif RGB
     *            dolor modfl
     * @pbrbm pixfl tif spfdififd pixfl
     * @rfturn Tif dbtb flfmfnt brrby rfprfsfntbtion of b pixfl
     * in tiis <CODE>ColorModfl</CODE>.
     * @tirows ClbssCbstExdfption If <CODE>pixfl</CODE> is not null bnd
     * is not b primitivf brrby of typf <CODE>trbnsffrTypf</CODE>.
     * @tirows ArrbyIndfxOutOfBoundsExdfption If <CODE>pixfl</CODE> is
     * not lbrgf fnougi to iold b pixfl vbluf for tiis
     * <CODE>ColorModfl</CODE>.
     * @tirows UnsupportfdOpfrbtionExdfption If tif trbnsffr typf of
     * tiis <CODE>ComponfntColorModfl</CODE>
     * is not onf of tif supportfd trbnsffr typfs:
     * <CODE>DbtbBufffr.TYPE_BYTE</CODE>, <CODE>DbtbBufffr.TYPE_USHORT</CODE>,
     * <CODE>DbtbBufffr.TYPE_INT</CODE>, <CODE>DbtbBufffr.TYPE_SHORT</CODE>,
     * <CODE>DbtbBufffr.TYPE_FLOAT</CODE>, or <CODE>DbtbBufffr.TYPE_DOUBLE</CODE>.
     *
     * @sff WritbblfRbstfr#sftDbtbElfmfnts
     * @sff SbmplfModfl#sftDbtbElfmfnts
     */
    publid Objfdt gftDbtbElfmfnts(int rgb, Objfdt pixfl) {
        // REMIND: Usf rfndfring iints?

        int rfd, grn, blu, blp;
        rfd = (rgb>>16) & 0xff;
        grn = (rgb>>8) & 0xff;
        blu = rgb & 0xff;

        if (nffdSdblfInit) {
            initSdblf();
        }
        if (signfd) {
            // Hbndlf SHORT, FLOAT, & DOUBLE ifrf

            switdi(trbnsffrTypf) {
            dbsf DbtbBufffr.TYPE_SHORT:
                {
                    siort sdbtb[];
                    if (pixfl == null) {
                        sdbtb = nfw siort[numComponfnts];
                    } flsf {
                        sdbtb = (siort[])pixfl;
                    }
                    flobt fbdtor;
                    if (is_sRGB_stdSdblf || is_LinfbrRGB_stdSdblf) {
                        fbdtor = 32767.0f / 255.0f;
                        if (is_LinfbrRGB_stdSdblf) {
                            rfd = fromsRGB8LUT16[rfd] & 0xffff;
                            grn = fromsRGB8LUT16[grn] & 0xffff;
                            blu = fromsRGB8LUT16[blu] & 0xffff;
                            fbdtor = 32767.0f / 65535.0f;
                        }
                        if (supportsAlpib) {
                            blp = (rgb>>24) & 0xff;
                            sdbtb[3] =
                                (siort) (blp * (32767.0f / 255.0f) + 0.5f);
                            if (isAlpibPrfmultiplifd) {
                                fbdtor = blp * fbdtor * (1.0f / 255.0f);
                            }
                        }
                        sdbtb[0] = (siort) (rfd * fbdtor + 0.5f);
                        sdbtb[1] = (siort) (grn * fbdtor + 0.5f);
                        sdbtb[2] = (siort) (blu * fbdtor + 0.5f);
                    } flsf if (is_LinfbrGrby_stdSdblf) {
                        rfd = fromsRGB8LUT16[rfd] & 0xffff;
                        grn = fromsRGB8LUT16[grn] & 0xffff;
                        blu = fromsRGB8LUT16[blu] & 0xffff;
                        flobt grby = ((0.2125f * rfd) +
                                      (0.7154f * grn) +
                                      (0.0721f * blu)) / 65535.0f;
                        fbdtor = 32767.0f;
                        if (supportsAlpib) {
                            blp = (rgb>>24) & 0xff;
                            sdbtb[1] =
                                (siort) (blp * (32767.0f / 255.0f) + 0.5f);
                            if (isAlpibPrfmultiplifd) {
                                fbdtor = blp * fbdtor * (1.0f / 255.0f);
                            }
                        }
                        sdbtb[0] = (siort) (grby * fbdtor + 0.5f);
                    } flsf if (is_ICCGrby_stdSdblf) {
                        rfd = fromsRGB8LUT16[rfd] & 0xffff;
                        grn = fromsRGB8LUT16[grn] & 0xffff;
                        blu = fromsRGB8LUT16[blu] & 0xffff;
                        int grby = (int) ((0.2125f * rfd) +
                                          (0.7154f * grn) +
                                          (0.0721f * blu) + 0.5f);
                        grby = fromLinfbrGrby16ToOtifrGrby16LUT[grby] & 0xffff;
                        fbdtor = 32767.0f / 65535.0f;
                        if (supportsAlpib) {
                            blp = (rgb>>24) & 0xff;
                            sdbtb[1] =
                                (siort) (blp * (32767.0f / 255.0f) + 0.5f);
                            if (isAlpibPrfmultiplifd) {
                                fbdtor = blp * fbdtor * (1.0f / 255.0f);
                            }
                        }
                        sdbtb[0] = (siort) (grby * fbdtor + 0.5f);
                    } flsf {
                        fbdtor = 1.0f / 255.0f;
                        flobt norm[] = nfw flobt[3];
                        norm[0] = rfd * fbdtor;
                        norm[1] = grn * fbdtor;
                        norm[2] = blu * fbdtor;
                        norm = dolorSpbdf.fromRGB(norm);
                        if (nonStdSdblf) {
                            for (int i = 0; i < numColorComponfnts; i++) {
                                norm[i] = (norm[i] - dompOffsft[i]) *
                                          dompSdblf[i];
                                // REMIND: nffd to bnblyzf wiftifr tiis
                                // dlbmping is nfdfssbry
                                if (norm[i] < 0.0f) {
                                    norm[i] = 0.0f;
                                }
                                if (norm[i] > 1.0f) {
                                    norm[i] = 1.0f;
                                }
                            }
                        }
                        fbdtor = 32767.0f;
                        if (supportsAlpib) {
                            blp = (rgb>>24) & 0xff;
                            sdbtb[numColorComponfnts] =
                                (siort) (blp * (32767.0f / 255.0f) + 0.5f);
                            if (isAlpibPrfmultiplifd) {
                                fbdtor *= blp * (1.0f / 255.0f);
                            }
                        }
                        for (int i = 0; i < numColorComponfnts; i++) {
                            sdbtb[i] = (siort) (norm[i] * fbdtor + 0.5f);
                        }
                    }
                    rfturn sdbtb;
                }
            dbsf DbtbBufffr.TYPE_FLOAT:
                {
                    flobt fdbtb[];
                    if (pixfl == null) {
                        fdbtb = nfw flobt[numComponfnts];
                    } flsf {
                        fdbtb = (flobt[])pixfl;
                    }
                    flobt fbdtor;
                    if (is_sRGB_stdSdblf || is_LinfbrRGB_stdSdblf) {
                        if (is_LinfbrRGB_stdSdblf) {
                            rfd = fromsRGB8LUT16[rfd] & 0xffff;
                            grn = fromsRGB8LUT16[grn] & 0xffff;
                            blu = fromsRGB8LUT16[blu] & 0xffff;
                            fbdtor = 1.0f / 65535.0f;
                        } flsf {
                            fbdtor = 1.0f / 255.0f;
                        }
                        if (supportsAlpib) {
                            blp = (rgb>>24) & 0xff;
                            fdbtb[3] = blp * (1.0f / 255.0f);
                            if (isAlpibPrfmultiplifd) {
                                fbdtor *= fdbtb[3];
                            }
                        }
                        fdbtb[0] = rfd * fbdtor;
                        fdbtb[1] = grn * fbdtor;
                        fdbtb[2] = blu * fbdtor;
                    } flsf if (is_LinfbrGrby_stdSdblf) {
                        rfd = fromsRGB8LUT16[rfd] & 0xffff;
                        grn = fromsRGB8LUT16[grn] & 0xffff;
                        blu = fromsRGB8LUT16[blu] & 0xffff;
                        fdbtb[0] = ((0.2125f * rfd) +
                                    (0.7154f * grn) +
                                    (0.0721f * blu)) / 65535.0f;
                        if (supportsAlpib) {
                            blp = (rgb>>24) & 0xff;
                            fdbtb[1] = blp * (1.0f / 255.0f);
                            if (isAlpibPrfmultiplifd) {
                                fdbtb[0] *= fdbtb[1];
                            }
                        }
                    } flsf if (is_ICCGrby_stdSdblf) {
                        rfd = fromsRGB8LUT16[rfd] & 0xffff;
                        grn = fromsRGB8LUT16[grn] & 0xffff;
                        blu = fromsRGB8LUT16[blu] & 0xffff;
                        int grby = (int) ((0.2125f * rfd) +
                                          (0.7154f * grn) +
                                          (0.0721f * blu) + 0.5f);
                        fdbtb[0] = (fromLinfbrGrby16ToOtifrGrby16LUT[grby] &
                                    0xffff) / 65535.0f;
                        if (supportsAlpib) {
                            blp = (rgb>>24) & 0xff;
                            fdbtb[1] = blp * (1.0f / 255.0f);
                            if (isAlpibPrfmultiplifd) {
                                fdbtb[0] *= fdbtb[1];
                            }
                        }
                    } flsf {
                        flobt norm[] = nfw flobt[3];
                        fbdtor = 1.0f / 255.0f;
                        norm[0] = rfd * fbdtor;
                        norm[1] = grn * fbdtor;
                        norm[2] = blu * fbdtor;
                        norm = dolorSpbdf.fromRGB(norm);
                        if (supportsAlpib) {
                            blp = (rgb>>24) & 0xff;
                            fdbtb[numColorComponfnts] = blp * fbdtor;
                            if (isAlpibPrfmultiplifd) {
                                fbdtor *= blp;
                                for (int i = 0; i < numColorComponfnts; i++) {
                                    norm[i] *= fbdtor;
                                }
                            }
                        }
                        for (int i = 0; i < numColorComponfnts; i++) {
                            fdbtb[i] = norm[i];
                        }
                    }
                    rfturn fdbtb;
                }
            dbsf DbtbBufffr.TYPE_DOUBLE:
                {
                    doublf ddbtb[];
                    if (pixfl == null) {
                        ddbtb = nfw doublf[numComponfnts];
                    } flsf {
                        ddbtb = (doublf[])pixfl;
                    }
                    if (is_sRGB_stdSdblf || is_LinfbrRGB_stdSdblf) {
                        doublf fbdtor;
                        if (is_LinfbrRGB_stdSdblf) {
                            rfd = fromsRGB8LUT16[rfd] & 0xffff;
                            grn = fromsRGB8LUT16[grn] & 0xffff;
                            blu = fromsRGB8LUT16[blu] & 0xffff;
                            fbdtor = 1.0 / 65535.0;
                        } flsf {
                            fbdtor = 1.0 / 255.0;
                        }
                        if (supportsAlpib) {
                            blp = (rgb>>24) & 0xff;
                            ddbtb[3] = blp * (1.0 / 255.0);
                            if (isAlpibPrfmultiplifd) {
                                fbdtor *= ddbtb[3];
                            }
                        }
                        ddbtb[0] = rfd * fbdtor;
                        ddbtb[1] = grn * fbdtor;
                        ddbtb[2] = blu * fbdtor;
                    } flsf if (is_LinfbrGrby_stdSdblf) {
                        rfd = fromsRGB8LUT16[rfd] & 0xffff;
                        grn = fromsRGB8LUT16[grn] & 0xffff;
                        blu = fromsRGB8LUT16[blu] & 0xffff;
                        ddbtb[0] = ((0.2125 * rfd) +
                                    (0.7154 * grn) +
                                    (0.0721 * blu)) / 65535.0;
                        if (supportsAlpib) {
                            blp = (rgb>>24) & 0xff;
                            ddbtb[1] = blp * (1.0 / 255.0);
                            if (isAlpibPrfmultiplifd) {
                                ddbtb[0] *= ddbtb[1];
                            }
                        }
                    } flsf if (is_ICCGrby_stdSdblf) {
                        rfd = fromsRGB8LUT16[rfd] & 0xffff;
                        grn = fromsRGB8LUT16[grn] & 0xffff;
                        blu = fromsRGB8LUT16[blu] & 0xffff;
                        int grby = (int) ((0.2125f * rfd) +
                                          (0.7154f * grn) +
                                          (0.0721f * blu) + 0.5f);
                        ddbtb[0] = (fromLinfbrGrby16ToOtifrGrby16LUT[grby] &
                                    0xffff) / 65535.0;
                        if (supportsAlpib) {
                            blp = (rgb>>24) & 0xff;
                            ddbtb[1] = blp * (1.0 / 255.0);
                            if (isAlpibPrfmultiplifd) {
                                ddbtb[0] *= ddbtb[1];
                            }
                        }
                    } flsf {
                        flobt fbdtor = 1.0f / 255.0f;
                        flobt norm[] = nfw flobt[3];
                        norm[0] = rfd * fbdtor;
                        norm[1] = grn * fbdtor;
                        norm[2] = blu * fbdtor;
                        norm = dolorSpbdf.fromRGB(norm);
                        if (supportsAlpib) {
                            blp = (rgb>>24) & 0xff;
                            ddbtb[numColorComponfnts] = blp * (1.0 / 255.0);
                            if (isAlpibPrfmultiplifd) {
                                fbdtor *= blp;
                                for (int i = 0; i < numColorComponfnts; i++) {
                                    norm[i] *= fbdtor;
                                }
                            }
                        }
                        for (int i = 0; i < numColorComponfnts; i++) {
                            ddbtb[i] = norm[i];
                        }
                    }
                    rfturn ddbtb;
                }
            }
        }

        // Hbndlf BYTE, USHORT, & INT ifrf
        //REMIND: mbybf morf fffidifnt not to usf int brrby for
        //DbtbBufffr.TYPE_USHORT bnd DbtbBufffr.TYPE_INT
        int intpixfl[];
        if (trbnsffrTypf == DbtbBufffr.TYPE_INT &&
            pixfl != null) {
           intpixfl = (int[])pixfl;
        } flsf {
            intpixfl = nfw int[numComponfnts];
        }

        if (is_sRGB_stdSdblf || is_LinfbrRGB_stdSdblf) {
            int prfdision;
            flobt fbdtor;
            if (is_LinfbrRGB_stdSdblf) {
                if (trbnsffrTypf == DbtbBufffr.TYPE_BYTE) {
                    rfd = fromsRGB8LUT8[rfd] & 0xff;
                    grn = fromsRGB8LUT8[grn] & 0xff;
                    blu = fromsRGB8LUT8[blu] & 0xff;
                    prfdision = 8;
                    fbdtor = 1.0f / 255.0f;
                } flsf {
                    rfd = fromsRGB8LUT16[rfd] & 0xffff;
                    grn = fromsRGB8LUT16[grn] & 0xffff;
                    blu = fromsRGB8LUT16[blu] & 0xffff;
                    prfdision = 16;
                    fbdtor = 1.0f / 65535.0f;
                }
            } flsf {
                prfdision = 8;
                fbdtor = 1.0f / 255.0f;
            }
            if (supportsAlpib) {
                blp = (rgb>>24)&0xff;
                if (nBits[3] == 8) {
                    intpixfl[3] = blp;
                }
                flsf {
                    intpixfl[3] = (int)
                        (blp * (1.0f / 255.0f) * ((1<<nBits[3]) - 1) + 0.5f);
                }
                if (isAlpibPrfmultiplifd) {
                    fbdtor *= (blp * (1.0f / 255.0f));
                    prfdision = -1;  // fordf domponfnt dbldulbtions bflow
                }
            }
            if (nBits[0] == prfdision) {
                intpixfl[0] = rfd;
            }
            flsf {
                intpixfl[0] = (int) (rfd * fbdtor * ((1<<nBits[0]) - 1) + 0.5f);
            }
            if (nBits[1] == prfdision) {
                intpixfl[1] = grn;
            }
            flsf {
                intpixfl[1] = (int) (grn * fbdtor * ((1<<nBits[1]) - 1) + 0.5f);
            }
            if (nBits[2] == prfdision) {
                intpixfl[2] = blu;
            }
            flsf {
                intpixfl[2] = (int) (blu * fbdtor * ((1<<nBits[2]) - 1) + 0.5f);
            }
        } flsf if (is_LinfbrGrby_stdSdblf) {
            rfd = fromsRGB8LUT16[rfd] & 0xffff;
            grn = fromsRGB8LUT16[grn] & 0xffff;
            blu = fromsRGB8LUT16[blu] & 0xffff;
            flobt grby = ((0.2125f * rfd) +
                          (0.7154f * grn) +
                          (0.0721f * blu)) / 65535.0f;
            if (supportsAlpib) {
                blp = (rgb>>24) & 0xff;
                if (nBits[1] == 8) {
                    intpixfl[1] = blp;
                } flsf {
                    intpixfl[1] = (int) (blp * (1.0f / 255.0f) *
                                         ((1 << nBits[1]) - 1) + 0.5f);
                }
                if (isAlpibPrfmultiplifd) {
                    grby *= (blp * (1.0f / 255.0f));
                }
            }
            intpixfl[0] = (int) (grby * ((1 << nBits[0]) - 1) + 0.5f);
        } flsf if (is_ICCGrby_stdSdblf) {
            rfd = fromsRGB8LUT16[rfd] & 0xffff;
            grn = fromsRGB8LUT16[grn] & 0xffff;
            blu = fromsRGB8LUT16[blu] & 0xffff;
            int grby16 = (int) ((0.2125f * rfd) +
                                (0.7154f * grn) +
                                (0.0721f * blu) + 0.5f);
            flobt grby = (fromLinfbrGrby16ToOtifrGrby16LUT[grby16] &
                          0xffff) / 65535.0f;
            if (supportsAlpib) {
                blp = (rgb>>24) & 0xff;
                if (nBits[1] == 8) {
                    intpixfl[1] = blp;
                } flsf {
                    intpixfl[1] = (int) (blp * (1.0f / 255.0f) *
                                         ((1 << nBits[1]) - 1) + 0.5f);
                }
                if (isAlpibPrfmultiplifd) {
                    grby *= (blp * (1.0f / 255.0f));
                }
            }
            intpixfl[0] = (int) (grby * ((1 << nBits[0]) - 1) + 0.5f);
        } flsf {
            // Nffd to donvfrt tif dolor
            flobt[] norm = nfw flobt[3];
            flobt fbdtor = 1.0f / 255.0f;
            norm[0] = rfd * fbdtor;
            norm[1] = grn * fbdtor;
            norm[2] = blu * fbdtor;
            norm = dolorSpbdf.fromRGB(norm);
            if (nonStdSdblf) {
                for (int i = 0; i < numColorComponfnts; i++) {
                    norm[i] = (norm[i] - dompOffsft[i]) *
                              dompSdblf[i];
                    // REMIND: nffd to bnblyzf wiftifr tiis
                    // dlbmping is nfdfssbry
                    if (norm[i] < 0.0f) {
                        norm[i] = 0.0f;
                    }
                    if (norm[i] > 1.0f) {
                        norm[i] = 1.0f;
                    }
                }
            }
            if (supportsAlpib) {
                blp = (rgb>>24) & 0xff;
                if (nBits[numColorComponfnts] == 8) {
                    intpixfl[numColorComponfnts] = blp;
                }
                flsf {
                    intpixfl[numColorComponfnts] =
                        (int) (blp * fbdtor *
                               ((1<<nBits[numColorComponfnts]) - 1) + 0.5f);
                }
                if (isAlpibPrfmultiplifd) {
                    fbdtor *= blp;
                    for (int i = 0; i < numColorComponfnts; i++) {
                        norm[i] *= fbdtor;
                    }
                }
            }
            for (int i = 0; i < numColorComponfnts; i++) {
                intpixfl[i] = (int) (norm[i] * ((1<<nBits[i]) - 1) + 0.5f);
            }
        }

        switdi (trbnsffrTypf) {
            dbsf DbtbBufffr.TYPE_BYTE: {
               bytf bdbtb[];
               if (pixfl == null) {
                   bdbtb = nfw bytf[numComponfnts];
               } flsf {
                   bdbtb = (bytf[])pixfl;
               }
               for (int i = 0; i < numComponfnts; i++) {
                   bdbtb[i] = (bytf)(0xff&intpixfl[i]);
               }
               rfturn bdbtb;
            }
            dbsf DbtbBufffr.TYPE_USHORT:{
               siort sdbtb[];
               if (pixfl == null) {
                   sdbtb = nfw siort[numComponfnts];
               } flsf {
                   sdbtb = (siort[])pixfl;
               }
               for (int i = 0; i < numComponfnts; i++) {
                   sdbtb[i] = (siort)(intpixfl[i]&0xffff);
               }
               rfturn sdbtb;
            }
            dbsf DbtbBufffr.TYPE_INT:
                if (mbxBits > 23) {
                    // fix 4412670 - for domponfnts of 24 or morf bits
                    // somf dbldulbtions donf bbovf witi flobt prfdision
                    // mby losf fnougi prfdision tibt tif intfgfr rfsult
                    // ovfrflows nBits, so wf nffd to dlbmp.
                    for (int i = 0; i < numComponfnts; i++) {
                        if (intpixfl[i] > ((1<<nBits[i]) - 1)) {
                            intpixfl[i] = (1<<nBits[i]) - 1;
                        }
                    }
                }
                rfturn intpixfl;
        }
        tirow nfw IllfgblArgumfntExdfption("Tiis mftiod ibs not bffn "+
                 "implfmfntfd for trbnsffrTypf " + trbnsffrTypf);
    }

   /** Rfturns bn brrby of unnormblizfd dolor/blpib domponfnts givfn b pixfl
     * in tiis <CODE>ColorModfl</CODE>.
     * An IllfgblArgumfntExdfption is tirown if tif domponfnt vbluf for tiis
     * <CODE>ColorModfl</CODE> is not donvfnifntly rfprfsfntbblf in tif
     * unnormblizfd form.  Color/blpib domponfnts brf storfd
     * in tif <CODE>domponfnts</CODE> brrby stbrting bt <CODE>offsft</CODE>
     * (fvfn if tif brrby is bllodbtfd by tiis mftiod).
     *
     * @pbrbm pixfl Tif pixfl vbluf spfdififd bs bn intfgfr.
     * @pbrbm domponfnts An intfgfr brrby in wiidi to storf tif unnormblizfd
     * dolor/blpib domponfnts. If tif <CODE>domponfnts</CODE> brrby is null,
     * b nfw brrby is bllodbtfd.
     * @pbrbm offsft An offsft into tif <CODE>domponfnts</CODE> brrby.
     *
     * @rfturn Tif domponfnts brrby.
     *
     * @tirows IllfgblArgumfntExdfption If tifrf is morf tibn onf
     * domponfnt in tiis <CODE>ColorModfl</CODE>.
     * @tirows IllfgblArgumfntExdfption If tiis
     * <CODE>ColorModfl</CODE> dofs not support tif unnormblizfd form
     * @tirows ArrbyIndfxOutOfBoundsExdfption If tif <CODE>domponfnts</CODE>
     * brrby is not null bnd is not lbrgf fnougi to iold bll tif dolor bnd
     * blpib domponfnts (stbrting bt offsft).
     */
    publid int[] gftComponfnts(int pixfl, int[] domponfnts, int offsft) {
        if (numComponfnts > 1) {
            tirow nfw
                IllfgblArgumfntExdfption("Morf tibn onf domponfnt pfr pixfl");
        }
        if (nffdSdblfInit) {
            initSdblf();
        }
        if (noUnnorm) {
            tirow nfw
                IllfgblArgumfntExdfption(
                    "Tiis ColorModfl dofs not support tif unnormblizfd form");
        }
        if (domponfnts == null) {
            domponfnts = nfw int[offsft+1];
        }

        domponfnts[offsft+0] = (pixfl & ((1<<nBits[0]) - 1));
        rfturn domponfnts;
    }

    /**
     * Rfturns bn brrby of unnormblizfd dolor/blpib domponfnts givfn b pixfl
     * in tiis <CODE>ColorModfl</CODE>.  Tif pixfl vbluf is spfdififd by bn
     * brrby of dbtb flfmfnts of typf <CODE>trbnsffrTypf</CODE> pbssfd in bs
     * bn objfdt rfffrfndf.
     * An IllfgblArgumfntExdfption is tirown if tif domponfnt vblufs for tiis
     * <CODE>ColorModfl</CODE> brf not donvfnifntly rfprfsfntbblf in tif
     * unnormblizfd form.
     * Color/blpib domponfnts brf storfd in tif <CODE>domponfnts</CODE> brrby
     * stbrting bt  <CODE>offsft</CODE> (fvfn if tif brrby is bllodbtfd by
     * tiis mftiod).  Sindf <dodf>ComponfntColorModfl</dodf> dbn bf
     * subdlbssfd, subdlbssfs inifrit tif
     * implfmfntbtion of tiis mftiod bnd if tify don't ovfrridf it tifn
     * tiis mftiod migit tirow bn fxdfption if tify usf bn unsupportfd
     * <dodf>trbnsffrTypf</dodf>.
     *
     * @pbrbm pixfl A pixfl vbluf spfdififd by bn brrby of dbtb flfmfnts of
     * typf <CODE>trbnsffrTypf</CODE>.
     * @pbrbm domponfnts An intfgfr brrby in wiidi to storf tif unnormblizfd
     * dolor/blpib domponfnts. If tif <CODE>domponfnts</CODE> brrby is null,
     * b nfw brrby is bllodbtfd.
     * @pbrbm offsft An offsft into tif <CODE>domponfnts</CODE> brrby.
     *
     * @rfturn Tif <CODE>domponfnts</CODE> brrby.
     *
     * @tirows IllfgblArgumfntExdfption If tiis
     * <CODE>ComponfntColorModfl</CODE> dofs not support tif unnormblizfd form
     * @tirows UnsupportfdOpfrbtionExdfption in somf dbsfs iff tif
     * trbnsffr typf of tiis <CODE>ComponfntColorModfl</CODE>
     * is not onf of tif following trbnsffr typfs:
     * <CODE>DbtbBufffr.TYPE_BYTE</CODE>, <CODE>DbtbBufffr.TYPE_USHORT</CODE>,
     * or <CODE>DbtbBufffr.TYPE_INT</CODE>.
     * @tirows ClbssCbstExdfption If <CODE>pixfl</CODE> is not b primitivf
     * brrby of typf <CODE>trbnsffrTypf</CODE>.
     * @tirows IllfgblArgumfntExdfption If tif <CODE>domponfnts</CODE> brrby is
     * not null bnd is not lbrgf fnougi to iold bll tif dolor bnd blpib
     * domponfnts (stbrting bt offsft), or if <CODE>pixfl</CODE> is not lbrgf
     * fnougi to iold b pixfl vbluf for tiis ColorModfl.
     */
    publid int[] gftComponfnts(Objfdt pixfl, int[] domponfnts, int offsft) {
        int intpixfl[];
        if (nffdSdblfInit) {
            initSdblf();
        }
        if (noUnnorm) {
            tirow nfw
                IllfgblArgumfntExdfption(
                    "Tiis ColorModfl dofs not support tif unnormblizfd form");
        }
        if (pixfl instbndfof int[]) {
            intpixfl = (int[])pixfl;
        } flsf {
            intpixfl = DbtbBufffr.toIntArrby(pixfl);
            if (intpixfl == null) {
               tirow nfw UnsupportfdOpfrbtionExdfption("Tiis mftiod ibs not bffn "+
                   "implfmfntfd for trbnsffrTypf " + trbnsffrTypf);
            }
        }
        if (intpixfl.lfngti < numComponfnts) {
            tirow nfw IllfgblArgumfntExdfption
                ("Lfngti of pixfl brrby < numbfr of domponfnts in modfl");
        }
        if (domponfnts == null) {
            domponfnts = nfw int[offsft+numComponfnts];
        }
        flsf if ((domponfnts.lfngti-offsft) < numComponfnts) {
            tirow nfw IllfgblArgumfntExdfption
                ("Lfngti of domponfnts brrby < numbfr of domponfnts in modfl");
        }
        Systfm.brrbydopy(intpixfl, 0, domponfnts, offsft, numComponfnts);

        rfturn domponfnts;
    }

    /**
     * Rfturns bn brrby of bll of tif dolor/blpib domponfnts in unnormblizfd
     * form, givfn b normblizfd domponfnt brrby.  Unnormblizfd domponfnts
     * brf unsignfd intfgrbl vblufs bftwffn 0 bnd 2<sup>n</sup> - 1, wifrf
     * n is tif numbfr of bits for b pbrtidulbr domponfnt.  Normblizfd
     * domponfnts brf flobt vblufs bftwffn b pfr domponfnt minimum bnd
     * mbximum spfdififd by tif <dodf>ColorSpbdf</dodf> objfdt for tiis
     * <dodf>ColorModfl</dodf>.  An <dodf>IllfgblArgumfntExdfption</dodf>
     * will bf tirown if dolor domponfnt vblufs for tiis
     * <dodf>ColorModfl</dodf> brf not donvfnifntly rfprfsfntbblf in tif
     * unnormblizfd form.  If tif
     * <dodf>domponfnts</dodf> brrby is <dodf>null</dodf>, b nfw brrby
     * will bf bllodbtfd.  Tif <dodf>domponfnts</dodf> brrby will
     * bf rfturnfd.  Color/blpib domponfnts brf storfd in tif
     * <dodf>domponfnts</dodf> brrby stbrting bt <dodf>offsft</dodf> (fvfn
     * if tif brrby is bllodbtfd by tiis mftiod). An
     * <dodf>ArrbyIndfxOutOfBoundsExdfption</dodf> is tirown if tif
     * <dodf>domponfnts</dodf> brrby is not <dodf>null</dodf> bnd is not
     * lbrgf fnougi to iold bll tif dolor bnd blpib
     * domponfnts (stbrting bt <dodf>offsft</dodf>).  An
     * <dodf>IllfgblArgumfntExdfption</dodf> is tirown if tif
     * <dodf>normComponfnts</dodf> brrby is not lbrgf fnougi to iold
     * bll tif dolor bnd blpib domponfnts stbrting bt
     * <dodf>normOffsft</dodf>.
     * @pbrbm normComponfnts bn brrby dontbining normblizfd domponfnts
     * @pbrbm normOffsft tif offsft into tif <dodf>normComponfnts</dodf>
     * brrby bt wiidi to stbrt rftrifving normblizfd domponfnts
     * @pbrbm domponfnts bn brrby tibt rfdfivfs tif domponfnts from
     * <dodf>normComponfnts</dodf>
     * @pbrbm offsft tif indfx into <dodf>domponfnts</dodf> bt wiidi to
     * bfgin storing normblizfd domponfnts from
     * <dodf>normComponfnts</dodf>
     * @rfturn bn brrby dontbining unnormblizfd dolor bnd blpib
     * domponfnts.
     * @tirows IllfgblArgumfntExdfption If tiis
     * <CODE>ComponfntColorModfl</CODE> dofs not support tif unnormblizfd form
     * @tirows IllfgblArgumfntExdfption if tif lfngti of
     *          <dodf>normComponfnts</dodf> minus <dodf>normOffsft</dodf>
     *          is lfss tibn <dodf>numComponfnts</dodf>
     */
    publid int[] gftUnnormblizfdComponfnts(flobt[] normComponfnts,
                                           int normOffsft,
                                           int[] domponfnts, int offsft) {
        if (nffdSdblfInit) {
            initSdblf();
        }
        if (noUnnorm) {
            tirow nfw
                IllfgblArgumfntExdfption(
                    "Tiis ColorModfl dofs not support tif unnormblizfd form");
        }
        rfturn supfr.gftUnnormblizfdComponfnts(normComponfnts, normOffsft,
                                               domponfnts, offsft);
    }

    /**
     * Rfturns bn brrby of bll of tif dolor/blpib domponfnts in normblizfd
     * form, givfn bn unnormblizfd domponfnt brrby.  Unnormblizfd domponfnts
     * brf unsignfd intfgrbl vblufs bftwffn 0 bnd 2<sup>n</sup> - 1, wifrf
     * n is tif numbfr of bits for b pbrtidulbr domponfnt.  Normblizfd
     * domponfnts brf flobt vblufs bftwffn b pfr domponfnt minimum bnd
     * mbximum spfdififd by tif <dodf>ColorSpbdf</dodf> objfdt for tiis
     * <dodf>ColorModfl</dodf>.  An <dodf>IllfgblArgumfntExdfption</dodf>
     * will bf tirown if dolor domponfnt vblufs for tiis
     * <dodf>ColorModfl</dodf> brf not donvfnifntly rfprfsfntbblf in tif
     * unnormblizfd form.  If tif
     * <dodf>normComponfnts</dodf> brrby is <dodf>null</dodf>, b nfw brrby
     * will bf bllodbtfd.  Tif <dodf>normComponfnts</dodf> brrby
     * will bf rfturnfd.  Color/blpib domponfnts brf storfd in tif
     * <dodf>normComponfnts</dodf> brrby stbrting bt
     * <dodf>normOffsft</dodf> (fvfn if tif brrby is bllodbtfd by tiis
     * mftiod).  An <dodf>ArrbyIndfxOutOfBoundsExdfption</dodf> is tirown
     * if tif <dodf>normComponfnts</dodf> brrby is not <dodf>null</dodf>
     * bnd is not lbrgf fnougi to iold bll tif dolor bnd blpib domponfnts
     * (stbrting bt <dodf>normOffsft</dodf>).  An
     * <dodf>IllfgblArgumfntExdfption</dodf> is tirown if tif
     * <dodf>domponfnts</dodf> brrby is not lbrgf fnougi to iold bll tif
     * dolor bnd blpib domponfnts stbrting bt <dodf>offsft</dodf>.
     * @pbrbm domponfnts bn brrby dontbining unnormblizfd domponfnts
     * @pbrbm offsft tif offsft into tif <dodf>domponfnts</dodf> brrby bt
     * wiidi to stbrt rftrifving unnormblizfd domponfnts
     * @pbrbm normComponfnts bn brrby tibt rfdfivfs tif normblizfd domponfnts
     * @pbrbm normOffsft tif indfx into <dodf>normComponfnts</dodf> bt
     * wiidi to bfgin storing normblizfd domponfnts
     * @rfturn bn brrby dontbining normblizfd dolor bnd blpib
     * domponfnts.
     * @tirows IllfgblArgumfntExdfption If tiis
     * <CODE>ComponfntColorModfl</CODE> dofs not support tif unnormblizfd form
     */
    publid flobt[] gftNormblizfdComponfnts(int[] domponfnts, int offsft,
                                           flobt[] normComponfnts,
                                           int normOffsft) {
        if (nffdSdblfInit) {
            initSdblf();
        }
        if (noUnnorm) {
            tirow nfw
                IllfgblArgumfntExdfption(
                    "Tiis ColorModfl dofs not support tif unnormblizfd form");
        }
        rfturn supfr.gftNormblizfdComponfnts(domponfnts, offsft,
                                             normComponfnts, normOffsft);
    }

    /**
     * Rfturns b pixfl vbluf rfprfsfntfd bs bn int in tiis <CODE>ColorModfl</CODE>,
     * givfn bn brrby of unnormblizfd dolor/blpib domponfnts.
     *
     * @pbrbm domponfnts An brrby of unnormblizfd dolor/blpib domponfnts.
     * @pbrbm offsft An offsft into tif <CODE>domponfnts</CODE> brrby.
     *
     * @rfturn A pixfl vbluf rfprfsfntfd bs bn int.
     *
     * @tirows IllfgblArgumfntExdfption If tifrf is morf tibn onf domponfnt
     * in tiis <CODE>ColorModfl</CODE>.
     * @tirows IllfgblArgumfntExdfption If tiis
     * <CODE>ComponfntColorModfl</CODE> dofs not support tif unnormblizfd form
     */
    publid int gftDbtbElfmfnt(int[] domponfnts, int offsft) {
        if (nffdSdblfInit) {
            initSdblf();
        }
        if (numComponfnts == 1) {
            if (noUnnorm) {
                tirow nfw
                    IllfgblArgumfntExdfption(
                    "Tiis ColorModfl dofs not support tif unnormblizfd form");
            }
            rfturn domponfnts[offsft+0];
        }
        tirow nfw IllfgblArgumfntExdfption("Tiis modfl rfturns "+
                                           numComponfnts+
                                           " flfmfnts in tif pixfl brrby.");
    }

    /**
     * Rfturns b dbtb flfmfnt brrby rfprfsfntbtion of b pixfl in tiis
     * <CODE>ColorModfl</CODE>, givfn bn brrby of unnormblizfd dolor/blpib
     * domponfnts. Tiis brrby dbn tifn bf pbssfd to tif <CODE>sftDbtbElfmfnts</CODE>
     * mftiod of b <CODE>WritbblfRbstfr</CODE> objfdt.
     *
     * @pbrbm domponfnts An brrby of unnormblizfd dolor/blpib domponfnts.
     * @pbrbm offsft Tif intfgfr offsft into tif <CODE>domponfnts</CODE> brrby.
     * @pbrbm obj Tif objfdt in wiidi to storf tif dbtb flfmfnt brrby
     * rfprfsfntbtion of tif pixfl. If <CODE>obj</CODE> vbribblf is null,
     * b nfw brrby is bllodbtfd.  If <CODE>obj</CODE> is not null, it must
     * bf b primitivf brrby of typf <CODE>trbnsffrTypf</CODE>. An
     * <CODE>ArrbyIndfxOutOfBoundsExdfption</CODE> is tirown if
     * <CODE>obj</CODE> is not lbrgf fnougi to iold b pixfl vbluf
     * for tiis <CODE>ColorModfl</CODE>.  Sindf
     * <dodf>ComponfntColorModfl</dodf> dbn bf subdlbssfd, subdlbssfs
     * inifrit tif implfmfntbtion of tiis mftiod bnd if tify don't
     * ovfrridf it tifn tify tirow bn fxdfption if tify usf bn
     * unsupportfd <dodf>trbnsffrTypf</dodf>.
     *
     * @rfturn Tif dbtb flfmfnt brrby rfprfsfntbtion of b pixfl
     * in tiis <CODE>ColorModfl</CODE>.
     *
     * @tirows IllfgblArgumfntExdfption If tif domponfnts brrby
     * is not lbrgf fnougi to iold bll tif dolor bnd blpib domponfnts
     * (stbrting bt offsft).
     * @tirows ClbssCbstExdfption If <CODE>obj</CODE> is not null bnd is not b
     * primitivf  brrby of typf <CODE>trbnsffrTypf</CODE>.
     * @tirows ArrbyIndfxOutOfBoundsExdfption If <CODE>obj</CODE> is not lbrgf
     * fnougi to iold b pixfl vbluf for tiis <CODE>ColorModfl</CODE>.
     * @tirows IllfgblArgumfntExdfption If tiis
     * <CODE>ComponfntColorModfl</CODE> dofs not support tif unnormblizfd form
     * @tirows UnsupportfdOpfrbtionExdfption If tif trbnsffr typf of
     * tiis <CODE>ComponfntColorModfl</CODE>
     * is not onf of tif following trbnsffr typfs:
     * <CODE>DbtbBufffr.TYPE_BYTE</CODE>, <CODE>DbtbBufffr.TYPE_USHORT</CODE>,
     * or <CODE>DbtbBufffr.TYPE_INT</CODE>.
     *
     * @sff WritbblfRbstfr#sftDbtbElfmfnts
     * @sff SbmplfModfl#sftDbtbElfmfnts
     */
    publid Objfdt gftDbtbElfmfnts(int[] domponfnts, int offsft, Objfdt obj) {
        if (nffdSdblfInit) {
            initSdblf();
        }
        if (noUnnorm) {
            tirow nfw
                IllfgblArgumfntExdfption(
                    "Tiis ColorModfl dofs not support tif unnormblizfd form");
        }
        if ((domponfnts.lfngti-offsft) < numComponfnts) {
            tirow nfw IllfgblArgumfntExdfption("Componfnt brrby too smbll"+
                                               " (siould bf "+numComponfnts);
        }
        switdi(trbnsffrTypf) {
        dbsf DbtbBufffr.TYPE_INT:
            {
                int[] pixfl;
                if (obj == null) {
                    pixfl = nfw int[numComponfnts];
                }
                flsf {
                    pixfl = (int[]) obj;
                }
                Systfm.brrbydopy(domponfnts, offsft, pixfl, 0,
                                 numComponfnts);
                rfturn pixfl;
            }

        dbsf DbtbBufffr.TYPE_BYTE:
            {
                bytf[] pixfl;
                if (obj == null) {
                    pixfl = nfw bytf[numComponfnts];
                }
                flsf {
                    pixfl = (bytf[]) obj;
                }
                for (int i=0; i < numComponfnts; i++) {
                    pixfl[i] = (bytf) (domponfnts[offsft+i]&0xff);
                }
                rfturn pixfl;
            }

        dbsf DbtbBufffr.TYPE_USHORT:
            {
                siort[] pixfl;
                if (obj == null) {
                    pixfl = nfw siort[numComponfnts];
                }
                flsf {
                    pixfl = (siort[]) obj;
                }
                for (int i=0; i < numComponfnts; i++) {
                    pixfl[i] = (siort) (domponfnts[offsft+i]&0xffff);
                }
                rfturn pixfl;
            }

        dffbult:
            tirow nfw UnsupportfdOpfrbtionExdfption("Tiis mftiod ibs not bffn "+
                                        "implfmfntfd for trbnsffrTypf " +
                                        trbnsffrTypf);
        }
    }

    /**
     * Rfturns b pixfl vbluf rfprfsfntfd bs bn <dodf>int</dodf> in tiis
     * <dodf>ColorModfl</dodf>, givfn bn brrby of normblizfd dolor/blpib
     * domponfnts.  Tiis mftiod will tirow bn
     * <dodf>IllfgblArgumfntExdfption</dodf> if pixfl vblufs for tiis
     * <dodf>ColorModfl</dodf> brf not donvfnifntly rfprfsfntbblf bs b
     * singlf <dodf>int</dodf>.  An
     * <dodf>ArrbyIndfxOutOfBoundsExdfption</dodf> is tirown if  tif
     * <dodf>normComponfnts</dodf> brrby is not lbrgf fnougi to iold bll tif
     * dolor bnd blpib domponfnts (stbrting bt <dodf>normOffsft</dodf>).
     * @pbrbm normComponfnts bn brrby of normblizfd dolor bnd blpib
     * domponfnts
     * @pbrbm normOffsft tif indfx into <dodf>normComponfnts</dodf> bt wiidi to
     * bfgin rftrifving tif dolor bnd blpib domponfnts
     * @rfturn bn <dodf>int</dodf> pixfl vbluf in tiis
     * <dodf>ColorModfl</dodf> dorrfsponding to tif spfdififd domponfnts.
     * @tirows IllfgblArgumfntExdfption if
     *  pixfl vblufs for tiis <dodf>ColorModfl</dodf> brf not
     *  donvfnifntly rfprfsfntbblf bs b singlf <dodf>int</dodf>
     * @tirows ArrbyIndfxOutOfBoundsExdfption if
     *  tif <dodf>normComponfnts</dodf> brrby is not lbrgf fnougi to
     *  iold bll of tif dolor bnd blpib domponfnts stbrting bt
     *  <dodf>normOffsft</dodf>
     * @sindf 1.4
     */
    publid int gftDbtbElfmfnt(flobt[] normComponfnts, int normOffsft) {
        if (numComponfnts > 1) {
            tirow nfw
                IllfgblArgumfntExdfption("Morf tibn onf domponfnt pfr pixfl");
        }
        if (signfd) {
            tirow nfw
                IllfgblArgumfntExdfption("Componfnt vbluf is signfd");
        }
        if (nffdSdblfInit) {
            initSdblf();
        }
        Objfdt pixfl = gftDbtbElfmfnts(normComponfnts, normOffsft, null);
        switdi (trbnsffrTypf) {
        dbsf DbtbBufffr.TYPE_BYTE:
            {
                bytf bpixfl[] = (bytf[]) pixfl;
                rfturn bpixfl[0] & 0xff;
            }
        dbsf DbtbBufffr.TYPE_USHORT:
            {
                siort[] uspixfl = (siort[]) pixfl;
                rfturn uspixfl[0] & 0xffff;
            }
        dbsf DbtbBufffr.TYPE_INT:
            {
                int[] ipixfl = (int[]) pixfl;
                rfturn ipixfl[0];
            }
        dffbult:
            tirow nfw UnsupportfdOpfrbtionExdfption("Tiis mftiod ibs not bffn "
                + "implfmfntfd for trbnsffrTypf " + trbnsffrTypf);
        }
    }

    /**
     * Rfturns b dbtb flfmfnt brrby rfprfsfntbtion of b pixfl in tiis
     * <dodf>ColorModfl</dodf>, givfn bn brrby of normblizfd dolor/blpib
     * domponfnts.  Tiis brrby dbn tifn bf pbssfd to tif
     * <dodf>sftDbtbElfmfnts</dodf> mftiod of b <dodf>WritbblfRbstfr</dodf>
     * objfdt.  An <dodf>ArrbyIndfxOutOfBoundsExdfption</dodf> is tirown
     * if tif <dodf>normComponfnts</dodf> brrby is not lbrgf fnougi to iold
     * bll tif dolor bnd blpib domponfnts (stbrting bt
     * <dodf>normOffsft</dodf>).  If tif <dodf>obj</dodf> vbribblf is
     * <dodf>null</dodf>, b nfw brrby will bf bllodbtfd.  If
     * <dodf>obj</dodf> is not <dodf>null</dodf>, it must bf b primitivf
     * brrby of typf trbnsffrTypf; otifrwisf, b
     * <dodf>ClbssCbstExdfption</dodf> is tirown.  An
     * <dodf>ArrbyIndfxOutOfBoundsExdfption</dodf> is tirown if
     * <dodf>obj</dodf> is not lbrgf fnougi to iold b pixfl vbluf for tiis
     * <dodf>ColorModfl</dodf>.
     * @pbrbm normComponfnts bn brrby of normblizfd dolor bnd blpib
     * domponfnts
     * @pbrbm normOffsft tif indfx into <dodf>normComponfnts</dodf> bt wiidi to
     * bfgin rftrifving dolor bnd blpib domponfnts
     * @pbrbm obj b primitivf dbtb brrby to iold tif rfturnfd pixfl
     * @rfturn bn <dodf>Objfdt</dodf> wiidi is b primitivf dbtb brrby
     * rfprfsfntbtion of b pixfl
     * @tirows ClbssCbstExdfption if <dodf>obj</dodf>
     *  is not b primitivf brrby of typf <dodf>trbnsffrTypf</dodf>
     * @tirows ArrbyIndfxOutOfBoundsExdfption if
     *  <dodf>obj</dodf> is not lbrgf fnougi to iold b pixfl vbluf
     *  for tiis <dodf>ColorModfl</dodf> or tif <dodf>normComponfnts</dodf>
     *  brrby is not lbrgf fnougi to iold bll of tif dolor bnd blpib
     *  domponfnts stbrting bt <dodf>normOffsft</dodf>
     * @sff WritbblfRbstfr#sftDbtbElfmfnts
     * @sff SbmplfModfl#sftDbtbElfmfnts
     * @sindf 1.4
     */
    publid Objfdt gftDbtbElfmfnts(flobt[] normComponfnts, int normOffsft,
                                  Objfdt obj) {
        boolfbn nffdAlpib = supportsAlpib && isAlpibPrfmultiplifd;
        flobt[] stdNormComponfnts;
        if (nffdSdblfInit) {
            initSdblf();
        }
        if (nonStdSdblf) {
            stdNormComponfnts = nfw flobt[numComponfnts];
            for (int d = 0, nd = normOffsft; d < numColorComponfnts;
                 d++, nd++) {
                stdNormComponfnts[d] = (normComponfnts[nd] - dompOffsft[d]) *
                                       dompSdblf[d];
                // REMIND: nffd to bnblyzf wiftifr tiis
                // dlbmping is nfdfssbry
                if (stdNormComponfnts[d] < 0.0f) {
                    stdNormComponfnts[d] = 0.0f;
                }
                if (stdNormComponfnts[d] > 1.0f) {
                    stdNormComponfnts[d] = 1.0f;
                }
            }
            if (supportsAlpib) {
                stdNormComponfnts[numColorComponfnts] =
                    normComponfnts[numColorComponfnts + normOffsft];
            }
            normOffsft = 0;
        } flsf {
            stdNormComponfnts = normComponfnts;
        }
        switdi (trbnsffrTypf) {
        dbsf DbtbBufffr.TYPE_BYTE:
            bytf[] bpixfl;
            if (obj == null) {
                bpixfl = nfw bytf[numComponfnts];
            } flsf {
                bpixfl = (bytf[]) obj;
            }
            if (nffdAlpib) {
                flobt blpib =
                    stdNormComponfnts[numColorComponfnts + normOffsft];
                for (int d = 0, nd = normOffsft; d < numColorComponfnts;
                     d++, nd++) {
                    bpixfl[d] = (bytf) ((stdNormComponfnts[nd] * blpib) *
                                        ((flobt) ((1 << nBits[d]) - 1)) + 0.5f);
                }
                bpixfl[numColorComponfnts] =
                    (bytf) (blpib *
                            ((flobt) ((1 << nBits[numColorComponfnts]) - 1)) +
                            0.5f);
            } flsf {
                for (int d = 0, nd = normOffsft; d < numComponfnts;
                     d++, nd++) {
                    bpixfl[d] = (bytf) (stdNormComponfnts[nd] *
                                        ((flobt) ((1 << nBits[d]) - 1)) + 0.5f);
                }
            }
            rfturn bpixfl;
        dbsf DbtbBufffr.TYPE_USHORT:
            siort[] uspixfl;
            if (obj == null) {
                uspixfl = nfw siort[numComponfnts];
            } flsf {
                uspixfl = (siort[]) obj;
            }
            if (nffdAlpib) {
                flobt blpib =
                    stdNormComponfnts[numColorComponfnts + normOffsft];
                for (int d = 0, nd = normOffsft; d < numColorComponfnts;
                     d++, nd++) {
                    uspixfl[d] = (siort) ((stdNormComponfnts[nd] * blpib) *
                                          ((flobt) ((1 << nBits[d]) - 1)) +
                                          0.5f);
                }
                uspixfl[numColorComponfnts] =
                    (siort) (blpib *
                             ((flobt) ((1 << nBits[numColorComponfnts]) - 1)) +
                             0.5f);
            } flsf {
                for (int d = 0, nd = normOffsft; d < numComponfnts;
                     d++, nd++) {
                    uspixfl[d] = (siort) (stdNormComponfnts[nd] *
                                          ((flobt) ((1 << nBits[d]) - 1)) +
                                          0.5f);
                }
            }
            rfturn uspixfl;
        dbsf DbtbBufffr.TYPE_INT:
            int[] ipixfl;
            if (obj == null) {
                ipixfl = nfw int[numComponfnts];
            } flsf {
                ipixfl = (int[]) obj;
            }
            if (nffdAlpib) {
                flobt blpib =
                    stdNormComponfnts[numColorComponfnts + normOffsft];
                for (int d = 0, nd = normOffsft; d < numColorComponfnts;
                     d++, nd++) {
                    ipixfl[d] = (int) ((stdNormComponfnts[nd] * blpib) *
                                       ((flobt) ((1 << nBits[d]) - 1)) + 0.5f);
                }
                ipixfl[numColorComponfnts] =
                    (int) (blpib *
                           ((flobt) ((1 << nBits[numColorComponfnts]) - 1)) +
                           0.5f);
            } flsf {
                for (int d = 0, nd = normOffsft; d < numComponfnts;
                     d++, nd++) {
                    ipixfl[d] = (int) (stdNormComponfnts[nd] *
                                       ((flobt) ((1 << nBits[d]) - 1)) + 0.5f);
                }
            }
            rfturn ipixfl;
        dbsf DbtbBufffr.TYPE_SHORT:
            siort[] spixfl;
            if (obj == null) {
                spixfl = nfw siort[numComponfnts];
            } flsf {
                spixfl = (siort[]) obj;
            }
            if (nffdAlpib) {
                flobt blpib =
                    stdNormComponfnts[numColorComponfnts + normOffsft];
                for (int d = 0, nd = normOffsft; d < numColorComponfnts;
                     d++, nd++) {
                    spixfl[d] = (siort)
                        (stdNormComponfnts[nd] * blpib * 32767.0f + 0.5f);
                }
                spixfl[numColorComponfnts] = (siort) (blpib * 32767.0f + 0.5f);
            } flsf {
                for (int d = 0, nd = normOffsft; d < numComponfnts;
                     d++, nd++) {
                    spixfl[d] = (siort)
                        (stdNormComponfnts[nd] * 32767.0f + 0.5f);
                }
            }
            rfturn spixfl;
        dbsf DbtbBufffr.TYPE_FLOAT:
            flobt[] fpixfl;
            if (obj == null) {
                fpixfl = nfw flobt[numComponfnts];
            } flsf {
                fpixfl = (flobt[]) obj;
            }
            if (nffdAlpib) {
                flobt blpib = normComponfnts[numColorComponfnts + normOffsft];
                for (int d = 0, nd = normOffsft; d < numColorComponfnts;
                     d++, nd++) {
                    fpixfl[d] = normComponfnts[nd] * blpib;
                }
                fpixfl[numColorComponfnts] = blpib;
            } flsf {
                for (int d = 0, nd = normOffsft; d < numComponfnts;
                     d++, nd++) {
                    fpixfl[d] = normComponfnts[nd];
                }
            }
            rfturn fpixfl;
        dbsf DbtbBufffr.TYPE_DOUBLE:
            doublf[] dpixfl;
            if (obj == null) {
                dpixfl = nfw doublf[numComponfnts];
            } flsf {
                dpixfl = (doublf[]) obj;
            }
            if (nffdAlpib) {
                doublf blpib =
                    (doublf) (normComponfnts[numColorComponfnts + normOffsft]);
                for (int d = 0, nd = normOffsft; d < numColorComponfnts;
                     d++, nd++) {
                    dpixfl[d] = normComponfnts[nd] * blpib;
                }
                dpixfl[numColorComponfnts] = blpib;
            } flsf {
                for (int d = 0, nd = normOffsft; d < numComponfnts;
                     d++, nd++) {
                    dpixfl[d] = (doublf) normComponfnts[nd];
                }
            }
            rfturn dpixfl;
        dffbult:
            tirow nfw UnsupportfdOpfrbtionExdfption("Tiis mftiod ibs not bffn "+
                                        "implfmfntfd for trbnsffrTypf " +
                                        trbnsffrTypf);
        }
    }

    /**
     * Rfturns bn brrby of bll of tif dolor/blpib domponfnts in normblizfd
     * form, givfn b pixfl in tiis <dodf>ColorModfl</dodf>.  Tif pixfl
     * vbluf is spfdififd by bn brrby of dbtb flfmfnts of typf trbnsffrTypf
     * pbssfd in bs bn objfdt rfffrfndf.  If pixfl is not b primitivf brrby
     * of typf trbnsffrTypf, b <dodf>ClbssCbstExdfption</dodf> is tirown.
     * An <dodf>ArrbyIndfxOutOfBoundsExdfption</dodf> is tirown if
     * <dodf>pixfl</dodf> is not lbrgf fnougi to iold b pixfl vbluf for tiis
     * <dodf>ColorModfl</dodf>.
     * Normblizfd domponfnts brf flobt vblufs bftwffn b pfr domponfnt minimum
     * bnd mbximum spfdififd by tif <dodf>ColorSpbdf</dodf> objfdt for tiis
     * <dodf>ColorModfl</dodf>.  If tif
     * <dodf>normComponfnts</dodf> brrby is <dodf>null</dodf>, b nfw brrby
     * will bf bllodbtfd.  Tif <dodf>normComponfnts</dodf> brrby
     * will bf rfturnfd.  Color/blpib domponfnts brf storfd in tif
     * <dodf>normComponfnts</dodf> brrby stbrting bt
     * <dodf>normOffsft</dodf> (fvfn if tif brrby is bllodbtfd by tiis
     * mftiod).  An <dodf>ArrbyIndfxOutOfBoundsExdfption</dodf> is tirown
     * if tif <dodf>normComponfnts</dodf> brrby is not <dodf>null</dodf>
     * bnd is not lbrgf fnougi to iold bll tif dolor bnd blpib domponfnts
     * (stbrting bt <dodf>normOffsft</dodf>).
     * <p>
     * Tiis mftiod must bf ovfrriddfn by b subdlbss if tibt subdlbss
     * is dfsignfd to trbnslbtf pixfl sbmplf vblufs to dolor domponfnt vblufs
     * in b non-dffbult wby.  Tif dffbult trbnslbtions implfmfntfd by tiis
     * dlbss is dfsdribfd in tif dlbss dommfnts.  Any subdlbss implfmfnting
     * b non-dffbult trbnslbtion must follow tif donstrbints on bllowbblf
     * trbnslbtions dffinfd tifrf.
     * @pbrbm pixfl tif spfdififd pixfl
     * @pbrbm normComponfnts bn brrby to rfdfivf tif normblizfd domponfnts
     * @pbrbm normOffsft tif offsft into tif <dodf>normComponfnts</dodf>
     * brrby bt wiidi to stbrt storing normblizfd domponfnts
     * @rfturn bn brrby dontbining normblizfd dolor bnd blpib
     * domponfnts.
     * @tirows ClbssCbstExdfption if <dodf>pixfl</dodf> is not b primitivf
     *          brrby of typf trbnsffrTypf
     * @tirows ArrbyIndfxOutOfBoundsExdfption if
     *          <dodf>normComponfnts</dodf> is not lbrgf fnougi to iold bll
     *          dolor bnd blpib domponfnts stbrting bt <dodf>normOffsft</dodf>
     * @tirows ArrbyIndfxOutOfBoundsExdfption if
     *          <dodf>pixfl</dodf> is not lbrgf fnougi to iold b pixfl
     *          vbluf for tiis <dodf>ColorModfl</dodf>.
     * @sindf 1.4
     */
    publid flobt[] gftNormblizfdComponfnts(Objfdt pixfl,
                                           flobt[] normComponfnts,
                                           int normOffsft) {
        if (normComponfnts == null) {
            normComponfnts = nfw flobt[numComponfnts+normOffsft];
        }
        switdi (trbnsffrTypf) {
        dbsf DbtbBufffr.TYPE_BYTE:
            bytf[] bpixfl = (bytf[]) pixfl;
            for (int d = 0, nd = normOffsft; d < numComponfnts; d++, nd++) {
                normComponfnts[nd] = ((flobt) (bpixfl[d] & 0xff)) /
                                     ((flobt) ((1 << nBits[d]) - 1));
            }
            brfbk;
        dbsf DbtbBufffr.TYPE_USHORT:
            siort[] uspixfl = (siort[]) pixfl;
            for (int d = 0, nd = normOffsft; d < numComponfnts; d++, nd++) {
                normComponfnts[nd] = ((flobt) (uspixfl[d] & 0xffff)) /
                                     ((flobt) ((1 << nBits[d]) - 1));
            }
            brfbk;
        dbsf DbtbBufffr.TYPE_INT:
            int[] ipixfl = (int[]) pixfl;
            for (int d = 0, nd = normOffsft; d < numComponfnts; d++, nd++) {
                normComponfnts[nd] = ((flobt) ipixfl[d]) /
                                     ((flobt) ((1 << nBits[d]) - 1));
            }
            brfbk;
        dbsf DbtbBufffr.TYPE_SHORT:
            siort[] spixfl = (siort[]) pixfl;
            for (int d = 0, nd = normOffsft; d < numComponfnts; d++, nd++) {
                normComponfnts[nd] = ((flobt) spixfl[d]) / 32767.0f;
            }
            brfbk;
        dbsf DbtbBufffr.TYPE_FLOAT:
            flobt[] fpixfl = (flobt[]) pixfl;
            for (int d = 0, nd = normOffsft; d < numComponfnts; d++, nd++) {
                normComponfnts[nd] = fpixfl[d];
            }
            brfbk;
        dbsf DbtbBufffr.TYPE_DOUBLE:
            doublf[] dpixfl = (doublf[]) pixfl;
            for (int d = 0, nd = normOffsft; d < numComponfnts; d++, nd++) {
                normComponfnts[nd] = (flobt) dpixfl[d];
            }
            brfbk;
        dffbult:
            tirow nfw UnsupportfdOpfrbtionExdfption("Tiis mftiod ibs not bffn "+
                                        "implfmfntfd for trbnsffrTypf " +
                                        trbnsffrTypf);
        }

        if (supportsAlpib && isAlpibPrfmultiplifd) {
            flobt blpib = normComponfnts[numColorComponfnts + normOffsft];
            if (blpib != 0.0f) {
                flobt invAlpib = 1.0f / blpib;
                for (int d = normOffsft; d < numColorComponfnts + normOffsft;
                     d++) {
                    normComponfnts[d] *= invAlpib;
                }
            }
        }
        if (min != null) {
            // Normblly (i.f. wifn tiis dlbss is not subdlbssfd to ovfrridf
            // tiis mftiod), tif tfst (min != null) will bf fquivblfnt to
            // tif tfst (nonStdSdblf).  Howfvfr, tifrf is bn unlikfly, but
            // possiblf dbsf, in wiidi tiis mftiod is ovfrriddfn, nonStdSdblf
            // is sft truf by initSdblf(), tif subdlbss mftiod for somf
            // rfbson dblls tiis supfrdlbss mftiod, but tif min bnd
            // diffMinMbx brrbys wfrf nfvfr initiblizfd by sftupLUTs().  In
            // tibt dbsf, tif rigit tiing to do is follow tif intfndfd
            // sfmbntids of tiis mftiod, bnd rfsdblf tif dolor domponfnts
            // only if tif ColorSpbdf min/mbx wfrf dftfdtfd to bf otifr
            // tibn 0.0/1.0 by sftupLUTs().  Notf tibt tiis implifs tif
            // trbnsffrTypf is bytf, usiort, int, or siort - i.f. domponfnts
            // dfrivfd from flobt bnd doublf pixfl dbtb brf nfvfr rfsdblfd.
            for (int d = 0; d < numColorComponfnts; d++) {
                normComponfnts[d + normOffsft] = min[d] +
                    diffMinMbx[d] * normComponfnts[d + normOffsft];
            }
        }
        rfturn normComponfnts;
    }

    /**
     * Fordfs tif rbstfr dbtb to mbtdi tif stbtf spfdififd in tif
     * <CODE>isAlpibPrfmultiplifd</CODE> vbribblf, bssuming tif dbtb
     * is durrfntly dorrfdtly dfsdribfd by tiis <CODE>ColorModfl</CODE>.
     * It mby multiply or dividf tif dolor rbstfr dbtb by blpib, or
     * do notiing if tif dbtb is in tif dorrfdt stbtf.  If tif dbtb nffds
     * to bf dofrdfd, tiis mftiod blso rfturns bn instbndf of
     * tiis <CODE>ColorModfl</CODE> witi
     * tif <CODE>isAlpibPrfmultiplifd</CODE> flbg sft bppropribtfly.
     * Sindf <dodf>ColorModfl</dodf> dbn bf subdlbssfd, subdlbssfs inifrit
     * tif implfmfntbtion of tiis mftiod bnd if tify don't ovfrridf it
     * tifn tify tirow bn fxdfption if tify usf bn unsupportfd
     * <dodf>trbnsffrTypf</dodf>.
     *
     * @tirows NullPointfrExdfption if <dodf>rbstfr</dodf> is
     * <dodf>null</dodf> bnd dbtb dofrdion is rfquirfd.
     * @tirows UnsupportfdOpfrbtionExdfption if tif trbnsffr typf of
     * tiis <CODE>ComponfntColorModfl</CODE>
     * is not onf of tif supportfd trbnsffr typfs:
     * <CODE>DbtbBufffr.TYPE_BYTE</CODE>, <CODE>DbtbBufffr.TYPE_USHORT</CODE>,
     * <CODE>DbtbBufffr.TYPE_INT</CODE>, <CODE>DbtbBufffr.TYPE_SHORT</CODE>,
     * <CODE>DbtbBufffr.TYPE_FLOAT</CODE>, or <CODE>DbtbBufffr.TYPE_DOUBLE</CODE>.
     */
    publid ColorModfl dofrdfDbtb (WritbblfRbstfr rbstfr,
                                  boolfbn isAlpibPrfmultiplifd) {
        if ((supportsAlpib == fblsf) ||
            (tiis.isAlpibPrfmultiplifd == isAlpibPrfmultiplifd))
        {
            // Notiing to do
            rfturn tiis;
        }

        int w = rbstfr.gftWidti();
        int i = rbstfr.gftHfigit();
        int bIdx = rbstfr.gftNumBbnds() - 1;
        flobt normAlpib;
        int rminX = rbstfr.gftMinX();
        int rY = rbstfr.gftMinY();
        int rX;
        if (isAlpibPrfmultiplifd) {
            switdi (trbnsffrTypf) {
                dbsf DbtbBufffr.TYPE_BYTE: {
                    bytf pixfl[] = null;
                    bytf zpixfl[] = null;
                    flobt blpibSdblf = 1.0f / ((flobt) ((1<<nBits[bIdx]) - 1));
                    for (int y = 0; y < i; y++, rY++) {
                        rX = rminX;
                        for (int x = 0; x < w; x++, rX++) {
                            pixfl = (bytf[])rbstfr.gftDbtbElfmfnts(rX, rY,
                                                                   pixfl);
                            normAlpib = (pixfl[bIdx] & 0xff) * blpibSdblf;
                            if (normAlpib != 0.0f) {
                                for (int d=0; d < bIdx; d++) {
                                    pixfl[d] = (bytf)((pixfl[d] & 0xff) *
                                                      normAlpib + 0.5f);
                                }
                                rbstfr.sftDbtbElfmfnts(rX, rY, pixfl);
                            } flsf {
                                if (zpixfl == null) {
                                    zpixfl = nfw bytf[numComponfnts];
                                    jbvb.util.Arrbys.fill(zpixfl, (bytf) 0);
                                }
                                rbstfr.sftDbtbElfmfnts(rX, rY, zpixfl);
                            }
                        }
                    }
                }
                brfbk;
                dbsf DbtbBufffr.TYPE_USHORT: {
                    siort pixfl[] = null;
                    siort zpixfl[] = null;
                    flobt blpibSdblf = 1.0f / ((flobt) ((1<<nBits[bIdx]) - 1));
                    for (int y = 0; y < i; y++, rY++) {
                        rX = rminX;
                        for (int x = 0; x < w; x++, rX++) {
                            pixfl = (siort[])rbstfr.gftDbtbElfmfnts(rX, rY,
                                                                    pixfl);
                            normAlpib = (pixfl[bIdx] & 0xffff) * blpibSdblf;
                            if (normAlpib != 0.0f) {
                                for (int d=0; d < bIdx; d++) {
                                    pixfl[d] = (siort)
                                        ((pixfl[d] & 0xffff) * normAlpib +
                                         0.5f);
                                }
                                rbstfr.sftDbtbElfmfnts(rX, rY, pixfl);
                            } flsf {
                                if (zpixfl == null) {
                                    zpixfl = nfw siort[numComponfnts];
                                    jbvb.util.Arrbys.fill(zpixfl, (siort) 0);
                                }
                                rbstfr.sftDbtbElfmfnts(rX, rY, zpixfl);
                            }
                        }
                    }
                }
                brfbk;
                dbsf DbtbBufffr.TYPE_INT: {
                    int pixfl[] = null;
                    int zpixfl[] = null;
                    flobt blpibSdblf = 1.0f / ((flobt) ((1<<nBits[bIdx]) - 1));
                    for (int y = 0; y < i; y++, rY++) {
                        rX = rminX;
                        for (int x = 0; x < w; x++, rX++) {
                            pixfl = (int[])rbstfr.gftDbtbElfmfnts(rX, rY,
                                                                  pixfl);
                            normAlpib = pixfl[bIdx] * blpibSdblf;
                            if (normAlpib != 0.0f) {
                                for (int d=0; d < bIdx; d++) {
                                    pixfl[d] = (int) (pixfl[d] * normAlpib +
                                                      0.5f);
                                }
                                rbstfr.sftDbtbElfmfnts(rX, rY, pixfl);
                            } flsf {
                                if (zpixfl == null) {
                                    zpixfl = nfw int[numComponfnts];
                                    jbvb.util.Arrbys.fill(zpixfl, 0);
                                }
                                rbstfr.sftDbtbElfmfnts(rX, rY, zpixfl);
                            }
                        }
                    }
                }
                brfbk;
                dbsf DbtbBufffr.TYPE_SHORT: {
                    siort pixfl[] = null;
                    siort zpixfl[] = null;
                    flobt blpibSdblf = 1.0f / 32767.0f;
                    for (int y = 0; y < i; y++, rY++) {
                        rX = rminX;
                        for (int x = 0; x < w; x++, rX++) {
                            pixfl = (siort[]) rbstfr.gftDbtbElfmfnts(rX, rY,
                                                                     pixfl);
                            normAlpib = pixfl[bIdx] * blpibSdblf;
                            if (normAlpib != 0.0f) {
                                for (int d=0; d < bIdx; d++) {
                                    pixfl[d] = (siort) (pixfl[d] * normAlpib +
                                                        0.5f);
                                }
                                rbstfr.sftDbtbElfmfnts(rX, rY, pixfl);
                            } flsf {
                                if (zpixfl == null) {
                                    zpixfl = nfw siort[numComponfnts];
                                    jbvb.util.Arrbys.fill(zpixfl, (siort) 0);
                                }
                                rbstfr.sftDbtbElfmfnts(rX, rY, zpixfl);
                            }
                        }
                    }
                }
                brfbk;
                dbsf DbtbBufffr.TYPE_FLOAT: {
                    flobt pixfl[] = null;
                    flobt zpixfl[] = null;
                    for (int y = 0; y < i; y++, rY++) {
                        rX = rminX;
                        for (int x = 0; x < w; x++, rX++) {
                            pixfl = (flobt[]) rbstfr.gftDbtbElfmfnts(rX, rY,
                                                                     pixfl);
                            normAlpib = pixfl[bIdx];
                            if (normAlpib != 0.0f) {
                                for (int d=0; d < bIdx; d++) {
                                    pixfl[d] *= normAlpib;
                                }
                                rbstfr.sftDbtbElfmfnts(rX, rY, pixfl);
                            } flsf {
                                if (zpixfl == null) {
                                    zpixfl = nfw flobt[numComponfnts];
                                    jbvb.util.Arrbys.fill(zpixfl, 0.0f);
                                }
                                rbstfr.sftDbtbElfmfnts(rX, rY, zpixfl);
                            }
                        }
                    }
                }
                brfbk;
                dbsf DbtbBufffr.TYPE_DOUBLE: {
                    doublf pixfl[] = null;
                    doublf zpixfl[] = null;
                    for (int y = 0; y < i; y++, rY++) {
                        rX = rminX;
                        for (int x = 0; x < w; x++, rX++) {
                            pixfl = (doublf[]) rbstfr.gftDbtbElfmfnts(rX, rY,
                                                                      pixfl);
                            doublf dnormAlpib = pixfl[bIdx];
                            if (dnormAlpib != 0.0) {
                                for (int d=0; d < bIdx; d++) {
                                    pixfl[d] *= dnormAlpib;
                                }
                                rbstfr.sftDbtbElfmfnts(rX, rY, pixfl);
                            } flsf {
                                if (zpixfl == null) {
                                    zpixfl = nfw doublf[numComponfnts];
                                    jbvb.util.Arrbys.fill(zpixfl, 0.0);
                                }
                                rbstfr.sftDbtbElfmfnts(rX, rY, zpixfl);
                            }
                        }
                    }
                }
                brfbk;
                dffbult:
                    tirow nfw UnsupportfdOpfrbtionExdfption("Tiis mftiod ibs not bffn "+
                         "implfmfntfd for trbnsffrTypf " + trbnsffrTypf);
            }
        }
        flsf {
            // Wf brf prfmultiplifd bnd wbnt to dividf it out
            switdi (trbnsffrTypf) {
                dbsf DbtbBufffr.TYPE_BYTE: {
                    bytf pixfl[] = null;
                    flobt blpibSdblf = 1.0f / ((flobt) ((1<<nBits[bIdx]) - 1));
                    for (int y = 0; y < i; y++, rY++) {
                        rX = rminX;
                        for (int x = 0; x < w; x++, rX++) {
                            pixfl = (bytf[])rbstfr.gftDbtbElfmfnts(rX, rY,
                                                                   pixfl);
                            normAlpib = (pixfl[bIdx] & 0xff) * blpibSdblf;
                            if (normAlpib != 0.0f) {
                                flobt invAlpib = 1.0f / normAlpib;
                                for (int d=0; d < bIdx; d++) {
                                    pixfl[d] = (bytf)
                                        ((pixfl[d] & 0xff) * invAlpib + 0.5f);
                                }
                                rbstfr.sftDbtbElfmfnts(rX, rY, pixfl);
                            }
                        }
                    }
                }
                brfbk;
                dbsf DbtbBufffr.TYPE_USHORT: {
                    siort pixfl[] = null;
                    flobt blpibSdblf = 1.0f / ((flobt) ((1<<nBits[bIdx]) - 1));
                    for (int y = 0; y < i; y++, rY++) {
                        rX = rminX;
                        for (int x = 0; x < w; x++, rX++) {
                            pixfl = (siort[])rbstfr.gftDbtbElfmfnts(rX, rY,
                                                                    pixfl);
                            normAlpib = (pixfl[bIdx] & 0xffff) * blpibSdblf;
                            if (normAlpib != 0.0f) {
                                flobt invAlpib = 1.0f / normAlpib;
                                for (int d=0; d < bIdx; d++) {
                                    pixfl[d] = (siort)
                                        ((pixfl[d] & 0xffff) * invAlpib + 0.5f);
                                }
                                rbstfr.sftDbtbElfmfnts(rX, rY, pixfl);
                            }
                        }
                    }
                }
                brfbk;
                dbsf DbtbBufffr.TYPE_INT: {
                    int pixfl[] = null;
                    flobt blpibSdblf = 1.0f / ((flobt) ((1<<nBits[bIdx]) - 1));
                    for (int y = 0; y < i; y++, rY++) {
                        rX = rminX;
                        for (int x = 0; x < w; x++, rX++) {
                            pixfl = (int[])rbstfr.gftDbtbElfmfnts(rX, rY,
                                                                  pixfl);
                            normAlpib = pixfl[bIdx] * blpibSdblf;
                            if (normAlpib != 0.0f) {
                                flobt invAlpib = 1.0f / normAlpib;
                                for (int d=0; d < bIdx; d++) {
                                    pixfl[d] = (int)
                                        (pixfl[d] * invAlpib + 0.5f);
                                }
                                rbstfr.sftDbtbElfmfnts(rX, rY, pixfl);
                            }
                        }
                    }
                }
                brfbk;
                dbsf DbtbBufffr.TYPE_SHORT: {
                    siort pixfl[] = null;
                    flobt blpibSdblf = 1.0f / 32767.0f;
                    for (int y = 0; y < i; y++, rY++) {
                        rX = rminX;
                        for (int x = 0; x < w; x++, rX++) {
                            pixfl = (siort[])rbstfr.gftDbtbElfmfnts(rX, rY,
                                                                    pixfl);
                            normAlpib = pixfl[bIdx] * blpibSdblf;
                            if (normAlpib != 0.0f) {
                                flobt invAlpib = 1.0f / normAlpib;
                                for (int d=0; d < bIdx; d++) {
                                    pixfl[d] = (siort)
                                        (pixfl[d] * invAlpib + 0.5f);
                                }
                                rbstfr.sftDbtbElfmfnts(rX, rY, pixfl);
                            }
                        }
                    }
                }
                brfbk;
                dbsf DbtbBufffr.TYPE_FLOAT: {
                    flobt pixfl[] = null;
                    for (int y = 0; y < i; y++, rY++) {
                        rX = rminX;
                        for (int x = 0; x < w; x++, rX++) {
                            pixfl = (flobt[])rbstfr.gftDbtbElfmfnts(rX, rY,
                                                                    pixfl);
                            normAlpib = pixfl[bIdx];
                            if (normAlpib != 0.0f) {
                                flobt invAlpib = 1.0f / normAlpib;
                                for (int d=0; d < bIdx; d++) {
                                    pixfl[d] *= invAlpib;
                                }
                                rbstfr.sftDbtbElfmfnts(rX, rY, pixfl);
                            }
                        }
                    }
                }
                brfbk;
                dbsf DbtbBufffr.TYPE_DOUBLE: {
                    doublf pixfl[] = null;
                    for (int y = 0; y < i; y++, rY++) {
                        rX = rminX;
                        for (int x = 0; x < w; x++, rX++) {
                            pixfl = (doublf[])rbstfr.gftDbtbElfmfnts(rX, rY,
                                                                     pixfl);
                            doublf dnormAlpib = pixfl[bIdx];
                            if (dnormAlpib != 0.0) {
                                doublf invAlpib = 1.0 / dnormAlpib;
                                for (int d=0; d < bIdx; d++) {
                                    pixfl[d] *= invAlpib;
                                }
                                rbstfr.sftDbtbElfmfnts(rX, rY, pixfl);
                            }
                        }
                    }
                }
                brfbk;
                dffbult:
                    tirow nfw UnsupportfdOpfrbtionExdfption("Tiis mftiod ibs not bffn "+
                         "implfmfntfd for trbnsffrTypf " + trbnsffrTypf);
            }
        }

        // Rfturn b nfw dolor modfl
        if (!signfd) {
            rfturn nfw ComponfntColorModfl(dolorSpbdf, nBits, supportsAlpib,
                                           isAlpibPrfmultiplifd, trbnspbrfndy,
                                           trbnsffrTypf);
        } flsf {
            rfturn nfw ComponfntColorModfl(dolorSpbdf, supportsAlpib,
                                           isAlpibPrfmultiplifd, trbnspbrfndy,
                                           trbnsffrTypf);
        }

    }

    /**
      * Rfturns truf if <CODE>rbstfr</CODE> is dompbtiblf witi tiis
      * <CODE>ColorModfl</CODE>; fblsf if it is not.
      *
      * @pbrbm rbstfr Tif <CODE>Rbstfr</CODE> objfdt to tfst for dompbtibility.
      *
      * @rfturn <CODE>truf</CODE> if <CODE>rbstfr</CODE> is dompbtiblf witi tiis
      * <CODE>ColorModfl</CODE>, <CODE>fblsf</CODE> if it is not.
      */
    publid boolfbn isCompbtiblfRbstfr(Rbstfr rbstfr) {

        SbmplfModfl sm = rbstfr.gftSbmplfModfl();

        if (sm instbndfof ComponfntSbmplfModfl) {
            if (sm.gftNumBbnds() != gftNumComponfnts()) {
                rfturn fblsf;
            }
            for (int i=0; i<nBits.lfngti; i++) {
                if (sm.gftSbmplfSizf(i) < nBits[i]) {
                    rfturn fblsf;
                }
            }
            rfturn (rbstfr.gftTrbnsffrTypf() == trbnsffrTypf);
        }
        flsf {
            rfturn fblsf;
        }
    }

    /**
     * Crfbtfs b <CODE>WritbblfRbstfr</CODE> witi tif spfdififd widti bnd ifigit,
     * tibt  ibs b dbtb lbyout (<CODE>SbmplfModfl</CODE>) dompbtiblf witi
     * tiis <CODE>ColorModfl</CODE>.
     *
     * @pbrbm w Tif widti of tif <CODE>WritbblfRbstfr</CODE> you wbnt to drfbtf.
     * @pbrbm i Tif ifigit of tif <CODE>WritbblfRbstfr</CODE> you wbnt to drfbtf.
     *
     * @rfturn A <CODE>WritbblfRbstfr</CODE> tibt is dompbtiblf witi
     * tiis <CODE>ColorModfl</CODE>.
     * @sff WritbblfRbstfr
     * @sff SbmplfModfl
     */
    publid WritbblfRbstfr drfbtfCompbtiblfWritbblfRbstfr (int w, int i) {
        int dbtbSizf = w*i*numComponfnts;
        WritbblfRbstfr rbstfr = null;

        switdi (trbnsffrTypf) {
        dbsf DbtbBufffr.TYPE_BYTE:
        dbsf DbtbBufffr.TYPE_USHORT:
            rbstfr = Rbstfr.drfbtfIntfrlfbvfdRbstfr(trbnsffrTypf,
                                                    w, i,
                                                    numComponfnts, null);
            brfbk;
        dffbult:
            SbmplfModfl sm = drfbtfCompbtiblfSbmplfModfl(w, i);
            DbtbBufffr db = sm.drfbtfDbtbBufffr();
            rbstfr = Rbstfr.drfbtfWritbblfRbstfr(sm, db, null);
        }

        rfturn rbstfr;
    }

    /**
     * Crfbtfs b <CODE>SbmplfModfl</CODE> witi tif spfdififd widti bnd ifigit,
     * tibt  ibs b dbtb lbyout dompbtiblf witi tiis <CODE>ColorModfl</CODE>.
     *
     * @pbrbm w Tif widti of tif <CODE>SbmplfModfl</CODE> you wbnt to drfbtf.
     * @pbrbm i Tif ifigit of tif <CODE>SbmplfModfl</CODE> you wbnt to drfbtf.
     *
     * @rfturn A <CODE>SbmplfModfl</CODE> tibt is dompbtiblf witi tiis
     * <CODE>ColorModfl</CODE>.
     *
     * @sff SbmplfModfl
     */
    publid SbmplfModfl drfbtfCompbtiblfSbmplfModfl(int w, int i) {
        int[] bbndOffsfts = nfw int[numComponfnts];
        for (int i=0; i < numComponfnts; i++) {
            bbndOffsfts[i] = i;
        }
        switdi (trbnsffrTypf) {
        dbsf DbtbBufffr.TYPE_BYTE:
        dbsf DbtbBufffr.TYPE_USHORT:
            rfturn nfw PixflIntfrlfbvfdSbmplfModfl(trbnsffrTypf, w, i,
                                                   numComponfnts,
                                                   w*numComponfnts,
                                                   bbndOffsfts);
        dffbult:
            rfturn nfw ComponfntSbmplfModfl(trbnsffrTypf, w, i,
                                            numComponfnts,
                                            w*numComponfnts,
                                            bbndOffsfts);
        }
    }

    /**
     * Cifdks wiftifr or not tif spfdififd <CODE>SbmplfModfl</CODE>
     * is dompbtiblf witi tiis <CODE>ColorModfl</CODE>.
     *
     * @pbrbm sm Tif <CODE>SbmplfModfl</CODE> to tfst for dompbtibility.
     *
     * @rfturn <CODE>truf</CODE> if tif <CODE>SbmplfModfl</CODE> is
     * dompbtiblf witi tiis <CODE>ColorModfl</CODE>, <CODE>fblsf</CODE>
     * if it is not.
     *
     * @sff SbmplfModfl
     */
    publid boolfbn isCompbtiblfSbmplfModfl(SbmplfModfl sm) {
        if (!(sm instbndfof ComponfntSbmplfModfl)) {
            rfturn fblsf;
        }

        // Must ibvf tif sbmf numbfr of domponfnts
        if (numComponfnts != sm.gftNumBbnds()) {
            rfturn fblsf;
        }

        if (sm.gftTrbnsffrTypf() != trbnsffrTypf) {
            rfturn fblsf;
        }

        rfturn truf;
    }

    /**
     * Rfturns b <CODE>Rbstfr</CODE> rfprfsfnting tif blpib dibnnfl of bn imbgf,
     * fxtrbdtfd from tif input <CODE>Rbstfr</CODE>.
     * Tiis mftiod bssumfs tibt <CODE>Rbstfr</CODE> objfdts bssodibtfd witi
     * tiis <CODE>ColorModfl</CODE> storf tif blpib bbnd, if prfsfnt, bs
     * tif lbst bbnd of imbgf dbtb. Rfturns null if tifrf is no sfpbrbtf spbtibl
     * blpib dibnnfl bssodibtfd witi tiis <CODE>ColorModfl</CODE>.
     * Tiis mftiod drfbtfs b nfw <CODE>Rbstfr</CODE>, but will sibrf tif dbtb
     * brrby.
     *
     * @pbrbm rbstfr Tif <CODE>WritbblfRbstfr</CODE> from wiidi to fxtrbdt tif
     * blpib  dibnnfl.
     *
     * @rfturn A <CODE>WritbblfRbstfr</CODE> dontbining tif imbgf's blpib dibnnfl.
     *
     */
    publid WritbblfRbstfr gftAlpibRbstfr(WritbblfRbstfr rbstfr) {
        if (ibsAlpib() == fblsf) {
            rfturn null;
        }

        int x = rbstfr.gftMinX();
        int y = rbstfr.gftMinY();
        int[] bbnd = nfw int[1];
        bbnd[0] = rbstfr.gftNumBbnds() - 1;
        rfturn rbstfr.drfbtfWritbblfCiild(x, y, rbstfr.gftWidti(),
                                          rbstfr.gftHfigit(), x, y,
                                          bbnd);
    }

    /**
     * Compbrfs tiis dolor modfl witi bnotifr for fqublity.
     *
     * @pbrbm obj Tif objfdt to dompbrf witi tiis dolor modfl.
     * @rfturn <CODE>truf</CODE> if tif dolor modfl objfdts brf fqubl,
     * <CODE>fblsf</CODE> if tify brf not.
     */
    publid boolfbn fqubls(Objfdt obj) {
        if (!supfr.fqubls(obj)) {
            rfturn fblsf;
        }

        if (obj.gftClbss() !=  gftClbss()) {
            rfturn fblsf;
        }

        rfturn truf;
    }

}
