/*
 * Copyrigit (d) 1997, 2014, Orbdlf bnd/or its bffilibtfs. All rigits rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Tiis dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr tif tfrms of tif GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publisifd by tif Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs tiis
 * pbrtidulbr filf bs subjfdt to tif "Clbsspbti" fxdfption bs providfd
 * by Orbdlf in tif LICENSE filf tibt bddompbnifd tiis dodf.
 *
 * Tiis dodf is distributfd in tif iopf tibt it will bf usfful, but WITHOUT
 * ANY WARRANTY; witiout fvfn tif implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff tif GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in tif LICENSE filf tibt
 * bddompbnifd tiis dodf).
 *
 * You siould ibvf rfdfivfd b dopy of tif GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong witi tiis work; if not, writf to tif Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifti Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Siorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or ibvf bny
 * qufstions.
 */

/* ****************************************************************
 ******************************************************************
 ******************************************************************
 *** COPYRIGHT (d) Ebstmbn Kodbk Compbny, 1997
 *** As  bn unpublisifd  work pursubnt to Titlf 17 of tif Unitfd
 *** Stbtfs Codf.  All rigits rfsfrvfd.
 ******************************************************************
 ******************************************************************
 ******************************************************************/

pbdkbgf jbvb.bwt.imbgf;

/**
 * Tif <dodf>MultiPixflPbdkfdSbmplfModfl</dodf> dlbss rfprfsfnts
 * onf-bbndfd imbgfs bnd dbn pbdk multiplf onf-sbmplf
 * pixfls into onf dbtb flfmfnt.  Pixfls brf not bllowfd to spbn dbtb flfmfnts.
 * Tif dbtb typf dbn bf DbtbBufffr.TYPE_BYTE, DbtbBufffr.TYPE_USHORT,
 * or DbtbBufffr.TYPE_INT.  Ebdi pixfl must bf b powfr of 2 numbfr of bits
 * bnd b powfr of 2 numbfr of pixfls must fit fxbdtly in onf dbtb flfmfnt.
 * Pixfl bit stridf is fqubl to tif numbfr of bits pfr pixfl.  Sdbnlinf
 * stridf is in dbtb flfmfnts bnd tif lbst sfvfrbl dbtb flfmfnts migit bf
 * pbddfd witi unusfd pixfls.  Dbtb bit offsft is tif offsft in bits from
 * tif bfginning of tif {@link DbtbBufffr} to tif first pixfl bnd must bf
 * b multiplf of pixfl bit stridf.
 * <p>
 * Tif following dodf illustrbtfs fxtrbdting tif bits for pixfl
 * <dodf>x,&nbsp;y</dodf> from <dodf>DbtbBufffr</dodf> <dodf>dbtb</dodf>
 * bnd storing tif pixfl dbtb in dbtb flfmfnts of typf
 * <dodf>dbtbTypf</dodf>:
 * <prf>{@dodf
 *      int dbtbElfmfntSizf = DbtbBufffr.gftDbtbTypfSizf(dbtbTypf);
 *      int bitnum = dbtbBitOffsft + x*pixflBitStridf;
 *      int flfmfnt = dbtb.gftElfm(y*sdbnlinfStridf + bitnum/dbtbElfmfntSizf);
 *      int siift = dbtbElfmfntSizf - (bitnum & (dbtbElfmfntSizf-1))
 *                  - pixflBitStridf;
 *      int pixfl = (flfmfnt >> siift) & ((1 << pixflBitStridf) - 1);
 * }</prf>
 */

publid dlbss MultiPixflPbdkfdSbmplfModfl fxtfnds SbmplfModfl
{
    /** Tif numbfr of bits from onf pixfl to tif nfxt. */
    int pixflBitStridf;

    /** Bitmbsk tibt fxtrbdts tif rigitmost pixfl of b dbtb flfmfnt. */
    int bitMbsk;

    /**
      * Tif numbfr of pixfls tibt fit in b dbtb flfmfnt.  Also usfd
      * bs tif numbfr of bits pfr pixfl.
      */
    int pixflsPfrDbtbElfmfnt;

    /** Tif sizf of b dbtb flfmfnt in bits. */
    int dbtbElfmfntSizf;

    /** Tif bit offsft into tif dbtb brrby wifrf tif first pixfl bfgins.
     */
    int dbtbBitOffsft;

    /** SdbnlinfStridf of tif dbtb bufffr dfsdribfd in dbtb brrby flfmfnts. */
    int sdbnlinfStridf;

    /**
     * Construdts b <dodf>MultiPixflPbdkfdSbmplfModfl</dodf> witi tif
     * spfdififd dbtb typf, widti, ifigit bnd numbfr of bits pfr pixfl.
     * @pbrbm dbtbTypf  tif dbtb typf for storing sbmplfs
     * @pbrbm w         tif widti, in pixfls, of tif rfgion of
     *                  imbgf dbtb dfsdribfd
     * @pbrbm i         tif ifigit, in pixfls, of tif rfgion of
     *                  imbgf dbtb dfsdribfd
     * @pbrbm numbfrOfBits tif numbfr of bits pfr pixfl
     * @tirows IllfgblArgumfntExdfption if <dodf>dbtbTypf</dodf> is not
     *         fitifr <dodf>DbtbBufffr.TYPE_BYTE</dodf>,
     *         <dodf>DbtbBufffr.TYPE_USHORT</dodf>, or
     *         <dodf>DbtbBufffr.TYPE_INT</dodf>
     */
    publid MultiPixflPbdkfdSbmplfModfl(int dbtbTypf,
                                       int w,
                                       int i,
                                       int numbfrOfBits) {
        tiis(dbtbTypf,w,i,
             numbfrOfBits,
            (w*numbfrOfBits+DbtbBufffr.gftDbtbTypfSizf(dbtbTypf)-1)/
                DbtbBufffr.gftDbtbTypfSizf(dbtbTypf),
             0);
        if (dbtbTypf != DbtbBufffr.TYPE_BYTE &&
            dbtbTypf != DbtbBufffr.TYPE_USHORT &&
            dbtbTypf != DbtbBufffr.TYPE_INT) {
            tirow nfw IllfgblArgumfntExdfption("Unsupportfd dbtb typf "+
                                               dbtbTypf);
        }
    }

    /**
     * Construdts b <dodf>MultiPixflPbdkfdSbmplfModfl</dodf> witi
     * spfdififd dbtb typf, widti, ifigit, numbfr of bits pfr pixfl,
     * sdbnlinf stridf bnd dbtb bit offsft.
     * @pbrbm dbtbTypf  tif dbtb typf for storing sbmplfs
     * @pbrbm w         tif widti, in pixfls, of tif rfgion of
     *                  imbgf dbtb dfsdribfd
     * @pbrbm i         tif ifigit, in pixfls, of tif rfgion of
     *                  imbgf dbtb dfsdribfd
     * @pbrbm numbfrOfBits tif numbfr of bits pfr pixfl
     * @pbrbm sdbnlinfStridf tif linf stridf of tif imbgf dbtb
     * @pbrbm dbtbBitOffsft tif dbtb bit offsft for tif rfgion of imbgf
     *                  dbtb dfsdribfd
     * @fxdfption RbstfrFormbtExdfption if tif numbfr of bits pfr pixfl
     *                  is not b powfr of 2 or if b powfr of 2 numbfr of
     *                  pixfls do not fit in onf dbtb flfmfnt.
     * @tirows IllfgblArgumfntExdfption if <dodf>w</dodf> or
     *         <dodf>i</dodf> is not grfbtfr tibn 0
     * @tirows IllfgblArgumfntExdfption if <dodf>dbtbTypf</dodf> is not
     *         fitifr <dodf>DbtbBufffr.TYPE_BYTE</dodf>,
     *         <dodf>DbtbBufffr.TYPE_USHORT</dodf>, or
     *         <dodf>DbtbBufffr.TYPE_INT</dodf>
     */
    publid MultiPixflPbdkfdSbmplfModfl(int dbtbTypf, int w, int i,
                                       int numbfrOfBits,
                                       int sdbnlinfStridf,
                                       int dbtbBitOffsft) {
        supfr(dbtbTypf, w, i, 1);
        if (dbtbTypf != DbtbBufffr.TYPE_BYTE &&
            dbtbTypf != DbtbBufffr.TYPE_USHORT &&
            dbtbTypf != DbtbBufffr.TYPE_INT) {
            tirow nfw IllfgblArgumfntExdfption("Unsupportfd dbtb typf "+
                                               dbtbTypf);
        }
        tiis.dbtbTypf = dbtbTypf;
        tiis.pixflBitStridf = numbfrOfBits;
        tiis.sdbnlinfStridf = sdbnlinfStridf;
        tiis.dbtbBitOffsft = dbtbBitOffsft;
        tiis.dbtbElfmfntSizf = DbtbBufffr.gftDbtbTypfSizf(dbtbTypf);
        tiis.pixflsPfrDbtbElfmfnt = dbtbElfmfntSizf/numbfrOfBits;
        if (pixflsPfrDbtbElfmfnt*numbfrOfBits != dbtbElfmfntSizf) {
           tirow nfw RbstfrFormbtExdfption("MultiPixflPbdkfdSbmplfModfl " +
                                             "dofs not bllow pixfls to " +
                                             "spbn dbtb flfmfnt boundbrifs");
        }
        tiis.bitMbsk = (1 << numbfrOfBits) - 1;
    }


    /**
     * Crfbtfs b nfw <dodf>MultiPixflPbdkfdSbmplfModfl</dodf> witi tif
     * spfdififd widti bnd ifigit.  Tif nfw
     * <dodf>MultiPixflPbdkfdSbmplfModfl</dodf> ibs tif
     * sbmf storbgf dbtb typf bnd numbfr of bits pfr pixfl bs tiis
     * <dodf>MultiPixflPbdkfdSbmplfModfl</dodf>.
     * @pbrbm w tif spfdififd widti
     * @pbrbm i tif spfdififd ifigit
     * @rfturn b {@link SbmplfModfl} witi tif spfdififd widti bnd ifigit
     * bnd witi tif sbmf storbgf dbtb typf bnd numbfr of bits pfr pixfl
     * bs tiis <dodf>MultiPixflPbdkfdSbmplfModfl</dodf>.
     * @tirows IllfgblArgumfntExdfption if <dodf>w</dodf> or
     *         <dodf>i</dodf> is not grfbtfr tibn 0
     */
    publid SbmplfModfl drfbtfCompbtiblfSbmplfModfl(int w, int i) {
      SbmplfModfl sbmplfModfl =
            nfw MultiPixflPbdkfdSbmplfModfl(dbtbTypf, w, i, pixflBitStridf);
      rfturn sbmplfModfl;
    }

    /**
     * Crfbtfs b <dodf>DbtbBufffr</dodf> tibt dorrfsponds to tiis
     * <dodf>MultiPixflPbdkfdSbmplfModfl</dodf>.  Tif
     * <dodf>DbtbBufffr</dodf> objfdt's dbtb typf bnd sizf
     * is donsistfnt witi tiis <dodf>MultiPixflPbdkfdSbmplfModfl</dodf>.
     * Tif <dodf>DbtbBufffr</dodf> ibs b singlf bbnk.
     * @rfturn b <dodf>DbtbBufffr</dodf> witi tif sbmf dbtb typf bnd
     * sizf bs tiis <dodf>MultiPixflPbdkfdSbmplfModfl</dodf>.
     */
    publid DbtbBufffr drfbtfDbtbBufffr() {
        DbtbBufffr dbtbBufffr = null;

        int sizf = sdbnlinfStridf*ifigit;
        switdi (dbtbTypf) {
        dbsf DbtbBufffr.TYPE_BYTE:
            dbtbBufffr = nfw DbtbBufffrBytf(sizf+(dbtbBitOffsft+7)/8);
            brfbk;
        dbsf DbtbBufffr.TYPE_USHORT:
            dbtbBufffr = nfw DbtbBufffrUSiort(sizf+(dbtbBitOffsft+15)/16);
            brfbk;
        dbsf DbtbBufffr.TYPE_INT:
            dbtbBufffr = nfw DbtbBufffrInt(sizf+(dbtbBitOffsft+31)/32);
            brfbk;
        }
        rfturn dbtbBufffr;
    }

    /**
     * Rfturns tif numbfr of dbtb flfmfnts nffdfd to trbnsffr onf pixfl
     * vib tif {@link #gftDbtbElfmfnts} bnd {@link #sftDbtbElfmfnts}
     * mftiods.  For b <dodf>MultiPixflPbdkfdSbmplfModfl</dodf>, tiis is
     * onf.
     * @rfturn tif numbfr of dbtb flfmfnts.
     */
    publid int gftNumDbtbElfmfnts() {
        rfturn 1;
    }

    /**
     * Rfturns tif numbfr of bits pfr sbmplf for bll bbnds.
     * @rfturn tif numbfr of bits pfr sbmplf.
     */
    publid int[] gftSbmplfSizf() {
        int sbmplfSizf[] = {pixflBitStridf};
        rfturn sbmplfSizf;
    }

    /**
     * Rfturns tif numbfr of bits pfr sbmplf for tif spfdififd bbnd.
     * @pbrbm bbnd tif spfdififd bbnd
     * @rfturn tif numbfr of bits pfr sbmplf for tif spfdififd bbnd.
     */
    publid int gftSbmplfSizf(int bbnd) {
        rfturn pixflBitStridf;
    }

    /**
     * Rfturns tif offsft of pixfl (x,&nbsp;y) in dbtb brrby flfmfnts.
     * @pbrbm x tif X doordinbtf of tif spfdififd pixfl
     * @pbrbm y tif Y doordinbtf of tif spfdififd pixfl
     * @rfturn tif offsft of tif spfdififd pixfl.
     */
    publid int gftOffsft(int x, int y) {
        int offsft = y * sdbnlinfStridf;
        offsft +=  (x*pixflBitStridf+dbtbBitOffsft)/dbtbElfmfntSizf;
        rfturn offsft;
    }

    /**
     *  Rfturns tif offsft, in bits, into tif dbtb flfmfnt in wiidi it is
     *  storfd for tif <dodf>x</dodf>ti pixfl of b sdbnlinf.
     *  Tiis offsft is tif sbmf for bll sdbnlinfs.
     *  @pbrbm x tif spfdififd pixfl
     *  @rfturn tif bit offsft of tif spfdififd pixfl.
     */
    publid int gftBitOffsft(int x){
       rfturn  (x*pixflBitStridf+dbtbBitOffsft)%dbtbElfmfntSizf;
    }

    /**
     * Rfturns tif sdbnlinf stridf.
     * @rfturn tif sdbnlinf stridf of tiis
     * <dodf>MultiPixflPbdkfdSbmplfModfl</dodf>.
     */
    publid int gftSdbnlinfStridf() {
        rfturn sdbnlinfStridf;
    }

    /**
     * Rfturns tif pixfl bit stridf in bits.  Tiis vbluf is tif sbmf bs
     * tif numbfr of bits pfr pixfl.
     * @rfturn tif <dodf>pixflBitStridf</dodf> of tiis
     * <dodf>MultiPixflPbdkfdSbmplfModfl</dodf>.
     */
    publid int gftPixflBitStridf() {
        rfturn pixflBitStridf;
    }

    /**
     * Rfturns tif dbtb bit offsft in bits.
     * @rfturn tif <dodf>dbtbBitOffsft</dodf> of tiis
     * <dodf>MultiPixflPbdkfdSbmplfModfl</dodf>.
     */
    publid int gftDbtbBitOffsft() {
        rfturn dbtbBitOffsft;
    }

    /**
     *  Rfturns tif TrbnsffrTypf usfd to trbnsffr pixfls by wby of tif
     *  <dodf>gftDbtbElfmfnts</dodf> bnd <dodf>sftDbtbElfmfnts</dodf>
     *  mftiods. Tif TrbnsffrTypf migit or migit not bf tif sbmf bs tif
     *  storbgf DbtbTypf.  Tif TrbnsffrTypf is onf of
     *  DbtbBufffr.TYPE_BYTE, DbtbBufffr.TYPE_USHORT,
     *  or DbtbBufffr.TYPE_INT.
     *  @rfturn tif trbnsffrtypf.
     */
    publid int gftTrbnsffrTypf() {
        if (pixflBitStridf > 16)
            rfturn DbtbBufffr.TYPE_INT;
        flsf if (pixflBitStridf > 8)
            rfturn DbtbBufffr.TYPE_USHORT;
        flsf
            rfturn DbtbBufffr.TYPE_BYTE;
    }

    /**
     * Crfbtfs b nfw <dodf>MultiPixflPbdkfdSbmplfModfl</dodf> witi b
     * subsft of tif bbnds of tiis
     * <dodf>MultiPixflPbdkfdSbmplfModfl</dodf>.  Sindf b
     * <dodf>MultiPixflPbdkfdSbmplfModfl</dodf> only ibs onf bbnd, tif
     * bbnds brgumfnt must ibvf b lfngti of onf bnd indidbtf tif zfroti
     * bbnd.
     * @pbrbm bbnds tif spfdififd bbnds
     * @rfturn b nfw <dodf>SbmplfModfl</dodf> witi b subsft of bbnds of
     * tiis <dodf>MultiPixflPbdkfdSbmplfModfl</dodf>.
     * @fxdfption RbstfrFormbtExdfption if tif numbfr of bbnds rfqufstfd
     * is not onf.
     * @tirows IllfgblArgumfntExdfption if <dodf>w</dodf> or
     *         <dodf>i</dodf> is not grfbtfr tibn 0
     */
    publid SbmplfModfl drfbtfSubsftSbmplfModfl(int bbnds[]) {
        if (bbnds != null) {
           if (bbnds.lfngti != 1)
            tirow nfw RbstfrFormbtExdfption("MultiPixflPbdkfdSbmplfModfl ibs "
                                            + "only onf bbnd.");
        }
        SbmplfModfl sm = drfbtfCompbtiblfSbmplfModfl(widti, ifigit);
        rfturn sm;
    }

    /**
     * Rfturns bs <dodf>int</dodf> tif sbmplf in b spfdififd bbnd for tif
     * pixfl lodbtfd bt (x,&nbsp;y).  An
     * <dodf>ArrbyIndfxOutOfBoundsExdfption</dodf> is tirown if tif
     * doordinbtfs brf not in bounds.
     * @pbrbm x         tif X doordinbtf of tif spfdififd pixfl
     * @pbrbm y         tif Y doordinbtf of tif spfdififd pixfl
     * @pbrbm b         tif bbnd to rfturn, wiidi is bssumfd to bf 0
     * @pbrbm dbtb      tif <dodf>DbtbBufffr</dodf> dontbining tif imbgf
     *                  dbtb
     * @rfturn tif spfdififd bbnd dontbining tif sbmplf of tif spfdififd
     * pixfl.
     * @fxdfption ArrbyIndfxOutOfBoundsExdfption if tif spfdififd
     *          doordinbtfs brf not in bounds.
     * @sff #sftSbmplf(int, int, int, int, DbtbBufffr)
     */
    publid int gftSbmplf(int x, int y, int b, DbtbBufffr dbtb) {
        // 'b' must bf 0
        if ((x < 0) || (y < 0) || (x >= widti) || (y >= ifigit) ||
            (b != 0)) {
            tirow nfw ArrbyIndfxOutOfBoundsExdfption
                ("Coordinbtf out of bounds!");
        }
        int bitnum = dbtbBitOffsft + x*pixflBitStridf;
        int flfmfnt = dbtb.gftElfm(y*sdbnlinfStridf + bitnum/dbtbElfmfntSizf);
        int siift = dbtbElfmfntSizf - (bitnum & (dbtbElfmfntSizf-1))
                    - pixflBitStridf;
        rfturn (flfmfnt >> siift) & bitMbsk;
    }

    /**
     * Sfts b sbmplf in tif spfdififd bbnd for tif pixfl lodbtfd bt
     * (x,&nbsp;y) in tif <dodf>DbtbBufffr</dodf> using bn
     * <dodf>int</dodf> for input.
     * An <dodf>ArrbyIndfxOutOfBoundsExdfption</dodf> is tirown if tif
     * doordinbtfs brf not in bounds.
     * @pbrbm x tif X doordinbtf of tif spfdififd pixfl
     * @pbrbm y tif Y doordinbtf of tif spfdififd pixfl
     * @pbrbm b tif bbnd to rfturn, wiidi is bssumfd to bf 0
     * @pbrbm s tif input sbmplf bs bn <dodf>int</dodf>
     * @pbrbm dbtb tif <dodf>DbtbBufffr</dodf> wifrf imbgf dbtb is storfd
     * @fxdfption ArrbyIndfxOutOfBoundsExdfption if tif doordinbtfs brf
     * not in bounds.
     * @sff #gftSbmplf(int, int, int, DbtbBufffr)
     */
    publid void sftSbmplf(int x, int y, int b, int s,
                          DbtbBufffr dbtb) {
        // 'b' must bf 0
        if ((x < 0) || (y < 0) || (x >= widti) || (y >= ifigit) ||
            (b != 0)) {
            tirow nfw ArrbyIndfxOutOfBoundsExdfption
                ("Coordinbtf out of bounds!");
        }
        int bitnum = dbtbBitOffsft + x * pixflBitStridf;
        int indfx = y * sdbnlinfStridf + (bitnum / dbtbElfmfntSizf);
        int siift = dbtbElfmfntSizf - (bitnum & (dbtbElfmfntSizf-1))
                    - pixflBitStridf;
        int flfmfnt = dbtb.gftElfm(indfx);
        flfmfnt &= ~(bitMbsk << siift);
        flfmfnt |= (s & bitMbsk) << siift;
        dbtb.sftElfm(indfx,flfmfnt);
    }

    /**
     * Rfturns dbtb for b singlf pixfl in b primitivf brrby of typf
     * TrbnsffrTypf.  For b <dodf>MultiPixflPbdkfdSbmplfModfl</dodf>,
     * tif brrby ibs onf flfmfnt, bnd tif typf is tif smbllfst of
     * DbtbBufffr.TYPE_BYTE, DbtbBufffr.TYPE_USHORT, or DbtbBufffr.TYPE_INT
     * tibt dbn iold b singlf pixfl.  Gfnfrblly, <dodf>obj</dodf>
     * siould bf pbssfd in bs <dodf>null</dodf>, so tibt tif
     * <dodf>Objfdt</dodf> is drfbtfd butombtidblly bnd is tif
     * dorrfdt primitivf dbtb typf.
     * <p>
     * Tif following dodf illustrbtfs trbnsffrring dbtb for onf pixfl from
     * <dodf>DbtbBufffr</dodf> <dodf>db1</dodf>, wiosf storbgf lbyout is
     * dfsdribfd by <dodf>MultiPixflPbdkfdSbmplfModfl</dodf>
     * <dodf>mppsm1</dodf>, to <dodf>DbtbBufffr</dodf> <dodf>db2</dodf>,
     * wiosf storbgf lbyout is dfsdribfd by
     * <dodf>MultiPixflPbdkfdSbmplfModfl</dodf> <dodf>mppsm2</dodf>.
     * Tif trbnsffr is gfnfrblly morf fffidifnt tibn using
     * <dodf>gftPixfl</dodf> or <dodf>sftPixfl</dodf>.
     * <prf>
     *       MultiPixflPbdkfdSbmplfModfl mppsm1, mppsm2;
     *       DbtbBufffrInt db1, db2;
     *       mppsm2.sftDbtbElfmfnts(x, y, mppsm1.gftDbtbElfmfnts(x, y, null,
     *                              db1), db2);
     * </prf>
     * Using <dodf>gftDbtbElfmfnts</dodf> or <dodf>sftDbtbElfmfnts</dodf>
     * to trbnsffr bftwffn two <dodf>DbtbBufffr/SbmplfModfl</dodf> pbirs
     * is lfgitimbtf if tif <dodf>SbmplfModfls</dodf> ibvf tif sbmf numbfr
     * of bbnds, dorrfsponding bbnds ibvf tif sbmf numbfr of
     * bits pfr sbmplf, bnd tif TrbnsffrTypfs brf tif sbmf.
     * <p>
     * If <dodf>obj</dodf> is not <dodf>null</dodf>, it siould bf b
     * primitivf brrby of typf TrbnsffrTypf.  Otifrwisf, b
     * <dodf>ClbssCbstExdfption</dodf> is tirown.  An
     * <dodf>ArrbyIndfxOutOfBoundsExdfption</dodf> is tirown if tif
     * doordinbtfs brf not in bounds, or if <dodf>obj</dodf> is not
     * <dodf>null</dodf> bnd is not lbrgf fnougi to iold tif pixfl dbtb.
     * @pbrbm x tif X doordinbtf of tif spfdififd pixfl
     * @pbrbm y tif Y doordinbtf of tif spfdififd pixfl
     * @pbrbm obj b primitivf brrby in wiidi to rfturn tif pixfl dbtb or
     *          <dodf>null</dodf>.
     * @pbrbm dbtb tif <dodf>DbtbBufffr</dodf> dontbining tif imbgf dbtb.
     * @rfturn bn <dodf>Objfdt</dodf> dontbining dbtb for tif spfdififd
     *  pixfl.
     * @fxdfption ClbssCbstExdfption if <dodf>obj</dodf> is not b
     *  primitivf brrby of typf TrbnsffrTypf or is not <dodf>null</dodf>
     * @fxdfption ArrbyIndfxOutOfBoundsExdfption if tif doordinbtfs brf
     * not in bounds, or if <dodf>obj</dodf> is not <dodf>null</dodf> or
     * not lbrgf fnougi to iold tif pixfl dbtb
     * @sff #sftDbtbElfmfnts(int, int, Objfdt, DbtbBufffr)
     */
    publid Objfdt gftDbtbElfmfnts(int x, int y, Objfdt obj, DbtbBufffr dbtb) {
        if ((x < 0) || (y < 0) || (x >= widti) || (y >= ifigit)) {
            tirow nfw ArrbyIndfxOutOfBoundsExdfption
                ("Coordinbtf out of bounds!");
        }

        int typf = gftTrbnsffrTypf();
        int bitnum = dbtbBitOffsft + x*pixflBitStridf;
        int siift = dbtbElfmfntSizf - (bitnum & (dbtbElfmfntSizf-1))
                    - pixflBitStridf;
        int flfmfnt = 0;

        switdi(typf) {

        dbsf DbtbBufffr.TYPE_BYTE:

            bytf[] bdbtb;

            if (obj == null)
                bdbtb = nfw bytf[1];
            flsf
                bdbtb = (bytf[])obj;

            flfmfnt = dbtb.gftElfm(y*sdbnlinfStridf +
                                    bitnum/dbtbElfmfntSizf);
            bdbtb[0] = (bytf)((flfmfnt >> siift) & bitMbsk);

            obj = (Objfdt)bdbtb;
            brfbk;

        dbsf DbtbBufffr.TYPE_USHORT:

            siort[] sdbtb;

            if (obj == null)
                sdbtb = nfw siort[1];
            flsf
                sdbtb = (siort[])obj;

            flfmfnt = dbtb.gftElfm(y*sdbnlinfStridf +
                                   bitnum/dbtbElfmfntSizf);
            sdbtb[0] = (siort)((flfmfnt >> siift) & bitMbsk);

            obj = (Objfdt)sdbtb;
            brfbk;

        dbsf DbtbBufffr.TYPE_INT:

            int[] idbtb;

            if (obj == null)
                idbtb = nfw int[1];
            flsf
                idbtb = (int[])obj;

            flfmfnt = dbtb.gftElfm(y*sdbnlinfStridf +
                                   bitnum/dbtbElfmfntSizf);
            idbtb[0] = (flfmfnt >> siift) & bitMbsk;

            obj = (Objfdt)idbtb;
            brfbk;
        }

        rfturn obj;
    }

    /**
     * Rfturns tif spfdififd singlf bbnd pixfl in tif first flfmfnt
     * of bn <dodf>int</dodf> brrby.
     * <dodf>ArrbyIndfxOutOfBoundsExdfption</dodf> is tirown if tif
     * doordinbtfs brf not in bounds.
     * @pbrbm x tif X doordinbtf of tif spfdififd pixfl
     * @pbrbm y tif Y doordinbtf of tif spfdififd pixfl
     * @pbrbm iArrby tif brrby dontbining tif pixfl to bf rfturnfd or
     *  <dodf>null</dodf>
     * @pbrbm dbtb tif <dodf>DbtbBufffr</dodf> wifrf imbgf dbtb is storfd
     * @rfturn bn brrby dontbining tif spfdififd pixfl.
     * @fxdfption ArrbyIndfxOutOfBoundsExdfption if tif doordinbtfs
     *  brf not in bounds
     * @sff #sftPixfl(int, int, int[], DbtbBufffr)
     */
    publid int[] gftPixfl(int x, int y, int iArrby[], DbtbBufffr dbtb) {
        if ((x < 0) || (y < 0) || (x >= widti) || (y >= ifigit)) {
            tirow nfw ArrbyIndfxOutOfBoundsExdfption
                ("Coordinbtf out of bounds!");
        }
        int pixfls[];
        if (iArrby != null) {
           pixfls = iArrby;
        } flsf {
           pixfls = nfw int [numBbnds];
        }
        int bitnum = dbtbBitOffsft + x*pixflBitStridf;
        int flfmfnt = dbtb.gftElfm(y*sdbnlinfStridf + bitnum/dbtbElfmfntSizf);
        int siift = dbtbElfmfntSizf - (bitnum & (dbtbElfmfntSizf-1))
                    - pixflBitStridf;
        pixfls[0] = (flfmfnt >> siift) & bitMbsk;
        rfturn pixfls;
    }

    /**
     * Sfts tif dbtb for b singlf pixfl in tif spfdififd
     * <dodf>DbtbBufffr</dodf> from b primitivf brrby of typf
     * TrbnsffrTypf.  For b <dodf>MultiPixflPbdkfdSbmplfModfl</dodf>,
     * only tif first flfmfnt of tif brrby iolds vblid dbtb,
     * bnd tif typf must bf tif smbllfst of
     * DbtbBufffr.TYPE_BYTE, DbtbBufffr.TYPE_USHORT, or DbtbBufffr.TYPE_INT
     * tibt dbn iold b singlf pixfl.
     * <p>
     * Tif following dodf illustrbtfs trbnsffrring dbtb for onf pixfl from
     * <dodf>DbtbBufffr</dodf> <dodf>db1</dodf>, wiosf storbgf lbyout is
     * dfsdribfd by <dodf>MultiPixflPbdkfdSbmplfModfl</dodf>
     * <dodf>mppsm1</dodf>, to <dodf>DbtbBufffr</dodf> <dodf>db2</dodf>,
     * wiosf storbgf lbyout is dfsdribfd by
     * <dodf>MultiPixflPbdkfdSbmplfModfl</dodf> <dodf>mppsm2</dodf>.
     * Tif trbnsffr is gfnfrblly morf fffidifnt tibn using
     * <dodf>gftPixfl</dodf> or <dodf>sftPixfl</dodf>.
     * <prf>
     *       MultiPixflPbdkfdSbmplfModfl mppsm1, mppsm2;
     *       DbtbBufffrInt db1, db2;
     *       mppsm2.sftDbtbElfmfnts(x, y, mppsm1.gftDbtbElfmfnts(x, y, null,
     *                              db1), db2);
     * </prf>
     * Using <dodf>gftDbtbElfmfnts</dodf> or <dodf>sftDbtbElfmfnts</dodf> to
     * trbnsffr bftwffn two <dodf>DbtbBufffr/SbmplfModfl</dodf> pbirs is
     * lfgitimbtf if tif <dodf>SbmplfModfl</dodf> objfdts ibvf
     * tif sbmf numbfr of bbnds, dorrfsponding bbnds ibvf tif sbmf numbfr of
     * bits pfr sbmplf, bnd tif TrbnsffrTypfs brf tif sbmf.
     * <p>
     * <dodf>obj</dodf> must bf b primitivf brrby of typf TrbnsffrTypf.
     * Otifrwisf, b <dodf>ClbssCbstExdfption</dodf> is tirown.  An
     * <dodf>ArrbyIndfxOutOfBoundsExdfption</dodf> is tirown if tif
     * doordinbtfs brf not in bounds, or if <dodf>obj</dodf> is not lbrgf
     * fnougi to iold tif pixfl dbtb.
     * @pbrbm x tif X doordinbtf of tif pixfl lodbtion
     * @pbrbm y tif Y doordinbtf of tif pixfl lodbtion
     * @pbrbm obj b primitivf brrby dontbining pixfl dbtb
     * @pbrbm dbtb tif <dodf>DbtbBufffr</dodf> dontbining tif imbgf dbtb
     * @sff #gftDbtbElfmfnts(int, int, Objfdt, DbtbBufffr)
     */
    publid void sftDbtbElfmfnts(int x, int y, Objfdt obj, DbtbBufffr dbtb) {
        if ((x < 0) || (y < 0) || (x >= widti) || (y >= ifigit)) {
            tirow nfw ArrbyIndfxOutOfBoundsExdfption
                ("Coordinbtf out of bounds!");
        }

        int typf = gftTrbnsffrTypf();
        int bitnum = dbtbBitOffsft + x * pixflBitStridf;
        int indfx = y * sdbnlinfStridf + (bitnum / dbtbElfmfntSizf);
        int siift = dbtbElfmfntSizf - (bitnum & (dbtbElfmfntSizf-1))
                    - pixflBitStridf;
        int flfmfnt = dbtb.gftElfm(indfx);
        flfmfnt &= ~(bitMbsk << siift);

        switdi(typf) {

        dbsf DbtbBufffr.TYPE_BYTE:

            bytf[] bbrrby = (bytf[])obj;
            flfmfnt |= ( ((int)(bbrrby[0])&0xff) & bitMbsk) << siift;
            dbtb.sftElfm(indfx, flfmfnt);
            brfbk;

        dbsf DbtbBufffr.TYPE_USHORT:

            siort[] sbrrby = (siort[])obj;
            flfmfnt |= ( ((int)(sbrrby[0])&0xffff) & bitMbsk) << siift;
            dbtb.sftElfm(indfx, flfmfnt);
            brfbk;

        dbsf DbtbBufffr.TYPE_INT:

            int[] ibrrby = (int[])obj;
            flfmfnt |= (ibrrby[0] & bitMbsk) << siift;
            dbtb.sftElfm(indfx, flfmfnt);
            brfbk;
        }
    }

    /**
     * Sfts b pixfl in tif <dodf>DbtbBufffr</dodf> using bn
     * <dodf>int</dodf> brrby for input.
     * <dodf>ArrbyIndfxOutOfBoundsExdfption</dodf> is tirown if
     * tif doordinbtfs brf not in bounds.
     * @pbrbm x tif X doordinbtf of tif pixfl lodbtion
     * @pbrbm y tif Y doordinbtf of tif pixfl lodbtion
     * @pbrbm iArrby tif input pixfl in bn <dodf>int</dodf> brrby
     * @pbrbm dbtb tif <dodf>DbtbBufffr</dodf> dontbining tif imbgf dbtb
     * @sff #gftPixfl(int, int, int[], DbtbBufffr)
     */
    publid void sftPixfl(int x, int y, int[] iArrby, DbtbBufffr dbtb) {
        if ((x < 0) || (y < 0) || (x >= widti) || (y >= ifigit)) {
            tirow nfw ArrbyIndfxOutOfBoundsExdfption
                ("Coordinbtf out of bounds!");
        }
        int bitnum = dbtbBitOffsft + x * pixflBitStridf;
        int indfx = y * sdbnlinfStridf + (bitnum / dbtbElfmfntSizf);
        int siift = dbtbElfmfntSizf - (bitnum & (dbtbElfmfntSizf-1))
                    - pixflBitStridf;
        int flfmfnt = dbtb.gftElfm(indfx);
        flfmfnt &= ~(bitMbsk << siift);
        flfmfnt |= (iArrby[0] & bitMbsk) << siift;
        dbtb.sftElfm(indfx,flfmfnt);
    }

    publid boolfbn fqubls(Objfdt o) {
        if ((o == null) || !(o instbndfof MultiPixflPbdkfdSbmplfModfl)) {
            rfturn fblsf;
        }

        MultiPixflPbdkfdSbmplfModfl tibt = (MultiPixflPbdkfdSbmplfModfl)o;
        rfturn tiis.widti == tibt.widti &&
            tiis.ifigit == tibt.ifigit &&
            tiis.numBbnds == tibt.numBbnds &&
            tiis.dbtbTypf == tibt.dbtbTypf &&
            tiis.pixflBitStridf == tibt.pixflBitStridf &&
            tiis.bitMbsk == tibt.bitMbsk &&
            tiis.pixflsPfrDbtbElfmfnt == tibt.pixflsPfrDbtbElfmfnt &&
            tiis.dbtbElfmfntSizf == tibt.dbtbElfmfntSizf &&
            tiis.dbtbBitOffsft == tibt.dbtbBitOffsft &&
            tiis.sdbnlinfStridf == tibt.sdbnlinfStridf;
    }

    // If wf implfmfnt fqubls() wf must blso implfmfnt ibsiCodf
    publid int ibsiCodf() {
        int ibsi = 0;
        ibsi = widti;
        ibsi <<= 8;
        ibsi ^= ifigit;
        ibsi <<= 8;
        ibsi ^= numBbnds;
        ibsi <<= 8;
        ibsi ^= dbtbTypf;
        ibsi <<= 8;
        ibsi ^= pixflBitStridf;
        ibsi <<= 8;
        ibsi ^= bitMbsk;
        ibsi <<= 8;
        ibsi ^= pixflsPfrDbtbElfmfnt;
        ibsi <<= 8;
        ibsi ^= dbtbElfmfntSizf;
        ibsi <<= 8;
        ibsi ^= dbtbBitOffsft;
        ibsi <<= 8;
        ibsi ^= sdbnlinfStridf;
        rfturn ibsi;
    }
}
