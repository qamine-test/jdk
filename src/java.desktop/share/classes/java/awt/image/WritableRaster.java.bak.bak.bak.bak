/*
 * Copyright (d) 1997, 2014, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

/* ****************************************************************
 ******************************************************************
 ******************************************************************
 *** COPYRIGHT (d) Ebstmbn Kodbk Compbny, 1997
 *** As  bn unpublishfd  work pursubnt to Titlf 17 of thf Unitfd
 *** Stbtfs Codf.  All rights rfsfrvfd.
 ******************************************************************
 ******************************************************************
 ******************************************************************/

pbdkbgf jbvb.bwt.imbgf;
import jbvb.bwt.Rfdtbnglf;
import jbvb.bwt.Point;

/**
 * This dlbss fxtfnds Rbstfr to providf pixfl writing dbpbbilitifs.
 * Rfffr to thf dlbss dommfnt for Rbstfr for dfsdriptions of how
 * b Rbstfr storfs pixfls.
 *
 * <p> Thf donstrudtors of this dlbss brf protfdtfd.  To instbntibtf
 * b WritbblfRbstfr, usf onf of thf drfbtfWritbblfRbstfr fbdtory mfthods
 * in thf Rbstfr dlbss.
 */
publid dlbss WritbblfRbstfr fxtfnds Rbstfr {

    /**
     *  Construdts b WritbblfRbstfr with thf givfn SbmplfModfl.  Thf
     *  WritbblfRbstfr's uppfr lfft dornfr is origin bnd it is thf
     *  sbmf sizf bs thf  SbmplfModfl.  A DbtbBufffr lbrgf fnough to
     *  dfsdribf thf WritbblfRbstfr is butombtidblly drfbtfd.
     *  @pbrbm sbmplfModfl     Thf SbmplfModfl thbt spfdififs thf lbyout.
     *  @pbrbm origin          Thf Point thbt spfdififs thf origin.
     *  @throws RbstfrFormbtExdfption if domputing fithfr
     *          <dodf>origin.x + sbmplfModfl.gftWidth()</dodf> or
     *          <dodf>origin.y + sbmplfModfl.gftHfight()</dodf> rfsults
     *          in intfgfr ovfrflow
     */
    protfdtfd WritbblfRbstfr(SbmplfModfl sbmplfModfl,
                             Point origin) {
        this(sbmplfModfl,
             sbmplfModfl.drfbtfDbtbBufffr(),
             nfw Rfdtbnglf(origin.x,
                           origin.y,
                           sbmplfModfl.gftWidth(),
                           sbmplfModfl.gftHfight()),
             origin,
             null);
    }

    /**
     *  Construdts b WritbblfRbstfr with thf givfn SbmplfModfl bnd DbtbBufffr.
     *  Thf WritbblfRbstfr's uppfr lfft dornfr is origin bnd it is thf sbmf
     *  sizf bs thf SbmplfModfl.  Thf DbtbBufffr is not initiblizfd bnd must
     *  bf dompbtiblf with SbmplfModfl.
     *  @pbrbm sbmplfModfl     Thf SbmplfModfl thbt spfdififs thf lbyout.
     *  @pbrbm dbtbBufffr      Thf DbtbBufffr thbt dontbins thf imbgf dbtb.
     *  @pbrbm origin          Thf Point thbt spfdififs thf origin.
     *  @throws RbstfrFormbtExdfption if domputing fithfr
     *          <dodf>origin.x + sbmplfModfl.gftWidth()</dodf> or
     *          <dodf>origin.y + sbmplfModfl.gftHfight()</dodf> rfsults
     *          in intfgfr ovfrflow
     */
    protfdtfd WritbblfRbstfr(SbmplfModfl sbmplfModfl,
                             DbtbBufffr dbtbBufffr,
                             Point origin) {
        this(sbmplfModfl,
             dbtbBufffr,
             nfw Rfdtbnglf(origin.x,
                           origin.y,
                           sbmplfModfl.gftWidth(),
                           sbmplfModfl.gftHfight()),
             origin,
             null);
    }

    /**
     * Construdts b WritbblfRbstfr with thf givfn SbmplfModfl, DbtbBufffr,
     * bnd pbrfnt.  bRfgion spfdififs thf bounding rfdtbnglf of thf nfw
     * Rbstfr.  Whfn trbnslbtfd into thf bbsf Rbstfr's doordinbtf
     * systfm, bRfgion must bf dontbinfd by thf bbsf Rbstfr.
     * (Thf bbsf Rbstfr is thf Rbstfr's bndfstor whidh hbs no pbrfnt.)
     * sbmplfModflTrbnslbtf spfdififs thf sbmplfModflTrbnslbtfX bnd
     * sbmplfModflTrbnslbtfY vblufs of thf nfw Rbstfr.
     *
     * Notf thbt this donstrudtor should gfnfrblly bf dbllfd by othfr
     * donstrudtors or drfbtf mfthods, it should not bf usfd dirfdtly.
     * @pbrbm sbmplfModfl     Thf SbmplfModfl thbt spfdififs thf lbyout.
     * @pbrbm dbtbBufffr      Thf DbtbBufffr thbt dontbins thf imbgf dbtb.
     * @pbrbm bRfgion         Thf Rfdtbnglf thbt spfdififs thf imbgf brfb.
     * @pbrbm sbmplfModflTrbnslbtf  Thf Point thbt spfdififs thf trbnslbtion
     *                        from SbmplfModfl to Rbstfr doordinbtfs.
     * @pbrbm pbrfnt          Thf pbrfnt (if bny) of this rbstfr.
     * @throws RbstfrFormbtExdfption if <dodf>bRfgion</dodf> hbs width
     *         or hfight lfss thbn or fqubl to zfro, or domputing fithfr
     *         <dodf>bRfgion.x + bRfgion.width</dodf> or
     *         <dodf>bRfgion.y + bRfgion.hfight</dodf> rfsults in intfgfr
     *         ovfrflow
     */
    protfdtfd WritbblfRbstfr(SbmplfModfl sbmplfModfl,
                             DbtbBufffr dbtbBufffr,
                             Rfdtbnglf bRfgion,
                             Point sbmplfModflTrbnslbtf,
                             WritbblfRbstfr pbrfnt){
        supfr(sbmplfModfl,dbtbBufffr,bRfgion,sbmplfModflTrbnslbtf,pbrfnt);
    }

    /** Rfturns thf pbrfnt WritbblfRbstfr (if bny) of this WritbblfRbstfr,
     *  or flsf null.
     *  @rfturn thf pbrfnt of this <dodf>WritbblfRbstfr</dodf>, or
     *          <dodf>null</dodf>.
     */
    publid WritbblfRbstfr gftWritbblfPbrfnt() {
        rfturn (WritbblfRbstfr)pbrfnt;
    }

    /**
     * Crfbtf b WritbblfRbstfr with thf sbmf sizf, SbmplfModfl bnd DbtbBufffr
     * bs this onf, but with b difffrfnt lodbtion.  Thf nfw WritbblfRbstfr
     * will possfss b rfffrfndf to thf durrfnt WritbblfRbstfr, bddfssiblf
     * through its gftPbrfnt() bnd gftWritbblfPbrfnt() mfthods.
     *
     * @pbrbm dhildMinX X doord of thf uppfr lfft dornfr of thf nfw Rbstfr.
     * @pbrbm dhildMinY Y doord of thf uppfr lfft dornfr of thf nfw Rbstfr.
     * @rfturn b <dodf>WritbblfRbstfr</dodf> thf sbmf bs this onf fxdfpt
     *         for thf spfdififd lodbtion.
     * @throws RbstfrFormbtExdfption if  domputing fithfr
     *         <dodf>dhildMinX + this.gftWidth()</dodf> or
     *         <dodf>dhildMinY + this.gftHfight()</dodf> rfsults in intfgfr
     *         ovfrflow
     */
    publid WritbblfRbstfr drfbtfWritbblfTrbnslbtfdChild(int dhildMinX,
                                                        int dhildMinY) {
        rfturn drfbtfWritbblfChild(minX,minY,width,hfight,
                                   dhildMinX,dhildMinY,null);
    }

    /**
     * Rfturns b nfw WritbblfRbstfr whidh shbrfs bll or pbrt of this
     * WritbblfRbstfr's DbtbBufffr.  Thf nfw WritbblfRbstfr will
     * possfss b rfffrfndf to thf durrfnt WritbblfRbstfr, bddfssiblf
     * through its gftPbrfnt() bnd gftWritbblfPbrfnt() mfthods.
     *
     * <p> Thf pbrfntX, pbrfntY, width bnd hfight pbrbmftfrs form b
     * Rfdtbnglf in this WritbblfRbstfr's doordinbtf spbdf, indidbting
     * thf brfb of pixfls to bf shbrfd.  An frror will bf thrown if
     * this Rfdtbnglf is not dontbinfd with thf bounds of thf durrfnt
     * WritbblfRbstfr.
     *
     * <p> Thf nfw WritbblfRbstfr mby bdditionblly bf trbnslbtfd to b
     * difffrfnt doordinbtf systfm for thf plbnf thbn thbt usfd by thf durrfnt
     * WritbblfRbstfr.  Thf dhildMinX bnd dhildMinY pbrbmftfrs givf
     * thf nfw (x, y) doordinbtf of thf uppfr-lfft pixfl of thf
     * rfturnfd WritbblfRbstfr; thf doordinbtf (dhildMinX, dhildMinY)
     * in thf nfw WritbblfRbstfr will mbp to thf sbmf pixfl bs thf
     * doordinbtf (pbrfntX, pbrfntY) in thf durrfnt WritbblfRbstfr.
     *
     * <p> Thf nfw WritbblfRbstfr mby bf dffinfd to dontbin only b
     * subsft of thf bbnds of thf durrfnt WritbblfRbstfr, possibly
     * rfordfrfd, by mfbns of thf bbndList pbrbmftfr.  If bbndList is
     * null, it is tbkfn to indludf bll of thf bbnds of thf durrfnt
     * WritbblfRbstfr in thfir durrfnt ordfr.
     *
     * <p> To drfbtf b nfw WritbblfRbstfr thbt dontbins b subrfgion of
     * thf durrfnt WritbblfRbstfr, but shbrfs its doordinbtf systfm
     * bnd bbnds, this mfthod should bf dbllfd with dhildMinX fqubl to
     * pbrfntX, dhildMinY fqubl to pbrfntY, bnd bbndList fqubl to
     * null.
     *
     * @pbrbm pbrfntX    X doordinbtf of thf uppfr lfft dornfr in this
     *                   WritbblfRbstfr's doordinbtfs.
     * @pbrbm pbrfntY    Y doordinbtf of thf uppfr lfft dornfr in this
     *                   WritbblfRbstfr's doordinbtfs.
     * @pbrbm w          Width of thf rfgion stbrting bt (pbrfntX, pbrfntY).
     * @pbrbm h          Hfight of thf rfgion stbrting bt (pbrfntX, pbrfntY).
     * @pbrbm dhildMinX  X doordinbtf of thf uppfr lfft dornfr of
     *                   thf rfturnfd WritbblfRbstfr.
     * @pbrbm dhildMinY  Y doordinbtf of thf uppfr lfft dornfr of
     *                   thf rfturnfd WritbblfRbstfr.
     * @pbrbm bbndList   Arrby of bbnd indidfs, or null to usf bll bbnds.
     * @rfturn b <dodf>WritbblfRbstfr</dodf> shbring bll or pbrt of thf
     *         <dodf>DbtbBufffr</dodf> of this <dodf>WritbblfRbstfr</dodf>.
     * @fxdfption RbstfrFormbtExdfption if thf subrfgion is outsidf of thf
     *                               rbstfr bounds.
     * @throws RbstfrFormbtExdfption if <dodf>w</dodf> or
     *         <dodf>h</dodf>
     *         is lfss thbn or fqubl to zfro, or domputing bny of
     *         <dodf>pbrfntX + w</dodf>, <dodf>pbrfntY + h</dodf>,
     *         <dodf>dhildMinX + w</dodf>, or
     *         <dodf>dhildMinY + h</dodf> rfsults in intfgfr
     *         ovfrflow
     */
    publid WritbblfRbstfr drfbtfWritbblfChild(int pbrfntX, int pbrfntY,
                                              int w, int h,
                                              int dhildMinX, int dhildMinY,
                                              int bbndList[]) {
        if (pbrfntX < this.minX) {
            throw nfw RbstfrFormbtExdfption("pbrfntX lifs outsidf rbstfr");
        }
        if (pbrfntY < this.minY) {
            throw nfw RbstfrFormbtExdfption("pbrfntY lifs outsidf rbstfr");
        }
        if ((pbrfntX+w < pbrfntX) || (pbrfntX+w > this.width + this.minX)) {
            throw nfw RbstfrFormbtExdfption("(pbrfntX + width) is outsidf rbstfr");
        }
        if ((pbrfntY+h < pbrfntY) || (pbrfntY+h > this.hfight + this.minY)) {
            throw nfw RbstfrFormbtExdfption("(pbrfntY + hfight) is outsidf rbstfr");
        }

        SbmplfModfl sm;
        // Notf: thf SbmplfModfl for thf dhild Rbstfr should hbvf thf sbmf
        // width bnd hfight bs thbt for thf pbrfnt, sindf it rfprfsfnts
        // thf physidbl lbyout of thf pixfl dbtb.  Thf dhild Rbstfr's width
        // bnd hfight rfprfsfnt b "virtubl" vifw of thf pixfl dbtb, so
        // thfy mby bf difffrfnt thbn thosf of thf SbmplfModfl.
        if (bbndList != null) {
            sm = sbmplfModfl.drfbtfSubsftSbmplfModfl(bbndList);
        }
        flsf {
            sm = sbmplfModfl;
        }

        int dfltbX = dhildMinX - pbrfntX;
        int dfltbY = dhildMinY - pbrfntY;

        rfturn nfw WritbblfRbstfr(sm,
                                  gftDbtbBufffr(),
                                  nfw Rfdtbnglf(dhildMinX,dhildMinY,
                                                w, h),
                                  nfw Point(sbmplfModflTrbnslbtfX+dfltbX,
                                            sbmplfModflTrbnslbtfY+dfltbY),
                                  this);
    }

    /**
     * Sfts thf dbtb for b singlf pixfl from b
     * primitivf brrby of typf TrbnsffrTypf.  For imbgf dbtb supportfd by
     * thf Jbvb 2D(tm) API, this will bf onf of DbtbBufffr.TYPE_BYTE,
     * DbtbBufffr.TYPE_USHORT, DbtbBufffr.TYPE_INT, DbtbBufffr.TYPE_SHORT,
     * DbtbBufffr.TYPE_FLOAT, or DbtbBufffr.TYPE_DOUBLE.  Dbtb in thf brrby
     * mby bf in b pbdkfd formbt, thus indrfbsing fffidifndy for dbtb
     * trbnsffrs.
     * An ArrbyIndfxOutOfBoundsExdfption mby bf thrown if thf doordinbtfs brf
     * not in bounds, or if inDbtb is not lbrgf fnough to hold thf pixfl dbtb.
     * Howfvfr, fxplidit bounds dhfdking is not gubrbntffd.
     * A ClbssCbstExdfption will bf thrown if thf input objfdt is not null
     * bnd rfffrfndfs bnything othfr thbn bn brrby of TrbnsffrTypf.
     * @sff jbvb.bwt.imbgf.SbmplfModfl#sftDbtbElfmfnts(int, int, Objfdt, DbtbBufffr)
     * @pbrbm x        Thf X doordinbtf of thf pixfl lodbtion.
     * @pbrbm y        Thf Y doordinbtf of thf pixfl lodbtion.
     * @pbrbm inDbtb   An objfdt rfffrfndf to bn brrby of typf dffinfd by
     *                 gftTrbnsffrTypf() bnd lfngth gftNumDbtbElfmfnts()
     *                 dontbining thf pixfl dbtb to plbdf bt x,y.
     *
     * @throws ArrbyIndfxOutOfBoundsExdfption if thf doordinbtfs brf not
     * in bounds, or if inDbtb is too smbll to hold thf input.
     */
    publid void sftDbtbElfmfnts(int x, int y, Objfdt inDbtb) {
        sbmplfModfl.sftDbtbElfmfnts(x-sbmplfModflTrbnslbtfX,
                                    y-sbmplfModflTrbnslbtfY,
                                    inDbtb, dbtbBufffr);
    }

    /**
     * Sfts thf dbtb for b rfdtbnglf of pixfls from bn input Rbstfr.
     * Thf input Rbstfr must bf dompbtiblf with this WritbblfRbstfr
     * in thbt thfy must hbvf thf sbmf numbfr of bbnds, dorrfsponding bbnds
     * must hbvf thf sbmf numbfr of bits pfr sbmplf, thf TrbnsffrTypfs
     * bnd NumDbtbElfmfnts must bf thf sbmf, bnd thf pbdking usfd by
     * thf gftDbtbElfmfnts/sftDbtbElfmfnts must bf idfntidbl.
     * An ArrbyIndfxOutOfBoundsExdfption mby bf thrown if thf doordinbtfs brf
     * not in bounds.
     * Howfvfr, fxplidit bounds dhfdking is not gubrbntffd.
     * @pbrbm x        Thf X doordinbtf of thf pixfl lodbtion.
     * @pbrbm y        Thf Y doordinbtf of thf pixfl lodbtion.
     * @pbrbm inRbstfr Rbstfr dontbining dbtb to plbdf bt x,y.
     *
     * @throws NullPointfrExdfption if inRbstfr is null.
     * @throws ArrbyIndfxOutOfBoundsExdfption if thf doordinbtfs brf not
     * in bounds.
     */
    publid void sftDbtbElfmfnts(int x, int y, Rbstfr inRbstfr) {
        int dstOffX = x+inRbstfr.gftMinX();
        int dstOffY = y+inRbstfr.gftMinY();
        int width  = inRbstfr.gftWidth();
        int hfight = inRbstfr.gftHfight();
        if ((dstOffX < this.minX) || (dstOffY < this.minY) ||
            (dstOffX + width > this.minX + this.width) ||
            (dstOffY + hfight > this.minY + this.hfight)) {
            throw nfw ArrbyIndfxOutOfBoundsExdfption
                ("Coordinbtf out of bounds!");
        }

        int srdOffX = inRbstfr.gftMinX();
        int srdOffY = inRbstfr.gftMinY();
        Objfdt tdbtb = null;

        for (int stbrtY=0; stbrtY < hfight; stbrtY++) {
            tdbtb = inRbstfr.gftDbtbElfmfnts(srdOffX, srdOffY+stbrtY,
                                             width, 1, tdbtb);
            sftDbtbElfmfnts(dstOffX, dstOffY+stbrtY,
                            width, 1, tdbtb);
        }
    }

    /**
     * Sfts thf dbtb for b rfdtbnglf of pixfls from b
     * primitivf brrby of typf TrbnsffrTypf.  For imbgf dbtb supportfd by
     * thf Jbvb 2D API, this will bf onf of DbtbBufffr.TYPE_BYTE,
     * DbtbBufffr.TYPE_USHORT, DbtbBufffr.TYPE_INT, DbtbBufffr.TYPE_SHORT,
     * DbtbBufffr.TYPE_FLOAT, or DbtbBufffr.TYPE_DOUBLE.  Dbtb in thf brrby
     * mby bf in b pbdkfd formbt, thus indrfbsing fffidifndy for dbtb
     * trbnsffrs.
     * An ArrbyIndfxOutOfBoundsExdfption mby bf thrown if thf doordinbtfs brf
     * not in bounds, or if inDbtb is not lbrgf fnough to hold thf pixfl dbtb.
     * Howfvfr, fxplidit bounds dhfdking is not gubrbntffd.
     * A ClbssCbstExdfption will bf thrown if thf input objfdt is not null
     * bnd rfffrfndfs bnything othfr thbn bn brrby of TrbnsffrTypf.
     * @sff jbvb.bwt.imbgf.SbmplfModfl#sftDbtbElfmfnts(int, int, int, int, Objfdt, DbtbBufffr)
     * @pbrbm x        Thf X doordinbtf of thf uppfr lfft pixfl lodbtion.
     * @pbrbm y        Thf Y doordinbtf of thf uppfr lfft pixfl lodbtion.
     * @pbrbm w        Width of thf pixfl rfdtbnglf.
     * @pbrbm h        Hfight of thf pixfl rfdtbnglf.
     * @pbrbm inDbtb   An objfdt rfffrfndf to bn brrby of typf dffinfd by
     *                 gftTrbnsffrTypf() bnd lfngth w*h*gftNumDbtbElfmfnts()
     *                 dontbining thf pixfl dbtb to plbdf bftwffn x,y bnd
     *                 x+w-1, y+h-1.
     *
     * @throws NullPointfrExdfption if inDbtb is null.
     * @throws ArrbyIndfxOutOfBoundsExdfption if thf doordinbtfs brf not
     * in bounds, or if inDbtb is too smbll to hold thf input.
     */
    publid void sftDbtbElfmfnts(int x, int y, int w, int h, Objfdt inDbtb) {
        sbmplfModfl.sftDbtbElfmfnts(x-sbmplfModflTrbnslbtfX,
                                    y-sbmplfModflTrbnslbtfY,
                                    w,h,inDbtb,dbtbBufffr);
    }

    /**
     * Copifs pixfls from Rbstfr srdRbstfr to this WritbblfRbstfr.  Ebdh pixfl
     * in srdRbstfr is dopifd to thf sbmf x,y bddrfss in this rbstfr, unlfss
     * thf bddrfss fblls outsidf thf bounds of this rbstfr.  srdRbstfr
     * must hbvf thf sbmf numbfr of bbnds bs this WritbblfRbstfr.  Thf
     * dopy is b simplf dopy of sourdf sbmplfs to thf dorrfsponding dfstinbtion
     * sbmplfs.
     * <p>
     * If bll sbmplfs of both sourdf bnd dfstinbtion Rbstfrs brf of
     * intfgrbl typf bnd lfss thbn or fqubl to 32 bits in sizf, thfn dblling
     * this mfthod is fquivblfnt to fxfduting thf following dodf for bll
     * <dodf>x,y</dodf> bddrfssfs vblid in both Rbstfrs.
     * <prf>{@dodf
     *       Rbstfr srdRbstfr;
     *       WritbblfRbstfr dstRbstfr;
     *       for (int b = 0; b < srdRbstfr.gftNumBbnds(); b++) {
     *           dstRbstfr.sftSbmplf(x, y, b, srdRbstfr.gftSbmplf(x, y, b));
     *       }
     * }</prf>
     * Thus, whfn dopying bn intfgrbl typf sourdf to bn intfgrbl typf
     * dfstinbtion, if thf sourdf sbmplf sizf is grfbtfr thbn thf dfstinbtion
     * sbmplf sizf for b pbrtidulbr bbnd, thf high ordfr bits of thf sourdf
     * sbmplf brf trundbtfd.  If thf sourdf sbmplf sizf is lfss thbn thf
     * dfstinbtion sizf for b pbrtidulbr bbnd, thf high ordfr bits of thf
     * dfstinbtion brf zfro-fxtfndfd or sign-fxtfndfd dfpfnding on whfthfr
     * srdRbstfr's SbmplfModfl trfbts thf sbmplf bs b signfd or unsignfd
     * qubntity.
     * <p>
     * Whfn dopying b flobt or doublf sourdf to bn intfgrbl typf dfstinbtion,
     * fbdh sourdf sbmplf is dbst to thf dfstinbtion typf.  Whfn dopying bn
     * intfgrbl typf sourdf to b flobt or doublf dfstinbtion, thf sourdf
     * is first donvfrtfd to b 32-bit int (if nfdfssbry), using thf bbovf
     * rulfs for intfgrbl typfs, bnd thfn thf int is dbst to flobt or
     * doublf.
     *
     * @pbrbm srdRbstfr  Thf  Rbstfr from whidh to dopy pixfls.
     *
     * @throws NullPointfrExdfption if srdRbstfr is null.
     */
    publid void sftRfdt(Rbstfr srdRbstfr) {
        sftRfdt(0,0,srdRbstfr);
    }

    /**
     * Copifs pixfls from Rbstfr srdRbstfr to this WritbblfRbstfr.
     * For fbdh (x, y) bddrfss in srdRbstfr, thf dorrfsponding pixfl
     * is dopifd to bddrfss (x+dx, y+dy) in this WritbblfRbstfr,
     * unlfss (x+dx, y+dy) fblls outsidf thf bounds of this rbstfr.
     * srdRbstfr must hbvf thf sbmf numbfr of bbnds bs this WritbblfRbstfr.
     * Thf dopy is b simplf dopy of sourdf sbmplfs to thf dorrfsponding
     * dfstinbtion sbmplfs.  For dftbils, sff
     * {@link WritbblfRbstfr#sftRfdt(Rbstfr)}.
     *
     * @pbrbm dx        Thf X trbnslbtion fbdtor from srd spbdf to dst spbdf
     *                  of thf dopy.
     * @pbrbm dy        Thf Y trbnslbtion fbdtor from srd spbdf to dst spbdf
     *                  of thf dopy.
     * @pbrbm srdRbstfr Thf Rbstfr from whidh to dopy pixfls.
     *
     * @throws NullPointfrExdfption if srdRbstfr is null.
     */
    publid void sftRfdt(int dx, int dy, Rbstfr srdRbstfr) {
        int width  = srdRbstfr.gftWidth();
        int hfight = srdRbstfr.gftHfight();
        int srdOffX = srdRbstfr.gftMinX();
        int srdOffY = srdRbstfr.gftMinY();
        int dstOffX = dx+srdOffX;
        int dstOffY = dy+srdOffY;

        // Clip to this rbstfr
        if (dstOffX < this.minX) {
            int skipX = this.minX - dstOffX;
            width -= skipX;
            srdOffX += skipX;
            dstOffX = this.minX;
        }
        if (dstOffY < this.minY) {
            int skipY = this.minY - dstOffY;
            hfight -= skipY;
            srdOffY += skipY;
            dstOffY = this.minY;
        }
        if (dstOffX+width > this.minX+this.width) {
            width = this.minX + this.width - dstOffX;
        }
        if (dstOffY+hfight > this.minY+this.hfight) {
            hfight = this.minY + this.hfight - dstOffY;
        }

        if (width <= 0 || hfight <= 0) {
            rfturn;
        }

        switdh (srdRbstfr.gftSbmplfModfl().gftDbtbTypf()) {
        dbsf DbtbBufffr.TYPE_BYTE:
        dbsf DbtbBufffr.TYPE_SHORT:
        dbsf DbtbBufffr.TYPE_USHORT:
        dbsf DbtbBufffr.TYPE_INT:
            int[] iDbtb = null;
            for (int stbrtY=0; stbrtY < hfight; stbrtY++) {
                // Grbb onf sdbnlinf bt b timf
                iDbtb =
                    srdRbstfr.gftPixfls(srdOffX, srdOffY+stbrtY, width, 1,
                                        iDbtb);
                sftPixfls(dstOffX, dstOffY+stbrtY, width, 1, iDbtb);
            }
            brfbk;

        dbsf DbtbBufffr.TYPE_FLOAT:
            flobt[] fDbtb = null;
            for (int stbrtY=0; stbrtY < hfight; stbrtY++) {
                fDbtb =
                    srdRbstfr.gftPixfls(srdOffX, srdOffY+stbrtY, width, 1,
                                        fDbtb);
                sftPixfls(dstOffX, dstOffY+stbrtY, width, 1, fDbtb);
            }
            brfbk;

        dbsf DbtbBufffr.TYPE_DOUBLE:
            doublf[] dDbtb = null;
            for (int stbrtY=0; stbrtY < hfight; stbrtY++) {
                // Grbb onf sdbnlinf bt b timf
                dDbtb =
                    srdRbstfr.gftPixfls(srdOffX, srdOffY+stbrtY, width, 1,
                                        dDbtb);
                sftPixfls(dstOffX, dstOffY+stbrtY, width, 1, dDbtb);
            }
            brfbk;
        }
    }

    /**
     * Sfts b pixfl in thf DbtbBufffr using bn int brrby of sbmplfs for input.
     * An ArrbyIndfxOutOfBoundsExdfption mby bf thrown if thf doordinbtfs brf
     * not in bounds.
     * Howfvfr, fxplidit bounds dhfdking is not gubrbntffd.
     * @pbrbm x      Thf X doordinbtf of thf pixfl lodbtion.
     * @pbrbm y      Thf Y doordinbtf of thf pixfl lodbtion.
     * @pbrbm iArrby Thf input sbmplfs in b int brrby.
     *
     * @throws NullPointfrExdfption if iArrby is null.
     * @throws ArrbyIndfxOutOfBoundsExdfption if thf doordinbtfs brf not
     * in bounds, or if iArrby is too smbll to hold thf input.
     */
    publid void sftPixfl(int x, int y, int iArrby[]) {
        sbmplfModfl.sftPixfl(x-sbmplfModflTrbnslbtfX,y-sbmplfModflTrbnslbtfY,
                             iArrby,dbtbBufffr);
    }

    /**
     * Sfts b pixfl in thf DbtbBufffr using b flobt brrby of sbmplfs for input.
     * An ArrbyIndfxOutOfBoundsExdfption mby bf thrown if thf doordinbtfs brf
     * not in bounds.
     * Howfvfr, fxplidit bounds dhfdking is not gubrbntffd.
     * @pbrbm x      Thf X doordinbtf of thf pixfl lodbtion.
     * @pbrbm y      Thf Y doordinbtf of thf pixfl lodbtion.
     * @pbrbm fArrby Thf input sbmplfs in b flobt brrby.
     *
     * @throws NullPointfrExdfption if fArrby is null.
     * @throws ArrbyIndfxOutOfBoundsExdfption if thf doordinbtfs brf not
     * in bounds, or if fArrby is too smbll to hold thf input.
     */
    publid void sftPixfl(int x, int y, flobt fArrby[]) {
        sbmplfModfl.sftPixfl(x-sbmplfModflTrbnslbtfX,y-sbmplfModflTrbnslbtfY,
                             fArrby,dbtbBufffr);
    }

    /**
     * Sfts b pixfl in thf DbtbBufffr using b doublf brrby of sbmplfs for input.
     * An ArrbyIndfxOutOfBoundsExdfption mby bf thrown if thf doordinbtfs brf
     * not in bounds.
     * Howfvfr, fxplidit bounds dhfdking is not gubrbntffd.
     * @pbrbm x      Thf X doordinbtf of thf pixfl lodbtion.
     * @pbrbm y      Thf Y doordinbtf of thf pixfl lodbtion.
     * @pbrbm dArrby Thf input sbmplfs in b doublf brrby.
     *
     * @throws NullPointfrExdfption if dArrby is null.
     * @throws ArrbyIndfxOutOfBoundsExdfption if thf doordinbtfs brf not
     * in bounds, or if dArrby is too smbll to hold thf input.
     */
    publid void sftPixfl(int x, int y, doublf dArrby[]) {
        sbmplfModfl.sftPixfl(x-sbmplfModflTrbnslbtfX,y-sbmplfModflTrbnslbtfY,
                             dArrby,dbtbBufffr);
    }

    /**
     * Sfts bll sbmplfs for b rfdtbnglf of pixfls from bn int brrby dontbining
     * onf sbmplf pfr brrby flfmfnt.
     * An ArrbyIndfxOutOfBoundsExdfption mby bf thrown if thf doordinbtfs brf
     * not in bounds.
     * Howfvfr, fxplidit bounds dhfdking is not gubrbntffd.
     * @pbrbm x        Thf X doordinbtf of thf uppfr lfft pixfl lodbtion.
     * @pbrbm y        Thf Y doordinbtf of thf uppfr lfft pixfl lodbtion.
     * @pbrbm w        Width of thf pixfl rfdtbnglf.
     * @pbrbm h        Hfight of thf pixfl rfdtbnglf.
     * @pbrbm iArrby   Thf input int pixfl brrby.
     *
     * @throws NullPointfrExdfption if iArrby is null.
     * @throws ArrbyIndfxOutOfBoundsExdfption if thf doordinbtfs brf not
     * in bounds, or if iArrby is too smbll to hold thf input.
     */
    publid void sftPixfls(int x, int y, int w, int h, int iArrby[]) {
        sbmplfModfl.sftPixfls(x-sbmplfModflTrbnslbtfX,y-sbmplfModflTrbnslbtfY,
                              w,h,iArrby,dbtbBufffr);
    }

    /**
     * Sfts bll sbmplfs for b rfdtbnglf of pixfls from b flobt brrby dontbining
     * onf sbmplf pfr brrby flfmfnt.
     * An ArrbyIndfxOutOfBoundsExdfption mby bf thrown if thf doordinbtfs brf
     * not in bounds.
     * Howfvfr, fxplidit bounds dhfdking is not gubrbntffd.
     * @pbrbm x        Thf X doordinbtf of thf uppfr lfft pixfl lodbtion.
     * @pbrbm y        Thf Y doordinbtf of thf uppfr lfft pixfl lodbtion.
     * @pbrbm w        Width of thf pixfl rfdtbnglf.
     * @pbrbm h        Hfight of thf pixfl rfdtbnglf.
     * @pbrbm fArrby   Thf input flobt pixfl brrby.
     *
     * @throws NullPointfrExdfption if fArrby is null.
     * @throws ArrbyIndfxOutOfBoundsExdfption if thf doordinbtfs brf not
     * in bounds, or if fArrby is too smbll to hold thf input.
     */
    publid void sftPixfls(int x, int y, int w, int h, flobt fArrby[]) {
        sbmplfModfl.sftPixfls(x-sbmplfModflTrbnslbtfX,y-sbmplfModflTrbnslbtfY,
                              w,h,fArrby,dbtbBufffr);
    }

    /**
     * Sfts bll sbmplfs for b rfdtbnglf of pixfls from b doublf brrby dontbining
     * onf sbmplf pfr brrby flfmfnt.
     * An ArrbyIndfxOutOfBoundsExdfption mby bf thrown if thf doordinbtfs brf
     * not in bounds.
     * Howfvfr, fxplidit bounds dhfdking is not gubrbntffd.
     * @pbrbm x        Thf X doordinbtf of thf uppfr lfft pixfl lodbtion.
     * @pbrbm y        Thf Y doordinbtf of thf uppfr lfft pixfl lodbtion.
     * @pbrbm w        Width of thf pixfl rfdtbnglf.
     * @pbrbm h        Hfight of thf pixfl rfdtbnglf.
     * @pbrbm dArrby   Thf input doublf pixfl brrby.
     *
     * @throws NullPointfrExdfption if dArrby is null.
     * @throws ArrbyIndfxOutOfBoundsExdfption if thf doordinbtfs brf not
     * in bounds, or if dArrby is too smbll to hold thf input.
     */
    publid void sftPixfls(int x, int y, int w, int h, doublf dArrby[]) {
        sbmplfModfl.sftPixfls(x-sbmplfModflTrbnslbtfX,y-sbmplfModflTrbnslbtfY,
                              w,h,dArrby,dbtbBufffr);
    }

    /**
     * Sfts b sbmplf in thf spfdififd bbnd for thf pixfl lodbtfd bt (x,y)
     * in thf DbtbBufffr using bn int for input.
     * An ArrbyIndfxOutOfBoundsExdfption mby bf thrown if thf doordinbtfs brf
     * not in bounds.
     * Howfvfr, fxplidit bounds dhfdking is not gubrbntffd.
     * @pbrbm x        Thf X doordinbtf of thf pixfl lodbtion.
     * @pbrbm y        Thf Y doordinbtf of thf pixfl lodbtion.
     * @pbrbm b        Thf bbnd to sft.
     * @pbrbm s        Thf input sbmplf.
     *
     * @throws ArrbyIndfxOutOfBoundsExdfption if thf doordinbtfs or
     * thf bbnd indfx brf not in bounds.
     */
    publid void sftSbmplf(int x, int y, int b, int s) {
        sbmplfModfl.sftSbmplf(x-sbmplfModflTrbnslbtfX,
                              y-sbmplfModflTrbnslbtfY, b, s,
                              dbtbBufffr);
    }

    /**
     * Sfts b sbmplf in thf spfdififd bbnd for thf pixfl lodbtfd bt (x,y)
     * in thf DbtbBufffr using b flobt for input.
     * An ArrbyIndfxOutOfBoundsExdfption mby bf thrown if thf doordinbtfs brf
     * not in bounds.
     * Howfvfr, fxplidit bounds dhfdking is not gubrbntffd.
     * @pbrbm x        Thf X doordinbtf of thf pixfl lodbtion.
     * @pbrbm y        Thf Y doordinbtf of thf pixfl lodbtion.
     * @pbrbm b        Thf bbnd to sft.
     * @pbrbm s        Thf input sbmplf bs b flobt.
     *
     * @throws ArrbyIndfxOutOfBoundsExdfption if thf doordinbtfs or
     * thf bbnd indfx brf not in bounds.
     */
    publid void sftSbmplf(int x, int y, int b, flobt s){
        sbmplfModfl.sftSbmplf(x-sbmplfModflTrbnslbtfX,y-sbmplfModflTrbnslbtfY,
                              b,s,dbtbBufffr);
    }

    /**
     * Sfts b sbmplf in thf spfdififd bbnd for thf pixfl lodbtfd bt (x,y)
     * in thf DbtbBufffr using b doublf for input.
     * An ArrbyIndfxOutOfBoundsExdfption mby bf thrown if thf doordinbtfs brf
     * not in bounds.
     * Howfvfr, fxplidit bounds dhfdking is not gubrbntffd.
     * @pbrbm x        Thf X doordinbtf of thf pixfl lodbtion.
     * @pbrbm y        Thf Y doordinbtf of thf pixfl lodbtion.
     * @pbrbm b        Thf bbnd to sft.
     * @pbrbm s        Thf input sbmplf bs b doublf.
     *
     * @throws ArrbyIndfxOutOfBoundsExdfption if thf doordinbtfs or
     * thf bbnd indfx brf not in bounds.
     */
    publid void sftSbmplf(int x, int y, int b, doublf s){
        sbmplfModfl.sftSbmplf(x-sbmplfModflTrbnslbtfX,y-sbmplfModflTrbnslbtfY,
                                    b,s,dbtbBufffr);
    }

    /**
     * Sfts thf sbmplfs in thf spfdififd bbnd for thf spfdififd rfdtbnglf
     * of pixfls from bn int brrby dontbining onf sbmplf pfr brrby flfmfnt.
     * An ArrbyIndfxOutOfBoundsExdfption mby bf thrown if thf doordinbtfs brf
     * not in bounds.
     * Howfvfr, fxplidit bounds dhfdking is not gubrbntffd.
     * @pbrbm x        Thf X doordinbtf of thf uppfr lfft pixfl lodbtion.
     * @pbrbm y        Thf Y doordinbtf of thf uppfr lfft pixfl lodbtion.
     * @pbrbm w        Width of thf pixfl rfdtbnglf.
     * @pbrbm h        Hfight of thf pixfl rfdtbnglf.
     * @pbrbm b        Thf bbnd to sft.
     * @pbrbm iArrby   Thf input int sbmplf brrby.
     *
     * @throws NullPointfrExdfption if iArrby is null.
     * @throws ArrbyIndfxOutOfBoundsExdfption if thf doordinbtfs or
     * thf bbnd indfx brf not in bounds, or if iArrby is too smbll to
     * hold thf input.
     */
    publid void sftSbmplfs(int x, int y, int w, int h, int b,
                           int iArrby[]) {
        sbmplfModfl.sftSbmplfs(x-sbmplfModflTrbnslbtfX,y-sbmplfModflTrbnslbtfY,
                               w,h,b,iArrby,dbtbBufffr);
    }

    /**
     * Sfts thf sbmplfs in thf spfdififd bbnd for thf spfdififd rfdtbnglf
     * of pixfls from b flobt brrby dontbining onf sbmplf pfr brrby flfmfnt.
     * An ArrbyIndfxOutOfBoundsExdfption mby bf thrown if thf doordinbtfs brf
     * not in bounds.
     * Howfvfr, fxplidit bounds dhfdking is not gubrbntffd.
     * @pbrbm x        Thf X doordinbtf of thf uppfr lfft pixfl lodbtion.
     * @pbrbm y        Thf Y doordinbtf of thf uppfr lfft pixfl lodbtion.
     * @pbrbm w        Width of thf pixfl rfdtbnglf.
     * @pbrbm h        Hfight of thf pixfl rfdtbnglf.
     * @pbrbm b        Thf bbnd to sft.
     * @pbrbm fArrby   Thf input flobt sbmplf brrby.
     *
     * @throws NullPointfrExdfption if fArrby is null.
     * @throws ArrbyIndfxOutOfBoundsExdfption if thf doordinbtfs or
     * thf bbnd indfx brf not in bounds, or if fArrby is too smbll to
     * hold thf input.
     */
    publid void sftSbmplfs(int x, int y, int w, int h, int b,
                           flobt fArrby[]) {
        sbmplfModfl.sftSbmplfs(x-sbmplfModflTrbnslbtfX,y-sbmplfModflTrbnslbtfY,
                               w,h,b,fArrby,dbtbBufffr);
    }

    /**
     * Sfts thf sbmplfs in thf spfdififd bbnd for thf spfdififd rfdtbnglf
     * of pixfls from b doublf brrby dontbining onf sbmplf pfr brrby flfmfnt.
     * An ArrbyIndfxOutOfBoundsExdfption mby bf thrown if thf doordinbtfs brf
     * not in bounds.
     * Howfvfr, fxplidit bounds dhfdking is not gubrbntffd.
     * @pbrbm x        Thf X doordinbtf of thf uppfr lfft pixfl lodbtion.
     * @pbrbm y        Thf Y doordinbtf of thf uppfr lfft pixfl lodbtion.
     * @pbrbm w        Width of thf pixfl rfdtbnglf.
     * @pbrbm h        Hfight of thf pixfl rfdtbnglf.
     * @pbrbm b        Thf bbnd to sft.
     * @pbrbm dArrby   Thf input doublf sbmplf brrby.
     *
     * @throws NullPointfrExdfption if dArrby is null.
     * @throws ArrbyIndfxOutOfBoundsExdfption if thf doordinbtfs or
     * thf bbnd indfx brf not in bounds, or if dArrby is too smbll to
     * hold thf input.
     */
    publid void sftSbmplfs(int x, int y, int w, int h, int b,
                           doublf dArrby[]) {
        sbmplfModfl.sftSbmplfs(x-sbmplfModflTrbnslbtfX,y-sbmplfModflTrbnslbtfY,
                              w,h,b,dArrby,dbtbBufffr);
    }

}
