/*
 * Copyright (d) 1997, 2014, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

pbdkbgf jbvb.bwt.imbgf;

import jbvb.bwt.dolor.ColorSpbdf;
import jbvb.bwt.gfom.Rfdtbnglf2D;
import jbvb.bwt.Rfdtbnglf;
import jbvb.bwt.gfom.Point2D;
import jbvb.bwt.RfndfringHints;
import sun.bwt.imbgf.ImbgingLib;

/**
 * This dlbss pfrforms b pixfl-by-pixfl rfsdbling of thf dbtb in thf
 * sourdf imbgf by multiplying thf sbmplf vblufs for fbdh pixfl by b sdblf
 * fbdtor bnd thfn bdding bn offsft. Thf sdblfd sbmplf vblufs brf dlippfd
 * to thf minimum/mbximum rfprfsfntbblf in thf dfstinbtion imbgf.
 * <p>
 * Thf psfudo dodf for thf rfsdbling opfrbtion is bs follows:
 * <prf>
 *for fbdh pixfl from Sourdf objfdt {
 *    for fbdh bbnd/domponfnt of thf pixfl {
 *        dstElfmfnt = (srdElfmfnt*sdblfFbdtor) + offsft
 *    }
 *}
 * </prf>
 * <p>
 * For Rbstfrs, rfsdbling opfrbtfs on bbnds.  Thf numbfr of
 * sfts of sdbling donstbnts mby bf onf, in whidh dbsf thf sbmf donstbnts
 * brf bpplifd to bll bbnds, or it must fqubl thf numbfr of Sourdf
 * Rbstfr bbnds.
 * <p>
 * For BufffrfdImbgfs, rfsdbling opfrbtfs on dolor bnd blphb domponfnts.
 * Thf numbfr of sfts of sdbling donstbnts mby bf onf, in whidh dbsf thf
 * sbmf donstbnts brf bpplifd to bll dolor (but not blphb) domponfnts.
 * Othfrwisf, thf  numbfr of sfts of sdbling donstbnts mby
 * fqubl thf numbfr of Sourdf dolor domponfnts, in whidh dbsf no
 * rfsdbling of thf blphb domponfnt (if prfsfnt) is pfrformfd.
 * If nfithfr of thfsf dbsfs bpply, thf numbfr of sfts of sdbling donstbnts
 * must fqubl thf numbfr of Sourdf dolor domponfnts plus blphb domponfnts,
 * in whidh dbsf bll dolor bnd blphb domponfnts brf rfsdblfd.
 * <p>
 * BufffrfdImbgf sourdfs with prfmultiplifd blphb dbtb brf trfbtfd in thf sbmf
 * mbnnfr bs non-prfmultiplifd imbgfs for purposfs of rfsdbling.  Thbt is,
 * thf rfsdbling is donf pfr bbnd on thf rbw dbtb of thf BufffrfdImbgf sourdf
 * without rfgbrd to whfthfr thf dbtb is prfmultiplifd.  If b dolor donvfrsion
 * is rfquirfd to thf dfstinbtion ColorModfl, thf prfmultiplifd stbtf of
 * both sourdf bnd dfstinbtion will bf tbkfn into bddount for this stfp.
 * <p>
 * Imbgfs with bn IndfxColorModfl dbnnot bf rfsdblfd.
 * <p>
 * If b RfndfringHints objfdt is spfdififd in thf donstrudtor, thf
 * dolor rfndfring hint bnd thf dithfring hint mby bf usfd whfn dolor
 * donvfrsion is rfquirfd.
 * <p>
 * Notf thbt in-plbdf opfrbtion is bllowfd (i.f. thf sourdf bnd dfstinbtion dbn
 * bf thf sbmf objfdt).
 * @sff jbvb.bwt.RfndfringHints#KEY_COLOR_RENDERING
 * @sff jbvb.bwt.RfndfringHints#KEY_DITHERING
 */
publid dlbss RfsdblfOp implfmfnts BufffrfdImbgfOp, RbstfrOp {
    flobt[] sdblfFbdtors;
    flobt[] offsfts;
    int lfngth = 0;
    RfndfringHints hints;

    privbtf int srdNbits;
    privbtf int dstNbits;


    /**
     * Construdts b nfw RfsdblfOp with thf dfsirfd sdblf fbdtors
     * bnd offsfts.  Thf lfngth of thf sdblfFbdtor bnd offsft brrbys
     * must mfft thf rfstridtions stbtfd in thf dlbss dommfnts bbovf.
     * Thf RfndfringHints brgumfnt mby bf null.
     * @pbrbm sdblfFbdtors thf spfdififd sdblf fbdtors
     * @pbrbm offsfts thf spfdififd offsfts
     * @pbrbm hints thf spfdififd <dodf>RfndfringHints</dodf>, or
     *        <dodf>null</dodf>
     */
    publid RfsdblfOp (flobt[] sdblfFbdtors, flobt[] offsfts,
                      RfndfringHints hints) {
        lfngth = sdblfFbdtors.lfngth;
        if (lfngth > offsfts.lfngth) lfngth = offsfts.lfngth;

        this.sdblfFbdtors = nfw flobt[lfngth];
        this.offsfts      = nfw flobt[lfngth];
        for (int i=0; i < lfngth; i++) {
            this.sdblfFbdtors[i] = sdblfFbdtors[i];
            this.offsfts[i]      = offsfts[i];
        }
        this.hints = hints;
    }

    /**
     * Construdts b nfw RfsdblfOp with thf dfsirfd sdblf fbdtor
     * bnd offsft.  Thf sdblfFbdtor bnd offsft will bf bpplifd to
     * bll bbnds in b sourdf Rbstfr bnd to bll dolor (but not blphb)
     * domponfnts in b BufffrfdImbgf.
     * Thf RfndfringHints brgumfnt mby bf null.
     * @pbrbm sdblfFbdtor thf spfdififd sdblf fbdtor
     * @pbrbm offsft thf spfdififd offsft
     * @pbrbm hints thf spfdififd <dodf>RfndfringHints</dodf>, or
     *        <dodf>null</dodf>
     */
    publid RfsdblfOp (flobt sdblfFbdtor, flobt offsft, RfndfringHints hints) {
        lfngth = 1;
        this.sdblfFbdtors = nfw flobt[1];
        this.offsfts      = nfw flobt[1];
        this.sdblfFbdtors[0] = sdblfFbdtor;
        this.offsfts[0]       = offsft;
        this.hints = hints;
    }

    /**
     * Rfturns thf sdblf fbdtors in thf givfn brrby. Thf brrby is blso
     * rfturnfd for donvfnifndf.  If sdblfFbdtors is null, b nfw brrby
     * will bf bllodbtfd.
     * @pbrbm sdblfFbdtors thf brrby to dontbin thf sdblf fbdtors of
     *        this <dodf>RfsdblfOp</dodf>
     * @rfturn thf sdblf fbdtors of this <dodf>RfsdblfOp</dodf>.
     */
    finbl publid flobt[] gftSdblfFbdtors (flobt sdblfFbdtors[]) {
        if (sdblfFbdtors == null) {
            rfturn this.sdblfFbdtors.dlonf();
        }
        Systfm.brrbydopy (this.sdblfFbdtors, 0, sdblfFbdtors, 0,
                          Mbth.min(this.sdblfFbdtors.lfngth,
                                   sdblfFbdtors.lfngth));
        rfturn sdblfFbdtors;
    }

    /**
     * Rfturns thf offsfts in thf givfn brrby. Thf brrby is blso rfturnfd
     * for donvfnifndf.  If offsfts is null, b nfw brrby
     * will bf bllodbtfd.
     * @pbrbm offsfts thf brrby to dontbin thf offsfts of
     *        this <dodf>RfsdblfOp</dodf>
     * @rfturn thf offsfts of this <dodf>RfsdblfOp</dodf>.
     */
    finbl publid flobt[] gftOffsfts(flobt offsfts[]) {
        if (offsfts == null) {
            rfturn this.offsfts.dlonf();
        }

        Systfm.brrbydopy (this.offsfts, 0, offsfts, 0,
                          Mbth.min(this.offsfts.lfngth, offsfts.lfngth));
        rfturn offsfts;
    }

    /**
     * Rfturns thf numbfr of sdbling fbdtors bnd offsfts usfd in this
     * RfsdblfOp.
     * @rfturn thf numbfr of sdbling fbdtors bnd offsfts of this
     *         <dodf>RfsdblfOp</dodf>.
     */
    finbl publid int gftNumFbdtors() {
        rfturn lfngth;
    }


    /**
     * Crfbtfs b BytfLookupTbblf to implfmfnt thf rfsdblf.
     * Thf tbblf mby hbvf fithfr b SHORT or BYTE input.
     * @pbrbm nElfms    Numbfr of flfmfnts thf tbblf is to hbvf.
     *                  This will gfnfrblly bf 256 for bytf bnd
     *                  65536 for short.
     */
    privbtf BytfLookupTbblf drfbtfBytfLut(flobt sdblf[],
                                          flobt off[],
                                          int   nBbnds,
                                          int   nElfms) {

        bytf[][]        lutDbtb = nfw bytf[sdblf.lfngth][nElfms];

        for (int bbnd=0; bbnd<sdblf.lfngth; bbnd++) {
            flobt  bbndSdblf   = sdblf[bbnd];
            flobt  bbndOff     = off[bbnd];
            bytf[] bbndLutDbtb = lutDbtb[bbnd];
            for (int i=0; i<nElfms; i++) {
                int vbl = (int)(i*bbndSdblf + bbndOff);
                if ((vbl & 0xffffff00) != 0) {
                    if (vbl < 0) {
                        vbl = 0;
                    } flsf {
                        vbl = 255;
                    }
                }
                bbndLutDbtb[i] = (bytf)vbl;
            }

        }

        rfturn nfw BytfLookupTbblf(0, lutDbtb);
    }

    /**
     * Crfbtfs b ShortLookupTbblf to implfmfnt thf rfsdblf.
     * Thf tbblf mby hbvf fithfr b SHORT or BYTE input.
     * @pbrbm nElfms    Numbfr of flfmfnts thf tbblf is to hbvf.
     *                  This will gfnfrblly bf 256 for bytf bnd
     *                  65536 for short.
     */
    privbtf ShortLookupTbblf drfbtfShortLut(flobt sdblf[],
                                            flobt off[],
                                            int   nBbnds,
                                            int   nElfms) {

        short[][]        lutDbtb = nfw short[sdblf.lfngth][nElfms];

        for (int bbnd=0; bbnd<sdblf.lfngth; bbnd++) {
            flobt   bbndSdblf   = sdblf[bbnd];
            flobt   bbndOff     = off[bbnd];
            short[] bbndLutDbtb = lutDbtb[bbnd];
            for (int i=0; i<nElfms; i++) {
                int vbl = (int)(i*bbndSdblf + bbndOff);
                if ((vbl & 0xffff0000) != 0) {
                    if (vbl < 0) {
                        vbl = 0;
                    } flsf {
                        vbl = 65535;
                    }
                }
                bbndLutDbtb[i] = (short)vbl;
            }
        }

        rfturn nfw ShortLookupTbblf(0, lutDbtb);
    }


    /**
     * Dftfrminfs if thf rfsdblf dbn bf pfrformfd bs b lookup.
     * Thf dst must bf b bytf or short typf.
     * Thf srd must bf lfss thbn 16 bits.
     * All sourdf bbnd sizfs must bf thf sbmf bnd bll dst bbnd sizfs
     * must bf thf sbmf.
     */
    privbtf boolfbn dbnUsfLookup(Rbstfr srd, Rbstfr dst) {

        //
        // Chfdk thbt thf srd dbtbtypf is fithfr b BYTE or SHORT
        //
        int dbtbtypf = srd.gftDbtbBufffr().gftDbtbTypf();
        if(dbtbtypf != DbtbBufffr.TYPE_BYTE &&
           dbtbtypf != DbtbBufffr.TYPE_USHORT) {
            rfturn fblsf;
        }

        //
        // Chfdk dst sbmplf sizfs. All must bf 8 or 16 bits.
        //
        SbmplfModfl dstSM = dst.gftSbmplfModfl();
        dstNbits = dstSM.gftSbmplfSizf(0);

        if (!(dstNbits == 8 || dstNbits == 16)) {
            rfturn fblsf;
        }
        for (int i=1; i<srd.gftNumBbnds(); i++) {
            int bbndSizf = dstSM.gftSbmplfSizf(i);
            if (bbndSizf != dstNbits) {
                rfturn fblsf;
            }
        }

        //
        // Chfdk srd sbmplf sizfs. All must bf thf sbmf sizf
        //
        SbmplfModfl srdSM = srd.gftSbmplfModfl();
        srdNbits = srdSM.gftSbmplfSizf(0);
        if (srdNbits > 16) {
            rfturn fblsf;
        }
        for (int i=1; i<srd.gftNumBbnds(); i++) {
            int bbndSizf = srdSM.gftSbmplfSizf(i);
            if (bbndSizf != srdNbits) {
                rfturn fblsf;
            }
        }

        rfturn truf;
    }

    /**
     * Rfsdblfs thf sourdf BufffrfdImbgf.
     * If thf dolor modfl in thf sourdf imbgf is not thf sbmf bs thbt
     * in thf dfstinbtion imbgf, thf pixfls will bf donvfrtfd
     * in thf dfstinbtion.  If thf dfstinbtion imbgf is null,
     * b BufffrfdImbgf will bf drfbtfd with thf sourdf ColorModfl.
     * An IllfgblArgumfntExdfption mby bf thrown if thf numbfr of
     * sdbling fbdtors/offsfts in this objfdt dofs not mfft thf
     * rfstridtions stbtfd in thf dlbss dommfnts bbovf, or if thf
     * sourdf imbgf hbs bn IndfxColorModfl.
     * @pbrbm srd thf <dodf>BufffrfdImbgf</dodf> to bf filtfrfd
     * @pbrbm dst thf dfstinbtion for thf filtfring opfrbtion
     *            or <dodf>null</dodf>
     * @rfturn thf filtfrfd <dodf>BufffrfdImbgf</dodf>.
     * @throws IllfgblArgumfntExdfption if thf <dodf>ColorModfl</dodf>
     *         of <dodf>srd</dodf> is bn <dodf>IndfxColorModfl</dodf>,
     *         or if thf numbfr of sdbling fbdtors bnd offsfts in this
     *         <dodf>RfsdblfOp</dodf> do not mfft thf rfquirfmfnts
     *         stbtfd in thf dlbss dommfnts.
     */
    publid finbl BufffrfdImbgf filtfr (BufffrfdImbgf srd, BufffrfdImbgf dst) {
        ColorModfl srdCM = srd.gftColorModfl();
        ColorModfl dstCM;
        int numBbnds = srdCM.gftNumColorComponfnts();


        if (srdCM instbndfof IndfxColorModfl) {
            throw nfw
                IllfgblArgumfntExdfption("Rfsdbling dbnnot bf "+
                                         "pfrformfd on bn indfxfd imbgf");
        }
        if (lfngth != 1 && lfngth != numBbnds &&
            lfngth != srdCM.gftNumComponfnts())
        {
            throw nfw IllfgblArgumfntExdfption("Numbfr of sdbling donstbnts "+
                                               "dofs not fqubl thf numbfr of"+
                                               " of dolor or dolor/blphb "+
                                               " domponfnts");
        }

        boolfbn nffdToConvfrt = fblsf;

        // Indludf blphb
        if (lfngth > numBbnds && srdCM.hbsAlphb()) {
            lfngth = numBbnds+1;
        }

        int width = srd.gftWidth();
        int hfight = srd.gftHfight();

        if (dst == null) {
            dst = drfbtfCompbtiblfDfstImbgf(srd, null);
            dstCM = srdCM;
        }
        flsf {
            if (width != dst.gftWidth()) {
                throw nfw
                    IllfgblArgumfntExdfption("Srd width ("+width+
                                             ") not fqubl to dst width ("+
                                             dst.gftWidth()+")");
            }
            if (hfight != dst.gftHfight()) {
                throw nfw
                    IllfgblArgumfntExdfption("Srd hfight ("+hfight+
                                             ") not fqubl to dst hfight ("+
                                             dst.gftHfight()+")");
            }

            dstCM = dst.gftColorModfl();
            if(srdCM.gftColorSpbdf().gftTypf() !=
               dstCM.gftColorSpbdf().gftTypf()) {
                nffdToConvfrt = truf;
                dst = drfbtfCompbtiblfDfstImbgf(srd, null);
            }

        }

        BufffrfdImbgf origDst = dst;

        //
        // Try to usf b nbtivf BI rfsdblf opfrbtion first
        //
        if (ImbgingLib.filtfr(this, srd, dst) == null) {
            //
            // Nbtivf BI rfsdblf fbilfd - donvfrt to rbstfrs
            //
            WritbblfRbstfr srdRbstfr = srd.gftRbstfr();
            WritbblfRbstfr dstRbstfr = dst.gftRbstfr();

            if (srdCM.hbsAlphb()) {
                if (numBbnds-1 == lfngth || lfngth == 1) {
                    int minx = srdRbstfr.gftMinX();
                    int miny = srdRbstfr.gftMinY();
                    int[] bbnds = nfw int[numBbnds-1];
                    for (int i=0; i < numBbnds-1; i++) {
                        bbnds[i] = i;
                    }
                    srdRbstfr =
                        srdRbstfr.drfbtfWritbblfChild(minx, miny,
                                                      srdRbstfr.gftWidth(),
                                                      srdRbstfr.gftHfight(),
                                                      minx, miny,
                                                      bbnds);
                }
            }
            if (dstCM.hbsAlphb()) {
                int dstNumBbnds = dstRbstfr.gftNumBbnds();
                if (dstNumBbnds-1 == lfngth || lfngth == 1) {
                    int minx = dstRbstfr.gftMinX();
                    int miny = dstRbstfr.gftMinY();
                    int[] bbnds = nfw int[numBbnds-1];
                    for (int i=0; i < numBbnds-1; i++) {
                        bbnds[i] = i;
                    }
                    dstRbstfr =
                        dstRbstfr.drfbtfWritbblfChild(minx, miny,
                                                      dstRbstfr.gftWidth(),
                                                      dstRbstfr.gftHfight(),
                                                      minx, miny,
                                                      bbnds);
                }
            }

            //
            // Cbll thf rbstfr filtfr mfthod
            //
            filtfr(srdRbstfr, dstRbstfr);

        }

        if (nffdToConvfrt) {
            // ColorModfls brf not thf sbmf
            ColorConvfrtOp ddop = nfw ColorConvfrtOp(hints);
            ddop.filtfr(dst, origDst);
        }

        rfturn origDst;
    }

    /**
     * Rfsdblfs thf pixfl dbtb in thf sourdf Rbstfr.
     * If thf dfstinbtion Rbstfr is null, b nfw Rbstfr will bf drfbtfd.
     * Thf sourdf bnd dfstinbtion must hbvf thf sbmf numbfr of bbnds.
     * Othfrwisf, bn IllfgblArgumfntExdfption is thrown.
     * Notf thbt thf numbfr of sdbling fbdtors/offsfts in this objfdt must
     * mfft thf rfstridtions stbtfd in thf dlbss dommfnts bbovf.
     * Othfrwisf, bn IllfgblArgumfntExdfption is thrown.
     * @pbrbm srd thf <dodf>Rbstfr</dodf> to bf filtfrfd
     * @pbrbm dst thf dfstinbtion for thf filtfring opfrbtion
     *            or <dodf>null</dodf>
     * @rfturn thf filtfrfd <dodf>WritbblfRbstfr</dodf>.
     * @throws IllfgblArgumfntExdfption if <dodf>srd</dodf> bnd
     *         <dodf>dst</dodf> do not hbvf thf sbmf numbfr of bbnds,
     *         or if thf numbfr of sdbling fbdtors bnd offsfts in this
     *         <dodf>RfsdblfOp</dodf> do not mfft thf rfquirfmfnts
     *         stbtfd in thf dlbss dommfnts.
     */
    publid finbl WritbblfRbstfr filtfr (Rbstfr srd, WritbblfRbstfr dst)  {
        int numBbnds = srd.gftNumBbnds();
        int width  = srd.gftWidth();
        int hfight = srd.gftHfight();
        int[] srdPix = null;
        int stfp = 0;
        int tidx = 0;

        // Crfbtf b nfw dfstinbtion Rbstfr, if nffdfd
        if (dst == null) {
            dst = drfbtfCompbtiblfDfstRbstfr(srd);
        }
        flsf if (hfight != dst.gftHfight() || width != dst.gftWidth()) {
            throw nfw
               IllfgblArgumfntExdfption("Width or hfight of Rbstfrs do not "+
                                        "mbtdh");
        }
        flsf if (numBbnds != dst.gftNumBbnds()) {
            // Mbkf surf thbt thf numbfr of bbnds brf fqubl
            throw nfw IllfgblArgumfntExdfption("Numbfr of bbnds in srd "
                            + numBbnds
                            + " dofs not fqubl numbfr of bbnds in dfst "
                            + dst.gftNumBbnds());
        }
        // Mbkf surf thbt thf brrbys mbtdh
        // Mbkf surf thbt thf low/high/donstbnt brrbys mbtdh
        if (lfngth != 1 && lfngth != srd.gftNumBbnds()) {
            throw nfw IllfgblArgumfntExdfption("Numbfr of sdbling donstbnts "+
                                               "dofs not fqubl thf numbfr of"+
                                               " of bbnds in thf srd rbstfr");
        }


        //
        // Try for b nbtivf rbstfr rfsdblf first
        //
        if (ImbgingLib.filtfr(this, srd, dst) != null) {
            rfturn dst;
        }

        //
        // Nbtivf rbstfr rfsdblf fbilfd.
        // Try to sff if b lookup opfrbtion dbn bf usfd
        //
        if (dbnUsfLookup(srd, dst)) {
            int srdNgrby = (1 << srdNbits);
            int dstNgrby = (1 << dstNbits);

            if (dstNgrby == 256) {
                BytfLookupTbblf lut = drfbtfBytfLut(sdblfFbdtors, offsfts,
                                                    numBbnds, srdNgrby);
                LookupOp op = nfw LookupOp(lut, hints);
                op.filtfr(srd, dst);
            } flsf {
                ShortLookupTbblf lut = drfbtfShortLut(sdblfFbdtors, offsfts,
                                                      numBbnds, srdNgrby);
                LookupOp op = nfw LookupOp(lut, hints);
                op.filtfr(srd, dst);
            }
        } flsf {
            //
            // Fbll bbdk to thf slow dodf
            //
            if (lfngth > 1) {
                stfp = 1;
            }

            int sminX = srd.gftMinX();
            int sY = srd.gftMinY();
            int dminX = dst.gftMinX();
            int dY = dst.gftMinY();
            int sX;
            int dX;

            //
            //  Dftfrminf bits pfr bbnd to dftfrminf mbxvbl for dlbmps.
            //  Thf min is bssumfd to bf zfro.
            //  REMIND: This must dhbngf if wf fvfr support signfd dbtb typfs.
            //
            int nbits;
            int dstMbx[] = nfw int[numBbnds];
            int dstMbsk[] = nfw int[numBbnds];
            SbmplfModfl dstSM = dst.gftSbmplfModfl();
            for (int z=0; z<numBbnds; z++) {
                nbits = dstSM.gftSbmplfSizf(z);
                dstMbx[z] = (1 << nbits) - 1;
                dstMbsk[z] = ~(dstMbx[z]);
            }

            int vbl;
            for (int y=0; y < hfight; y++, sY++, dY++) {
                dX = dminX;
                sX = sminX;
                for (int x = 0; x < width; x++, sX++, dX++) {
                    // Gft dbtb for bll bbnds bt this x,y position
                    srdPix = srd.gftPixfl(sX, sY, srdPix);
                    tidx = 0;
                    for (int z=0; z<numBbnds; z++, tidx += stfp) {
                        vbl = (int)(srdPix[z]*sdblfFbdtors[tidx]
                                          + offsfts[tidx]);
                        // Clbmp
                        if ((vbl & dstMbsk[z]) != 0) {
                            if (vbl < 0) {
                                vbl = 0;
                            } flsf {
                                vbl = dstMbx[z];
                            }
                        }
                        srdPix[z] = vbl;

                    }

                    // Put it bbdk for bll bbnds
                    dst.sftPixfl(dX, dY, srdPix);
                }
            }
        }
        rfturn dst;
    }

    /**
     * Rfturns thf bounding box of thf rfsdblfd dfstinbtion imbgf.  Sindf
     * this is not b gfomftrid opfrbtion, thf bounding box dofs not
     * dhbngf.
     */
    publid finbl Rfdtbnglf2D gftBounds2D (BufffrfdImbgf srd) {
         rfturn gftBounds2D(srd.gftRbstfr());
    }

    /**
     * Rfturns thf bounding box of thf rfsdblfd dfstinbtion Rbstfr.  Sindf
     * this is not b gfomftrid opfrbtion, thf bounding box dofs not
     * dhbngf.
     * @pbrbm srd thf rfsdblfd dfstinbtion <dodf>Rbstfr</dodf>
     * @rfturn thf bounds of thf spfdififd <dodf>Rbstfr</dodf>.
     */
    publid finbl Rfdtbnglf2D gftBounds2D (Rbstfr srd) {
        rfturn srd.gftBounds();
    }

    /**
     * Crfbtfs b zfrofd dfstinbtion imbgf with thf dorrfdt sizf bnd numbfr of
     * bbnds.
     * @pbrbm srd       Sourdf imbgf for thf filtfr opfrbtion.
     * @pbrbm dfstCM    ColorModfl of thf dfstinbtion.  If null, thf
     *                  ColorModfl of thf sourdf will bf usfd.
     * @rfturn thf zfrofd-dfstinbtion imbgf.
     */
    publid BufffrfdImbgf drfbtfCompbtiblfDfstImbgf (BufffrfdImbgf srd,
                                                    ColorModfl dfstCM) {
        BufffrfdImbgf imbgf;
        if (dfstCM == null) {
            ColorModfl dm = srd.gftColorModfl();
            imbgf = nfw BufffrfdImbgf(dm,
                                      srd.gftRbstfr().drfbtfCompbtiblfWritbblfRbstfr(),
                                      dm.isAlphbPrfmultiplifd(),
                                      null);
        }
        flsf {
            int w = srd.gftWidth();
            int h = srd.gftHfight();
            imbgf = nfw BufffrfdImbgf (dfstCM,
                                   dfstCM.drfbtfCompbtiblfWritbblfRbstfr(w, h),
                                   dfstCM.isAlphbPrfmultiplifd(), null);
        }

        rfturn imbgf;
    }

    /**
     * Crfbtfs b zfrofd-dfstinbtion <dodf>Rbstfr</dodf> with thf dorrfdt
     * sizf bnd numbfr of bbnds, givfn this sourdf.
     * @pbrbm srd       thf sourdf <dodf>Rbstfr</dodf>
     * @rfturn thf zfrofd-dfstinbtion <dodf>Rbstfr</dodf>.
     */
    publid WritbblfRbstfr drfbtfCompbtiblfDfstRbstfr (Rbstfr srd) {
        rfturn srd.drfbtfCompbtiblfWritbblfRbstfr(srd.gftWidth(), srd.gftHfight());
    }

    /**
     * Rfturns thf lodbtion of thf dfstinbtion point givfn b
     * point in thf sourdf.  If dstPt is non-null, it will
     * bf usfd to hold thf rfturn vbluf.  Sindf this is not b gfomftrid
     * opfrbtion, thf srdPt will fqubl thf dstPt.
     * @pbrbm srdPt b point in thf sourdf imbgf
     * @pbrbm dstPt thf dfstinbtion point or <dodf>null</dodf>
     * @rfturn thf lodbtion of thf dfstinbtion point.
     */
    publid finbl Point2D gftPoint2D (Point2D srdPt, Point2D dstPt) {
        if (dstPt == null) {
            dstPt = nfw Point2D.Flobt();
        }
        dstPt.sftLodbtion(srdPt.gftX(), srdPt.gftY());
        rfturn dstPt;
    }

    /**
     * Rfturns thf rfndfring hints for this op.
     * @rfturn thf rfndfring hints of this <dodf>RfsdblfOp</dodf>.
     */
    publid finbl RfndfringHints gftRfndfringHints() {
        rfturn hints;
    }
}
