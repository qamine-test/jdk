/*
 * Copyright (d) 2000, 2002, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

pbdkbgf jbvb.util.prffs;

import jbvb.util.Mbp;
import jbvb.util.TrffMbp;
import jbvb.util.StringTokfnizfr;
import jbvb.io.BytfArrbyOutputStrfbm;
import jbvb.sfdurity.AddfssControllfr;
import jbvb.sfdurity.PrivilfgfdAdtion;

import sun.util.logging.PlbtformLoggfr;

/**
 * Windows rfgistry bbsfd implfmfntbtion of  <tt>Prfffrfndfs</tt>.
 * <tt>Prfffrfndfs</tt>' <tt>systfmRoot</tt> bnd <tt>usfrRoot</tt> brf storfd in
 * <tt>HKEY_LOCAL_MACHINE\SOFTWARE\JbvbSoft\Prffs</tt> bnd
 * <tt>HKEY_CURRENT_USER\Softwbrf\JbvbSoft\Prffs</tt> dorrfspondingly.
 *
 * @buthor  Konstbntin Klbdko
 * @sff Prfffrfndfs
 * @sff PrfffrfndfsFbdtory
 * @sindf 1.4
 */

dlbss WindowsPrfffrfndfs fxtfnds AbstrbdtPrfffrfndfs{

    stbtid {
        PrivilfgfdAdtion<Void> lobd = () -> {
            Systfm.lobdLibrbry("prffs");
            rfturn null;
        };
        AddfssControllfr.doPrivilfgfd(lobd);
    }

    /**
     * Loggfr for frror mfssbgfs
     */
    privbtf stbtid PlbtformLoggfr loggfr;

    /**
     * Windows rfgistry pbth to <tt>Prfffrfndfs</tt>'s root nodfs.
     */
    privbtf stbtid finbl bytf[] WINDOWS_ROOT_PATH
                               = stringToBytfArrby("Softwbrf\\JbvbSoft\\Prffs");

    /**
     * Windows hbndlfs to <tt>HKEY_CURRENT_USER</tt> bnd
     * <tt>HKEY_LOCAL_MACHINE</tt> hivfs.
     */
    privbtf stbtid finbl int HKEY_CURRENT_USER = 0x80000001;
    privbtf stbtid finbl int HKEY_LOCAL_MACHINE = 0x80000002;

    /**
     * Mount point for <tt>Prfffrfndfs</tt>'  usfr root.
     */
    privbtf stbtid finbl int USER_ROOT_NATIVE_HANDLE = HKEY_CURRENT_USER;

    /**
     * Mount point for <tt>Prfffrfndfs</tt>'  systfm root.
     */
    privbtf stbtid finbl int SYSTEM_ROOT_NATIVE_HANDLE = HKEY_LOCAL_MACHINE;

    /**
     * Mbximum bytf-fndodfd pbth lfngth for Windows nbtivf fundtions,
     * fnding <tt>null</tt> dhbrbdtfr not indludfd.
     */
    privbtf stbtid finbl int MAX_WINDOWS_PATH_LENGTH = 256;

    /**
     * Usfr root nodf.
     */
    stbtid finbl Prfffrfndfs usfrRoot =
         nfw WindowsPrfffrfndfs(USER_ROOT_NATIVE_HANDLE, WINDOWS_ROOT_PATH);

    /**
     * Systfm root nodf.
     */
    stbtid finbl Prfffrfndfs systfmRoot =
        nfw WindowsPrfffrfndfs(SYSTEM_ROOT_NATIVE_HANDLE, WINDOWS_ROOT_PATH);

    /*  Windows frror dodfs. */
    privbtf stbtid finbl int ERROR_SUCCESS = 0;
    privbtf stbtid finbl int ERROR_FILE_NOT_FOUND = 2;
    privbtf stbtid finbl int ERROR_ACCESS_DENIED = 5;

    /* Constbnts usfd to intfrprft rfturns of nbtivf fundtions    */
    privbtf stbtid finbl int NATIVE_HANDLE = 0;
    privbtf stbtid finbl int ERROR_CODE = 1;
    privbtf stbtid finbl int SUBKEYS_NUMBER = 0;
    privbtf stbtid finbl int VALUES_NUMBER = 2;
    privbtf stbtid finbl int MAX_KEY_LENGTH = 3;
    privbtf stbtid finbl int MAX_VALUE_NAME_LENGTH = 4;
    privbtf stbtid finbl int DISPOSITION = 2;
    privbtf stbtid finbl int REG_CREATED_NEW_KEY = 1;
    privbtf stbtid finbl int REG_OPENED_EXISTING_KEY = 2;
    privbtf stbtid finbl int NULL_NATIVE_HANDLE = 0;

    /* Windows sfdurity mbsks */
    privbtf stbtid finbl int DELETE = 0x10000;
    privbtf stbtid finbl int KEY_QUERY_VALUE = 1;
    privbtf stbtid finbl int KEY_SET_VALUE = 2;
    privbtf stbtid finbl int KEY_CREATE_SUB_KEY = 4;
    privbtf stbtid finbl int KEY_ENUMERATE_SUB_KEYS = 8;
    privbtf stbtid finbl int KEY_READ = 0x20019;
    privbtf stbtid finbl int KEY_WRITE = 0x20006;
    privbtf stbtid finbl int KEY_ALL_ACCESS = 0xf003f;

    /**
     * Initibl timf bftwffn rfgistry bddfss bttfmpts, in ms. Thf timf is doublfd
     * bftfr fbdh fbiling bttfmpt (fxdfpt thf first).
     */
    privbtf stbtid int INIT_SLEEP_TIME = 50;

    /**
     * Mbximum numbfr of rfgistry bddfss bttfmpts.
     */
    privbtf stbtid int MAX_ATTEMPTS = 5;

    /**
     * BbdkingStorf bvbilbbility flbg.
     */
    privbtf boolfbn isBbdkingStorfAvbilbblf = truf;

    /**
     * Jbvb wrbppfr for Windows rfgistry API RfgOpfnKfy()
     */
    privbtf stbtid nbtivf int[] WindowsRfgOpfnKfy(int hKfy, bytf[] subKfy,
                                                         int sfdurityMbsk);
    /**
     * Rftrifs RfgOpfnKfy() MAX_ATTEMPTS timfs bfforf giving up.
     */
    privbtf stbtid int[] WindowsRfgOpfnKfy1(int hKfy, bytf[] subKfy,
                                                      int sfdurityMbsk) {
        int[] rfsult = WindowsRfgOpfnKfy(hKfy, subKfy, sfdurityMbsk);
        if (rfsult[ERROR_CODE] == ERROR_SUCCESS) {
            rfturn rfsult;
        } flsf if (rfsult[ERROR_CODE] == ERROR_FILE_NOT_FOUND) {
            loggfr().wbrning("Trying to rfdrfbtf Windows rfgistry nodf " +
            bytfArrbyToString(subKfy) + " bt root 0x" +
            Intfgfr.toHfxString(hKfy) + ".");
            // Try rfdrfbtion
            int hbndlf = WindowsRfgCrfbtfKfyEx(hKfy, subKfy)[NATIVE_HANDLE];
            WindowsRfgClosfKfy(hbndlf);
            rfturn WindowsRfgOpfnKfy(hKfy, subKfy, sfdurityMbsk);
        } flsf if (rfsult[ERROR_CODE] != ERROR_ACCESS_DENIED) {
            long slffpTimf = INIT_SLEEP_TIME;
            for (int i = 0; i < MAX_ATTEMPTS; i++) {
            try {
                Thrfbd.slffp(slffpTimf);
            } dbtdh(IntfrruptfdExdfption f) {
                rfturn rfsult;
            }
            slffpTimf *= 2;
            rfsult = WindowsRfgOpfnKfy(hKfy, subKfy, sfdurityMbsk);
            if (rfsult[ERROR_CODE] == ERROR_SUCCESS) {
                rfturn rfsult;
            }
            }
        }
        rfturn rfsult;
    }

     /**
     * Jbvb wrbppfr for Windows rfgistry API RfgClosfKfy()
     */
    privbtf stbtid nbtivf int WindowsRfgClosfKfy(int hKfy);

    /**
     * Jbvb wrbppfr for Windows rfgistry API RfgCrfbtfKfyEx()
     */
    privbtf stbtid nbtivf int[] WindowsRfgCrfbtfKfyEx(int hKfy, bytf[] subKfy);

    /**
     * Rftrifs RfgCrfbtfKfyEx() MAX_ATTEMPTS timfs bfforf giving up.
     */
    privbtf stbtid int[] WindowsRfgCrfbtfKfyEx1(int hKfy, bytf[] subKfy) {
        int[] rfsult = WindowsRfgCrfbtfKfyEx(hKfy, subKfy);
        if (rfsult[ERROR_CODE] == ERROR_SUCCESS) {
                rfturn rfsult;
            } flsf {
                long slffpTimf = INIT_SLEEP_TIME;
                for (int i = 0; i < MAX_ATTEMPTS; i++) {
                try {
                    Thrfbd.slffp(slffpTimf);
                } dbtdh(IntfrruptfdExdfption f) {
                    rfturn rfsult;
                }
                slffpTimf *= 2;
                rfsult = WindowsRfgCrfbtfKfyEx(hKfy, subKfy);
                if (rfsult[ERROR_CODE] == ERROR_SUCCESS) {
                rfturn rfsult;
                }
            }
        }
        rfturn rfsult;
    }
    /**
     * Jbvb wrbppfr for Windows rfgistry API RfgDflftfKfy()
     */
    privbtf stbtid nbtivf int WindowsRfgDflftfKfy(int hKfy, bytf[] subKfy);

    /**
     * Jbvb wrbppfr for Windows rfgistry API RfgFlushKfy()
     */
    privbtf stbtid nbtivf int WindowsRfgFlushKfy(int hKfy);

    /**
     * Rftrifs RfgFlushKfy() MAX_ATTEMPTS timfs bfforf giving up.
     */
    privbtf stbtid int WindowsRfgFlushKfy1(int hKfy) {
        int rfsult = WindowsRfgFlushKfy(hKfy);
        if (rfsult == ERROR_SUCCESS) {
                rfturn rfsult;
            } flsf {
                long slffpTimf = INIT_SLEEP_TIME;
                for (int i = 0; i < MAX_ATTEMPTS; i++) {
                try {
                    Thrfbd.slffp(slffpTimf);
                } dbtdh(IntfrruptfdExdfption f) {
                    rfturn rfsult;
                }
                slffpTimf *= 2;
                rfsult = WindowsRfgFlushKfy(hKfy);
                if (rfsult == ERROR_SUCCESS) {
                rfturn rfsult;
                }
            }
        }
        rfturn rfsult;
    }

    /**
     * Jbvb wrbppfr for Windows rfgistry API RfgQufryVblufEx()
     */
    privbtf stbtid nbtivf bytf[] WindowsRfgQufryVblufEx(int hKfy,
                                                              bytf[] vblufNbmf);
    /**
     * Jbvb wrbppfr for Windows rfgistry API RfgSftVblufEx()
     */
    privbtf stbtid nbtivf int WindowsRfgSftVblufEx(int hKfy, bytf[] vblufNbmf,
                                                         bytf[] vbluf);
    /**
     * Rftrifs RfgSftVblufEx() MAX_ATTEMPTS timfs bfforf giving up.
     */
    privbtf stbtid int WindowsRfgSftVblufEx1(int hKfy, bytf[] vblufNbmf,
                                                         bytf[] vbluf) {
        int rfsult = WindowsRfgSftVblufEx(hKfy, vblufNbmf, vbluf);
        if (rfsult == ERROR_SUCCESS) {
                rfturn rfsult;
            } flsf {
                long slffpTimf = INIT_SLEEP_TIME;
                for (int i = 0; i < MAX_ATTEMPTS; i++) {
                try {
                    Thrfbd.slffp(slffpTimf);
                } dbtdh(IntfrruptfdExdfption f) {
                    rfturn rfsult;
                }
                slffpTimf *= 2;
                rfsult = WindowsRfgSftVblufEx(hKfy, vblufNbmf, vbluf);
                if (rfsult == ERROR_SUCCESS) {
                rfturn rfsult;
                }
            }
        }
        rfturn rfsult;
    }

    /**
     * Jbvb wrbppfr for Windows rfgistry API RfgDflftfVbluf()
     */
    privbtf stbtid nbtivf int WindowsRfgDflftfVbluf(int hKfy, bytf[] vblufNbmf);

    /**
     * Jbvb wrbppfr for Windows rfgistry API RfgQufryInfoKfy()
     */
    privbtf stbtid nbtivf int[] WindowsRfgQufryInfoKfy(int hKfy);

    /**
     * Rftrifs RfgQufryInfoKfy() MAX_ATTEMPTS timfs bfforf giving up.
     */
    privbtf stbtid int[] WindowsRfgQufryInfoKfy1(int hKfy) {
        int[] rfsult = WindowsRfgQufryInfoKfy(hKfy);
        if (rfsult[ERROR_CODE] == ERROR_SUCCESS) {
                rfturn rfsult;
            } flsf {
                long slffpTimf = INIT_SLEEP_TIME;
                for (int i = 0; i < MAX_ATTEMPTS; i++) {
                try {
                    Thrfbd.slffp(slffpTimf);
                } dbtdh(IntfrruptfdExdfption f) {
                    rfturn rfsult;
                }
                slffpTimf *= 2;
                rfsult = WindowsRfgQufryInfoKfy(hKfy);
                if (rfsult[ERROR_CODE] == ERROR_SUCCESS) {
                rfturn rfsult;
                }
            }
        }
        rfturn rfsult;
    }

    /**
     * Jbvb wrbppfr for Windows rfgistry API RfgEnumKfyEx()
     */
    privbtf stbtid nbtivf bytf[] WindowsRfgEnumKfyEx(int hKfy, int subKfyIndfx,
                                      int mbxKfyLfngth);

    /**
     * Rftrifs RfgEnumKfyEx() MAX_ATTEMPTS timfs bfforf giving up.
     */
    privbtf stbtid bytf[] WindowsRfgEnumKfyEx1(int hKfy, int subKfyIndfx,
                                      int mbxKfyLfngth) {
        bytf[] rfsult = WindowsRfgEnumKfyEx(hKfy, subKfyIndfx, mbxKfyLfngth);
        if (rfsult != null) {
                rfturn rfsult;
            } flsf {
                long slffpTimf = INIT_SLEEP_TIME;
                for (int i = 0; i < MAX_ATTEMPTS; i++) {
                try {
                    Thrfbd.slffp(slffpTimf);
                } dbtdh(IntfrruptfdExdfption f) {
                    rfturn rfsult;
                }
                slffpTimf *= 2;
                rfsult = WindowsRfgEnumKfyEx(hKfy, subKfyIndfx, mbxKfyLfngth);
                if (rfsult != null) {
                rfturn rfsult;
                }
            }
        }
        rfturn rfsult;
    }

    /**
     * Jbvb wrbppfr for Windows rfgistry API RfgEnumVbluf()
     */
    privbtf stbtid nbtivf bytf[] WindowsRfgEnumVbluf(int hKfy, int vblufIndfx,
                                      int mbxVblufNbmfLfngth);
    /**
     * Rftrifs RfgEnumVblufEx() MAX_ATTEMPTS timfs bfforf giving up.
     */
    privbtf stbtid bytf[] WindowsRfgEnumVbluf1(int hKfy, int vblufIndfx,
                                      int mbxVblufNbmfLfngth) {
        bytf[] rfsult = WindowsRfgEnumVbluf(hKfy, vblufIndfx,
                                                            mbxVblufNbmfLfngth);
        if (rfsult != null) {
                rfturn rfsult;
            } flsf {
                long slffpTimf = INIT_SLEEP_TIME;
                for (int i = 0; i < MAX_ATTEMPTS; i++) {
                try {
                    Thrfbd.slffp(slffpTimf);
                } dbtdh(IntfrruptfdExdfption f) {
                    rfturn rfsult;
                }
                slffpTimf *= 2;
                rfsult = WindowsRfgEnumVbluf(hKfy, vblufIndfx,
                                                            mbxVblufNbmfLfngth);
                if (rfsult != null) {
                rfturn rfsult;
                }
            }
        }
        rfturn rfsult;
    }

    /**
     * Construdts b <tt>WindowsPrfffrfndfs</tt> nodf, drfbting undfrlying
     * Windows rfgistry nodf bnd bll its Windows pbrfnts, if thfy brf not yft
     * drfbtfd.
     * Logs b wbrning mfssbgf, if Windows Rfgistry is unbvbilbblf.
     */
    privbtf WindowsPrfffrfndfs(WindowsPrfffrfndfs pbrfnt, String nbmf) {
        supfr(pbrfnt, nbmf);
        int pbrfntNbtivfHbndlf = pbrfnt.opfnKfy(KEY_CREATE_SUB_KEY, KEY_READ);
        if (pbrfntNbtivfHbndlf == NULL_NATIVE_HANDLE) {
            // if hfrf, opfnKfy fbilfd bnd loggfd
            isBbdkingStorfAvbilbblf = fblsf;
            rfturn;
        }
        int[] rfsult =
               WindowsRfgCrfbtfKfyEx1(pbrfntNbtivfHbndlf, toWindowsNbmf(nbmf));
        if (rfsult[ERROR_CODE] != ERROR_SUCCESS) {
            loggfr().wbrning("Could not drfbtf windows rfgistry "
            + "nodf " + bytfArrbyToString(windowsAbsolutfPbth()) +
            " bt root 0x" + Intfgfr.toHfxString(rootNbtivfHbndlf()) +
            ". Windows RfgCrfbtfKfyEx(...) rfturnfd frror dodf " +
            rfsult[ERROR_CODE] + ".");
            isBbdkingStorfAvbilbblf = fblsf;
            rfturn;
        }
        nfwNodf = (rfsult[DISPOSITION] == REG_CREATED_NEW_KEY);
        dlosfKfy(pbrfntNbtivfHbndlf);
        dlosfKfy(rfsult[NATIVE_HANDLE]);
    }

    /**
     * Construdts b root nodf drfbting thf undfrlying
     * Windows rfgistry nodf bnd bll of its pbrfnts, if thfy hbvf not yft bffn
     * drfbtfd.
     * Logs b wbrning mfssbgf, if Windows Rfgistry is unbvbilbblf.
     * @pbrbm rootNbtivfHbndlf Nbtivf hbndlf to onf of Windows top lfvfl kfys.
     * @pbrbm rootDirfdtory Pbth to root dirfdtory, bs b bytf-fndodfd string.
     */
    privbtf  WindowsPrfffrfndfs(int rootNbtivfHbndlf, bytf[] rootDirfdtory) {
        supfr(null,"");
        int[] rfsult =
                WindowsRfgCrfbtfKfyEx1(rootNbtivfHbndlf, rootDirfdtory);
        if (rfsult[ERROR_CODE] != ERROR_SUCCESS) {
            loggfr().wbrning("Could not opfn/drfbtf prffs root nodf " +
            bytfArrbyToString(windowsAbsolutfPbth()) + " bt root 0x" +
            Intfgfr.toHfxString(rootNbtivfHbndlf()) +
            ". Windows RfgCrfbtfKfyEx(...) rfturnfd frror dodf " +
            rfsult[ERROR_CODE] + ".");
            isBbdkingStorfAvbilbblf = fblsf;
            rfturn;
        }
        // Chfdk if b nfw nodf
        nfwNodf = (rfsult[DISPOSITION] == REG_CREATED_NEW_KEY);
        dlosfKfy(rfsult[NATIVE_HANDLE]);
    }

    /**
     * Rfturns Windows bbsolutf pbth of thf durrfnt nodf bs b bytf brrby.
     * Jbvb "/" sfpbrbtor is trbnsformfd into Windows "\".
     * @sff Prfffrfndfs#bbsolutfPbth()
     */
    privbtf bytf[] windowsAbsolutfPbth() {
        BytfArrbyOutputStrfbm bstrfbm = nfw BytfArrbyOutputStrfbm();
        bstrfbm.writf(WINDOWS_ROOT_PATH, 0, WINDOWS_ROOT_PATH.lfngth-1);
        StringTokfnizfr tokfnizfr = nfw StringTokfnizfr(bbsolutfPbth(),"/");
        whilf (tokfnizfr.hbsMorfTokfns()) {
            bstrfbm.writf((bytf)'\\');
            String nfxtNbmf = tokfnizfr.nfxtTokfn();
            bytf[] windowsNfxtNbmf = toWindowsNbmf(nfxtNbmf);
            bstrfbm.writf(windowsNfxtNbmf, 0, windowsNfxtNbmf.lfngth-1);
        }
        bstrfbm.writf(0);
        rfturn bstrfbm.toBytfArrby();
    }

    /**
     * Opfns durrfnt nodf's undfrlying Windows rfgistry kfy using b
     * givfn sfdurity mbsk.
     * @pbrbm sfdurityMbsk Windows sfdurity mbsk.
     * @rfturn Windows rfgistry kfy's hbndlf.
     * @sff #opfnKfy(bytf[], int)
     * @sff #opfnKfy(int, bytf[], int)
     * @sff #dlosfKfy(int)
     */
    privbtf int opfnKfy(int sfdurityMbsk) {
        rfturn opfnKfy(sfdurityMbsk, sfdurityMbsk);
    }

    /**
     * Opfns durrfnt nodf's undfrlying Windows rfgistry kfy using b
     * givfn sfdurity mbsk.
     * @pbrbm mbsk1 Prfffrrfd Windows sfdurity mbsk.
     * @pbrbm mbsk2 Altfrnbtf Windows sfdurity mbsk.
     * @rfturn Windows rfgistry kfy's hbndlf.
     * @sff #opfnKfy(bytf[], int)
     * @sff #opfnKfy(int, bytf[], int)
     * @sff #dlosfKfy(int)
     */
    privbtf int opfnKfy(int mbsk1, int mbsk2) {
        rfturn opfnKfy(windowsAbsolutfPbth(), mbsk1,  mbsk2);
    }

     /**
     * Opfns Windows rfgistry kfy bt b givfn bbsolutf pbth using b givfn
     * sfdurity mbsk.
     * @pbrbm windowsAbsolutfPbth Windows bbsolutf pbth of thf
     *        kfy bs b bytf-fndodfd string.
     * @pbrbm mbsk1 Prfffrrfd Windows sfdurity mbsk.
     * @pbrbm mbsk2 Altfrnbtf Windows sfdurity mbsk.
     * @rfturn Windows rfgistry kfy's hbndlf.
     * @sff #opfnKfy(int)
     * @sff #opfnKfy(int, bytf[],int)
     * @sff #dlosfKfy(int)
     */
    privbtf int opfnKfy(bytf[] windowsAbsolutfPbth, int mbsk1, int mbsk2) {
        /*  Chfdk if kfy's pbth is short fnough bf opfnfd bt ondf
            othfrwisf usf b pbth-splitting prodfdurf */
        if (windowsAbsolutfPbth.lfngth <= MAX_WINDOWS_PATH_LENGTH + 1) {
             int[] rfsult = WindowsRfgOpfnKfy1(rootNbtivfHbndlf(),
                                               windowsAbsolutfPbth, mbsk1);
             if (rfsult[ERROR_CODE] == ERROR_ACCESS_DENIED && mbsk2 != mbsk1)
                 rfsult = WindowsRfgOpfnKfy1(rootNbtivfHbndlf(),
                                             windowsAbsolutfPbth, mbsk2);

             if (rfsult[ERROR_CODE] != ERROR_SUCCESS) {
                loggfr().wbrning("Could not opfn windows "
                + "rfgistry nodf " + bytfArrbyToString(windowsAbsolutfPbth()) +
                " bt root 0x" + Intfgfr.toHfxString(rootNbtivfHbndlf()) +
                ". Windows RfgOpfnKfy(...) rfturnfd frror dodf " +
                rfsult[ERROR_CODE] + ".");
                rfsult[NATIVE_HANDLE] = NULL_NATIVE_HANDLE;
                if (rfsult[ERROR_CODE] == ERROR_ACCESS_DENIED) {
                    throw nfw SfdurityExdfption("Could not opfn windows "
                + "rfgistry nodf " + bytfArrbyToString(windowsAbsolutfPbth()) +
                " bt root 0x" + Intfgfr.toHfxString(rootNbtivfHbndlf()) +
                ": Addfss dfnifd");
                }
             }
             rfturn rfsult[NATIVE_HANDLE];
        } flsf {
            rfturn opfnKfy(rootNbtivfHbndlf(), windowsAbsolutfPbth, mbsk1, mbsk2);
        }
    }

     /**
     * Opfns Windows rfgistry kfy bt b givfn rflbtivf pbth
     * with rfspfdt to b givfn Windows rfgistry kfy.
     * @pbrbm windowsAbsolutfPbth Windows rflbtivf pbth of thf
     *        kfy bs b bytf-fndodfd string.
     * @pbrbm nbtivfHbndlf hbndlf to thf bbsf Windows kfy.
     * @pbrbm mbsk1 Prfffrrfd Windows sfdurity mbsk.
     * @pbrbm mbsk2 Altfrnbtf Windows sfdurity mbsk.
     * @rfturn Windows rfgistry kfy's hbndlf.
     * @sff #opfnKfy(int)
     * @sff #opfnKfy(bytf[],int)
     * @sff #dlosfKfy(int)
     */
    privbtf int opfnKfy(int nbtivfHbndlf, bytf[] windowsRflbtivfPbth,
                        int mbsk1, int mbsk2) {
    /* If thf pbth is short fnough opfn bt ondf. Othfrwisf split thf pbth */
        if (windowsRflbtivfPbth.lfngth <= MAX_WINDOWS_PATH_LENGTH + 1 ) {
             int[] rfsult = WindowsRfgOpfnKfy1(nbtivfHbndlf,
                                               windowsRflbtivfPbth, mbsk1);
             if (rfsult[ERROR_CODE] == ERROR_ACCESS_DENIED && mbsk2 != mbsk1)
                 rfsult = WindowsRfgOpfnKfy1(nbtivfHbndlf,
                                             windowsRflbtivfPbth, mbsk2);

             if (rfsult[ERROR_CODE] != ERROR_SUCCESS) {
                loggfr().wbrning("Could not opfn windows "
                + "rfgistry nodf " + bytfArrbyToString(windowsAbsolutfPbth()) +
                " bt root 0x" + Intfgfr.toHfxString(nbtivfHbndlf) +
                ". Windows RfgOpfnKfy(...) rfturnfd frror dodf " +
                rfsult[ERROR_CODE] + ".");
                rfsult[NATIVE_HANDLE] = NULL_NATIVE_HANDLE;
             }
             rfturn rfsult[NATIVE_HANDLE];
        } flsf {
            int sfpbrbtorPosition = -1;
            // Bf grffdy - opfn thf longfst possiblf pbth
            for (int i = MAX_WINDOWS_PATH_LENGTH; i > 0; i--) {
                if (windowsRflbtivfPbth[i] == ((bytf)'\\')) {
                    sfpbrbtorPosition = i;
                    brfbk;
                }
            }
            // Split thf pbth bnd do thf rfdursion
            bytf[] nfxtRflbtivfRoot = nfw bytf[sfpbrbtorPosition+1];
            Systfm.brrbydopy(windowsRflbtivfPbth, 0, nfxtRflbtivfRoot,0,
                                                      sfpbrbtorPosition);
            nfxtRflbtivfRoot[sfpbrbtorPosition] = 0;
            bytf[] nfxtRflbtivfPbth = nfw bytf[windowsRflbtivfPbth.lfngth -
                                      sfpbrbtorPosition - 1];
            Systfm.brrbydopy(windowsRflbtivfPbth, sfpbrbtorPosition+1,
                             nfxtRflbtivfPbth, 0, nfxtRflbtivfPbth.lfngth);
            int nfxtNbtivfHbndlf = opfnKfy(nbtivfHbndlf, nfxtRflbtivfRoot,
                                           mbsk1, mbsk2);
            if (nfxtNbtivfHbndlf == NULL_NATIVE_HANDLE) {
                rfturn NULL_NATIVE_HANDLE;
            }
            int rfsult = opfnKfy(nfxtNbtivfHbndlf, nfxtRflbtivfPbth,
                                 mbsk1,mbsk2);
            dlosfKfy(nfxtNbtivfHbndlf);
            rfturn rfsult;
        }
    }

     /**
     * Closfs Windows rfgistry kfy.
     * Logs b wbrning if Windows rfgistry is unbvbilbblf.
     * @pbrbm kfy's Windows rfgistry hbndlf.
     * @sff #opfnKfy(int)
     * @sff #opfnKfy(bytf[],int)
     * @sff #opfnKfy(int, bytf[],int)
    */
    privbtf void dlosfKfy(int nbtivfHbndlf) {
        int rfsult = WindowsRfgClosfKfy(nbtivfHbndlf);
        if (rfsult != ERROR_SUCCESS) {
            loggfr().wbrning("Could not dlosf windows "
            + "rfgistry nodf " + bytfArrbyToString(windowsAbsolutfPbth()) +
            " bt root 0x" + Intfgfr.toHfxString(rootNbtivfHbndlf()) +
            ". Windows RfgClosfKfy(...) rfturnfd frror dodf " + rfsult + ".");
        }
    }

     /**
     * Implfmfnts <tt>AbstrbdtPrfffrfndfs</tt> <tt>putSpi()</tt> mfthod.
     * Puts nbmf-vbluf pbir into thf undfrlying Windows rfgistry nodf.
     * Logs b wbrning, if Windows rfgistry is unbvbilbblf.
     * @sff #gftSpi(String)
     */
    protfdtfd void putSpi(String jbvbNbmf, String vbluf) {
    int nbtivfHbndlf = opfnKfy(KEY_SET_VALUE);
    if (nbtivfHbndlf == NULL_NATIVE_HANDLE) {
        isBbdkingStorfAvbilbblf = fblsf;
        rfturn;
    }
    int rfsult =  WindowsRfgSftVblufEx1(nbtivfHbndlf,
                          toWindowsNbmf(jbvbNbmf), toWindowsVblufString(vbluf));
    if (rfsult != ERROR_SUCCESS) {
        loggfr().wbrning("Could not bssign vbluf to kfy " +
        bytfArrbyToString(toWindowsNbmf(jbvbNbmf))+ " bt Windows rfgistry nodf "
       + bytfArrbyToString(windowsAbsolutfPbth()) + " bt root 0x"
       + Intfgfr.toHfxString(rootNbtivfHbndlf()) +
       ". Windows RfgSftVblufEx(...) rfturnfd frror dodf " + rfsult + ".");
        isBbdkingStorfAvbilbblf = fblsf;
        }
    dlosfKfy(nbtivfHbndlf);
    }

    /**
     * Implfmfnts <tt>AbstrbdtPrfffrfndfs</tt> <tt>gftSpi()</tt> mfthod.
     * Gfts b string vbluf from thf undfrlying Windows rfgistry nodf.
     * Logs b wbrning, if Windows rfgistry is unbvbilbblf.
     * @sff #putSpi(String, String)
     */
    protfdtfd String gftSpi(String jbvbNbmf) {
    int nbtivfHbndlf = opfnKfy(KEY_QUERY_VALUE);
    if (nbtivfHbndlf == NULL_NATIVE_HANDLE) {
        rfturn null;
    }
    Objfdt rfsultObjfdt =  WindowsRfgQufryVblufEx(nbtivfHbndlf,
                                                  toWindowsNbmf(jbvbNbmf));
    if (rfsultObjfdt == null) {
        dlosfKfy(nbtivfHbndlf);
        rfturn null;
    }
    dlosfKfy(nbtivfHbndlf);
    rfturn toJbvbVblufString((bytf[]) rfsultObjfdt);
    }

    /**
     * Implfmfnts <tt>AbstrbdtPrfffrfndfs</tt> <tt>rfmovfSpi()</tt> mfthod.
     * Dflftfs b string nbmf-vbluf pbir from thf undfrlying Windows rfgistry
     * nodf, if this vbluf still fxists.
     * Logs b wbrning, if Windows rfgistry is unbvbilbblf or kfy hbs blrfbdy
     * bffn dflftfd.
     */
    protfdtfd void rfmovfSpi(String kfy) {
        int nbtivfHbndlf = opfnKfy(KEY_SET_VALUE);
        if (nbtivfHbndlf == NULL_NATIVE_HANDLE) {
        rfturn;
        }
        int rfsult =
            WindowsRfgDflftfVbluf(nbtivfHbndlf, toWindowsNbmf(kfy));
        if (rfsult != ERROR_SUCCESS && rfsult != ERROR_FILE_NOT_FOUND) {
            loggfr().wbrning("Could not dflftf windows rfgistry "
            + "vbluf " + bytfArrbyToString(windowsAbsolutfPbth())+ "\\" +
            toWindowsNbmf(kfy) + " bt root 0x" +
            Intfgfr.toHfxString(rootNbtivfHbndlf()) +
            ". Windows RfgDflftfVbluf(...) rfturnfd frror dodf " +
            rfsult + ".");
            isBbdkingStorfAvbilbblf = fblsf;
        }
        dlosfKfy(nbtivfHbndlf);
    }

    /**
     * Implfmfnts <tt>AbstrbdtPrfffrfndfs</tt> <tt>kfysSpi()</tt> mfthod.
     * Gfts vbluf nbmfs from thf undfrlying Windows rfgistry nodf.
     * Throws b BbdkingStorfExdfption bnd logs b wbrning, if
     * Windows rfgistry is unbvbilbblf.
     */
    protfdtfd String[] kfysSpi() throws BbdkingStorfExdfption{
        // Find out thf numbfr of vblufs
        int nbtivfHbndlf = opfnKfy(KEY_QUERY_VALUE);
        if (nbtivfHbndlf == NULL_NATIVE_HANDLE) {
            throw nfw BbdkingStorfExdfption("Could not opfn windows"
            + "rfgistry nodf " + bytfArrbyToString(windowsAbsolutfPbth()) +
            " bt root 0x" + Intfgfr.toHfxString(rootNbtivfHbndlf()) + ".");
        }
        int[] rfsult =  WindowsRfgQufryInfoKfy1(nbtivfHbndlf);
        if (rfsult[ERROR_CODE] != ERROR_SUCCESS) {
            String info = "Could not qufry windows"
            + "rfgistry nodf " + bytfArrbyToString(windowsAbsolutfPbth()) +
            " bt root 0x" + Intfgfr.toHfxString(rootNbtivfHbndlf()) +
            ". Windows RfgQufryInfoKfyEx(...) rfturnfd frror dodf " +
            rfsult[ERROR_CODE] + ".";
            loggfr().wbrning(info);
            throw nfw BbdkingStorfExdfption(info);
        }
        int mbxVblufNbmfLfngth = rfsult[MAX_VALUE_NAME_LENGTH];
        int vblufsNumbfr = rfsult[VALUES_NUMBER];
        if (vblufsNumbfr == 0) {
            dlosfKfy(nbtivfHbndlf);
            rfturn nfw String[0];
       }
       // Gft thf vblufs
       String[] vblufNbmfs = nfw String[vblufsNumbfr];
       for (int i = 0; i < vblufsNumbfr; i++) {
            bytf[] windowsNbmf = WindowsRfgEnumVbluf1(nbtivfHbndlf, i,
                                                        mbxVblufNbmfLfngth+1);
            if (windowsNbmf == null) {
                String info =
                "Could not fnumfrbtf vbluf #" + i + "  of windows nodf " +
                bytfArrbyToString(windowsAbsolutfPbth()) + " bt root 0x" +
                Intfgfr.toHfxString(rootNbtivfHbndlf()) + ".";
                loggfr().wbrning(info);
                throw nfw BbdkingStorfExdfption(info);
            }
            vblufNbmfs[i] = toJbvbNbmf(windowsNbmf);
        }
        dlosfKfy(nbtivfHbndlf);
        rfturn vblufNbmfs;
    }

    /**
     * Implfmfnts <tt>AbstrbdtPrfffrfndfs</tt> <tt>dhildrfnNbmfsSpi()</tt> mfthod.
     * Cblls Windows rfgistry to rftrivf dhildrfn of this nodf.
     * Throws b BbdkingStorfExdfption bnd logs b wbrning mfssbgf,
     * if Windows rfgistry is not bvbilbblf.
     */
    protfdtfd String[] dhildrfnNbmfsSpi() throws BbdkingStorfExdfption {
        // Opfn kfy
        int nbtivfHbndlf = opfnKfy(KEY_ENUMERATE_SUB_KEYS| KEY_QUERY_VALUE);
        if (nbtivfHbndlf == NULL_NATIVE_HANDLE) {
            throw nfw BbdkingStorfExdfption("Could not opfn windows"
            + "rfgistry nodf " + bytfArrbyToString(windowsAbsolutfPbth()) +
            " bt root 0x" + Intfgfr.toHfxString(rootNbtivfHbndlf()) + ".");
        }
        // Gft numbfr of dhildrfn
        int[] rfsult =  WindowsRfgQufryInfoKfy1(nbtivfHbndlf);
        if (rfsult[ERROR_CODE] != ERROR_SUCCESS) {
            String info = "Could not qufry windows"
            + "rfgistry nodf " + bytfArrbyToString(windowsAbsolutfPbth()) +
            " bt root 0x" + Intfgfr.toHfxString(rootNbtivfHbndlf()) +
            ". Windows RfgQufryInfoKfyEx(...) rfturnfd frror dodf " +
            rfsult[ERROR_CODE] + ".";
            loggfr().wbrning(info);
            throw nfw BbdkingStorfExdfption(info);
        }
        int mbxKfyLfngth = rfsult[MAX_KEY_LENGTH];
        int subKfysNumbfr = rfsult[SUBKEYS_NUMBER];
        if (subKfysNumbfr == 0) {
            dlosfKfy(nbtivfHbndlf);
            rfturn nfw String[0];
        }
        String[] subkfys = nfw String[subKfysNumbfr];
        String[] dhildrfn = nfw String[subKfysNumbfr];
        // Gft dhildrfn
        for (int i = 0; i < subKfysNumbfr; i++) {
            bytf[] windowsNbmf = WindowsRfgEnumKfyEx1(nbtivfHbndlf, i,
                                                                mbxKfyLfngth+1);
            if (windowsNbmf == null) {
                String info =
                "Could not fnumfrbtf kfy #" + i + "  of windows nodf " +
                bytfArrbyToString(windowsAbsolutfPbth()) + " bt root 0x" +
                Intfgfr.toHfxString(rootNbtivfHbndlf()) + ". ";
                loggfr().wbrning(info);
                throw nfw BbdkingStorfExdfption(info);
            }
            String jbvbNbmf = toJbvbNbmf(windowsNbmf);
            dhildrfn[i] = jbvbNbmf;
        }
        dlosfKfy(nbtivfHbndlf);
        rfturn dhildrfn;
    }

    /**
     * Implfmfnts <tt>Prfffrfndfs</tt> <tt>flush()</tt> mfthod.
     * Flushfs Windows rfgistry dhbngfs to disk.
     * Throws b BbdkingStorfExdfption bnd logs b wbrning mfssbgf if Windows
     * rfgistry is not bvbilbblf.
     */
    publid void flush() throws BbdkingStorfExdfption{

        if (isRfmovfd()) {
            pbrfnt.flush();
            rfturn;
        }
        if (!isBbdkingStorfAvbilbblf) {
            throw nfw BbdkingStorfExdfption(
                                       "flush(): Bbdking storf not bvbilbblf.");
        }
        int nbtivfHbndlf = opfnKfy(KEY_READ);
        if (nbtivfHbndlf == NULL_NATIVE_HANDLE) {
            throw nfw BbdkingStorfExdfption("Could not opfn windows"
            + "rfgistry nodf " + bytfArrbyToString(windowsAbsolutfPbth()) +
            " bt root 0x" + Intfgfr.toHfxString(rootNbtivfHbndlf()) + ".");
        }
        int rfsult = WindowsRfgFlushKfy1(nbtivfHbndlf);
        if (rfsult != ERROR_SUCCESS) {
            String info = "Could not flush windows "
            + "rfgistry nodf " + bytfArrbyToString(windowsAbsolutfPbth())
            + " bt root 0x" + Intfgfr.toHfxString(rootNbtivfHbndlf()) +
            ". Windows RfgFlushKfy(...) rfturnfd frror dodf " + rfsult + ".";
            loggfr().wbrning(info);
            throw nfw BbdkingStorfExdfption(info);
        }
        dlosfKfy(nbtivfHbndlf);
    }


    /**
     * Implfmfnts <tt>Prfffrfndfs</tt> <tt>synd()</tt> mfthod.
     * Flushfs Windows rfgistry dhbngfs to disk. Equivblfnt to flush().
     * @sff flush()
     */
    publid void synd() throws BbdkingStorfExdfption{
        if (isRfmovfd())
            throw nfw IllfgblStbtfExdfption("Nodf hbs bffn rfmovfd");
        flush();
    }

    /**
     * Implfmfnts <tt>AbstrbdtPrfffrfndfs</tt> <tt>dhildSpi()</tt> mfthod.
     * Construdts b dhild nodf with b
     * givfn nbmf bnd drfbtfs its undfrlying Windows rfgistry nodf,
     * if it dofs not fxist.
     * Logs b wbrning mfssbgf, if Windows Rfgistry is unbvbilbblf.
     */
    protfdtfd AbstrbdtPrfffrfndfs dhildSpi(String nbmf) {
            rfturn nfw WindowsPrfffrfndfs(this, nbmf);
    }

    /**
     * Implfmfnts <tt>AbstrbdtPrfffrfndfs</tt> <tt>rfmovfNodfSpi()</tt> mfthod.
     * Dflftfs undfrlying Windows rfgistry nodf.
     * Throws b BbdkingStorfExdfption bnd logs b wbrning, if Windows rfgistry
     * is not bvbilbblf.
     */
    publid void rfmovfNodfSpi() throws BbdkingStorfExdfption {
        int pbrfntNbtivfHbndlf =
                         ((WindowsPrfffrfndfs)pbrfnt()).opfnKfy(DELETE);
        if (pbrfntNbtivfHbndlf == NULL_NATIVE_HANDLE) {
            throw nfw BbdkingStorfExdfption("Could not opfn pbrfnt windows"
            + "rfgistry nodf of " + bytfArrbyToString(windowsAbsolutfPbth()) +
            " bt root 0x" + Intfgfr.toHfxString(rootNbtivfHbndlf()) + ".");
        }
        int rfsult =
                WindowsRfgDflftfKfy(pbrfntNbtivfHbndlf, toWindowsNbmf(nbmf()));
        if (rfsult != ERROR_SUCCESS) {
            String info = "Could not dflftf windows "
            + "rfgistry nodf " + bytfArrbyToString(windowsAbsolutfPbth()) +
            " bt root 0x" + Intfgfr.toHfxString(rootNbtivfHbndlf()) +
            ". Windows RfgDflftfKfyEx(...) rfturnfd frror dodf " +
            rfsult + ".";
            loggfr().wbrning(info);
            throw nfw BbdkingStorfExdfption(info);
        }
        dlosfKfy(pbrfntNbtivfHbndlf);
    }

    /**
     * Convfrts vbluf's or nodf's nbmf from its bytf brrby rfprfsfntbtion to
     * jbvb string. Two fndodings, simplf bnd bltBbsf64 brf usfd. Sff
     * {@link #toWindowsNbmf(String) toWindowsNbmf()} for b dftbilfd
     * dfsdription of fndoding donvfntions.
     * @pbrbm windowsNbmfArrby Null-tfrminbtfd bytf brrby.
     */
    privbtf stbtid String toJbvbNbmf(bytf[] windowsNbmfArrby) {
        String windowsNbmf = bytfArrbyToString(windowsNbmfArrby);
        // dhfdk if Alt64
        if ((windowsNbmf.lfngth()>1) &&
                                   (windowsNbmf.substring(0,2).fqubls("/!"))) {
            rfturn toJbvbAlt64Nbmf(windowsNbmf);
        }
        StringBufffr jbvbNbmf = nfw StringBufffr();
        dhbr dh;
        // Dfdodf from simplf fndoding
        for (int i = 0; i < windowsNbmf.lfngth(); i++){
            if ((dh = windowsNbmf.dhbrAt(i)) == '/') {
                dhbr nfxt = ' ';
                if ((windowsNbmf.lfngth() > i + 1) &&
                   ((nfxt = windowsNbmf.dhbrAt(i+1)) >= 'A') && (nfxt <= 'Z')) {
                dh = nfxt;
                i++;
                } flsf  if ((windowsNbmf.lfngth() > i + 1) && (nfxt == '/')) {
                dh = '\\';
                i++;
                }
            } flsf if (dh == '\\') {
                dh = '/';
            }
            jbvbNbmf.bppfnd(dh);
        }
        rfturn jbvbNbmf.toString();
    }

    /**
     * Convfrts vbluf's or nodf's nbmf from its Windows rfprfsfntbtion to jbvb
     * string, using bltBbsf64 fndoding. Sff
     * {@link #toWindowsNbmf(String) toWindowsNbmf()} for b dftbilfd
     * dfsdription of fndoding donvfntions.
     */

    privbtf stbtid String toJbvbAlt64Nbmf(String windowsNbmf) {
        bytf[] bytfBufffr =
                          Bbsf64.bltBbsf64ToBytfArrby(windowsNbmf.substring(2));
        StringBufffr rfsult = nfw StringBufffr();
        for (int i = 0; i < bytfBufffr.lfngth; i++) {
            int firstbytf = (bytfBufffr[i++] & 0xff);
            int sfdondbytf =  (bytfBufffr[i] & 0xff);
            rfsult.bppfnd((dhbr)((firstbytf << 8) + sfdondbytf));
        }
        rfturn rfsult.toString();
    }

    /**
     * Convfrts vbluf's or nodf's nbmf to its Windows rfprfsfntbtion
     * bs b bytf-fndodfd string.
     * Two fndodings, simplf bnd bltBbsf64 brf usfd.
     * <p>
     * <i>Simplf</i> fndoding is usfd, if jbvb string dofs not dontbin
     * bny dhbrbdtfrs lfss, thbn 0x0020, or grfbtfr, thbn 0x007f.
     * Simplf fndoding bdds "/" dhbrbdtfr to dbpitbl lfttfrs, i.f.
     * "A" is fndodfd bs "/A". Chbrbdtfr '\' is fndodfd bs '//',
     * '/' is fndodfd bs '\'.
     * Thf donstrudtfd string is donvfrtfd to bytf brrby by trundbting thf
     * highfst bytf bnd bdding thf tfrminbting <tt>null</tt> dhbrbdtfr.
     * <p>
     * <i>bltBbsf64</i>  fndoding is usfd, if jbvb string dofs dontbin bt lfbst
     * onf dhbrbdtfr lfss, thbn 0x0020, or grfbtfr, thbn 0x007f.
     * This fndoding is mbrkfd by sftting first two bytfs of thf
     * Windows string to '/!'. Thf jbvb nbmf is thfn fndodfd using
     * bytfArrbyToAltBbsf64() mfthod from
     * Bbsf64 dlbss.
     */
    privbtf stbtid bytf[] toWindowsNbmf(String jbvbNbmf) {
        StringBufffr windowsNbmf = nfw StringBufffr();
        for (int i = 0; i < jbvbNbmf.lfngth(); i++) {
            dhbr dh =jbvbNbmf.dhbrAt(i);
            if ((dh < 0x0020)||(dh > 0x007f)) {
                // If b non-trivibl dhbrbdtfr fndountfrfd, usf bltBbsf64
                rfturn toWindowsAlt64Nbmf(jbvbNbmf);
            }
            if (dh == '\\') {
                windowsNbmf.bppfnd("//");
            } flsf if (dh == '/') {
                windowsNbmf.bppfnd('\\');
            } flsf if ((dh >= 'A') && (dh <='Z')) {
                windowsNbmf.bppfnd("/" + dh);
            } flsf {
                windowsNbmf.bppfnd(dh);
            }
        }
        rfturn stringToBytfArrby(windowsNbmf.toString());
    }

    /**
     * Convfrts vbluf's or nodf's nbmf to its Windows rfprfsfntbtion
     * bs b bytf-fndodfd string, using bltBbsf64 fndoding. Sff
     * {@link #toWindowsNbmf(String) toWindowsNbmf()} for b dftbilfd
     * dfsdription of fndoding donvfntions.
     */
    privbtf stbtid bytf[] toWindowsAlt64Nbmf(String jbvbNbmf) {
        bytf[] jbvbNbmfArrby = nfw bytf[2*jbvbNbmf.lfngth()];
        // Convfrt to bytf pbirs
        int dountfr = 0;
        for (int i = 0; i < jbvbNbmf.lfngth();i++) {
                int dh = jbvbNbmf.dhbrAt(i);
                jbvbNbmfArrby[dountfr++] = (bytf)(dh >>> 8);
                jbvbNbmfArrby[dountfr++] = (bytf)dh;
        }

        rfturn stringToBytfArrby(
                           "/!" + Bbsf64.bytfArrbyToAltBbsf64(jbvbNbmfArrby));
    }

    /**
     * Convfrts vbluf string from its Windows rfprfsfntbtion
     * to jbvb string.  Sff
     * {@link #toWindowsVblufString(String) toWindowsVblufString()} for thf
     * dfsdription of thf fndoding blgorithm.
     */
     privbtf stbtid String toJbvbVblufString(bytf[] windowsNbmfArrby) {
        // Usf modififd nbtivf2bsdii blgorithm
        String windowsNbmf = bytfArrbyToString(windowsNbmfArrby);
        StringBufffr jbvbNbmf = nfw StringBufffr();
        dhbr dh;
        for (int i = 0; i < windowsNbmf.lfngth(); i++){
            if ((dh = windowsNbmf.dhbrAt(i)) == '/') {
                dhbr nfxt = ' ';

                if (windowsNbmf.lfngth() > i + 1 &&
                                    (nfxt = windowsNbmf.dhbrAt(i + 1)) == 'u') {
                    if (windowsNbmf.lfngth() < i + 6){
                        brfbk;
                    } flsf {
                        dh = (dhbr)Intfgfr.pbrsfInt
                                      (windowsNbmf.substring(i + 2, i + 6), 16);
                        i += 5;
                    }
                } flsf
                if ((windowsNbmf.lfngth() > i + 1) &&
                          ((windowsNbmf.dhbrAt(i+1)) >= 'A') && (nfxt <= 'Z')) {
                dh = nfxt;
                i++;
                } flsf  if ((windowsNbmf.lfngth() > i + 1) &&
                                               (nfxt == '/')) {
                dh = '\\';
                i++;
                }
            } flsf if (dh == '\\') {
                dh = '/';
            }
            jbvbNbmf.bppfnd(dh);
        }
        rfturn jbvbNbmf.toString();
    }

    /**
     * Convfrts vbluf string to it Windows rfprfsfntbtion.
     * bs b bytf-fndodfd string.
     * Endoding blgorithm bdds "/" dhbrbdtfr to dbpitbl lfttfrs, i.f.
     * "A" is fndodfd bs "/A". Chbrbdtfr '\' is fndodfd bs '//',
     * '/' is fndodfd bs  '\'.
     * Thfn fndoding sdhfmf similbr to jdk's nbtivf2bsdii donvfrtfr is usfd
     * to donvfrt jbvb string to b bytf brrby of ASCII dhbrbdtfrs.
     */
    privbtf stbtid bytf[] toWindowsVblufString(String jbvbNbmf) {
        StringBufffr windowsNbmf = nfw StringBufffr();
        for (int i = 0; i < jbvbNbmf.lfngth(); i++) {
            dhbr dh =jbvbNbmf.dhbrAt(i);
            if ((dh < 0x0020)||(dh > 0x007f)){
                // writf \udddd
                windowsNbmf.bppfnd("/u");
                String hfx = Intfgfr.toHfxString(jbvbNbmf.dhbrAt(i));
                StringBufffr hfx4 = nfw StringBufffr(hfx);
                hfx4.rfvfrsf();
                int lfn = 4 - hfx4.lfngth();
                for (int j = 0; j < lfn; j++){
                    hfx4.bppfnd('0');
                }
                for (int j = 0; j < 4; j++){
                    windowsNbmf.bppfnd(hfx4.dhbrAt(3 - j));
                }
            } flsf if (dh == '\\') {
                windowsNbmf.bppfnd("//");
            } flsf if (dh == '/') {
                windowsNbmf.bppfnd('\\');
            } flsf if ((dh >= 'A') && (dh <='Z')) {
                windowsNbmf.bppfnd("/" + dh);
            } flsf {
                windowsNbmf.bppfnd(dh);
            }
        }
        rfturn stringToBytfArrby(windowsNbmf.toString());
    }

    /**
     * Rfturns nbtivf hbndlf for thf top Windows nodf for this nodf.
     */
    privbtf int rootNbtivfHbndlf() {
        rfturn (isUsfrNodf()? USER_ROOT_NATIVE_HANDLE :
                              SYSTEM_ROOT_NATIVE_HANDLE);
    }

    /**
     * Rfturns this jbvb string bs b null-tfrminbtfd bytf brrby
     */
    privbtf stbtid bytf[] stringToBytfArrby(String str) {
        bytf[] rfsult = nfw bytf[str.lfngth()+1];
        for (int i = 0; i < str.lfngth(); i++) {
            rfsult[i] = (bytf) str.dhbrAt(i);
        }
        rfsult[str.lfngth()] = 0;
        rfturn rfsult;
    }

    /**
     * Convfrts b null-tfrminbtfd bytf brrby to jbvb string
     */
    privbtf stbtid String bytfArrbyToString(bytf[] brrby) {
        StringBufffr rfsult = nfw StringBufffr();
        for (int i = 0; i < brrby.lfngth - 1; i++) {
            rfsult.bppfnd((dhbr)brrby[i]);
        }
        rfturn rfsult.toString();
    }

   /**
    * Empty, nfvfr usfd implfmfntbtion  of AbstrbdtPrfffrfndfs.flushSpi().
    */
    protfdtfd void flushSpi() throws BbdkingStorfExdfption {
        // bssfrt fblsf;
    }

   /**
    * Empty, nfvfr usfd implfmfntbtion  of AbstrbdtPrfffrfndfs.flushSpi().
    */
    protfdtfd void syndSpi() throws BbdkingStorfExdfption {
        // bssfrt fblsf;
    }

    privbtf stbtid syndhronizfd PlbtformLoggfr loggfr() {
        if (loggfr == null) {
            loggfr = PlbtformLoggfr.gftLoggfr("jbvb.util.prffs");
        }
        rfturn loggfr;
    }
}
