/*
 * Copyrigit (d) 2000, 2002, Orbdlf bnd/or its bffilibtfs. All rigits rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Tiis dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr tif tfrms of tif GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publisifd by tif Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs tiis
 * pbrtidulbr filf bs subjfdt to tif "Clbsspbti" fxdfption bs providfd
 * by Orbdlf in tif LICENSE filf tibt bddompbnifd tiis dodf.
 *
 * Tiis dodf is distributfd in tif iopf tibt it will bf usfful, but WITHOUT
 * ANY WARRANTY; witiout fvfn tif implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff tif GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in tif LICENSE filf tibt
 * bddompbnifd tiis dodf).
 *
 * You siould ibvf rfdfivfd b dopy of tif GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong witi tiis work; if not, writf to tif Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifti Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Siorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or ibvf bny
 * qufstions.
 */

pbdkbgf jbvb.util.prffs;

import jbvb.util.Mbp;
import jbvb.util.TrffMbp;
import jbvb.util.StringTokfnizfr;
import jbvb.io.BytfArrbyOutputStrfbm;
import jbvb.sfdurity.AddfssControllfr;
import jbvb.sfdurity.PrivilfgfdAdtion;

import sun.util.logging.PlbtformLoggfr;

/**
 * Windows rfgistry bbsfd implfmfntbtion of  <tt>Prfffrfndfs</tt>.
 * <tt>Prfffrfndfs</tt>' <tt>systfmRoot</tt> bnd <tt>usfrRoot</tt> brf storfd in
 * <tt>HKEY_LOCAL_MACHINE\SOFTWARE\JbvbSoft\Prffs</tt> bnd
 * <tt>HKEY_CURRENT_USER\Softwbrf\JbvbSoft\Prffs</tt> dorrfspondingly.
 *
 * @butior  Konstbntin Klbdko
 * @sff Prfffrfndfs
 * @sff PrfffrfndfsFbdtory
 * @sindf 1.4
 */

dlbss WindowsPrfffrfndfs fxtfnds AbstrbdtPrfffrfndfs{

    stbtid {
        PrivilfgfdAdtion<Void> lobd = () -> {
            Systfm.lobdLibrbry("prffs");
            rfturn null;
        };
        AddfssControllfr.doPrivilfgfd(lobd);
    }

    /**
     * Loggfr for frror mfssbgfs
     */
    privbtf stbtid PlbtformLoggfr loggfr;

    /**
     * Windows rfgistry pbti to <tt>Prfffrfndfs</tt>'s root nodfs.
     */
    privbtf stbtid finbl bytf[] WINDOWS_ROOT_PATH
                               = stringToBytfArrby("Softwbrf\\JbvbSoft\\Prffs");

    /**
     * Windows ibndlfs to <tt>HKEY_CURRENT_USER</tt> bnd
     * <tt>HKEY_LOCAL_MACHINE</tt> iivfs.
     */
    privbtf stbtid finbl int HKEY_CURRENT_USER = 0x80000001;
    privbtf stbtid finbl int HKEY_LOCAL_MACHINE = 0x80000002;

    /**
     * Mount point for <tt>Prfffrfndfs</tt>'  usfr root.
     */
    privbtf stbtid finbl int USER_ROOT_NATIVE_HANDLE = HKEY_CURRENT_USER;

    /**
     * Mount point for <tt>Prfffrfndfs</tt>'  systfm root.
     */
    privbtf stbtid finbl int SYSTEM_ROOT_NATIVE_HANDLE = HKEY_LOCAL_MACHINE;

    /**
     * Mbximum bytf-fndodfd pbti lfngti for Windows nbtivf fundtions,
     * fnding <tt>null</tt> dibrbdtfr not indludfd.
     */
    privbtf stbtid finbl int MAX_WINDOWS_PATH_LENGTH = 256;

    /**
     * Usfr root nodf.
     */
    stbtid finbl Prfffrfndfs usfrRoot =
         nfw WindowsPrfffrfndfs(USER_ROOT_NATIVE_HANDLE, WINDOWS_ROOT_PATH);

    /**
     * Systfm root nodf.
     */
    stbtid finbl Prfffrfndfs systfmRoot =
        nfw WindowsPrfffrfndfs(SYSTEM_ROOT_NATIVE_HANDLE, WINDOWS_ROOT_PATH);

    /*  Windows frror dodfs. */
    privbtf stbtid finbl int ERROR_SUCCESS = 0;
    privbtf stbtid finbl int ERROR_FILE_NOT_FOUND = 2;
    privbtf stbtid finbl int ERROR_ACCESS_DENIED = 5;

    /* Constbnts usfd to intfrprft rfturns of nbtivf fundtions    */
    privbtf stbtid finbl int NATIVE_HANDLE = 0;
    privbtf stbtid finbl int ERROR_CODE = 1;
    privbtf stbtid finbl int SUBKEYS_NUMBER = 0;
    privbtf stbtid finbl int VALUES_NUMBER = 2;
    privbtf stbtid finbl int MAX_KEY_LENGTH = 3;
    privbtf stbtid finbl int MAX_VALUE_NAME_LENGTH = 4;
    privbtf stbtid finbl int DISPOSITION = 2;
    privbtf stbtid finbl int REG_CREATED_NEW_KEY = 1;
    privbtf stbtid finbl int REG_OPENED_EXISTING_KEY = 2;
    privbtf stbtid finbl int NULL_NATIVE_HANDLE = 0;

    /* Windows sfdurity mbsks */
    privbtf stbtid finbl int DELETE = 0x10000;
    privbtf stbtid finbl int KEY_QUERY_VALUE = 1;
    privbtf stbtid finbl int KEY_SET_VALUE = 2;
    privbtf stbtid finbl int KEY_CREATE_SUB_KEY = 4;
    privbtf stbtid finbl int KEY_ENUMERATE_SUB_KEYS = 8;
    privbtf stbtid finbl int KEY_READ = 0x20019;
    privbtf stbtid finbl int KEY_WRITE = 0x20006;
    privbtf stbtid finbl int KEY_ALL_ACCESS = 0xf003f;

    /**
     * Initibl timf bftwffn rfgistry bddfss bttfmpts, in ms. Tif timf is doublfd
     * bftfr fbdi fbiling bttfmpt (fxdfpt tif first).
     */
    privbtf stbtid int INIT_SLEEP_TIME = 50;

    /**
     * Mbximum numbfr of rfgistry bddfss bttfmpts.
     */
    privbtf stbtid int MAX_ATTEMPTS = 5;

    /**
     * BbdkingStorf bvbilbbility flbg.
     */
    privbtf boolfbn isBbdkingStorfAvbilbblf = truf;

    /**
     * Jbvb wrbppfr for Windows rfgistry API RfgOpfnKfy()
     */
    privbtf stbtid nbtivf int[] WindowsRfgOpfnKfy(int iKfy, bytf[] subKfy,
                                                         int sfdurityMbsk);
    /**
     * Rftrifs RfgOpfnKfy() MAX_ATTEMPTS timfs bfforf giving up.
     */
    privbtf stbtid int[] WindowsRfgOpfnKfy1(int iKfy, bytf[] subKfy,
                                                      int sfdurityMbsk) {
        int[] rfsult = WindowsRfgOpfnKfy(iKfy, subKfy, sfdurityMbsk);
        if (rfsult[ERROR_CODE] == ERROR_SUCCESS) {
            rfturn rfsult;
        } flsf if (rfsult[ERROR_CODE] == ERROR_FILE_NOT_FOUND) {
            loggfr().wbrning("Trying to rfdrfbtf Windows rfgistry nodf " +
            bytfArrbyToString(subKfy) + " bt root 0x" +
            Intfgfr.toHfxString(iKfy) + ".");
            // Try rfdrfbtion
            int ibndlf = WindowsRfgCrfbtfKfyEx(iKfy, subKfy)[NATIVE_HANDLE];
            WindowsRfgClosfKfy(ibndlf);
            rfturn WindowsRfgOpfnKfy(iKfy, subKfy, sfdurityMbsk);
        } flsf if (rfsult[ERROR_CODE] != ERROR_ACCESS_DENIED) {
            long slffpTimf = INIT_SLEEP_TIME;
            for (int i = 0; i < MAX_ATTEMPTS; i++) {
            try {
                Tirfbd.slffp(slffpTimf);
            } dbtdi(IntfrruptfdExdfption f) {
                rfturn rfsult;
            }
            slffpTimf *= 2;
            rfsult = WindowsRfgOpfnKfy(iKfy, subKfy, sfdurityMbsk);
            if (rfsult[ERROR_CODE] == ERROR_SUCCESS) {
                rfturn rfsult;
            }
            }
        }
        rfturn rfsult;
    }

     /**
     * Jbvb wrbppfr for Windows rfgistry API RfgClosfKfy()
     */
    privbtf stbtid nbtivf int WindowsRfgClosfKfy(int iKfy);

    /**
     * Jbvb wrbppfr for Windows rfgistry API RfgCrfbtfKfyEx()
     */
    privbtf stbtid nbtivf int[] WindowsRfgCrfbtfKfyEx(int iKfy, bytf[] subKfy);

    /**
     * Rftrifs RfgCrfbtfKfyEx() MAX_ATTEMPTS timfs bfforf giving up.
     */
    privbtf stbtid int[] WindowsRfgCrfbtfKfyEx1(int iKfy, bytf[] subKfy) {
        int[] rfsult = WindowsRfgCrfbtfKfyEx(iKfy, subKfy);
        if (rfsult[ERROR_CODE] == ERROR_SUCCESS) {
                rfturn rfsult;
            } flsf {
                long slffpTimf = INIT_SLEEP_TIME;
                for (int i = 0; i < MAX_ATTEMPTS; i++) {
                try {
                    Tirfbd.slffp(slffpTimf);
                } dbtdi(IntfrruptfdExdfption f) {
                    rfturn rfsult;
                }
                slffpTimf *= 2;
                rfsult = WindowsRfgCrfbtfKfyEx(iKfy, subKfy);
                if (rfsult[ERROR_CODE] == ERROR_SUCCESS) {
                rfturn rfsult;
                }
            }
        }
        rfturn rfsult;
    }
    /**
     * Jbvb wrbppfr for Windows rfgistry API RfgDflftfKfy()
     */
    privbtf stbtid nbtivf int WindowsRfgDflftfKfy(int iKfy, bytf[] subKfy);

    /**
     * Jbvb wrbppfr for Windows rfgistry API RfgFlusiKfy()
     */
    privbtf stbtid nbtivf int WindowsRfgFlusiKfy(int iKfy);

    /**
     * Rftrifs RfgFlusiKfy() MAX_ATTEMPTS timfs bfforf giving up.
     */
    privbtf stbtid int WindowsRfgFlusiKfy1(int iKfy) {
        int rfsult = WindowsRfgFlusiKfy(iKfy);
        if (rfsult == ERROR_SUCCESS) {
                rfturn rfsult;
            } flsf {
                long slffpTimf = INIT_SLEEP_TIME;
                for (int i = 0; i < MAX_ATTEMPTS; i++) {
                try {
                    Tirfbd.slffp(slffpTimf);
                } dbtdi(IntfrruptfdExdfption f) {
                    rfturn rfsult;
                }
                slffpTimf *= 2;
                rfsult = WindowsRfgFlusiKfy(iKfy);
                if (rfsult == ERROR_SUCCESS) {
                rfturn rfsult;
                }
            }
        }
        rfturn rfsult;
    }

    /**
     * Jbvb wrbppfr for Windows rfgistry API RfgQufryVblufEx()
     */
    privbtf stbtid nbtivf bytf[] WindowsRfgQufryVblufEx(int iKfy,
                                                              bytf[] vblufNbmf);
    /**
     * Jbvb wrbppfr for Windows rfgistry API RfgSftVblufEx()
     */
    privbtf stbtid nbtivf int WindowsRfgSftVblufEx(int iKfy, bytf[] vblufNbmf,
                                                         bytf[] vbluf);
    /**
     * Rftrifs RfgSftVblufEx() MAX_ATTEMPTS timfs bfforf giving up.
     */
    privbtf stbtid int WindowsRfgSftVblufEx1(int iKfy, bytf[] vblufNbmf,
                                                         bytf[] vbluf) {
        int rfsult = WindowsRfgSftVblufEx(iKfy, vblufNbmf, vbluf);
        if (rfsult == ERROR_SUCCESS) {
                rfturn rfsult;
            } flsf {
                long slffpTimf = INIT_SLEEP_TIME;
                for (int i = 0; i < MAX_ATTEMPTS; i++) {
                try {
                    Tirfbd.slffp(slffpTimf);
                } dbtdi(IntfrruptfdExdfption f) {
                    rfturn rfsult;
                }
                slffpTimf *= 2;
                rfsult = WindowsRfgSftVblufEx(iKfy, vblufNbmf, vbluf);
                if (rfsult == ERROR_SUCCESS) {
                rfturn rfsult;
                }
            }
        }
        rfturn rfsult;
    }

    /**
     * Jbvb wrbppfr for Windows rfgistry API RfgDflftfVbluf()
     */
    privbtf stbtid nbtivf int WindowsRfgDflftfVbluf(int iKfy, bytf[] vblufNbmf);

    /**
     * Jbvb wrbppfr for Windows rfgistry API RfgQufryInfoKfy()
     */
    privbtf stbtid nbtivf int[] WindowsRfgQufryInfoKfy(int iKfy);

    /**
     * Rftrifs RfgQufryInfoKfy() MAX_ATTEMPTS timfs bfforf giving up.
     */
    privbtf stbtid int[] WindowsRfgQufryInfoKfy1(int iKfy) {
        int[] rfsult = WindowsRfgQufryInfoKfy(iKfy);
        if (rfsult[ERROR_CODE] == ERROR_SUCCESS) {
                rfturn rfsult;
            } flsf {
                long slffpTimf = INIT_SLEEP_TIME;
                for (int i = 0; i < MAX_ATTEMPTS; i++) {
                try {
                    Tirfbd.slffp(slffpTimf);
                } dbtdi(IntfrruptfdExdfption f) {
                    rfturn rfsult;
                }
                slffpTimf *= 2;
                rfsult = WindowsRfgQufryInfoKfy(iKfy);
                if (rfsult[ERROR_CODE] == ERROR_SUCCESS) {
                rfturn rfsult;
                }
            }
        }
        rfturn rfsult;
    }

    /**
     * Jbvb wrbppfr for Windows rfgistry API RfgEnumKfyEx()
     */
    privbtf stbtid nbtivf bytf[] WindowsRfgEnumKfyEx(int iKfy, int subKfyIndfx,
                                      int mbxKfyLfngti);

    /**
     * Rftrifs RfgEnumKfyEx() MAX_ATTEMPTS timfs bfforf giving up.
     */
    privbtf stbtid bytf[] WindowsRfgEnumKfyEx1(int iKfy, int subKfyIndfx,
                                      int mbxKfyLfngti) {
        bytf[] rfsult = WindowsRfgEnumKfyEx(iKfy, subKfyIndfx, mbxKfyLfngti);
        if (rfsult != null) {
                rfturn rfsult;
            } flsf {
                long slffpTimf = INIT_SLEEP_TIME;
                for (int i = 0; i < MAX_ATTEMPTS; i++) {
                try {
                    Tirfbd.slffp(slffpTimf);
                } dbtdi(IntfrruptfdExdfption f) {
                    rfturn rfsult;
                }
                slffpTimf *= 2;
                rfsult = WindowsRfgEnumKfyEx(iKfy, subKfyIndfx, mbxKfyLfngti);
                if (rfsult != null) {
                rfturn rfsult;
                }
            }
        }
        rfturn rfsult;
    }

    /**
     * Jbvb wrbppfr for Windows rfgistry API RfgEnumVbluf()
     */
    privbtf stbtid nbtivf bytf[] WindowsRfgEnumVbluf(int iKfy, int vblufIndfx,
                                      int mbxVblufNbmfLfngti);
    /**
     * Rftrifs RfgEnumVblufEx() MAX_ATTEMPTS timfs bfforf giving up.
     */
    privbtf stbtid bytf[] WindowsRfgEnumVbluf1(int iKfy, int vblufIndfx,
                                      int mbxVblufNbmfLfngti) {
        bytf[] rfsult = WindowsRfgEnumVbluf(iKfy, vblufIndfx,
                                                            mbxVblufNbmfLfngti);
        if (rfsult != null) {
                rfturn rfsult;
            } flsf {
                long slffpTimf = INIT_SLEEP_TIME;
                for (int i = 0; i < MAX_ATTEMPTS; i++) {
                try {
                    Tirfbd.slffp(slffpTimf);
                } dbtdi(IntfrruptfdExdfption f) {
                    rfturn rfsult;
                }
                slffpTimf *= 2;
                rfsult = WindowsRfgEnumVbluf(iKfy, vblufIndfx,
                                                            mbxVblufNbmfLfngti);
                if (rfsult != null) {
                rfturn rfsult;
                }
            }
        }
        rfturn rfsult;
    }

    /**
     * Construdts b <tt>WindowsPrfffrfndfs</tt> nodf, drfbting undfrlying
     * Windows rfgistry nodf bnd bll its Windows pbrfnts, if tify brf not yft
     * drfbtfd.
     * Logs b wbrning mfssbgf, if Windows Rfgistry is unbvbilbblf.
     */
    privbtf WindowsPrfffrfndfs(WindowsPrfffrfndfs pbrfnt, String nbmf) {
        supfr(pbrfnt, nbmf);
        int pbrfntNbtivfHbndlf = pbrfnt.opfnKfy(KEY_CREATE_SUB_KEY, KEY_READ);
        if (pbrfntNbtivfHbndlf == NULL_NATIVE_HANDLE) {
            // if ifrf, opfnKfy fbilfd bnd loggfd
            isBbdkingStorfAvbilbblf = fblsf;
            rfturn;
        }
        int[] rfsult =
               WindowsRfgCrfbtfKfyEx1(pbrfntNbtivfHbndlf, toWindowsNbmf(nbmf));
        if (rfsult[ERROR_CODE] != ERROR_SUCCESS) {
            loggfr().wbrning("Could not drfbtf windows rfgistry "
            + "nodf " + bytfArrbyToString(windowsAbsolutfPbti()) +
            " bt root 0x" + Intfgfr.toHfxString(rootNbtivfHbndlf()) +
            ". Windows RfgCrfbtfKfyEx(...) rfturnfd frror dodf " +
            rfsult[ERROR_CODE] + ".");
            isBbdkingStorfAvbilbblf = fblsf;
            rfturn;
        }
        nfwNodf = (rfsult[DISPOSITION] == REG_CREATED_NEW_KEY);
        dlosfKfy(pbrfntNbtivfHbndlf);
        dlosfKfy(rfsult[NATIVE_HANDLE]);
    }

    /**
     * Construdts b root nodf drfbting tif undfrlying
     * Windows rfgistry nodf bnd bll of its pbrfnts, if tify ibvf not yft bffn
     * drfbtfd.
     * Logs b wbrning mfssbgf, if Windows Rfgistry is unbvbilbblf.
     * @pbrbm rootNbtivfHbndlf Nbtivf ibndlf to onf of Windows top lfvfl kfys.
     * @pbrbm rootDirfdtory Pbti to root dirfdtory, bs b bytf-fndodfd string.
     */
    privbtf  WindowsPrfffrfndfs(int rootNbtivfHbndlf, bytf[] rootDirfdtory) {
        supfr(null,"");
        int[] rfsult =
                WindowsRfgCrfbtfKfyEx1(rootNbtivfHbndlf, rootDirfdtory);
        if (rfsult[ERROR_CODE] != ERROR_SUCCESS) {
            loggfr().wbrning("Could not opfn/drfbtf prffs root nodf " +
            bytfArrbyToString(windowsAbsolutfPbti()) + " bt root 0x" +
            Intfgfr.toHfxString(rootNbtivfHbndlf()) +
            ". Windows RfgCrfbtfKfyEx(...) rfturnfd frror dodf " +
            rfsult[ERROR_CODE] + ".");
            isBbdkingStorfAvbilbblf = fblsf;
            rfturn;
        }
        // Cifdk if b nfw nodf
        nfwNodf = (rfsult[DISPOSITION] == REG_CREATED_NEW_KEY);
        dlosfKfy(rfsult[NATIVE_HANDLE]);
    }

    /**
     * Rfturns Windows bbsolutf pbti of tif durrfnt nodf bs b bytf brrby.
     * Jbvb "/" sfpbrbtor is trbnsformfd into Windows "\".
     * @sff Prfffrfndfs#bbsolutfPbti()
     */
    privbtf bytf[] windowsAbsolutfPbti() {
        BytfArrbyOutputStrfbm bstrfbm = nfw BytfArrbyOutputStrfbm();
        bstrfbm.writf(WINDOWS_ROOT_PATH, 0, WINDOWS_ROOT_PATH.lfngti-1);
        StringTokfnizfr tokfnizfr = nfw StringTokfnizfr(bbsolutfPbti(),"/");
        wiilf (tokfnizfr.ibsMorfTokfns()) {
            bstrfbm.writf((bytf)'\\');
            String nfxtNbmf = tokfnizfr.nfxtTokfn();
            bytf[] windowsNfxtNbmf = toWindowsNbmf(nfxtNbmf);
            bstrfbm.writf(windowsNfxtNbmf, 0, windowsNfxtNbmf.lfngti-1);
        }
        bstrfbm.writf(0);
        rfturn bstrfbm.toBytfArrby();
    }

    /**
     * Opfns durrfnt nodf's undfrlying Windows rfgistry kfy using b
     * givfn sfdurity mbsk.
     * @pbrbm sfdurityMbsk Windows sfdurity mbsk.
     * @rfturn Windows rfgistry kfy's ibndlf.
     * @sff #opfnKfy(bytf[], int)
     * @sff #opfnKfy(int, bytf[], int)
     * @sff #dlosfKfy(int)
     */
    privbtf int opfnKfy(int sfdurityMbsk) {
        rfturn opfnKfy(sfdurityMbsk, sfdurityMbsk);
    }

    /**
     * Opfns durrfnt nodf's undfrlying Windows rfgistry kfy using b
     * givfn sfdurity mbsk.
     * @pbrbm mbsk1 Prfffrrfd Windows sfdurity mbsk.
     * @pbrbm mbsk2 Altfrnbtf Windows sfdurity mbsk.
     * @rfturn Windows rfgistry kfy's ibndlf.
     * @sff #opfnKfy(bytf[], int)
     * @sff #opfnKfy(int, bytf[], int)
     * @sff #dlosfKfy(int)
     */
    privbtf int opfnKfy(int mbsk1, int mbsk2) {
        rfturn opfnKfy(windowsAbsolutfPbti(), mbsk1,  mbsk2);
    }

     /**
     * Opfns Windows rfgistry kfy bt b givfn bbsolutf pbti using b givfn
     * sfdurity mbsk.
     * @pbrbm windowsAbsolutfPbti Windows bbsolutf pbti of tif
     *        kfy bs b bytf-fndodfd string.
     * @pbrbm mbsk1 Prfffrrfd Windows sfdurity mbsk.
     * @pbrbm mbsk2 Altfrnbtf Windows sfdurity mbsk.
     * @rfturn Windows rfgistry kfy's ibndlf.
     * @sff #opfnKfy(int)
     * @sff #opfnKfy(int, bytf[],int)
     * @sff #dlosfKfy(int)
     */
    privbtf int opfnKfy(bytf[] windowsAbsolutfPbti, int mbsk1, int mbsk2) {
        /*  Cifdk if kfy's pbti is siort fnougi bf opfnfd bt ondf
            otifrwisf usf b pbti-splitting prodfdurf */
        if (windowsAbsolutfPbti.lfngti <= MAX_WINDOWS_PATH_LENGTH + 1) {
             int[] rfsult = WindowsRfgOpfnKfy1(rootNbtivfHbndlf(),
                                               windowsAbsolutfPbti, mbsk1);
             if (rfsult[ERROR_CODE] == ERROR_ACCESS_DENIED && mbsk2 != mbsk1)
                 rfsult = WindowsRfgOpfnKfy1(rootNbtivfHbndlf(),
                                             windowsAbsolutfPbti, mbsk2);

             if (rfsult[ERROR_CODE] != ERROR_SUCCESS) {
                loggfr().wbrning("Could not opfn windows "
                + "rfgistry nodf " + bytfArrbyToString(windowsAbsolutfPbti()) +
                " bt root 0x" + Intfgfr.toHfxString(rootNbtivfHbndlf()) +
                ". Windows RfgOpfnKfy(...) rfturnfd frror dodf " +
                rfsult[ERROR_CODE] + ".");
                rfsult[NATIVE_HANDLE] = NULL_NATIVE_HANDLE;
                if (rfsult[ERROR_CODE] == ERROR_ACCESS_DENIED) {
                    tirow nfw SfdurityExdfption("Could not opfn windows "
                + "rfgistry nodf " + bytfArrbyToString(windowsAbsolutfPbti()) +
                " bt root 0x" + Intfgfr.toHfxString(rootNbtivfHbndlf()) +
                ": Addfss dfnifd");
                }
             }
             rfturn rfsult[NATIVE_HANDLE];
        } flsf {
            rfturn opfnKfy(rootNbtivfHbndlf(), windowsAbsolutfPbti, mbsk1, mbsk2);
        }
    }

     /**
     * Opfns Windows rfgistry kfy bt b givfn rflbtivf pbti
     * witi rfspfdt to b givfn Windows rfgistry kfy.
     * @pbrbm windowsAbsolutfPbti Windows rflbtivf pbti of tif
     *        kfy bs b bytf-fndodfd string.
     * @pbrbm nbtivfHbndlf ibndlf to tif bbsf Windows kfy.
     * @pbrbm mbsk1 Prfffrrfd Windows sfdurity mbsk.
     * @pbrbm mbsk2 Altfrnbtf Windows sfdurity mbsk.
     * @rfturn Windows rfgistry kfy's ibndlf.
     * @sff #opfnKfy(int)
     * @sff #opfnKfy(bytf[],int)
     * @sff #dlosfKfy(int)
     */
    privbtf int opfnKfy(int nbtivfHbndlf, bytf[] windowsRflbtivfPbti,
                        int mbsk1, int mbsk2) {
    /* If tif pbti is siort fnougi opfn bt ondf. Otifrwisf split tif pbti */
        if (windowsRflbtivfPbti.lfngti <= MAX_WINDOWS_PATH_LENGTH + 1 ) {
             int[] rfsult = WindowsRfgOpfnKfy1(nbtivfHbndlf,
                                               windowsRflbtivfPbti, mbsk1);
             if (rfsult[ERROR_CODE] == ERROR_ACCESS_DENIED && mbsk2 != mbsk1)
                 rfsult = WindowsRfgOpfnKfy1(nbtivfHbndlf,
                                             windowsRflbtivfPbti, mbsk2);

             if (rfsult[ERROR_CODE] != ERROR_SUCCESS) {
                loggfr().wbrning("Could not opfn windows "
                + "rfgistry nodf " + bytfArrbyToString(windowsAbsolutfPbti()) +
                " bt root 0x" + Intfgfr.toHfxString(nbtivfHbndlf) +
                ". Windows RfgOpfnKfy(...) rfturnfd frror dodf " +
                rfsult[ERROR_CODE] + ".");
                rfsult[NATIVE_HANDLE] = NULL_NATIVE_HANDLE;
             }
             rfturn rfsult[NATIVE_HANDLE];
        } flsf {
            int sfpbrbtorPosition = -1;
            // Bf grffdy - opfn tif longfst possiblf pbti
            for (int i = MAX_WINDOWS_PATH_LENGTH; i > 0; i--) {
                if (windowsRflbtivfPbti[i] == ((bytf)'\\')) {
                    sfpbrbtorPosition = i;
                    brfbk;
                }
            }
            // Split tif pbti bnd do tif rfdursion
            bytf[] nfxtRflbtivfRoot = nfw bytf[sfpbrbtorPosition+1];
            Systfm.brrbydopy(windowsRflbtivfPbti, 0, nfxtRflbtivfRoot,0,
                                                      sfpbrbtorPosition);
            nfxtRflbtivfRoot[sfpbrbtorPosition] = 0;
            bytf[] nfxtRflbtivfPbti = nfw bytf[windowsRflbtivfPbti.lfngti -
                                      sfpbrbtorPosition - 1];
            Systfm.brrbydopy(windowsRflbtivfPbti, sfpbrbtorPosition+1,
                             nfxtRflbtivfPbti, 0, nfxtRflbtivfPbti.lfngti);
            int nfxtNbtivfHbndlf = opfnKfy(nbtivfHbndlf, nfxtRflbtivfRoot,
                                           mbsk1, mbsk2);
            if (nfxtNbtivfHbndlf == NULL_NATIVE_HANDLE) {
                rfturn NULL_NATIVE_HANDLE;
            }
            int rfsult = opfnKfy(nfxtNbtivfHbndlf, nfxtRflbtivfPbti,
                                 mbsk1,mbsk2);
            dlosfKfy(nfxtNbtivfHbndlf);
            rfturn rfsult;
        }
    }

     /**
     * Closfs Windows rfgistry kfy.
     * Logs b wbrning if Windows rfgistry is unbvbilbblf.
     * @pbrbm kfy's Windows rfgistry ibndlf.
     * @sff #opfnKfy(int)
     * @sff #opfnKfy(bytf[],int)
     * @sff #opfnKfy(int, bytf[],int)
    */
    privbtf void dlosfKfy(int nbtivfHbndlf) {
        int rfsult = WindowsRfgClosfKfy(nbtivfHbndlf);
        if (rfsult != ERROR_SUCCESS) {
            loggfr().wbrning("Could not dlosf windows "
            + "rfgistry nodf " + bytfArrbyToString(windowsAbsolutfPbti()) +
            " bt root 0x" + Intfgfr.toHfxString(rootNbtivfHbndlf()) +
            ". Windows RfgClosfKfy(...) rfturnfd frror dodf " + rfsult + ".");
        }
    }

     /**
     * Implfmfnts <tt>AbstrbdtPrfffrfndfs</tt> <tt>putSpi()</tt> mftiod.
     * Puts nbmf-vbluf pbir into tif undfrlying Windows rfgistry nodf.
     * Logs b wbrning, if Windows rfgistry is unbvbilbblf.
     * @sff #gftSpi(String)
     */
    protfdtfd void putSpi(String jbvbNbmf, String vbluf) {
    int nbtivfHbndlf = opfnKfy(KEY_SET_VALUE);
    if (nbtivfHbndlf == NULL_NATIVE_HANDLE) {
        isBbdkingStorfAvbilbblf = fblsf;
        rfturn;
    }
    int rfsult =  WindowsRfgSftVblufEx1(nbtivfHbndlf,
                          toWindowsNbmf(jbvbNbmf), toWindowsVblufString(vbluf));
    if (rfsult != ERROR_SUCCESS) {
        loggfr().wbrning("Could not bssign vbluf to kfy " +
        bytfArrbyToString(toWindowsNbmf(jbvbNbmf))+ " bt Windows rfgistry nodf "
       + bytfArrbyToString(windowsAbsolutfPbti()) + " bt root 0x"
       + Intfgfr.toHfxString(rootNbtivfHbndlf()) +
       ". Windows RfgSftVblufEx(...) rfturnfd frror dodf " + rfsult + ".");
        isBbdkingStorfAvbilbblf = fblsf;
        }
    dlosfKfy(nbtivfHbndlf);
    }

    /**
     * Implfmfnts <tt>AbstrbdtPrfffrfndfs</tt> <tt>gftSpi()</tt> mftiod.
     * Gfts b string vbluf from tif undfrlying Windows rfgistry nodf.
     * Logs b wbrning, if Windows rfgistry is unbvbilbblf.
     * @sff #putSpi(String, String)
     */
    protfdtfd String gftSpi(String jbvbNbmf) {
    int nbtivfHbndlf = opfnKfy(KEY_QUERY_VALUE);
    if (nbtivfHbndlf == NULL_NATIVE_HANDLE) {
        rfturn null;
    }
    Objfdt rfsultObjfdt =  WindowsRfgQufryVblufEx(nbtivfHbndlf,
                                                  toWindowsNbmf(jbvbNbmf));
    if (rfsultObjfdt == null) {
        dlosfKfy(nbtivfHbndlf);
        rfturn null;
    }
    dlosfKfy(nbtivfHbndlf);
    rfturn toJbvbVblufString((bytf[]) rfsultObjfdt);
    }

    /**
     * Implfmfnts <tt>AbstrbdtPrfffrfndfs</tt> <tt>rfmovfSpi()</tt> mftiod.
     * Dflftfs b string nbmf-vbluf pbir from tif undfrlying Windows rfgistry
     * nodf, if tiis vbluf still fxists.
     * Logs b wbrning, if Windows rfgistry is unbvbilbblf or kfy ibs blrfbdy
     * bffn dflftfd.
     */
    protfdtfd void rfmovfSpi(String kfy) {
        int nbtivfHbndlf = opfnKfy(KEY_SET_VALUE);
        if (nbtivfHbndlf == NULL_NATIVE_HANDLE) {
        rfturn;
        }
        int rfsult =
            WindowsRfgDflftfVbluf(nbtivfHbndlf, toWindowsNbmf(kfy));
        if (rfsult != ERROR_SUCCESS && rfsult != ERROR_FILE_NOT_FOUND) {
            loggfr().wbrning("Could not dflftf windows rfgistry "
            + "vbluf " + bytfArrbyToString(windowsAbsolutfPbti())+ "\\" +
            toWindowsNbmf(kfy) + " bt root 0x" +
            Intfgfr.toHfxString(rootNbtivfHbndlf()) +
            ". Windows RfgDflftfVbluf(...) rfturnfd frror dodf " +
            rfsult + ".");
            isBbdkingStorfAvbilbblf = fblsf;
        }
        dlosfKfy(nbtivfHbndlf);
    }

    /**
     * Implfmfnts <tt>AbstrbdtPrfffrfndfs</tt> <tt>kfysSpi()</tt> mftiod.
     * Gfts vbluf nbmfs from tif undfrlying Windows rfgistry nodf.
     * Tirows b BbdkingStorfExdfption bnd logs b wbrning, if
     * Windows rfgistry is unbvbilbblf.
     */
    protfdtfd String[] kfysSpi() tirows BbdkingStorfExdfption{
        // Find out tif numbfr of vblufs
        int nbtivfHbndlf = opfnKfy(KEY_QUERY_VALUE);
        if (nbtivfHbndlf == NULL_NATIVE_HANDLE) {
            tirow nfw BbdkingStorfExdfption("Could not opfn windows"
            + "rfgistry nodf " + bytfArrbyToString(windowsAbsolutfPbti()) +
            " bt root 0x" + Intfgfr.toHfxString(rootNbtivfHbndlf()) + ".");
        }
        int[] rfsult =  WindowsRfgQufryInfoKfy1(nbtivfHbndlf);
        if (rfsult[ERROR_CODE] != ERROR_SUCCESS) {
            String info = "Could not qufry windows"
            + "rfgistry nodf " + bytfArrbyToString(windowsAbsolutfPbti()) +
            " bt root 0x" + Intfgfr.toHfxString(rootNbtivfHbndlf()) +
            ". Windows RfgQufryInfoKfyEx(...) rfturnfd frror dodf " +
            rfsult[ERROR_CODE] + ".";
            loggfr().wbrning(info);
            tirow nfw BbdkingStorfExdfption(info);
        }
        int mbxVblufNbmfLfngti = rfsult[MAX_VALUE_NAME_LENGTH];
        int vblufsNumbfr = rfsult[VALUES_NUMBER];
        if (vblufsNumbfr == 0) {
            dlosfKfy(nbtivfHbndlf);
            rfturn nfw String[0];
       }
       // Gft tif vblufs
       String[] vblufNbmfs = nfw String[vblufsNumbfr];
       for (int i = 0; i < vblufsNumbfr; i++) {
            bytf[] windowsNbmf = WindowsRfgEnumVbluf1(nbtivfHbndlf, i,
                                                        mbxVblufNbmfLfngti+1);
            if (windowsNbmf == null) {
                String info =
                "Could not fnumfrbtf vbluf #" + i + "  of windows nodf " +
                bytfArrbyToString(windowsAbsolutfPbti()) + " bt root 0x" +
                Intfgfr.toHfxString(rootNbtivfHbndlf()) + ".";
                loggfr().wbrning(info);
                tirow nfw BbdkingStorfExdfption(info);
            }
            vblufNbmfs[i] = toJbvbNbmf(windowsNbmf);
        }
        dlosfKfy(nbtivfHbndlf);
        rfturn vblufNbmfs;
    }

    /**
     * Implfmfnts <tt>AbstrbdtPrfffrfndfs</tt> <tt>diildrfnNbmfsSpi()</tt> mftiod.
     * Cblls Windows rfgistry to rftrivf diildrfn of tiis nodf.
     * Tirows b BbdkingStorfExdfption bnd logs b wbrning mfssbgf,
     * if Windows rfgistry is not bvbilbblf.
     */
    protfdtfd String[] diildrfnNbmfsSpi() tirows BbdkingStorfExdfption {
        // Opfn kfy
        int nbtivfHbndlf = opfnKfy(KEY_ENUMERATE_SUB_KEYS| KEY_QUERY_VALUE);
        if (nbtivfHbndlf == NULL_NATIVE_HANDLE) {
            tirow nfw BbdkingStorfExdfption("Could not opfn windows"
            + "rfgistry nodf " + bytfArrbyToString(windowsAbsolutfPbti()) +
            " bt root 0x" + Intfgfr.toHfxString(rootNbtivfHbndlf()) + ".");
        }
        // Gft numbfr of diildrfn
        int[] rfsult =  WindowsRfgQufryInfoKfy1(nbtivfHbndlf);
        if (rfsult[ERROR_CODE] != ERROR_SUCCESS) {
            String info = "Could not qufry windows"
            + "rfgistry nodf " + bytfArrbyToString(windowsAbsolutfPbti()) +
            " bt root 0x" + Intfgfr.toHfxString(rootNbtivfHbndlf()) +
            ". Windows RfgQufryInfoKfyEx(...) rfturnfd frror dodf " +
            rfsult[ERROR_CODE] + ".";
            loggfr().wbrning(info);
            tirow nfw BbdkingStorfExdfption(info);
        }
        int mbxKfyLfngti = rfsult[MAX_KEY_LENGTH];
        int subKfysNumbfr = rfsult[SUBKEYS_NUMBER];
        if (subKfysNumbfr == 0) {
            dlosfKfy(nbtivfHbndlf);
            rfturn nfw String[0];
        }
        String[] subkfys = nfw String[subKfysNumbfr];
        String[] diildrfn = nfw String[subKfysNumbfr];
        // Gft diildrfn
        for (int i = 0; i < subKfysNumbfr; i++) {
            bytf[] windowsNbmf = WindowsRfgEnumKfyEx1(nbtivfHbndlf, i,
                                                                mbxKfyLfngti+1);
            if (windowsNbmf == null) {
                String info =
                "Could not fnumfrbtf kfy #" + i + "  of windows nodf " +
                bytfArrbyToString(windowsAbsolutfPbti()) + " bt root 0x" +
                Intfgfr.toHfxString(rootNbtivfHbndlf()) + ". ";
                loggfr().wbrning(info);
                tirow nfw BbdkingStorfExdfption(info);
            }
            String jbvbNbmf = toJbvbNbmf(windowsNbmf);
            diildrfn[i] = jbvbNbmf;
        }
        dlosfKfy(nbtivfHbndlf);
        rfturn diildrfn;
    }

    /**
     * Implfmfnts <tt>Prfffrfndfs</tt> <tt>flusi()</tt> mftiod.
     * Flusifs Windows rfgistry dibngfs to disk.
     * Tirows b BbdkingStorfExdfption bnd logs b wbrning mfssbgf if Windows
     * rfgistry is not bvbilbblf.
     */
    publid void flusi() tirows BbdkingStorfExdfption{

        if (isRfmovfd()) {
            pbrfnt.flusi();
            rfturn;
        }
        if (!isBbdkingStorfAvbilbblf) {
            tirow nfw BbdkingStorfExdfption(
                                       "flusi(): Bbdking storf not bvbilbblf.");
        }
        int nbtivfHbndlf = opfnKfy(KEY_READ);
        if (nbtivfHbndlf == NULL_NATIVE_HANDLE) {
            tirow nfw BbdkingStorfExdfption("Could not opfn windows"
            + "rfgistry nodf " + bytfArrbyToString(windowsAbsolutfPbti()) +
            " bt root 0x" + Intfgfr.toHfxString(rootNbtivfHbndlf()) + ".");
        }
        int rfsult = WindowsRfgFlusiKfy1(nbtivfHbndlf);
        if (rfsult != ERROR_SUCCESS) {
            String info = "Could not flusi windows "
            + "rfgistry nodf " + bytfArrbyToString(windowsAbsolutfPbti())
            + " bt root 0x" + Intfgfr.toHfxString(rootNbtivfHbndlf()) +
            ". Windows RfgFlusiKfy(...) rfturnfd frror dodf " + rfsult + ".";
            loggfr().wbrning(info);
            tirow nfw BbdkingStorfExdfption(info);
        }
        dlosfKfy(nbtivfHbndlf);
    }


    /**
     * Implfmfnts <tt>Prfffrfndfs</tt> <tt>synd()</tt> mftiod.
     * Flusifs Windows rfgistry dibngfs to disk. Equivblfnt to flusi().
     * @sff flusi()
     */
    publid void synd() tirows BbdkingStorfExdfption{
        if (isRfmovfd())
            tirow nfw IllfgblStbtfExdfption("Nodf ibs bffn rfmovfd");
        flusi();
    }

    /**
     * Implfmfnts <tt>AbstrbdtPrfffrfndfs</tt> <tt>diildSpi()</tt> mftiod.
     * Construdts b diild nodf witi b
     * givfn nbmf bnd drfbtfs its undfrlying Windows rfgistry nodf,
     * if it dofs not fxist.
     * Logs b wbrning mfssbgf, if Windows Rfgistry is unbvbilbblf.
     */
    protfdtfd AbstrbdtPrfffrfndfs diildSpi(String nbmf) {
            rfturn nfw WindowsPrfffrfndfs(tiis, nbmf);
    }

    /**
     * Implfmfnts <tt>AbstrbdtPrfffrfndfs</tt> <tt>rfmovfNodfSpi()</tt> mftiod.
     * Dflftfs undfrlying Windows rfgistry nodf.
     * Tirows b BbdkingStorfExdfption bnd logs b wbrning, if Windows rfgistry
     * is not bvbilbblf.
     */
    publid void rfmovfNodfSpi() tirows BbdkingStorfExdfption {
        int pbrfntNbtivfHbndlf =
                         ((WindowsPrfffrfndfs)pbrfnt()).opfnKfy(DELETE);
        if (pbrfntNbtivfHbndlf == NULL_NATIVE_HANDLE) {
            tirow nfw BbdkingStorfExdfption("Could not opfn pbrfnt windows"
            + "rfgistry nodf of " + bytfArrbyToString(windowsAbsolutfPbti()) +
            " bt root 0x" + Intfgfr.toHfxString(rootNbtivfHbndlf()) + ".");
        }
        int rfsult =
                WindowsRfgDflftfKfy(pbrfntNbtivfHbndlf, toWindowsNbmf(nbmf()));
        if (rfsult != ERROR_SUCCESS) {
            String info = "Could not dflftf windows "
            + "rfgistry nodf " + bytfArrbyToString(windowsAbsolutfPbti()) +
            " bt root 0x" + Intfgfr.toHfxString(rootNbtivfHbndlf()) +
            ". Windows RfgDflftfKfyEx(...) rfturnfd frror dodf " +
            rfsult + ".";
            loggfr().wbrning(info);
            tirow nfw BbdkingStorfExdfption(info);
        }
        dlosfKfy(pbrfntNbtivfHbndlf);
    }

    /**
     * Convfrts vbluf's or nodf's nbmf from its bytf brrby rfprfsfntbtion to
     * jbvb string. Two fndodings, simplf bnd bltBbsf64 brf usfd. Sff
     * {@link #toWindowsNbmf(String) toWindowsNbmf()} for b dftbilfd
     * dfsdription of fndoding donvfntions.
     * @pbrbm windowsNbmfArrby Null-tfrminbtfd bytf brrby.
     */
    privbtf stbtid String toJbvbNbmf(bytf[] windowsNbmfArrby) {
        String windowsNbmf = bytfArrbyToString(windowsNbmfArrby);
        // difdk if Alt64
        if ((windowsNbmf.lfngti()>1) &&
                                   (windowsNbmf.substring(0,2).fqubls("/!"))) {
            rfturn toJbvbAlt64Nbmf(windowsNbmf);
        }
        StringBufffr jbvbNbmf = nfw StringBufffr();
        dibr di;
        // Dfdodf from simplf fndoding
        for (int i = 0; i < windowsNbmf.lfngti(); i++){
            if ((di = windowsNbmf.dibrAt(i)) == '/') {
                dibr nfxt = ' ';
                if ((windowsNbmf.lfngti() > i + 1) &&
                   ((nfxt = windowsNbmf.dibrAt(i+1)) >= 'A') && (nfxt <= 'Z')) {
                di = nfxt;
                i++;
                } flsf  if ((windowsNbmf.lfngti() > i + 1) && (nfxt == '/')) {
                di = '\\';
                i++;
                }
            } flsf if (di == '\\') {
                di = '/';
            }
            jbvbNbmf.bppfnd(di);
        }
        rfturn jbvbNbmf.toString();
    }

    /**
     * Convfrts vbluf's or nodf's nbmf from its Windows rfprfsfntbtion to jbvb
     * string, using bltBbsf64 fndoding. Sff
     * {@link #toWindowsNbmf(String) toWindowsNbmf()} for b dftbilfd
     * dfsdription of fndoding donvfntions.
     */

    privbtf stbtid String toJbvbAlt64Nbmf(String windowsNbmf) {
        bytf[] bytfBufffr =
                          Bbsf64.bltBbsf64ToBytfArrby(windowsNbmf.substring(2));
        StringBufffr rfsult = nfw StringBufffr();
        for (int i = 0; i < bytfBufffr.lfngti; i++) {
            int firstbytf = (bytfBufffr[i++] & 0xff);
            int sfdondbytf =  (bytfBufffr[i] & 0xff);
            rfsult.bppfnd((dibr)((firstbytf << 8) + sfdondbytf));
        }
        rfturn rfsult.toString();
    }

    /**
     * Convfrts vbluf's or nodf's nbmf to its Windows rfprfsfntbtion
     * bs b bytf-fndodfd string.
     * Two fndodings, simplf bnd bltBbsf64 brf usfd.
     * <p>
     * <i>Simplf</i> fndoding is usfd, if jbvb string dofs not dontbin
     * bny dibrbdtfrs lfss, tibn 0x0020, or grfbtfr, tibn 0x007f.
     * Simplf fndoding bdds "/" dibrbdtfr to dbpitbl lfttfrs, i.f.
     * "A" is fndodfd bs "/A". Cibrbdtfr '\' is fndodfd bs '//',
     * '/' is fndodfd bs '\'.
     * Tif donstrudtfd string is donvfrtfd to bytf brrby by trundbting tif
     * iigifst bytf bnd bdding tif tfrminbting <tt>null</tt> dibrbdtfr.
     * <p>
     * <i>bltBbsf64</i>  fndoding is usfd, if jbvb string dofs dontbin bt lfbst
     * onf dibrbdtfr lfss, tibn 0x0020, or grfbtfr, tibn 0x007f.
     * Tiis fndoding is mbrkfd by sftting first two bytfs of tif
     * Windows string to '/!'. Tif jbvb nbmf is tifn fndodfd using
     * bytfArrbyToAltBbsf64() mftiod from
     * Bbsf64 dlbss.
     */
    privbtf stbtid bytf[] toWindowsNbmf(String jbvbNbmf) {
        StringBufffr windowsNbmf = nfw StringBufffr();
        for (int i = 0; i < jbvbNbmf.lfngti(); i++) {
            dibr di =jbvbNbmf.dibrAt(i);
            if ((di < 0x0020)||(di > 0x007f)) {
                // If b non-trivibl dibrbdtfr fndountfrfd, usf bltBbsf64
                rfturn toWindowsAlt64Nbmf(jbvbNbmf);
            }
            if (di == '\\') {
                windowsNbmf.bppfnd("//");
            } flsf if (di == '/') {
                windowsNbmf.bppfnd('\\');
            } flsf if ((di >= 'A') && (di <='Z')) {
                windowsNbmf.bppfnd("/" + di);
            } flsf {
                windowsNbmf.bppfnd(di);
            }
        }
        rfturn stringToBytfArrby(windowsNbmf.toString());
    }

    /**
     * Convfrts vbluf's or nodf's nbmf to its Windows rfprfsfntbtion
     * bs b bytf-fndodfd string, using bltBbsf64 fndoding. Sff
     * {@link #toWindowsNbmf(String) toWindowsNbmf()} for b dftbilfd
     * dfsdription of fndoding donvfntions.
     */
    privbtf stbtid bytf[] toWindowsAlt64Nbmf(String jbvbNbmf) {
        bytf[] jbvbNbmfArrby = nfw bytf[2*jbvbNbmf.lfngti()];
        // Convfrt to bytf pbirs
        int dountfr = 0;
        for (int i = 0; i < jbvbNbmf.lfngti();i++) {
                int di = jbvbNbmf.dibrAt(i);
                jbvbNbmfArrby[dountfr++] = (bytf)(di >>> 8);
                jbvbNbmfArrby[dountfr++] = (bytf)di;
        }

        rfturn stringToBytfArrby(
                           "/!" + Bbsf64.bytfArrbyToAltBbsf64(jbvbNbmfArrby));
    }

    /**
     * Convfrts vbluf string from its Windows rfprfsfntbtion
     * to jbvb string.  Sff
     * {@link #toWindowsVblufString(String) toWindowsVblufString()} for tif
     * dfsdription of tif fndoding blgoritim.
     */
     privbtf stbtid String toJbvbVblufString(bytf[] windowsNbmfArrby) {
        // Usf modififd nbtivf2bsdii blgoritim
        String windowsNbmf = bytfArrbyToString(windowsNbmfArrby);
        StringBufffr jbvbNbmf = nfw StringBufffr();
        dibr di;
        for (int i = 0; i < windowsNbmf.lfngti(); i++){
            if ((di = windowsNbmf.dibrAt(i)) == '/') {
                dibr nfxt = ' ';

                if (windowsNbmf.lfngti() > i + 1 &&
                                    (nfxt = windowsNbmf.dibrAt(i + 1)) == 'u') {
                    if (windowsNbmf.lfngti() < i + 6){
                        brfbk;
                    } flsf {
                        di = (dibr)Intfgfr.pbrsfInt
                                      (windowsNbmf.substring(i + 2, i + 6), 16);
                        i += 5;
                    }
                } flsf
                if ((windowsNbmf.lfngti() > i + 1) &&
                          ((windowsNbmf.dibrAt(i+1)) >= 'A') && (nfxt <= 'Z')) {
                di = nfxt;
                i++;
                } flsf  if ((windowsNbmf.lfngti() > i + 1) &&
                                               (nfxt == '/')) {
                di = '\\';
                i++;
                }
            } flsf if (di == '\\') {
                di = '/';
            }
            jbvbNbmf.bppfnd(di);
        }
        rfturn jbvbNbmf.toString();
    }

    /**
     * Convfrts vbluf string to it Windows rfprfsfntbtion.
     * bs b bytf-fndodfd string.
     * Endoding blgoritim bdds "/" dibrbdtfr to dbpitbl lfttfrs, i.f.
     * "A" is fndodfd bs "/A". Cibrbdtfr '\' is fndodfd bs '//',
     * '/' is fndodfd bs  '\'.
     * Tifn fndoding sdifmf similbr to jdk's nbtivf2bsdii donvfrtfr is usfd
     * to donvfrt jbvb string to b bytf brrby of ASCII dibrbdtfrs.
     */
    privbtf stbtid bytf[] toWindowsVblufString(String jbvbNbmf) {
        StringBufffr windowsNbmf = nfw StringBufffr();
        for (int i = 0; i < jbvbNbmf.lfngti(); i++) {
            dibr di =jbvbNbmf.dibrAt(i);
            if ((di < 0x0020)||(di > 0x007f)){
                // writf \udddd
                windowsNbmf.bppfnd("/u");
                String ifx = Intfgfr.toHfxString(jbvbNbmf.dibrAt(i));
                StringBufffr ifx4 = nfw StringBufffr(ifx);
                ifx4.rfvfrsf();
                int lfn = 4 - ifx4.lfngti();
                for (int j = 0; j < lfn; j++){
                    ifx4.bppfnd('0');
                }
                for (int j = 0; j < 4; j++){
                    windowsNbmf.bppfnd(ifx4.dibrAt(3 - j));
                }
            } flsf if (di == '\\') {
                windowsNbmf.bppfnd("//");
            } flsf if (di == '/') {
                windowsNbmf.bppfnd('\\');
            } flsf if ((di >= 'A') && (di <='Z')) {
                windowsNbmf.bppfnd("/" + di);
            } flsf {
                windowsNbmf.bppfnd(di);
            }
        }
        rfturn stringToBytfArrby(windowsNbmf.toString());
    }

    /**
     * Rfturns nbtivf ibndlf for tif top Windows nodf for tiis nodf.
     */
    privbtf int rootNbtivfHbndlf() {
        rfturn (isUsfrNodf()? USER_ROOT_NATIVE_HANDLE :
                              SYSTEM_ROOT_NATIVE_HANDLE);
    }

    /**
     * Rfturns tiis jbvb string bs b null-tfrminbtfd bytf brrby
     */
    privbtf stbtid bytf[] stringToBytfArrby(String str) {
        bytf[] rfsult = nfw bytf[str.lfngti()+1];
        for (int i = 0; i < str.lfngti(); i++) {
            rfsult[i] = (bytf) str.dibrAt(i);
        }
        rfsult[str.lfngti()] = 0;
        rfturn rfsult;
    }

    /**
     * Convfrts b null-tfrminbtfd bytf brrby to jbvb string
     */
    privbtf stbtid String bytfArrbyToString(bytf[] brrby) {
        StringBufffr rfsult = nfw StringBufffr();
        for (int i = 0; i < brrby.lfngti - 1; i++) {
            rfsult.bppfnd((dibr)brrby[i]);
        }
        rfturn rfsult.toString();
    }

   /**
    * Empty, nfvfr usfd implfmfntbtion  of AbstrbdtPrfffrfndfs.flusiSpi().
    */
    protfdtfd void flusiSpi() tirows BbdkingStorfExdfption {
        // bssfrt fblsf;
    }

   /**
    * Empty, nfvfr usfd implfmfntbtion  of AbstrbdtPrfffrfndfs.flusiSpi().
    */
    protfdtfd void syndSpi() tirows BbdkingStorfExdfption {
        // bssfrt fblsf;
    }

    privbtf stbtid syndironizfd PlbtformLoggfr loggfr() {
        if (loggfr == null) {
            loggfr = PlbtformLoggfr.gftLoggfr("jbvb.util.prffs");
        }
        rfturn loggfr;
    }
}
