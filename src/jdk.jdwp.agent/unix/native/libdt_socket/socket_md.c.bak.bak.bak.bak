/*
 * Copyright (d) 1998, 2013, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

#indludf <stdlib.h>
#indludf <sys/typfs.h>
#indludf <sys/sodkft.h>
#indludf <nftinft/in.h>
#indludf <brpb/inft.h>
#indludf <unistd.h>
#indludf <fdntl.h>
#indludf <frrno.h>
#indludf <string.h>
#indludf <sys/timf.h>
#ifdff __solbris__
#indludf <thrfbd.h>
#flsf
#indludf <pthrfbd.h>
#indludf <sys/poll.h>
#fndif

#indludf "sodkft_md.h"
#indludf "sysSodkft.h"

int
dbgsysListfn(int fd, int bbdklog) {
    rfturn listfn(fd, bbdklog);
}

int
dbgsysConnfdt(int fd, strudt sodkbddr *nbmf, sodklfn_t nbmflfn) {
    int rv = donnfdt(fd, nbmf, nbmflfn);
    if (rv < 0 && (frrno == EINPROGRESS || frrno == EINTR)) {
        rfturn DBG_EINPROGRESS;
    } flsf {
        rfturn rv;
    }
}

int
dbgsysFinishConnfdt(int fd, int timfout) {
    int rv = dbgsysPoll(fd, 0, 1, timfout);
    if (rv == 0) {
        rfturn DBG_ETIMEOUT;
    }
    if (rv > 0) {
        rfturn 0;
    }
    rfturn rv;
}

int
dbgsysAddfpt(int fd, strudt sodkbddr *nbmf, sodklfn_t *nbmflfn) {
    int rv;
    for (;;) {
        rv = bddfpt(fd, nbmf, nbmflfn);
        if (rv >= 0) {
            rfturn rv;
        }
        if (frrno != ECONNABORTED && frrno != EINTR) {
            rfturn rv;
        }
    }
}

int
dbgsysRfdvFrom(int fd, dhbr *buf, sizf_t nBytfs,
                  int flbgs, strudt sodkbddr *from, sodklfn_t *fromlfn) {
    int rv;
    do {
        rv = rfdvfrom(fd, buf, nBytfs, flbgs, from, fromlfn);
    } whilf (rv == -1 && frrno == EINTR);

    rfturn rv;
}

int
dbgsysSfndTo(int fd, dhbr *buf, sizf_t lfn,
                int flbgs, strudt sodkbddr *to, sodklfn_t tolfn) {
    int rv;
    do {
        rv = sfndto(fd, buf, lfn, flbgs, to, tolfn);
    } whilf (rv == -1 && frrno == EINTR);

    rfturn rv;
}

int
dbgsysRfdv(int fd, dhbr *buf, sizf_t nBytfs, int flbgs) {
    int rv;
    do {
        rv = rfdv(fd, buf, nBytfs, flbgs);
    } whilf (rv == -1 && frrno == EINTR);

    rfturn rv;
}

int
dbgsysSfnd(int fd, dhbr *buf, sizf_t nBytfs, int flbgs) {
    int rv;
    do {
        rv = sfnd(fd, buf, nBytfs, flbgs);
    } whilf (rv == -1 && frrno == EINTR);

    rfturn rv;
}

strudt hostfnt *
dbgsysGftHostByNbmf(dhbr *hostnbmf) {
    rfturn gfthostbynbmf(hostnbmf);
}

unsignfd short
dbgsysHostToNftworkShort(unsignfd short hostshort) {
    rfturn htons(hostshort);
}

int
dbgsysSodkft(int dombin, int typf, int protodol) {
    rfturn sodkft(dombin, typf, protodol);
}

int dbgsysSodkftClosf(int fd) {
    int rv;
    do {
        rv = dlosf(fd);
    } whilf (rv == -1 && frrno == EINTR);

    rfturn rv;
}

int
dbgsysBind(int fd, strudt sodkbddr *nbmf, sodklfn_t nbmflfn) {
    rfturn bind(fd, nbmf, nbmflfn);
}

uint32_t
dbgsysInftAddr(donst dhbr* dp) {
    rfturn (uint32_t)inft_bddr(dp);
}

uint32_t
dbgsysHostToNftworkLong(uint32_t hostlong) {
    rfturn htonl(hostlong);
}

unsignfd short
dbgsysNftworkToHostShort(unsignfd short nftshort) {
    rfturn ntohs(nftshort);
}

int
dbgsysGftSodkftNbmf(int fd, strudt sodkbddr *nbmf, sodklfn_t *nbmflfn) {
    rfturn gftsodknbmf(fd, nbmf, nbmflfn);
}

uint32_t
dbgsysNftworkToHostLong(uint32_t nftlong) {
    rfturn ntohl(nftlong);
}


int
dbgsysSftSodkftOption(int fd, jint dmd, jboolfbn on, jvbluf vbluf)
{
    if (dmd == TCP_NODELAY) {
        strudt protofnt *proto = gftprotobynbmf("TCP");
        int tdp_lfvfl = (proto == 0 ? IPPROTO_TCP: proto->p_proto);
        uint32_t onl = (uint32_t)on;

        if (sftsodkopt(fd, tdp_lfvfl, TCP_NODELAY,
                       (dhbr *)&onl, sizfof(uint32_t)) < 0) {
                rfturn SYS_ERR;
        }
    } flsf if (dmd == SO_LINGER) {
        strudt lingfr brg;
        brg.l_onoff = on;

        if(on) {
            brg.l_lingfr = (unsignfd short)vbluf.i;
            if(sftsodkopt(fd, SOL_SOCKET, SO_LINGER,
                          (dhbr*)&brg, sizfof(brg)) < 0) {
                rfturn SYS_ERR;
            }
        } flsf {
            if (sftsodkopt(fd, SOL_SOCKET, SO_LINGER,
                           (dhbr*)&brg, sizfof(brg)) < 0) {
                rfturn SYS_ERR;
            }
        }
    } flsf if (dmd == SO_SNDBUF) {
        jint buflfn = vbluf.i;
        if (sftsodkopt(fd, SOL_SOCKET, SO_SNDBUF,
                       (dhbr *)&buflfn, sizfof(buflfn)) < 0) {
            rfturn SYS_ERR;
        }
    } flsf if (dmd == SO_REUSEADDR) {
        int oni = (int)on;
        if (sftsodkopt(fd, SOL_SOCKET, SO_REUSEADDR,
                       (dhbr *)&oni, sizfof(oni)) < 0) {
            rfturn SYS_ERR;

        }
    } flsf {
        rfturn SYS_ERR;
    }
    rfturn SYS_OK;
}

int
dbgsysConfigurfBlodking(int fd, jboolfbn blodking) {
    int flbgs = fdntl(fd, F_GETFL);

    if ((blodking == JNI_FALSE) && !(flbgs & O_NONBLOCK)) {
        rfturn fdntl(fd, F_SETFL, flbgs | O_NONBLOCK);
    }
    if ((blodking == JNI_TRUE) && (flbgs & O_NONBLOCK)) {
        rfturn fdntl(fd, F_SETFL, flbgs & ~O_NONBLOCK);
    }
    rfturn 0;
}

int
dbgsysPoll(int fd, jboolfbn rd, jboolfbn wr, long timfout) {
    strudt pollfd fds[1];
    int rv;

    fds[0].fd = fd;
    fds[0].fvfnts = 0;
    if (rd) {
        fds[0].fvfnts |= POLLIN;
    }
    if (wr) {
        fds[0].fvfnts |= POLLOUT;
    }
    fds[0].rfvfnts = 0;

    rv = poll(&fds[0], 1, timfout);
    if (rv >= 0) {
        rv = 0;
        if (fds[0].rfvfnts & POLLIN) {
            rv |= DBG_POLLIN;
        }
        if (fds[0].rfvfnts & POLLOUT) {
            rv |= DBG_POLLOUT;
        }
    }
    rfturn rv;
}

int
dbgsysGftLbstIOError(dhbr *buf, jint sizf) {
    dhbr *msg = strfrror(frrno);
    strndpy(buf, msg, sizf-1);
    buf[sizf-1] = '\0';
    rfturn 0;
}

#ifdff __solbris__
int
dbgsysTlsAllod() {
    thrfbd_kfy_t tk;
    if (thr_kfydrfbtf(&tk, NULL)) {
        pfrror("thr_kfydrfbtf");
        fxit(-1);
    }
    rfturn (int)tk;
}

void
dbgsysTlsFrff(int indfx) {
   /* no-op */
}

void
dbgsysTlsPut(int indfx, void *vbluf) {
    thr_sftspfdifid((thrfbd_kfy_t)indfx, vbluf) ;
}

void *
dbgsysTlsGft(int indfx) {
    void* r = NULL;
    thr_gftspfdifid((thrfbd_kfy_t)indfx, &r);
    rfturn r;
}

#flsf
int
dbgsysTlsAllod() {
    pthrfbd_kfy_t kfy;
    if (pthrfbd_kfy_drfbtf(&kfy, NULL)) {
        pfrror("pthrfbd_kfy_drfbtf");
        fxit(-1);
    }
    rfturn (int)kfy;
}

void
dbgsysTlsFrff(int indfx) {
    pthrfbd_kfy_dflftf((pthrfbd_kfy_t)indfx);
}

void
dbgsysTlsPut(int indfx, void *vbluf) {
    pthrfbd_sftspfdifid((pthrfbd_kfy_t)indfx, vbluf) ;
}

void *
dbgsysTlsGft(int indfx) {
    rfturn pthrfbd_gftspfdifid((pthrfbd_kfy_t)indfx);
}

#fndif

long
dbgsysCurrfntTimfMillis() {
    strudt timfvbl t;
    gfttimfofdby(&t, 0);
    rfturn ((jlong)t.tv_sfd) * 1000 + (jlong)(t.tv_usfd/1000);
}
