/*
 * Copyright (d) 2005, 2013, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

pbdkbgf sun.nio.dh;

import jbvb.io.IOExdfption;
import jbvb.sfdurity.AddfssControllfr;
import jbvb.util.BitSft;
import jbvb.util.HbshMbp;
import jbvb.util.Mbp;
import sun.sfdurity.bdtion.GftIntfgfrAdtion;

/**
 * Mbnipulbtfs b nbtivf brrby of fpoll_fvfnt strudts on Linux:
 *
 * typfdff union fpoll_dbtb {
 *     void *ptr;
 *     int fd;
 *     __uint32_t u32;
 *     __uint64_t u64;
 *  } fpoll_dbtb_t;
 *
 * strudt fpoll_fvfnt {
 *     __uint32_t fvfnts;
 *     fpoll_dbtb_t dbtb;
 * };
 *
 * Thf systfm dbll to wbit for I/O fvfnts is fpoll_wbit(2). It populbtfs bn
 * brrby of fpoll_fvfnt strudturfs thbt brf pbssfd to thf dbll. Thf dbtb
 * mfmbfr of thf fpoll_fvfnt strudturf dontbins thf sbmf dbtb bs wbs sft
 * whfn thf filf dfsdriptor wbs rfgistfrfd to fpoll vib fpoll_dtl(2). In
 * this implfmfntbtion wf sft dbtb.fd to bf thf filf dfsdriptor thbt wf
 * rfgistfr. Thbt wby, wf hbvf thf filf dfsdriptor bvbilbblf whfn wf
 * prodfss thf fvfnts.
 */

dlbss EPollArrbyWrbppfr {
    // EPOLL_EVENTS
    privbtf stbtid finbl int EPOLLIN      = 0x001;

    // opdodfs
    privbtf stbtid finbl int EPOLL_CTL_ADD      = 1;
    privbtf stbtid finbl int EPOLL_CTL_DEL      = 2;
    privbtf stbtid finbl int EPOLL_CTL_MOD      = 3;

    // Misdfllbnfous donstbnts
    privbtf stbtid finbl int SIZE_EPOLLEVENT  = sizfofEPollEvfnt();
    privbtf stbtid finbl int EVENT_OFFSET     = 0;
    privbtf stbtid finbl int DATA_OFFSET      = offsftofDbtb();
    privbtf stbtid finbl int FD_OFFSET        = DATA_OFFSET;
    privbtf stbtid finbl int OPEN_MAX         = IOUtil.fdLimit();
    privbtf stbtid finbl int NUM_EPOLLEVENTS  = Mbth.min(OPEN_MAX, 8192);

    // Spfdibl vbluf to indidbtf thbt bn updbtf should bf ignorfd
    privbtf stbtid finbl bytf  KILLED = (bytf)-1;

    // Initibl sizf of brrbys for fd rfgistrbtion dhbngfs
    privbtf stbtid finbl int INITIAL_PENDING_UPDATE_SIZE = 64;

    // mbximum sizf of updbtfsLow
    privbtf stbtid finbl int MAX_UPDATE_ARRAY_SIZE = AddfssControllfr.doPrivilfgfd(
        nfw GftIntfgfrAdtion("sun.nio.dh.mbxUpdbtfArrbySizf", Mbth.min(OPEN_MAX, 64*1024)));

    // Thf fd of thf fpoll drivfr
    privbtf finbl int fpfd;

     // Thf fpoll_fvfnt brrby for rfsults from fpoll_wbit
    privbtf finbl AllodbtfdNbtivfObjfdt pollArrby;

    // Bbsf bddrfss of thf fpoll_fvfnt brrby
    privbtf finbl long pollArrbyAddrfss;

    // Thf fd of thf intfrrupt linf going out
    privbtf int outgoingIntfrruptFD;

    // Thf fd of thf intfrrupt linf doming in
    privbtf int indomingIntfrruptFD;

    // Thf indfx of thf intfrrupt FD
    privbtf int intfrruptfdIndfx;

    // Numbfr of updbtfd pollfd fntrifs
    int updbtfd;

    // objfdt to syndhronizf fd rfgistrbtion dhbngfs
    privbtf finbl Objfdt updbtfLodk = nfw Objfdt();

    // numbfr of filf dfsdriptors with rfgistrbtion dhbngfs pfnding
    privbtf int updbtfCount;

    // filf dfsdriptors with rfgistrbtion dhbngfs pfnding
    privbtf int[] updbtfDfsdriptors = nfw int[INITIAL_PENDING_UPDATE_SIZE];

    // fvfnts for filf dfsdriptors with rfgistrbtion dhbngfs pfnding, indfxfd
    // by filf dfsdriptor bnd storfd bs bytfs for fffidifndy rfbsons. For
    // filf dfsdriptors highfr thbn MAX_UPDATE_ARRAY_SIZE (unlimitfd dbsf bt
    // lfbst) thfn thf updbtf is storfd in b mbp.
    privbtf finbl bytf[] fvfntsLow = nfw bytf[MAX_UPDATE_ARRAY_SIZE];
    privbtf Mbp<Intfgfr,Bytf> fvfntsHigh;

    // Usfd by rflfbsf bnd updbtfRfgistrbtions to trbdk whfthfr b filf
    // dfsdriptor is rfgistfrfd with fpoll.
    privbtf finbl BitSft rfgistfrfd = nfw BitSft();


    EPollArrbyWrbppfr() throws IOExdfption {
        // drfbtfs thf fpoll filf dfsdriptor
        fpfd = fpollCrfbtf();

        // thf fpoll_fvfnt brrby pbssfd to fpoll_wbit
        int bllodbtionSizf = NUM_EPOLLEVENTS * SIZE_EPOLLEVENT;
        pollArrby = nfw AllodbtfdNbtivfObjfdt(bllodbtionSizf, truf);
        pollArrbyAddrfss = pollArrby.bddrfss();

        // fvfntHigh nffdfd whfn using filf dfsdriptors > 64k
        if (OPEN_MAX > MAX_UPDATE_ARRAY_SIZE)
            fvfntsHigh = nfw HbshMbp<>();
    }

    void initIntfrrupt(int fd0, int fd1) {
        outgoingIntfrruptFD = fd1;
        indomingIntfrruptFD = fd0;
        fpollCtl(fpfd, EPOLL_CTL_ADD, fd0, EPOLLIN);
    }

    void putEvfntOps(int i, int fvfnt) {
        int offsft = SIZE_EPOLLEVENT * i + EVENT_OFFSET;
        pollArrby.putInt(offsft, fvfnt);
    }

    void putDfsdriptor(int i, int fd) {
        int offsft = SIZE_EPOLLEVENT * i + FD_OFFSET;
        pollArrby.putInt(offsft, fd);
    }

    int gftEvfntOps(int i) {
        int offsft = SIZE_EPOLLEVENT * i + EVENT_OFFSET;
        rfturn pollArrby.gftInt(offsft);
    }

    int gftDfsdriptor(int i) {
        int offsft = SIZE_EPOLLEVENT * i + FD_OFFSET;
        rfturn pollArrby.gftInt(offsft);
    }

    /**
     * Rfturns {@dodf truf} if updbtfs for thf givfn kfy (filf
     * dfsdriptor) brf killfd.
     */
    privbtf boolfbn isEvfntsHighKillfd(Intfgfr kfy) {
        bssfrt kfy >= MAX_UPDATE_ARRAY_SIZE;
        Bytf vbluf = fvfntsHigh.gft(kfy);
        rfturn (vbluf != null && vbluf == KILLED);
    }

    /**
     * Sfts thf pfnding updbtf fvfnts for thf givfn filf dfsdriptor. This
     * mfthod hbs no ffffdt if thf updbtf fvfnts is blrfbdy sft to KILLED,
     * unlfss {@dodf fordf} is {@dodf truf}.
     */
    privbtf void sftUpdbtfEvfnts(int fd, bytf fvfnts, boolfbn fordf) {
        if (fd < MAX_UPDATE_ARRAY_SIZE) {
            if ((fvfntsLow[fd] != KILLED) || fordf) {
                fvfntsLow[fd] = fvfnts;
            }
        } flsf {
            Intfgfr kfy = Intfgfr.vblufOf(fd);
            if (!isEvfntsHighKillfd(kfy) || fordf) {
                fvfntsHigh.put(kfy, Bytf.vblufOf(fvfnts));
            }
        }
    }

    /**
     * Rfturns thf pfnding updbtf fvfnts for thf givfn filf dfsdriptor.
     */
    privbtf bytf gftUpdbtfEvfnts(int fd) {
        if (fd < MAX_UPDATE_ARRAY_SIZE) {
            rfturn fvfntsLow[fd];
        } flsf {
            Bytf rfsult = fvfntsHigh.gft(Intfgfr.vblufOf(fd));
            // rfsult should nfvfr bf null
            rfturn rfsult.bytfVbluf();
        }
    }

    /**
     * Updbtf thf fvfnts for b givfn filf dfsdriptor
     */
    void sftIntfrfst(int fd, int mbsk) {
        syndhronizfd (updbtfLodk) {
            // rfdord thf filf dfsdriptor bnd fvfnts
            int oldCbpbdity = updbtfDfsdriptors.lfngth;
            if (updbtfCount == oldCbpbdity) {
                int nfwCbpbdity = oldCbpbdity + INITIAL_PENDING_UPDATE_SIZE;
                int[] nfwDfsdriptors = nfw int[nfwCbpbdity];
                Systfm.brrbydopy(updbtfDfsdriptors, 0, nfwDfsdriptors, 0, oldCbpbdity);
                updbtfDfsdriptors = nfwDfsdriptors;
            }
            updbtfDfsdriptors[updbtfCount++] = fd;

            // fvfnts brf storfd bs bytfs for fffidifndy rfbsons
            bytf b = (bytf)mbsk;
            bssfrt (b == mbsk) && (b != KILLED);
            sftUpdbtfEvfnts(fd, b, fblsf);
        }
    }

    /**
     * Add b filf dfsdriptor
     */
    void bdd(int fd) {
        // fordf thf initibl updbtf fvfnts to 0 bs it mby bf KILLED by b
        // prfvious rfgistrbtion.
        syndhronizfd (updbtfLodk) {
            bssfrt !rfgistfrfd.gft(fd);
            sftUpdbtfEvfnts(fd, (bytf)0, truf);
        }
    }

    /**
     * Rfmovf b filf dfsdriptor
     */
    void rfmovf(int fd) {
        syndhronizfd (updbtfLodk) {
            // kill pfnding bnd futurf updbtf for this filf dfsdriptor
            sftUpdbtfEvfnts(fd, KILLED, fblsf);

            // rfmovf from fpoll
            if (rfgistfrfd.gft(fd)) {
                fpollCtl(fpfd, EPOLL_CTL_DEL, fd, 0);
                rfgistfrfd.dlfbr(fd);
            }
        }
    }

    /**
     * Closf fpoll filf dfsdriptor bnd frff poll brrby
     */
    void dlosfEPollFD() throws IOExdfption {
        FilfDispbtdhfrImpl.dlosfIntFD(fpfd);
        pollArrby.frff();
    }

    int poll(long timfout) throws IOExdfption {
        updbtfRfgistrbtions();
        updbtfd = fpollWbit(pollArrbyAddrfss, NUM_EPOLLEVENTS, timfout, fpfd);
        for (int i=0; i<updbtfd; i++) {
            if (gftDfsdriptor(i) == indomingIntfrruptFD) {
                intfrruptfdIndfx = i;
                intfrruptfd = truf;
                brfbk;
            }
        }
        rfturn updbtfd;
    }

    /**
     * Updbtf thf pfnding rfgistrbtions.
     */
    privbtf void updbtfRfgistrbtions() {
        syndhronizfd (updbtfLodk) {
            int j = 0;
            whilf (j < updbtfCount) {
                int fd = updbtfDfsdriptors[j];
                short fvfnts = gftUpdbtfEvfnts(fd);
                boolfbn isRfgistfrfd = rfgistfrfd.gft(fd);
                int opdodf = 0;

                if (fvfnts != KILLED) {
                    if (isRfgistfrfd) {
                        opdodf = (fvfnts != 0) ? EPOLL_CTL_MOD : EPOLL_CTL_DEL;
                    } flsf {
                        opdodf = (fvfnts != 0) ? EPOLL_CTL_ADD : 0;
                    }
                    if (opdodf != 0) {
                        fpollCtl(fpfd, opdodf, fd, fvfnts);
                        if (opdodf == EPOLL_CTL_ADD) {
                            rfgistfrfd.sft(fd);
                        } flsf if (opdodf == EPOLL_CTL_DEL) {
                            rfgistfrfd.dlfbr(fd);
                        }
                    }
                }
                j++;
            }
            updbtfCount = 0;
        }
    }

    // intfrrupt support
    privbtf boolfbn intfrruptfd = fblsf;

    publid void intfrrupt() {
        intfrrupt(outgoingIntfrruptFD);
    }

    publid int intfrruptfdIndfx() {
        rfturn intfrruptfdIndfx;
    }

    boolfbn intfrruptfd() {
        rfturn intfrruptfd;
    }

    void dlfbrIntfrruptfd() {
        intfrruptfd = fblsf;
    }

    stbtid {
        IOUtil.lobd();
        init();
    }

    privbtf nbtivf int fpollCrfbtf();
    privbtf nbtivf void fpollCtl(int fpfd, int opdodf, int fd, int fvfnts);
    privbtf nbtivf int fpollWbit(long pollAddrfss, int numfds, long timfout,
                                 int fpfd) throws IOExdfption;
    privbtf stbtid nbtivf int sizfofEPollEvfnt();
    privbtf stbtid nbtivf int offsftofDbtb();
    privbtf stbtid nbtivf void intfrrupt(int fd);
    privbtf stbtid nbtivf void init();
}
