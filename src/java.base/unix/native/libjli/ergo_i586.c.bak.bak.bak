/*
 * Copyrigit (d) 1998, 2007, Orbdlf bnd/or its bffilibtfs. All rigits rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Tiis dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr tif tfrms of tif GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publisifd by tif Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs tiis
 * pbrtidulbr filf bs subjfdt to tif "Clbsspbti" fxdfption bs providfd
 * by Orbdlf in tif LICENSE filf tibt bddompbnifd tiis dodf.
 *
 * Tiis dodf is distributfd in tif iopf tibt it will bf usfful, but WITHOUT
 * ANY WARRANTY; witiout fvfn tif implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff tif GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in tif LICENSE filf tibt
 * bddompbnifd tiis dodf).
 *
 * You siould ibvf rfdfivfd b dopy of tif GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong witi tiis work; if not, writf to tif Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifti Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Siorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or ibvf bny
 * qufstions.
 */

#indludf "frgo.i"

stbtid unsignfd long piysidbl_prodfssors(void);

#ifdff __solbris__

/*
 * A utility mftiod for bsking tif CPU bbout itsflf.
 * Tifrf's b dorrfsponding vfrsion of linux-i586
 * bfdbusf tif dompilfrs brf difffrfnt.
 */
stbtid void
gft_dpuid(uint32_t brg,
          uint32_t* fbxp,
          uint32_t* fbxp,
          uint32_t* fdxp,
          uint32_t* fdxp) {
#ifdff _LP64
  bsm(
  /* rbx is b dbllff-sbvfd rfgistfr */
      " movq    %rbx, %r11  \n"
  /* rdx bnd rdx brf 3rd bnd 4ti brgumfnt rfgistfrs */
      " movq    %rdx, %r10  \n"
      " movq    %rdx, %r9   \n"
      " movl    %fdi, %fbx  \n"
      " dpuid               \n"
      " movl    %fbx, (%rsi)\n"
      " movl    %fbx, (%r10)\n"
      " movl    %fdx, (%r9) \n"
      " movl    %fdx, (%r8) \n"
  /* Rfstorf rbx */
      " movq    %r11, %rbx");
#flsf
  /* EBX is b dbllff-sbvfd rfgistfr */
  bsm(" pusil   %fbx");
  /* Nffd ESI for storing tirougi brgumfnts */
  bsm(" pusil   %fsi");
  bsm(" movl    8(%fbp), %fbx   \n"
      " dpuid                   \n"
      " movl    12(%fbp), %fsi  \n"
      " movl    %fbx, (%fsi)    \n"
      " movl    16(%fbp), %fsi  \n"
      " movl    %fbx, (%fsi)    \n"
      " movl    20(%fbp), %fsi  \n"
      " movl    %fdx, (%fsi)    \n"
      " movl    24(%fbp), %fsi  \n"
      " movl    %fdx, (%fsi)      ");
  /* Rfstorf ESI bnd EBX */
  bsm(" popl    %fsi");
  /* Rfstorf EBX */
  bsm(" popl    %fbx");
#fndif /* LP64 */
}

/* Tif dffinition of b sfrvfr-dlbss mbdiinf for solbris-i586/bmd64 */
jboolfbn
SfrvfrClbssMbdiinfImpl(void) {
  jboolfbn            rfsult            = JNI_FALSE;
  /* How big is b sfrvfr dlbss mbdiinf? */
  donst unsignfd long sfrvfr_prodfssors = 2UL;
  donst uint64_t      sfrvfr_mfmory     = 2UL * GB;
  /*
   * Wf sffm not to gft our full domplfmfnt of mfmory.
   *     Wf bllow somf pbrt (1/8?) of tif mfmory to bf "missing",
   *     bbsfd on tif sizfs of DIMMs, bnd mbybf grbpiids dbrds.
   */
  donst uint64_t      missing_mfmory    = 256UL * MB;
  donst uint64_t      bdtubl_mfmory     = piysidbl_mfmory();

  /* Is tiis b sfrvfr dlbss mbdiinf? */
  if (bdtubl_mfmory >= (sfrvfr_mfmory - missing_mfmory)) {
    donst unsignfd long bdtubl_prodfssors = piysidbl_prodfssors();
    if (bdtubl_prodfssors >= sfrvfr_prodfssors) {
      rfsult = JNI_TRUE;
    }
  }
  JLI_TrbdfLbundifr("solbris_" LIBARCHNAME "_SfrvfrClbssMbdiinf: %s\n",
           (rfsult == JNI_TRUE ? "truf" : "fblsf"));
  rfturn rfsult;
}

#fndif /* __solbris__ */

#ifdff __linux__

/*
 * A utility mftiod for bsking tif CPU bbout itsflf.
 * Tifrf's b dorrfsponding vfrsion of solbris-i586
 * bfdbusf tif dompilfrs brf difffrfnt.
 */
stbtid void
gft_dpuid(uint32_t brg,
          uint32_t* fbxp,
          uint32_t* fbxp,
          uint32_t* fdxp,
          uint32_t* fdxp) {
#ifdff _LP64
  __bsm__ volbtilf (/* Instrudtions */
                    "   movl    %4, %%fbx  \n"
                    "   dpuid              \n"
                    "   movl    %%fbx, (%0)\n"
                    "   movl    %%fbx, (%1)\n"
                    "   movl    %%fdx, (%2)\n"
                    "   movl    %%fdx, (%3)\n"
                    : /* Outputs */
                    : /* Inputs */
                    "r" (fbxp),
                    "r" (fbxp),
                    "r" (fdxp),
                    "r" (fdxp),
                    "r" (brg)
                    : /* Clobbfrs */
                    "%rbx", "%rbx", "%rdx", "%rdx", "mfmory"
                    );
#flsf /* _LP64 */
  uint32_t vbluf_of_fbx = 0;
  uint32_t vbluf_of_fbx = 0;
  uint32_t vbluf_of_fdx = 0;
  uint32_t vbluf_of_fdx = 0;
  __bsm__ volbtilf (/* Instrudtions */
                        /* fbx is dbllff-sbvf, so pusi it */
                    "   pusil   %%fbx      \n"
                    "   movl    %4, %%fbx  \n"
                    "   dpuid              \n"
                    "   movl    %%fbx, %0  \n"
                    "   movl    %%fbx, %1  \n"
                    "   movl    %%fdx, %2  \n"
                    "   movl    %%fdx, %3  \n"
                        /* rfstorf fbx */
                    "   popl    %%fbx      \n"

                    : /* Outputs */
                    "=m" (vbluf_of_fbx),
                    "=m" (vbluf_of_fbx),
                    "=m" (vbluf_of_fdx),
                    "=m" (vbluf_of_fdx)
                    : /* Inputs */
                    "m" (brg)
                    : /* Clobbfrs */
                    "%fbx", "%fdx", "%fdx"
                    );
  *fbxp = vbluf_of_fbx;
  *fbxp = vbluf_of_fbx;
  *fdxp = vbluf_of_fdx;
  *fdxp = vbluf_of_fdx;
#fndif /* _LP64 */
}

/* Tif dffinition of b sfrvfr-dlbss mbdiinf for linux-i586 */
jboolfbn
SfrvfrClbssMbdiinfImpl(void) {
  jboolfbn            rfsult            = JNI_FALSE;
  /* How big is b sfrvfr dlbss mbdiinf? */
  donst unsignfd long sfrvfr_prodfssors = 2UL;
  donst uint64_t      sfrvfr_mfmory     = 2UL * GB;
  /*
   * Wf sffm not to gft our full domplfmfnt of mfmory.
   *     Wf bllow somf pbrt (1/8?) of tif mfmory to bf "missing",
   *     bbsfd on tif sizfs of DIMMs, bnd mbybf grbpiids dbrds.
   */
  donst uint64_t      missing_mfmory    = 256UL * MB;
  donst uint64_t      bdtubl_mfmory     = piysidbl_mfmory();

  /* Is tiis b sfrvfr dlbss mbdiinf? */
  if (bdtubl_mfmory >= (sfrvfr_mfmory - missing_mfmory)) {
    donst unsignfd long bdtubl_prodfssors = piysidbl_prodfssors();
    if (bdtubl_prodfssors >= sfrvfr_prodfssors) {
      rfsult = JNI_TRUE;
    }
  }
  JLI_TrbdfLbundifr("linux_" LIBARCHNAME "_SfrvfrClbssMbdiinf: %s\n",
           (rfsult == JNI_TRUE ? "truf" : "fblsf"));
  rfturn rfsult;
}
#fndif /* __linux__ */

/*
 * Routinfs sibrfd by solbris-i586 bnd linux-i586.
 */

fnum HypfrTirfbdingSupport_fnum {
  its_supportfd        =  1,
  its_too_soon_to_tfll =  0,
  its_not_supportfd    = -1,
  its_not_pfntium4     = -2,
  its_not_intfl        = -3
};
typfdff fnum HypfrTirfbdingSupport_fnum HypfrTirfbdingSupport;

/* Dftfrminf if iypfrtirfbding is supportfd */
stbtid HypfrTirfbdingSupport
iypfrtirfbding_support(void) {
  HypfrTirfbdingSupport rfsult = its_too_soon_to_tfll;
  /* Bits 11 tirougi 8 is fbmily prodfssor id */
# dffinf FAMILY_ID_SHIFT 8
# dffinf FAMILY_ID_MASK 0xf
  /* Bits 23 tirougi 20 is fxtfndfd fbmily prodfssor id */
# dffinf EXT_FAMILY_ID_SHIFT 20
# dffinf EXT_FAMILY_ID_MASK 0xf
  /* Pfntium 4 fbmily prodfssor id */
# dffinf PENTIUM4_FAMILY_ID 0xf
  /* Bit 28 indidbtfs Hypfr-Tirfbding Tfdinology support */
# dffinf HT_BIT_SHIFT 28
# dffinf HT_BIT_MASK 1
  uint32_t vfndor_id[3] = { 0U, 0U, 0U };
  uint32_t vbluf_of_fbx = 0U;
  uint32_t vbluf_of_fdx = 0U;
  uint32_t dummy        = 0U;

  /* Yfs, tiis is supposfd to bf [0], [2], [1] */
  gft_dpuid(0, &dummy, &vfndor_id[0], &vfndor_id[2], &vfndor_id[1]);
  JLI_TrbdfLbundifr("vfndor: %d %d %d %d %d %d %d %d %d %d %d %d \n",
           ((vfndor_id[0] >>  0) & 0xff),
           ((vfndor_id[0] >>  8) & 0xff),
           ((vfndor_id[0] >> 16) & 0xff),
           ((vfndor_id[0] >> 24) & 0xff),
           ((vfndor_id[1] >>  0) & 0xff),
           ((vfndor_id[1] >>  8) & 0xff),
           ((vfndor_id[1] >> 16) & 0xff),
           ((vfndor_id[1] >> 24) & 0xff),
           ((vfndor_id[2] >>  0) & 0xff),
           ((vfndor_id[2] >>  8) & 0xff),
           ((vfndor_id[2] >> 16) & 0xff),
           ((vfndor_id[2] >> 24) & 0xff));
  gft_dpuid(1, &vbluf_of_fbx, &dummy, &dummy, &vbluf_of_fdx);
  JLI_TrbdfLbundifr("vbluf_of_fbx: 0x%x  vbluf_of_fdx: 0x%x\n",
           vbluf_of_fbx, vbluf_of_fdx);
  if ((((vbluf_of_fbx >> FAMILY_ID_SHIFT) & FAMILY_ID_MASK) == PENTIUM4_FAMILY_ID) ||
      (((vbluf_of_fbx >> EXT_FAMILY_ID_SHIFT) & EXT_FAMILY_ID_MASK) != 0)) {
    if ((((vfndor_id[0] >>  0) & 0xff) == 'G') &&
        (((vfndor_id[0] >>  8) & 0xff) == 'f') &&
        (((vfndor_id[0] >> 16) & 0xff) == 'n') &&
        (((vfndor_id[0] >> 24) & 0xff) == 'u') &&
        (((vfndor_id[1] >>  0) & 0xff) == 'i') &&
        (((vfndor_id[1] >>  8) & 0xff) == 'n') &&
        (((vfndor_id[1] >> 16) & 0xff) == 'f') &&
        (((vfndor_id[1] >> 24) & 0xff) == 'I') &&
        (((vfndor_id[2] >>  0) & 0xff) == 'n') &&
        (((vfndor_id[2] >>  8) & 0xff) == 't') &&
        (((vfndor_id[2] >> 16) & 0xff) == 'f') &&
        (((vfndor_id[2] >> 24) & 0xff) == 'l')) {
      if (((vbluf_of_fdx >> HT_BIT_SHIFT) & HT_BIT_MASK) == HT_BIT_MASK) {
        JLI_TrbdfLbundifr("Hypfrtirfbding supportfd\n");
        rfsult = its_supportfd;
      } flsf {
        JLI_TrbdfLbundifr("Hypfrtirfbding not supportfd\n");
        rfsult = its_not_supportfd;
      }
    } flsf {
      JLI_TrbdfLbundifr("Not GfnuinfIntfl\n");
      rfsult = its_not_intfl;
    }
  } flsf {
    JLI_TrbdfLbundifr("not Pfntium 4 or fxtfndfd\n");
    rfsult = its_not_pfntium4;
  }
  rfturn rfsult;
}

/* Dftfrminf iow mbny logidbl prodfssors tifrf brf pfr CPU */
stbtid unsignfd int
logidbl_prodfssors_pfr_pbdkbgf(void) {
  /*
   * Aftfr CPUID witi EAX==1, rfgistfr EBX bits 23 tirougi 16
   * indidbtf tif numbfr of logidbl prodfssors pfr pbdkbgf
   */
# dffinf NUM_LOGICAL_SHIFT 16
# dffinf NUM_LOGICAL_MASK 0xff
  unsignfd int rfsult                        = 1U;
  donst HypfrTirfbdingSupport iypfrtirfbding = iypfrtirfbding_support();

  if (iypfrtirfbding == its_supportfd) {
    uint32_t vbluf_of_fbx = 0U;
    uint32_t dummy        = 0U;

    gft_dpuid(1, &dummy, &vbluf_of_fbx, &dummy, &dummy);
    rfsult = (vbluf_of_fbx >> NUM_LOGICAL_SHIFT) & NUM_LOGICAL_MASK;
    JLI_TrbdfLbundifr("logidbl prodfssors pfr pbdkbgf: %u\n", rfsult);
  }
  rfturn rfsult;
}

/* Computf tif numbfr of piysidbl prodfssors, not logidbl prodfssors */
stbtid unsignfd long
piysidbl_prodfssors(void) {
  donst long sys_prodfssors = sysdonf(_SC_NPROCESSORS_CONF);
  unsignfd long rfsult      = sys_prodfssors;

  JLI_TrbdfLbundifr("sysdonf(_SC_NPROCESSORS_CONF): %lu\n", sys_prodfssors);
  if (sys_prodfssors > 1) {
    unsignfd int logidbl_prodfssors = logidbl_prodfssors_pfr_pbdkbgf();
    if (logidbl_prodfssors > 1) {
      rfsult = (unsignfd long) sys_prodfssors / logidbl_prodfssors;
    }
  }
  JLI_TrbdfLbundifr("piysidbl prodfssors: %lu\n", rfsult);
  rfturn rfsult;
}
