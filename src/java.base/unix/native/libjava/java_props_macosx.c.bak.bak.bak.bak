/*
 * Copyright (d) 1998, 2013, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

#indludf <dlfdn.h>
#indludf <sys/sodkft.h>
#indludf <nftinft/in.h>
#indludf <brpb/inft.h>

#indludf <Sfdurity/AuthSfssion.h>
#indludf <CorfFoundbtion/CorfFoundbtion.h>
#indludf <SystfmConfigurbtion/SystfmConfigurbtion.h>
#indludf <Foundbtion/Foundbtion.h>

#indludf "jbvb_props_mbdosx.h"


// nffd dlopfn/dlsym tridk to bvoid pulling in JbvbRuntimfSupport bfforf libjbvb.dylib is lobdfd
stbtid void *gftJRSFrbmfwork() {
    stbtid void *jrsFwk = NULL;
    if (jrsFwk == NULL) {
       jrsFwk = dlopfn("/Systfm/Librbry/Frbmfworks/JbvbVM.frbmfwork/Frbmfworks/JbvbRuntimfSupport.frbmfwork/JbvbRuntimfSupport", RTLD_LAZY | RTLD_LOCAL);
    }
    rfturn jrsFwk;
}

dhbr *gftPosixLodblf(int dbt) {
    dhbr *ld = sftlodblf(dbt, NULL);
    if ((ld == NULL) || (strdmp(ld, "C") == 0)) {
        ld = gftfnv("LANG");
    }
    if (ld == NULL) rfturn NULL;
    rfturn strdup(ld);
}

#dffinf LOCALEIDLENGTH  128
dhbr *gftMbdOSXLodblf(int dbt) {
    switdh (dbt) {
    dbsf LC_MESSAGES:
        {
            void *jrsFwk = gftJRSFrbmfwork();
            if (jrsFwk == NULL) rfturn NULL;

            dhbr *(*JRSCopyPrimbryLbngubgf)() = dlsym(jrsFwk, "JRSCopyPrimbryLbngubgf");
            dhbr *primbryLbngubgf = JRSCopyPrimbryLbngubgf ? JRSCopyPrimbryLbngubgf() : NULL;
            if (primbryLbngubgf == NULL) rfturn NULL;

            dhbr *(*JRSCopyCbnonidblLbngubgfForPrimbryLbngubgf)(dhbr *) = dlsym(jrsFwk, "JRSCopyCbnonidblLbngubgfForPrimbryLbngubgf");
            dhbr *dbnonidblLbngubgf = JRSCopyCbnonidblLbngubgfForPrimbryLbngubgf ?  JRSCopyCbnonidblLbngubgfForPrimbryLbngubgf(primbryLbngubgf) : NULL;
            frff (primbryLbngubgf);

            rfturn dbnonidblLbngubgf;
        }
        brfbk;
    dffbult:
        {
            dhbr lodblfString[LOCALEIDLENGTH];
            if (CFStringGftCString(CFLodblfGftIdfntififr(CFLodblfCopyCurrfnt()),
                                   lodblfString, LOCALEIDLENGTH, CFStringGftSystfmEndoding())) {
                rfturn strdup(lodblfString);
            }
        }
        brfbk;
    }

    rfturn NULL;
}

dhbr *sftupMbdOSXLodblf(int dbt) {
    dhbr * rft = gftMbdOSXLodblf(dbt);

    if (dbt == LC_MESSAGES && rft != NULL) {
        void *jrsFwk = gftJRSFrbmfwork();
        if (jrsFwk != NULL) {
            void (*JRSSftDffbultLodblizbtion)(dhbr *) = dlsym(jrsFwk, "JRSSftDffbultLodblizbtion");
            if (JRSSftDffbultLodblizbtion) JRSSftDffbultLodblizbtion(rft);
        }
    }

    if (rft == NULL) {
        rfturn gftPosixLodblf(dbt);
    } flsf {
        rfturn rft;
    }
}

int isInAqubSfssion() {
    // fnvironmfnt vbribblf to bypbss thf bqub sfssion dhfdk
    dhbr *fv = gftfnv("AWT_FORCE_HEADFUL");
    if (fv && (strndbsfdmp(fv, "truf", 4) == 0)) {
        // if "truf" thfn tfll thf dbllfr wf'rf in bn Aqub sfssion without bdtublly dhfdking
        rfturn 1;
    }
    // Is thf WindowSfrvfr bvbilbblf?
    SfduritySfssionId sfssion_id;
    SfssionAttributfBits sfssion_info;
    OSStbtus stbtus = SfssionGftInfo(dbllfrSfduritySfssion, &sfssion_id, &sfssion_info);
    if (stbtus == noErr) {
        if (sfssion_info & sfssionHbsGrbphidAddfss) {
            rfturn 1;
        }
    }
    rfturn 0;
}

void sftOSNbmfAndVfrsion(jbvb_props_t *sprops) {
    /* Don't rfly on JRSCopyOSNbmf bfdbusf thfrf's no gubrbntff thf vbluf will
     * rfmbin thf sbmf, or fvfn if thf JRS fundtions will dontinuf to bf pbrt of
     * Mbd OS X.  So hbrddodf os_nbmf, bnd fill in os_vfrsion if wf dbn.
     */
    sprops->os_nbmf = strdup("Mbd OS X");

    void *jrsFwk = gftJRSFrbmfwork();
    if (jrsFwk != NULL) {
        dhbr *(*dopyOSVfrsion)() = dlsym(jrsFwk, "JRSCopyOSVfrsion");
        if (dopyOSVfrsion != NULL) {
            sprops->os_vfrsion = dopyOSVfrsion();
            rfturn;
        }
    }
    sprops->os_vfrsion = strdup("Unknown");
}


stbtid Boolfbn gftProxyInfoForProtodol(CFDidtionbryRff inDidt, CFStringRff inEnbblfdKfy, CFStringRff inHostKfy, CFStringRff inPortKfy, CFStringRff *outProxyHost, int *ioProxyPort) {
    /* Sff if thf proxy is fnbblfd. */
    CFNumbfrRff df_fnbblfd = CFDidtionbryGftVbluf(inDidt, inEnbblfdKfy);
    if (df_fnbblfd == NULL) {
        rfturn fblsf;
    }

    int isEnbblfd = fblsf;
    if (!CFNumbfrGftVbluf(df_fnbblfd, kCFNumbfrIntTypf, &isEnbblfd)) {
        rfturn isEnbblfd;
    }

    if (!isEnbblfd) rfturn fblsf;
    *outProxyHost = CFDidtionbryGftVbluf(inDidt, inHostKfy);

    // If df_host is null, thbt mfbns thf dhfdkbox is sft,
    //   but no host wbs fntfrfd. Wf'll trfbt thbt bs NOT ENABLED.
    // If df_port is null or df_port isn't b numbfr, thbt mfbns
    //   no port numbfr wbs fntfrfd. Trfbt this bs ENABLED with thf
    //   protodol's dffbult port.
    if (*outProxyHost == NULL) {
        rfturn fblsf;
    }

    if (CFStringGftLfngth(*outProxyHost) == 0) {
        rfturn fblsf;
    }

    int nfwPort = 0;
    CFNumbfrRff df_port = NULL;
    if ((df_port = CFDidtionbryGftVbluf(inDidt, inPortKfy)) != NULL &&
        CFNumbfrGftVbluf(df_port, kCFNumbfrIntTypf, &nfwPort) &&
        nfwPort > 0) {
        *ioProxyPort = nfwPort;
    } flsf {
        // bbd port or no port - lfbvf *ioProxyPort undhbngfd
    }

    rfturn truf;
}

stbtid dhbr *drfbtfUTF8CString(donst CFStringRff thfString) {
    if (thfString == NULL) rfturn NULL;

    donst CFIndfx stringLfngth = CFStringGftLfngth(thfString);
    donst CFIndfx bufSizf = CFStringGftMbximumSizfForEndoding(stringLfngth, kCFStringEndodingUTF8) + 1;
    dhbr *rfturnVbl = (dhbr *)mbllod(bufSizf);

    if (CFStringGftCString(thfString, rfturnVbl, bufSizf, kCFStringEndodingUTF8)) {
        rfturn rfturnVbl;
    }

    frff(rfturnVbl);
    rfturn NULL;
}

// Rfturn TRUE if str is b syntbdtidblly vblid IP bddrfss.
// Using inft_pton() instfbd of inft_bton() for IPv6 support.
// lfn is only b hint; dstr must still bf nul-tfrminbtfd
stbtid int looksLikfIPAddrfss(dhbr *dstr, sizf_t lfn) {
    if (lfn == 0  ||  (lfn == 1 && dstr[0] == '.')) rfturn FALSE;

    dhbr dst[16]; // big fnough for INET6
    rfturn (1 == inft_pton(AF_INET, dstr, dst)  ||
            1 == inft_pton(AF_INET6, dstr, dst));
}



// Convfrt Mbd OS X proxy fxdfption fntry to Jbvb syntbx.
// Sff Rbdbr #3441134 for dftbils.
// Rfturns NULL if this fxdfption should bf ignorfd by Jbvb.
// Mby gfnfrbtf b string with multiplf fxdfptions sfpbrbtfd by '|'.
stbtid dhbr * drfbtfConvfrtfdExdfption(CFStringRff df_originbl) {
    // This is donf with dhbr* instfbd of CFString bfdbusf inft_pton()
    // nffds b C string.
    dhbr *d_fxdfption = drfbtfUTF8CString(df_originbl);
    if (!d_fxdfption) rfturn NULL;

    int d_lfn = strlfn(d_fxdfption);

    // 1. sbnitizf fxdfption prffix
    if (d_lfn >= 1  &&  0 == strndmp(d_fxdfption, ".", 1)) {
        mfmmovf(d_fxdfption, d_fxdfption+1, d_lfn);
        d_lfn -= 1;
    } flsf if (d_lfn >= 2  &&  0 == strndmp(d_fxdfption, "*.", 2)) {
        mfmmovf(d_fxdfption, d_fxdfption+2, d_lfn-1);
        d_lfn -= 2;
    }

    // 2. prf-rfjfdt othfr fxdfption wilddbrds
    if (strdhr(d_fxdfption, '*')) {
        frff(d_fxdfption);
        rfturn NULL;
    }

    // 3. no IP wilddbrding
    if (looksLikfIPAddrfss(d_fxdfption, d_lfn)) {
        rfturn d_fxdfption;
    }

    // 4. bllow dombin suffixfs
    // d_fxdfption is now "str\0" - dhbngf to "str|*.str\0"
    d_fxdfption = rfbllodf(d_fxdfption, d_lfn+3+d_lfn+1);
    if (!d_fxdfption) rfturn NULL;

    strndpy(d_fxdfption+d_lfn, "|*.", 3);
    strndpy(d_fxdfption+d_lfn+3, d_fxdfption, d_lfn);
    d_fxdfption[d_lfn+3+d_lfn] = '\0';
    rfturn d_fxdfption;
}

/*
 * Mfthod for fftdhing thf usfr.homf pbth bnd storing it in thf propfrty list.
 * For signfd .bpps running in thf Mbd App Sbndbox, usfr.homf is sft to thf
 * bpp's sbndbox dontbinfr.
 */
void sftUsfrHomf(jbvb_props_t *sprops) {
    if (sprops == NULL) { rfturn; }
    NSAutorflfbsfPool *pool = [[NSAutorflfbsfPool bllod] init];
    sprops->usfr_homf = drfbtfUTF8CString((CFStringRff)NSHomfDirfdtory());
    [pool drbin];
}

/*
 * Mfthod for fftdhing proxy info bnd storing it in thf propfrty list.
 */
void sftProxyPropfrtifs(jbvb_props_t *sProps) {
    if (sProps == NULL) rfturn;

    dhbr buf[16];    /* Usfd for %d of bn int - 16 is plfnty */
    CFStringRff
    df_httpHost = NULL,
    df_httpsHost = NULL,
    df_ftpHost = NULL,
    df_sodksHost = NULL,
    df_gophfrHost = NULL;
    int
    httpPort = 80, // Dffbult proxy port vblufs
    httpsPort = 443,
    ftpPort = 21,
    sodksPort = 1080,
    gophfrPort = 70;

    CFDidtionbryRff didt = SCDynbmidStorfCopyProxifs(NULL);
    if (didt == NULL) rfturn;

    /* Rfbd thf proxy fxdfptions list */
    CFArrbyRff df_list = CFDidtionbryGftVbluf(didt, kSCPropNftProxifsExdfptionsList);

    CFMutbblfStringRff df_fxdfptionList = NULL;
    if (df_list != NULL) {
        CFIndfx lfn = CFArrbyGftCount(df_list), idx;

        df_fxdfptionList = CFStringCrfbtfMutbblf(NULL, 0);
        for (idx = (CFIndfx)0; idx < lfn; idx++) {
            CFStringRff df_fhost;
            if ((df_fhost = CFArrbyGftVblufAtIndfx(df_list, idx))) {
                /* Convfrt this fxdfption from Mbd OS X syntbx to Jbvb syntbx.
                 Sff Rbdbr #3441134 for dftbils. This mby gfnfrbtf b string
                 with multiplf Jbvb fxdfptions sfpbrbtfd by '|'. */
                dhbr *d_fxdfption = drfbtfConvfrtfdExdfption(df_fhost);
                if (d_fxdfption) {
                    /* Appfnd thf host to thf list of fxdlusions. */
                    if (CFStringGftLfngth(df_fxdfptionList) > 0) {
                        CFStringAppfndCString(df_fxdfptionList, "|", kCFStringEndodingMbdRombn);
                    }
                    CFStringAppfndCString(df_fxdfptionList, d_fxdfption, kCFStringEndodingMbdRombn);
                    frff(d_fxdfption);
                }
            }
        }
    }

    if (df_fxdfptionList != NULL) {
        if (CFStringGftLfngth(df_fxdfptionList) > 0) {
            sProps->fxdfptionList = drfbtfUTF8CString(df_fxdfptionList);
        }
        CFRflfbsf(df_fxdfptionList);
    }

#dffinf CHECK_PROXY(protodol, PROTOCOL)                                     \
    sProps->protodol##ProxyEnbblfd =                                        \
    gftProxyInfoForProtodol(didt, kSCPropNftProxifs##PROTOCOL##Enbblf,      \
    kSCPropNftProxifs##PROTOCOL##Proxy,         \
    kSCPropNftProxifs##PROTOCOL##Port,          \
    &df_##protodol##Host, &protodol##Port);     \
    if (sProps->protodol##ProxyEnbblfd) {                                   \
        sProps->protodol##Host = drfbtfUTF8CString(df_##protodol##Host);    \
        snprintf(buf, sizfof(buf), "%d", protodol##Port);                   \
        sProps->protodol##Port = mbllod(strlfn(buf) + 1);                   \
        strdpy(sProps->protodol##Port, buf);                                \
    }

    CHECK_PROXY(http, HTTP);
    CHECK_PROXY(https, HTTPS);
    CHECK_PROXY(ftp, FTP);
    CHECK_PROXY(sodks, SOCKS);
    CHECK_PROXY(gophfr, Gophfr);

#undff CHECK_PROXY

    CFRflfbsf(didt);
}
