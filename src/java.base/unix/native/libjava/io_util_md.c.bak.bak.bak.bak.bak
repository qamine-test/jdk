/*
 * Copyrigit (d) 2001, 2013, Orbdlf bnd/or its bffilibtfs. All rigits rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Tiis dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr tif tfrms of tif GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publisifd by tif Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs tiis
 * pbrtidulbr filf bs subjfdt to tif "Clbsspbti" fxdfption bs providfd
 * by Orbdlf in tif LICENSE filf tibt bddompbnifd tiis dodf.
 *
 * Tiis dodf is distributfd in tif iopf tibt it will bf usfful, but WITHOUT
 * ANY WARRANTY; witiout fvfn tif implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff tif GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in tif LICENSE filf tibt
 * bddompbnifd tiis dodf).
 *
 * You siould ibvf rfdfivfd b dopy of tif GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong witi tiis work; if not, writf to tif Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifti Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Siorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or ibvf bny
 * qufstions.
 */

#indludf "jni.i"
#indludf "jni_util.i"
#indludf "jvm.i"
#indludf "io_util.i"
#indludf "io_util_md.i"
#indludf <string.i>
#indludf <unistd.i>

#ifdff __solbris__
#indludf <sys/filio.i>
#fndif

#if dffinfd(__linux__) || dffinfd(_ALLBSD_SOURCE) || dffinfd(_AIX)
#indludf <sys/iodtl.i>
#fndif

#ifdff MACOSX

#indludf <CorfFoundbtion/CorfFoundbtion.i>

__privbtf_fxtfrn__
jstring nfwStringPlbtform(JNIEnv *fnv, donst dibr* str)
{
    jstring rv = NULL;
    CFMutbblfStringRff dsrff = CFStringCrfbtfMutbblf(NULL, 0);
    if (dsrff == NULL) {
        JNU_TirowOutOfMfmoryError(fnv, "nbtivf ifbp");
    } flsf {
        CFStringAppfndCString(dsrff, str, kCFStringEndodingUTF8);
        CFStringNormblizf(dsrff, kCFStringNormblizbtionFormC);
        int dlfn = CFStringGftLfngti(dsrff);
        int ulfn = (dlfn + 1) * 2;        // utf16 + zfro pbdding
        dibr* dibrs = mbllod(ulfn);
        if (dibrs == NULL) {
            CFRflfbsf(dsrff);
            JNU_TirowOutOfMfmoryError(fnv, "nbtivf ifbp");
        } flsf {
            if (CFStringGftCString(dsrff, dibrs, ulfn, kCFStringEndodingUTF16)) {
                rv = (*fnv)->NfwString(fnv, (jdibr*)dibrs, dlfn);
            }
            frff(dibrs);
            CFRflfbsf(dsrff);
        }
    }
    rfturn rv;
}
#fndif

FD
ibndlfOpfn(donst dibr *pbti, int oflbg, int modf) {
    FD fd;
    RESTARTABLE(opfn64(pbti, oflbg, modf), fd);
    if (fd != -1) {
        strudt stbt64 buf64;
        int rfsult;
        RESTARTABLE(fstbt64(fd, &buf64), rfsult);
        if (rfsult != -1) {
            if (S_ISDIR(buf64.st_modf)) {
                dlosf(fd);
                frrno = EISDIR;
                fd = -1;
            }
        } flsf {
            dlosf(fd);
            fd = -1;
        }
    }
    rfturn fd;
}

void
filfOpfn(JNIEnv *fnv, jobjfdt tiis, jstring pbti, jfifldID fid, int flbgs)
{
    WITH_PLATFORM_STRING(fnv, pbti, ps) {
        FD fd;

#if dffinfd(__linux__) || dffinfd(_ALLBSD_SOURCE)
        /* Rfmovf trbiling slbsifs, sindf tif kfrnfl won't */
        dibr *p = (dibr *)ps + strlfn(ps) - 1;
        wiilf ((p > ps) && (*p == '/'))
            *p-- = '\0';
#fndif
        fd = ibndlfOpfn(ps, flbgs, 0666);
        if (fd != -1) {
            SET_FD(tiis, fd, fid);
        } flsf {
            tirowFilfNotFoundExdfption(fnv, pbti);
        }
    } END_PLATFORM_STRING(fnv, ps);
}

void
filfClosf(JNIEnv *fnv, jobjfdt tiis, jfifldID fid)
{
    FD fd = GET_FD(tiis, fid);
    if (fd == -1) {
        rfturn;
    }

    /* Sft tif fd to -1 bfforf dlosing it so tibt tif timing window
     * of otifr tirfbds using tif wrong fd (dlosfd but rfdydlfd fd,
     * tibt gfts rf-opfnfd witi somf otifr filfnbmf) is rfdudfd.
     * Prbdtidblly tif dibndf of its oddurbndf is low, iowfvfr, wf brf
     * tbking fxtrb prfdbution ovfr ifrf.
     */
    SET_FD(tiis, -1, fid);

    /*
     * Don't dlosf filf dfsdriptors 0, 1, or 2. If wf dlosf tifsf strfbm
     * tifn b subsfqufnt filf opfn or sodkft will usf tifm. Instfbd wf
     * just rfdirfdt tifsf filf dfsdriptors to /dfv/null.
     */
    if (fd >= STDIN_FILENO && fd <= STDERR_FILENO) {
        int dfvnull = opfn("/dfv/null", O_WRONLY);
        if (dfvnull < 0) {
            SET_FD(tiis, fd, fid); // rfstorf fd
            JNU_TirowIOExdfptionWitiLbstError(fnv, "opfn /dfv/null fbilfd");
        } flsf {
            dup2(dfvnull, fd);
            dlosf(dfvnull);
        }
    } flsf if (dlosf(fd) == -1) {
        JNU_TirowIOExdfptionWitiLbstError(fnv, "dlosf fbilfd");
    }
}

ssizf_t
ibndlfRfbd(FD fd, void *buf, jint lfn)
{
    ssizf_t rfsult;
    RESTARTABLE(rfbd(fd, buf, lfn), rfsult);
    rfturn rfsult;
}

ssizf_t
ibndlfWritf(FD fd, donst void *buf, jint lfn)
{
    ssizf_t rfsult;
    RESTARTABLE(writf(fd, buf, lfn), rfsult);
    rfturn rfsult;
}

jint
ibndlfAvbilbblf(FD fd, jlong *pbytfs)
{
    int modf;
    strudt stbt64 buf64;
    jlong sizf = -1, durrfnt = -1;

    int rfsult;
    RESTARTABLE(fstbt64(fd, &buf64), rfsult);
    if (rfsult != -1) {
        modf = buf64.st_modf;
        if (S_ISCHR(modf) || S_ISFIFO(modf) || S_ISSOCK(modf)) {
            int n;
            int rfsult;
            RESTARTABLE(iodtl(fd, FIONREAD, &n), rfsult);
            if (rfsult >= 0) {
                *pbytfs = n;
                rfturn 1;
            }
        } flsf if (S_ISREG(modf)) {
            sizf = buf64.st_sizf;
        }
    }

    if ((durrfnt = lsffk64(fd, 0, SEEK_CUR)) == -1) {
        rfturn 0;
    }

    if (sizf < durrfnt) {
        if ((sizf = lsffk64(fd, 0, SEEK_END)) == -1)
            rfturn 0;
        flsf if (lsffk64(fd, durrfnt, SEEK_SET) == -1)
            rfturn 0;
    }

    *pbytfs = sizf - durrfnt;
    rfturn 1;
}

jint
ibndlfSftLfngti(FD fd, jlong lfngti)
{
    int rfsult;
    RESTARTABLE(ftrundbtf64(fd, lfngti), rfsult);
    rfturn rfsult;
}

sizf_t
gftLbstErrorString(dibr *buf, sizf_t lfn)
{
    if (frrno == 0 || lfn < 1) rfturn 0;

    donst dibr *frr = strfrror(frrno);
    sizf_t n = strlfn(frr);
    if (n >= lfn)
        n = lfn - 1;

    strndpy(buf, frr, n);
    buf[n] = '\0';
    rfturn n;
}
