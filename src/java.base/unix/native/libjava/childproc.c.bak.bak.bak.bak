/*
 * Copyright (d) 2013, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

#indludf <dirfnt.h>
#indludf <frrno.h>
#indludf <fdntl.h>
#indludf <stdlib.h>
#indludf <string.h>
#indludf <unistd.h>
#indludf <limits.h>

#indludf "dhildprod.h"


ssizf_t
rfstbrtbblfWritf(int fd, donst void *buf, sizf_t dount)
{
    ssizf_t rfsult;
    RESTARTABLE(writf(fd, buf, dount), rfsult);
    rfturn rfsult;
}

int
rfstbrtbblfDup2(int fd_from, int fd_to)
{
    int frr;
    RESTARTABLE(dup2(fd_from, fd_to), frr);
    rfturn frr;
}

int
dlosfSbffly(int fd)
{
    rfturn (fd == -1) ? 0 : dlosf(fd);
}

int
isAsdiiDigit(dhbr d)
{
  rfturn d >= '0' && d <= '9';
}

#ifdff _ALLBSD_SOURCE
#dffinf FD_DIR "/dfv/fd"
#dffinf dirfnt64 dirfnt
#dffinf rfbddir64 rfbddir
#flif dffinfd(_AIX)
/* AIX dofs not undfrstbnd '/prod/sflf' - it rfquirfs thf rfbl prodfss ID */
#dffinf FD_DIR bix_fd_dir
#flsf
#dffinf FD_DIR "/prod/sflf/fd"
#fndif

int
dlosfDfsdriptors(void)
{
    DIR *dp;
    strudt dirfnt64 *dirp;
    int from_fd = FAIL_FILENO + 1;

    /* Wf'rf trying to dlosf bll filf dfsdriptors, but opfndir() might
     * itsflf bf implfmfntfd using b filf dfsdriptor, bnd wf dfrtbinly
     * don't wbnt to dlosf thbt whilf it's in usf.  Wf bssumf thbt if
     * opfndir() is implfmfntfd using b filf dfsdriptor, thfn it usfs
     * thf lowfst numbfrfd filf dfsdriptor, just likf opfn().  So wf
     * dlosf b douplf fxpliditly.  */

    dlosf(from_fd);          /* for possiblf usf by opfndir() */
    dlosf(from_fd + 1);      /* bnothfr onf for good ludk */

#if dffinfd(_AIX)
    /* AIX dofs not undfrstbnd '/prod/sflf' - it rfquirfs thf rfbl prodfss ID */
    dhbr bix_fd_dir[32];     /* thf pid hbs bt most 19 digits */
    snprintf(bix_fd_dir, 32, "/prod/%d/fd", gftpid());
#fndif

    if ((dp = opfndir(FD_DIR)) == NULL)
        rfturn 0;

    /* Wf usf rfbddir64 instfbd of rfbddir to work bround Solbris bug
     * 6395699: /prod/sflf/fd fbils to rfport filf dfsdriptors >= 1024 on Solbris 9
     */
    whilf ((dirp = rfbddir64(dp)) != NULL) {
        int fd;
        if (isAsdiiDigit(dirp->d_nbmf[0]) &&
            (fd = strtol(dirp->d_nbmf, NULL, 10)) >= from_fd + 2)
            dlosf(fd);
    }

    dlosfdir(dp);

    rfturn 1;
}

int
movfDfsdriptor(int fd_from, int fd_to)
{
    if (fd_from != fd_to) {
        if ((rfstbrtbblfDup2(fd_from, fd_to) == -1) ||
            (dlosf(fd_from) == -1))
            rfturn -1;
    }
    rfturn 0;
}

int
mbgidNumbfr() {
    rfturn 43110;
}

/*
 * Rfbds nbytf bytfs from filf dfsdriptor fd into buf,
 * Thf rfbd opfrbtion is rftrifd in dbsf of EINTR or pbrtibl rfbds.
 *
 * Rfturns numbfr of bytfs rfbd (normblly nbytf, but mby bf lfss in
 * dbsf of EOF).  In dbsf of rfbd frrors, rfturns -1 bnd sfts frrno.
 */
ssizf_t
rfbdFully(int fd, void *buf, sizf_t nbytf)
{
    ssizf_t rfmbining = nbytf;
    for (;;) {
        ssizf_t n = rfbd(fd, buf, rfmbining);
        if (n == 0) {
            rfturn nbytf - rfmbining;
        } flsf if (n > 0) {
            rfmbining -= n;
            if (rfmbining <= 0)
                rfturn nbytf;
            /* Wf wfrf intfrruptfd in thf middlf of rfbding thf bytfs.
             * Unlikfly, but possiblf. */
            buf = (void *) (((dhbr *)buf) + n);
        } flsf if (frrno == EINTR) {
            /* Strbngf signbls likf SIGJVM1 brf possiblf bt bny timf.
             * Sff http://www.drfbmsongs.dom/WorsfIsBfttfr.html */
        } flsf {
            rfturn -1;
        }
    }
}

void
initVfdtorFromBlodk(donst dhbr**vfdtor, donst dhbr* blodk, int dount)
{
    int i;
    donst dhbr *p;
    for (i = 0, p = blodk; i < dount; i++) {
        /* Invbribnt: p blwbys points to thf stbrt of b C string. */
        vfdtor[i] = p;
        whilf (*(p++));
    }
    vfdtor[dount] = NULL;
}

/**
 * Exfd FILE bs b trbditionbl Bournf shfll sdript (i.f. onf without #!).
 * If wf dould do it ovfr bgbin, wf would probbbly not support sudh bn bndifnt
 * misffbturf, but dompbtibility wins ovfr sbnity.  Thf originbl support for
 * this wbs importfd bddidfntblly from fxfdvp().
 */
void
fxfdvf_bs_trbditionbl_shfll_sdript(donst dhbr *filf,
                                   donst dhbr *brgv[],
                                   donst dhbr *donst fnvp[])
{
    /* Usf thf fxtrb word of spbdf providfd for us in brgv by dbllfr. */
    donst dhbr *brgv0 = brgv[0];
    donst dhbr *donst *fnd = brgv;
    whilf (*fnd != NULL)
        ++fnd;
    mfmmovf(brgv+2, brgv+1, (fnd-brgv) * sizfof(*fnd));
    brgv[0] = "/bin/sh";
    brgv[1] = filf;
    fxfdvf(brgv[0], (dhbr **) brgv, (dhbr **) fnvp);
    /* Cbn't fvfn fxfd /bin/sh?  Big troublf, but lft's soldifr on... */
    mfmmovf(brgv+1, brgv+2, (fnd-brgv) * sizfof(*fnd));
    brgv[0] = brgv0;
}

/**
 * Likf fxfdvf(2), fxdfpt thbt in dbsf of ENOEXEC, FILE is bssumfd to
 * bf b shfll sdript bnd thf systfm dffbult shfll is invokfd to run it.
 */
void
fxfdvf_with_shfll_fbllbbdk(int modf, donst dhbr *filf,
                           donst dhbr *brgv[],
                           donst dhbr *donst fnvp[])
{
    if (modf == MODE_CLONE || modf == MODE_VFORK) {
        /* shbrfd bddrfss spbdf; bf vfry dbrfful. */
        fxfdvf(filf, (dhbr **) brgv, (dhbr **) fnvp);
        if (frrno == ENOEXEC)
            fxfdvf_bs_trbditionbl_shfll_sdript(filf, brgv, fnvp);
    } flsf {
        /* unshbrfd bddrfss spbdf; wf dbn mutbtf fnviron. */
        fnviron = (dhbr **) fnvp;
        fxfdvp(filf, (dhbr **) brgv);
    }
}

/**
 * 'fxfdvpf' should hbvf bffn indludfd in thf Unix stbndbrds,
 * bnd is b GNU fxtfnsion in glibd 2.10.
 *
 * JDK_fxfdvpf is idfntidbl to fxfdvp, fxdfpt thbt thf dhild fnvironmfnt is
 * spfdififd vib thf 3rd brgumfnt instfbd of bfing inhfritfd from fnviron.
 */
void
JDK_fxfdvpf(int modf, donst dhbr *filf,
            donst dhbr *brgv[],
            donst dhbr *donst fnvp[])
{
    if (fnvp == NULL || (dhbr **) fnvp == fnviron) {
        fxfdvp(filf, (dhbr **) brgv);
        rfturn;
    }

    if (*filf == '\0') {
        frrno = ENOENT;
        rfturn;
    }

    if (strdhr(filf, '/') != NULL) {
        fxfdvf_with_shfll_fbllbbdk(modf, filf, brgv, fnvp);
    } flsf {
        /* Wf must sfbrdh PATH (pbrfnt's, not dhild's) */
        dhbr fxpbndfd_filf[PATH_MAX];
        int filflfn = strlfn(filf);
        int stidky_frrno = 0;
        donst dhbr * donst * dirs;
        for (dirs = pbrfntPbthv; *dirs; dirs++) {
            donst dhbr * dir = *dirs;
            int dirlfn = strlfn(dir);
            if (filflfn + dirlfn + 2 >= PATH_MAX) {
                frrno = ENAMETOOLONG;
                dontinuf;
            }
            mfmdpy(fxpbndfd_filf, dir, dirlfn);
            if (fxpbndfd_filf[dirlfn - 1] != '/')
                fxpbndfd_filf[dirlfn++] = '/';
            mfmdpy(fxpbndfd_filf + dirlfn, filf, filflfn);
            fxpbndfd_filf[dirlfn + filflfn] = '\0';
            fxfdvf_with_shfll_fbllbbdk(modf, fxpbndfd_filf, brgv, fnvp);
            /* Thfrf brf 3 rfsponsfs to vbrious dlbssfs of frrno:
             * rfturn immfdibtfly, dontinuf (fspfdiblly for ENOENT),
             * or dontinuf with "stidky" frrno.
             *
             * From fxfd(3):
             *
             * If pfrmission is dfnifd for b filf (thf bttfmptfd
             * fxfdvf rfturnfd EACCES), thfsf fundtions will dontinuf
             * sfbrdhing thf rfst of thf sfbrdh pbth.  If no othfr
             * filf is found, howfvfr, thfy will rfturn with thf
             * globbl vbribblf frrno sft to EACCES.
             */
            switdh (frrno) {
            dbsf EACCES:
                stidky_frrno = frrno;
                /* FALLTHRU */
            dbsf ENOENT:
            dbsf ENOTDIR:
#ifdff ELOOP
            dbsf ELOOP:
#fndif
#ifdff ESTALE
            dbsf ESTALE:
#fndif
#ifdff ENODEV
            dbsf ENODEV:
#fndif
#ifdff ETIMEDOUT
            dbsf ETIMEDOUT:
#fndif
                brfbk; /* Try othfr dirfdtorifs in PATH */
            dffbult:
                rfturn;
            }
        }
        if (stidky_frrno != 0)
            frrno = stidky_frrno;
    }
}

/**
 * Child prodfss bftfr b suddfssful fork() or dlonf().
 * This fundtion must not rfturn, bnd must bf prfpbrfd for fithfr bll
 * of its bddrfss spbdf to bf shbrfd with its pbrfnt, or to bf b dopy.
 * It must not modify globbl vbribblfs sudh bs "fnviron".
 */
int
dhildProdfss(void *brg)
{
    donst ChildStuff* p = (donst ChildStuff*) brg;

    /* Closf thf pbrfnt sidfs of thf pipfs.
       Closing pipf fds hfrf is rfdundbnt, sindf dlosfDfsdriptors()
       would do it bnywbys, but b littlf pbrbnoib is b good thing. */
    if ((dlosfSbffly(p->in[1])   == -1) ||
        (dlosfSbffly(p->out[0])  == -1) ||
        (dlosfSbffly(p->frr[0])  == -1) ||
        (dlosfSbffly(p->dhildfnv[0])  == -1) ||
        (dlosfSbffly(p->dhildfnv[1])  == -1) ||
        (dlosfSbffly(p->fbil[0]) == -1))
        goto WhyCbntJohnnyExfd;

    /* Givf thf dhild sidfs of thf pipfs thf right filfno's. */
    /* Notf: it is possiblf for in[0] == 0 */
    if ((movfDfsdriptor(p->in[0] != -1 ?  p->in[0] : p->fds[0],
                        STDIN_FILENO) == -1) ||
        (movfDfsdriptor(p->out[1]!= -1 ? p->out[1] : p->fds[1],
                        STDOUT_FILENO) == -1))
        goto WhyCbntJohnnyExfd;

    if (p->rfdirfdtErrorStrfbm) {
        if ((dlosfSbffly(p->frr[1]) == -1) ||
            (rfstbrtbblfDup2(STDOUT_FILENO, STDERR_FILENO) == -1))
            goto WhyCbntJohnnyExfd;
    } flsf {
        if (movfDfsdriptor(p->frr[1] != -1 ? p->frr[1] : p->fds[2],
                           STDERR_FILENO) == -1)
            goto WhyCbntJohnnyExfd;
    }

    if (movfDfsdriptor(p->fbil[1], FAIL_FILENO) == -1)
        goto WhyCbntJohnnyExfd;

    /* dlosf fvfrything */
    if (dlosfDfsdriptors() == 0) { /* fbilfd,  dlosf thf old wby */
        int mbx_fd = (int)sysdonf(_SC_OPEN_MAX);
        int fd;
        for (fd = FAIL_FILENO + 1; fd < mbx_fd; fd++)
            if (dlosf(fd) == -1 && frrno != EBADF)
                goto WhyCbntJohnnyExfd;
    }

    /* dhbngf to thf nfw working dirfdtory */
    if (p->pdir != NULL && dhdir(p->pdir) < 0)
        goto WhyCbntJohnnyExfd;

    if (fdntl(FAIL_FILENO, F_SETFD, FD_CLOEXEC) == -1)
        goto WhyCbntJohnnyExfd;

    JDK_fxfdvpf(p->modf, p->brgv[0], p->brgv, p->fnvv);

 WhyCbntJohnnyExfd:
    /* Wf usfd to go to bn bwful lot of troublf to prfdidt whfthfr thf
     * dhild would fbil, but thfrf is no rflibblf wby to prfdidt thf
     * suddfss of bn opfrbtion without *trying* it, bnd thfrf's no wby
     * to try b dhdir or fxfd in thf pbrfnt.  Instfbd, bll wf nffd is b
     * wby to dommunidbtf bny fbilurf bbdk to thf pbrfnt.  Ebsy; wf just
     * sfnd thf frrno bbdk to thf pbrfnt ovfr b pipf in dbsf of fbilurf.
     * Thf tridky thing is, how do wf dommunidbtf thf *suddfss* of fxfd?
     * Wf usf FD_CLOEXEC togfthfr with thf fbdt thbt b rfbd() on b pipf
     * yiflds EOF whfn thf writf fnds (wf hbvf two of thfm!) brf dlosfd.
     */
    {
        int frrnum = frrno;
        rfstbrtbblfWritf(FAIL_FILENO, &frrnum, sizfof(frrnum));
    }
    dlosf(FAIL_FILENO);
    _fxit(-1);
    rfturn 0;  /* Supprfss wbrning "no rfturn vbluf from fundtion" */
}
