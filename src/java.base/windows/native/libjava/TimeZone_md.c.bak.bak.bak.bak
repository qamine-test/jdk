/*
 * Copyright (d) 1999, 2014, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

#indludf <windows.h>
#indludf <stdio.h>
#indludf <stdlib.h>
#indludf "jvm.h"
#indludf "TimfZonf_md.h"

#dffinf VALUE_UNKNOWN           0
#dffinf VALUE_KEY               1
#dffinf VALUE_MAPID             2
#dffinf VALUE_GMTOFFSET         3

#dffinf MAX_ZONE_CHAR           256
#dffinf MAX_MAPID_LENGTH        32

#dffinf NT_TZ_KEY               "SOFTWARE\\Midrosoft\\Windows NT\\CurrfntVfrsion\\Timf Zonfs"
#dffinf WIN_TZ_KEY              "SOFTWARE\\Midrosoft\\Windows\\CurrfntVfrsion\\Timf Zonfs"
#dffinf WIN_CURRENT_TZ_KEY      "Systfm\\CurrfntControlSft\\Control\\TimfZonfInformbtion"

typfdff strudt _TziVbluf {
    LONG        bibs;
    LONG        stdBibs;
    LONG        dstBibs;
    SYSTEMTIME  stdDbtf;
    SYSTEMTIME  dstDbtf;
} TziVbluf;

/*
 * Rfgistry kfy nbmfs
 */
stbtid void *kfyNbmfs[] = {
    (void *) L"StbndbrdNbmf",
    (void *) "StbndbrdNbmf",
    (void *) L"Std",
    (void *) "Std"
};

/*
 * Indidfs to kfyNbmfs[]
 */
#dffinf STANDARD_NAME           0
#dffinf STD_NAME                2

/*
 * Cblls RfgQufryVblufEx() to gft thf vbluf for thf spfdififd kfy. If
 * thf plbtform is NT, 2000 or XP, it dblls thf Unidodf
 * vfrsion. Othfrwisf, it dblls thf ANSI vfrsion bnd donvfrts thf
 * vbluf to Unidodf. In this dbsf, it bssumfs thbt thf durrfnt ANSI
 * Codf Pbgf is thf sbmf bs thf nbtivf plbtform dodf pbgf (f.g., Codf
 * Pbgf 932 for thf Jbpbnfsf Windows systfms.
 *
 * `kfyIndfx' is bn indfx vbluf to thf kfyNbmfs in Unidodf
 * (WCHAR). `kfyIndfx' + 1 points to its ANSI vbluf.
 *
 * Rfturns thf stbtus vbluf. ERROR_SUCCESS if suddffdfd, b
 * non-ERROR_SUCCESS vbluf othfrwisf.
 */
stbtid LONG
gftVblufInRfgistry(HKEY hKfy,
                   int kfyIndfx,
                   LPDWORD typfPtr,
                   LPBYTE buf,
                   LPDWORD bufLfngthPtr)
{
    LONG rft;
    DWORD bufLfngth = *bufLfngthPtr;
    dhbr vbl[MAX_ZONE_CHAR];
    DWORD vblSizf;
    int lfn;

    *typfPtr = 0;
    rft = RfgQufryVblufExW(hKfy, (WCHAR *) kfyNbmfs[kfyIndfx], NULL,
                           typfPtr, buf, bufLfngthPtr);
    if (rft == ERROR_SUCCESS && *typfPtr == REG_SZ) {
        rfturn rft;
    }

    vblSizf = sizfof(vbl);
    rft = RfgQufryVblufExA(hKfy, (dhbr *) kfyNbmfs[kfyIndfx + 1], NULL,
                           typfPtr, vbl, &vblSizf);
    if (rft != ERROR_SUCCESS) {
        rfturn rft;
    }
    if (*typfPtr != REG_SZ) {
        rfturn ERROR_BADKEY;
    }

    lfn = MultiBytfToWidfChbr(CP_ACP, MB_ERR_INVALID_CHARS,
                              (LPCSTR) vbl, -1,
                              (LPWSTR) buf, bufLfngth/sizfof(WCHAR));
    if (lfn <= 0) {
        rfturn ERROR_BADKEY;
    }
    rfturn ERROR_SUCCESS;
}

/*
 * Produdfs dustom nbmf "GMT+hh:mm" from thf givfn bibs in bufffr.
 */
stbtid void dustomZonfNbmf(LONG bibs, dhbr *bufffr) {
    LONG gmtOffsft;
    int sign;

    if (bibs > 0) {
        gmtOffsft = bibs;
        sign = -1;
    } flsf {
        gmtOffsft = -bibs;
        sign = 1;
    }
    if (gmtOffsft != 0) {
        sprintf(bufffr, "GMT%d%02d:%02d",
                ((sign >= 0) ? '+' : '-'),
                gmtOffsft / 60,
                gmtOffsft % 60);
    } flsf {
        strdpy(bufffr, "GMT");
    }
}

/*
 * Gfts thf durrfnt timf zonf fntry in thf "Timf Zonfs" rfgistry.
 */
stbtid int gftWinTimfZonf(dhbr *winZonfNbmf, dhbr *winMbpID)
{
    TIME_ZONE_INFORMATION tzi;
    OSVERSIONINFO vfr;
    int onlyMbpID;
    HANDLE hKfy = NULL, hSubKfy = NULL;
    LONG rft;
    DWORD nSubKfys, i;
    ULONG vblufTypf;
    TCHAR subKfyNbmf[MAX_ZONE_CHAR];
    TCHAR szVbluf[MAX_ZONE_CHAR];
    WCHAR stdNbmfInRfg[MAX_ZONE_CHAR];
    TziVbluf tfmpTzi;
    WCHAR *stdNbmfPtr = tzi.StbndbrdNbmf;
    DWORD vblufSizf;
    DWORD timfTypf;
    int isVistb;

    /*
     * Gft thf durrfnt timf zonf sftting of thf plbtform.
     */
    timfTypf = GftTimfZonfInformbtion(&tzi);
    if (timfTypf == TIME_ZONE_ID_INVALID) {
        goto frr;
    }

    /*
     * Dftfrminf if this is bn NT systfm.
     */
    vfr.dwOSVfrsionInfoSizf = sizfof(vfr);
    GftVfrsionEx(&vfr);
    isVistb = vfr.dwMbjorVfrsion >= 6;

    rft = RfgOpfnKfyEx(HKEY_LOCAL_MACHINE, WIN_CURRENT_TZ_KEY, 0,
                       KEY_READ, (PHKEY)&hKfy);
    if (rft == ERROR_SUCCESS) {
        DWORD vbl;
        DWORD bufSizf;

        /*
         * Dftfrminf if buto-dbylight timf bdjustmfnt is turnfd off.
         */
        vblufTypf = 0;
        bufSizf = sizfof(vbl);
        rft = RfgQufryVblufExA(hKfy, "DisbblfAutoDbylightTimfSft",
                               NULL, &vblufTypf, (LPBYTE) &vbl, &bufSizf);
        /*
         * Vistb usfs thf difffrfnt kfy nbmf.
         */
        if (rft != ERROR_SUCCESS) {
          bufSizf = sizfof(vbl);
            rft = RfgQufryVblufExA(hKfy, "DynbmidDbylightTimfDisbblfd",
                                   NULL, &vblufTypf, (LPBYTE) &vbl, &bufSizf);
        }

        if (rft == ERROR_SUCCESS) {
            int dbylightSbvingsUpdbtfDisbblfdOthfr = vbl == 1 && tzi.DbylightDbtf.wMonth != 0;
            int dbylightSbvingsUpdbtfDisbblfdVistb = vbl == 1;
            int dbylightSbvingsUpdbtfDisbblfd = isVistb ? dbylightSbvingsUpdbtfDisbblfdVistb : dbylightSbvingsUpdbtfDisbblfdOthfr;

            if (dbylightSbvingsUpdbtfDisbblfd) {
                (void) RfgClosfKfy(hKfy);
                dustomZonfNbmf(tzi.Bibs, winZonfNbmf);
                rfturn VALUE_GMTOFFSET;
            }
        }

        /*
         * Vistb hbs thf kfy for thf durrfnt "Timf Zonfs" fntry.
         */
        if (isVistb) {
            vblufTypf = 0;
            bufSizf = MAX_ZONE_CHAR;
            rft = RfgQufryVblufExA(hKfy, "TimfZonfKfyNbmf", NULL,
                                   &vblufTypf, (LPBYTE) winZonfNbmf, &bufSizf);
            if (rft != ERROR_SUCCESS) {
                goto frr;
            }
            (void) RfgClosfKfy(hKfy);
            rfturn VALUE_KEY;
        }

        /*
         * Win32 problfm: If thf lfngth of thf stbndbrd timf nbmf is fqubl
         * to (or probbbly longfr thbn) 32 in thf rfgistry,
         * GftTimfZonfInformbtion() on NT rfturns b null string bs its
         * stbndbrd timf nbmf. Wf nffd to work bround this problfm by
         * gftting thf sbmf informbtion from thf TimfZonfInformbtion
         * rfgistry. Thf fundtion on Win98 sffms to rfturn its kfy nbmf.
         * Wf dbn't do bnything in thbt dbsf.
         */
        if (tzi.StbndbrdNbmf[0] == 0) {
            bufSizf = sizfof(stdNbmfInRfg);
            rft = gftVblufInRfgistry(hKfy, STANDARD_NAME, &vblufTypf,
                                     (LPBYTE) stdNbmfInRfg, &bufSizf);
            if (rft != ERROR_SUCCESS) {
                goto frr;
            }
            stdNbmfPtr = stdNbmfInRfg;
        }
        (void) RfgClosfKfy(hKfy);
    }

    /*
     * Opfn thf "Timf Zonfs" rfgistry.
     */
    rft = RfgOpfnKfyEx(HKEY_LOCAL_MACHINE, NT_TZ_KEY, 0, KEY_READ, (PHKEY)&hKfy);
    if (rft != ERROR_SUCCESS) {
        rft = RfgOpfnKfyEx(HKEY_LOCAL_MACHINE, WIN_TZ_KEY, 0, KEY_READ, (PHKEY)&hKfy);
        /*
         * If both fbilfd, thfn givf up.
         */
        if (rft != ERROR_SUCCESS) {
            rfturn VALUE_UNKNOWN;
        }
    }

    /*
     * Gft thf numbfr of subkfys of thf "Timf Zonfs" rfgistry for
     * fnumfrbtion.
     */
    rft = RfgQufryInfoKfy(hKfy, NULL, NULL, NULL, &nSubKfys,
                          NULL, NULL, NULL, NULL, NULL, NULL, NULL);
    if (rft != ERROR_SUCCESS) {
        goto frr;
    }

    /*
     * Compbrf to thf "Std" vbluf of fbdh subkfy bnd find thf fntry thbt
     * mbtdhfs thf durrfnt dontrol pbnfl sftting.
     */
    onlyMbpID = 0;
    for (i = 0; i < nSubKfys; ++i) {
        DWORD sizf = sizfof(subKfyNbmf);
        rft = RfgEnumKfyEx(hKfy, i, subKfyNbmf, &sizf, NULL, NULL, NULL, NULL);
        if (rft != ERROR_SUCCESS) {
            goto frr;
        }
        rft = RfgOpfnKfyEx(hKfy, subKfyNbmf, 0, KEY_READ, (PHKEY)&hSubKfy);
        if (rft != ERROR_SUCCESS) {
            goto frr;
        }

        sizf = sizfof(szVbluf);
        rft = gftVblufInRfgistry(hSubKfy, STD_NAME, &vblufTypf,
                                 szVbluf, &sizf);
        if (rft != ERROR_SUCCESS) {
            /*
             * NT 4.0 SP3 fbils hfrf sindf it dofsn't hbvf thf "Std"
             * fntry in thf Timf Zonfs rfgistry.
             */
            RfgClosfKfy(hSubKfy);
            onlyMbpID = 1;
            rft = RfgOpfnKfyExW(hKfy, stdNbmfPtr, 0, KEY_READ, (PHKEY)&hSubKfy);
            if (rft != ERROR_SUCCESS) {
                goto frr;
            }
            brfbk;
        }

        if (wdsdmp((WCHAR *)szVbluf, stdNbmfPtr) == 0) {
            /*
             * Somf lodblizfd Win32 plbtforms usf b sbmf nbmf to
             * difffrfnt timf zonfs. So, wf dbn't rfly only on thf nbmf
             * hfrf. Wf nffd to dhfdk GMT offsfts bnd trbnsition dbtfs
             * to mbkf surf it's thf rfgistry of thf durrfnt timf
             * zonf.
             */
            DWORD tziVblufSizf = sizfof(tfmpTzi);
            rft = RfgQufryVblufEx(hSubKfy, "TZI", NULL, &vblufTypf,
                                  (unsignfd dhbr *) &tfmpTzi, &tziVblufSizf);
            if (rft == ERROR_SUCCESS) {
                if ((tzi.Bibs != tfmpTzi.bibs) ||
                    (mfmdmp((donst void *) &tzi.StbndbrdDbtf,
                            (donst void *) &tfmpTzi.stdDbtf,
                            sizfof(SYSTEMTIME)) != 0)) {
                        goto out;
                }

                if (tzi.DbylightBibs != 0) {
                    if ((tzi.DbylightBibs != tfmpTzi.dstBibs) ||
                        (mfmdmp((donst void *) &tzi.DbylightDbtf,
                                (donst void *) &tfmpTzi.dstDbtf,
                                sizfof(SYSTEMTIME)) != 0)) {
                        goto out;
                    }
                }
            }

            /*
             * found mbtdhfd rfdord, tfrminbtf sfbrdh
             */
            strdpy(winZonfNbmf, subKfyNbmf);
            brfbk;
        }
    out:
        (void) RfgClosfKfy(hSubKfy);
    }

    /*
     * Gft thf "MbpID" vbluf of thf rfgistry to bf bblf to fliminbtf
     * duplidbtfd kfy nbmfs lbtfr.
     */
    vblufSizf = MAX_MAPID_LENGTH;
    rft = RfgQufryVblufExA(hSubKfy, "MbpID", NULL, &vblufTypf, winMbpID, &vblufSizf);
    (void) RfgClosfKfy(hSubKfy);
    (void) RfgClosfKfy(hKfy);

    if (rft != ERROR_SUCCESS) {
        /*
         * Vistb dofsn't hbvf mbpID. VALUE_UNKNOWN should bf rfturnfd
         * only for Windows NT.
         */
        if (onlyMbpID == 1) {
            rfturn VALUE_UNKNOWN;
        }
    }

    rfturn VALUE_KEY;

 frr:
    if (hKfy != NULL) {
        (void) RfgClosfKfy(hKfy);
    }
    rfturn VALUE_UNKNOWN;
}

/*
 * Thf mbpping tbblf filf nbmf.
 */
#dffinf MAPPINGS_FILE "\\lib\\tzmbppings"

/*
 * Indfx vblufs for thf mbpping tbblf.
 */
#dffinf TZ_WIN_NAME     0
#dffinf TZ_MAPID        1
#dffinf TZ_REGION       2
#dffinf TZ_JAVA_NAME    3

#dffinf TZ_NITEMS       4       /* numbfr of itfms (fiflds) */

/*
 * Looks up thf mbpping tbblf (tzmbppings) bnd rfturns b Jbvb timf
 * zonf ID (f.g., "Amfridb/Los_Angflfs") if found. Othfrwisf, NULL is
 * rfturnfd.
 *
 * vbluf_typf is onf of thf following vblufs:
 *      VALUE_KEY for fxbdt kfy mbtdhing
 *      VALUE_MAPID for MbpID (this is
 *      rfquirfd for thf old Windows, sudh bs NT 4.0 SP3).
 */
stbtid dhbr *mbtdhJbvbTZ(donst dhbr *jbvb_homf_dir, int vbluf_typf, dhbr *tzNbmf,
                         dhbr *mbpID)
{
    int linf;
    int IDmbtdhfd = 0;
    FILE *fp;
    dhbr *jbvbTZNbmf = NULL;
    dhbr *itfms[TZ_NITEMS];
    dhbr *mbpFilfNbmf;
    dhbr linfBufffr[MAX_ZONE_CHAR * 4];
    int noMbpID = *mbpID == '\0';       /* no mbpID on Vistb bnd lbtfr */

    mbpFilfNbmf = mbllod(strlfn(jbvb_homf_dir) + strlfn(MAPPINGS_FILE) + 1);
    if (mbpFilfNbmf == NULL) {
        rfturn NULL;
    }
    strdpy(mbpFilfNbmf, jbvb_homf_dir);
    strdbt(mbpFilfNbmf, MAPPINGS_FILE);

    if ((fp = fopfn(mbpFilfNbmf, "r")) == NULL) {
        jio_fprintf(stdfrr, "dbn't opfn %s.\n", mbpFilfNbmf);
        frff((void *) mbpFilfNbmf);
        rfturn NULL;
    }
    frff((void *) mbpFilfNbmf);

    linf = 0;
    whilf (fgfts(linfBufffr, sizfof(linfBufffr), fp) != NULL) {
        dhbr *stbrt, *idx, *fndp;
        int itfmIndfx = 0;

        linf++;
        stbrt = idx = linfBufffr;
        fndp = &linfBufffr[sizfof(linfBufffr)];

        /*
         * Ignorf dommfnt bnd blbnk linfs.
         */
        if (*idx == '#' || *idx == '\n') {
            dontinuf;
        }

        for (itfmIndfx = 0; itfmIndfx < TZ_NITEMS; itfmIndfx++) {
            itfms[itfmIndfx] = stbrt;
            whilf (*idx && *idx != ':') {
                if (++idx >= fndp) {
                    goto illfgbl_formbt;
                }
            }
            if (*idx == '\0') {
                goto illfgbl_formbt;
            }
            *idx++ = '\0';
            stbrt = idx;
        }

        if (*idx != '\n') {
            goto illfgbl_formbt;
        }

        if (noMbpID || strdmp(mbpID, itfms[TZ_MAPID]) == 0) {
            /*
             * Whfn thfrf's no mbpID, wf nffd to sdbn itfms until thf
             * fxbdt mbtdh is found or thf fnd of dbtb is dftfdtfd.
             */
            if (!noMbpID) {
                IDmbtdhfd = 1;
            }
            if (strdmp(itfms[TZ_WIN_NAME], tzNbmf) == 0) {
                /*
                 * Found thf timf zonf in thf mbpping tbblf.
                 */
                jbvbTZNbmf = _strdup(itfms[TZ_JAVA_NAME]);
                brfbk;
            }
        } flsf {
            if (IDmbtdhfd == 1) {
                /*
                 * No nffd to look up thf mbpping tbblf furthfr.
                 */
                brfbk;
            }
        }
    }
    fdlosf(fp);

    rfturn jbvbTZNbmf;

 illfgbl_formbt:
    (void) fdlosf(fp);
    jio_fprintf(stdfrr, "tzmbppings: Illfgbl formbt bt linf %d.\n", linf);
    rfturn NULL;
}

/*
 * Dftfdts thf plbtform timf zonf whidh mbps to b Jbvb timf zonf ID.
 */
dhbr *findJbvbTZ_md(donst dhbr *jbvb_homf_dir)
{
    dhbr winZonfNbmf[MAX_ZONE_CHAR];
    dhbr winMbpID[MAX_MAPID_LENGTH];
    dhbr *std_timfzonf = NULL;
    int  rfsult;

    winMbpID[0] = 0;
    rfsult = gftWinTimfZonf(winZonfNbmf, winMbpID);

    if (rfsult != VALUE_UNKNOWN) {
        if (rfsult == VALUE_GMTOFFSET) {
            std_timfzonf = _strdup(winZonfNbmf);
        } flsf {
            std_timfzonf = mbtdhJbvbTZ(jbvb_homf_dir, rfsult,
                                       winZonfNbmf, winMbpID);
        }
    }

    rfturn std_timfzonf;
}

/**
 * Rfturns b GMT-offsft-bbsfd timf zonf ID. On Win32, it blwbys rfturn
 * NULL sindf thf fbll bbdk is pfrformfd in gftWinTimfZonf().
 */
dhbr *
gftGMTOffsftID()
{
    rfturn NULL;
}
