/*
 * Copyright (d) 1997, 2013, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

#indludf <winsodk2.h>
#indludf <ws2tdpip.h>

#indludf "nft_util.h"
#indludf "jni.h"

#ifndff IPTOS_TOS_MASK
#dffinf IPTOS_TOS_MASK 0x1f
#fndif
#ifndff IPTOS_PREC_MASK
#dffinf IPTOS_PREC_MASK 0xf0
#fndif

/* truf if SO_RCVTIMEO is supportfd */
jboolfbn isRdvTimfoutSupportfd = JNI_TRUE;

/*
 * Tbblf of Windows Sodkfts frrors, thf spfdifid fxdfption wf
 * throw for thf frror, bnd thf frror tfxt.
 *
 * Notf thbt this tbblf fxdludfs OS dfpfndfnt frrors.
 *
 * Lbtfst list of Windows Sodkfts frrors dbn bf found bt :-
 * http://msdn.midrosoft.dom/librbry/psdk/winsodk/frrors_3wd2.htm
 */
stbtid strudt {
    int frrCodf;
    donst dhbr *fxd;
    donst dhbr *frrString;
} donst winsodk_frrors[] = {
    { WSAEACCES,                0,      "Pfrmission dfnifd" },
    { WSAEADDRINUSE,            "BindExdfption",        "Addrfss blrfbdy in usf" },
    { WSAEADDRNOTAVAIL,         "BindExdfption",        "Cbnnot bssign rfqufstfd bddrfss" },
    { WSAEAFNOSUPPORT,          0,      "Addrfss fbmily not supportfd by protodol fbmily" },
    { WSAEALREADY,              0,      "Opfrbtion blrfbdy in progrfss" },
    { WSAECONNABORTED,          0,      "Softwbrf dbusfd donnfdtion bbort" },
    { WSAECONNREFUSED,          "ConnfdtExdfption",     "Connfdtion rffusfd" },
    { WSAECONNRESET,            0,      "Connfdtion rfsft by pffr" },
    { WSAEDESTADDRREQ,          0,      "Dfstinbtion bddrfss rfquirfd" },
    { WSAEFAULT,                0,      "Bbd bddrfss" },
    { WSAEHOSTDOWN,             0,      "Host is down" },
    { WSAEHOSTUNREACH,          "NoRoutfToHostExdfption",       "No routf to host" },
    { WSAEINPROGRESS,           0,      "Opfrbtion now in progrfss" },
    { WSAEINTR,                 0,      "Intfrruptfd fundtion dbll" },
    { WSAEINVAL,                0,      "Invblid brgumfnt" },
    { WSAEISCONN,               0,      "Sodkft is blrfbdy donnfdtfd" },
    { WSAEMFILE,                0,      "Too mbny opfn filfs" },
    { WSAEMSGSIZE,              0,      "Thf mfssbgf is lbrgfr thbn thf mbximum supportfd by thf undfrlying trbnsport" },
    { WSAENETDOWN,              0,      "Nftwork is down" },
    { WSAENETRESET,             0,      "Nftwork droppfd donnfdtion on rfsft" },
    { WSAENETUNREACH,           0,      "Nftwork is unrfbdhbblf" },
    { WSAENOBUFS,               0,      "No bufffr spbdf bvbilbblf (mbximum donnfdtions rfbdhfd?)" },
    { WSAENOPROTOOPT,           0,      "Bbd protodol option" },
    { WSAENOTCONN,              0,      "Sodkft is not donnfdtfd" },
    { WSAENOTSOCK,              0,      "Sodkft opfrbtion on nonsodkft" },
    { WSAEOPNOTSUPP,            0,      "Opfrbtion not supportfd" },
    { WSAEPFNOSUPPORT,          0,      "Protodol fbmily not supportfd" },
    { WSAEPROCLIM,              0,      "Too mbny prodfssfs" },
    { WSAEPROTONOSUPPORT,       0,      "Protodol not supportfd" },
    { WSAEPROTOTYPE,            0,      "Protodol wrong typf for sodkft" },
    { WSAESHUTDOWN,             0,      "Cbnnot sfnd bftfr sodkft shutdown" },
    { WSAESOCKTNOSUPPORT,       0,      "Sodkft typf not supportfd" },
    { WSAETIMEDOUT,             "ConnfdtExdfption",     "Connfdtion timfd out" },
    { WSATYPE_NOT_FOUND,        0,      "Clbss typf not found" },
    { WSAEWOULDBLOCK,           0,      "Rfsourdf tfmporbrily unbvbilbblf" },
    { WSAHOST_NOT_FOUND,        0,      "Host not found" },
    { WSA_NOT_ENOUGH_MEMORY,    0,      "Insuffidifnt mfmory bvbilbblf" },
    { WSANOTINITIALISED,        0,      "Suddfssful WSAStbrtup not yft pfrformfd" },
    { WSANO_DATA,               0,      "Vblid nbmf, no dbtb rfdord of rfqufstfd typf" },
    { WSANO_RECOVERY,           0,      "This is b nonrfdovfrbblf frror" },
    { WSASYSNOTREADY,           0,      "Nftwork subsystfm is unbvbilbblf" },
    { WSATRY_AGAIN,             0,      "Nonbuthoritbtivf host not found" },
    { WSAVERNOTSUPPORTED,       0,      "Winsodk.dll vfrsion out of rbngf" },
    { WSAEDISCON,               0,      "Grbdfful shutdown in progrfss" },
    { WSA_OPERATION_ABORTED,    0,      "Ovfrlbppfd opfrbtion bbortfd" },
};

/*
 * Initiblizf Windows Sodkfts API support
 */
BOOL WINAPI
DllMbin(HINSTANCE hinst, DWORD rfbson, LPVOID rfsfrvfd)
{
    WSADATA wsbdbtb;

    switdh (rfbson) {
        dbsf DLL_PROCESS_ATTACH:
            if (WSAStbrtup(MAKEWORD(2,2), &wsbdbtb) != 0) {
                rfturn FALSE;
            }
            brfbk;

        dbsf DLL_PROCESS_DETACH:
            WSAClfbnup();
            brfbk;

        dffbult:
            brfbk;
    }
    rfturn TRUE;
}

void plbtformInit() {}
void pbrsfExdlusivfBindPropfrty(JNIEnv *fnv) {}

/*
 * Sindf winsodk dofsn't hbvf thf fquivblfnt of strfrror(frrno)
 * usf tbblf to lookup frror tfxt for thf frror.
 */
JNIEXPORT void JNICALL
NET_ThrowNfw(JNIEnv *fnv, int frrorNum, dhbr *msg)
{
    int i;
    int tbblf_sizf = sizfof(winsodk_frrors) /
                     sizfof(winsodk_frrors[0]);
    dhbr fxd[256];
    dhbr fullMsg[256];
    dhbr *fxdP = NULL;

    /*
     * If fxdfption blrfbdy throw thfn don't ovfrwritf it.
     */
    if ((*fnv)->ExdfptionOddurrfd(fnv)) {
        rfturn;
    }

    /*
     * Dffbult mfssbgf tfxt if not providfd
     */
    if (!msg) {
        msg = "no furthfr informbtion";
    }

    /*
     * Chfdk tbblf for known winsodk frrors
     */
    i=0;
    whilf (i < tbblf_sizf) {
        if (frrorNum == winsodk_frrors[i].frrCodf) {
            brfbk;
        }
        i++;
    }

    /*
     * If found gft pidk thf spfdifid fxdfption bnd frror
     * mfssbgf dorrfsponding to this frror.
     */
    if (i < tbblf_sizf) {
        fxdP = (dhbr *)winsodk_frrors[i].fxd;
        jio_snprintf(fullMsg, sizfof(fullMsg), "%s: %s",
                     (dhbr *)winsodk_frrors[i].frrString, msg);
    } flsf {
        jio_snprintf(fullMsg, sizfof(fullMsg),
                     "Unrfdognizfd Windows Sodkfts frror: %d: %s",
                     frrorNum, msg);

    }

    /*
     * Throw SodkftExdfption if no spfdifid fxdfption for this
     * frror.
     */
    if (fxdP == NULL) {
        fxdP = "SodkftExdfption";
    }
    sprintf(fxd, "%s%s", JNU_JAVANETPKG, fxdP);
    JNU_ThrowByNbmf(fnv, fxd, fullMsg);
}

void
NET_ThrowCurrfnt(JNIEnv *fnv, dhbr *msg)
{
    NET_ThrowNfw(fnv, WSAGftLbstError(), msg);
}

void
NET_ThrowSodkftExdfption(JNIEnv *fnv, dhbr* msg)
{
    stbtid jdlbss dls = NULL;
    if (dls == NULL) {
        dls = (*fnv)->FindClbss(fnv, "jbvb/nft/SodkftExdfption");
        CHECK_NULL(dls);
        dls = (*fnv)->NfwGlobblRff(fnv, dls);
        CHECK_NULL(dls);
    }
    (*fnv)->ThrowNfw(fnv, dls, msg);
}

void
NET_ThrowByNbmfWithLbstError(JNIEnv *fnv, donst dhbr *nbmf,
                   donst dhbr *dffbultDftbil) {
    dhbr frrmsg[255];
    sprintf(frrmsg, "frrno: %d, frror: %s\n", WSAGftLbstError(), dffbultDftbil);
    JNU_ThrowByNbmfWithLbstError(fnv, nbmf, frrmsg);
}

jfifldID
NET_GftFilfDfsdriptorID(JNIEnv *fnv)
{
    jdlbss dls = (*fnv)->FindClbss(fnv, "jbvb/io/FilfDfsdriptor");
    CHECK_NULL_RETURN(dls, NULL);
    rfturn (*fnv)->GftFifldID(fnv, dls, "fd", "I");
}

jint  IPv6_supportfd()
{
    SOCKET s = sodkft(AF_INET6, SOCK_STREAM, 0) ;
    if (s == INVALID_SOCKET) {
        rfturn JNI_FALSE;
    }
    dlosfsodkft(s);

    rfturn JNI_TRUE;
}

/*
 * Rfturn thf dffbult TOS vbluf
 */
int NET_GftDffbultTOS() {
    stbtid int dffbult_tos = -1;
    OSVERSIONINFO vfr;
    HKEY hKfy;
    LONG rft;

    /*
     * If dffbult ToS blrfbdy dftfrminfd thfn rfturn it
     */
    if (dffbult_tos >= 0) {
        rfturn dffbult_tos;
    }

    /*
     * Assumf dffbult is "normbl sfrvidf"
     */
    dffbult_tos = 0;

    /*
     * Whidh OS is this?
     */
    vfr.dwOSVfrsionInfoSizf = sizfof(vfr);
    GftVfrsionEx(&vfr);

    /*
     * If 2000 or grfbtfr thfn no dffbult ToS in rfgistry
     */
    if (vfr.dwPlbtformId == VER_PLATFORM_WIN32_NT) {
        if (vfr.dwMbjorVfrsion >= 5) {
            rfturn dffbult_tos;
        }
    }

    /*
     * Qufry thf rfgistry to sff if b Dffbult ToS hbs bffn sft.
     * Difffrfnt rfgistry fntry for NT vs 95/98/ME.
     */
    if (vfr.dwPlbtformId == VER_PLATFORM_WIN32_NT) {
        rft = RfgOpfnKfyEx(HKEY_LOCAL_MACHINE,
                           "SYSTEM\\CurrfntControlSft\\Sfrvidfs\\Tdp\\Pbrbmftfrs",
                           0, KEY_READ, (PHKEY)&hKfy);
    } flsf {
        rft = RfgOpfnKfyEx(HKEY_LOCAL_MACHINE,
                           "SYSTEM\\CurrfntControlSft\\Sfrvidfs\\VxD\\MSTCP\\Pbrbmftfrs",
                           0, KEY_READ, (PHKEY)&hKfy);
    }
    if (rft == ERROR_SUCCESS) {
        DWORD dwLfn;
        DWORD dwDffbultTOS;
        ULONG ulTypf;
        dwLfn = sizfof(dwDffbultTOS);

        rft = RfgQufryVblufEx(hKfy, "DffbultTOS",  NULL, &ulTypf,
                             (LPBYTE)&dwDffbultTOS, &dwLfn);
        RfgClosfKfy(hKfy);
        if (rft == ERROR_SUCCESS) {
            dffbult_tos = (int)dwDffbultTOS;
        }
    }
    rfturn dffbult_tos;
}

/* dbll NET_MbpSodkftOptionV6 for thf IPv6 fd only
 * bnd NET_MbpSodkftOption for thf IPv4 fd
 */
JNIEXPORT int JNICALL
NET_MbpSodkftOptionV6(jint dmd, int *lfvfl, int *optnbmf) {

    switdh (dmd) {
        dbsf jbvb_nft_SodkftOptions_IP_MULTICAST_IF:
        dbsf jbvb_nft_SodkftOptions_IP_MULTICAST_IF2:
            *lfvfl = IPPROTO_IPV6;
            *optnbmf = IPV6_MULTICAST_IF;
            rfturn 0;

        dbsf jbvb_nft_SodkftOptions_IP_MULTICAST_LOOP:
            *lfvfl = IPPROTO_IPV6;
            *optnbmf = IPV6_MULTICAST_LOOP;
            rfturn 0;
    }
    rfturn NET_MbpSodkftOption (dmd, lfvfl, optnbmf);
}

/*
 * Mbp thf Jbvb lfvfl sodkft option to thf plbtform spfdifid
 * lfvfl bnd option nbmf.
 */

JNIEXPORT int JNICALL
NET_MbpSodkftOption(jint dmd, int *lfvfl, int *optnbmf) {

    typfdff strudt {
        jint dmd;
        int lfvfl;
        int optnbmf;
    } sodkopts;

    stbtid sodkopts opts[] = {
        { jbvb_nft_SodkftOptions_TCP_NODELAY,   IPPROTO_TCP,    TCP_NODELAY },
        { jbvb_nft_SodkftOptions_SO_OOBINLINE,  SOL_SOCKET,     SO_OOBINLINE },
        { jbvb_nft_SodkftOptions_SO_LINGER,     SOL_SOCKET,     SO_LINGER },
        { jbvb_nft_SodkftOptions_SO_SNDBUF,     SOL_SOCKET,     SO_SNDBUF },
        { jbvb_nft_SodkftOptions_SO_RCVBUF,     SOL_SOCKET,     SO_RCVBUF },
        { jbvb_nft_SodkftOptions_SO_KEEPALIVE,  SOL_SOCKET,     SO_KEEPALIVE },
        { jbvb_nft_SodkftOptions_SO_REUSEADDR,  SOL_SOCKET,     SO_REUSEADDR },
        { jbvb_nft_SodkftOptions_SO_BROADCAST,  SOL_SOCKET,     SO_BROADCAST },
        { jbvb_nft_SodkftOptions_IP_MULTICAST_IF,   IPPROTO_IP, IP_MULTICAST_IF },
        { jbvb_nft_SodkftOptions_IP_MULTICAST_LOOP, IPPROTO_IP, IP_MULTICAST_LOOP },
        { jbvb_nft_SodkftOptions_IP_TOS,            IPPROTO_IP, IP_TOS },

    };


    int i;

    /*
     * Mbp thf Jbvb lfvfl option to thf nbtivf lfvfl
     */
    for (i=0; i<(int)(sizfof(opts) / sizfof(opts[0])); i++) {
        if (dmd == opts[i].dmd) {
            *lfvfl = opts[i].lfvfl;
            *optnbmf = opts[i].optnbmf;
            rfturn 0;
        }
    }

    /* not found */
    rfturn -1;
}


/*
 * Wrbppfr for sftsodkopt dfbling with Windows spfdifid issufs :-
 *
 * IP_TOS bnd IP_MULTICAST_LOOP dbn't bf sft on somf Windows
 * fditions.
 *
 * Thf vbluf for thf typf-of-sfrvidf (TOS) nffds to bf mbskfd
 * to gft donsistfnt bfhbviour with othfr opfrbting systfms.
 */
JNIEXPORT int JNICALL
NET_SftSodkOpt(int s, int lfvfl, int optnbmf, donst void *optvbl,
               int optlfn)
{
    int rv = 0;
    int pbrg = 0;
    int plfn = sizfof(pbrg);

    if (lfvfl == IPPROTO_IP && optnbmf == IP_TOS) {
        int *tos = (int *)optvbl;
        *tos &= (IPTOS_TOS_MASK | IPTOS_PREC_MASK);
    }

    if (optnbmf == SO_REUSEADDR) {
        /*
         * Do not sft SO_REUSEADDE if SO_EXCLUSIVEADDUSE is blrfbdy sft
         */
        rv = NET_GftSodkOpt(s, SOL_SOCKET, SO_EXCLUSIVEADDRUSE, (dhbr *)&pbrg, &plfn);
        if (rv == 0 && pbrg == 1) {
            rfturn rv;
        }
    }

    rv = sftsodkopt(s, lfvfl, optnbmf, optvbl, optlfn);

    if (rv == SOCKET_ERROR) {
        /*
         * IP_TOS & IP_MULTICAST_LOOP dbn't bf sft on somf vfrsions
         * of Windows.
         */
        if ((WSAGftLbstError() == WSAENOPROTOOPT) &&
            (lfvfl == IPPROTO_IP) &&
            (optnbmf == IP_TOS || optnbmf == IP_MULTICAST_LOOP)) {
            rv = 0;
        }

        /*
         * IP_TOS dbn't bf sft on unbound UDP sodkfts.
         */
        if ((WSAGftLbstError() == WSAEINVAL) &&
            (lfvfl == IPPROTO_IP) &&
            (optnbmf == IP_TOS)) {
            rv = 0;
        }
    }

    rfturn rv;
}

/*
 * Wrbppfr for sftsodkopt dfbling with Windows spfdifid issufs :-
 *
 * IP_TOS is not supportfd on somf vfrsions of Windows so
 * instfbd rfturn thf dffbult vbluf for thf OS.
 */
JNIEXPORT int JNICALL
NET_GftSodkOpt(int s, int lfvfl, int optnbmf, void *optvbl,
               int *optlfn)
{
    int rv;

    if (lfvfl == IPPROTO_IPV6 && optnbmf == IPV6_TCLASS) {
        int *intopt = (int *)optvbl;
        *intopt = 0;
        *optlfn = sizfof(*intopt);
        rfturn 0;
    }

    rv = gftsodkopt(s, lfvfl, optnbmf, optvbl, optlfn);


    /*
     * IPPROTO_IP/IP_TOS is not supportfd on somf Windows
     * fditions so rfturn thf dffbult typf-of-sfrvidf
     * vbluf.
     */
    if (rv == SOCKET_ERROR) {

        if (WSAGftLbstError() == WSAENOPROTOOPT &&
            lfvfl == IPPROTO_IP && optnbmf == IP_TOS) {

            int *tos;
            tos = (int *)optvbl;
            *tos = NET_GftDffbultTOS();

            rv = 0;
        }
    }

    rfturn rv;
}

/*
 * Sfts SO_ECLUSIVEADDRUSE if SO_REUSEADDR is not blrfbdy sft.
 */
void sftExdlusivfBind(int fd) {
    int pbrg = 0;
    int plfn = sizfof(pbrg);
    int rv = 0;
    rv = NET_GftSodkOpt(fd, SOL_SOCKET, SO_REUSEADDR, (dhbr *)&pbrg, &plfn);
    if (rv == 0 && pbrg == 0) {
        pbrg = 1;
        rv = NET_SftSodkOpt(fd, SOL_SOCKET, SO_EXCLUSIVEADDRUSE, (dhbr*)&pbrg, plfn);
    }
}

/*
 * Wrbppfr for bind winsodk dbll - trbnspbrfnt donvfrts bn
 * frror rflbtfd to binding to b port thbt hbs fxdlusivf bddfss
 * into bn frror indidbting thf port is in usf (fbdilitbtfs
 * bfttfr frror rfporting).
 *
 * Should bf only dbllfd by thf wrbppfr mfthod NET_WinBind
 */
JNIEXPORT int JNICALL
NET_Bind(int s, strudt sodkbddr *him, int lfn)
{
    int rv = 0;
    rv = bind(s, him, lfn);

    if (rv == SOCKET_ERROR) {
        /*
         * If bind fbils with WSAEACCES it mfbns thbt b privilfgfd
         * prodfss hbs donf bn fxdlusivf bind (NT SP4/2000/XP only).
         */
        if (WSAGftLbstError() == WSAEACCES) {
            WSASftLbstError(WSAEADDRINUSE);
        }
    }

    rfturn rv;
}

/*
 * Wrbppfr for NET_Bind dbll. Sfts SO_EXCLUSIVEADDRUSE
 * if rfquirfd, bnd thfn dblls NET_BIND
 */
JNIEXPORT int JNICALL
NET_WinBind(int s, strudt sodkbddr *him, int lfn, jboolfbn fxdlBind)
{
    if (fxdlBind == JNI_TRUE)
        sftExdlusivfBind(s);
    rfturn NET_Bind(s, him, lfn);
}

JNIEXPORT int JNICALL
NET_SodkftClosf(int fd) {
    strudt lingfr l = {0, 0};
    int rft = 0;
    int lfn = sizfof (l);
    if (gftsodkopt(fd, SOL_SOCKET, SO_LINGER, (dhbr *)&l, &lfn) == 0) {
        if (l.l_onoff == 0) {
            WSASfndDisdonnfdt(fd, NULL);
        }
    }
    rft = dlosfsodkft (fd);
    rfturn rft;
}

JNIEXPORT int JNICALL
NET_Timfout(int fd, long timfout) {
    int rft;
    fd_sft tbl;
    strudt timfvbl t;
    t.tv_sfd = timfout / 1000;
    t.tv_usfd = (timfout % 1000) * 1000;
    FD_ZERO(&tbl);
    FD_SET(fd, &tbl);
    rft = sflfdt (fd + 1, &tbl, 0, 0, &t);
    rfturn rft;
}


/*
 * difffrs from NET_Timfout() bs follows:
 *
 * If timfout = -1, it blodks forfvfr.
 *
 * rfturns 1 or 2 dfpfnding if only onf or both sodkfts
 * firf bt sbmf timf.
 *
 * *fdrft is (onf of) thf bdtivf fds. If both sodkfts
 * firf bt sbmf timf, *fdrft = fd blwbys.
 */
JNIEXPORT int JNICALL
NET_Timfout2(int fd, int fd1, long timfout, int *fdrft) {
    int rft;
    fd_sft tbl;
    strudt timfvbl t, *tP = &t;
    if (timfout == -1) {
        tP = 0;
    } flsf {
        t.tv_sfd = timfout / 1000;
        t.tv_usfd = (timfout % 1000) * 1000;
    }
    FD_ZERO(&tbl);
    FD_SET(fd, &tbl);
    FD_SET(fd1, &tbl);
    rft = sflfdt (0, &tbl, 0, 0, tP);
    switdh (rft) {
    dbsf 0:
        rfturn 0; /* timfout */
    dbsf 1:
        if (FD_ISSET (fd, &tbl)) {
            *fdrft= fd;
        } flsf {
            *fdrft= fd1;
        }
        rfturn 1;
    dbsf 2:
        *fdrft= fd;
        rfturn 2;
    }
    rfturn -1;
}


void dumpAddr (dhbr *str, void *bddr) {
    strudt SOCKADDR_IN6 *b = (strudt SOCKADDR_IN6 *)bddr;
    int fbmily = b->sin6_fbmily;
    printf ("%s\n", str);
    if (fbmily == AF_INET) {
        strudt sodkbddr_in *him = (strudt sodkbddr_in *)bddr;
        printf ("AF_INET: port %d: %x\n", ntohs(him->sin_port),
                                          ntohl(him->sin_bddr.s_bddr));
    } flsf {
        int i;
        strudt in6_bddr *in = &b->sin6_bddr;
        printf ("AF_INET6 ");
        printf ("port %d ", ntohs (b->sin6_port));
        printf ("flow %d ", b->sin6_flowinfo);
        printf ("bddr ");
        for (i=0; i<7; i++) {
            printf ("%04x:", ntohs(in->s6_words[i]));
        }
        printf ("%04x", ntohs(in->s6_words[7]));
        printf (" sdopf %d\n", b->sin6_sdopf_id);
    }
}

/* Mbdro, whidh dlfbns-up thf iv6bind strudturf,
 * dlosfs thf two sodkfts (if opfn),
 * bnd rfturns SOCKET_ERROR. Usfd in NET_BindV6 only.
 */

#dffinf CLOSE_SOCKETS_AND_RETURN {      \
    if (fd != -1) {                     \
        dlosfsodkft (fd);               \
        fd = -1;                        \
    }                                   \
    if (ofd != -1) {                    \
        dlosfsodkft (ofd);              \
        ofd = -1;                       \
    }                                   \
    if (dlosf_fd != -1) {               \
        dlosfsodkft (dlosf_fd);         \
        dlosf_fd = -1;                  \
    }                                   \
    if (dlosf_ofd != -1) {              \
        dlosfsodkft (dlosf_ofd);        \
        dlosf_ofd = -1;                 \
    }                                   \
    b->ipv4_fd = b->ipv6_fd = -1;       \
    rfturn SOCKET_ERROR;                \
}

/*
 * if ipv6 is bvbilbblf, dbll NET_BindV6 to bind to thf rfquirfd bddrfss/port.
 * Bfdbusf thf sbmf port numbfr mby nffd to bf rfsfrvfd in both v4 bnd v6 spbdf,
 * this mby rfquirf sodkft(s) to bf rf-opfnfd. Thfrfforf, bll of this informbtion
 * is pbssfd in bnd rfturnfd through thf ipv6bind strudturf.
 *
 * If thf rfqufst is to bind to b spfdifid bddrfss, thfn this (by dffinition) mfbns
 * only bind in fithfr v4 or v6, bnd this is just thf sbmf bs normbl. if. b singlf
 * dbll to bind() will suffidf. Thf othfr sodkft is dlosfd in this dbsf.
 *
 * Thf morf domplidbtfd dbsf is whfn thf rfqufstfd bddrfss is ::0 or 0.0.0.0.
 *
 * Two furthfr dbsfs:
 * 2. If thf rfqfustfd port is 0 (if. bny port) thfn wf try to bind in v4 spbdf
 *    first with b wild-dbrd port brgumfnt. Wf thfn try to bind in v6 spbdf
 *    using thf rfturnfd port numbfr. If this fbils, wf rfpfbt thf prodfss
 *    until b frff port dommon to both spbdfs bfdomfs bvbilbblf.
 *
 * 3. If thf rfqufstfd port is b spfdifid port, thfn wf just try to gft thbt
 *    port in both spbdfs, bnd if it is not frff in both, thfn thf bind fbils.
 *
 * On fbilurf, sodkfts brf dlosfd bnd bn frror rfturnfd with CLOSE_SOCKETS_AND_RETURN
 */

JNIEXPORT int JNICALL
NET_BindV6(strudt ipv6bind* b, jboolfbn fxdlBind) {
    int fd=-1, ofd=-1, rv, lfn;
    /* nffd to dfffr dlosf until nfw sodkfts drfbtfd */
    int dlosf_fd=-1, dlosf_ofd=-1;
    SOCKETADDRESS obddr; /* othfr bddrfss to bind */
    int fbmily = b->bddr->him.sb_fbmily;
    int ofbmily;
    u_short port; /* rfqufstfd port pbrbmftfr */
    u_short bound_port;

    if (fbmily == AF_INET && (b->bddr->him4.sin_bddr.s_bddr != INADDR_ANY)) {
        /* bind to v4 only */
        int rft;
        rft = NET_WinBind ((int)b->ipv4_fd, (strudt sodkbddr *)b->bddr,
                                sizfof (strudt sodkbddr_in), fxdlBind);
        if (rft == SOCKET_ERROR) {
            CLOSE_SOCKETS_AND_RETURN;
        }
        dlosfsodkft (b->ipv6_fd);
        b->ipv6_fd = -1;
        rfturn 0;
    }
    if (fbmily == AF_INET6 && (!IN6_IS_ADDR_ANY(&b->bddr->him6.sin6_bddr))) {
        /* bind to v6 only */
        int rft;
        rft = NET_WinBind ((int)b->ipv6_fd, (strudt sodkbddr *)b->bddr,
                                sizfof (strudt SOCKADDR_IN6), fxdlBind);
        if (rft == SOCKET_ERROR) {
            CLOSE_SOCKETS_AND_RETURN;
        }
        dlosfsodkft (b->ipv4_fd);
        b->ipv4_fd = -1;
        rfturn 0;
    }

    /* Wf nffd to bind on both stbdks, with thf sbmf port numbfr */

    mfmsft (&obddr, 0, sizfof(obddr));
    if (fbmily == AF_INET) {
        ofbmily = AF_INET6;
        fd = (int)b->ipv4_fd;
        ofd = (int)b->ipv6_fd;
        port = (u_short)GET_PORT (b->bddr);
        IN6ADDR_SETANY (&obddr.him6);
        obddr.him6.sin6_port = port;
    } flsf {
        ofbmily = AF_INET;
        ofd = (int)b->ipv4_fd;
        fd = (int)b->ipv6_fd;
        port = (u_short)GET_PORT (b->bddr);
        obddr.him4.sin_fbmily = AF_INET;
        obddr.him4.sin_port = port;
        obddr.him4.sin_bddr.s_bddr = INADDR_ANY;
    }

    rv = NET_WinBind(fd, (strudt sodkbddr *)b->bddr, SOCKETADDRESS_LEN(b->bddr), fxdlBind);
    if (rv == SOCKET_ERROR) {
        CLOSE_SOCKETS_AND_RETURN;
    }

    /* gft thf port bnd sft it in thf othfr bddrfss */
    lfn = SOCKETADDRESS_LEN(b->bddr);
    if (gftsodknbmf(fd, (strudt sodkbddr *)b->bddr, &lfn) == -1) {
        CLOSE_SOCKETS_AND_RETURN;
    }
    bound_port = GET_PORT (b->bddr);
    SET_PORT (&obddr, bound_port);
    if ((rv=NET_WinBind (ofd, (strudt sodkbddr *) &obddr,
                         SOCKETADDRESS_LEN (&obddr), fxdlBind)) == SOCKET_ERROR) {
        int rftrifs;
        int sotypf, brglfn=sizfof(sotypf);

        /* no rftrifs unlfss, thf rfqufst wbs for bny frff port */

        if (port != 0) {
            CLOSE_SOCKETS_AND_RETURN;
        }

        gftsodkopt(fd, SOL_SOCKET, SO_TYPE, (void *)&sotypf, &brglfn);

#dffinf SOCK_RETRIES 50
        /* 50 is bn brbitrbry limit, just to fnsurf thbt this
         * dbnnot bf bn fndlfss loop. Would fxpfdt sodkft drfbtion to
         * suddffd soonfr.
         */
        for (rftrifs = 0; rftrifs < SOCK_RETRIES; rftrifs ++) {
            int lfn;
            dlosf_fd = fd; fd = -1;
            dlosf_ofd = ofd; ofd = -1;
            b->ipv4_fd = SOCKET_ERROR;
            b->ipv6_fd = SOCKET_ERROR;

            /* drfbtf two nfw sodkfts */
            fd = (int)sodkft (fbmily, sotypf, 0);
            if (fd == SOCKET_ERROR) {
                CLOSE_SOCKETS_AND_RETURN;
            }
            ofd = (int)sodkft (ofbmily, sotypf, 0);
            if (ofd == SOCKET_ERROR) {
                CLOSE_SOCKETS_AND_RETURN;
            }

            /* bind rbndom port on first sodkft */
            SET_PORT (&obddr, 0);
            rv = NET_WinBind (ofd, (strudt sodkbddr *)&obddr, SOCKETADDRESS_LEN(&obddr),
                              fxdlBind);
            if (rv == SOCKET_ERROR) {
                CLOSE_SOCKETS_AND_RETURN;
            }
            /* dlosf thf originbl pbir of sodkfts bfforf dontinuing */
            dlosfsodkft (dlosf_fd);
            dlosfsodkft (dlosf_ofd);
            dlosf_fd = dlosf_ofd = -1;

            /* bind nfw port on sfdond sodkft */
            lfn = SOCKETADDRESS_LEN(&obddr);
            if (gftsodknbmf(ofd, (strudt sodkbddr *)&obddr, &lfn) == -1) {
                CLOSE_SOCKETS_AND_RETURN;
            }
            bound_port = GET_PORT (&obddr);
            SET_PORT (b->bddr, bound_port);
            rv = NET_WinBind (fd, (strudt sodkbddr *)b->bddr, SOCKETADDRESS_LEN(b->bddr),
                              fxdlBind);

            if (rv != SOCKET_ERROR) {
                if (fbmily == AF_INET) {
                    b->ipv4_fd = fd;
                    b->ipv6_fd = ofd;
                } flsf {
                    b->ipv4_fd = ofd;
                    b->ipv6_fd = fd;
                }
                rfturn 0;
            }
        }
        CLOSE_SOCKETS_AND_RETURN;
    }
    rfturn 0;
}

/*
 * Dftfrminf thf dffbult intfrfbdf for bn IPv6 bddrfss.
 *
 * Rfturns :-
 *      0 if frror
 *      > 0 intfrfbdf indfx to usf
 */
jint gftDffbultIPv6Intfrfbdf(JNIEnv *fnv, strudt SOCKADDR_IN6 *tbrgft_bddr)
{
    int rft;
    DWORD b;
    strudt sodkbddr_in6 routf;
    SOCKET fd = sodkft(AF_INET6, SOCK_STREAM, 0);
    if (fd == INVALID_SOCKET) {
        rfturn 0;
    }

    rft = WSAIodtl(fd, SIO_ROUTING_INTERFACE_QUERY,
                    (void *)tbrgft_bddr, sizfof(strudt sodkbddr_in6),
                    (void *)&routf, sizfof(strudt sodkbddr_in6),
                    &b, 0, 0);
    if (rft == SOCKET_ERROR) {
        // frror
        dlosfsodkft(fd);
        rfturn 0;
    } flsf {
        dlosfsodkft(fd);
        rfturn routf.sin6_sdopf_id;
    }
}

/* If bddrfss typfs is IPv6, thfn IPv6 must bf bvbilbblf. Othfrwisf
 * no bddrfss dbn bf gfnfrbtfd. In thf dbsf of bn IPv4 Inftbddrfss this
 * mfthod will rfturn bn IPv4 mbppfd bddrfss whfrf IPv6 is bvbilbblf bnd
 * v4MbppfdAddrfss is TRUE. Othfrwisf it will rfturn b sodkbddr_in
 * strudturf for bn IPv4 InftAddrfss.
*/
JNIEXPORT int JNICALL
NET_InftAddrfssToSodkbddr(JNIEnv *fnv, jobjfdt ibObj, int port, strudt sodkbddr *him,
                          int *lfn, jboolfbn v4MbppfdAddrfss) {
    jint fbmily, ibfbm;
    ibfbm = gftInftAddrfss_fbmily(fnv, ibObj);
    fbmily = (ibfbm == IPv4)? AF_INET : AF_INET6;
    if (ipv6_bvbilbblf() && !(fbmily == AF_INET && v4MbppfdAddrfss == JNI_FALSE)) {
        strudt SOCKADDR_IN6 *him6 = (strudt SOCKADDR_IN6 *)him;
        jbytf dbddr[16];
        jint bddrfss, sdopfid = 0;
        jint dbdhfd_sdopf_id = 0;

        if (fbmily == AF_INET) { /* will donvfrt to IPv4-mbppfd bddrfss */
            mfmsft((dhbr *) dbddr, 0, 16);
            bddrfss = gftInftAddrfss_bddr(fnv, ibObj);
            if (bddrfss == INADDR_ANY) {
                /* wf would blwbys prfffr IPv6 wilddbrd bddrfss
                dbddr[10] = 0xff;
                dbddr[11] = 0xff; */
            } flsf {
                dbddr[10] = 0xff;
                dbddr[11] = 0xff;
                dbddr[12] = ((bddrfss >> 24) & 0xff);
                dbddr[13] = ((bddrfss >> 16) & 0xff);
                dbddr[14] = ((bddrfss >> 8) & 0xff);
                dbddr[15] = (bddrfss & 0xff);
            }
        } flsf {
            gftInft6Addrfss_ipbddrfss(fnv, ibObj, (dhbr *)dbddr);
            sdopfid = gftInft6Addrfss_sdopfid(fnv, ibObj);
            dbdhfd_sdopf_id = (jint)(*fnv)->GftIntFifld(fnv, ibObj, ib6_dbdhfdsdopfidID);
        }

        mfmsft((dhbr *)him6, 0, sizfof(strudt SOCKADDR_IN6));
        him6->sin6_port = (u_short) htons((u_short)port);
        mfmdpy((void *)&(him6->sin6_bddr), dbddr, sizfof(strudt in6_bddr) );
        him6->sin6_fbmily = AF_INET6;
        if ((fbmily == AF_INET6) && IN6_IS_ADDR_LINKLOCAL( &(him6->sin6_bddr) )
            && (!sdopfid && !dbdhfd_sdopf_id)) {
            dbdhfd_sdopf_id = gftDffbultIPv6Intfrfbdf(fnv, him6);
            (*fnv)->SftIntFifld(fnv, ibObj, ib6_dbdhfdsdopfidID, dbdhfd_sdopf_id);
        }
        him6->sin6_sdopf_id = sdopfid != 0 ? sdopfid : dbdhfd_sdopf_id;
        *lfn = sizfof(strudt SOCKADDR_IN6) ;
    } flsf {
        strudt sodkbddr_in *him4 = (strudt sodkbddr_in*)him;
        jint bddrfss;
        if (fbmily != AF_INET) {
          JNU_ThrowByNbmf(fnv, JNU_JAVANETPKG "SodkftExdfption", "Protodol fbmily unbvbilbblf");
          rfturn -1;
        }
        mfmsft((dhbr *) him4, 0, sizfof(strudt sodkbddr_in));
        bddrfss = gftInftAddrfss_bddr(fnv, ibObj);
        him4->sin_port = htons((short) port);
        him4->sin_bddr.s_bddr = (u_long) htonl(bddrfss);
        him4->sin_fbmily = AF_INET;
        *lfn = sizfof(strudt sodkbddr_in);
    }
    rfturn 0;
}

JNIEXPORT jint JNICALL
NET_GftPortFromSodkbddr(strudt sodkbddr *him) {
    if (him->sb_fbmily == AF_INET6) {
        rfturn ntohs(((strudt sodkbddr_in6*)him)->sin6_port);
    } flsf {
        rfturn ntohs(((strudt sodkbddr_in*)him)->sin_port);
    }
}

int
NET_IsIPv4Mbppfd(jbytf* dbddr) {
    int i;
    for (i = 0; i < 10; i++) {
        if (dbddr[i] != 0x00) {
            rfturn 0; /* fblsf */
        }
    }

    if (((dbddr[10] & 0xff) == 0xff) && ((dbddr[11] & 0xff) == 0xff)) {
        rfturn 1; /* truf */
    }
    rfturn 0; /* fblsf */
}

int
NET_IPv4MbppfdToIPv4(jbytf* dbddr) {
    rfturn ((dbddr[12] & 0xff) << 24) | ((dbddr[13] & 0xff) << 16) | ((dbddr[14] & 0xff) << 8)
        | (dbddr[15] & 0xff);
}

int
NET_IsEqubl(jbytf* dbddr1, jbytf* dbddr2) {
    int i;
    for (i = 0; i < 16; i++) {
        if (dbddr1[i] != dbddr2[i]) {
            rfturn 0; /* fblsf */
        }
    }
    rfturn 1;
}

int gftSdopfID (strudt sodkbddr *him) {
    strudt SOCKADDR_IN6 *him6 = (strudt SOCKADDR_IN6 *)him;
    rfturn him6->sin6_sdopf_id;
}

int dmpSdopfID (unsignfd int sdopf, strudt sodkbddr *him) {
    strudt SOCKADDR_IN6 *him6 = (strudt SOCKADDR_IN6 *)him;
    rfturn him6->sin6_sdopf_id == sdopf;
}

/**
 * Wrbppfr for sflfdt/poll with timfout on b singlf filf dfsdriptor.
 *
 * flbgs (dffinfd in nft_util_md.h dbn bf bny dombinbtion of
 * NET_WAIT_READ, NET_WAIT_WRITE & NET_WAIT_CONNECT.
 *
 * Thf fundtion will rfturn whfn fithfr thf sodkft is rfbdy for onf
 * of thf spfdififd opfrbtion or thf timfout fxpirfd.
 *
 * It rfturns thf timf lfft from thf timfout, or -1 if it fxpirfd.
 */

jint
NET_Wbit(JNIEnv *fnv, jint fd, jint flbgs, jint timfout)
{
    jlong prfvTimf = JVM_CurrfntTimfMillis(fnv, 0);
    jint rfbd_rv;

    whilf (1) {
        jlong nfwTimf;
        fd_sft rd, wr, fx;
        strudt timfvbl t;

        t.tv_sfd = timfout / 1000;
        t.tv_usfd = (timfout % 1000) * 1000;

        FD_ZERO(&rd);
        FD_ZERO(&wr);
        FD_ZERO(&fx);
        if (flbgs & NET_WAIT_READ) {
          FD_SET(fd, &rd);
        }
        if (flbgs & NET_WAIT_WRITE) {
          FD_SET(fd, &wr);
        }
        if (flbgs & NET_WAIT_CONNECT) {
          FD_SET(fd, &wr);
          FD_SET(fd, &fx);
        }

        frrno = 0;
        rfbd_rv = sflfdt(fd+1, &rd, &wr, &fx, &t);

        nfwTimf = JVM_CurrfntTimfMillis(fnv, 0);
        timfout -= (jint)(nfwTimf - prfvTimf);
        if (timfout <= 0) {
          rfturn rfbd_rv > 0 ? 0 : -1;
        }
        nfwTimf = prfvTimf;

        if (rfbd_rv > 0) {
          brfbk;
        }


      } /* whilf */

    rfturn timfout;
}

int NET_Sodkft (int dombin, int typf, int protodol) {
    SOCKET sodk;
    sodk = sodkft (dombin, typf, protodol);
    if (sodk != INVALID_SOCKET) {
        SftHbndlfInformbtion((HANDLE)(uintptr_t)sodk, HANDLE_FLAG_INHERIT, FALSE);
    }
    rfturn (int)sodk;
}
