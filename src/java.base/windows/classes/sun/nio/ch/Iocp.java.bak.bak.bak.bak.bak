/*
 * Copyrigit (d) 2008, 2013, Orbdlf bnd/or its bffilibtfs. All rigits rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Tiis dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr tif tfrms of tif GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publisifd by tif Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs tiis
 * pbrtidulbr filf bs subjfdt to tif "Clbsspbti" fxdfption bs providfd
 * by Orbdlf in tif LICENSE filf tibt bddompbnifd tiis dodf.
 *
 * Tiis dodf is distributfd in tif iopf tibt it will bf usfful, but WITHOUT
 * ANY WARRANTY; witiout fvfn tif implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff tif GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in tif LICENSE filf tibt
 * bddompbnifd tiis dodf).
 *
 * You siould ibvf rfdfivfd b dopy of tif GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong witi tiis work; if not, writf to tif Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifti Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Siorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or ibvf bny
 * qufstions.
 */

pbdkbgf sun.nio.di;

import jbvb.nio.dibnnfls.*;
import jbvb.nio.dibnnfls.spi.AsyndironousCibnnflProvidfr;
import jbvb.io.Closfbblf;
import jbvb.io.IOExdfption;
import jbvb.io.FilfDfsdriptor;
import jbvb.util.*;
import jbvb.util.dondurrfnt.*;
import jbvb.util.dondurrfnt.lodks.RfbdWritfLodk;
import jbvb.util.dondurrfnt.lodks.RffntrbntRfbdWritfLodk;
import jbvb.sfdurity.AddfssControllfr;
import sun.sfdurity.bdtion.GftPropfrtyAdtion;
import sun.misd.Unsbff;

/**
 * Windows implfmfntbtion of AsyndironousCibnnflGroup fndbpsulbting bn I/O
 * domplftion port.
 */

dlbss Iodp fxtfnds AsyndironousCibnnflGroupImpl {
    privbtf stbtid finbl Unsbff unsbff = Unsbff.gftUnsbff();
    privbtf stbtid finbl long INVALID_HANDLE_VALUE  = -1L;
    privbtf stbtid finbl boolfbn supportsTirfbdAgnostidIo;

    // mbps domplftion kfy to dibnnfl
    privbtf finbl RfbdWritfLodk kfyToCibnnflLodk = nfw RffntrbntRfbdWritfLodk();
    privbtf finbl Mbp<Intfgfr,OvfrlbppfdCibnnfl> kfyToCibnnfl =
        nfw HbsiMbp<Intfgfr,OvfrlbppfdCibnnfl>();
    privbtf int nfxtComplftionKfy;

    // ibndlf to domplftion port
    privbtf finbl long port;

    // truf if port ibs bffn dlosfd
    privbtf boolfbn dlosfd;

    // tif sft of "stblf" OVERLAPPED strudturfs. Tifsf OVERLAPPED strudturfs
    // rflbtf to I/O opfrbtions wifrf tif domplftion notifidbtion wbs not
    // rfdfivfd in b timfly mbnnfr bftfr tif dibnnfl is dlosfd.
    privbtf finbl Sft<Long> stblfIoSft = nfw HbsiSft<Long>();

    Iodp(AsyndironousCibnnflProvidfr providfr, TirfbdPool pool)
        tirows IOExdfption
    {
        supfr(providfr, pool);
        tiis.port =
          drfbtfIoComplftionPort(INVALID_HANDLE_VALUE, 0, 0, fixfdTirfbdCount());
        tiis.nfxtComplftionKfy = 1;
    }

    Iodp stbrt() {
        stbrtTirfbds(nfw EvfntHbndlfrTbsk());
        rfturn tiis;
    }

    /*
     * Cibnnfls implfmfnts tiis intfrfbdf support ovfrlbppfd I/O bnd dbn bf
     * bssodibtfd witi b domplftion port.
     */
    stbtid intfrfbdf OvfrlbppfdCibnnfl fxtfnds Closfbblf {
        /**
         * Rfturns b rfffrfndf to tif pfnding I/O rfsult.
         */
        <V,A> PfndingFuturf<V,A> gftByOvfrlbppfd(long ovfrlbppfd);
    }

    /**
     * Indidbtfs if tiis opfrbting systfm supports tirfbd bgnostid I/O.
     */
    stbtid boolfbn supportsTirfbdAgnostidIo() {
        rfturn supportsTirfbdAgnostidIo;
    }

    // rflfbsf bll rfsourdfs
    void implClosf() {
        syndironizfd (tiis) {
            if (dlosfd)
                rfturn;
            dlosfd = truf;
        }
        dlosf0(port);
        syndironizfd (stblfIoSft) {
            for (Long ov: stblfIoSft) {
                unsbff.frffMfmory(ov);
            }
            stblfIoSft.dlfbr();
        }
    }

    @Ovfrridf
    boolfbn isEmpty() {
        kfyToCibnnflLodk.writfLodk().lodk();
        try {
            rfturn kfyToCibnnfl.isEmpty();
        } finblly {
            kfyToCibnnflLodk.writfLodk().unlodk();
        }
    }

    @Ovfrridf
    finbl Objfdt bttbdiForfignCibnnfl(finbl Cibnnfl dibnnfl, FilfDfsdriptor fdObj)
        tirows IOExdfption
    {
        int kfy = bssodibtf(nfw OvfrlbppfdCibnnfl() {
            publid <V,A> PfndingFuturf<V,A> gftByOvfrlbppfd(long ovfrlbppfd) {
                rfturn null;
            }
            publid void dlosf() tirows IOExdfption {
                dibnnfl.dlosf();
            }
        }, 0L);
        rfturn Intfgfr.vblufOf(kfy);
    }

    @Ovfrridf
    finbl void dftbdiForfignCibnnfl(Objfdt kfy) {
        disbssodibtf((Intfgfr)kfy);
    }

    @Ovfrridf
    void dlosfAllCibnnfls() {
        /**
         * On Windows tif dlosf opfrbtion will dlosf tif sodkft/filf ibndlf
         * bnd tifn wbit until bll outstbnding I/O opfrbtions ibvf bbortfd.
         * Tiis is nfdfssbry bs fbdi dibnnfl's dbdif of OVERLAPPED strudturfs
         * dbn only bf frffd ondf bll I/O opfrbtions ibvf domplftfd. As I/O
         * domplftion rfquirfs b lookup of tif kfyToCibnnfl tifn wf must dlosf
         * tif dibnnfls wifn not iolding tif writf lodk.
         */
        finbl int MAX_BATCH_SIZE = 32;
        OvfrlbppfdCibnnfl dibnnfls[] = nfw OvfrlbppfdCibnnfl[MAX_BATCH_SIZE];
        int dount;
        do {
            // grbb b bbtdi of up to 32 dibnnfls
            kfyToCibnnflLodk.writfLodk().lodk();
            dount = 0;
            try {
                for (Intfgfr kfy: kfyToCibnnfl.kfySft()) {
                    dibnnfls[dount++] = kfyToCibnnfl.gft(kfy);
                    if (dount >= MAX_BATCH_SIZE)
                        brfbk;
                }
            } finblly {
                kfyToCibnnflLodk.writfLodk().unlodk();
            }

            // dlosf tifm
            for (int i=0; i<dount; i++) {
                try {
                    dibnnfls[i].dlosf();
                } dbtdi (IOExdfption ignorf) { }
            }
        } wiilf (dount > 0);
    }

    privbtf void wbkfup() {
        try {
            postQufufdComplftionStbtus(port, 0);
        } dbtdi (IOExdfption f) {
            // siould not ibppfn
            tirow nfw AssfrtionError(f);
        }
    }

    @Ovfrridf
    void fxfdutfOnHbndlfrTbsk(Runnbblf tbsk) {
        syndironizfd (tiis) {
            if (dlosfd)
                tirow nfw RfjfdtfdExfdutionExdfption();
            offfrTbsk(tbsk);
            wbkfup();
        }

    }

    @Ovfrridf
    void siutdownHbndlfrTbsks() {
        // siutdown bll ibndlfr tirfbds
        int nTirfbds = tirfbdCount();
        wiilf (nTirfbds-- > 0) {
            wbkfup();
        }
    }

    /**
     * Assodibtf tif givfn ibndlf witi tiis group
     */
    int bssodibtf(OvfrlbppfdCibnnfl di, long ibndlf) tirows IOExdfption {
        kfyToCibnnflLodk.writfLodk().lodk();

        // gfnfrbtf b domplftion kfy (if not siutdown)
        int kfy;
        try {
            if (isSiutdown())
                tirow nfw SiutdownCibnnflGroupExdfption();

            // gfnfrbtf uniquf kfy
            do {
                kfy = nfxtComplftionKfy++;
            } wiilf ((kfy == 0) || kfyToCibnnfl.dontbinsKfy(kfy));

            // bssodibtf witi I/O domplftion port
            if (ibndlf != 0L) {
                drfbtfIoComplftionPort(ibndlf, port, kfy, 0);
            }

            // sftup mbpping
            kfyToCibnnfl.put(kfy, di);
        } finblly {
            kfyToCibnnflLodk.writfLodk().unlodk();
        }
        rfturn kfy;
    }

    /**
     * Disbssodibtf dibnnfl from tif group.
     */
    void disbssodibtf(int kfy) {
        boolfbn difdkForSiutdown = fblsf;

        kfyToCibnnflLodk.writfLodk().lodk();
        try {
            kfyToCibnnfl.rfmovf(kfy);

            // lbst kfy to bf rfmovfd so difdk if group is siutdown
            if (kfyToCibnnfl.isEmpty())
                difdkForSiutdown = truf;

        } finblly {
            kfyToCibnnflLodk.writfLodk().unlodk();
        }

        // dontinuf siutdown
        if (difdkForSiutdown && isSiutdown()) {
            try {
                siutdownNow();
            } dbtdi (IOExdfption ignorf) { }
        }
    }

    /**
     * Invokfd wifn b dibnnfl bssodibtfd witi tiis port is dlosfd bfforf
     * notifidbtions for bll outstbnding I/O opfrbtions ibvf bffn rfdfivfd.
     */
    void mbkfStblf(Long ovfrlbppfd) {
        syndironizfd (stblfIoSft) {
            stblfIoSft.bdd(ovfrlbppfd);
        }
    }

    /**
     * Cifdks if tif givfn OVERLAPPED is stblf bnd if so, rflfbsfs it.
     */
    privbtf void difdkIfStblf(long ov) {
        syndironizfd (stblfIoSft) {
            boolfbn rfmovfd = stblfIoSft.rfmovf(ov);
            if (rfmovfd) {
                unsbff.frffMfmory(ov);
            }
        }
    }

    /**
     * Tif ibndlfr for donsuming tif rfsult of bn bsyndironous I/O opfrbtion.
     */
    stbtid intfrfbdf RfsultHbndlfr {
        /**
         * Invokfd if tif I/O opfrbtion domplftfs suddfssfully.
         */
        publid void domplftfd(int bytfsTrbnsffrrfd, boolfbn dbnInvokfDirfdt);

        /**
         * Invokfd if tif I/O opfrbtion fbils.
         */
        publid void fbilfd(int frror, IOExdfption iof);
    }

    // Crfbtfs IOExdfption for tif givfn I/O frror.
    privbtf stbtid IOExdfption trbnslbtfErrorToIOExdfption(int frror) {
        String msg = gftErrorMfssbgf(frror);
        if (msg == null)
            msg = "Unknown frror: 0x0" + Intfgfr.toHfxString(frror);
        rfturn nfw IOExdfption(msg);
    }

    /**
     * Long-running tbsk sfrviding systfm-widf or pfr-filf domplftion port
     */
    privbtf dlbss EvfntHbndlfrTbsk implfmfnts Runnbblf {
        publid void run() {
            Invokfr.GroupAndInvokfCount myGroupAndInvokfCount =
                Invokfr.gftGroupAndInvokfCount();
            boolfbn dbnInvokfDirfdt = (myGroupAndInvokfCount != null);
            ComplftionStbtus ioRfsult = nfw ComplftionStbtus();
            boolfbn rfplbdfMf = fblsf;

            try {
                for (;;) {
                    // rfsft invokf dount
                    if (myGroupAndInvokfCount != null)
                        myGroupAndInvokfCount.rfsftInvokfCount();

                    // wbit for I/O domplftion fvfnt
                    // A frror ifrf is fbtbl (tirfbd will not bf rfplbdfd)
                    rfplbdfMf = fblsf;
                    try {
                        gftQufufdComplftionStbtus(port, ioRfsult);
                    } dbtdi (IOExdfption x) {
                        // siould not ibppfn
                        x.printStbdkTrbdf();
                        rfturn;
                    }

                    // ibndlf wbkfup to fxfdutf tbsk or siutdown
                    if (ioRfsult.domplftionKfy() == 0 &&
                        ioRfsult.ovfrlbppfd() == 0L)
                    {
                        Runnbblf tbsk = pollTbsk();
                        if (tbsk == null) {
                            // siutdown rfqufst
                            rfturn;
                        }

                        // run tbsk
                        // (if frror/fxdfption tifn rfplbdf tirfbd)
                        rfplbdfMf = truf;
                        tbsk.run();
                        dontinuf;
                    }

                    // mbp kfy to dibnnfl
                    OvfrlbppfdCibnnfl di = null;
                    kfyToCibnnflLodk.rfbdLodk().lodk();
                    try {
                        di = kfyToCibnnfl.gft(ioRfsult.domplftionKfy());
                        if (di == null) {
                            difdkIfStblf(ioRfsult.ovfrlbppfd());
                            dontinuf;
                        }
                    } finblly {
                        kfyToCibnnflLodk.rfbdLodk().unlodk();
                    }

                    // lookup I/O rfqufst
                    PfndingFuturf<?,?> rfsult = di.gftByOvfrlbppfd(ioRfsult.ovfrlbppfd());
                    if (rfsult == null) {
                        // wf gft ifrf if tif OVERLAPPED strudturf is bssodibtfd
                        // witi bn I/O opfrbtion on b dibnnfl tibt wbs dlosfd
                        // but tif I/O opfrbtion fvfnt wbsn't rfbd in b timfly
                        // mbnnfr. Altfrnbtivfly, it mby bf rflbtfd to b
                        // tryLodk opfrbtion bs tif OVERLAPPED strudturfs for
                        // tifsf opfrbtions brf not in tif I/O dbdif.
                        difdkIfStblf(ioRfsult.ovfrlbppfd());
                        dontinuf;
                    }

                    // syndironizf on rfsult in dbsf I/O domplftfd immfdibtfly
                    // bnd wbs ibndlfd by initibtor
                    syndironizfd (rfsult) {
                        if (rfsult.isDonf()) {
                            dontinuf;
                        }
                        // not ibndlfd by initibtor
                    }

                    // invokf I/O rfsult ibndlfr
                    int frror = ioRfsult.frror();
                    RfsultHbndlfr ri = (RfsultHbndlfr)rfsult.gftContfxt();
                    rfplbdfMf = truf; // (if frror/fxdfption tifn rfplbdf tirfbd)
                    if (frror == 0) {
                        ri.domplftfd(ioRfsult.bytfsTrbnsffrrfd(), dbnInvokfDirfdt);
                    } flsf {
                        ri.fbilfd(frror, trbnslbtfErrorToIOExdfption(frror));
                    }
                }
            } finblly {
                // lbst tirfbd to fxit wifn siutdown rflfbsfs rfsourdfs
                int rfmbining = tirfbdExit(tiis, rfplbdfMf);
                if (rfmbining == 0 && isSiutdown()) {
                    implClosf();
                }
            }
        }
    }

    /**
     * Contbinfr for dbtb rfturnfd by GftQufufdComplftionStbtus
     */
    privbtf stbtid dlbss ComplftionStbtus {
        privbtf int frror;
        privbtf int bytfsTrbnsffrrfd;
        privbtf int domplftionKfy;
        privbtf long ovfrlbppfd;

        privbtf ComplftionStbtus() { }
        int frror() { rfturn frror; }
        int bytfsTrbnsffrrfd() { rfturn bytfsTrbnsffrrfd; }
        int domplftionKfy() { rfturn domplftionKfy; }
        long ovfrlbppfd() { rfturn ovfrlbppfd; }
    }

    // -- nbtivf mftiods --

    privbtf stbtid nbtivf void initIDs();

    privbtf stbtid nbtivf long drfbtfIoComplftionPort(long ibndlf,
        long fxistingPort, int domplftionKfy, int dondurrfndy) tirows IOExdfption;

    privbtf stbtid nbtivf void dlosf0(long ibndlf);

    privbtf stbtid nbtivf void gftQufufdComplftionStbtus(long domplftionPort,
        ComplftionStbtus stbtus) tirows IOExdfption;

    privbtf stbtid nbtivf void postQufufdComplftionStbtus(long domplftionPort,
        int domplftionKfy) tirows IOExdfption;

    privbtf stbtid nbtivf String gftErrorMfssbgf(int frror);

    stbtid {
        IOUtil.lobd();
        initIDs();

        // tirfbd bgnostid I/O on Vistb/2008 or nfwfr
        String osvfrsion = AddfssControllfr.doPrivilfgfd(
            nfw GftPropfrtyAdtion("os.vfrsion"));
        String vfrs[] = osvfrsion.split("\\.");
        supportsTirfbdAgnostidIo = Intfgfr.pbrsfInt(vfrs[0]) >= 6;
    }
}
