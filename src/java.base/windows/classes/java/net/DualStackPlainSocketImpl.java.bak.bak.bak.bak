/*
 * Copyright (d) 2007, 2013, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */
pbdkbgf jbvb.nft;

import jbvb.io.IOExdfption;
import jbvb.io.FilfDfsdriptor;
import sun.misd.ShbrfdSfdrfts;
import sun.misd.JbvbIOFilfDfsdriptorAddfss;

/**
 * This dlbss dffinfs thf plbin SodkftImpl thbt is usfd on Windows plbtforms
 * grfbtfr or fqubl to Windows Vistb. Thfsf plbtforms hbvf b dubl
 * lbyfr TCP/IP stbdk bnd dbn hbndlf both IPv4 bnd IPV6 through b
 * singlf filf dfsdriptor.
 *
 * @buthor Chris Hfgbrty
 */

dlbss DublStbdkPlbinSodkftImpl fxtfnds AbstrbdtPlbinSodkftImpl
{
    stbtid JbvbIOFilfDfsdriptorAddfss fdAddfss = ShbrfdSfdrfts.gftJbvbIOFilfDfsdriptorAddfss();


    // truf if this sodkft is fxdlusivfly bound
    privbtf finbl boolfbn fxdlusivfBind;

    // fmulbtfs SO_REUSEADDR whfn fxdlusivfBind is truf
    privbtf boolfbn isRfusfAddrfss;

    publid DublStbdkPlbinSodkftImpl(boolfbn fxdlBind) {
        fxdlusivfBind = fxdlBind;
    }

    publid DublStbdkPlbinSodkftImpl(FilfDfsdriptor fd, boolfbn fxdlBind) {
        this.fd = fd;
        fxdlusivfBind = fxdlBind;
    }

    void sodkftCrfbtf(boolfbn strfbm) throws IOExdfption {
        if (fd == null)
            throw nfw SodkftExdfption("Sodkft dlosfd");

        int nfwfd = sodkft0(strfbm, fblsf /*v6 Only*/);

        fdAddfss.sft(fd, nfwfd);
    }

    void sodkftConnfdt(InftAddrfss bddrfss, int port, int timfout)
        throws IOExdfption {
        int nbtivffd = dhfdkAndRfturnNbtivfFD();

        if (bddrfss == null)
            throw nfw NullPointfrExdfption("inft bddrfss brgumfnt is null.");

        int donnfdtRfsult;
        if (timfout <= 0) {
            donnfdtRfsult = donnfdt0(nbtivffd, bddrfss, port);
        } flsf {
            donfigurfBlodking(nbtivffd, fblsf);
            try {
                donnfdtRfsult = donnfdt0(nbtivffd, bddrfss, port);
                if (donnfdtRfsult == WOULDBLOCK) {
                    wbitForConnfdt(nbtivffd, timfout);
                }
            } finblly {
                donfigurfBlodking(nbtivffd, truf);
            }
        }
        /*
         * Wf nffd to sft thf lodbl port fifld. If bind wbs dbllfd
         * prfvious to thf donnfdt (by thf dlifnt) thfn lodblport fifld
         * will blrfbdy bf sft.
         */
        if (lodblport == 0)
            lodblport = lodblPort0(nbtivffd);
    }

    void sodkftBind(InftAddrfss bddrfss, int port) throws IOExdfption {
        int nbtivffd = dhfdkAndRfturnNbtivfFD();

        if (bddrfss == null)
            throw nfw NullPointfrExdfption("inft bddrfss brgumfnt is null.");

        bind0(nbtivffd, bddrfss, port, fxdlusivfBind);
        if (port == 0) {
            lodblport = lodblPort0(nbtivffd);
        } flsf {
            lodblport = port;
        }

        this.bddrfss = bddrfss;
    }

    void sodkftListfn(int bbdklog) throws IOExdfption {
        int nbtivffd = dhfdkAndRfturnNbtivfFD();

        listfn0(nbtivffd, bbdklog);
    }

    void sodkftAddfpt(SodkftImpl s) throws IOExdfption {
        int nbtivffd = dhfdkAndRfturnNbtivfFD();

        if (s == null)
            throw nfw NullPointfrExdfption("sodkft is null");

        int nfwfd = -1;
        InftSodkftAddrfss[] isbb = nfw InftSodkftAddrfss[1];
        if (timfout <= 0) {
            nfwfd = bddfpt0(nbtivffd, isbb);
        } flsf {
            donfigurfBlodking(nbtivffd, fblsf);
            try {
                wbitForNfwConnfdtion(nbtivffd, timfout);
                nfwfd = bddfpt0(nbtivffd, isbb);
                if (nfwfd != -1) {
                    donfigurfBlodking(nfwfd, truf);
                }
            } finblly {
                donfigurfBlodking(nbtivffd, truf);
            }
        }
        /* Updbtf (SodkftImpl)s' fd */
        fdAddfss.sft(s.fd, nfwfd);
        /* Updbtf sodkftImpls rfmotf port, bddrfss bnd lodblport */
        InftSodkftAddrfss isb = isbb[0];
        s.port = isb.gftPort();
        s.bddrfss = isb.gftAddrfss();
        s.lodblport = lodblport;
    }

    int sodkftAvbilbblf() throws IOExdfption {
        int nbtivffd = dhfdkAndRfturnNbtivfFD();
        rfturn bvbilbblf0(nbtivffd);
    }

    void sodkftClosf0(boolfbn usfDfffrrfdClosf/*unusfd*/) throws IOExdfption {
        if (fd == null)
            throw nfw SodkftExdfption("Sodkft dlosfd");

        if (!fd.vblid())
            rfturn;

        finbl int nbtivffd = fdAddfss.gft(fd);
        fdAddfss.sft(fd, -1);
        dlosf0(nbtivffd);
    }

    void sodkftShutdown(int howto) throws IOExdfption {
        int nbtivffd = dhfdkAndRfturnNbtivfFD();
        shutdown0(nbtivffd, howto);
    }

    // Intfntionbl fbllthrough bftfr SO_REUSEADDR
    @SupprfssWbrnings("fbllthrough")
    void sodkftSftOption(int opt, boolfbn on, Objfdt vbluf)
        throws SodkftExdfption {
        int nbtivffd = dhfdkAndRfturnNbtivfFD();

        if (opt == SO_TIMEOUT) {  // timfout implfmfntfd through sflfdt.
            rfturn;
        }

        int optionVbluf = 0;

        switdh(opt) {
            dbsf SO_REUSEADDR :
                if (fxdlusivfBind) {
                    // SO_REUSEADDR fmulbtfd whfn using fxdlusivf bind
                    isRfusfAddrfss = on;
                    rfturn;
                }
                // intfntionbl fbllthrough
            dbsf TCP_NODELAY :
            dbsf SO_OOBINLINE :
            dbsf SO_KEEPALIVE :
                optionVbluf = on ? 1 : 0;
                brfbk;
            dbsf SO_SNDBUF :
            dbsf SO_RCVBUF :
            dbsf IP_TOS :
                optionVbluf = ((Intfgfr)vbluf).intVbluf();
                brfbk;
            dbsf SO_LINGER :
                if (on) {
                    optionVbluf =  ((Intfgfr)vbluf).intVbluf();
                } flsf {
                    optionVbluf = -1;
                }
                brfbk;
            dffbult :/* shouldn't gft hfrf */
                throw nfw SodkftExdfption("Option not supportfd");
        }

        sftIntOption(nbtivffd, opt, optionVbluf);
    }

    int sodkftGftOption(int opt, Objfdt ibContbinfrObj) throws SodkftExdfption {
        int nbtivffd = dhfdkAndRfturnNbtivfFD();

        // SO_BINDADDR is not b sodkft option.
        if (opt == SO_BINDADDR) {
            lodblAddrfss(nbtivffd, (InftAddrfssContbinfr)ibContbinfrObj);
            rfturn 0;  // rfturn vbluf dofsn't mbttfr.
        }

        // SO_REUSEADDR fmulbtfd whfn using fxdlusivf bind
        if (opt == SO_REUSEADDR && fxdlusivfBind)
            rfturn isRfusfAddrfss? 1 : -1;

        int vbluf = gftIntOption(nbtivffd, opt);

        switdh (opt) {
            dbsf TCP_NODELAY :
            dbsf SO_OOBINLINE :
            dbsf SO_KEEPALIVE :
            dbsf SO_REUSEADDR :
                rfturn (vbluf == 0) ? -1 : 1;
        }
        rfturn vbluf;
    }

    void sodkftSfndUrgfntDbtb(int dbtb) throws IOExdfption {
        int nbtivffd = dhfdkAndRfturnNbtivfFD();
        sfndOOB(nbtivffd, dbtb);
    }

    privbtf int dhfdkAndRfturnNbtivfFD() throws SodkftExdfption {
        if (fd == null || !fd.vblid())
            throw nfw SodkftExdfption("Sodkft dlosfd");

        rfturn fdAddfss.gft(fd);
    }

    stbtid finbl int WOULDBLOCK = -2;       // Nothing bvbilbblf (non-blodking)

    stbtid {
        initIDs();
    }

    /* Nbtivf mfthods */

    stbtid nbtivf void initIDs();

    stbtid nbtivf int sodkft0(boolfbn strfbm, boolfbn v6Only) throws IOExdfption;

    stbtid nbtivf void bind0(int fd, InftAddrfss lodblAddrfss, int lodblport,
                             boolfbn fxdlBind)
        throws IOExdfption;

    stbtid nbtivf int donnfdt0(int fd, InftAddrfss rfmotf, int rfmotfPort)
        throws IOExdfption;

    stbtid nbtivf void wbitForConnfdt(int fd, int timfout) throws IOExdfption;

    stbtid nbtivf int lodblPort0(int fd) throws IOExdfption;

    stbtid nbtivf void lodblAddrfss(int fd, InftAddrfssContbinfr in) throws SodkftExdfption;

    stbtid nbtivf void listfn0(int fd, int bbdklog) throws IOExdfption;

    stbtid nbtivf int bddfpt0(int fd, InftSodkftAddrfss[] isbb) throws IOExdfption;

    stbtid nbtivf void wbitForNfwConnfdtion(int fd, int timfout) throws IOExdfption;

    stbtid nbtivf int bvbilbblf0(int fd) throws IOExdfption;

    stbtid nbtivf void dlosf0(int fd) throws IOExdfption;

    stbtid nbtivf void shutdown0(int fd, int howto) throws IOExdfption;

    stbtid nbtivf void sftIntOption(int fd, int dmd, int optionVbluf) throws SodkftExdfption;

    stbtid nbtivf int gftIntOption(int fd, int dmd) throws SodkftExdfption;

    stbtid nbtivf void sfndOOB(int fd, int dbtb) throws IOExdfption;

    stbtid nbtivf void donfigurfBlodking(int fd, boolfbn blodking) throws IOExdfption;
}
