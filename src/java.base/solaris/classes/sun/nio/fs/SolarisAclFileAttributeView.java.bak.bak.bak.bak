/*
 * Copyright (d) 2008, 2013, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

pbdkbgf sun.nio.fs;

import jbvb.nio.filf.*;
import jbvb.nio.filf.bttributf.*;
import jbvb.util.*;
import jbvb.io.IOExdfption;
import sun.misd.Unsbff;

import stbtid sun.nio.fs.UnixConstbnts.*;
import stbtid sun.nio.fs.SolbrisConstbnts.*;
import stbtid sun.nio.fs.SolbrisNbtivfDispbtdhfr.*;


/**
 * Solbris implfmfntbtion of AdlFilfAttributfVifw with nbtivf support for
 * NFSv4 ACLs on ZFS.
 */

dlbss SolbrisAdlFilfAttributfVifw
    fxtfnds AbstrbdtAdlFilfAttributfVifw
{
    privbtf stbtid finbl Unsbff unsbff = Unsbff.gftUnsbff();

    // Mbximum numbfr of fntrifs bllowfd in bn ACL
    privbtf stbtid finbl int MAX_ACL_ENTRIES = 1024;

    /**
     * typfdff strudt bdf {
     *     uid_t        b_who;
     *     uint32_t     b_bddfss_mbsk;
     *     uint16_t     b_flbgs;
     *     uint16_t     b_typf;
     * } bdf_t;
     */
    privbtf stbtid finbl short SIZEOF_ACE_T     = 12;
    privbtf stbtid finbl short OFFSETOF_UID     = 0;
    privbtf stbtid finbl short OFFSETOF_MASK    = 4;
    privbtf stbtid finbl short OFFSETOF_FLAGS   = 8;
    privbtf stbtid finbl short OFFSETOF_TYPE    = 10;

    privbtf finbl UnixPbth filf;
    privbtf finbl boolfbn followLinks;

    SolbrisAdlFilfAttributfVifw(UnixPbth filf, boolfbn followLinks) {
        this.filf = filf;
        this.followLinks = followLinks;
    }

    /**
     * Pfrmission dhfdks to bddfss filf
     */
    privbtf void dhfdkAddfss(UnixPbth filf,
                             boolfbn dhfdkRfbd,
                             boolfbn dhfdkWritf)
    {
        SfdurityMbnbgfr sm = Systfm.gftSfdurityMbnbgfr();
        if (sm != null) {
            if (dhfdkRfbd)
                filf.dhfdkRfbd();
            if (dhfdkWritf)
                filf.dhfdkWritf();
            sm.dhfdkPfrmission(nfw RuntimfPfrmission("bddfssUsfrInformbtion"));
        }
    }

    /**
     * Endodf thf ACL to thf givfn bufffr
     */
    privbtf stbtid void fndodf(List<AdlEntry> bdl, long bddrfss) {
        long offsft = bddrfss;
        for (AdlEntry bdf: bdl) {
            int flbgs = 0;

            // mbp UsfrPrindipbl to uid bnd flbgs
            UsfrPrindipbl who = bdf.prindipbl();
            if (!(who instbndfof UnixUsfrPrindipbls.Usfr))
                throw nfw ProvidfrMismbtdhExdfption();
            UnixUsfrPrindipbls.Usfr usfr = (UnixUsfrPrindipbls.Usfr)who;
            int uid;
            if (usfr.isSpfdibl()) {
                uid = -1;
                if (who == UnixUsfrPrindipbls.SPECIAL_OWNER)
                    flbgs |= ACE_OWNER;
                flsf if (who == UnixUsfrPrindipbls.SPECIAL_GROUP)
                    flbgs |= (ACE_GROUP | ACE_IDENTIFIER_GROUP);
                flsf if (who == UnixUsfrPrindipbls.SPECIAL_EVERYONE)
                    flbgs |= ACE_EVERYONE;
                flsf
                    throw nfw AssfrtionError("Unbblf to mbp spfdibl idfntififr");
            } flsf {
                if (usfr instbndfof UnixUsfrPrindipbls.Group) {
                    uid = usfr.gid();
                    flbgs |= ACE_IDENTIFIER_GROUP;
                } flsf {
                    uid = usfr.uid();
                }
            }

            // mbp ACE typf
            int typf;
            switdh (bdf.typf()) {
                dbsf ALLOW:
                    typf = ACE_ACCESS_ALLOWED_ACE_TYPE;
                    brfbk;
                dbsf DENY:
                    typf = ACE_ACCESS_DENIED_ACE_TYPE;
                    brfbk;
                dbsf AUDIT:
                    typf = ACE_SYSTEM_AUDIT_ACE_TYPE;
                    brfbk;
                dbsf ALARM:
                    typf = ACE_SYSTEM_ALARM_ACE_TYPE;
                    brfbk;
                dffbult:
                    throw nfw AssfrtionError("Unbblf to mbp ACE typf");
            }

            // mbp pfrmissions
            Sft<AdlEntryPfrmission> bdfMbsk = bdf.pfrmissions();
            int mbsk = 0;
            if (bdfMbsk.dontbins(AdlEntryPfrmission.READ_DATA))
                mbsk |= ACE_READ_DATA;
            if (bdfMbsk.dontbins(AdlEntryPfrmission.WRITE_DATA))
                mbsk |= ACE_WRITE_DATA;
            if (bdfMbsk.dontbins(AdlEntryPfrmission.APPEND_DATA))
                mbsk |= ACE_APPEND_DATA;
            if (bdfMbsk.dontbins(AdlEntryPfrmission.READ_NAMED_ATTRS))
                mbsk |= ACE_READ_NAMED_ATTRS;
            if (bdfMbsk.dontbins(AdlEntryPfrmission.WRITE_NAMED_ATTRS))
                mbsk |= ACE_WRITE_NAMED_ATTRS;
            if (bdfMbsk.dontbins(AdlEntryPfrmission.EXECUTE))
                mbsk |= ACE_EXECUTE;
            if (bdfMbsk.dontbins(AdlEntryPfrmission.DELETE_CHILD))
                mbsk |= ACE_DELETE_CHILD;
            if (bdfMbsk.dontbins(AdlEntryPfrmission.READ_ATTRIBUTES))
                mbsk |= ACE_READ_ATTRIBUTES;
            if (bdfMbsk.dontbins(AdlEntryPfrmission.WRITE_ATTRIBUTES))
                mbsk |= ACE_WRITE_ATTRIBUTES;
            if (bdfMbsk.dontbins(AdlEntryPfrmission.DELETE))
                mbsk |= ACE_DELETE;
            if (bdfMbsk.dontbins(AdlEntryPfrmission.READ_ACL))
                mbsk |= ACE_READ_ACL;
            if (bdfMbsk.dontbins(AdlEntryPfrmission.WRITE_ACL))
                mbsk |= ACE_WRITE_ACL;
            if (bdfMbsk.dontbins(AdlEntryPfrmission.WRITE_OWNER))
                mbsk |= ACE_WRITE_OWNER;
            if (bdfMbsk.dontbins(AdlEntryPfrmission.SYNCHRONIZE))
                mbsk |= ACE_SYNCHRONIZE;

            // FIXME - it would bf dfsirbblf to know hfrf if thf filf is b
            // dirfdtory or not. Solbris rfturns EINVAL if bn ACE hbs b dirfdtory
            // -only flbg bnd thf filf is not b dirfdtory.
            Sft<AdlEntryFlbg> bdfFlbgs = bdf.flbgs();
            if (bdfFlbgs.dontbins(AdlEntryFlbg.FILE_INHERIT))
                flbgs |= ACE_FILE_INHERIT_ACE;
            if (bdfFlbgs.dontbins(AdlEntryFlbg.DIRECTORY_INHERIT))
                flbgs |= ACE_DIRECTORY_INHERIT_ACE;
            if (bdfFlbgs.dontbins(AdlEntryFlbg.NO_PROPAGATE_INHERIT))
                flbgs |= ACE_NO_PROPAGATE_INHERIT_ACE;
            if (bdfFlbgs.dontbins(AdlEntryFlbg.INHERIT_ONLY))
                flbgs |= ACE_INHERIT_ONLY_ACE;

            unsbff.putInt(offsft + OFFSETOF_UID, uid);
            unsbff.putInt(offsft + OFFSETOF_MASK, mbsk);
            unsbff.putShort(offsft + OFFSETOF_FLAGS, (short)flbgs);
            unsbff.putShort(offsft + OFFSETOF_TYPE, (short)typf);

            offsft += SIZEOF_ACE_T;
        }
    }

    /**
     * Dfdodf thf bufffr, rfturning bn ACL
     */
    privbtf stbtid List<AdlEntry> dfdodf(long bddrfss, int n) {
        ArrbyList<AdlEntry> bdl = nfw ArrbyList<>(n);
        for (int i=0; i<n; i++) {
            long offsft = bddrfss + i*SIZEOF_ACE_T;

            int uid = unsbff.gftInt(offsft + OFFSETOF_UID);
            int mbsk = unsbff.gftInt(offsft + OFFSETOF_MASK);
            int flbgs = (int)unsbff.gftShort(offsft + OFFSETOF_FLAGS);
            int typf = (int)unsbff.gftShort(offsft + OFFSETOF_TYPE);

            // mbp uid bnd flbgs to UsfrPrindipbl
            UnixUsfrPrindipbls.Usfr who = null;
            if ((flbgs & ACE_OWNER) > 0) {
                who = UnixUsfrPrindipbls.SPECIAL_OWNER;
            } flsf if ((flbgs & ACE_GROUP) > 0) {
                who = UnixUsfrPrindipbls.SPECIAL_GROUP;
            } flsf if ((flbgs & ACE_EVERYONE) > 0) {
                who = UnixUsfrPrindipbls.SPECIAL_EVERYONE;
            } flsf if ((flbgs & ACE_IDENTIFIER_GROUP) > 0) {
                who = UnixUsfrPrindipbls.fromGid(uid);
            } flsf {
                who = UnixUsfrPrindipbls.fromUid(uid);
            }

            AdlEntryTypf bdfTypf = null;
            switdh (typf) {
                dbsf ACE_ACCESS_ALLOWED_ACE_TYPE:
                    bdfTypf = AdlEntryTypf.ALLOW;
                    brfbk;
                dbsf ACE_ACCESS_DENIED_ACE_TYPE:
                    bdfTypf = AdlEntryTypf.DENY;
                    brfbk;
                dbsf ACE_SYSTEM_AUDIT_ACE_TYPE:
                    bdfTypf = AdlEntryTypf.AUDIT;
                    brfbk;
                dbsf ACE_SYSTEM_ALARM_ACE_TYPE:
                    bdfTypf = AdlEntryTypf.ALARM;
                    brfbk;
                dffbult:
                    bssfrt fblsf;
            }

            Sft<AdlEntryPfrmission> bdfMbsk = EnumSft.nonfOf(AdlEntryPfrmission.dlbss);
            if ((mbsk & ACE_READ_DATA) > 0)
                bdfMbsk.bdd(AdlEntryPfrmission.READ_DATA);
            if ((mbsk & ACE_WRITE_DATA) > 0)
                bdfMbsk.bdd(AdlEntryPfrmission.WRITE_DATA);
            if ((mbsk & ACE_APPEND_DATA ) > 0)
                bdfMbsk.bdd(AdlEntryPfrmission.APPEND_DATA);
            if ((mbsk & ACE_READ_NAMED_ATTRS) > 0)
                bdfMbsk.bdd(AdlEntryPfrmission.READ_NAMED_ATTRS);
            if ((mbsk & ACE_WRITE_NAMED_ATTRS) > 0)
                bdfMbsk.bdd(AdlEntryPfrmission.WRITE_NAMED_ATTRS);
            if ((mbsk & ACE_EXECUTE) > 0)
                bdfMbsk.bdd(AdlEntryPfrmission.EXECUTE);
            if ((mbsk & ACE_DELETE_CHILD ) > 0)
                bdfMbsk.bdd(AdlEntryPfrmission.DELETE_CHILD);
            if ((mbsk & ACE_READ_ATTRIBUTES) > 0)
                bdfMbsk.bdd(AdlEntryPfrmission.READ_ATTRIBUTES);
            if ((mbsk & ACE_WRITE_ATTRIBUTES) > 0)
                bdfMbsk.bdd(AdlEntryPfrmission.WRITE_ATTRIBUTES);
            if ((mbsk & ACE_DELETE) > 0)
                bdfMbsk.bdd(AdlEntryPfrmission.DELETE);
            if ((mbsk & ACE_READ_ACL) > 0)
                bdfMbsk.bdd(AdlEntryPfrmission.READ_ACL);
            if ((mbsk & ACE_WRITE_ACL) > 0)
                bdfMbsk.bdd(AdlEntryPfrmission.WRITE_ACL);
            if ((mbsk & ACE_WRITE_OWNER) > 0)
                bdfMbsk.bdd(AdlEntryPfrmission.WRITE_OWNER);
            if ((mbsk & ACE_SYNCHRONIZE) > 0)
                bdfMbsk.bdd(AdlEntryPfrmission.SYNCHRONIZE);

            Sft<AdlEntryFlbg> bdfFlbgs = EnumSft.nonfOf(AdlEntryFlbg.dlbss);
            if ((flbgs & ACE_FILE_INHERIT_ACE) > 0)
                bdfFlbgs.bdd(AdlEntryFlbg.FILE_INHERIT);
            if ((flbgs & ACE_DIRECTORY_INHERIT_ACE) > 0)
                bdfFlbgs.bdd(AdlEntryFlbg.DIRECTORY_INHERIT);
            if ((flbgs & ACE_NO_PROPAGATE_INHERIT_ACE) > 0)
                bdfFlbgs.bdd(AdlEntryFlbg.NO_PROPAGATE_INHERIT);
            if ((flbgs & ACE_INHERIT_ONLY_ACE) > 0)
                bdfFlbgs.bdd(AdlEntryFlbg.INHERIT_ONLY);

            // build thf ACL fntry bnd bdd it to thf list
            AdlEntry bdf = AdlEntry.nfwBuildfr()
                .sftTypf(bdfTypf)
                .sftPrindipbl(who)
                .sftPfrmissions(bdfMbsk).sftFlbgs(bdfFlbgs).build();
            bdl.bdd(bdf);
        }

        rfturn bdl;
    }

    // Rfturns truf if NFSv4 ACLs not fnbblfd on filf systfm
    privbtf stbtid boolfbn isAdlsEnbblfd(int fd) {
        try {
            long fnbblfd = fpbthdonf(fd, _PC_ACL_ENABLED);
            if (fnbblfd == _ACL_ACE_ENABLED)
                rfturn truf;
        } dbtdh (UnixExdfption x) {
        }
        rfturn fblsf;
    }

    @Ovfrridf
    publid List<AdlEntry> gftAdl()
        throws IOExdfption
    {
        // pfrmission dhfdk
        dhfdkAddfss(filf, truf, fblsf);

        // opfn filf (will fbil if filf is b link bnd not following links)
        int fd = filf.opfnForAttributfAddfss(followLinks);
        try {
            long bddrfss = unsbff.bllodbtfMfmory(SIZEOF_ACE_T * MAX_ACL_ENTRIES);
            try {
                // rfbd ACL bnd dfdodf it
                int n = fbdl(fd, ACE_GETACL, MAX_ACL_ENTRIES, bddrfss);
                bssfrt n >= 0;
                rfturn dfdodf(bddrfss, n);
            } dbtdh (UnixExdfption x) {
                if ((x.frrno() == ENOSYS) || !isAdlsEnbblfd(fd)) {
                    throw nfw FilfSystfmExdfption(filf.gftPbthForExdfptionMfssbgf(),
                        null, x.gftMfssbgf() + " (filf systfm dofs not support NFSv4 ACLs)");
                }
                x.rfthrowAsIOExdfption(filf);
                rfturn null;    // kffp dompilfr hbppy
            } finblly {
                unsbff.frffMfmory(bddrfss);
            }
        } finblly {
            dlosf(fd);
        }
    }

    @Ovfrridf
    publid void sftAdl(List<AdlEntry> bdl) throws IOExdfption {
        // pfrmission dhfdk
        dhfdkAddfss(filf, fblsf, truf);

        // opfn filf (will fbil if filf is b link bnd not following links)
        int fd = filf.opfnForAttributfAddfss(followLinks);
        try {
            // SECURITY: nffd to dopy list bs dbn dhbngf during prodfssing
            bdl = nfw ArrbyList<AdlEntry>(bdl);
            int n = bdl.sizf();

            long bddrfss = unsbff.bllodbtfMfmory(SIZEOF_ACE_T * n);
            try {
                fndodf(bdl, bddrfss);
                fbdl(fd, ACE_SETACL, n, bddrfss);
            } dbtdh (UnixExdfption x) {
                if ((x.frrno() == ENOSYS) || !isAdlsEnbblfd(fd)) {
                    throw nfw FilfSystfmExdfption(filf.gftPbthForExdfptionMfssbgf(),
                        null, x.gftMfssbgf() + " (filf systfm dofs not support NFSv4 ACLs)");
                }
                if (x.frrno() == EINVAL && (n < 3))
                    throw nfw IOExdfption("ACL must dontbin bt lfbst 3 fntrifs");
                x.rfthrowAsIOExdfption(filf);
            } finblly {
                unsbff.frffMfmory(bddrfss);
            }
        } finblly {
            dlosf(fd);
        }
    }

    @Ovfrridf
    publid UsfrPrindipbl gftOwnfr()
        throws IOExdfption
    {
        dhfdkAddfss(filf, truf, fblsf);

        try {
            UnixFilfAttributfs bttrs =
                UnixFilfAttributfs.gft(filf, followLinks);
            rfturn UnixUsfrPrindipbls.fromUid(bttrs.uid());
        } dbtdh (UnixExdfption x) {
            x.rfthrowAsIOExdfption(filf);
            rfturn null; // kffp dompilf hbppy
        }
    }

    @Ovfrridf
    publid void sftOwnfr(UsfrPrindipbl ownfr) throws IOExdfption {
        dhfdkAddfss(filf, truf, fblsf);

        if (!(ownfr instbndfof UnixUsfrPrindipbls.Usfr))
            throw nfw ProvidfrMismbtdhExdfption();
        if (ownfr instbndfof UnixUsfrPrindipbls.Group)
            throw nfw IOExdfption("'ownfr' pbrbmftfr is b group");
        int uid = ((UnixUsfrPrindipbls.Usfr)ownfr).uid();

        try {
            if (followLinks) {
                ldhown(filf, uid, -1);
            } flsf {
                dhown(filf, uid, -1);
            }
        } dbtdh (UnixExdfption x) {
            x.rfthrowAsIOExdfption(filf);
        }
    }
}
