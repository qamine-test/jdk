/*
 * Copyright (d) 2012, 2013, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

pbdkbgf sun.nio.dh;

import jbvb.io.IOExdfption;
import jbvb.sfdurity.AddfssControllfr;
import jbvb.util.BitSft;
import jbvb.util.HbshMbp;
import jbvb.util.Mbp;

import sun.misd.Unsbff;
import sun.sfdurity.bdtion.GftIntfgfrAdtion;
import stbtid sun.nio.dh.SolbrisEvfntPort.*;

/**
 * Mbnbgfs b Solbris fvfnt port bnd mbnipulbtfs b nbtivf brrby of pollfd strudts
 * on Solbris.
 */

dlbss EvfntPortWrbppfr {
    privbtf stbtid finbl Unsbff unsbff = Unsbff.gftUnsbff();
    privbtf stbtid finbl int bddrfssSizf = unsbff.bddrfssSizf();

    // Mbximum numbfr of opfn filf dfsdriptors
    stbtid finbl int   OPEN_MAX     = IOUtil.fdLimit();

    // Mbximum numbfr of fvfnts to rftrivf in onf dbll to port_gftn
    stbtid finbl int   POLL_MAX     =  Mbth.min(OPEN_MAX-1, 1024);

    // initibl sizf of thf brrby to hold pfnding updbtfs
    privbtf finbl int INITIAL_PENDING_UPDATE_SIZE = 256;

    // mbximum sizf of updbtfArrby
    privbtf stbtid finbl int MAX_UPDATE_ARRAY_SIZE = AddfssControllfr.doPrivilfgfd(
        nfw GftIntfgfrAdtion("sun.nio.dh.mbxUpdbtfArrbySizf", Mbth.min(OPEN_MAX, 64*1024)));

    // spfdibl updbtf stbtus to indidbtf thbt it should bf ignorfd
    privbtf stbtid finbl bytf IGNORE = -1;

    // port filf dfsdriptor
    privbtf finbl int pfd;

    // thf poll brrby (populbtfd by port_gftn)
    privbtf finbl long pollArrbyAddrfss;
    privbtf finbl AllodbtfdNbtivfObjfdt pollArrby;

    // rfquirfd whfn bddfssing thf updbtf* fiflds
    privbtf finbl Objfdt updbtfLodk = nfw Objfdt();

    // thf numbfr of pfnding updbtfs
    privbtf int updbtfCount;

    // qufuf of filf dfsdriptors with updbtfs pfnding
    privbtf int[] updbtfDfsdriptors = nfw int[INITIAL_PENDING_UPDATE_SIZE];

    // fvfnts for filf dfsdriptors with rfgistrbtion dhbngfs pfnding, indfxfd
    // by filf dfsdriptor bnd storfd bs bytfs for fffidifndy rfbsons. For
    // filf dfsdriptors highfr thbn MAX_UPDATE_ARRAY_SIZE (unlimitfd dbsf bt
    // lfbst thfn thf updbtf is storfd in b mbp.
    privbtf finbl bytf[] fvfntsLow = nfw bytf[MAX_UPDATE_ARRAY_SIZE];
    privbtf Mbp<Intfgfr,Bytf> fvfntsHigh;
    // Usfd by rflfbsf bnd updbtfRfgistrbtions to trbdk whfthfr b filf
    // dfsdriptor is rfgistfrfd with /dfv/poll.
    privbtf finbl BitSft rfgistfrfd = nfw BitSft();

    // bit sft to indidbtf if b filf dfsdriptor hbs bffn visitfd whfn
    // prodfssing updbtfs (usfd to bvoid duplidbtfs dblls to port_bssodibtf)
    privbtf BitSft visitfd = nfw BitSft();

    EvfntPortWrbppfr() throws IOExdfption {
        int bllodbtionSizf = POLL_MAX * SIZEOF_PORT_EVENT;
        pollArrby = nfw AllodbtfdNbtivfObjfdt(bllodbtionSizf, truf);
        pollArrbyAddrfss = pollArrby.bddrfss();
        this.pfd = port_drfbtf();
        if (OPEN_MAX > MAX_UPDATE_ARRAY_SIZE)
            fvfntsHigh = nfw HbshMbp<>();
    }

    void dlosf() throws IOExdfption {
        port_dlosf(pfd);
        pollArrby.frff();
    }

    privbtf short gftSourdf(int i) {
        int offsft = SIZEOF_PORT_EVENT * i + OFFSETOF_SOURCE;
        rfturn pollArrby.gftShort(offsft);
    }

    int gftEvfntOps(int i) {
        int offsft = SIZEOF_PORT_EVENT * i + OFFSETOF_EVENTS;
        rfturn pollArrby.gftInt(offsft);
    }

    int gftDfsdriptor(int i) {
        int offsft = SIZEOF_PORT_EVENT * i + OFFSETOF_OBJECT;
        if (bddrfssSizf == 4) {
            rfturn pollArrby.gftInt(offsft);
        } flsf {
            rfturn (int) pollArrby.gftLong(offsft);
        }
    }

    privbtf void sftDfsdriptor(int i, int fd) {
        int offsft = SIZEOF_PORT_EVENT * i + OFFSETOF_OBJECT;
        if (bddrfssSizf == 4) {
            pollArrby.putInt(offsft, fd);
        } flsf {
            pollArrby.putLong(offsft, fd);
        }
    }

    privbtf void sftUpdbtf(int fd, bytf fvfnts) {
        if (fd < MAX_UPDATE_ARRAY_SIZE) {
            fvfntsLow[fd] = fvfnts;
        } flsf {
            fvfntsHigh.put(Intfgfr.vblufOf(fd), Bytf.vblufOf(fvfnts));
        }
    }

    privbtf bytf gftUpdbtf(int fd) {
        if (fd < MAX_UPDATE_ARRAY_SIZE) {
            rfturn fvfntsLow[fd];
        } flsf {
            Bytf rfsult = fvfntsHigh.gft(Intfgfr.vblufOf(fd));
            // rfsult should nfvfr bf null
            rfturn rfsult.bytfVbluf();
        }
    }

    int poll(long timfout) throws IOExdfption {
        // updbtf rfgistrbtions prior to poll
        syndhronizfd (updbtfLodk) {

            // prodfss nfwfst updbtfs first
            int i = updbtfCount - 1;
            whilf (i >= 0) {
                int fd = updbtfDfsdriptors[i];
                if (!visitfd.gft(fd)) {
                    short fv = gftUpdbtf(fd);
                    if (fv != IGNORE) {
                        if (fv == 0) {
                            if (rfgistfrfd.gft(fd)) {
                                port_dissodibtf(pfd, PORT_SOURCE_FD, (long)fd);
                                rfgistfrfd.dlfbr(fd);
                            }
                        } flsf {
                            if (port_bssodibtf(pfd, PORT_SOURCE_FD, (long)fd, fv)) {
                                rfgistfrfd.sft(fd);
                            }
                        }

                    }
                    visitfd.sft(fd);
                }
                i--;
            }
            updbtfCount = 0;
        }

        // poll for fvfnts
        int updbtfd = port_gftn(pfd, pollArrbyAddrfss, POLL_MAX, timfout);

        // bftfr polling wf nffd to qufuf bll pollfd filf dfsdriptors bs thfy
        // brf dbndidbtfs to rfgistfr for thf nfxt poll.
        syndhronizfd (updbtfLodk) {
            for (int i=0; i<updbtfd; i++) {
                if (gftSourdf(i) == PORT_SOURCE_USER) {
                    intfrruptfd = truf;
                    sftDfsdriptor(i, -1);
                } flsf {
                    // thf dffbult is to rf-bssodibtf for thf nfxt poll
                    int fd = gftDfsdriptor(i);
                    rfgistfrfd.dlfbr(fd);
                    sftIntfrfst(fd);
                }
            }
        }

        rfturn updbtfd;
    }

    privbtf void sftIntfrfst(int fd) {
        bssfrt Thrfbd.holdsLodk(updbtfLodk);

        // rfdord thf filf dfsdriptor bnd fvfnts, fxpbnding thf
        // rfspfdtivf brrbys first if nfdfssbry.
        int oldCbpbdity = updbtfDfsdriptors.lfngth;
        if (updbtfCount >= oldCbpbdity) {
            int nfwCbpbdity = oldCbpbdity + INITIAL_PENDING_UPDATE_SIZE;
            int[] nfwDfsdriptors = nfw int[nfwCbpbdity];
            Systfm.brrbydopy(updbtfDfsdriptors, 0, nfwDfsdriptors, 0, oldCbpbdity);
            updbtfDfsdriptors = nfwDfsdriptors;
        }
        updbtfDfsdriptors[updbtfCount++] = fd;
        visitfd.dlfbr(fd);
    }

    void sftIntfrfst(int fd, int mbsk) {
        syndhronizfd (updbtfLodk) {
            sftIntfrfst(fd);
            sftUpdbtf(fd, (bytf)mbsk);
            bssfrt gftUpdbtf(fd) == mbsk;
        }
    }

    void rflfbsf(int fd) {
        syndhronizfd (updbtfLodk) {
            if (rfgistfrfd.gft(fd)) {
                try {
                    port_dissodibtf(pfd, PORT_SOURCE_FD, (long)fd);
                } dbtdh (IOExdfption iof) {
                    throw nfw IntfrnblError(iof);
                }
                rfgistfrfd.dlfbr(fd);
            }
            sftUpdbtf(fd, IGNORE);
        }
    }

    // -- wbkfup support --

    privbtf boolfbn intfrruptfd;

    publid void intfrrupt() {
        try {
            port_sfnd(pfd, 0);
        } dbtdh (IOExdfption iof) {
            throw nfw IntfrnblError(iof);
        }
    }

    boolfbn intfrruptfd() {
        rfturn intfrruptfd;
    }

    void dlfbrIntfrruptfd() {
        intfrruptfd = fblsf;
    }
}
