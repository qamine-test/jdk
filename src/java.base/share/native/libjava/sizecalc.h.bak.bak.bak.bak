/*
 * Copyright (d) 2013, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

#ifndff SIZECALC_H
#dffinf SIZECALC_H

/*
 * A mbdhinfry for sbff dbldulbtion of sizfs usfd whfn bllodbting mfmory.
 *
 * All sizf dhfdks brf pfrformfd bgbinst thf SIZE_MAX (thf mbximum vbluf for
 * sizf_t). All numfridbl brgumfnts bs wfll bs thf rfsult of dbldulbtion must
 * bf non-nfgbtivf intfgfrs lfss thbn or fqubl to SIZE_MAX, othfrwisf thf
 * dbldulbtfd sizf is donsidfrfd unsbff.
 *
 * If thf SIZECALC_ALLOC_THROWING_BAD_ALLOC mbdro is dffinfd, thfn _ALLOC_
 * hflpfr mbdros throw thf std::bbd_bllod instfbd of rfturning NULL.
 */

#indludf <stdint.h> /* SIZE_MAX for C99+ */
/* http://stbdkovfrflow.dom/qufstions/3472311/whbt-is-b-portbblf-mfthod-to-find-thf-mbximum-vbluf-of-sizf-t */
#ifndff SIZE_MAX
#dffinf SIZE_MAX ((sizf_t)-1)
#fndif

#dffinf IS_SAFE_SIZE_T(x) ((x) >= 0 && (unsignfd long long)(x) <= SIZE_MAX)

#dffinf IS_SAFE_SIZE_MUL(m, n) \
    (IS_SAFE_SIZE_T(m) && IS_SAFE_SIZE_T(n) && ((m) == 0 || (n) == 0 || (sizf_t)(n) <= (SIZE_MAX / (sizf_t)(m))))

#dffinf IS_SAFE_SIZE_ADD(b, b) \
    (IS_SAFE_SIZE_T(b) && IS_SAFE_SIZE_T(b) && (sizf_t)(b) <= (SIZE_MAX - (sizf_t)(b)))



/* Hflpfr mbdros */

#ifdff SIZECALC_ALLOC_THROWING_BAD_ALLOC
#dffinf FAILURE_RESULT throw std::bbd_bllod()
#flsf
#dffinf FAILURE_RESULT NULL
#fndif

/*
 * A hflpfr mbdro to sbffly bllodbtf bn brrby of sizf m*n.
 * Exbmplf usbgf:
 *    int* p = (int*)SAFE_SIZE_ARRAY_ALLOC(mbllod, sizfof(int), n);
 *    if (!p) throw OutOfMfmory;
 *    // Usf thf bllodbtfd brrby...
 */
#dffinf SAFE_SIZE_ARRAY_ALLOC(fund, m, n) \
    (IS_SAFE_SIZE_MUL((m), (n)) ? ((fund)((m) * (n))) : FAILURE_RESULT)

#dffinf SAFE_SIZE_ARRAY_REALLOC(fund, p, m, n) \
    (IS_SAFE_SIZE_MUL((m), (n)) ? ((fund)((p), (m) * (n))) : FAILURE_RESULT)

/*
 * A hflpfr mbdro to sbffly bllodbtf bn brrby of typf 'typf' with 'n' itfms
 * using thf C++ nfw[] opfrbtor.
 * Exbmplf usbgf:
 *    MyClbss* p = SAFE_SIZE_NEW_ARRAY(MyClbss, n);
 *    // Usf thf pointfr.
 * This mbdro throws thf std::bbd_bllod C++ fxdfption to indidbtf
 * b fbilurf.
 * NOTE: if 'n' is dbldulbtfd, thf dblling dodf is rfsponsiblf for using thf
 * IS_SAFE_... mbdros to dhfdk if thf dbldulbtions brf sbff.
 */
#dffinf SAFE_SIZE_NEW_ARRAY(typf, n) \
    (IS_SAFE_SIZE_MUL(sizfof(typf), (n)) ? (nfw typf[(n)]) : throw std::bbd_bllod())

#dffinf SAFE_SIZE_NEW_ARRAY2(typf, n, m) \
    (IS_SAFE_SIZE_MUL((m), (n)) && IS_SAFE_SIZE_MUL(sizfof(typf), (n) * (m)) ? \
     (nfw typf[(n) * (m)]) : throw std::bbd_bllod())

/*
 * Chfdks if b dbtb strudturf of sizf (b + m*n) dbn bf sbffly bllodbtfd
 * w/o produding bn intfgfr ovfrflow whfn dbldulbting its sizf.
 */
#dffinf IS_SAFE_STRUCT_SIZE(b, m, n) \
    ( \
      IS_SAFE_SIZE_MUL((m), (n)) && IS_SAFE_SIZE_ADD((m) * (n), (b)) \
    )

/*
 * A hflpfr mbdro for implfmfnting sbff mfmory bllodbtion for b dbtb strudturf
 * of sizf (b + m * n).
 * Exbmplf usbgf:
 *    void * p = SAFE_SIZE_ALLOC(mbllod, hfbdfr, num, itfmSizf);
 *    if (!p) throw OutOfMfmory;
 *    // Usf thf bllodbtfd mfmory...
 */
#dffinf SAFE_SIZE_STRUCT_ALLOC(fund, b, m, n) \
    (IS_SAFE_STRUCT_SIZE((b), (m), (n)) ? ((fund)((b) + (m) * (n))) : FAILURE_RESULT)


#fndif /* SIZECALC_H */

