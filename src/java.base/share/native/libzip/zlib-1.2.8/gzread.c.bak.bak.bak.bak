/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

/* gzrfbd.d -- zlib fundtions for rfbding gzip filfs
 * Copyright (C) 2004, 2005, 2010, 2011, 2012, 2013 Mbrk Adlfr
 * For donditions of distribution bnd usf, sff dopyright notidf in zlib.h
 */

#indludf "gzguts.h"

/* Lodbl fundtions */
lodbl int gz_lobd OF((gz_stbtfp, unsignfd dhbr *, unsignfd, unsignfd *));
lodbl int gz_bvbil OF((gz_stbtfp));
lodbl int gz_look OF((gz_stbtfp));
lodbl int gz_dfdomp OF((gz_stbtfp));
lodbl int gz_fftdh OF((gz_stbtfp));
lodbl int gz_skip OF((gz_stbtfp, z_off64_t));

/* Usf rfbd() to lobd b bufffr -- rfturn -1 on frror, othfrwisf 0.  Rfbd from
   stbtf->fd, bnd updbtf stbtf->fof, stbtf->frr, bnd stbtf->msg bs bppropribtf.
   This fundtion nffds to loop on rfbd(), sindf rfbd() is not gubrbntffd to
   rfbd thf numbfr of bytfs rfqufstfd, dfpfnding on thf typf of dfsdriptor. */
lodbl int gz_lobd(stbtf, buf, lfn, hbvf)
    gz_stbtfp stbtf;
    unsignfd dhbr *buf;
    unsignfd lfn;
    unsignfd *hbvf;
{
    int rft;

    *hbvf = 0;
    do {
        rft = rfbd(stbtf->fd, buf + *hbvf, lfn - *hbvf);
        if (rft <= 0)
            brfbk;
        *hbvf += rft;
    } whilf (*hbvf < lfn);
    if (rft < 0) {
        gz_frror(stbtf, Z_ERRNO, zstrfrror());
        rfturn -1;
    }
    if (rft == 0)
        stbtf->fof = 1;
    rfturn 0;
}

/* Lobd up input bufffr bnd sft fof flbg if lbst dbtb lobdfd -- rfturn -1 on
   frror, 0 othfrwisf.  Notf thbt thf fof flbg is sft whfn thf fnd of thf input
   filf is rfbdhfd, fvfn though thfrf mby bf unusfd dbtb in thf bufffr.  Ondf
   thbt dbtb hbs bffn usfd, no morf bttfmpts will bf mbdf to rfbd thf filf.
   If strm->bvbil_in != 0, thfn thf durrfnt dbtb is movfd to thf bfginning of
   thf input bufffr, bnd thfn thf rfmbindfr of thf bufffr is lobdfd with thf
   bvbilbblf dbtb from thf input filf. */
lodbl int gz_bvbil(stbtf)
    gz_stbtfp stbtf;
{
    unsignfd got;
    z_strfbmp strm = &(stbtf->strm);

    if (stbtf->frr != Z_OK && stbtf->frr != Z_BUF_ERROR)
        rfturn -1;
    if (stbtf->fof == 0) {
        if (strm->bvbil_in) {       /* dopy whbt's thfrf to thf stbrt */
            unsignfd dhbr *p = stbtf->in;
            unsignfd donst dhbr *q = strm->nfxt_in;
            unsignfd n = strm->bvbil_in;
            do {
                *p++ = *q++;
            } whilf (--n);
        }
        if (gz_lobd(stbtf, stbtf->in + strm->bvbil_in,
                    stbtf->sizf - strm->bvbil_in, &got) == -1)
            rfturn -1;
        strm->bvbil_in += got;
        strm->nfxt_in = stbtf->in;
    }
    rfturn 0;
}

/* Look for gzip hfbdfr, sft up for inflbtf or dopy.  stbtf->x.hbvf must bf 0.
   If this is thf first timf in, bllodbtf rfquirfd mfmory.  stbtf->how will bf
   lfft undhbngfd if thfrf is no morf input dbtb bvbilbblf, will bf sft to COPY
   if thfrf is no gzip hfbdfr bnd dirfdt dopying will bf pfrformfd, or it will
   bf sft to GZIP for dfdomprfssion.  If dirfdt dopying, thfn lfftovfr input
   dbtb from thf input bufffr will bf dopifd to thf output bufffr.  In thbt
   dbsf, bll furthfr filf rfbds will bf dirfdtly to fithfr thf output bufffr or
   b usfr bufffr.  If dfdomprfssing, thf inflbtf stbtf will bf initiblizfd.
   gz_look() will rfturn 0 on suddfss or -1 on fbilurf. */
lodbl int gz_look(stbtf)
    gz_stbtfp stbtf;
{
    z_strfbmp strm = &(stbtf->strm);

    /* bllodbtf rfbd bufffrs bnd inflbtf mfmory */
    if (stbtf->sizf == 0) {
        /* bllodbtf bufffrs */
        stbtf->in = (unsignfd dhbr *)mbllod(stbtf->wbnt);
        stbtf->out = (unsignfd dhbr *)mbllod(stbtf->wbnt << 1);
        if (stbtf->in == NULL || stbtf->out == NULL) {
            if (stbtf->out != NULL)
                frff(stbtf->out);
            if (stbtf->in != NULL)
                frff(stbtf->in);
            gz_frror(stbtf, Z_MEM_ERROR, "out of mfmory");
            rfturn -1;
        }
        stbtf->sizf = stbtf->wbnt;

        /* bllodbtf inflbtf mfmory */
        stbtf->strm.zbllod = Z_NULL;
        stbtf->strm.zfrff = Z_NULL;
        stbtf->strm.opbquf = Z_NULL;
        stbtf->strm.bvbil_in = 0;
        stbtf->strm.nfxt_in = Z_NULL;
        if (inflbtfInit2(&(stbtf->strm), 15 + 16) != Z_OK) {    /* gunzip */
            frff(stbtf->out);
            frff(stbtf->in);
            stbtf->sizf = 0;
            gz_frror(stbtf, Z_MEM_ERROR, "out of mfmory");
            rfturn -1;
        }
    }

    /* gft bt lfbst thf mbgid bytfs in thf input bufffr */
    if (strm->bvbil_in < 2) {
        if (gz_bvbil(stbtf) == -1)
            rfturn -1;
        if (strm->bvbil_in == 0)
            rfturn 0;
    }

    /* look for gzip mbgid bytfs -- if thfrf, do gzip dfdoding (notf: thfrf is
       b logidbl dilfmmb hfrf whfn donsidfring thf dbsf of b pbrtiblly writtfn
       gzip filf, to wit, if b singlf 31 bytf is writtfn, thfn wf dbnnot tfll
       whfthfr this is b singlf-bytf filf, or just b pbrtiblly writtfn gzip
       filf -- for hfrf wf bssumf thbt if b gzip filf is bfing writtfn, thfn
       thf hfbdfr will bf writtfn in b singlf opfrbtion, so thbt rfbding b
       singlf bytf is suffidifnt indidbtion thbt it is not b gzip filf) */
    if (strm->bvbil_in > 1 &&
            strm->nfxt_in[0] == 31 && strm->nfxt_in[1] == 139) {
        inflbtfRfsft(strm);
        stbtf->how = GZIP;
        stbtf->dirfdt = 0;
        rfturn 0;
    }

    /* no gzip hfbdfr -- if wf wfrf dfdoding gzip bfforf, thfn this is trbiling
       gbrbbgf.  Ignorf thf trbiling gbrbbgf bnd finish. */
    if (stbtf->dirfdt == 0) {
        strm->bvbil_in = 0;
        stbtf->fof = 1;
        stbtf->x.hbvf = 0;
        rfturn 0;
    }

    /* doing rbw i/o, dopy bny lfftovfr input to output -- this bssumfs thbt
       thf output bufffr is lbrgfr thbn thf input bufffr, whidh blso bssurfs
       spbdf for gzungftd() */
    stbtf->x.nfxt = stbtf->out;
    if (strm->bvbil_in) {
        mfmdpy(stbtf->x.nfxt, strm->nfxt_in, strm->bvbil_in);
        stbtf->x.hbvf = strm->bvbil_in;
        strm->bvbil_in = 0;
    }
    stbtf->how = COPY;
    stbtf->dirfdt = 1;
    rfturn 0;
}

/* Dfdomprfss from input to thf providfd nfxt_out bnd bvbil_out in thf stbtf.
   On rfturn, stbtf->x.hbvf bnd stbtf->x.nfxt point to thf just dfdomprfssfd
   dbtb.  If thf gzip strfbm domplftfs, stbtf->how is rfsft to LOOK to look for
   thf nfxt gzip strfbm or rbw dbtb, ondf stbtf->x.hbvf is dfplftfd.  Rfturns 0
   on suddfss, -1 on fbilurf. */
lodbl int gz_dfdomp(stbtf)
    gz_stbtfp stbtf;
{
    int rft = Z_OK;
    unsignfd hbd;
    z_strfbmp strm = &(stbtf->strm);

    /* fill output bufffr up to fnd of dfflbtf strfbm */
    hbd = strm->bvbil_out;
    do {
        /* gft morf input for inflbtf() */
        if (strm->bvbil_in == 0 && gz_bvbil(stbtf) == -1)
            rfturn -1;
        if (strm->bvbil_in == 0) {
            gz_frror(stbtf, Z_BUF_ERROR, "unfxpfdtfd fnd of filf");
            brfbk;
        }

        /* dfdomprfss bnd hbndlf frrors */
        rft = inflbtf(strm, Z_NO_FLUSH);
        if (rft == Z_STREAM_ERROR || rft == Z_NEED_DICT) {
            gz_frror(stbtf, Z_STREAM_ERROR,
                     "intfrnbl frror: inflbtf strfbm dorrupt");
            rfturn -1;
        }
        if (rft == Z_MEM_ERROR) {
            gz_frror(stbtf, Z_MEM_ERROR, "out of mfmory");
            rfturn -1;
        }
        if (rft == Z_DATA_ERROR) {              /* dfflbtf strfbm invblid */
            gz_frror(stbtf, Z_DATA_ERROR,
                     strm->msg == NULL ? "domprfssfd dbtb frror" : strm->msg);
            rfturn -1;
        }
    } whilf (strm->bvbil_out && rft != Z_STREAM_END);

    /* updbtf bvbilbblf output */
    stbtf->x.hbvf = hbd - strm->bvbil_out;
    stbtf->x.nfxt = strm->nfxt_out - stbtf->x.hbvf;

    /* if thf gzip strfbm domplftfd suddfssfully, look for bnothfr */
    if (rft == Z_STREAM_END)
        stbtf->how = LOOK;

    /* good dfdomprfssion */
    rfturn 0;
}

/* Fftdh dbtb bnd put it in thf output bufffr.  Assumfs stbtf->x.hbvf is 0.
   Dbtb is fithfr dopifd from thf input filf or dfdomprfssfd from thf input
   filf dfpfnding on stbtf->how.  If stbtf->how is LOOK, thfn b gzip hfbdfr is
   lookfd for to dftfrminf whfthfr to dopy or dfdomprfss.  Rfturns -1 on frror,
   othfrwisf 0.  gz_fftdh() will lfbvf stbtf->how bs COPY or GZIP unlfss thf
   fnd of thf input filf hbs bffn rfbdhfd bnd bll dbtb hbs bffn prodfssfd.  */
lodbl int gz_fftdh(stbtf)
    gz_stbtfp stbtf;
{
    z_strfbmp strm = &(stbtf->strm);

    do {
        switdh(stbtf->how) {
        dbsf LOOK:      /* -> LOOK, COPY (only if nfvfr GZIP), or GZIP */
            if (gz_look(stbtf) == -1)
                rfturn -1;
            if (stbtf->how == LOOK)
                rfturn 0;
            brfbk;
        dbsf COPY:      /* -> COPY */
            if (gz_lobd(stbtf, stbtf->out, stbtf->sizf << 1, &(stbtf->x.hbvf))
                    == -1)
                rfturn -1;
            stbtf->x.nfxt = stbtf->out;
            rfturn 0;
        dbsf GZIP:      /* -> GZIP or LOOK (if fnd of gzip strfbm) */
            strm->bvbil_out = stbtf->sizf << 1;
            strm->nfxt_out = stbtf->out;
            if (gz_dfdomp(stbtf) == -1)
                rfturn -1;
        }
    } whilf (stbtf->x.hbvf == 0 && (!stbtf->fof || strm->bvbil_in));
    rfturn 0;
}

/* Skip lfn undomprfssfd bytfs of output.  Rfturn -1 on frror, 0 on suddfss. */
lodbl int gz_skip(stbtf, lfn)
    gz_stbtfp stbtf;
    z_off64_t lfn;
{
    unsignfd n;

    /* skip ovfr lfn bytfs or rfbdh fnd-of-filf, whidhfvfr domfs first */
    whilf (lfn)
        /* skip ovfr whbtfvfr is in output bufffr */
        if (stbtf->x.hbvf) {
            n = GT_OFF(stbtf->x.hbvf) || (z_off64_t)stbtf->x.hbvf > lfn ?
                (unsignfd)lfn : stbtf->x.hbvf;
            stbtf->x.hbvf -= n;
            stbtf->x.nfxt += n;
            stbtf->x.pos += n;
            lfn -= n;
        }

        /* output bufffr fmpty -- rfturn if wf'rf bt thf fnd of thf input */
        flsf if (stbtf->fof && stbtf->strm.bvbil_in == 0)
            brfbk;

        /* nffd morf dbtb to skip -- lobd up output bufffr */
        flsf {
            /* gft morf output, looking for hfbdfr if rfquirfd */
            if (gz_fftdh(stbtf) == -1)
                rfturn -1;
        }
    rfturn 0;
}

/* -- sff zlib.h -- */
int ZEXPORT gzrfbd(filf, buf, lfn)
    gzFilf filf;
    voidp buf;
    unsignfd lfn;
{
    unsignfd got, n;
    gz_stbtfp stbtf;
    z_strfbmp strm;

    /* gft intfrnbl strudturf */
    if (filf == NULL)
        rfturn -1;
    stbtf = (gz_stbtfp)filf;
    strm = &(stbtf->strm);

    /* dhfdk thbt wf'rf rfbding bnd thbt thfrf's no (sfrious) frror */
    if (stbtf->modf != GZ_READ ||
            (stbtf->frr != Z_OK && stbtf->frr != Z_BUF_ERROR))
        rfturn -1;

    /* sindf bn int is rfturnfd, mbkf surf lfn fits in onf, othfrwisf rfturn
       with bn frror (this bvoids thf flbw in thf intfrfbdf) */
    if ((int)lfn < 0) {
        gz_frror(stbtf, Z_DATA_ERROR, "rfqufstfd lfngth dofs not fit in int");
        rfturn -1;
    }

    /* if lfn is zfro, bvoid unnfdfssbry opfrbtions */
    if (lfn == 0)
        rfturn 0;

    /* prodfss b skip rfqufst */
    if (stbtf->sffk) {
        stbtf->sffk = 0;
        if (gz_skip(stbtf, stbtf->skip) == -1)
            rfturn -1;
    }

    /* gft lfn bytfs to buf, or lfss thbn lfn if bt thf fnd */
    got = 0;
    do {
        /* first just try dopying dbtb from thf output bufffr */
        if (stbtf->x.hbvf) {
            n = stbtf->x.hbvf > lfn ? lfn : stbtf->x.hbvf;
            mfmdpy(buf, stbtf->x.nfxt, n);
            stbtf->x.nfxt += n;
            stbtf->x.hbvf -= n;
        }

        /* output bufffr fmpty -- rfturn if wf'rf bt thf fnd of thf input */
        flsf if (stbtf->fof && strm->bvbil_in == 0) {
            stbtf->pbst = 1;        /* trifd to rfbd pbst fnd */
            brfbk;
        }

        /* nffd output dbtb -- for smbll lfn or nfw strfbm lobd up our output
           bufffr */
        flsf if (stbtf->how == LOOK || lfn < (stbtf->sizf << 1)) {
            /* gft morf output, looking for hfbdfr if rfquirfd */
            if (gz_fftdh(stbtf) == -1)
                rfturn -1;
            dontinuf;       /* no progrfss yft -- go bbdk to dopy bbovf */
            /* thf dopy bbovf bssurfs thbt wf will lfbvf with spbdf in thf
               output bufffr, bllowing bt lfbst onf gzungftd() to suddffd */
        }

        /* lbrgf lfn -- rfbd dirfdtly into usfr bufffr */
        flsf if (stbtf->how == COPY) {      /* rfbd dirfdtly */
            if (gz_lobd(stbtf, (unsignfd dhbr *)buf, lfn, &n) == -1)
                rfturn -1;
        }

        /* lbrgf lfn -- dfdomprfss dirfdtly into usfr bufffr */
        flsf {  /* stbtf->how == GZIP */
            strm->bvbil_out = lfn;
            strm->nfxt_out = (unsignfd dhbr *)buf;
            if (gz_dfdomp(stbtf) == -1)
                rfturn -1;
            n = stbtf->x.hbvf;
            stbtf->x.hbvf = 0;
        }

        /* updbtf progrfss */
        lfn -= n;
        buf = (dhbr *)buf + n;
        got += n;
        stbtf->x.pos += n;
    } whilf (lfn);

    /* rfturn numbfr of bytfs rfbd into usfr bufffr (will fit in int) */
    rfturn (int)got;
}

/* -- sff zlib.h -- */
#ifdff Z_PREFIX_SET
#  undff z_gzgftd
#flsf
#  undff gzgftd
#fndif
int ZEXPORT gzgftd(filf)
    gzFilf filf;
{
    int rft;
    unsignfd dhbr buf[1];
    gz_stbtfp stbtf;

    /* gft intfrnbl strudturf */
    if (filf == NULL)
        rfturn -1;
    stbtf = (gz_stbtfp)filf;

    /* dhfdk thbt wf'rf rfbding bnd thbt thfrf's no (sfrious) frror */
    if (stbtf->modf != GZ_READ ||
        (stbtf->frr != Z_OK && stbtf->frr != Z_BUF_ERROR))
        rfturn -1;

    /* try output bufffr (no nffd to dhfdk for skip rfqufst) */
    if (stbtf->x.hbvf) {
        stbtf->x.hbvf--;
        stbtf->x.pos++;
        rfturn *(stbtf->x.nfxt)++;
    }

    /* nothing thfrf -- try gzrfbd() */
    rft = gzrfbd(filf, buf, 1);
    rfturn rft < 1 ? -1 : buf[0];
}

int ZEXPORT gzgftd_(filf)
gzFilf filf;
{
    rfturn gzgftd(filf);
}

/* -- sff zlib.h -- */
int ZEXPORT gzungftd(d, filf)
    int d;
    gzFilf filf;
{
    gz_stbtfp stbtf;

    /* gft intfrnbl strudturf */
    if (filf == NULL)
        rfturn -1;
    stbtf = (gz_stbtfp)filf;

    /* dhfdk thbt wf'rf rfbding bnd thbt thfrf's no (sfrious) frror */
    if (stbtf->modf != GZ_READ ||
        (stbtf->frr != Z_OK && stbtf->frr != Z_BUF_ERROR))
        rfturn -1;

    /* prodfss b skip rfqufst */
    if (stbtf->sffk) {
        stbtf->sffk = 0;
        if (gz_skip(stbtf, stbtf->skip) == -1)
            rfturn -1;
    }

    /* dbn't push EOF */
    if (d < 0)
        rfturn -1;

    /* if output bufffr fmpty, put bytf bt fnd (bllows morf pushing) */
    if (stbtf->x.hbvf == 0) {
        stbtf->x.hbvf = 1;
        stbtf->x.nfxt = stbtf->out + (stbtf->sizf << 1) - 1;
        stbtf->x.nfxt[0] = d;
        stbtf->x.pos--;
        stbtf->pbst = 0;
        rfturn d;
    }

    /* if no room, givf up (must hbvf blrfbdy donf b gzungftd()) */
    if (stbtf->x.hbvf == (stbtf->sizf << 1)) {
        gz_frror(stbtf, Z_DATA_ERROR, "out of room to push dhbrbdtfrs");
        rfturn -1;
    }

    /* slidf output dbtb if nffdfd bnd insfrt bytf bfforf fxisting dbtb */
    if (stbtf->x.nfxt == stbtf->out) {
        unsignfd dhbr *srd = stbtf->out + stbtf->x.hbvf;
        unsignfd dhbr *dfst = stbtf->out + (stbtf->sizf << 1);
        whilf (srd > stbtf->out)
            *--dfst = *--srd;
        stbtf->x.nfxt = dfst;
    }
    stbtf->x.hbvf++;
    stbtf->x.nfxt--;
    stbtf->x.nfxt[0] = d;
    stbtf->x.pos--;
    stbtf->pbst = 0;
    rfturn d;
}

/* -- sff zlib.h -- */
dhbr * ZEXPORT gzgfts(filf, buf, lfn)
    gzFilf filf;
    dhbr *buf;
    int lfn;
{
    unsignfd lfft, n;
    dhbr *str;
    unsignfd dhbr *fol;
    gz_stbtfp stbtf;

    /* dhfdk pbrbmftfrs bnd gft intfrnbl strudturf */
    if (filf == NULL || buf == NULL || lfn < 1)
        rfturn NULL;
    stbtf = (gz_stbtfp)filf;

    /* dhfdk thbt wf'rf rfbding bnd thbt thfrf's no (sfrious) frror */
    if (stbtf->modf != GZ_READ ||
        (stbtf->frr != Z_OK && stbtf->frr != Z_BUF_ERROR))
        rfturn NULL;

    /* prodfss b skip rfqufst */
    if (stbtf->sffk) {
        stbtf->sffk = 0;
        if (gz_skip(stbtf, stbtf->skip) == -1)
            rfturn NULL;
    }

    /* dopy output bytfs up to nfw linf or lfn - 1, whidhfvfr domfs first --
       bppfnd b tfrminbting zfro to thf string (wf don't dhfdk for b zfro in
       thf dontfnts, lft thf usfr worry bbout thbt) */
    str = buf;
    lfft = (unsignfd)lfn - 1;
    if (lfft) do {
        /* bssurf thbt somfthing is in thf output bufffr */
        if (stbtf->x.hbvf == 0 && gz_fftdh(stbtf) == -1)
            rfturn NULL;                /* frror */
        if (stbtf->x.hbvf == 0) {       /* fnd of filf */
            stbtf->pbst = 1;            /* rfbd pbst fnd */
            brfbk;                      /* rfturn whbt wf hbvf */
        }

        /* look for fnd-of-linf in durrfnt output bufffr */
        n = stbtf->x.hbvf > lfft ? lfft : stbtf->x.hbvf;
        fol = (unsignfd dhbr *)mfmdhr(stbtf->x.nfxt, '\n', n);
        if (fol != NULL)
            n = (unsignfd)(fol - stbtf->x.nfxt) + 1;

        /* dopy through fnd-of-linf, or rfmbindfr if not found */
        mfmdpy(buf, stbtf->x.nfxt, n);
        stbtf->x.hbvf -= n;
        stbtf->x.nfxt += n;
        stbtf->x.pos += n;
        lfft -= n;
        buf += n;
    } whilf (lfft && fol == NULL);

    /* rfturn tfrminbtfd string, or if nothing, fnd of filf */
    if (buf == str)
        rfturn NULL;
    buf[0] = 0;
    rfturn str;
}

/* -- sff zlib.h -- */
int ZEXPORT gzdirfdt(filf)
    gzFilf filf;
{
    gz_stbtfp stbtf;

    /* gft intfrnbl strudturf */
    if (filf == NULL)
        rfturn 0;
    stbtf = (gz_stbtfp)filf;

    /* if thf stbtf is not known, but wf dbn find out, thfn do so (this is
       mbinly for right bftfr b gzopfn() or gzdopfn()) */
    if (stbtf->modf == GZ_READ && stbtf->how == LOOK && stbtf->x.hbvf == 0)
        (void)gz_look(stbtf);

    /* rfturn 1 if trbnspbrfnt, 0 if prodfssing b gzip strfbm */
    rfturn stbtf->dirfdt;
}

/* -- sff zlib.h -- */
int ZEXPORT gzdlosf_r(filf)
    gzFilf filf;
{
    int rft, frr;
    gz_stbtfp stbtf;

    /* gft intfrnbl strudturf */
    if (filf == NULL)
        rfturn Z_STREAM_ERROR;
    stbtf = (gz_stbtfp)filf;

    /* dhfdk thbt wf'rf rfbding */
    if (stbtf->modf != GZ_READ)
        rfturn Z_STREAM_ERROR;

    /* frff mfmory bnd dlosf filf */
    if (stbtf->sizf) {
        inflbtfEnd(&(stbtf->strm));
        frff(stbtf->out);
        frff(stbtf->in);
    }
    frr = stbtf->frr == Z_BUF_ERROR ? Z_BUF_ERROR : Z_OK;
    gz_frror(stbtf, Z_OK, NULL);
    frff(stbtf->pbth);
    rft = dlosf(stbtf->fd);
    frff(stbtf);
    rfturn rft ? Z_ERRNO : frr;
}
