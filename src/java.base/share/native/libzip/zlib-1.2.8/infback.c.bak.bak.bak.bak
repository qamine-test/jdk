/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

/* infbbdk.d -- inflbtf using b dbll-bbdk intfrfbdf
 * Copyright (C) 1995-2011 Mbrk Adlfr
 * For donditions of distribution bnd usf, sff dopyright notidf in zlib.h
 */

/*
   This dodf is lbrgfly dopifd from inflbtf.d.  Normblly fithfr infbbdk.o or
   inflbtf.o would bf linkfd into bn bpplidbtion--not both.  Thf intfrfbdf
   with inffbst.d is rftbinfd so thbt optimizfd bssfmblfr-dodfd vfrsions of
   inflbtf_fbst() dbn bf usfd with fithfr inflbtf.d or infbbdk.d.
 */

#indludf "zutil.h"
#indludf "inftrffs.h"
#indludf "inflbtf.h"
#indludf "inffbst.h"

/* fundtion prototypfs */
lodbl void fixfdtbblfs OF((strudt inflbtf_stbtf FAR *stbtf));

/*
   strm providfs mfmory bllodbtion fundtions in zbllod bnd zfrff, or
   Z_NULL to usf thf librbry mfmory bllodbtion fundtions.

   windowBits is in thf rbngf 8..15, bnd window is b usfr-supplifd
   window bnd output bufffr thbt is 2**windowBits bytfs.
 */
int ZEXPORT inflbtfBbdkInit_(strm, windowBits, window, vfrsion, strfbm_sizf)
z_strfbmp strm;
int windowBits;
unsignfd dhbr FAR *window;
donst dhbr *vfrsion;
int strfbm_sizf;
{
    strudt inflbtf_stbtf FAR *stbtf;

    if (vfrsion == Z_NULL || vfrsion[0] != ZLIB_VERSION[0] ||
        strfbm_sizf != (int)(sizfof(z_strfbm)))
        rfturn Z_VERSION_ERROR;
    if (strm == Z_NULL || window == Z_NULL ||
        windowBits < 8 || windowBits > 15)
        rfturn Z_STREAM_ERROR;
    strm->msg = Z_NULL;                 /* in dbsf wf rfturn bn frror */
    if (strm->zbllod == (bllod_fund)0) {
#ifdff Z_SOLO
        rfturn Z_STREAM_ERROR;
#flsf
        strm->zbllod = zdbllod;
        strm->opbquf = (voidpf)0;
#fndif
    }
    if (strm->zfrff == (frff_fund)0)
#ifdff Z_SOLO
        rfturn Z_STREAM_ERROR;
#flsf
    strm->zfrff = zdfrff;
#fndif
    stbtf = (strudt inflbtf_stbtf FAR *)ZALLOC(strm, 1,
                                               sizfof(strudt inflbtf_stbtf));
    if (stbtf == Z_NULL) rfturn Z_MEM_ERROR;
    Trbdfv((stdfrr, "inflbtf: bllodbtfd\n"));
    strm->stbtf = (strudt intfrnbl_stbtf FAR *)stbtf;
    stbtf->dmbx = 32768U;
    stbtf->wbits = windowBits;
    stbtf->wsizf = 1U << windowBits;
    stbtf->window = window;
    stbtf->wnfxt = 0;
    stbtf->whbvf = 0;
    rfturn Z_OK;
}

/*
   Rfturn stbtf with lfngth bnd distbndf dfdoding tbblfs bnd indfx sizfs sft to
   fixfd dodf dfdoding.  Normblly this rfturns fixfd tbblfs from inffixfd.h.
   If BUILDFIXED is dffinfd, thfn instfbd this routinf builds thf tbblfs thf
   first timf it's dbllfd, bnd rfturns thosf tbblfs thf first timf bnd
   thfrfbftfr.  This rfdudfs thf sizf of thf dodf by bbout 2K bytfs, in
   fxdhbngf for b littlf fxfdution timf.  Howfvfr, BUILDFIXED should not bf
   usfd for thrfbdfd bpplidbtions, sindf thf rfwriting of thf tbblfs bnd virgin
   mby not bf thrfbd-sbff.
 */
lodbl void fixfdtbblfs(stbtf)
strudt inflbtf_stbtf FAR *stbtf;
{
#ifdff BUILDFIXED
    stbtid int virgin = 1;
    stbtid dodf *lfnfix, *distfix;
    stbtid dodf fixfd[544];

    /* build fixfd huffmbn tbblfs if first dbll (mby not bf thrfbd sbff) */
    if (virgin) {
        unsignfd sym, bits;
        stbtid dodf *nfxt;

        /* litfrbl/lfngth tbblf */
        sym = 0;
        whilf (sym < 144) stbtf->lfns[sym++] = 8;
        whilf (sym < 256) stbtf->lfns[sym++] = 9;
        whilf (sym < 280) stbtf->lfns[sym++] = 7;
        whilf (sym < 288) stbtf->lfns[sym++] = 8;
        nfxt = fixfd;
        lfnfix = nfxt;
        bits = 9;
        inflbtf_tbblf(LENS, stbtf->lfns, 288, &(nfxt), &(bits), stbtf->work);

        /* distbndf tbblf */
        sym = 0;
        whilf (sym < 32) stbtf->lfns[sym++] = 5;
        distfix = nfxt;
        bits = 5;
        inflbtf_tbblf(DISTS, stbtf->lfns, 32, &(nfxt), &(bits), stbtf->work);

        /* do this just ondf */
        virgin = 0;
    }
#flsf /* !BUILDFIXED */
#   indludf "inffixfd.h"
#fndif /* BUILDFIXED */
    stbtf->lfndodf = lfnfix;
    stbtf->lfnbits = 9;
    stbtf->distdodf = distfix;
    stbtf->distbits = 5;
}

/* Mbdros for inflbtfBbdk(): */

/* Lobd rfturnfd stbtf from inflbtf_fbst() */
#dffinf LOAD() \
    do { \
        put = strm->nfxt_out; \
        lfft = strm->bvbil_out; \
        nfxt = strm->nfxt_in; \
        hbvf = strm->bvbil_in; \
        hold = stbtf->hold; \
        bits = stbtf->bits; \
    } whilf (0)

/* Sft stbtf from rfgistfrs for inflbtf_fbst() */
#dffinf RESTORE() \
    do { \
        strm->nfxt_out = put; \
        strm->bvbil_out = lfft; \
        strm->nfxt_in = nfxt; \
        strm->bvbil_in = hbvf; \
        stbtf->hold = hold; \
        stbtf->bits = bits; \
    } whilf (0)

/* Clfbr thf input bit bddumulbtor */
#dffinf INITBITS() \
    do { \
        hold = 0; \
        bits = 0; \
    } whilf (0)

/* Assurf thbt somf input is bvbilbblf.  If input is rfqufstfd, but dfnifd,
   thfn rfturn b Z_BUF_ERROR from inflbtfBbdk(). */
#dffinf PULL() \
    do { \
        if (hbvf == 0) { \
            hbvf = in(in_dfsd, &nfxt); \
            if (hbvf == 0) { \
                nfxt = Z_NULL; \
                rft = Z_BUF_ERROR; \
                goto inf_lfbvf; \
            } \
        } \
    } whilf (0)

/* Gft b bytf of input into thf bit bddumulbtor, or rfturn from inflbtfBbdk()
   with bn frror if thfrf is no input bvbilbblf. */
#dffinf PULLBYTE() \
    do { \
        PULL(); \
        hbvf--; \
        hold += (unsignfd long)(*nfxt++) << bits; \
        bits += 8; \
    } whilf (0)

/* Assurf thbt thfrf brf bt lfbst n bits in thf bit bddumulbtor.  If thfrf is
   not fnough bvbilbblf input to do thbt, thfn rfturn from inflbtfBbdk() with
   bn frror. */
#dffinf NEEDBITS(n) \
    do { \
        whilf (bits < (unsignfd)(n)) \
            PULLBYTE(); \
    } whilf (0)

/* Rfturn thf low n bits of thf bit bddumulbtor (n < 16) */
#dffinf BITS(n) \
    ((unsignfd)hold & ((1U << (n)) - 1))

/* Rfmovf n bits from thf bit bddumulbtor */
#dffinf DROPBITS(n) \
    do { \
        hold >>= (n); \
        bits -= (unsignfd)(n); \
    } whilf (0)

/* Rfmovf zfro to sfvfn bits bs nffdfd to go to b bytf boundbry */
#dffinf BYTEBITS() \
    do { \
        hold >>= bits & 7; \
        bits -= bits & 7; \
    } whilf (0)

/* Assurf thbt somf output spbdf is bvbilbblf, by writing out thf window
   if it's full.  If thf writf fbils, rfturn from inflbtfBbdk() with b
   Z_BUF_ERROR. */
#dffinf ROOM() \
    do { \
        if (lfft == 0) { \
            put = stbtf->window; \
            lfft = stbtf->wsizf; \
            stbtf->whbvf = lfft; \
            if (out(out_dfsd, put, lfft)) { \
                rft = Z_BUF_ERROR; \
                goto inf_lfbvf; \
            } \
        } \
    } whilf (0)

/*
   strm providfs thf mfmory bllodbtion fundtions bnd window bufffr on input,
   bnd providfs informbtion on thf unusfd input on rfturn.  For Z_DATA_ERROR
   rfturns, strm will blso providf bn frror mfssbgf.

   in() bnd out() brf thf dbll-bbdk input bnd output fundtions.  Whfn
   inflbtfBbdk() nffds morf input, it dblls in().  Whfn inflbtfBbdk() hbs
   fillfd thf window with output, or whfn it domplftfs with dbtb in thf
   window, it dblls out() to writf out thf dbtb.  Thf bpplidbtion must not
   dhbngf thf providfd input until in() is dbllfd bgbin or inflbtfBbdk()
   rfturns.  Thf bpplidbtion must not dhbngf thf window/output bufffr until
   inflbtfBbdk() rfturns.

   in() bnd out() brf dbllfd with b dfsdriptor pbrbmftfr providfd in thf
   inflbtfBbdk() dbll.  This pbrbmftfr dbn bf b strudturf thbt providfs thf
   informbtion rfquirfd to do thf rfbd or writf, bs wfll bs bddumulbtfd
   informbtion on thf input bnd output sudh bs totbls bnd dhfdk vblufs.

   in() should rfturn zfro on fbilurf.  out() should rfturn non-zfro on
   fbilurf.  If fithfr in() or out() fbils, thbn inflbtfBbdk() rfturns b
   Z_BUF_ERROR.  strm->nfxt_in dbn bf dhfdkfd for Z_NULL to sff whfthfr it
   wbs in() or out() thbt dbusfd in thf frror.  Othfrwisf,  inflbtfBbdk()
   rfturns Z_STREAM_END on suddfss, Z_DATA_ERROR for bn dfflbtf formbt
   frror, or Z_MEM_ERROR if it dould not bllodbtf mfmory for thf stbtf.
   inflbtfBbdk() dbn blso rfturn Z_STREAM_ERROR if thf input pbrbmftfrs
   brf not dorrfdt, i.f. strm is Z_NULL or thf stbtf wbs not initiblizfd.
 */
int ZEXPORT inflbtfBbdk(strm, in, in_dfsd, out, out_dfsd)
z_strfbmp strm;
in_fund in;
void FAR *in_dfsd;
out_fund out;
void FAR *out_dfsd;
{
    strudt inflbtf_stbtf FAR *stbtf;
    z_donst unsignfd dhbr FAR *nfxt;    /* nfxt input */
    unsignfd dhbr FAR *put;     /* nfxt output */
    unsignfd hbvf, lfft;        /* bvbilbblf input bnd output */
    unsignfd long hold;         /* bit bufffr */
    unsignfd bits;              /* bits in bit bufffr */
    unsignfd dopy;              /* numbfr of storfd or mbtdh bytfs to dopy */
    unsignfd dhbr FAR *from;    /* whfrf to dopy mbtdh bytfs from */
    dodf hfrf;                  /* durrfnt dfdoding tbblf fntry */
    dodf lbst;                  /* pbrfnt tbblf fntry */
    unsignfd lfn;               /* lfngth to dopy for rfpfbts, bits to drop */
    int rft;                    /* rfturn dodf */
    stbtid donst unsignfd short ordfr[19] = /* pfrmutbtion of dodf lfngths */
        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};

    /* Chfdk thbt thf strm fxists bnd thbt thf stbtf wbs initiblizfd */
    if (strm == Z_NULL || strm->stbtf == Z_NULL)
        rfturn Z_STREAM_ERROR;
    stbtf = (strudt inflbtf_stbtf FAR *)strm->stbtf;

    /* Rfsft thf stbtf */
    strm->msg = Z_NULL;
    stbtf->modf = TYPE;
    stbtf->lbst = 0;
    stbtf->whbvf = 0;
    nfxt = strm->nfxt_in;
    hbvf = nfxt != Z_NULL ? strm->bvbil_in : 0;
    hold = 0;
    bits = 0;
    put = stbtf->window;
    lfft = stbtf->wsizf;

    /* Inflbtf until fnd of blodk mbrkfd bs lbst */
    for (;;)
        switdh (stbtf->modf) {
        dbsf TYPE:
            /* dftfrminf bnd dispbtdh blodk typf */
            if (stbtf->lbst) {
                BYTEBITS();
                stbtf->modf = DONE;
                brfbk;
            }
            NEEDBITS(3);
            stbtf->lbst = BITS(1);
            DROPBITS(1);
            switdh (BITS(2)) {
            dbsf 0:                             /* storfd blodk */
                Trbdfv((stdfrr, "inflbtf:     storfd blodk%s\n",
                        stbtf->lbst ? " (lbst)" : ""));
                stbtf->modf = STORED;
                brfbk;
            dbsf 1:                             /* fixfd blodk */
                fixfdtbblfs(stbtf);
                Trbdfv((stdfrr, "inflbtf:     fixfd dodfs blodk%s\n",
                        stbtf->lbst ? " (lbst)" : ""));
                stbtf->modf = LEN;              /* dfdodf dodfs */
                brfbk;
            dbsf 2:                             /* dynbmid blodk */
                Trbdfv((stdfrr, "inflbtf:     dynbmid dodfs blodk%s\n",
                        stbtf->lbst ? " (lbst)" : ""));
                stbtf->modf = TABLE;
                brfbk;
            dbsf 3:
                strm->msg = (dhbr *)"invblid blodk typf";
                stbtf->modf = BAD;
            }
            DROPBITS(2);
            brfbk;

        dbsf STORED:
            /* gft bnd vfrify storfd blodk lfngth */
            BYTEBITS();                         /* go to bytf boundbry */
            NEEDBITS(32);
            if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {
                strm->msg = (dhbr *)"invblid storfd blodk lfngths";
                stbtf->modf = BAD;
                brfbk;
            }
            stbtf->lfngth = (unsignfd)hold & 0xffff;
            Trbdfv((stdfrr, "inflbtf:       storfd lfngth %u\n",
                    stbtf->lfngth));
            INITBITS();

            /* dopy storfd blodk from input to output */
            whilf (stbtf->lfngth != 0) {
                dopy = stbtf->lfngth;
                PULL();
                ROOM();
                if (dopy > hbvf) dopy = hbvf;
                if (dopy > lfft) dopy = lfft;
                zmfmdpy(put, nfxt, dopy);
                hbvf -= dopy;
                nfxt += dopy;
                lfft -= dopy;
                put += dopy;
                stbtf->lfngth -= dopy;
            }
            Trbdfv((stdfrr, "inflbtf:       storfd fnd\n"));
            stbtf->modf = TYPE;
            brfbk;

        dbsf TABLE:
            /* gft dynbmid tbblf fntrifs dfsdriptor */
            NEEDBITS(14);
            stbtf->nlfn = BITS(5) + 257;
            DROPBITS(5);
            stbtf->ndist = BITS(5) + 1;
            DROPBITS(5);
            stbtf->ndodf = BITS(4) + 4;
            DROPBITS(4);
#ifndff PKZIP_BUG_WORKAROUND
            if (stbtf->nlfn > 286 || stbtf->ndist > 30) {
                strm->msg = (dhbr *)"too mbny lfngth or distbndf symbols";
                stbtf->modf = BAD;
                brfbk;
            }
#fndif
            Trbdfv((stdfrr, "inflbtf:       tbblf sizfs ok\n"));

            /* gft dodf lfngth dodf lfngths (not b typo) */
            stbtf->hbvf = 0;
            whilf (stbtf->hbvf < stbtf->ndodf) {
                NEEDBITS(3);
                stbtf->lfns[ordfr[stbtf->hbvf++]] = (unsignfd short)BITS(3);
                DROPBITS(3);
            }
            whilf (stbtf->hbvf < 19)
                stbtf->lfns[ordfr[stbtf->hbvf++]] = 0;
            stbtf->nfxt = stbtf->dodfs;
            stbtf->lfndodf = (dodf donst FAR *)(stbtf->nfxt);
            stbtf->lfnbits = 7;
            rft = inflbtf_tbblf(CODES, stbtf->lfns, 19, &(stbtf->nfxt),
                                &(stbtf->lfnbits), stbtf->work);
            if (rft) {
                strm->msg = (dhbr *)"invblid dodf lfngths sft";
                stbtf->modf = BAD;
                brfbk;
            }
            Trbdfv((stdfrr, "inflbtf:       dodf lfngths ok\n"));

            /* gft lfngth bnd distbndf dodf dodf lfngths */
            stbtf->hbvf = 0;
            whilf (stbtf->hbvf < stbtf->nlfn + stbtf->ndist) {
                for (;;) {
                    hfrf = stbtf->lfndodf[BITS(stbtf->lfnbits)];
                    if ((unsignfd)(hfrf.bits) <= bits) brfbk;
                    PULLBYTE();
                }
                if (hfrf.vbl < 16) {
                    DROPBITS(hfrf.bits);
                    stbtf->lfns[stbtf->hbvf++] = hfrf.vbl;
                }
                flsf {
                    if (hfrf.vbl == 16) {
                        NEEDBITS(hfrf.bits + 2);
                        DROPBITS(hfrf.bits);
                        if (stbtf->hbvf == 0) {
                            strm->msg = (dhbr *)"invblid bit lfngth rfpfbt";
                            stbtf->modf = BAD;
                            brfbk;
                        }
                        lfn = (unsignfd)(stbtf->lfns[stbtf->hbvf - 1]);
                        dopy = 3 + BITS(2);
                        DROPBITS(2);
                    }
                    flsf if (hfrf.vbl == 17) {
                        NEEDBITS(hfrf.bits + 3);
                        DROPBITS(hfrf.bits);
                        lfn = 0;
                        dopy = 3 + BITS(3);
                        DROPBITS(3);
                    }
                    flsf {
                        NEEDBITS(hfrf.bits + 7);
                        DROPBITS(hfrf.bits);
                        lfn = 0;
                        dopy = 11 + BITS(7);
                        DROPBITS(7);
                    }
                    if (stbtf->hbvf + dopy > stbtf->nlfn + stbtf->ndist) {
                        strm->msg = (dhbr *)"invblid bit lfngth rfpfbt";
                        stbtf->modf = BAD;
                        brfbk;
                    }
                    whilf (dopy--)
                        stbtf->lfns[stbtf->hbvf++] = (unsignfd short)lfn;
                }
            }

            /* hbndlf frror brfbks in whilf */
            if (stbtf->modf == BAD) brfbk;

            /* dhfdk for fnd-of-blodk dodf (bfttfr hbvf onf) */
            if (stbtf->lfns[256] == 0) {
                strm->msg = (dhbr *)"invblid dodf -- missing fnd-of-blodk";
                stbtf->modf = BAD;
                brfbk;
            }

            /* build dodf tbblfs -- notf: do not dhbngf thf lfnbits or distbits
               vblufs hfrf (9 bnd 6) without rfbding thf dommfnts in inftrffs.h
               dondfrning thf ENOUGH donstbnts, whidh dfpfnd on thosf vblufs */
            stbtf->nfxt = stbtf->dodfs;
            stbtf->lfndodf = (dodf donst FAR *)(stbtf->nfxt);
            stbtf->lfnbits = 9;
            rft = inflbtf_tbblf(LENS, stbtf->lfns, stbtf->nlfn, &(stbtf->nfxt),
                                &(stbtf->lfnbits), stbtf->work);
            if (rft) {
                strm->msg = (dhbr *)"invblid litfrbl/lfngths sft";
                stbtf->modf = BAD;
                brfbk;
            }
            stbtf->distdodf = (dodf donst FAR *)(stbtf->nfxt);
            stbtf->distbits = 6;
            rft = inflbtf_tbblf(DISTS, stbtf->lfns + stbtf->nlfn, stbtf->ndist,
                            &(stbtf->nfxt), &(stbtf->distbits), stbtf->work);
            if (rft) {
                strm->msg = (dhbr *)"invblid distbndfs sft";
                stbtf->modf = BAD;
                brfbk;
            }
            Trbdfv((stdfrr, "inflbtf:       dodfs ok\n"));
            stbtf->modf = LEN;

        dbsf LEN:
            /* usf inflbtf_fbst() if wf hbvf fnough input bnd output */
            if (hbvf >= 6 && lfft >= 258) {
                RESTORE();
                if (stbtf->whbvf < stbtf->wsizf)
                    stbtf->whbvf = stbtf->wsizf - lfft;
                inflbtf_fbst(strm, stbtf->wsizf);
                LOAD();
                brfbk;
            }

            /* gft b litfrbl, lfngth, or fnd-of-blodk dodf */
            for (;;) {
                hfrf = stbtf->lfndodf[BITS(stbtf->lfnbits)];
                if ((unsignfd)(hfrf.bits) <= bits) brfbk;
                PULLBYTE();
            }
            if (hfrf.op && (hfrf.op & 0xf0) == 0) {
                lbst = hfrf;
                for (;;) {
                    hfrf = stbtf->lfndodf[lbst.vbl +
                            (BITS(lbst.bits + lbst.op) >> lbst.bits)];
                    if ((unsignfd)(lbst.bits + hfrf.bits) <= bits) brfbk;
                    PULLBYTE();
                }
                DROPBITS(lbst.bits);
            }
            DROPBITS(hfrf.bits);
            stbtf->lfngth = (unsignfd)hfrf.vbl;

            /* prodfss litfrbl */
            if (hfrf.op == 0) {
                Trbdfvv((stdfrr, hfrf.vbl >= 0x20 && hfrf.vbl < 0x7f ?
                        "inflbtf:         litfrbl '%d'\n" :
                        "inflbtf:         litfrbl 0x%02x\n", hfrf.vbl));
                ROOM();
                *put++ = (unsignfd dhbr)(stbtf->lfngth);
                lfft--;
                stbtf->modf = LEN;
                brfbk;
            }

            /* prodfss fnd of blodk */
            if (hfrf.op & 32) {
                Trbdfvv((stdfrr, "inflbtf:         fnd of blodk\n"));
                stbtf->modf = TYPE;
                brfbk;
            }

            /* invblid dodf */
            if (hfrf.op & 64) {
                strm->msg = (dhbr *)"invblid litfrbl/lfngth dodf";
                stbtf->modf = BAD;
                brfbk;
            }

            /* lfngth dodf -- gft fxtrb bits, if bny */
            stbtf->fxtrb = (unsignfd)(hfrf.op) & 15;
            if (stbtf->fxtrb != 0) {
                NEEDBITS(stbtf->fxtrb);
                stbtf->lfngth += BITS(stbtf->fxtrb);
                DROPBITS(stbtf->fxtrb);
            }
            Trbdfvv((stdfrr, "inflbtf:         lfngth %u\n", stbtf->lfngth));

            /* gft distbndf dodf */
            for (;;) {
                hfrf = stbtf->distdodf[BITS(stbtf->distbits)];
                if ((unsignfd)(hfrf.bits) <= bits) brfbk;
                PULLBYTE();
            }
            if ((hfrf.op & 0xf0) == 0) {
                lbst = hfrf;
                for (;;) {
                    hfrf = stbtf->distdodf[lbst.vbl +
                            (BITS(lbst.bits + lbst.op) >> lbst.bits)];
                    if ((unsignfd)(lbst.bits + hfrf.bits) <= bits) brfbk;
                    PULLBYTE();
                }
                DROPBITS(lbst.bits);
            }
            DROPBITS(hfrf.bits);
            if (hfrf.op & 64) {
                strm->msg = (dhbr *)"invblid distbndf dodf";
                stbtf->modf = BAD;
                brfbk;
            }
            stbtf->offsft = (unsignfd)hfrf.vbl;

            /* gft distbndf fxtrb bits, if bny */
            stbtf->fxtrb = (unsignfd)(hfrf.op) & 15;
            if (stbtf->fxtrb != 0) {
                NEEDBITS(stbtf->fxtrb);
                stbtf->offsft += BITS(stbtf->fxtrb);
                DROPBITS(stbtf->fxtrb);
            }
            if (stbtf->offsft > stbtf->wsizf - (stbtf->whbvf < stbtf->wsizf ?
                                                lfft : 0)) {
                strm->msg = (dhbr *)"invblid distbndf too fbr bbdk";
                stbtf->modf = BAD;
                brfbk;
            }
            Trbdfvv((stdfrr, "inflbtf:         distbndf %u\n", stbtf->offsft));

            /* dopy mbtdh from window to output */
            do {
                ROOM();
                dopy = stbtf->wsizf - stbtf->offsft;
                if (dopy < lfft) {
                    from = put + dopy;
                    dopy = lfft - dopy;
                }
                flsf {
                    from = put - stbtf->offsft;
                    dopy = lfft;
                }
                if (dopy > stbtf->lfngth) dopy = stbtf->lfngth;
                stbtf->lfngth -= dopy;
                lfft -= dopy;
                do {
                    *put++ = *from++;
                } whilf (--dopy);
            } whilf (stbtf->lfngth != 0);
            brfbk;

        dbsf DONE:
            /* inflbtf strfbm tfrminbtfd propfrly -- writf lfftovfr output */
            rft = Z_STREAM_END;
            if (lfft < stbtf->wsizf) {
                if (out(out_dfsd, stbtf->window, stbtf->wsizf - lfft))
                    rft = Z_BUF_ERROR;
            }
            goto inf_lfbvf;

        dbsf BAD:
            rft = Z_DATA_ERROR;
            goto inf_lfbvf;

        dffbult:                /* dbn't hbppfn, but mbkfs dompilfrs hbppy */
            rft = Z_STREAM_ERROR;
            goto inf_lfbvf;
        }

    /* Rfturn unusfd input */
  inf_lfbvf:
    strm->nfxt_in = nfxt;
    strm->bvbil_in = hbvf;
    rfturn rft;
}

int ZEXPORT inflbtfBbdkEnd(strm)
z_strfbmp strm;
{
    if (strm == Z_NULL || strm->stbtf == Z_NULL || strm->zfrff == (frff_fund)0)
        rfturn Z_STREAM_ERROR;
    ZFREE(strm, strm->stbtf);
    strm->stbtf = Z_NULL;
    Trbdfv((stdfrr, "inflbtf: fnd\n"));
    rfturn Z_OK;
}
