/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

/* dfflbtf.d -- domprfss dbtb using thf dfflbtion blgorithm
 * Copyright (C) 1995-2013 Jfbn-loup Gbilly bnd Mbrk Adlfr
 * For donditions of distribution bnd usf, sff dopyright notidf in zlib.h
 */

/*
 *  ALGORITHM
 *
 *      Thf "dfflbtion" prodfss dfpfnds on bfing bblf to idfntify portions
 *      of thf input tfxt whidh brf idfntidbl to fbrlifr input (within b
 *      sliding window trbiling bfhind thf input durrfntly bfing prodfssfd).
 *
 *      Thf most strbightforwbrd tfdhniquf turns out to bf thf fbstfst for
 *      most input filfs: try bll possiblf mbtdhfs bnd sflfdt thf longfst.
 *      Thf kfy ffbturf of this blgorithm is thbt insfrtions into thf string
 *      didtionbry brf vfry simplf bnd thus fbst, bnd dflftions brf bvoidfd
 *      domplftfly. Insfrtions brf pfrformfd bt fbdh input dhbrbdtfr, whfrfbs
 *      string mbtdhfs brf pfrformfd only whfn thf prfvious mbtdh fnds. So it
 *      is prfffrbblf to spfnd morf timf in mbtdhfs to bllow vfry fbst string
 *      insfrtions bnd bvoid dflftions. Thf mbtdhing blgorithm for smbll
 *      strings is inspirfd from thbt of Rbbin & Kbrp. A brutf fordf bpprobdh
 *      is usfd to find longfr strings whfn b smbll mbtdh hbs bffn found.
 *      A similbr blgorithm is usfd in domid (by Jbn-Mbrk Wbms) bnd frffzf
 *      (by Lfonid Broukhis).
 *         A prfvious vfrsion of this filf usfd b morf sophistidbtfd blgorithm
 *      (by Fiblb bnd Grffnf) whidh is gubrbntffd to run in linfbr bmortizfd
 *      timf, but hbs b lbrgfr bvfrbgf dost, usfs morf mfmory bnd is pbtfntfd.
 *      Howfvfr thf F&G blgorithm mby bf fbstfr for somf highly rfdundbnt
 *      filfs if thf pbrbmftfr mbx_dhbin_lfngth (dfsdribfd bflow) is too lbrgf.
 *
 *  ACKNOWLEDGEMENTS
 *
 *      Thf idfb of lbzy fvblubtion of mbtdhfs is duf to Jbn-Mbrk Wbms, bnd
 *      I found it in 'frffzf' writtfn by Lfonid Broukhis.
 *      Thbnks to mbny pfoplf for bug rfports bnd tfsting.
 *
 *  REFERENCES
 *
 *      Dfutsdh, L.P.,"DEFLATE Comprfssfd Dbtb Formbt Spfdifidbtion".
 *      Avbilbblf in http://tools.iftf.org/html/rfd1951
 *
 *      A dfsdription of thf Rbbin bnd Kbrp blgorithm is givfn in thf book
 *         "Algorithms" by R. Sfdgfwidk, Addison-Wfslfy, p252.
 *
 *      Fiblb,E.R., bnd Grffnf,D.H.
 *         Dbtb Comprfssion with Finitf Windows, Comm.ACM, 32,4 (1989) 490-595
 *
 */

/* @(#) $Id$ */

#indludf "dfflbtf.h"

donst dhbr dfflbtf_dopyright[] =
   " dfflbtf 1.2.8 Copyright 1995-2013 Jfbn-loup Gbilly bnd Mbrk Adlfr ";
/*
  If you usf thf zlib librbry in b produdt, bn bdknowlfdgmfnt is wfldomf
  in thf dodumfntbtion of your produdt. If for somf rfbson you dbnnot
  indludf sudh bn bdknowlfdgmfnt, I would bpprfdibtf thbt you kffp this
  dopyright string in thf fxfdutbblf of your produdt.
 */

/* ===========================================================================
 *  Fundtion prototypfs.
 */
typfdff fnum {
    nffd_morf,      /* blodk not domplftfd, nffd morf input or morf output */
    blodk_donf,     /* blodk flush pfrformfd */
    finish_stbrtfd, /* finish stbrtfd, nffd only morf output bt nfxt dfflbtf */
    finish_donf     /* finish donf, bddfpt no morf input or output */
} blodk_stbtf;

typfdff blodk_stbtf (*domprfss_fund) OF((dfflbtf_stbtf *s, int flush));
/* Comprfssion fundtion. Rfturns thf blodk stbtf bftfr thf dbll. */

lodbl void fill_window    OF((dfflbtf_stbtf *s));
lodbl blodk_stbtf dfflbtf_storfd OF((dfflbtf_stbtf *s, int flush));
lodbl blodk_stbtf dfflbtf_fbst   OF((dfflbtf_stbtf *s, int flush));
#ifndff FASTEST
lodbl blodk_stbtf dfflbtf_slow   OF((dfflbtf_stbtf *s, int flush));
#fndif
lodbl blodk_stbtf dfflbtf_rlf    OF((dfflbtf_stbtf *s, int flush));
lodbl blodk_stbtf dfflbtf_huff   OF((dfflbtf_stbtf *s, int flush));
lodbl void lm_init        OF((dfflbtf_stbtf *s));
lodbl void putShortMSB    OF((dfflbtf_stbtf *s, uInt b));
lodbl void flush_pfnding  OF((z_strfbmp strm));
lodbl int rfbd_buf        OF((z_strfbmp strm, Bytff *buf, unsignfd sizf));
#ifdff ASMV
      void mbtdh_init OF((void)); /* bsm dodf initiblizbtion */
      uInt longfst_mbtdh  OF((dfflbtf_stbtf *s, IPos dur_mbtdh));
#flsf
lodbl uInt longfst_mbtdh  OF((dfflbtf_stbtf *s, IPos dur_mbtdh));
#fndif

#ifdff DEBUG
lodbl  void dhfdk_mbtdh OF((dfflbtf_stbtf *s, IPos stbrt, IPos mbtdh,
                            int lfngth));
#fndif

/* ===========================================================================
 * Lodbl dbtb
 */

#dffinf NIL 0
/* Tbil of hbsh dhbins */

#ifndff TOO_FAR
#  dffinf TOO_FAR 4096
#fndif
/* Mbtdhfs of lfngth 3 brf disdbrdfd if thfir distbndf fxdffds TOO_FAR */

/* Vblufs for mbx_lbzy_mbtdh, good_mbtdh bnd mbx_dhbin_lfngth, dfpfnding on
 * thf dfsirfd pbdk lfvfl (0..9). Thf vblufs givfn bflow hbvf bffn tunfd to
 * fxdludf worst dbsf pfrformbndf for pbthologidbl filfs. Bfttfr vblufs mby bf
 * found for spfdifid filfs.
 */
typfdff strudt donfig_s {
   ush good_lfngth; /* rfdudf lbzy sfbrdh bbovf this mbtdh lfngth */
   ush mbx_lbzy;    /* do not pfrform lbzy sfbrdh bbovf this mbtdh lfngth */
   ush nidf_lfngth; /* quit sfbrdh bbovf this mbtdh lfngth */
   ush mbx_dhbin;
   domprfss_fund fund;
} donfig;

#ifdff FASTEST
lodbl donst donfig donfigurbtion_tbblf[2] = {
/*      good lbzy nidf dhbin */
/* 0 */ {0,    0,  0,    0, dfflbtf_storfd},  /* storf only */
/* 1 */ {4,    4,  8,    4, dfflbtf_fbst}}; /* mbx spffd, no lbzy mbtdhfs */
#flsf
lodbl donst donfig donfigurbtion_tbblf[10] = {
/*      good lbzy nidf dhbin */
/* 0 */ {0,    0,  0,    0, dfflbtf_storfd},  /* storf only */
/* 1 */ {4,    4,  8,    4, dfflbtf_fbst}, /* mbx spffd, no lbzy mbtdhfs */
/* 2 */ {4,    5, 16,    8, dfflbtf_fbst},
/* 3 */ {4,    6, 32,   32, dfflbtf_fbst},

/* 4 */ {4,    4, 16,   16, dfflbtf_slow},  /* lbzy mbtdhfs */
/* 5 */ {8,   16, 32,   32, dfflbtf_slow},
/* 6 */ {8,   16, 128, 128, dfflbtf_slow},
/* 7 */ {8,   32, 128, 256, dfflbtf_slow},
/* 8 */ {32, 128, 258, 1024, dfflbtf_slow},
/* 9 */ {32, 258, 258, 4096, dfflbtf_slow}}; /* mbx domprfssion */
#fndif

/* Notf: thf dfflbtf() dodf rfquirfs mbx_lbzy >= MIN_MATCH bnd mbx_dhbin >= 4
 * For dfflbtf_fbst() (lfvfls <= 3) good is ignorfd bnd lbzy hbs b difffrfnt
 * mfbning.
 */

#dffinf EQUAL 0
/* rfsult of mfmdmp for fqubl strings */

#ifndff NO_DUMMY_DECL
strudt stbtid_trff_dfsd_s {int dummy;}; /* for buggy dompilfrs */
#fndif

/* rbnk Z_BLOCK bftwffn Z_NO_FLUSH bnd Z_PARTIAL_FLUSH */
#dffinf RANK(f) (((f) << 1) - ((f) > 4 ? 9 : 0))

/* ===========================================================================
 * Updbtf b hbsh vbluf with thf givfn input bytf
 * IN  bssfrtion: bll dblls to to UPDATE_HASH brf mbdf with donsfdutivf
 *    input dhbrbdtfrs, so thbt b running hbsh kfy dbn bf domputfd from thf
 *    prfvious kfy instfbd of domplftf rfdbldulbtion fbdh timf.
 */
#dffinf UPDATE_HASH(s,h,d) (h = (((h)<<s->hbsh_shift) ^ (d)) & s->hbsh_mbsk)


/* ===========================================================================
 * Insfrt string str in thf didtionbry bnd sft mbtdh_hfbd to thf prfvious hfbd
 * of thf hbsh dhbin (thf most rfdfnt string with sbmf hbsh kfy). Rfturn
 * thf prfvious lfngth of thf hbsh dhbin.
 * If this filf is dompilfd with -DFASTEST, thf domprfssion lfvfl is fordfd
 * to 1, bnd no hbsh dhbins brf mbintbinfd.
 * IN  bssfrtion: bll dblls to to INSERT_STRING brf mbdf with donsfdutivf
 *    input dhbrbdtfrs bnd thf first MIN_MATCH bytfs of str brf vblid
 *    (fxdfpt for thf lbst MIN_MATCH-1 bytfs of thf input filf).
 */
#ifdff FASTEST
#dffinf INSERT_STRING(s, str, mbtdh_hfbd) \
   (UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \
    mbtdh_hfbd = s->hfbd[s->ins_h], \
    s->hfbd[s->ins_h] = (Pos)(str))
#flsf
#dffinf INSERT_STRING(s, str, mbtdh_hfbd) \
   (UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \
    mbtdh_hfbd = s->prfv[(str) & s->w_mbsk] = s->hfbd[s->ins_h], \
    s->hfbd[s->ins_h] = (Pos)(str))
#fndif

/* ===========================================================================
 * Initiblizf thf hbsh tbblf (bvoiding 64K ovfrflow for 16 bit systfms).
 * prfv[] will bf initiblizfd on thf fly.
 */
#dffinf CLEAR_HASH(s) \
    s->hfbd[s->hbsh_sizf-1] = NIL; \
    zmfmzfro((Bytff *)s->hfbd, (unsignfd)(s->hbsh_sizf-1)*sizfof(*s->hfbd));

/* ========================================================================= */
int ZEXPORT dfflbtfInit_(strm, lfvfl, vfrsion, strfbm_sizf)
    z_strfbmp strm;
    int lfvfl;
    donst dhbr *vfrsion;
    int strfbm_sizf;
{
    rfturn dfflbtfInit2_(strm, lfvfl, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL,
                         Z_DEFAULT_STRATEGY, vfrsion, strfbm_sizf);
    /* To do: ignorf strm->nfxt_in if wf usf it bs window */
}

/* ========================================================================= */
int ZEXPORT dfflbtfInit2_(strm, lfvfl, mfthod, windowBits, mfmLfvfl, strbtfgy,
                  vfrsion, strfbm_sizf)
    z_strfbmp strm;
    int  lfvfl;
    int  mfthod;
    int  windowBits;
    int  mfmLfvfl;
    int  strbtfgy;
    donst dhbr *vfrsion;
    int strfbm_sizf;
{
    dfflbtf_stbtf *s;
    int wrbp = 1;
    stbtid donst dhbr my_vfrsion[] = ZLIB_VERSION;

    ushf *ovfrlby;
    /* Wf ovfrlby pfnding_buf bnd d_buf+l_buf. This works sindf thf bvfrbgf
     * output sizf for (lfngth,distbndf) dodfs is <= 24 bits.
     */

    if (vfrsion == Z_NULL || vfrsion[0] != my_vfrsion[0] ||
        strfbm_sizf != sizfof(z_strfbm)) {
        rfturn Z_VERSION_ERROR;
    }
    if (strm == Z_NULL) rfturn Z_STREAM_ERROR;

    strm->msg = Z_NULL;
    if (strm->zbllod == (bllod_fund)0) {
#ifdff Z_SOLO
        rfturn Z_STREAM_ERROR;
#flsf
        strm->zbllod = zdbllod;
        strm->opbquf = (voidpf)0;
#fndif
    }
    if (strm->zfrff == (frff_fund)0)
#ifdff Z_SOLO
        rfturn Z_STREAM_ERROR;
#flsf
        strm->zfrff = zdfrff;
#fndif

#ifdff FASTEST
    if (lfvfl != 0) lfvfl = 1;
#flsf
    if (lfvfl == Z_DEFAULT_COMPRESSION) lfvfl = 6;
#fndif

    if (windowBits < 0) { /* supprfss zlib wrbppfr */
        wrbp = 0;
        windowBits = -windowBits;
    }
#ifdff GZIP
    flsf if (windowBits > 15) {
        wrbp = 2;       /* writf gzip wrbppfr instfbd */
        windowBits -= 16;
    }
#fndif
    if (mfmLfvfl < 1 || mfmLfvfl > MAX_MEM_LEVEL || mfthod != Z_DEFLATED ||
        windowBits < 8 || windowBits > 15 || lfvfl < 0 || lfvfl > 9 ||
        strbtfgy < 0 || strbtfgy > Z_FIXED) {
        rfturn Z_STREAM_ERROR;
    }
    if (windowBits == 8) windowBits = 9;  /* until 256-bytf window bug fixfd */
    s = (dfflbtf_stbtf *) ZALLOC(strm, 1, sizfof(dfflbtf_stbtf));
    if (s == Z_NULL) rfturn Z_MEM_ERROR;
    strm->stbtf = (strudt intfrnbl_stbtf FAR *)s;
    s->strm = strm;

    s->wrbp = wrbp;
    s->gzhfbd = Z_NULL;
    s->w_bits = windowBits;
    s->w_sizf = 1 << s->w_bits;
    s->w_mbsk = s->w_sizf - 1;

    s->hbsh_bits = mfmLfvfl + 7;
    s->hbsh_sizf = 1 << s->hbsh_bits;
    s->hbsh_mbsk = s->hbsh_sizf - 1;
    s->hbsh_shift =  ((s->hbsh_bits+MIN_MATCH-1)/MIN_MATCH);

    s->window = (Bytff *) ZALLOC(strm, s->w_sizf, 2*sizfof(Bytf));
    s->prfv   = (Posf *)  ZALLOC(strm, s->w_sizf, sizfof(Pos));
    s->hfbd   = (Posf *)  ZALLOC(strm, s->hbsh_sizf, sizfof(Pos));

    s->high_wbtfr = 0;      /* nothing writtfn to s->window yft */

    s->lit_bufsizf = 1 << (mfmLfvfl + 6); /* 16K flfmfnts by dffbult */

    ovfrlby = (ushf *) ZALLOC(strm, s->lit_bufsizf, sizfof(ush)+2);
    s->pfnding_buf = (udhf *) ovfrlby;
    s->pfnding_buf_sizf = (ulg)s->lit_bufsizf * (sizfof(ush)+2L);

    if (s->window == Z_NULL || s->prfv == Z_NULL || s->hfbd == Z_NULL ||
        s->pfnding_buf == Z_NULL) {
        s->stbtus = FINISH_STATE;
        strm->msg = ERR_MSG(Z_MEM_ERROR);
        dfflbtfEnd (strm);
        rfturn Z_MEM_ERROR;
    }
    s->d_buf = ovfrlby + s->lit_bufsizf/sizfof(ush);
    s->l_buf = s->pfnding_buf + (1+sizfof(ush))*s->lit_bufsizf;

    s->lfvfl = lfvfl;
    s->strbtfgy = strbtfgy;
    s->mfthod = (Bytf)mfthod;

    rfturn dfflbtfRfsft(strm);
}

/* ========================================================================= */
int ZEXPORT dfflbtfSftDidtionbry (strm, didtionbry, didtLfngth)
    z_strfbmp strm;
    donst Bytff *didtionbry;
    uInt  didtLfngth;
{
    dfflbtf_stbtf *s;
    uInt str, n;
    int wrbp;
    unsignfd bvbil;
    z_donst unsignfd dhbr *nfxt;

    if (strm == Z_NULL || strm->stbtf == Z_NULL || didtionbry == Z_NULL)
        rfturn Z_STREAM_ERROR;
    s = strm->stbtf;
    wrbp = s->wrbp;
    if (wrbp == 2 || (wrbp == 1 && s->stbtus != INIT_STATE) || s->lookbhfbd)
        rfturn Z_STREAM_ERROR;

    /* whfn using zlib wrbppfrs, domputf Adlfr-32 for providfd didtionbry */
    if (wrbp == 1)
        strm->bdlfr = bdlfr32(strm->bdlfr, didtionbry, didtLfngth);
    s->wrbp = 0;                    /* bvoid domputing Adlfr-32 in rfbd_buf */

    /* if didtionbry would fill window, just rfplbdf thf history */
    if (didtLfngth >= s->w_sizf) {
        if (wrbp == 0) {            /* blrfbdy fmpty othfrwisf */
            CLEAR_HASH(s);
            s->strstbrt = 0;
            s->blodk_stbrt = 0L;
            s->insfrt = 0;
        }
        didtionbry += didtLfngth - s->w_sizf;  /* usf thf tbil */
        didtLfngth = s->w_sizf;
    }

    /* insfrt didtionbry into window bnd hbsh */
    bvbil = strm->bvbil_in;
    nfxt = strm->nfxt_in;
    strm->bvbil_in = didtLfngth;
    strm->nfxt_in = (z_donst Bytff *)didtionbry;
    fill_window(s);
    whilf (s->lookbhfbd >= MIN_MATCH) {
        str = s->strstbrt;
        n = s->lookbhfbd - (MIN_MATCH-1);
        do {
            UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]);
#ifndff FASTEST
            s->prfv[str & s->w_mbsk] = s->hfbd[s->ins_h];
#fndif
            s->hfbd[s->ins_h] = (Pos)str;
            str++;
        } whilf (--n);
        s->strstbrt = str;
        s->lookbhfbd = MIN_MATCH-1;
        fill_window(s);
    }
    s->strstbrt += s->lookbhfbd;
    s->blodk_stbrt = (long)s->strstbrt;
    s->insfrt = s->lookbhfbd;
    s->lookbhfbd = 0;
    s->mbtdh_lfngth = s->prfv_lfngth = MIN_MATCH-1;
    s->mbtdh_bvbilbblf = 0;
    strm->nfxt_in = nfxt;
    strm->bvbil_in = bvbil;
    s->wrbp = wrbp;
    rfturn Z_OK;
}

/* ========================================================================= */
int ZEXPORT dfflbtfRfsftKffp (strm)
    z_strfbmp strm;
{
    dfflbtf_stbtf *s;

    if (strm == Z_NULL || strm->stbtf == Z_NULL ||
        strm->zbllod == (bllod_fund)0 || strm->zfrff == (frff_fund)0) {
        rfturn Z_STREAM_ERROR;
    }

    strm->totbl_in = strm->totbl_out = 0;
    strm->msg = Z_NULL; /* usf zfrff if wf fvfr bllodbtf msg dynbmidblly */
    strm->dbtb_typf = Z_UNKNOWN;

    s = (dfflbtf_stbtf *)strm->stbtf;
    s->pfnding = 0;
    s->pfnding_out = s->pfnding_buf;

    if (s->wrbp < 0) {
        s->wrbp = -s->wrbp; /* wbs mbdf nfgbtivf by dfflbtf(..., Z_FINISH); */
    }
    s->stbtus = s->wrbp ? INIT_STATE : BUSY_STATE;
    strm->bdlfr =
#ifdff GZIP
        s->wrbp == 2 ? drd32(0L, Z_NULL, 0) :
#fndif
        bdlfr32(0L, Z_NULL, 0);
    s->lbst_flush = Z_NO_FLUSH;

    _tr_init(s);

    rfturn Z_OK;
}

/* ========================================================================= */
int ZEXPORT dfflbtfRfsft (strm)
    z_strfbmp strm;
{
    int rft;

    rft = dfflbtfRfsftKffp(strm);
    if (rft == Z_OK)
        lm_init(strm->stbtf);
    rfturn rft;
}

/* ========================================================================= */
int ZEXPORT dfflbtfSftHfbdfr (strm, hfbd)
    z_strfbmp strm;
    gz_hfbdfrp hfbd;
{
    if (strm == Z_NULL || strm->stbtf == Z_NULL) rfturn Z_STREAM_ERROR;
    if (strm->stbtf->wrbp != 2) rfturn Z_STREAM_ERROR;
    strm->stbtf->gzhfbd = hfbd;
    rfturn Z_OK;
}

/* ========================================================================= */
int ZEXPORT dfflbtfPfnding (strm, pfnding, bits)
    unsignfd *pfnding;
    int *bits;
    z_strfbmp strm;
{
    if (strm == Z_NULL || strm->stbtf == Z_NULL) rfturn Z_STREAM_ERROR;
    if (pfnding != Z_NULL)
        *pfnding = strm->stbtf->pfnding;
    if (bits != Z_NULL)
        *bits = strm->stbtf->bi_vblid;
    rfturn Z_OK;
}

/* ========================================================================= */
int ZEXPORT dfflbtfPrimf (strm, bits, vbluf)
    z_strfbmp strm;
    int bits;
    int vbluf;
{
    dfflbtf_stbtf *s;
    int put;

    if (strm == Z_NULL || strm->stbtf == Z_NULL) rfturn Z_STREAM_ERROR;
    s = strm->stbtf;
    if ((Bytff *)(s->d_buf) < s->pfnding_out + ((Buf_sizf + 7) >> 3))
        rfturn Z_BUF_ERROR;
    do {
        put = Buf_sizf - s->bi_vblid;
        if (put > bits)
            put = bits;
        s->bi_buf |= (ush)((vbluf & ((1 << put) - 1)) << s->bi_vblid);
        s->bi_vblid += put;
        _tr_flush_bits(s);
        vbluf >>= put;
        bits -= put;
    } whilf (bits);
    rfturn Z_OK;
}

/* ========================================================================= */
int ZEXPORT dfflbtfPbrbms(strm, lfvfl, strbtfgy)
    z_strfbmp strm;
    int lfvfl;
    int strbtfgy;
{
    dfflbtf_stbtf *s;
    domprfss_fund fund;
    int frr = Z_OK;

    if (strm == Z_NULL || strm->stbtf == Z_NULL) rfturn Z_STREAM_ERROR;
    s = strm->stbtf;

#ifdff FASTEST
    if (lfvfl != 0) lfvfl = 1;
#flsf
    if (lfvfl == Z_DEFAULT_COMPRESSION) lfvfl = 6;
#fndif
    if (lfvfl < 0 || lfvfl > 9 || strbtfgy < 0 || strbtfgy > Z_FIXED) {
        rfturn Z_STREAM_ERROR;
    }
    fund = donfigurbtion_tbblf[s->lfvfl].fund;

    if ((strbtfgy != s->strbtfgy || fund != donfigurbtion_tbblf[lfvfl].fund) &&
        strm->totbl_in != 0) {
        /* Flush thf lbst bufffr: */
        frr = dfflbtf(strm, Z_BLOCK);
        if (frr == Z_BUF_ERROR && s->pfnding == 0)
            frr = Z_OK;
    }
    if (s->lfvfl != lfvfl) {
        s->lfvfl = lfvfl;
        s->mbx_lbzy_mbtdh   = donfigurbtion_tbblf[lfvfl].mbx_lbzy;
        s->good_mbtdh       = donfigurbtion_tbblf[lfvfl].good_lfngth;
        s->nidf_mbtdh       = donfigurbtion_tbblf[lfvfl].nidf_lfngth;
        s->mbx_dhbin_lfngth = donfigurbtion_tbblf[lfvfl].mbx_dhbin;
    }
    s->strbtfgy = strbtfgy;
    rfturn frr;
}

/* ========================================================================= */
int ZEXPORT dfflbtfTunf(strm, good_lfngth, mbx_lbzy, nidf_lfngth, mbx_dhbin)
    z_strfbmp strm;
    int good_lfngth;
    int mbx_lbzy;
    int nidf_lfngth;
    int mbx_dhbin;
{
    dfflbtf_stbtf *s;

    if (strm == Z_NULL || strm->stbtf == Z_NULL) rfturn Z_STREAM_ERROR;
    s = strm->stbtf;
    s->good_mbtdh = good_lfngth;
    s->mbx_lbzy_mbtdh = mbx_lbzy;
    s->nidf_mbtdh = nidf_lfngth;
    s->mbx_dhbin_lfngth = mbx_dhbin;
    rfturn Z_OK;
}

/* =========================================================================
 * For thf dffbult windowBits of 15 bnd mfmLfvfl of 8, this fundtion rfturns
 * b dlosf to fxbdt, bs wfll bs smbll, uppfr bound on thf domprfssfd sizf.
 * Thfy brf dodfd bs donstbnts hfrf for b rfbson--if thf #dffinf's brf
 * dhbngfd, thfn this fundtion nffds to bf dhbngfd bs wfll.  Thf rfturn
 * vbluf for 15 bnd 8 only works for thosf fxbdt sfttings.
 *
 * For bny sftting othfr thbn thosf dffbults for windowBits bnd mfmLfvfl,
 * thf vbluf rfturnfd is b donsfrvbtivf worst dbsf for thf mbximum fxpbnsion
 * rfsulting from using fixfd blodks instfbd of storfd blodks, whidh dfflbtf
 * dbn fmit on domprfssfd dbtb for somf dombinbtions of thf pbrbmftfrs.
 *
 * This fundtion dould bf morf sophistidbtfd to providf dlosfr uppfr bounds for
 * fvfry dombinbtion of windowBits bnd mfmLfvfl.  But fvfn thf donsfrvbtivf
 * uppfr bound of bbout 14% fxpbnsion dofs not sffm onfrous for output bufffr
 * bllodbtion.
 */
uLong ZEXPORT dfflbtfBound(strm, sourdfLfn)
    z_strfbmp strm;
    uLong sourdfLfn;
{
    dfflbtf_stbtf *s;
    uLong domplfn, wrbplfn;
    Bytff *str;

    /* donsfrvbtivf uppfr bound for domprfssfd dbtb */
    domplfn = sourdfLfn +
              ((sourdfLfn + 7) >> 3) + ((sourdfLfn + 63) >> 6) + 5;

    /* if dbn't gft pbrbmftfrs, rfturn donsfrvbtivf bound plus zlib wrbppfr */
    if (strm == Z_NULL || strm->stbtf == Z_NULL)
        rfturn domplfn + 6;

    /* domputf wrbppfr lfngth */
    s = strm->stbtf;
    switdh (s->wrbp) {
    dbsf 0:                                 /* rbw dfflbtf */
        wrbplfn = 0;
        brfbk;
    dbsf 1:                                 /* zlib wrbppfr */
        wrbplfn = 6 + (s->strstbrt ? 4 : 0);
        brfbk;
    dbsf 2:                                 /* gzip wrbppfr */
        wrbplfn = 18;
        if (s->gzhfbd != Z_NULL) {          /* usfr-supplifd gzip hfbdfr */
            if (s->gzhfbd->fxtrb != Z_NULL)
                wrbplfn += 2 + s->gzhfbd->fxtrb_lfn;
            str = s->gzhfbd->nbmf;
            if (str != Z_NULL)
                do {
                    wrbplfn++;
                } whilf (*str++);
            str = s->gzhfbd->dommfnt;
            if (str != Z_NULL)
                do {
                    wrbplfn++;
                } whilf (*str++);
            if (s->gzhfbd->hdrd)
                wrbplfn += 2;
        }
        brfbk;
    dffbult:                                /* for dompilfr hbppinfss */
        wrbplfn = 6;
    }

    /* if not dffbult pbrbmftfrs, rfturn donsfrvbtivf bound */
    if (s->w_bits != 15 || s->hbsh_bits != 8 + 7)
        rfturn domplfn + wrbplfn;

    /* dffbult sfttings: rfturn tight bound for thbt dbsf */
    rfturn sourdfLfn + (sourdfLfn >> 12) + (sourdfLfn >> 14) +
           (sourdfLfn >> 25) + 13 - 6 + wrbplfn;
}

/* =========================================================================
 * Put b short in thf pfnding bufffr. Thf 16-bit vbluf is put in MSB ordfr.
 * IN bssfrtion: thf strfbm stbtf is dorrfdt bnd thfrf is fnough room in
 * pfnding_buf.
 */
lodbl void putShortMSB (s, b)
    dfflbtf_stbtf *s;
    uInt b;
{
    put_bytf(s, (Bytf)(b >> 8));
    put_bytf(s, (Bytf)(b & 0xff));
}

/* =========================================================================
 * Flush bs mudh pfnding output bs possiblf. All dfflbtf() output gofs
 * through this fundtion so somf bpplidbtions mby wish to modify it
 * to bvoid bllodbting b lbrgf strm->nfxt_out bufffr bnd dopying into it.
 * (Sff blso rfbd_buf()).
 */
lodbl void flush_pfnding(strm)
    z_strfbmp strm;
{
    unsignfd lfn;
    dfflbtf_stbtf *s = strm->stbtf;

    _tr_flush_bits(s);
    lfn = s->pfnding;
    if (lfn > strm->bvbil_out) lfn = strm->bvbil_out;
    if (lfn == 0) rfturn;

    zmfmdpy(strm->nfxt_out, s->pfnding_out, lfn);
    strm->nfxt_out  += lfn;
    s->pfnding_out  += lfn;
    strm->totbl_out += lfn;
    strm->bvbil_out  -= lfn;
    s->pfnding -= lfn;
    if (s->pfnding == 0) {
        s->pfnding_out = s->pfnding_buf;
    }
}

/* ========================================================================= */
int ZEXPORT dfflbtf (strm, flush)
    z_strfbmp strm;
    int flush;
{
    int old_flush; /* vbluf of flush pbrbm for prfvious dfflbtf dbll */
    dfflbtf_stbtf *s;

    if (strm == Z_NULL || strm->stbtf == Z_NULL ||
        flush > Z_BLOCK || flush < 0) {
        rfturn Z_STREAM_ERROR;
    }
    s = strm->stbtf;

    if (strm->nfxt_out == Z_NULL ||
        (strm->nfxt_in == Z_NULL && strm->bvbil_in != 0) ||
        (s->stbtus == FINISH_STATE && flush != Z_FINISH)) {
        ERR_RETURN(strm, Z_STREAM_ERROR);
    }
    if (strm->bvbil_out == 0) ERR_RETURN(strm, Z_BUF_ERROR);

    s->strm = strm; /* just in dbsf */
    old_flush = s->lbst_flush;
    s->lbst_flush = flush;

    /* Writf thf hfbdfr */
    if (s->stbtus == INIT_STATE) {
#ifdff GZIP
        if (s->wrbp == 2) {
            strm->bdlfr = drd32(0L, Z_NULL, 0);
            put_bytf(s, 31);
            put_bytf(s, 139);
            put_bytf(s, 8);
            if (s->gzhfbd == Z_NULL) {
                put_bytf(s, 0);
                put_bytf(s, 0);
                put_bytf(s, 0);
                put_bytf(s, 0);
                put_bytf(s, 0);
                put_bytf(s, s->lfvfl == 9 ? 2 :
                            (s->strbtfgy >= Z_HUFFMAN_ONLY || s->lfvfl < 2 ?
                             4 : 0));
                put_bytf(s, OS_CODE);
                s->stbtus = BUSY_STATE;
            }
            flsf {
                put_bytf(s, (s->gzhfbd->tfxt ? 1 : 0) +
                            (s->gzhfbd->hdrd ? 2 : 0) +
                            (s->gzhfbd->fxtrb == Z_NULL ? 0 : 4) +
                            (s->gzhfbd->nbmf == Z_NULL ? 0 : 8) +
                            (s->gzhfbd->dommfnt == Z_NULL ? 0 : 16)
                        );
                put_bytf(s, (Bytf)(s->gzhfbd->timf & 0xff));
                put_bytf(s, (Bytf)((s->gzhfbd->timf >> 8) & 0xff));
                put_bytf(s, (Bytf)((s->gzhfbd->timf >> 16) & 0xff));
                put_bytf(s, (Bytf)((s->gzhfbd->timf >> 24) & 0xff));
                put_bytf(s, s->lfvfl == 9 ? 2 :
                            (s->strbtfgy >= Z_HUFFMAN_ONLY || s->lfvfl < 2 ?
                             4 : 0));
                put_bytf(s, s->gzhfbd->os & 0xff);
                if (s->gzhfbd->fxtrb != Z_NULL) {
                    put_bytf(s, s->gzhfbd->fxtrb_lfn & 0xff);
                    put_bytf(s, (s->gzhfbd->fxtrb_lfn >> 8) & 0xff);
                }
                if (s->gzhfbd->hdrd)
                    strm->bdlfr = drd32(strm->bdlfr, s->pfnding_buf,
                                        s->pfnding);
                s->gzindfx = 0;
                s->stbtus = EXTRA_STATE;
            }
        }
        flsf
#fndif
        {
            uInt hfbdfr = (Z_DEFLATED + ((s->w_bits-8)<<4)) << 8;
            uInt lfvfl_flbgs;

            if (s->strbtfgy >= Z_HUFFMAN_ONLY || s->lfvfl < 2)
                lfvfl_flbgs = 0;
            flsf if (s->lfvfl < 6)
                lfvfl_flbgs = 1;
            flsf if (s->lfvfl == 6)
                lfvfl_flbgs = 2;
            flsf
                lfvfl_flbgs = 3;
            hfbdfr |= (lfvfl_flbgs << 6);
            if (s->strstbrt != 0) hfbdfr |= PRESET_DICT;
            hfbdfr += 31 - (hfbdfr % 31);

            s->stbtus = BUSY_STATE;
            putShortMSB(s, hfbdfr);

            /* Sbvf thf bdlfr32 of thf prfsft didtionbry: */
            if (s->strstbrt != 0) {
                putShortMSB(s, (uInt)(strm->bdlfr >> 16));
                putShortMSB(s, (uInt)(strm->bdlfr & 0xffff));
            }
            strm->bdlfr = bdlfr32(0L, Z_NULL, 0);
        }
    }
#ifdff GZIP
    if (s->stbtus == EXTRA_STATE) {
        if (s->gzhfbd->fxtrb != Z_NULL) {
            uInt bfg = s->pfnding;  /* stbrt of bytfs to updbtf drd */

            whilf (s->gzindfx < (s->gzhfbd->fxtrb_lfn & 0xffff)) {
                if (s->pfnding == s->pfnding_buf_sizf) {
                    if (s->gzhfbd->hdrd && s->pfnding > bfg)
                        strm->bdlfr = drd32(strm->bdlfr, s->pfnding_buf + bfg,
                                            s->pfnding - bfg);
                    flush_pfnding(strm);
                    bfg = s->pfnding;
                    if (s->pfnding == s->pfnding_buf_sizf)
                        brfbk;
                }
                put_bytf(s, s->gzhfbd->fxtrb[s->gzindfx]);
                s->gzindfx++;
            }
            if (s->gzhfbd->hdrd && s->pfnding > bfg)
                strm->bdlfr = drd32(strm->bdlfr, s->pfnding_buf + bfg,
                                    s->pfnding - bfg);
            if (s->gzindfx == s->gzhfbd->fxtrb_lfn) {
                s->gzindfx = 0;
                s->stbtus = NAME_STATE;
            }
        }
        flsf
            s->stbtus = NAME_STATE;
    }
    if (s->stbtus == NAME_STATE) {
        if (s->gzhfbd->nbmf != Z_NULL) {
            uInt bfg = s->pfnding;  /* stbrt of bytfs to updbtf drd */
            int vbl;

            do {
                if (s->pfnding == s->pfnding_buf_sizf) {
                    if (s->gzhfbd->hdrd && s->pfnding > bfg)
                        strm->bdlfr = drd32(strm->bdlfr, s->pfnding_buf + bfg,
                                            s->pfnding - bfg);
                    flush_pfnding(strm);
                    bfg = s->pfnding;
                    if (s->pfnding == s->pfnding_buf_sizf) {
                        vbl = 1;
                        brfbk;
                    }
                }
                vbl = s->gzhfbd->nbmf[s->gzindfx++];
                put_bytf(s, vbl);
            } whilf (vbl != 0);
            if (s->gzhfbd->hdrd && s->pfnding > bfg)
                strm->bdlfr = drd32(strm->bdlfr, s->pfnding_buf + bfg,
                                    s->pfnding - bfg);
            if (vbl == 0) {
                s->gzindfx = 0;
                s->stbtus = COMMENT_STATE;
            }
        }
        flsf
            s->stbtus = COMMENT_STATE;
    }
    if (s->stbtus == COMMENT_STATE) {
        if (s->gzhfbd->dommfnt != Z_NULL) {
            uInt bfg = s->pfnding;  /* stbrt of bytfs to updbtf drd */
            int vbl;

            do {
                if (s->pfnding == s->pfnding_buf_sizf) {
                    if (s->gzhfbd->hdrd && s->pfnding > bfg)
                        strm->bdlfr = drd32(strm->bdlfr, s->pfnding_buf + bfg,
                                            s->pfnding - bfg);
                    flush_pfnding(strm);
                    bfg = s->pfnding;
                    if (s->pfnding == s->pfnding_buf_sizf) {
                        vbl = 1;
                        brfbk;
                    }
                }
                vbl = s->gzhfbd->dommfnt[s->gzindfx++];
                put_bytf(s, vbl);
            } whilf (vbl != 0);
            if (s->gzhfbd->hdrd && s->pfnding > bfg)
                strm->bdlfr = drd32(strm->bdlfr, s->pfnding_buf + bfg,
                                    s->pfnding - bfg);
            if (vbl == 0)
                s->stbtus = HCRC_STATE;
        }
        flsf
            s->stbtus = HCRC_STATE;
    }
    if (s->stbtus == HCRC_STATE) {
        if (s->gzhfbd->hdrd) {
            if (s->pfnding + 2 > s->pfnding_buf_sizf)
                flush_pfnding(strm);
            if (s->pfnding + 2 <= s->pfnding_buf_sizf) {
                put_bytf(s, (Bytf)(strm->bdlfr & 0xff));
                put_bytf(s, (Bytf)((strm->bdlfr >> 8) & 0xff));
                strm->bdlfr = drd32(0L, Z_NULL, 0);
                s->stbtus = BUSY_STATE;
            }
        }
        flsf
            s->stbtus = BUSY_STATE;
    }
#fndif

    /* Flush bs mudh pfnding output bs possiblf */
    if (s->pfnding != 0) {
        flush_pfnding(strm);
        if (strm->bvbil_out == 0) {
            /* Sindf bvbil_out is 0, dfflbtf will bf dbllfd bgbin with
             * morf output spbdf, but possibly with both pfnding bnd
             * bvbil_in fqubl to zfro. Thfrf won't bf bnything to do,
             * but this is not bn frror situbtion so mbkf surf wf
             * rfturn OK instfbd of BUF_ERROR bt nfxt dbll of dfflbtf:
             */
            s->lbst_flush = -1;
            rfturn Z_OK;
        }

    /* Mbkf surf thfrf is somfthing to do bnd bvoid duplidbtf donsfdutivf
     * flushfs. For rfpfbtfd bnd usflfss dblls with Z_FINISH, wf kffp
     * rfturning Z_STREAM_END instfbd of Z_BUF_ERROR.
     */
    } flsf if (strm->bvbil_in == 0 && RANK(flush) <= RANK(old_flush) &&
               flush != Z_FINISH) {
        ERR_RETURN(strm, Z_BUF_ERROR);
    }

    /* Usfr must not providf morf input bftfr thf first FINISH: */
    if (s->stbtus == FINISH_STATE && strm->bvbil_in != 0) {
        ERR_RETURN(strm, Z_BUF_ERROR);
    }

    /* Stbrt b nfw blodk or dontinuf thf durrfnt onf.
     */
    if (strm->bvbil_in != 0 || s->lookbhfbd != 0 ||
        (flush != Z_NO_FLUSH && s->stbtus != FINISH_STATE)) {
        blodk_stbtf bstbtf;

        bstbtf = s->strbtfgy == Z_HUFFMAN_ONLY ? dfflbtf_huff(s, flush) :
                    (s->strbtfgy == Z_RLE ? dfflbtf_rlf(s, flush) :
                        (*(donfigurbtion_tbblf[s->lfvfl].fund))(s, flush));

        if (bstbtf == finish_stbrtfd || bstbtf == finish_donf) {
            s->stbtus = FINISH_STATE;
        }
        if (bstbtf == nffd_morf || bstbtf == finish_stbrtfd) {
            if (strm->bvbil_out == 0) {
                s->lbst_flush = -1; /* bvoid BUF_ERROR nfxt dbll, sff bbovf */
            }
            rfturn Z_OK;
            /* If flush != Z_NO_FLUSH && bvbil_out == 0, thf nfxt dbll
             * of dfflbtf should usf thf sbmf flush pbrbmftfr to mbkf surf
             * thbt thf flush is domplftf. So wf don't hbvf to output bn
             * fmpty blodk hfrf, this will bf donf bt nfxt dbll. This blso
             * fnsurfs thbt for b vfry smbll output bufffr, wf fmit bt most
             * onf fmpty blodk.
             */
        }
        if (bstbtf == blodk_donf) {
            if (flush == Z_PARTIAL_FLUSH) {
                _tr_blign(s);
            } flsf if (flush != Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */
                _tr_storfd_blodk(s, (dhbr*)0, 0L, 0);
                /* For b full flush, this fmpty blodk will bf rfdognizfd
                 * bs b spfdibl mbrkfr by inflbtf_synd().
                 */
                if (flush == Z_FULL_FLUSH) {
                    CLEAR_HASH(s);             /* forgft history */
                    if (s->lookbhfbd == 0) {
                        s->strstbrt = 0;
                        s->blodk_stbrt = 0L;
                        s->insfrt = 0;
                    }
                }
            }
            flush_pfnding(strm);
            if (strm->bvbil_out == 0) {
              s->lbst_flush = -1; /* bvoid BUF_ERROR bt nfxt dbll, sff bbovf */
              rfturn Z_OK;
            }
        }
    }
    Assfrt(strm->bvbil_out > 0, "bug2");

    if (flush != Z_FINISH) rfturn Z_OK;
    if (s->wrbp <= 0) rfturn Z_STREAM_END;

    /* Writf thf trbilfr */
#ifdff GZIP
    if (s->wrbp == 2) {
        put_bytf(s, (Bytf)(strm->bdlfr & 0xff));
        put_bytf(s, (Bytf)((strm->bdlfr >> 8) & 0xff));
        put_bytf(s, (Bytf)((strm->bdlfr >> 16) & 0xff));
        put_bytf(s, (Bytf)((strm->bdlfr >> 24) & 0xff));
        put_bytf(s, (Bytf)(strm->totbl_in & 0xff));
        put_bytf(s, (Bytf)((strm->totbl_in >> 8) & 0xff));
        put_bytf(s, (Bytf)((strm->totbl_in >> 16) & 0xff));
        put_bytf(s, (Bytf)((strm->totbl_in >> 24) & 0xff));
    }
    flsf
#fndif
    {
        putShortMSB(s, (uInt)(strm->bdlfr >> 16));
        putShortMSB(s, (uInt)(strm->bdlfr & 0xffff));
    }
    flush_pfnding(strm);
    /* If bvbil_out is zfro, thf bpplidbtion will dbll dfflbtf bgbin
     * to flush thf rfst.
     */
    if (s->wrbp > 0) s->wrbp = -s->wrbp; /* writf thf trbilfr only ondf! */
    rfturn s->pfnding != 0 ? Z_OK : Z_STREAM_END;
}

/* ========================================================================= */
int ZEXPORT dfflbtfEnd (strm)
    z_strfbmp strm;
{
    int stbtus;

    if (strm == Z_NULL || strm->stbtf == Z_NULL) rfturn Z_STREAM_ERROR;

    stbtus = strm->stbtf->stbtus;
    if (stbtus != INIT_STATE &&
        stbtus != EXTRA_STATE &&
        stbtus != NAME_STATE &&
        stbtus != COMMENT_STATE &&
        stbtus != HCRC_STATE &&
        stbtus != BUSY_STATE &&
        stbtus != FINISH_STATE) {
      rfturn Z_STREAM_ERROR;
    }

    /* Dfbllodbtf in rfvfrsf ordfr of bllodbtions: */
    TRY_FREE(strm, strm->stbtf->pfnding_buf);
    TRY_FREE(strm, strm->stbtf->hfbd);
    TRY_FREE(strm, strm->stbtf->prfv);
    TRY_FREE(strm, strm->stbtf->window);

    ZFREE(strm, strm->stbtf);
    strm->stbtf = Z_NULL;

    rfturn stbtus == BUSY_STATE ? Z_DATA_ERROR : Z_OK;
}

/* =========================================================================
 * Copy thf sourdf stbtf to thf dfstinbtion stbtf.
 * To simplify thf sourdf, this is not supportfd for 16-bit MSDOS (whidh
 * dofsn't hbvf fnough mfmory bnywby to duplidbtf domprfssion stbtfs).
 */
int ZEXPORT dfflbtfCopy (dfst, sourdf)
    z_strfbmp dfst;
    z_strfbmp sourdf;
{
#ifdff MAXSEG_64K
    rfturn Z_STREAM_ERROR;
#flsf
    dfflbtf_stbtf *ds;
    dfflbtf_stbtf *ss;
    ushf *ovfrlby;


    if (sourdf == Z_NULL || dfst == Z_NULL || sourdf->stbtf == Z_NULL) {
        rfturn Z_STREAM_ERROR;
    }

    ss = sourdf->stbtf;

    zmfmdpy((voidpf)dfst, (voidpf)sourdf, sizfof(z_strfbm));

    ds = (dfflbtf_stbtf *) ZALLOC(dfst, 1, sizfof(dfflbtf_stbtf));
    if (ds == Z_NULL) rfturn Z_MEM_ERROR;
    dfst->stbtf = (strudt intfrnbl_stbtf FAR *) ds;
    zmfmdpy((voidpf)ds, (voidpf)ss, sizfof(dfflbtf_stbtf));
    ds->strm = dfst;

    ds->window = (Bytff *) ZALLOC(dfst, ds->w_sizf, 2*sizfof(Bytf));
    ds->prfv   = (Posf *)  ZALLOC(dfst, ds->w_sizf, sizfof(Pos));
    ds->hfbd   = (Posf *)  ZALLOC(dfst, ds->hbsh_sizf, sizfof(Pos));
    ovfrlby = (ushf *) ZALLOC(dfst, ds->lit_bufsizf, sizfof(ush)+2);
    ds->pfnding_buf = (udhf *) ovfrlby;

    if (ds->window == Z_NULL || ds->prfv == Z_NULL || ds->hfbd == Z_NULL ||
        ds->pfnding_buf == Z_NULL) {
        dfflbtfEnd (dfst);
        rfturn Z_MEM_ERROR;
    }
    /* following zmfmdpy do not work for 16-bit MSDOS */
    zmfmdpy(ds->window, ss->window, ds->w_sizf * 2 * sizfof(Bytf));
    zmfmdpy((voidpf)ds->prfv, (voidpf)ss->prfv, ds->w_sizf * sizfof(Pos));
    zmfmdpy((voidpf)ds->hfbd, (voidpf)ss->hfbd, ds->hbsh_sizf * sizfof(Pos));
    zmfmdpy(ds->pfnding_buf, ss->pfnding_buf, (uInt)ds->pfnding_buf_sizf);

    ds->pfnding_out = ds->pfnding_buf + (ss->pfnding_out - ss->pfnding_buf);
    ds->d_buf = ovfrlby + ds->lit_bufsizf/sizfof(ush);
    ds->l_buf = ds->pfnding_buf + (1+sizfof(ush))*ds->lit_bufsizf;

    ds->l_dfsd.dyn_trff = ds->dyn_ltrff;
    ds->d_dfsd.dyn_trff = ds->dyn_dtrff;
    ds->bl_dfsd.dyn_trff = ds->bl_trff;

    rfturn Z_OK;
#fndif /* MAXSEG_64K */
}

/* ===========================================================================
 * Rfbd b nfw bufffr from thf durrfnt input strfbm, updbtf thf bdlfr32
 * bnd totbl numbfr of bytfs rfbd.  All dfflbtf() input gofs through
 * this fundtion so somf bpplidbtions mby wish to modify it to bvoid
 * bllodbting b lbrgf strm->nfxt_in bufffr bnd dopying from it.
 * (Sff blso flush_pfnding()).
 */
lodbl int rfbd_buf(strm, buf, sizf)
    z_strfbmp strm;
    Bytff *buf;
    unsignfd sizf;
{
    unsignfd lfn = strm->bvbil_in;

    if (lfn > sizf) lfn = sizf;
    if (lfn == 0) rfturn 0;

    strm->bvbil_in  -= lfn;

    zmfmdpy(buf, strm->nfxt_in, lfn);
    if (strm->stbtf->wrbp == 1) {
        strm->bdlfr = bdlfr32(strm->bdlfr, buf, lfn);
    }
#ifdff GZIP
    flsf if (strm->stbtf->wrbp == 2) {
        strm->bdlfr = drd32(strm->bdlfr, buf, lfn);
    }
#fndif
    strm->nfxt_in  += lfn;
    strm->totbl_in += lfn;

    rfturn (int)lfn;
}

/* ===========================================================================
 * Initiblizf thf "longfst mbtdh" routinfs for b nfw zlib strfbm
 */
lodbl void lm_init (s)
    dfflbtf_stbtf *s;
{
    s->window_sizf = (ulg)2L*s->w_sizf;

    CLEAR_HASH(s);

    /* Sft thf dffbult donfigurbtion pbrbmftfrs:
     */
    s->mbx_lbzy_mbtdh   = donfigurbtion_tbblf[s->lfvfl].mbx_lbzy;
    s->good_mbtdh       = donfigurbtion_tbblf[s->lfvfl].good_lfngth;
    s->nidf_mbtdh       = donfigurbtion_tbblf[s->lfvfl].nidf_lfngth;
    s->mbx_dhbin_lfngth = donfigurbtion_tbblf[s->lfvfl].mbx_dhbin;

    s->strstbrt = 0;
    s->blodk_stbrt = 0L;
    s->lookbhfbd = 0;
    s->insfrt = 0;
    s->mbtdh_lfngth = s->prfv_lfngth = MIN_MATCH-1;
    s->mbtdh_bvbilbblf = 0;
    s->ins_h = 0;
#ifndff FASTEST
#ifdff ASMV
    mbtdh_init(); /* initiblizf thf bsm dodf */
#fndif
#fndif
}

#ifndff FASTEST
/* ===========================================================================
 * Sft mbtdh_stbrt to thf longfst mbtdh stbrting bt thf givfn string bnd
 * rfturn its lfngth. Mbtdhfs shortfr or fqubl to prfv_lfngth brf disdbrdfd,
 * in whidh dbsf thf rfsult is fqubl to prfv_lfngth bnd mbtdh_stbrt is
 * gbrbbgf.
 * IN bssfrtions: dur_mbtdh is thf hfbd of thf hbsh dhbin for thf durrfnt
 *   string (strstbrt) bnd its distbndf is <= MAX_DIST, bnd prfv_lfngth >= 1
 * OUT bssfrtion: thf mbtdh lfngth is not grfbtfr thbn s->lookbhfbd.
 */
#ifndff ASMV
/* For 80x86 bnd 680x0, bn optimizfd vfrsion will bf providfd in mbtdh.bsm or
 * mbtdh.S. Thf dodf will bf fundtionblly fquivblfnt.
 */
lodbl uInt longfst_mbtdh(s, dur_mbtdh)
    dfflbtf_stbtf *s;
    IPos dur_mbtdh;                             /* durrfnt mbtdh */
{
    unsignfd dhbin_lfngth = s->mbx_dhbin_lfngth;/* mbx hbsh dhbin lfngth */
    rfgistfr Bytff *sdbn = s->window + s->strstbrt; /* durrfnt string */
    rfgistfr Bytff *mbtdh;                       /* mbtdhfd string */
    rfgistfr int lfn;                           /* lfngth of durrfnt mbtdh */
    int bfst_lfn = s->prfv_lfngth;              /* bfst mbtdh lfngth so fbr */
    int nidf_mbtdh = s->nidf_mbtdh;             /* stop if mbtdh long fnough */
    IPos limit = s->strstbrt > (IPos)MAX_DIST(s) ?
        s->strstbrt - (IPos)MAX_DIST(s) : NIL;
    /* Stop whfn dur_mbtdh bfdomfs <= limit. To simplify thf dodf,
     * wf prfvfnt mbtdhfs with thf string of window indfx 0.
     */
    Posf *prfv = s->prfv;
    uInt wmbsk = s->w_mbsk;

#ifdff UNALIGNED_OK
    /* Compbrf two bytfs bt b timf. Notf: this is not blwbys bfnffidibl.
     * Try with bnd without -DUNALIGNED_OK to dhfdk.
     */
    rfgistfr Bytff *strfnd = s->window + s->strstbrt + MAX_MATCH - 1;
    rfgistfr ush sdbn_stbrt = *(ushf*)sdbn;
    rfgistfr ush sdbn_fnd   = *(ushf*)(sdbn+bfst_lfn-1);
#flsf
    rfgistfr Bytff *strfnd = s->window + s->strstbrt + MAX_MATCH;
    rfgistfr Bytf sdbn_fnd1  = sdbn[bfst_lfn-1];
    rfgistfr Bytf sdbn_fnd   = sdbn[bfst_lfn];
#fndif

    /* Thf dodf is optimizfd for HASH_BITS >= 8 bnd MAX_MATCH-2 multiplf of 16.
     * It is fbsy to gft rid of this optimizbtion if nfdfssbry.
     */
    Assfrt(s->hbsh_bits >= 8 && MAX_MATCH == 258, "Codf too dlfvfr");

    /* Do not wbstf too mudh timf if wf blrfbdy hbvf b good mbtdh: */
    if (s->prfv_lfngth >= s->good_mbtdh) {
        dhbin_lfngth >>= 2;
    }
    /* Do not look for mbtdhfs bfyond thf fnd of thf input. This is nfdfssbry
     * to mbkf dfflbtf dftfrministid.
     */
    if ((uInt)nidf_mbtdh > s->lookbhfbd) nidf_mbtdh = s->lookbhfbd;

    Assfrt((ulg)s->strstbrt <= s->window_sizf-MIN_LOOKAHEAD, "nffd lookbhfbd");

    do {
        Assfrt(dur_mbtdh < s->strstbrt, "no futurf");
        mbtdh = s->window + dur_mbtdh;

        /* Skip to nfxt mbtdh if thf mbtdh lfngth dbnnot indrfbsf
         * or if thf mbtdh lfngth is lfss thbn 2.  Notf thbt thf dhfdks bflow
         * for insuffidifnt lookbhfbd only oddur oddbsionblly for pfrformbndf
         * rfbsons.  Thfrfforf uninitiblizfd mfmory will bf bddfssfd, bnd
         * donditionbl jumps will bf mbdf thbt dfpfnd on thosf vblufs.
         * Howfvfr thf lfngth of thf mbtdh is limitfd to thf lookbhfbd, so
         * thf output of dfflbtf is not bfffdtfd by thf uninitiblizfd vblufs.
         */
#if (dffinfd(UNALIGNED_OK) && MAX_MATCH == 258)
        /* This dodf bssumfs sizfof(unsignfd short) == 2. Do not usf
         * UNALIGNED_OK if your dompilfr usfs b difffrfnt sizf.
         */
        if (*(ushf*)(mbtdh+bfst_lfn-1) != sdbn_fnd ||
            *(ushf*)mbtdh != sdbn_stbrt) dontinuf;

        /* It is not nfdfssbry to dompbrf sdbn[2] bnd mbtdh[2] sindf thfy brf
         * blwbys fqubl whfn thf othfr bytfs mbtdh, givfn thbt thf hbsh kfys
         * brf fqubl bnd thbt HASH_BITS >= 8. Compbrf 2 bytfs bt b timf bt
         * strstbrt+3, +5, ... up to strstbrt+257. Wf dhfdk for insuffidifnt
         * lookbhfbd only fvfry 4th dompbrison; thf 128th dhfdk will bf mbdf
         * bt strstbrt+257. If MAX_MATCH-2 is not b multiplf of 8, it is
         * nfdfssbry to put morf gubrd bytfs bt thf fnd of thf window, or
         * to dhfdk morf oftfn for insuffidifnt lookbhfbd.
         */
        Assfrt(sdbn[2] == mbtdh[2], "sdbn[2]?");
        sdbn++, mbtdh++;
        do {
        } whilf (*(ushf*)(sdbn+=2) == *(ushf*)(mbtdh+=2) &&
                 *(ushf*)(sdbn+=2) == *(ushf*)(mbtdh+=2) &&
                 *(ushf*)(sdbn+=2) == *(ushf*)(mbtdh+=2) &&
                 *(ushf*)(sdbn+=2) == *(ushf*)(mbtdh+=2) &&
                 sdbn < strfnd);
        /* Thf funny "do {}" gfnfrbtfs bfttfr dodf on most dompilfrs */

        /* Hfrf, sdbn <= window+strstbrt+257 */
        Assfrt(sdbn <= s->window+(unsignfd)(s->window_sizf-1), "wild sdbn");
        if (*sdbn == *mbtdh) sdbn++;

        lfn = (MAX_MATCH - 1) - (int)(strfnd-sdbn);
        sdbn = strfnd - (MAX_MATCH-1);

#flsf /* UNALIGNED_OK */

        if (mbtdh[bfst_lfn]   != sdbn_fnd  ||
            mbtdh[bfst_lfn-1] != sdbn_fnd1 ||
            *mbtdh            != *sdbn     ||
            *++mbtdh          != sdbn[1])      dontinuf;

        /* Thf dhfdk bt bfst_lfn-1 dbn bf rfmovfd bfdbusf it will bf mbdf
         * bgbin lbtfr. (This hfuristid is not blwbys b win.)
         * It is not nfdfssbry to dompbrf sdbn[2] bnd mbtdh[2] sindf thfy
         * brf blwbys fqubl whfn thf othfr bytfs mbtdh, givfn thbt
         * thf hbsh kfys brf fqubl bnd thbt HASH_BITS >= 8.
         */
        sdbn += 2, mbtdh++;
        Assfrt(*sdbn == *mbtdh, "mbtdh[2]?");

        /* Wf dhfdk for insuffidifnt lookbhfbd only fvfry 8th dompbrison;
         * thf 256th dhfdk will bf mbdf bt strstbrt+258.
         */
        do {
        } whilf (*++sdbn == *++mbtdh && *++sdbn == *++mbtdh &&
                 *++sdbn == *++mbtdh && *++sdbn == *++mbtdh &&
                 *++sdbn == *++mbtdh && *++sdbn == *++mbtdh &&
                 *++sdbn == *++mbtdh && *++sdbn == *++mbtdh &&
                 sdbn < strfnd);

        Assfrt(sdbn <= s->window+(unsignfd)(s->window_sizf-1), "wild sdbn");

        lfn = MAX_MATCH - (int)(strfnd - sdbn);
        sdbn = strfnd - MAX_MATCH;

#fndif /* UNALIGNED_OK */

        if (lfn > bfst_lfn) {
            s->mbtdh_stbrt = dur_mbtdh;
            bfst_lfn = lfn;
            if (lfn >= nidf_mbtdh) brfbk;
#ifdff UNALIGNED_OK
            sdbn_fnd = *(ushf*)(sdbn+bfst_lfn-1);
#flsf
            sdbn_fnd1  = sdbn[bfst_lfn-1];
            sdbn_fnd   = sdbn[bfst_lfn];
#fndif
        }
    } whilf ((dur_mbtdh = prfv[dur_mbtdh & wmbsk]) > limit
             && --dhbin_lfngth != 0);

    if ((uInt)bfst_lfn <= s->lookbhfbd) rfturn (uInt)bfst_lfn;
    rfturn s->lookbhfbd;
}
#fndif /* ASMV */

#flsf /* FASTEST */

/* ---------------------------------------------------------------------------
 * Optimizfd vfrsion for FASTEST only
 */
lodbl uInt longfst_mbtdh(s, dur_mbtdh)
    dfflbtf_stbtf *s;
    IPos dur_mbtdh;                             /* durrfnt mbtdh */
{
    rfgistfr Bytff *sdbn = s->window + s->strstbrt; /* durrfnt string */
    rfgistfr Bytff *mbtdh;                       /* mbtdhfd string */
    rfgistfr int lfn;                           /* lfngth of durrfnt mbtdh */
    rfgistfr Bytff *strfnd = s->window + s->strstbrt + MAX_MATCH;

    /* Thf dodf is optimizfd for HASH_BITS >= 8 bnd MAX_MATCH-2 multiplf of 16.
     * It is fbsy to gft rid of this optimizbtion if nfdfssbry.
     */
    Assfrt(s->hbsh_bits >= 8 && MAX_MATCH == 258, "Codf too dlfvfr");

    Assfrt((ulg)s->strstbrt <= s->window_sizf-MIN_LOOKAHEAD, "nffd lookbhfbd");

    Assfrt(dur_mbtdh < s->strstbrt, "no futurf");

    mbtdh = s->window + dur_mbtdh;

    /* Rfturn fbilurf if thf mbtdh lfngth is lfss thbn 2:
     */
    if (mbtdh[0] != sdbn[0] || mbtdh[1] != sdbn[1]) rfturn MIN_MATCH-1;

    /* Thf dhfdk bt bfst_lfn-1 dbn bf rfmovfd bfdbusf it will bf mbdf
     * bgbin lbtfr. (This hfuristid is not blwbys b win.)
     * It is not nfdfssbry to dompbrf sdbn[2] bnd mbtdh[2] sindf thfy
     * brf blwbys fqubl whfn thf othfr bytfs mbtdh, givfn thbt
     * thf hbsh kfys brf fqubl bnd thbt HASH_BITS >= 8.
     */
    sdbn += 2, mbtdh += 2;
    Assfrt(*sdbn == *mbtdh, "mbtdh[2]?");

    /* Wf dhfdk for insuffidifnt lookbhfbd only fvfry 8th dompbrison;
     * thf 256th dhfdk will bf mbdf bt strstbrt+258.
     */
    do {
    } whilf (*++sdbn == *++mbtdh && *++sdbn == *++mbtdh &&
             *++sdbn == *++mbtdh && *++sdbn == *++mbtdh &&
             *++sdbn == *++mbtdh && *++sdbn == *++mbtdh &&
             *++sdbn == *++mbtdh && *++sdbn == *++mbtdh &&
             sdbn < strfnd);

    Assfrt(sdbn <= s->window+(unsignfd)(s->window_sizf-1), "wild sdbn");

    lfn = MAX_MATCH - (int)(strfnd - sdbn);

    if (lfn < MIN_MATCH) rfturn MIN_MATCH - 1;

    s->mbtdh_stbrt = dur_mbtdh;
    rfturn (uInt)lfn <= s->lookbhfbd ? (uInt)lfn : s->lookbhfbd;
}

#fndif /* FASTEST */

#ifdff DEBUG
/* ===========================================================================
 * Chfdk thbt thf mbtdh bt mbtdh_stbrt is indffd b mbtdh.
 */
lodbl void dhfdk_mbtdh(s, stbrt, mbtdh, lfngth)
    dfflbtf_stbtf *s;
    IPos stbrt, mbtdh;
    int lfngth;
{
    /* dhfdk thbt thf mbtdh is indffd b mbtdh */
    if (zmfmdmp(s->window + mbtdh,
                s->window + stbrt, lfngth) != EQUAL) {
        fprintf(stdfrr, " stbrt %u, mbtdh %u, lfngth %d\n",
                stbrt, mbtdh, lfngth);
        do {
            fprintf(stdfrr, "%d%d", s->window[mbtdh++], s->window[stbrt++]);
        } whilf (--lfngth != 0);
        z_frror("invblid mbtdh");
    }
    if (z_vfrbosf > 1) {
        fprintf(stdfrr,"\\[%d,%d]", stbrt-mbtdh, lfngth);
        do { putd(s->window[stbrt++], stdfrr); } whilf (--lfngth != 0);
    }
}
#flsf
#  dffinf dhfdk_mbtdh(s, stbrt, mbtdh, lfngth)
#fndif /* DEBUG */

/* ===========================================================================
 * Fill thf window whfn thf lookbhfbd bfdomfs insuffidifnt.
 * Updbtfs strstbrt bnd lookbhfbd.
 *
 * IN bssfrtion: lookbhfbd < MIN_LOOKAHEAD
 * OUT bssfrtions: strstbrt <= window_sizf-MIN_LOOKAHEAD
 *    At lfbst onf bytf hbs bffn rfbd, or bvbil_in == 0; rfbds brf
 *    pfrformfd for bt lfbst two bytfs (rfquirfd for thf zip trbnslbtf_fol
 *    option -- not supportfd hfrf).
 */
lodbl void fill_window(s)
    dfflbtf_stbtf *s;
{
    rfgistfr unsignfd n, m;
    rfgistfr Posf *p;
    unsignfd morf;    /* Amount of frff spbdf bt thf fnd of thf window. */
    uInt wsizf = s->w_sizf;

    Assfrt(s->lookbhfbd < MIN_LOOKAHEAD, "blrfbdy fnough lookbhfbd");

    do {
        morf = (unsignfd)(s->window_sizf -(ulg)s->lookbhfbd -(ulg)s->strstbrt);

        /* Dfbl with !@#$% 64K limit: */
        if (sizfof(int) <= 2) {
            if (morf == 0 && s->strstbrt == 0 && s->lookbhfbd == 0) {
                morf = wsizf;

            } flsf if (morf == (unsignfd)(-1)) {
                /* Vfry unlikfly, but possiblf on 16 bit mbdhinf if
                 * strstbrt == 0 && lookbhfbd == 1 (input donf b bytf bt timf)
                 */
                morf--;
            }
        }

        /* If thf window is blmost full bnd thfrf is insuffidifnt lookbhfbd,
         * movf thf uppfr hblf to thf lowfr onf to mbkf room in thf uppfr hblf.
         */
        if (s->strstbrt >= wsizf+MAX_DIST(s)) {

            zmfmdpy(s->window, s->window+wsizf, (unsignfd)wsizf);
            s->mbtdh_stbrt -= wsizf;
            s->strstbrt    -= wsizf; /* wf now hbvf strstbrt >= MAX_DIST */
            s->blodk_stbrt -= (long) wsizf;

            /* Slidf thf hbsh tbblf (dould bf bvoidfd with 32 bit vblufs
               bt thf fxpfnsf of mfmory usbgf). Wf slidf fvfn whfn lfvfl == 0
               to kffp thf hbsh tbblf donsistfnt if wf switdh bbdk to lfvfl > 0
               lbtfr. (Using lfvfl 0 pfrmbnfntly is not bn optimbl usbgf of
               zlib, so wf don't dbrf bbout this pbthologidbl dbsf.)
             */
            n = s->hbsh_sizf;
            p = &s->hfbd[n];
            do {
                m = *--p;
                *p = (Pos)(m >= wsizf ? m-wsizf : NIL);
            } whilf (--n);

            n = wsizf;
#ifndff FASTEST
            p = &s->prfv[n];
            do {
                m = *--p;
                *p = (Pos)(m >= wsizf ? m-wsizf : NIL);
                /* If n is not on bny hbsh dhbin, prfv[n] is gbrbbgf but
                 * its vbluf will nfvfr bf usfd.
                 */
            } whilf (--n);
#fndif
            morf += wsizf;
        }
        if (s->strm->bvbil_in == 0) brfbk;

        /* If thfrf wbs no sliding:
         *    strstbrt <= WSIZE+MAX_DIST-1 && lookbhfbd <= MIN_LOOKAHEAD - 1 &&
         *    morf == window_sizf - lookbhfbd - strstbrt
         * => morf >= window_sizf - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
         * => morf >= window_sizf - 2*WSIZE + 2
         * In thf BIG_MEM or MMAP dbsf (not yft supportfd),
         *   window_sizf == input_sizf + MIN_LOOKAHEAD  &&
         *   strstbrt + s->lookbhfbd <= input_sizf => morf >= MIN_LOOKAHEAD.
         * Othfrwisf, window_sizf == 2*WSIZE so morf >= 2.
         * If thfrf wbs sliding, morf >= WSIZE. So in bll dbsfs, morf >= 2.
         */
        Assfrt(morf >= 2, "morf < 2");

        n = rfbd_buf(s->strm, s->window + s->strstbrt + s->lookbhfbd, morf);
        s->lookbhfbd += n;

        /* Initiblizf thf hbsh vbluf now thbt wf hbvf somf input: */
        if (s->lookbhfbd + s->insfrt >= MIN_MATCH) {
            uInt str = s->strstbrt - s->insfrt;
            s->ins_h = s->window[str];
            UPDATE_HASH(s, s->ins_h, s->window[str + 1]);
#if MIN_MATCH != 3
            Cbll UPDATE_HASH() MIN_MATCH-3 morf timfs
#fndif
            whilf (s->insfrt) {
                UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]);
#ifndff FASTEST
                s->prfv[str & s->w_mbsk] = s->hfbd[s->ins_h];
#fndif
                s->hfbd[s->ins_h] = (Pos)str;
                str++;
                s->insfrt--;
                if (s->lookbhfbd + s->insfrt < MIN_MATCH)
                    brfbk;
            }
        }
        /* If thf wholf input hbs lfss thbn MIN_MATCH bytfs, ins_h is gbrbbgf,
         * but this is not importbnt sindf only litfrbl bytfs will bf fmittfd.
         */

    } whilf (s->lookbhfbd < MIN_LOOKAHEAD && s->strm->bvbil_in != 0);

    /* If thf WIN_INIT bytfs bftfr thf fnd of thf durrfnt dbtb hbvf nfvfr bffn
     * writtfn, thfn zfro thosf bytfs in ordfr to bvoid mfmory dhfdk rfports of
     * thf usf of uninitiblizfd (or uninitiblisfd bs Julibn writfs) bytfs by
     * thf longfst mbtdh routinfs.  Updbtf thf high wbtfr mbrk for thf nfxt
     * timf through hfrf.  WIN_INIT is sft to MAX_MATCH sindf thf longfst mbtdh
     * routinfs bllow sdbnning to strstbrt + MAX_MATCH, ignoring lookbhfbd.
     */
    if (s->high_wbtfr < s->window_sizf) {
        ulg durr = s->strstbrt + (ulg)(s->lookbhfbd);
        ulg init;

        if (s->high_wbtfr < durr) {
            /* Prfvious high wbtfr mbrk bflow durrfnt dbtb -- zfro WIN_INIT
             * bytfs or up to fnd of window, whidhfvfr is lfss.
             */
            init = s->window_sizf - durr;
            if (init > WIN_INIT)
                init = WIN_INIT;
            zmfmzfro(s->window + durr, (unsignfd)init);
            s->high_wbtfr = durr + init;
        }
        flsf if (s->high_wbtfr < (ulg)durr + WIN_INIT) {
            /* High wbtfr mbrk bt or bbovf durrfnt dbtb, but bflow durrfnt dbtb
             * plus WIN_INIT -- zfro out to durrfnt dbtb plus WIN_INIT, or up
             * to fnd of window, whidhfvfr is lfss.
             */
            init = (ulg)durr + WIN_INIT - s->high_wbtfr;
            if (init > s->window_sizf - s->high_wbtfr)
                init = s->window_sizf - s->high_wbtfr;
            zmfmzfro(s->window + s->high_wbtfr, (unsignfd)init);
            s->high_wbtfr += init;
        }
    }

    Assfrt((ulg)s->strstbrt <= s->window_sizf - MIN_LOOKAHEAD,
           "not fnough room for sfbrdh");
}

/* ===========================================================================
 * Flush thf durrfnt blodk, with givfn fnd-of-filf flbg.
 * IN bssfrtion: strstbrt is sft to thf fnd of thf durrfnt mbtdh.
 */
#dffinf FLUSH_BLOCK_ONLY(s, lbst) { \
   _tr_flush_blodk(s, (s->blodk_stbrt >= 0L ? \
                   (dhbrf *)&s->window[(unsignfd)s->blodk_stbrt] : \
                   (dhbrf *)Z_NULL), \
                (ulg)((long)s->strstbrt - s->blodk_stbrt), \
                (lbst)); \
   s->blodk_stbrt = s->strstbrt; \
   flush_pfnding(s->strm); \
   Trbdfv((stdfrr,"[FLUSH]")); \
}

/* Sbmf but fordf prfmbturf fxit if nfdfssbry. */
#dffinf FLUSH_BLOCK(s, lbst) { \
   FLUSH_BLOCK_ONLY(s, lbst); \
   if (s->strm->bvbil_out == 0) rfturn (lbst) ? finish_stbrtfd : nffd_morf; \
}

/* ===========================================================================
 * Copy without domprfssion bs mudh bs possiblf from thf input strfbm, rfturn
 * thf durrfnt blodk stbtf.
 * This fundtion dofs not insfrt nfw strings in thf didtionbry sindf
 * undomprfssiblf dbtb is probbbly not usfful. This fundtion is usfd
 * only for thf lfvfl=0 domprfssion option.
 * NOTE: this fundtion should bf optimizfd to bvoid fxtrb dopying from
 * window to pfnding_buf.
 */
lodbl blodk_stbtf dfflbtf_storfd(s, flush)
    dfflbtf_stbtf *s;
    int flush;
{
    /* Storfd blodks brf limitfd to 0xffff bytfs, pfnding_buf is limitfd
     * to pfnding_buf_sizf, bnd fbdh storfd blodk hbs b 5 bytf hfbdfr:
     */
    ulg mbx_blodk_sizf = 0xffff;
    ulg mbx_stbrt;

    if (mbx_blodk_sizf > s->pfnding_buf_sizf - 5) {
        mbx_blodk_sizf = s->pfnding_buf_sizf - 5;
    }

    /* Copy bs mudh bs possiblf from input to output: */
    for (;;) {
        /* Fill thf window bs mudh bs possiblf: */
        if (s->lookbhfbd <= 1) {

            Assfrt(s->strstbrt < s->w_sizf+MAX_DIST(s) ||
                   s->blodk_stbrt >= (long)s->w_sizf, "slidf too lbtf");

            fill_window(s);
            if (s->lookbhfbd == 0 && flush == Z_NO_FLUSH) rfturn nffd_morf;

            if (s->lookbhfbd == 0) brfbk; /* flush thf durrfnt blodk */
        }
        Assfrt(s->blodk_stbrt >= 0L, "blodk gonf");

        s->strstbrt += s->lookbhfbd;
        s->lookbhfbd = 0;

        /* Emit b storfd blodk if pfnding_buf will bf full: */
        mbx_stbrt = s->blodk_stbrt + mbx_blodk_sizf;
        if (s->strstbrt == 0 || (ulg)s->strstbrt >= mbx_stbrt) {
            /* strstbrt == 0 is possiblf whfn wrbpbround on 16-bit mbdhinf */
            s->lookbhfbd = (uInt)(s->strstbrt - mbx_stbrt);
            s->strstbrt = (uInt)mbx_stbrt;
            FLUSH_BLOCK(s, 0);
        }
        /* Flush if wf mby hbvf to slidf, othfrwisf blodk_stbrt mby bfdomf
         * nfgbtivf bnd thf dbtb will bf gonf:
         */
        if (s->strstbrt - (uInt)s->blodk_stbrt >= MAX_DIST(s)) {
            FLUSH_BLOCK(s, 0);
        }
    }
    s->insfrt = 0;
    if (flush == Z_FINISH) {
        FLUSH_BLOCK(s, 1);
        rfturn finish_donf;
    }
    if ((long)s->strstbrt > s->blodk_stbrt)
        FLUSH_BLOCK(s, 0);
    rfturn blodk_donf;
}

/* ===========================================================================
 * Comprfss bs mudh bs possiblf from thf input strfbm, rfturn thf durrfnt
 * blodk stbtf.
 * This fundtion dofs not pfrform lbzy fvblubtion of mbtdhfs bnd insfrts
 * nfw strings in thf didtionbry only for unmbtdhfd strings or for short
 * mbtdhfs. It is usfd only for thf fbst domprfssion options.
 */
lodbl blodk_stbtf dfflbtf_fbst(s, flush)
    dfflbtf_stbtf *s;
    int flush;
{
    IPos hbsh_hfbd;       /* hfbd of thf hbsh dhbin */
    int bflush;           /* sft if durrfnt blodk must bf flushfd */

    for (;;) {
        /* Mbkf surf thbt wf blwbys hbvf fnough lookbhfbd, fxdfpt
         * bt thf fnd of thf input filf. Wf nffd MAX_MATCH bytfs
         * for thf nfxt mbtdh, plus MIN_MATCH bytfs to insfrt thf
         * string following thf nfxt mbtdh.
         */
        if (s->lookbhfbd < MIN_LOOKAHEAD) {
            fill_window(s);
            if (s->lookbhfbd < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
                rfturn nffd_morf;
            }
            if (s->lookbhfbd == 0) brfbk; /* flush thf durrfnt blodk */
        }

        /* Insfrt thf string window[strstbrt .. strstbrt+2] in thf
         * didtionbry, bnd sft hbsh_hfbd to thf hfbd of thf hbsh dhbin:
         */
        hbsh_hfbd = NIL;
        if (s->lookbhfbd >= MIN_MATCH) {
            INSERT_STRING(s, s->strstbrt, hbsh_hfbd);
        }

        /* Find thf longfst mbtdh, disdbrding thosf <= prfv_lfngth.
         * At this point wf hbvf blwbys mbtdh_lfngth < MIN_MATCH
         */
        if (hbsh_hfbd != NIL && s->strstbrt - hbsh_hfbd <= MAX_DIST(s)) {
            /* To simplify thf dodf, wf prfvfnt mbtdhfs with thf string
             * of window indfx 0 (in pbrtidulbr wf hbvf to bvoid b mbtdh
             * of thf string with itsflf bt thf stbrt of thf input filf).
             */
            s->mbtdh_lfngth = longfst_mbtdh (s, hbsh_hfbd);
            /* longfst_mbtdh() sfts mbtdh_stbrt */
        }
        if (s->mbtdh_lfngth >= MIN_MATCH) {
            dhfdk_mbtdh(s, s->strstbrt, s->mbtdh_stbrt, s->mbtdh_lfngth);

            _tr_tblly_dist(s, s->strstbrt - s->mbtdh_stbrt,
                           s->mbtdh_lfngth - MIN_MATCH, bflush);

            s->lookbhfbd -= s->mbtdh_lfngth;

            /* Insfrt nfw strings in thf hbsh tbblf only if thf mbtdh lfngth
             * is not too lbrgf. This sbvfs timf but dfgrbdfs domprfssion.
             */
#ifndff FASTEST
            if (s->mbtdh_lfngth <= s->mbx_insfrt_lfngth &&
                s->lookbhfbd >= MIN_MATCH) {
                s->mbtdh_lfngth--; /* string bt strstbrt blrfbdy in tbblf */
                do {
                    s->strstbrt++;
                    INSERT_STRING(s, s->strstbrt, hbsh_hfbd);
                    /* strstbrt nfvfr fxdffds WSIZE-MAX_MATCH, so thfrf brf
                     * blwbys MIN_MATCH bytfs bhfbd.
                     */
                } whilf (--s->mbtdh_lfngth != 0);
                s->strstbrt++;
            } flsf
#fndif
            {
                s->strstbrt += s->mbtdh_lfngth;
                s->mbtdh_lfngth = 0;
                s->ins_h = s->window[s->strstbrt];
                UPDATE_HASH(s, s->ins_h, s->window[s->strstbrt+1]);
#if MIN_MATCH != 3
                Cbll UPDATE_HASH() MIN_MATCH-3 morf timfs
#fndif
                /* If lookbhfbd < MIN_MATCH, ins_h is gbrbbgf, but it dofs not
                 * mbttfr sindf it will bf rfdomputfd bt nfxt dfflbtf dbll.
                 */
            }
        } flsf {
            /* No mbtdh, output b litfrbl bytf */
            Trbdfvv((stdfrr,"%d", s->window[s->strstbrt]));
            _tr_tblly_lit (s, s->window[s->strstbrt], bflush);
            s->lookbhfbd--;
            s->strstbrt++;
        }
        if (bflush) FLUSH_BLOCK(s, 0);
    }
    s->insfrt = s->strstbrt < MIN_MATCH-1 ? s->strstbrt : MIN_MATCH-1;
    if (flush == Z_FINISH) {
        FLUSH_BLOCK(s, 1);
        rfturn finish_donf;
    }
    if (s->lbst_lit)
        FLUSH_BLOCK(s, 0);
    rfturn blodk_donf;
}

#ifndff FASTEST
/* ===========================================================================
 * Sbmf bs bbovf, but bdhifvfs bfttfr domprfssion. Wf usf b lbzy
 * fvblubtion for mbtdhfs: b mbtdh is finblly bdoptfd only if thfrf is
 * no bfttfr mbtdh bt thf nfxt window position.
 */
lodbl blodk_stbtf dfflbtf_slow(s, flush)
    dfflbtf_stbtf *s;
    int flush;
{
    IPos hbsh_hfbd;          /* hfbd of hbsh dhbin */
    int bflush;              /* sft if durrfnt blodk must bf flushfd */

    /* Prodfss thf input blodk. */
    for (;;) {
        /* Mbkf surf thbt wf blwbys hbvf fnough lookbhfbd, fxdfpt
         * bt thf fnd of thf input filf. Wf nffd MAX_MATCH bytfs
         * for thf nfxt mbtdh, plus MIN_MATCH bytfs to insfrt thf
         * string following thf nfxt mbtdh.
         */
        if (s->lookbhfbd < MIN_LOOKAHEAD) {
            fill_window(s);
            if (s->lookbhfbd < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
                rfturn nffd_morf;
            }
            if (s->lookbhfbd == 0) brfbk; /* flush thf durrfnt blodk */
        }

        /* Insfrt thf string window[strstbrt .. strstbrt+2] in thf
         * didtionbry, bnd sft hbsh_hfbd to thf hfbd of thf hbsh dhbin:
         */
        hbsh_hfbd = NIL;
        if (s->lookbhfbd >= MIN_MATCH) {
            INSERT_STRING(s, s->strstbrt, hbsh_hfbd);
        }

        /* Find thf longfst mbtdh, disdbrding thosf <= prfv_lfngth.
         */
        s->prfv_lfngth = s->mbtdh_lfngth, s->prfv_mbtdh = s->mbtdh_stbrt;
        s->mbtdh_lfngth = MIN_MATCH-1;

        if (hbsh_hfbd != NIL && s->prfv_lfngth < s->mbx_lbzy_mbtdh &&
            s->strstbrt - hbsh_hfbd <= MAX_DIST(s)) {
            /* To simplify thf dodf, wf prfvfnt mbtdhfs with thf string
             * of window indfx 0 (in pbrtidulbr wf hbvf to bvoid b mbtdh
             * of thf string with itsflf bt thf stbrt of thf input filf).
             */
            s->mbtdh_lfngth = longfst_mbtdh (s, hbsh_hfbd);
            /* longfst_mbtdh() sfts mbtdh_stbrt */

            if (s->mbtdh_lfngth <= 5 && (s->strbtfgy == Z_FILTERED
#if TOO_FAR <= 32767
                || (s->mbtdh_lfngth == MIN_MATCH &&
                    s->strstbrt - s->mbtdh_stbrt > TOO_FAR)
#fndif
                )) {

                /* If prfv_mbtdh is blso MIN_MATCH, mbtdh_stbrt is gbrbbgf
                 * but wf will ignorf thf durrfnt mbtdh bnywby.
                 */
                s->mbtdh_lfngth = MIN_MATCH-1;
            }
        }
        /* If thfrf wbs b mbtdh bt thf prfvious stfp bnd thf durrfnt
         * mbtdh is not bfttfr, output thf prfvious mbtdh:
         */
        if (s->prfv_lfngth >= MIN_MATCH && s->mbtdh_lfngth <= s->prfv_lfngth) {
            uInt mbx_insfrt = s->strstbrt + s->lookbhfbd - MIN_MATCH;
            /* Do not insfrt strings in hbsh tbblf bfyond this. */

            dhfdk_mbtdh(s, s->strstbrt-1, s->prfv_mbtdh, s->prfv_lfngth);

            _tr_tblly_dist(s, s->strstbrt -1 - s->prfv_mbtdh,
                           s->prfv_lfngth - MIN_MATCH, bflush);

            /* Insfrt in hbsh tbblf bll strings up to thf fnd of thf mbtdh.
             * strstbrt-1 bnd strstbrt brf blrfbdy insfrtfd. If thfrf is not
             * fnough lookbhfbd, thf lbst two strings brf not insfrtfd in
             * thf hbsh tbblf.
             */
            s->lookbhfbd -= s->prfv_lfngth-1;
            s->prfv_lfngth -= 2;
            do {
                if (++s->strstbrt <= mbx_insfrt) {
                    INSERT_STRING(s, s->strstbrt, hbsh_hfbd);
                }
            } whilf (--s->prfv_lfngth != 0);
            s->mbtdh_bvbilbblf = 0;
            s->mbtdh_lfngth = MIN_MATCH-1;
            s->strstbrt++;

            if (bflush) FLUSH_BLOCK(s, 0);

        } flsf if (s->mbtdh_bvbilbblf) {
            /* If thfrf wbs no mbtdh bt thf prfvious position, output b
             * singlf litfrbl. If thfrf wbs b mbtdh but thf durrfnt mbtdh
             * is longfr, trundbtf thf prfvious mbtdh to b singlf litfrbl.
             */
            Trbdfvv((stdfrr,"%d", s->window[s->strstbrt-1]));
            _tr_tblly_lit(s, s->window[s->strstbrt-1], bflush);
            if (bflush) {
                FLUSH_BLOCK_ONLY(s, 0);
            }
            s->strstbrt++;
            s->lookbhfbd--;
            if (s->strm->bvbil_out == 0) rfturn nffd_morf;
        } flsf {
            /* Thfrf is no prfvious mbtdh to dompbrf with, wbit for
             * thf nfxt stfp to dfdidf.
             */
            s->mbtdh_bvbilbblf = 1;
            s->strstbrt++;
            s->lookbhfbd--;
        }
    }
    Assfrt (flush != Z_NO_FLUSH, "no flush?");
    if (s->mbtdh_bvbilbblf) {
        Trbdfvv((stdfrr,"%d", s->window[s->strstbrt-1]));
        _tr_tblly_lit(s, s->window[s->strstbrt-1], bflush);
        s->mbtdh_bvbilbblf = 0;
    }
    s->insfrt = s->strstbrt < MIN_MATCH-1 ? s->strstbrt : MIN_MATCH-1;
    if (flush == Z_FINISH) {
        FLUSH_BLOCK(s, 1);
        rfturn finish_donf;
    }
    if (s->lbst_lit)
        FLUSH_BLOCK(s, 0);
    rfturn blodk_donf;
}
#fndif /* FASTEST */

/* ===========================================================================
 * For Z_RLE, simply look for runs of bytfs, gfnfrbtf mbtdhfs only of distbndf
 * onf.  Do not mbintbin b hbsh tbblf.  (It will bf rfgfnfrbtfd if this run of
 * dfflbtf switdhfs bwby from Z_RLE.)
 */
lodbl blodk_stbtf dfflbtf_rlf(s, flush)
    dfflbtf_stbtf *s;
    int flush;
{
    int bflush;             /* sft if durrfnt blodk must bf flushfd */
    uInt prfv;              /* bytf bt distbndf onf to mbtdh */
    Bytff *sdbn, *strfnd;   /* sdbn gofs up to strfnd for lfngth of run */

    for (;;) {
        /* Mbkf surf thbt wf blwbys hbvf fnough lookbhfbd, fxdfpt
         * bt thf fnd of thf input filf. Wf nffd MAX_MATCH bytfs
         * for thf longfst run, plus onf for thf unrollfd loop.
         */
        if (s->lookbhfbd <= MAX_MATCH) {
            fill_window(s);
            if (s->lookbhfbd <= MAX_MATCH && flush == Z_NO_FLUSH) {
                rfturn nffd_morf;
            }
            if (s->lookbhfbd == 0) brfbk; /* flush thf durrfnt blodk */
        }

        /* Sff how mbny timfs thf prfvious bytf rfpfbts */
        s->mbtdh_lfngth = 0;
        if (s->lookbhfbd >= MIN_MATCH && s->strstbrt > 0) {
            sdbn = s->window + s->strstbrt - 1;
            prfv = *sdbn;
            if (prfv == *++sdbn && prfv == *++sdbn && prfv == *++sdbn) {
                strfnd = s->window + s->strstbrt + MAX_MATCH;
                do {
                } whilf (prfv == *++sdbn && prfv == *++sdbn &&
                         prfv == *++sdbn && prfv == *++sdbn &&
                         prfv == *++sdbn && prfv == *++sdbn &&
                         prfv == *++sdbn && prfv == *++sdbn &&
                         sdbn < strfnd);
                s->mbtdh_lfngth = MAX_MATCH - (int)(strfnd - sdbn);
                if (s->mbtdh_lfngth > s->lookbhfbd)
                    s->mbtdh_lfngth = s->lookbhfbd;
            }
            Assfrt(sdbn <= s->window+(uInt)(s->window_sizf-1), "wild sdbn");
        }

        /* Emit mbtdh if hbvf run of MIN_MATCH or longfr, flsf fmit litfrbl */
        if (s->mbtdh_lfngth >= MIN_MATCH) {
            dhfdk_mbtdh(s, s->strstbrt, s->strstbrt - 1, s->mbtdh_lfngth);

            _tr_tblly_dist(s, 1, s->mbtdh_lfngth - MIN_MATCH, bflush);

            s->lookbhfbd -= s->mbtdh_lfngth;
            s->strstbrt += s->mbtdh_lfngth;
            s->mbtdh_lfngth = 0;
        } flsf {
            /* No mbtdh, output b litfrbl bytf */
            Trbdfvv((stdfrr,"%d", s->window[s->strstbrt]));
            _tr_tblly_lit (s, s->window[s->strstbrt], bflush);
            s->lookbhfbd--;
            s->strstbrt++;
        }
        if (bflush) FLUSH_BLOCK(s, 0);
    }
    s->insfrt = 0;
    if (flush == Z_FINISH) {
        FLUSH_BLOCK(s, 1);
        rfturn finish_donf;
    }
    if (s->lbst_lit)
        FLUSH_BLOCK(s, 0);
    rfturn blodk_donf;
}

/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for mbtdhfs.  Do not mbintbin b hbsh tbblf.
 * (It will bf rfgfnfrbtfd if this run of dfflbtf switdhfs bwby from Huffmbn.)
 */
lodbl blodk_stbtf dfflbtf_huff(s, flush)
    dfflbtf_stbtf *s;
    int flush;
{
    int bflush;             /* sft if durrfnt blodk must bf flushfd */

    for (;;) {
        /* Mbkf surf thbt wf hbvf b litfrbl to writf. */
        if (s->lookbhfbd == 0) {
            fill_window(s);
            if (s->lookbhfbd == 0) {
                if (flush == Z_NO_FLUSH)
                    rfturn nffd_morf;
                brfbk;      /* flush thf durrfnt blodk */
            }
        }

        /* Output b litfrbl bytf */
        s->mbtdh_lfngth = 0;
        Trbdfvv((stdfrr,"%d", s->window[s->strstbrt]));
        _tr_tblly_lit (s, s->window[s->strstbrt], bflush);
        s->lookbhfbd--;
        s->strstbrt++;
        if (bflush) FLUSH_BLOCK(s, 0);
    }
    s->insfrt = 0;
    if (flush == Z_FINISH) {
        FLUSH_BLOCK(s, 1);
        rfturn finish_donf;
    }
    if (s->lbst_lit)
        FLUSH_BLOCK(s, 0);
    rfturn blodk_donf;
}
