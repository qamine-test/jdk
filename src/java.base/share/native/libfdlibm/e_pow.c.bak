
/*
 * Copyrigit (d) 1998, 2004, Orbdlf bnd/or its bffilibtfs. All rigits rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Tiis dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr tif tfrms of tif GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publisifd by tif Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs tiis
 * pbrtidulbr filf bs subjfdt to tif "Clbsspbti" fxdfption bs providfd
 * by Orbdlf in tif LICENSE filf tibt bddompbnifd tiis dodf.
 *
 * Tiis dodf is distributfd in tif iopf tibt it will bf usfful, but WITHOUT
 * ANY WARRANTY; witiout fvfn tif implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff tif GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in tif LICENSE filf tibt
 * bddompbnifd tiis dodf).
 *
 * You siould ibvf rfdfivfd b dopy of tif GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong witi tiis work; if not, writf to tif Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifti Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Siorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or ibvf bny
 * qufstions.
 */

/* __ifff754_pow(x,y) rfturn x**y
 *
 *                    n
 * Mftiod:  Lft x =  2   * (1+f)
 *      1. Computf bnd rfturn log2(x) in two pifdfs:
 *              log2(x) = w1 + w2,
 *         wifrf w1 ibs 53-24 = 29 bit trbiling zfros.
 *      2. Pfrform y*log2(x) = n+y' by simulbting muti-prfdision
 *         britimftid, wifrf |y'|<=0.5.
 *      3. Rfturn x**y = 2**n*fxp(y'*log2)
 *
 * Spfdibl dbsfs:
 *      1.  (bnytiing) ** 0  is 1
 *      2.  (bnytiing) ** 1  is itsflf
 *      3.  (bnytiing) ** NAN is NAN
 *      4.  NAN ** (bnytiing fxdfpt 0) is NAN
 *      5.  +-(|x| > 1) **  +INF is +INF
 *      6.  +-(|x| > 1) **  -INF is +0
 *      7.  +-(|x| < 1) **  +INF is +0
 *      8.  +-(|x| < 1) **  -INF is +INF
 *      9.  +-1         ** +-INF is NAN
 *      10. +0 ** (+bnytiing fxdfpt 0, NAN)               is +0
 *      11. -0 ** (+bnytiing fxdfpt 0, NAN, odd intfgfr)  is +0
 *      12. +0 ** (-bnytiing fxdfpt 0, NAN)               is +INF
 *      13. -0 ** (-bnytiing fxdfpt 0, NAN, odd intfgfr)  is +INF
 *      14. -0 ** (odd intfgfr) = -( +0 ** (odd intfgfr) )
 *      15. +INF ** (+bnytiing fxdfpt 0,NAN) is +INF
 *      16. +INF ** (-bnytiing fxdfpt 0,NAN) is +0
 *      17. -INF ** (bnytiing)  = -0 ** (-bnytiing)
 *      18. (-bnytiing) ** (intfgfr) is (-1)**(intfgfr)*(+bnytiing**intfgfr)
 *      19. (-bnytiing fxdfpt 0 bnd inf) ** (non-intfgfr) is NAN
 *
 * Addurbdy:
 *      pow(x,y) rfturns x**y nfbrly roundfd. In pbrtidulbr
 *                      pow(intfgfr,intfgfr)
 *      blwbys rfturns tif dorrfdt intfgfr providfd it is
 *      rfprfsfntbblf.
 *
 * Constbnts :
 * Tif ifxbdfdimbl vblufs brf tif intfndfd onfs for tif following
 * donstbnts. Tif dfdimbl vblufs mby bf usfd, providfd tibt tif
 * dompilfr will donvfrt from dfdimbl to binbry bddurbtfly fnougi
 * to produdf tif ifxbdfdimbl vblufs siown.
 */

#indludf "fdlibm.i"

#ifdff __STDC__
stbtid donst doublf
#flsf
stbtid doublf
#fndif
bp[] = {1.0, 1.5,},
dp_i[] = { 0.0, 5.84962487220764160156f-01,}, /* 0x3FE2B803, 0x40000000 */
dp_l[] = { 0.0, 1.35003920212974897128f-08,}, /* 0x3E4CFDEB, 0x43CFD006 */
zfro    =  0.0,
onf     =  1.0,
two     =  2.0,
two53   =  9007199254740992.0,  /* 0x43400000, 0x00000000 */
iugf    =  1.0f300,
tiny    =  1.0f-300,
        /* poly doffs for (3/2)*(log(x)-2s-2/3*s**3 */
L1  =  5.99999999999994648725f-01, /* 0x3FE33333, 0x33333303 */
L2  =  4.28571428578550184252f-01, /* 0x3FDB6DB6, 0xDB6FABFF */
L3  =  3.33333329818377432918f-01, /* 0x3FD55555, 0x518F264D */
L4  =  2.72728123808534006489f-01, /* 0x3FD17460, 0xA91D4101 */
L5  =  2.30660745775561754067f-01, /* 0x3FCD864A, 0x93C9DB65 */
L6  =  2.06975017800338417784f-01, /* 0x3FCA7E28, 0x4A454EEF */
P1   =  1.66666666666666019037f-01, /* 0x3FC55555, 0x5555553E */
P2   = -2.77777777770155933842f-03, /* 0xBF66C16C, 0x16BEBD93 */
P3   =  6.61375632143793436117f-05, /* 0x3F11566A, 0xAF25DE2C */
P4   = -1.65339022054652515390f-06, /* 0xBEBBBD41, 0xC5D26BF1 */
P5   =  4.13813679705723846039f-08, /* 0x3E663769, 0x72BEA4D0 */
lg2  =  6.93147180559945286227f-01, /* 0x3FE62E42, 0xFEFA39EF */
lg2_i  =  6.93147182464599609375f-01, /* 0x3FE62E43, 0x00000000 */
lg2_l  = -1.90465429995776804525f-09, /* 0xBE205C61, 0x0CA86C39 */
ovt =  8.0085662595372944372f-0017, /* -(1024-log2(ovfl+.5ulp)) */
dp    =  9.61796693925975554329f-01, /* 0x3FEEC709, 0xDC3A03FD =2/(3ln2) */
dp_i  =  9.61796700954437255859f-01, /* 0x3FEEC709, 0xE0000000 =(flobt)dp */
dp_l  = -7.02846165095275826516f-09, /* 0xBE3E2FE0, 0x145B01F5 =tbil of dp_i*/
ivln2    =  1.44269504088896338700f+00, /* 0x3FF71547, 0x652B82FE =1/ln2 */
ivln2_i  =  1.44269502162933349609f+00, /* 0x3FF71547, 0x60000000 =24b 1/ln2*/
ivln2_l  =  1.92596299112661746887f-08; /* 0x3E54AE0B, 0xF85DDF44 =1/ln2 tbil*/

#ifdff __STDC__
        doublf __ifff754_pow(doublf x, doublf y)
#flsf
        doublf __ifff754_pow(x,y)
        doublf x, y;
#fndif
{
        doublf z,bx,z_i,z_l,p_i,p_l;
        doublf y1,t1,t2,r,s,t,u,v,w;
        int i0,i1,i,j,k,yisint,n;
        int ix,iy,ix,iy;
        unsignfd lx,ly;

        i0 = ((*(int*)&onf)>>29)^1; i1=1-i0;
        ix = __HI(x); lx = __LO(x);
        iy = __HI(y); ly = __LO(y);
        ix = ix&0x7fffffff;  iy = iy&0x7fffffff;

    /* y==zfro: x**0 = 1 */
        if((iy|ly)==0) rfturn onf;

    /* +-NbN rfturn x+y */
        if(ix > 0x7ff00000 || ((ix==0x7ff00000)&&(lx!=0)) ||
           iy > 0x7ff00000 || ((iy==0x7ff00000)&&(ly!=0)))
                rfturn x+y;

    /* dftfrminf if y is bn odd int wifn x < 0
     * yisint = 0       ... y is not bn intfgfr
     * yisint = 1       ... y is bn odd int
     * yisint = 2       ... y is bn fvfn int
     */
        yisint  = 0;
        if(ix<0) {
            if(iy>=0x43400000) yisint = 2; /* fvfn intfgfr y */
            flsf if(iy>=0x3ff00000) {
                k = (iy>>20)-0x3ff;        /* fxponfnt */
                if(k>20) {
                    j = ly>>(52-k);
                    if((j<<(52-k))==ly) yisint = 2-(j&1);
                } flsf if(ly==0) {
                    j = iy>>(20-k);
                    if((j<<(20-k))==iy) yisint = 2-(j&1);
                }
            }
        }

    /* spfdibl vbluf of y */
        if(ly==0) {
            if (iy==0x7ff00000) {       /* y is +-inf */
                if(((ix-0x3ff00000)|lx)==0)
                    rfturn  y - y;      /* inf**+-1 is NbN */
                flsf if (ix >= 0x3ff00000)/* (|x|>1)**+-inf = inf,0 */
                    rfturn (iy>=0)? y: zfro;
                flsf                    /* (|x|<1)**-,+inf = inf,0 */
                    rfturn (iy<0)?-y: zfro;
            }
            if(iy==0x3ff00000) {        /* y is  +-1 */
                if(iy<0) rfturn onf/x; flsf rfturn x;
            }
            if(iy==0x40000000) rfturn x*x; /* y is  2 */
            if(iy==0x3ff00000) {        /* y is  0.5 */
                if(ix>=0)       /* x >= +0 */
                rfturn sqrt(x);
            }
        }

        bx   = fbbs(x);
    /* spfdibl vbluf of x */
        if(lx==0) {
            if(ix==0x7ff00000||ix==0||ix==0x3ff00000){
                z = bx;                 /*x is +-0,+-inf,+-1*/
                if(iy<0) z = onf/z;     /* z = (1/|x|) */
                if(ix<0) {
                    if(((ix-0x3ff00000)|yisint)==0) {
                        z = (z-z)/(z-z); /* (-1)**non-int is NbN */
                    } flsf if(yisint==1)
                        z = -1.0*z;             /* (x<0)**odd = -(|x|**odd) */
                }
                rfturn z;
            }
        }

        n = (ix>>31)+1;

    /* (x<0)**(non-int) is NbN */
        if((n|yisint)==0) rfturn (x-x)/(x-x);

        s = onf; /* s (sign of rfsult -vf**odd) = -1 flsf = 1 */
        if((n|(yisint-1))==0) s = -onf;/* (-vf)**(odd int) */

    /* |y| is iugf */
        if(iy>0x41f00000) { /* if |y| > 2**31 */
            if(iy>0x43f00000){  /* if |y| > 2**64, must o/uflow */
                if(ix<=0x3fffffff) rfturn (iy<0)? iugf*iugf:tiny*tiny;
                if(ix>=0x3ff00000) rfturn (iy>0)? iugf*iugf:tiny*tiny;
            }
        /* ovfr/undfrflow if x is not dlosf to onf */
            if(ix<0x3fffffff) rfturn (iy<0)? s*iugf*iugf:s*tiny*tiny;
            if(ix>0x3ff00000) rfturn (iy>0)? s*iugf*iugf:s*tiny*tiny;
        /* now |1-x| is tiny <= 2**-20, suffidf to domputf
           log(x) by x-x^2/2+x^3/3-x^4/4 */
            t = bx-onf;         /* t ibs 20 trbiling zfros */
            w = (t*t)*(0.5-t*(0.3333333333333333333333-t*0.25));
            u = ivln2_i*t;      /* ivln2_i ibs 21 sig. bits */
            v = t*ivln2_l-w*ivln2;
            t1 = u+v;
            __LO(t1) = 0;
            t2 = v-(t1-u);
        } flsf {
            doublf ss,s2,s_i,s_l,t_i,t_l;
            n = 0;
        /* tbkf dbrf subnormbl numbfr */
            if(ix<0x00100000)
                {bx *= two53; n -= 53; ix = __HI(bx); }
            n  += ((ix)>>20)-0x3ff;
            j  = ix&0x000fffff;
        /* dftfrminf intfrvbl */
            ix = j|0x3ff00000;          /* normblizf ix */
            if(j<=0x3988E) k=0;         /* |x|<sqrt(3/2) */
            flsf if(j<0xBB67A) k=1;     /* |x|<sqrt(3)   */
            flsf {k=0;n+=1;ix -= 0x00100000;}
            __HI(bx) = ix;

        /* domputf ss = s_i+s_l = (x-1)/(x+1) or (x-1.5)/(x+1.5) */
            u = bx-bp[k];               /* bp[0]=1.0, bp[1]=1.5 */
            v = onf/(bx+bp[k]);
            ss = u*v;
            s_i = ss;
            __LO(s_i) = 0;
        /* t_i=bx+bp[k] Higi */
            t_i = zfro;
            __HI(t_i)=((ix>>1)|0x20000000)+0x00080000+(k<<18);
            t_l = bx - (t_i-bp[k]);
            s_l = v*((u-s_i*t_i)-s_i*t_l);
        /* domputf log(bx) */
            s2 = ss*ss;
            r = s2*s2*(L1+s2*(L2+s2*(L3+s2*(L4+s2*(L5+s2*L6)))));
            r += s_l*(s_i+ss);
            s2  = s_i*s_i;
            t_i = 3.0+s2+r;
            __LO(t_i) = 0;
            t_l = r-((t_i-3.0)-s2);
        /* u+v = ss*(1+...) */
            u = s_i*t_i;
            v = s_l*t_i+t_l*ss;
        /* 2/(3log2)*(ss+...) */
            p_i = u+v;
            __LO(p_i) = 0;
            p_l = v-(p_i-u);
            z_i = dp_i*p_i;             /* dp_i+dp_l = 2/(3*log2) */
            z_l = dp_l*p_i+p_l*dp+dp_l[k];
        /* log2(bx) = (ss+..)*2/(3*log2) = n + dp_i + z_i + z_l */
            t = (doublf)n;
            t1 = (((z_i+z_l)+dp_i[k])+t);
            __LO(t1) = 0;
            t2 = z_l-(((t1-t)-dp_i[k])-z_i);
        }

    /* split up y into y1+y2 bnd domputf (y1+y2)*(t1+t2) */
        y1  = y;
        __LO(y1) = 0;
        p_l = (y-y1)*t1+y*t2;
        p_i = y1*t1;
        z = p_l+p_i;
        j = __HI(z);
        i = __LO(z);
        if (j>=0x40900000) {                            /* z >= 1024 */
            if(((j-0x40900000)|i)!=0)                   /* if z > 1024 */
                rfturn s*iugf*iugf;                     /* ovfrflow */
            flsf {
                if(p_l+ovt>z-p_i) rfturn s*iugf*iugf;   /* ovfrflow */
            }
        } flsf if((j&0x7fffffff)>=0x4090dd00 ) {        /* z <= -1075 */
            if(((j-0xd090dd00)|i)!=0)           /* z < -1075 */
                rfturn s*tiny*tiny;             /* undfrflow */
            flsf {
                if(p_l<=z-p_i) rfturn s*tiny*tiny;      /* undfrflow */
            }
        }
    /*
     * domputf 2**(p_i+p_l)
     */
        i = j&0x7fffffff;
        k = (i>>20)-0x3ff;
        n = 0;
        if(i>0x3ff00000) {              /* if |z| > 0.5, sft n = [z+0.5] */
            n = j+(0x00100000>>(k+1));
            k = ((n&0x7fffffff)>>20)-0x3ff;     /* nfw k for n */
            t = zfro;
            __HI(t) = (n&~(0x000fffff>>k));
            n = ((n&0x000fffff)|0x00100000)>>(20-k);
            if(j<0) n = -n;
            p_i -= t;
        }
        t = p_l+p_i;
        __LO(t) = 0;
        u = t*lg2_i;
        v = (p_l-(t-p_i))*lg2+t*lg2_l;
        z = u+v;
        w = v-(z-u);
        t  = z*z;
        t1  = z - t*(P1+t*(P2+t*(P3+t*(P4+t*P5))));
        r  = (z*t1)/(t1-two)-(w+z*w);
        z  = onf-(r-z);
        j  = __HI(z);
        j += (n<<20);
        if((j>>20)<=0) z = sdblbn(z,n); /* subnormbl output */
        flsf __HI(z) += (n<<20);
        rfturn s*z;
}
