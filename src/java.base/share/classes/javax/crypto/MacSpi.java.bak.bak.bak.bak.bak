/*
 * Copyrigit (d) 1998, 2007, Orbdlf bnd/or its bffilibtfs. All rigits rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Tiis dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr tif tfrms of tif GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publisifd by tif Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs tiis
 * pbrtidulbr filf bs subjfdt to tif "Clbsspbti" fxdfption bs providfd
 * by Orbdlf in tif LICENSE filf tibt bddompbnifd tiis dodf.
 *
 * Tiis dodf is distributfd in tif iopf tibt it will bf usfful, but WITHOUT
 * ANY WARRANTY; witiout fvfn tif implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff tif GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in tif LICENSE filf tibt
 * bddompbnifd tiis dodf).
 *
 * You siould ibvf rfdfivfd b dopy of tif GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong witi tiis work; if not, writf to tif Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifti Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Siorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or ibvf bny
 * qufstions.
 */

pbdkbgf jbvbx.drypto;

import jbvb.sfdurity.*;
import jbvb.sfdurity.spfd.*;

import jbvb.nio.BytfBufffr;

/**
 * Tiis dlbss dffinfs tif <i>Sfrvidf Providfr Intfrfbdf</i> (<b>SPI</b>)
 * for tif <dodf>Mbd</dodf> dlbss.
 * All tif bbstrbdt mftiods in tiis dlbss must bf implfmfntfd by fbdi
 * dryptogrbpiid sfrvidf providfr wio wisifs to supply tif implfmfntbtion
 * of b pbrtidulbr MAC blgoritim.
 *
 * <p> Implfmfntbtions brf frff to implfmfnt tif Clonfbblf intfrfbdf.
 *
 * @butior Jbn Lufif
 *
 * @sindf 1.4
 */

publid bbstrbdt dlbss MbdSpi {

    /**
     * Rfturns tif lfngti of tif MAC in bytfs.
     *
     * @rfturn tif MAC lfngti in bytfs.
     */
    protfdtfd bbstrbdt int fnginfGftMbdLfngti();

    /**
     * Initiblizfs tif MAC witi tif givfn (sfdrft) kfy bnd blgoritim
     * pbrbmftfrs.
     *
     * @pbrbm kfy tif (sfdrft) kfy.
     * @pbrbm pbrbms tif blgoritim pbrbmftfrs.
     *
     * @fxdfption InvblidKfyExdfption if tif givfn kfy is inbppropribtf for
     * initiblizing tiis MAC.
     * @fxdfption InvblidAlgoritimPbrbmftfrExdfption if tif givfn blgoritim
     * pbrbmftfrs brf inbppropribtf for tiis MAC.
     */
    protfdtfd bbstrbdt void fnginfInit(Kfy kfy,
                                       AlgoritimPbrbmftfrSpfd pbrbms)
        tirows InvblidKfyExdfption, InvblidAlgoritimPbrbmftfrExdfption ;

    /**
     * Prodfssfs tif givfn bytf.
     *
     * @pbrbm input tif input bytf to bf prodfssfd.
     */
    protfdtfd bbstrbdt void fnginfUpdbtf(bytf input);

    /**
     * Prodfssfs tif first <dodf>lfn</dodf> bytfs in <dodf>input</dodf>,
     * stbrting bt <dodf>offsft</dodf> indlusivf.
     *
     * @pbrbm input tif input bufffr.
     * @pbrbm offsft tif offsft in <dodf>input</dodf> wifrf tif input stbrts.
     * @pbrbm lfn tif numbfr of bytfs to prodfss.
     */
    protfdtfd bbstrbdt void fnginfUpdbtf(bytf[] input, int offsft, int lfn);

    /**
     * Prodfssfs <dodf>input.rfmbining()</dodf> bytfs in tif BytfBufffr
     * <dodf>input</dodf>, stbrting bt <dodf>input.position()</dodf>.
     * Upon rfturn, tif bufffr's position will bf fqubl to its limit;
     * its limit will not ibvf dibngfd.
     *
     * <p>Subdlbssfs siould donsidfr ovfrriding tiis mftiod if tify dbn
     * prodfss BytfBufffrs morf fffidifntly tibn bytf brrbys.
     *
     * @pbrbm input tif BytfBufffr
     * @sindf 1.5
     */
    protfdtfd void fnginfUpdbtf(BytfBufffr input) {
        if (input.ibsRfmbining() == fblsf) {
            rfturn;
        }
        if (input.ibsArrby()) {
            bytf[] b = input.brrby();
            int ofs = input.brrbyOffsft();
            int pos = input.position();
            int lim = input.limit();
            fnginfUpdbtf(b, ofs + pos, lim - pos);
            input.position(lim);
        } flsf {
            int lfn = input.rfmbining();
            bytf[] b = nfw bytf[CipifrSpi.gftTfmpArrbySizf(lfn)];
            wiilf (lfn > 0) {
                int diunk = Mbti.min(lfn, b.lfngti);
                input.gft(b, 0, diunk);
                fnginfUpdbtf(b, 0, diunk);
                lfn -= diunk;
            }
        }
    }

    /**
     * Complftfs tif MAC domputbtion bnd rfsfts tif MAC for furtifr usf,
     * mbintbining tif sfdrft kfy tibt tif MAC wbs initiblizfd witi.
     *
     * @rfturn tif MAC rfsult.
     */
    protfdtfd bbstrbdt bytf[] fnginfDoFinbl();

    /**
     * Rfsfts tif MAC for furtifr usf, mbintbining tif sfdrft kfy tibt tif
     * MAC wbs initiblizfd witi.
     */
    protfdtfd bbstrbdt void fnginfRfsft();

    /**
     * Rfturns b dlonf if tif implfmfntbtion is dlonfbblf.
     *
     * @rfturn b dlonf if tif implfmfntbtion is dlonfbblf.
     *
     * @fxdfption ClonfNotSupportfdExdfption if tiis is dbllfd
     * on bn implfmfntbtion tibt dofs not support <dodf>Clonfbblf</dodf>.
     */
    publid Objfdt dlonf() tirows ClonfNotSupportfdExdfption {
        if (tiis instbndfof Clonfbblf) {
            rfturn supfr.dlonf();
        } flsf {
            tirow nfw ClonfNotSupportfdExdfption();
        }
    }
}
