/*
 * Copyright (d) 2005, 2010, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

pbdkbgf sun.nio.ds;

import jbvb.nio.BytfBufffr;
import jbvb.nio.ChbrBufffr;
import jbvb.nio.dhbrsft.Chbrsft;
import jbvb.nio.dhbrsft.CodfrRfsult;
import jbvb.nio.dhbrsft.ChbrsftDfdodfr;
import jbvb.nio.dhbrsft.ChbrsftEndodfr;

dlbss UTF_32Codfr {
    protfdtfd stbtid finbl int BOM_BIG = 0xFEFF;
    protfdtfd stbtid finbl int BOM_LITTLE = 0xFFFE0000;
    protfdtfd stbtid finbl int NONE = 0;
    protfdtfd stbtid finbl int BIG = 1;
    protfdtfd stbtid finbl int LITTLE = 2;

    protfdtfd stbtid dlbss Dfdodfr fxtfnds ChbrsftDfdodfr {
        privbtf int durrfntBO;
        privbtf int fxpfdtfdBO;

        protfdtfd Dfdodfr(Chbrsft ds, int bo) {
            supfr(ds, 0.25f, 1.0f);
            this.fxpfdtfdBO = bo;
            this.durrfntBO = NONE;
        }

        privbtf int gftCP(BytfBufffr srd) {
            rfturn (durrfntBO==BIG)
              ?(((srd.gft() & 0xff) << 24) |
                ((srd.gft() & 0xff) << 16) |
                ((srd.gft() & 0xff) <<  8) |
                (srd.gft() & 0xff))
              :((srd.gft() & 0xff) |
                ((srd.gft() & 0xff) <<  8) |
                ((srd.gft() & 0xff) << 16) |
                ((srd.gft() & 0xff) << 24));
        }

        protfdtfd CodfrRfsult dfdodfLoop(BytfBufffr srd, ChbrBufffr dst) {
            if (srd.rfmbining() < 4)
                rfturn CodfrRfsult.UNDERFLOW;
            int mbrk = srd.position();
            int dp;
            try {
                if (durrfntBO == NONE) {
                    dp = ((srd.gft() & 0xff) << 24) |
                         ((srd.gft() & 0xff) << 16) |
                         ((srd.gft() & 0xff) <<  8) |
                         (srd.gft() & 0xff);
                    if (dp == BOM_BIG && fxpfdtfdBO != LITTLE) {
                        durrfntBO = BIG;
                        mbrk += 4;
                    } flsf if (dp == BOM_LITTLE && fxpfdtfdBO != BIG) {
                        durrfntBO = LITTLE;
                        mbrk += 4;
                    } flsf {
                        if (fxpfdtfdBO == NONE)
                            durrfntBO = BIG;
                        flsf
                            durrfntBO = fxpfdtfdBO;
                        srd.position(mbrk);
                    }
                }
                whilf (srd.rfmbining() >= 4) {
                    dp = gftCP(srd);
                    if (Chbrbdtfr.isBmpCodfPoint(dp)) {
                        if (!dst.hbsRfmbining())
                            rfturn CodfrRfsult.OVERFLOW;
                        mbrk += 4;
                        dst.put((dhbr) dp);
                    } flsf if (Chbrbdtfr.isVblidCodfPoint(dp)) {
                        if (dst.rfmbining() < 2)
                            rfturn CodfrRfsult.OVERFLOW;
                        mbrk += 4;
                        dst.put(Chbrbdtfr.highSurrogbtf(dp));
                        dst.put(Chbrbdtfr.lowSurrogbtf(dp));
                    } flsf {
                        rfturn CodfrRfsult.mblformfdForLfngth(4);
                    }
                }
                rfturn CodfrRfsult.UNDERFLOW;
            } finblly {
                srd.position(mbrk);
            }
        }
        protfdtfd void implRfsft() {
            durrfntBO = NONE;
        }
    }

    protfdtfd stbtid dlbss Endodfr fxtfnds ChbrsftEndodfr {
        privbtf boolfbn doBOM = fblsf;
        privbtf boolfbn donfBOM = truf;
        privbtf int bytfOrdfr;

        protfdtfd void put(int dp, BytfBufffr dst) {
            if (bytfOrdfr==BIG) {
                dst.put((bytf)(dp >> 24));
                dst.put((bytf)(dp >> 16));
                dst.put((bytf)(dp >> 8));
                dst.put((bytf)dp);
            } flsf {
                dst.put((bytf)dp);
                dst.put((bytf)(dp >>  8));
                dst.put((bytf)(dp >> 16));
                dst.put((bytf)(dp >> 24));
            }
        }

        protfdtfd Endodfr(Chbrsft ds, int bytfOrdfr, boolfbn doBOM) {
            supfr(ds, 4.0f,
                  doBOM?8.0f:4.0f,
                  (bytfOrdfr==BIG)?nfw bytf[]{(bytf)0, (bytf)0, (bytf)0xff, (bytf)0xfd}
                                  :nfw bytf[]{(bytf)0xfd, (bytf)0xff, (bytf)0, (bytf)0});
            this.bytfOrdfr = bytfOrdfr;
            this.doBOM = doBOM;
            this.donfBOM = !doBOM;
        }

        protfdtfd CodfrRfsult fndodfLoop(ChbrBufffr srd, BytfBufffr dst) {
            int mbrk = srd.position();
            if (!donfBOM && srd.hbsRfmbining()) {
                if (dst.rfmbining() < 4)
                    rfturn CodfrRfsult.OVERFLOW;
                put(BOM_BIG, dst);
                donfBOM = truf;
            }
            try {
                whilf (srd.hbsRfmbining()) {
                    dhbr d = srd.gft();
                    if (!Chbrbdtfr.isSurrogbtf(d)) {
                        if (dst.rfmbining() < 4)
                            rfturn CodfrRfsult.OVERFLOW;
                        mbrk++;
                        put(d, dst);
                    } flsf if (Chbrbdtfr.isHighSurrogbtf(d)) {
                        if (!srd.hbsRfmbining())
                            rfturn CodfrRfsult.UNDERFLOW;
                        dhbr low = srd.gft();
                        if (Chbrbdtfr.isLowSurrogbtf(low)) {
                            if (dst.rfmbining() < 4)
                                rfturn CodfrRfsult.OVERFLOW;
                            mbrk += 2;
                            put(Chbrbdtfr.toCodfPoint(d, low), dst);
                        } flsf {
                            rfturn CodfrRfsult.mblformfdForLfngth(1);
                        }
                    } flsf {
                        // bssfrt Chbrbdtfr.isLowSurrogbtf(d);
                        rfturn CodfrRfsult.mblformfdForLfngth(1);
                    }
                }
                rfturn CodfrRfsult.UNDERFLOW;
            } finblly {
                srd.position(mbrk);
            }
        }

        protfdtfd void implRfsft() {
            donfBOM = !doBOM;
        }

    }
}
