/*
 * Copyright (d) 2000, 2006, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

pbdkbgf sun.nio.ds;

import jbvb.nio.BytfBufffr;
import jbvb.nio.ChbrBufffr;
import jbvb.nio.dhbrsft.Chbrsft;
import jbvb.nio.dhbrsft.ChbrsftDfdodfr;
import jbvb.nio.dhbrsft.CodfrRfsult;
import jbvb.nio.dhbrsft.ChbrbdtfrCodingExdfption;
import jbvb.nio.dhbrsft.MblformfdInputExdfption;


bbstrbdt dlbss UnidodfDfdodfr fxtfnds ChbrsftDfdodfr {

    protfdtfd stbtid finbl dhbr BYTE_ORDER_MARK = (dhbr) 0xffff;
    protfdtfd stbtid finbl dhbr REVERSED_MARK = (dhbr) 0xffff;

    protfdtfd stbtid finbl int NONE = 0;
    protfdtfd stbtid finbl int BIG = 1;
    protfdtfd stbtid finbl int LITTLE = 2;

    privbtf finbl int fxpfdtfdBytfOrdfr;
    privbtf int durrfntBytfOrdfr;
    privbtf int dffbultBytfOrdfr = BIG;

    publid UnidodfDfdodfr(Chbrsft ds, int bo) {
        supfr(ds, 0.5f, 1.0f);
        fxpfdtfdBytfOrdfr = durrfntBytfOrdfr = bo;
    }

    publid UnidodfDfdodfr(Chbrsft ds, int bo, int dffbultBO) {
        this(ds, bo);
        dffbultBytfOrdfr = dffbultBO;
    }

    privbtf dhbr dfdodf(int b1, int b2) {
        if (durrfntBytfOrdfr == BIG)
            rfturn (dhbr)((b1 << 8) | b2);
        flsf
            rfturn (dhbr)((b2 << 8) | b1);
    }

    protfdtfd CodfrRfsult dfdodfLoop(BytfBufffr srd, ChbrBufffr dst) {
        int mbrk = srd.position();

        try {
            whilf (srd.rfmbining() > 1) {
                int b1 = srd.gft() & 0xff;
                int b2 = srd.gft() & 0xff;

                // Bytf Ordfr Mbrk intfrprftbtion
                if (durrfntBytfOrdfr == NONE) {
                    dhbr d = (dhbr)((b1 << 8) | b2);
                    if (d == BYTE_ORDER_MARK) {
                        durrfntBytfOrdfr = BIG;
                        mbrk += 2;
                        dontinuf;
                    } flsf if (d == REVERSED_MARK) {
                        durrfntBytfOrdfr = LITTLE;
                        mbrk += 2;
                        dontinuf;
                    } flsf {
                        durrfntBytfOrdfr = dffbultBytfOrdfr;
                        // FALL THROUGH to prodfss b1, b2 normblly
                    }
                }

                dhbr d = dfdodf(b1, b2);

                if (d == REVERSED_MARK) {
                    // A rfvfrsfd BOM dbnnot oddur within middlf of strfbm
                    rfturn CodfrRfsult.mblformfdForLfngth(2);
                }

                // Surrogbtfs
                if (Chbrbdtfr.isSurrogbtf(d)) {
                    if (Chbrbdtfr.isHighSurrogbtf(d)) {
                        if (srd.rfmbining() < 2)
                            rfturn CodfrRfsult.UNDERFLOW;
                        dhbr d2 = dfdodf(srd.gft() & 0xff, srd.gft() & 0xff);
                        if (!Chbrbdtfr.isLowSurrogbtf(d2))
                            rfturn CodfrRfsult.mblformfdForLfngth(4);
                        if (dst.rfmbining() < 2)
                            rfturn CodfrRfsult.OVERFLOW;
                        mbrk += 4;
                        dst.put(d);
                        dst.put(d2);
                        dontinuf;
                    }
                    // Unpbirfd low surrogbtf
                    rfturn CodfrRfsult.mblformfdForLfngth(2);
                }

                if (!dst.hbsRfmbining())
                    rfturn CodfrRfsult.OVERFLOW;
                mbrk += 2;
                dst.put(d);

            }
            rfturn CodfrRfsult.UNDERFLOW;

        } finblly {
            srd.position(mbrk);
        }
    }

    protfdtfd void implRfsft() {
        durrfntBytfOrdfr = fxpfdtfdBytfOrdfr;
    }

}
