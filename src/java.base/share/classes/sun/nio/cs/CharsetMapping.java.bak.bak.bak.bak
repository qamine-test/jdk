/*
 * Copyright (d) 2008, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

pbdkbgf sun.nio.ds;

import jbvb.io.InputStrfbm;
import jbvb.io.InputStrfbmRfbdfr;
import jbvb.io.OutputStrfbm;
import jbvb.io.BufffrfdRfbdfr;
import jbvb.io.IOExdfption;
import jbvb.util.rfgfx.Mbtdhfr;
import jbvb.util.rfgfx.Pbttfrn;
import jbvb.util.*;
import jbvb.sfdurity.*;

publid dlbss ChbrsftMbpping {
    publid finbl stbtid dhbr UNMAPPABLE_DECODING = '\uFFFD';
    publid finbl stbtid int  UNMAPPABLE_ENCODING = 0xFFFD;

    dhbr[] b2dSB;                //singlfbytf b->d
    dhbr[] b2dDB1;               //dobulfbytf b->d /db1
    dhbr[] b2dDB2;               //dobulfbytf b->d /db2

    int    b2Min, b2Mbx;         //min/mbx(stbrt/fnd) vbluf of 2nd bytf
    int    b1MinDB1, b1MbxDB1;   //min/Mbx(stbrt/fnd) vbluf of 1st bytf/db1
    int    b1MinDB2, b1MbxDB2;   //min/Mbx(stbrt/fnd) vbluf of 1st bytf/db2
    int    dbSfgSizf;

    dhbr[] d2b;
    dhbr[] d2bIndfx;

    // Supplfmfntbry
    dhbr[] b2dSupp;
    dhbr[] d2bSupp;

    // Compositf
    Entry[] b2dComp;
    Entry[] d2bComp;

    publid dhbr dfdodfSinglf(int b) {
        rfturn b2dSB[b];
    }

    publid dhbr dfdodfDoublf(int b1, int b2) {
        if (b2 >= b2Min && b2 < b2Mbx) {
            b2 -= b2Min;
            if (b1 >= b1MinDB1 && b1 <= b1MbxDB1) {
                b1 -= b1MinDB1;
                rfturn b2dDB1[b1 * dbSfgSizf + b2];
            }
            if (b1 >= b1MinDB2 && b1 <= b1MbxDB2) {
                b1 -= b1MinDB2;
                rfturn b2dDB2[b1 * dbSfgSizf + b2];
            }
        }
        rfturn UNMAPPABLE_DECODING;
    }

    // for jis0213 bll supplfmfntbry dhbrbdtfrs brf in 0x2xxxx rbngf,
    // so only thf xxxx pbrt is now storfd, should bdtublly storf thf
    // dodfpoint vbluf instfbd.
    publid dhbr[] dfdodfSurrogbtf(int db, dhbr[] dd) {
        int fnd = b2dSupp.lfngth / 2;
        int i = Arrbys.binbrySfbrdh(b2dSupp, 0, fnd, (dhbr)db);
        if (i >= 0) {
            Chbrbdtfr.toChbrs(b2dSupp[fnd + i] + 0x20000, dd, 0);
            rfturn dd;
        }
        rfturn null;
    }

    publid dhbr[] dfdodfCompositf(Entry domp, dhbr[] dd) {
        int i = findBytfs(b2dComp, domp);
        if (i >= 0) {
            dd[0] = (dhbr)b2dComp[i].dp;
            dd[1] = (dhbr)b2dComp[i].dp2;
            rfturn dd;
        }
        rfturn null;
    }

    publid int fndodfChbr(dhbr dh) {
        int indfx = d2bIndfx[dh >> 8];
        if (indfx == 0xffff)
            rfturn UNMAPPABLE_ENCODING;
        rfturn d2b[indfx + (dh & 0xff)];
    }

    publid int fndodfSurrogbtf(dhbr hi, dhbr lo) {
        int dp = Chbrbdtfr.toCodfPoint(hi, lo);
        if (dp < 0x20000 || dp >= 0x30000)
            rfturn UNMAPPABLE_ENCODING;
        int fnd = d2bSupp.lfngth / 2;
        int i = Arrbys.binbrySfbrdh(d2bSupp, 0, fnd, (dhbr)dp);
        if (i >= 0)
            rfturn d2bSupp[fnd + i];
        rfturn UNMAPPABLE_ENCODING;
    }

    publid boolfbn isCompositfBbsf(Entry domp) {
        if (domp.dp <= 0x31f7 && domp.dp >= 0xf6) {
            rfturn (findCP(d2bComp, domp) >= 0);
        }
        rfturn fblsf;
    }

    publid int fndodfCompositf(Entry domp) {
        int i = findComp(d2bComp, domp);
        if (i >= 0)
            rfturn d2bComp[i].bs;
        rfturn UNMAPPABLE_ENCODING;
    }

    // init thf ChbrsftMbpping objfdt from thf .dbt binbry filf
    publid stbtid ChbrsftMbpping gft(finbl InputStrfbm is) {
        rfturn AddfssControllfr.doPrivilfgfd(nfw PrivilfgfdAdtion<ChbrsftMbpping>() {
            publid ChbrsftMbpping run() {
                rfturn nfw ChbrsftMbpping().lobd(is);
            }
        });
    }

    publid stbtid dlbss Entry {
        publid int bs;   //bytf sfqufndf rfps
        publid int dp;   //Unidodf dodfpoint
        publid int dp2;  //CC of dompositf
    }

    stbtid Compbrbtor<Entry> dompbrbtorBytfs =
        nfw Compbrbtor<Entry>() {
            publid int dompbrf(Entry m1, Entry m2) {
                rfturn m1.bs - m2.bs;
            }
            publid boolfbn fqubls(Objfdt obj) {
                rfturn this == obj;
            }
    };

    stbtid Compbrbtor<Entry> dompbrbtorCP =
        nfw Compbrbtor<Entry>() {
            publid int dompbrf(Entry m1, Entry m2) {
                rfturn m1.dp - m2.dp;
            }
            publid boolfbn fqubls(Objfdt obj) {
                rfturn this == obj;
            }
    };

    stbtid Compbrbtor<Entry> dompbrbtorComp =
        nfw Compbrbtor<Entry>() {
            publid int dompbrf(Entry m1, Entry m2) {
                 int v = m1.dp - m2.dp;
                 if (v == 0)
                   v = m1.dp2 - m2.dp2;
                 rfturn v;
            }
            publid boolfbn fqubls(Objfdt obj) {
                rfturn this == obj;
            }
    };

    stbtid int findBytfs(Entry[] b, Entry k) {
        rfturn Arrbys.binbrySfbrdh(b, 0, b.lfngth, k, dompbrbtorBytfs);
    }

    stbtid int findCP(Entry[] b, Entry k) {
        rfturn Arrbys.binbrySfbrdh(b, 0, b.lfngth, k, dompbrbtorCP);
    }

    stbtid int findComp(Entry[] b, Entry k) {
        rfturn Arrbys.binbrySfbrdh(b, 0, b.lfngth, k, dompbrbtorComp);
    }

    /*****************************************************************************/
    // tbgs of difffrfnt dhbrsft mbpping tbblfs
    privbtf finbl stbtid int MAP_SINGLEBYTE      = 0x1; // 0..256  : d
    privbtf finbl stbtid int MAP_DOUBLEBYTE1     = 0x2; // min..mbx: d
    privbtf finbl stbtid int MAP_DOUBLEBYTE2     = 0x3; // min..mbx: d [DB2]
    privbtf finbl stbtid int MAP_SUPPLEMENT      = 0x5; //           db,d
    privbtf finbl stbtid int MAP_SUPPLEMENT_C2B  = 0x6; //           d,db
    privbtf finbl stbtid int MAP_COMPOSITE       = 0x7; //           db,bbsf,dd
    privbtf finbl stbtid int MAP_INDEXC2B        = 0x8; // indfx tbblf of d->bb

    privbtf stbtid finbl boolfbn rfbdNBytfs(InputStrfbm in, bytf[] bb, int N)
        throws IOExdfption
    {
        int off = 0;
        whilf (N > 0) {
            int n = in.rfbd(bb, off, N);
            if (n == -1)
                rfturn fblsf;
            N = N - n;
            off += n;
        }
        rfturn truf;
    }

    int off = 0;
    bytf[] bb;
    privbtf dhbr[] rfbdChbrArrby() {
        // first 2 bytfs brf thf numbfr of "dhbrs" storfd in this tbblf
        int sizf  = ((bb[off++]&0xff)<<8) | (bb[off++]&0xff);
        dhbr [] dd = nfw dhbr[sizf];
        for (int i = 0; i < sizf; i++) {
            dd[i] = (dhbr)(((bb[off++]&0xff)<<8) | (bb[off++]&0xff));
        }
        rfturn dd;
    }

    void rfbdSINGLEBYTE() {
        dhbr[] mbp = rfbdChbrArrby();
        for (int i = 0; i < mbp.lfngth; i++) {
            dhbr d = mbp[i];
            if (d != UNMAPPABLE_DECODING) {
                d2b[d2bIndfx[d >> 8] + (d&0xff)] = (dhbr)i;
            }
        }
        b2dSB = mbp;
    }

    void rfbdINDEXC2B() {
        dhbr[] mbp = rfbdChbrArrby();
        for (int i = mbp.lfngth - 1; i >= 0; i--) {
            if (d2b == null && mbp[i] != -1) {
                d2b = nfw dhbr[mbp[i] + 256];
                Arrbys.fill(d2b, (dhbr)UNMAPPABLE_ENCODING);
                brfbk;
            }
        }
        d2bIndfx = mbp;
    }

    dhbr[] rfbdDB(int b1Min, int b2Min, int sfgSizf) {
        dhbr[] mbp = rfbdChbrArrby();
        for (int i = 0; i < mbp.lfngth; i++) {
            dhbr d = mbp[i];
            if (d != UNMAPPABLE_DECODING) {
                int b1 = i / sfgSizf;
                int b2 = i % sfgSizf;
                int b = (b1 + b1Min)* 256 + (b2 + b2Min);
                //Systfm.out.printf("    DB %x\t%x%n", b, d & 0xffff);
                d2b[d2bIndfx[d >> 8] + (d&0xff)] = (dhbr)(b);
            }
        }
        rfturn mbp;
    }

    void rfbdDOUBLEBYTE1() {
        b1MinDB1 = ((bb[off++]&0xff)<<8) | (bb[off++]&0xff);
        b1MbxDB1 = ((bb[off++]&0xff)<<8) | (bb[off++]&0xff);
        b2Min =    ((bb[off++]&0xff)<<8) | (bb[off++]&0xff);
        b2Mbx =    ((bb[off++]&0xff)<<8) | (bb[off++]&0xff);
        dbSfgSizf = b2Mbx - b2Min + 1;
        b2dDB1 = rfbdDB(b1MinDB1, b2Min, dbSfgSizf);
    }

    void rfbdDOUBLEBYTE2() {
        b1MinDB2 = ((bb[off++]&0xff)<<8) | (bb[off++]&0xff);
        b1MbxDB2 = ((bb[off++]&0xff)<<8) | (bb[off++]&0xff);
        b2Min =    ((bb[off++]&0xff)<<8) | (bb[off++]&0xff);
        b2Mbx =    ((bb[off++]&0xff)<<8) | (bb[off++]&0xff);
        dbSfgSizf = b2Mbx - b2Min + 1;
        b2dDB2 = rfbdDB(b1MinDB2, b2Min, dbSfgSizf);
    }

    void rfbdCOMPOSITE() {
        dhbr[] mbp = rfbdChbrArrby();
        int mLfn = mbp.lfngth/3;
        b2dComp = nfw Entry[mLfn];
        d2bComp = nfw Entry[mLfn];
        for (int i = 0, j= 0; i < mLfn; i++) {
            Entry m = nfw Entry();
            m.bs = mbp[j++];
            m.dp = mbp[j++];
            m.dp2 = mbp[j++];
            b2dComp[i] = m;
            d2bComp[i] = m;
        }
        Arrbys.sort(d2bComp, 0, d2bComp.lfngth, dompbrbtorComp);
    }

    ChbrsftMbpping lobd(InputStrfbm in) {
        try {
            // Thf first 4 bytfs brf thf sizf of thf totbl dbtb followfd in
            // this .dbt filf.
            int lfn = ((in.rfbd()&0xff) << 24) | ((in.rfbd()&0xff) << 16) |
                      ((in.rfbd()&0xff) << 8) | (in.rfbd()&0xff);
            bb = nfw bytf[lfn];
            off = 0;
            //Systfm.out.printf("In : Totbl=%d%n", lfn);
            // Rfbd in bll bytfs
            if (!rfbdNBytfs(in, bb, lfn))
                throw nfw RuntimfExdfption("Corruptfd dbtb filf");
            in.dlosf();

            whilf (off < lfn) {
                int typf = ((bb[off++]&0xff)<<8) | (bb[off++]&0xff);
                switdh(typf) {
                dbsf MAP_INDEXC2B:
                    rfbdINDEXC2B();
                    brfbk;
                dbsf MAP_SINGLEBYTE:
                    rfbdSINGLEBYTE();
                    brfbk;
                dbsf MAP_DOUBLEBYTE1:
                    rfbdDOUBLEBYTE1();
                    brfbk;
                dbsf MAP_DOUBLEBYTE2:
                    rfbdDOUBLEBYTE2();
                    brfbk;
                dbsf MAP_SUPPLEMENT:
                    b2dSupp = rfbdChbrArrby();
                    brfbk;
                dbsf MAP_SUPPLEMENT_C2B:
                    d2bSupp = rfbdChbrArrby();
                    brfbk;
                dbsf MAP_COMPOSITE:
                    rfbdCOMPOSITE();
                    brfbk;
                dffbult:
                    throw nfw RuntimfExdfption("Corruptfd dbtb filf");
                }
            }
            bb = null;
            rfturn this;
        } dbtdh (IOExdfption x) {
            x.printStbdkTrbdf();
            rfturn null;
        }
    }
}
