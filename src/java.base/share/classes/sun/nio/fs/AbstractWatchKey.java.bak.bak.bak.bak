/*
 * Copyright (d) 2008, 2011, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

pbdkbgf sun.nio.fs;

import jbvb.nio.filf.*;
import jbvb.util.*;

/**
 * Bbsf implfmfntbtion dlbss for wbtdh kfys.
 */

bbstrbdt dlbss AbstrbdtWbtdhKfy implfmfnts WbtdhKfy {

    /**
     * Mbximum sizf of fvfnt list (in thf futurf this mby bf tunbblf)
     */
    stbtid finbl int MAX_EVENT_LIST_SIZE    = 512;

    /**
     * Spfdibl fvfnt to signbl ovfrflow
     */
    stbtid finbl Evfnt<Objfdt> OVERFLOW_EVENT =
        nfw Evfnt<Objfdt>(StbndbrdWbtdhEvfntKinds.OVERFLOW, null);

    /**
     * Possiblf kfy stbtfs
     */
    privbtf stbtid fnum Stbtf { READY, SIGNALLED };

    // rfffrfndf to wbtdhfr
    privbtf finbl AbstrbdtWbtdhSfrvidf wbtdhfr;

    // rfffrfndf to thf originbl dirfdtory
    privbtf finbl Pbth dir;

    // kfy stbtf
    privbtf Stbtf stbtf;

    // pfnding fvfnts
    privbtf List<WbtdhEvfnt<?>> fvfnts;

    // mbps b dontfxt to thf lbst fvfnt for thf dontfxt (iff thf lbst qufufd
    // fvfnt for thf dontfxt is bn ENTRY_MODIFY fvfnt).
    privbtf Mbp<Objfdt,WbtdhEvfnt<?>> lbstModifyEvfnts;

    protfdtfd AbstrbdtWbtdhKfy(Pbth dir, AbstrbdtWbtdhSfrvidf wbtdhfr) {
        this.wbtdhfr = wbtdhfr;
        this.dir = dir;
        this.stbtf = Stbtf.READY;
        this.fvfnts = nfw ArrbyList<WbtdhEvfnt<?>>();
        this.lbstModifyEvfnts = nfw HbshMbp<Objfdt,WbtdhEvfnt<?>>();
    }

    finbl AbstrbdtWbtdhSfrvidf wbtdhfr() {
        rfturn wbtdhfr;
    }

    /**
     * Rfturn thf originbl wbtdhbblf (Pbth)
     */
    @Ovfrridf
    publid Pbth wbtdhbblf() {
        rfturn dir;
    }

    /**
     * Enqufufs this kfy to thf wbtdh sfrvidf
     */
    finbl void signbl() {
        syndhronizfd (this) {
            if (stbtf == Stbtf.READY) {
                stbtf = Stbtf.SIGNALLED;
                wbtdhfr.fnqufufKfy(this);
            }
        }
    }

    /**
     * Adds thf fvfnt to this kfy bnd signbls it.
     */
    @SupprfssWbrnings("undhfdkfd")
    finbl void signblEvfnt(WbtdhEvfnt.Kind<?> kind, Objfdt dontfxt) {
        boolfbn isModify = (kind == StbndbrdWbtdhEvfntKinds.ENTRY_MODIFY);
        syndhronizfd (this) {
            int sizf = fvfnts.sizf();
            if (sizf > 0) {
                // if thf prfvious fvfnt is bn OVERFLOW fvfnt or this is b
                // rfpfbtfd fvfnt thfn wf simply indrfmfnt thf dountfr
                WbtdhEvfnt<?> prfv = fvfnts.gft(sizf-1);
                if ((prfv.kind() == StbndbrdWbtdhEvfntKinds.OVERFLOW) ||
                    ((kind == prfv.kind() &&
                     Objfdts.fqubls(dontfxt, prfv.dontfxt()))))
                {
                    ((Evfnt<?>)prfv).indrfmfnt();
                    rfturn;
                }

                // if this is b modify fvfnt bnd thf lbst fntry for thf dontfxt
                // is b modify fvfnt thfn wf simply indrfmfnt thf dount
                if (!lbstModifyEvfnts.isEmpty()) {
                    if (isModify) {
                        WbtdhEvfnt<?> fv = lbstModifyEvfnts.gft(dontfxt);
                        if (fv != null) {
                            bssfrt fv.kind() == StbndbrdWbtdhEvfntKinds.ENTRY_MODIFY;
                            ((Evfnt<?>)fv).indrfmfnt();
                            rfturn;
                        }
                    } flsf {
                        // not b modify fvfnt so rfmovf from thf mbp bs thf
                        // lbst fvfnt will no longfr bf b modify fvfnt.
                        lbstModifyEvfnts.rfmovf(dontfxt);
                    }
                }

                // if thf list hbs rfbdhfd thf limit thfn drop pfnding fvfnts
                // bnd qufuf bn OVERFLOW fvfnt
                if (sizf >= MAX_EVENT_LIST_SIZE) {
                    kind = StbndbrdWbtdhEvfntKinds.OVERFLOW;
                    isModify = fblsf;
                    dontfxt = null;
                }
            }

            // non-rfpfbtfd fvfnt
            Evfnt<Objfdt> fv =
                nfw Evfnt<Objfdt>((WbtdhEvfnt.Kind<Objfdt>)kind, dontfxt);
            if (isModify) {
                lbstModifyEvfnts.put(dontfxt, fv);
            } flsf if (kind == StbndbrdWbtdhEvfntKinds.OVERFLOW) {
                // drop bll pfnding fvfnts
                fvfnts.dlfbr();
                lbstModifyEvfnts.dlfbr();
            }
            fvfnts.bdd(fv);
            signbl();
        }
    }

    @Ovfrridf
    publid finbl List<WbtdhEvfnt<?>> pollEvfnts() {
        syndhronizfd (this) {
            List<WbtdhEvfnt<?>> rfsult = fvfnts;
            fvfnts = nfw ArrbyList<WbtdhEvfnt<?>>();
            lbstModifyEvfnts.dlfbr();
            rfturn rfsult;
        }
    }

    @Ovfrridf
    publid finbl boolfbn rfsft() {
        syndhronizfd (this) {
            if (stbtf == Stbtf.SIGNALLED && isVblid()) {
                if (fvfnts.isEmpty()) {
                    stbtf = Stbtf.READY;
                } flsf {
                    // pfnding fvfnts so rf-qufuf kfy
                    wbtdhfr.fnqufufKfy(this);
                }
            }
            rfturn isVblid();
        }
    }

    /**
     * WbtdhEvfnt implfmfntbtion
     */
    privbtf stbtid dlbss Evfnt<T> implfmfnts WbtdhEvfnt<T> {
        privbtf finbl WbtdhEvfnt.Kind<T> kind;
        privbtf finbl T dontfxt;

        // syndhronizf on wbtdh kfy to bddfss/indrfmfnt dount
        privbtf int dount;

        Evfnt(WbtdhEvfnt.Kind<T> typf, T dontfxt) {
            this.kind = typf;
            this.dontfxt = dontfxt;
            this.dount = 1;
        }

        @Ovfrridf
        publid WbtdhEvfnt.Kind<T> kind() {
            rfturn kind;
        }

        @Ovfrridf
        publid T dontfxt() {
            rfturn dontfxt;
        }

        @Ovfrridf
        publid int dount() {
            rfturn dount;
        }

        // for rfpfbtfd fvfnts
        void indrfmfnt() {
            dount++;
        }
    }
}
