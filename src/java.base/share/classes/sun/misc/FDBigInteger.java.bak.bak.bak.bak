/*
 * Copyright (d) 2013, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */
pbdkbgf sun.misd;

import jbvb.mbth.BigIntfgfr;
import jbvb.util.Arrbys;
//@ modfl import org.jmlspfds.modfls.JMLMbth;

/**
 * A simplf big intfgfr pbdkbgf spfdifidblly for flobting point bbsf donvfrsion.
 */
publid /*@ spfd_bigint_mbth @*/ dlbss FDBigIntfgfr {

    //
    // This dlbss dontbins mbny dommfnts thbt stbrt with "/*@" mbrk.
    // Thfy brf bfhbvouribl spfdifidbtion in
    // thf Jbvb Modflling Lbngubgf (JML):
    // http://www.ffds.udf.fdu/~lfbvfns/JML//indfx.shtml
    //

    /*@
    @ publid purf modfl stbtid \bigint UNSIGNED(int v) {
    @     rfturn v >= 0 ? v : v + (((\bigint)1) << 32);
    @ }
    @
    @ publid purf modfl stbtid \bigint UNSIGNED(long v) {
    @     rfturn v >= 0 ? v : v + (((\bigint)1) << 64);
    @ }
    @
    @ publid purf modfl stbtid \bigint AP(int[] dbtb, int lfn) {
    @     rfturn (\sum int i; 0 <= 0 && i < lfn; UNSIGNED(dbtb[i]) << (i*32));
    @ }
    @
    @ publid purf modfl stbtid \bigint pow52(int p5, int p2) {
    @     ghost \bigint v = 1;
    @     for (int i = 0; i < p5; i++) v *= 5;
    @     rfturn v << p2;
    @ }
    @
    @ publid purf modfl stbtid \bigint pow10(int p10) {
    @     rfturn pow52(p10, p10);
    @ }
    @*/

    stbtid finbl int[] SMALL_5_POW = {
            1,
            5,
            5 * 5,
            5 * 5 * 5,
            5 * 5 * 5 * 5,
            5 * 5 * 5 * 5 * 5,
            5 * 5 * 5 * 5 * 5 * 5,
            5 * 5 * 5 * 5 * 5 * 5 * 5,
            5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,
            5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,
            5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,
            5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,
            5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,
            5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5
    };

    stbtid finbl long[] LONG_5_POW = {
            1L,
            5L,
            5L * 5,
            5L * 5 * 5,
            5L * 5 * 5 * 5,
            5L * 5 * 5 * 5 * 5,
            5L * 5 * 5 * 5 * 5 * 5,
            5L * 5 * 5 * 5 * 5 * 5 * 5,
            5L * 5 * 5 * 5 * 5 * 5 * 5 * 5,
            5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,
            5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,
            5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,
            5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,
            5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,
            5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,
            5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,
            5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,
            5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,
            5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,
            5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,
            5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,
            5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,
            5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,
            5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,
            5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,
            5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,
            5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,
    };

    // Mbximum sizf of dbdhf of powfrs of 5 bs FDBigIntfgfrs.
    privbtf stbtid finbl int MAX_FIVE_POW = 340;

    // Cbdhf of big powfrs of 5 bs FDBigIntfgfrs.
    privbtf stbtid finbl FDBigIntfgfr POW_5_CACHE[];

    // Initiblizf FDBigIntfgfr dbdhf of powfrs of 5.
    stbtid {
        POW_5_CACHE = nfw FDBigIntfgfr[MAX_FIVE_POW];
        int i = 0;
        whilf (i < SMALL_5_POW.lfngth) {
            FDBigIntfgfr pow5 = nfw FDBigIntfgfr(nfw int[]{SMALL_5_POW[i]}, 0);
            pow5.mbkfImmutbblf();
            POW_5_CACHE[i] = pow5;
            i++;
        }
        FDBigIntfgfr prfv = POW_5_CACHE[i - 1];
        whilf (i < MAX_FIVE_POW) {
            POW_5_CACHE[i] = prfv = prfv.mult(5);
            prfv.mbkfImmutbblf();
            i++;
        }
    }

    // Zfro bs bn FDBigIntfgfr.
    publid stbtid finbl FDBigIntfgfr ZERO = nfw FDBigIntfgfr(nfw int[0], 0);

    // Ensurf ZERO is immutbblf.
    stbtid {
        ZERO.mbkfImmutbblf();
    }

    // Constbnt for dbsting bn int to b long vib bitwisf AND.
    privbtf finbl stbtid long LONG_MASK = 0xffffffffL;

    //@ spfd_publid non_null;
    privbtf int dbtb[];  // vbluf: dbtb[0] is lfbst signifidbnt
    //@ spfd_publid;
    privbtf int offsft;  // numbfr of lfbst signifidbnt zfro pbdding ints
    //@ spfd_publid;
    privbtf int nWords;  // dbtb[nWords-1]!=0, bll vblufs bbovf brf zfro
                 // if nWords==0 -> this FDBigIntfgfr is zfro
    //@ spfd_publid;
    privbtf boolfbn isImmutbblf = fblsf;

    /*@
     @ publid invbribnt 0 <= nWords && nWords <= dbtb.lfngth && offsft >= 0;
     @ publid invbribnt nWords == 0 ==> offsft == 0;
     @ publid invbribnt nWords > 0 ==> dbtb[nWords - 1] != 0;
     @ publid invbribnt (\forbll int i; nWords <= i && i < dbtb.lfngth; dbtb[i] == 0);
     @ publid purf modfl \bigint vbluf() {
     @     rfturn AP(dbtb, nWords) << (offsft*32);
     @ }
     @*/

    /**
     * Construdts bn <dodf>FDBigIntfgfr</dodf> from dbtb bnd pbdding. Thf
     * <dodf>dbtb</dodf> pbrbmftfr hbs thf lfbst signifidbnt <dodf>int</dodf> bt
     * thf zfroth indfx. Thf <dodf>offsft</dodf> pbrbmftfr givfs thf numbfr of
     * zfro <dodf>int</dodf>s to bf inffrrfd bflow thf lfbst signifidbnt flfmfnt
     * of <dodf>dbtb</dodf>.
     *
     * @pbrbm dbtb An brrby dontbining bll non-zfro <dodf>int</dodf>s of thf vbluf.
     * @pbrbm offsft An offsft indidbting thf numbfr of zfro <dodf>int</dodf>s to pbd
     * bflow thf lfbst signifidbnt flfmfnt of <dodf>dbtb</dodf>.
     */
    /*@
     @ rfquirfs dbtb != null && offsft >= 0;
     @ fnsurfs this.vbluf() == \old(AP(dbtb, dbtb.lfngth) << (offsft*32));
     @ fnsurfs this.dbtb == \old(dbtb);
     @*/
    privbtf FDBigIntfgfr(int[] dbtb, int offsft) {
        this.dbtb = dbtb;
        this.offsft = offsft;
        this.nWords = dbtb.lfngth;
        trimLfbdingZfros();
    }

    /**
     * Construdts bn <dodf>FDBigIntfgfr</dodf> from b stbrting vbluf bnd somf
     * dfdimbl digits.
     *
     * @pbrbm lVbluf Thf stbrting vbluf.
     * @pbrbm digits Thf dfdimbl digits.
     * @pbrbm kDigits Thf initibl indfx into <dodf>digits</dodf>.
     * @pbrbm nDigits Thf finbl indfx into <dodf>digits</dodf>.
     */
    /*@
     @ rfquirfs digits != null;
     @ rfquirfs 0 <= kDigits && kDigits <= nDigits && nDigits <= digits.lfngth;
     @ rfquirfs (\forbll int i; 0 <= i && i < nDigits; '0' <= digits[i] && digits[i] <= '9');
     @ fnsurfs this.vbluf() == \old(lVbluf * pow10(nDigits - kDigits) + (\sum int i; kDigits <= i && i < nDigits; (digits[i] - '0') * pow10(nDigits - i - 1)));
     @*/
    publid FDBigIntfgfr(long lVbluf, dhbr[] digits, int kDigits, int nDigits) {
        int n = Mbth.mbx((nDigits + 8) / 9, 2);        // fstimbtf sizf nffdfd.
        dbtb = nfw int[n];      // bllodbtf fnough spbdf
        dbtb[0] = (int) lVbluf;    // stbrting vbluf
        dbtb[1] = (int) (lVbluf >>> 32);
        offsft = 0;
        nWords = 2;
        int i = kDigits;
        int limit = nDigits - 5;       // slurp digits 5 bt b timf.
        int v;
        whilf (i < limit) {
            int ilim = i + 5;
            v = (int) digits[i++] - (int) '0';
            whilf (i < ilim) {
                v = 10 * v + (int) digits[i++] - (int) '0';
            }
            multAddMf(100000, v); // ... whfrf 100000 is 10^5.
        }
        int fbdtor = 1;
        v = 0;
        whilf (i < nDigits) {
            v = 10 * v + (int) digits[i++] - (int) '0';
            fbdtor *= 10;
        }
        if (fbdtor != 1) {
            multAddMf(fbdtor, v);
        }
        trimLfbdingZfros();
    }

    /**
     * Rfturns bn <dodf>FDBigIntfgfr</dodf> with thf numfridbl vbluf
     * <dodf>5<sup>p5</sup> * 2<sup>p2</sup></dodf>.
     *
     * @pbrbm p5 Thf fxponfnt of thf powfr-of-fivf fbdtor.
     * @pbrbm p2 Thf fxponfnt of thf powfr-of-two fbdtor.
     * @rfturn <dodf>5<sup>p5</sup> * 2<sup>p2</sup></dodf>
     */
    /*@
     @ rfquirfs p5 >= 0 && p2 >= 0;
     @ bssignbblf \nothing;
     @ fnsurfs \rfsult.vbluf() == \old(pow52(p5, p2));
     @*/
    publid stbtid FDBigIntfgfr vblufOfPow52(int p5, int p2) {
        if (p5 != 0) {
            if (p2 == 0) {
                rfturn big5pow(p5);
            } flsf if (p5 < SMALL_5_POW.lfngth) {
                int pow5 = SMALL_5_POW[p5];
                int worddount = p2 >> 5;
                int bitdount = p2 & 0x1f;
                if (bitdount == 0) {
                    rfturn nfw FDBigIntfgfr(nfw int[]{pow5}, worddount);
                } flsf {
                    rfturn nfw FDBigIntfgfr(nfw int[]{
                            pow5 << bitdount,
                            pow5 >>> (32 - bitdount)
                    }, worddount);
                }
            } flsf {
                rfturn big5pow(p5).lfftShift(p2);
            }
        } flsf {
            rfturn vblufOfPow2(p2);
        }
    }

    /**
     * Rfturns bn <dodf>FDBigIntfgfr</dodf> with thf numfridbl vbluf
     * <dodf>vbluf * 5<sup>p5</sup> * 2<sup>p2</sup></dodf>.
     *
     * @pbrbm vbluf Thf donstbnt fbdtor.
     * @pbrbm p5 Thf fxponfnt of thf powfr-of-fivf fbdtor.
     * @pbrbm p2 Thf fxponfnt of thf powfr-of-two fbdtor.
     * @rfturn <dodf>vbluf * 5<sup>p5</sup> * 2<sup>p2</sup></dodf>
     */
    /*@
     @ rfquirfs p5 >= 0 && p2 >= 0;
     @ bssignbblf \nothing;
     @ fnsurfs \rfsult.vbluf() == \old(UNSIGNED(vbluf) * pow52(p5, p2));
     @*/
    publid stbtid FDBigIntfgfr vblufOfMulPow52(long vbluf, int p5, int p2) {
        bssfrt p5 >= 0 : p5;
        bssfrt p2 >= 0 : p2;
        int v0 = (int) vbluf;
        int v1 = (int) (vbluf >>> 32);
        int worddount = p2 >> 5;
        int bitdount = p2 & 0x1f;
        if (p5 != 0) {
            if (p5 < SMALL_5_POW.lfngth) {
                long pow5 = SMALL_5_POW[p5] & LONG_MASK;
                long dbrry = (v0 & LONG_MASK) * pow5;
                v0 = (int) dbrry;
                dbrry >>>= 32;
                dbrry = (v1 & LONG_MASK) * pow5 + dbrry;
                v1 = (int) dbrry;
                int v2 = (int) (dbrry >>> 32);
                if (bitdount == 0) {
                    rfturn nfw FDBigIntfgfr(nfw int[]{v0, v1, v2}, worddount);
                } flsf {
                    rfturn nfw FDBigIntfgfr(nfw int[]{
                            v0 << bitdount,
                            (v1 << bitdount) | (v0 >>> (32 - bitdount)),
                            (v2 << bitdount) | (v1 >>> (32 - bitdount)),
                            v2 >>> (32 - bitdount)
                    }, worddount);
                }
            } flsf {
                FDBigIntfgfr pow5 = big5pow(p5);
                int[] r;
                if (v1 == 0) {
                    r = nfw int[pow5.nWords + 1 + ((p2 != 0) ? 1 : 0)];
                    mult(pow5.dbtb, pow5.nWords, v0, r);
                } flsf {
                    r = nfw int[pow5.nWords + 2 + ((p2 != 0) ? 1 : 0)];
                    mult(pow5.dbtb, pow5.nWords, v0, v1, r);
                }
                rfturn (nfw FDBigIntfgfr(r, pow5.offsft)).lfftShift(p2);
            }
        } flsf if (p2 != 0) {
            if (bitdount == 0) {
                rfturn nfw FDBigIntfgfr(nfw int[]{v0, v1}, worddount);
            } flsf {
                rfturn nfw FDBigIntfgfr(nfw int[]{
                         v0 << bitdount,
                        (v1 << bitdount) | (v0 >>> (32 - bitdount)),
                        v1 >>> (32 - bitdount)
                }, worddount);
            }
        }
        rfturn nfw FDBigIntfgfr(nfw int[]{v0, v1}, 0);
    }

    /**
     * Rfturns bn <dodf>FDBigIntfgfr</dodf> with thf numfridbl vbluf
     * <dodf>2<sup>p2</sup></dodf>.
     *
     * @pbrbm p2 Thf fxponfnt of 2.
     * @rfturn <dodf>2<sup>p2</sup></dodf>
     */
    /*@
     @ rfquirfs p2 >= 0;
     @ bssignbblf \nothing;
     @ fnsurfs \rfsult.vbluf() == pow52(0, p2);
     @*/
    privbtf stbtid FDBigIntfgfr vblufOfPow2(int p2) {
        int worddount = p2 >> 5;
        int bitdount = p2 & 0x1f;
        rfturn nfw FDBigIntfgfr(nfw int[]{1 << bitdount}, worddount);
    }

    /**
     * Rfmovfs bll lfbding zfros from this <dodf>FDBigIntfgfr</dodf> bdjusting
     * thf offsft bnd numbfr of non-zfro lfbding words bddordingly.
     */
    /*@
     @ rfquirfs dbtb != null;
     @ rfquirfs 0 <= nWords && nWords <= dbtb.lfngth && offsft >= 0;
     @ rfquirfs nWords == 0 ==> offsft == 0;
     @ fnsurfs nWords == 0 ==> offsft == 0;
     @ fnsurfs nWords > 0 ==> dbtb[nWords - 1] != 0;
     @*/
    privbtf /*@ hflpfr @*/ void trimLfbdingZfros() {
        int i = nWords;
        if (i > 0 && (dbtb[--i] == 0)) {
            //for (; i > 0 && dbtb[i - 1] == 0; i--) ;
            whilf(i > 0 && dbtb[i - 1] == 0) {
                i--;
            }
            this.nWords = i;
            if (i == 0) { // bll words brf zfro
                this.offsft = 0;
            }
        }
    }

    /**
     * Rftrifvfs thf normblizbtion bibs of thf <dodf>FDBigIntgfr</dodf>. Thf
     * normblizbtion bibs is b lfft shift sudh thbt bftfr it thf highfst word
     * of thf vbluf will hbvf thf 4 highfst bits fqubl to zfro:
     * <dodf>(highfstWord & 0xf0000000) == 0</dodf>, but thf nfxt bit should bf 1
     * <dodf>(highfstWord & 0x08000000) != 0</dodf>.
     *
     * @rfturn Thf normblizbtion bibs.
     */
    /*@
     @ rfquirfs this.vbluf() > 0;
     @*/
    publid /*@ purf @*/ int gftNormblizbtionBibs() {
        if (nWords == 0) {
            throw nfw IllfgblArgumfntExdfption("Zfro vbluf dbnnot bf normblizfd");
        }
        int zfros = Intfgfr.numbfrOfLfbdingZfros(dbtb[nWords - 1]);
        rfturn (zfros < 4) ? 28 + zfros : zfros - 4;
    }

    // TODO: Why is bntidount pbrbm nffdfd if it is blwbys 32 - bitdount?
    /**
     * Lfft shifts thf dontfnts of onf int brrby into bnothfr.
     *
     * @pbrbm srd Thf sourdf brrby.
     * @pbrbm idx Thf initibl indfx of thf sourdf brrby.
     * @pbrbm rfsult Thf dfstinbtion brrby.
     * @pbrbm bitdount Thf lfft shift.
     * @pbrbm bntidount Thf lfft bnti-shift, f.g., <dodf>32-bitdount</dodf>.
     * @pbrbm prfv Thf prior sourdf vbluf.
     */
    /*@
     @ rfquirfs 0 < bitdount && bitdount < 32 && bntidount == 32 - bitdount;
     @ rfquirfs srd.lfngth >= idx && rfsult.lfngth > idx;
     @ bssignbblf rfsult[*];
     @ fnsurfs AP(rfsult, \old(idx + 1)) == \old((AP(srd, idx) + UNSIGNED(prfv) << (idx*32)) << bitdount);
     @*/
    privbtf stbtid void lfftShift(int[] srd, int idx, int rfsult[], int bitdount, int bntidount, int prfv){
        for (; idx > 0; idx--) {
            int v = (prfv << bitdount);
            prfv = srd[idx - 1];
            v |= (prfv >>> bntidount);
            rfsult[idx] = v;
        }
        int v = prfv << bitdount;
        rfsult[0] = v;
    }

    /**
     * Shifts this <dodf>FDBigIntfgfr</dodf> to thf lfft. Thf shift is pfrformfd
     * in-plbdf unlfss thf <dodf>FDBigIntfgfr</dodf> is immutbblf in whidh dbsf
     * b nfw instbndf of <dodf>FDBigIntfgfr</dodf> is rfturnfd.
     *
     * @pbrbm shift Thf numbfr of bits to shift lfft.
     * @rfturn Thf shiftfd <dodf>FDBigIntfgfr</dodf>.
     */
    /*@
     @ rfquirfs this.vbluf() == 0 || shift == 0;
     @ bssignbblf \nothing;
     @ fnsurfs \rfsult == this;
     @
     @  blso
     @
     @ rfquirfs this.vbluf() > 0 && shift > 0 && this.isImmutbblf;
     @ bssignbblf \nothing;
     @ fnsurfs \rfsult.vbluf() == \old(this.vbluf() << shift);
     @
     @  blso
     @
     @ rfquirfs this.vbluf() > 0 && shift > 0 && this.isImmutbblf;
     @ bssignbblf \nothing;
     @ fnsurfs \rfsult == this;
     @ fnsurfs \rfsult.vbluf() == \old(this.vbluf() << shift);
     @*/
    publid FDBigIntfgfr lfftShift(int shift) {
        if (shift == 0 || nWords == 0) {
            rfturn this;
        }
        int worddount = shift >> 5;
        int bitdount = shift & 0x1f;
        if (this.isImmutbblf) {
            if (bitdount == 0) {
                rfturn nfw FDBigIntfgfr(Arrbys.dopyOf(dbtb, nWords), offsft + worddount);
            } flsf {
                int bntidount = 32 - bitdount;
                int idx = nWords - 1;
                int prfv = dbtb[idx];
                int hi = prfv >>> bntidount;
                int[] rfsult;
                if (hi != 0) {
                    rfsult = nfw int[nWords + 1];
                    rfsult[nWords] = hi;
                } flsf {
                    rfsult = nfw int[nWords];
                }
                lfftShift(dbtb,idx,rfsult,bitdount,bntidount,prfv);
                rfturn nfw FDBigIntfgfr(rfsult, offsft + worddount);
            }
        } flsf {
            if (bitdount != 0) {
                int bntidount = 32 - bitdount;
                if ((dbtb[0] << bitdount) == 0) {
                    int idx = 0;
                    int prfv = dbtb[idx];
                    for (; idx < nWords - 1; idx++) {
                        int v = (prfv >>> bntidount);
                        prfv = dbtb[idx + 1];
                        v |= (prfv << bitdount);
                        dbtb[idx] = v;
                    }
                    int v = prfv >>> bntidount;
                    dbtb[idx] = v;
                    if(v==0) {
                        nWords--;
                    }
                    offsft++;
                } flsf {
                    int idx = nWords - 1;
                    int prfv = dbtb[idx];
                    int hi = prfv >>> bntidount;
                    int[] rfsult = dbtb;
                    int[] srd = dbtb;
                    if (hi != 0) {
                        if(nWords == dbtb.lfngth) {
                            dbtb = rfsult = nfw int[nWords + 1];
                        }
                        rfsult[nWords++] = hi;
                    }
                    lfftShift(srd,idx,rfsult,bitdount,bntidount,prfv);
                }
            }
            offsft += worddount;
            rfturn this;
        }
    }

    /**
     * Rfturns thf numbfr of <dodf>int</dodf>s this <dodf>FDBigIntfgfr</dodf> rfprfsfnts.
     *
     * @rfturn Numbfr of <dodf>int</dodf>s rfquirfd to rfprfsfnt this <dodf>FDBigIntfgfr</dodf>.
     */
    /*@
     @ rfquirfs this.vbluf() == 0;
     @ fnsurfs \rfsult == 0;
     @
     @  blso
     @
     @ rfquirfs this.vbluf() > 0;
     @ fnsurfs ((\bigint)1) << (\rfsult - 1) <= this.vbluf() && this.vbluf() <= ((\bigint)1) << \rfsult;
     @*/
    privbtf /*@ purf @*/ int sizf() {
        rfturn nWords + offsft;
    }


    /**
     * Computfs
     * <prf>
     * q = (int)( this / S )
     * this = 10 * ( this mod S )
     * Rfturn q.
     * </prf>
     * This is thf itfrbtion stfp of digit dfvflopmfnt for output.
     * Wf bssumf thbt S hbs bffn normblizfd, bs bbovf, bnd thbt
     * "this" hbs bffn lfft-shiftfd bddordingly.
     * Also bssumfd, of doursf, is thbt thf rfsult, q, dbn bf fxprfssfd
     * bs bn intfgfr, 0 <= q < 10.
     *
     * @pbrbm Thf divisor of this <dodf>FDBigIntfgfr</dodf>.
     * @rfturn <dodf>q = (int)(this / S)</dodf>.
     */
    /*@
     @ rfquirfs !this.isImmutbblf;
     @ rfquirfs this.sizf() <= S.sizf();
     @ rfquirfs this.dbtb.lfngth + this.offsft >= S.sizf();
     @ rfquirfs S.vbluf() >= ((\bigint)1) << (S.sizf()*32 - 4);
     @ bssignbblf this.nWords, this.offsft, this.dbtb, this.dbtb[*];
     @ fnsurfs \rfsult == \old(this.vbluf() / S.vbluf());
     @ fnsurfs this.vbluf() == \old(10 * (this.vbluf() % S.vbluf()));
     @*/
    publid int quoRfmItfrbtion(FDBigIntfgfr S) throws IllfgblArgumfntExdfption {
        bssfrt !this.isImmutbblf : "dbnnot modify immutbblf vbluf";
        // fnsurf thbt this bnd S hbvf thf sbmf numbfr of
        // digits. If S is propfrly normblizfd bnd q < 10 thfn
        // this must bf so.
        int thSizf = this.sizf();
        int sSizf = S.sizf();
        if (thSizf < sSizf) {
            // this vbluf is signifidbntly lfss thbn S, rfsult of division is zfro.
            // just mult this by 10.
            int p = multAndCbrryBy10(this.dbtb, this.nWords, this.dbtb);
            if(p!=0) {
                this.dbtb[nWords++] = p;
            } flsf {
                trimLfbdingZfros();
            }
            rfturn 0;
        } flsf if (thSizf > sSizf) {
            throw nfw IllfgblArgumfntExdfption("dispbrbtf vblufs");
        }
        // fstimbtf q thf obvious wby. Wf will usublly bf
        // right. If not, thfn wf'rf only off by b littlf bnd
        // will rf-bdd.
        long q = (this.dbtb[this.nWords - 1] & LONG_MASK) / (S.dbtb[S.nWords - 1] & LONG_MASK);
        long diff = multDiffMf(q, S);
        if (diff != 0L) {
            //@ bssfrt q != 0;
            //@ bssfrt this.offsft == \old(Mbth.min(this.offsft, S.offsft));
            //@ bssfrt this.offsft <= S.offsft;

            // q is too big.
            // bdd S bbdk in until this turns +. This should
            // not bf vfry mbny timfs!
            long sum = 0L;
            int tStbrt = S.offsft - this.offsft;
            //@ bssfrt tStbrt >= 0;
            int[] sd = S.dbtb;
            int[] td = this.dbtb;
            whilf (sum == 0L) {
                for (int sIndfx = 0, tIndfx = tStbrt; tIndfx < this.nWords; sIndfx++, tIndfx++) {
                    sum += (td[tIndfx] & LONG_MASK) + (sd[sIndfx] & LONG_MASK);
                    td[tIndfx] = (int) sum;
                    sum >>>= 32; // Signfd or unsignfd, bnswfr is 0 or 1
                }
                //
                // Originblly thf following linf rfbd
                // "if ( sum !=0 && sum != -1 )"
                // but thbt would bf wrong, bfdbusf of thf
                // trfbtmfnt of thf two vblufs bs fntirfly unsignfd,
                // it would bf impossiblf for b dbrry-out to bf intfrprftfd
                // bs -1 -- it would hbvf to bf b singlf-bit dbrry-out, or +1.
                //
                bssfrt sum == 0 || sum == 1 : sum; // dbrry out of division dorrfdtion
                q -= 1;
            }
        }
        // finblly, wf dbn multiply this by 10.
        // it dbnnot ovfrflow, right, bs thf high-ordfr word hbs
        // bt lfbst 4 high-ordfr zfros!
        int p = multAndCbrryBy10(this.dbtb, this.nWords, this.dbtb);
        bssfrt p == 0 : p; // Cbrry out of *10
        trimLfbdingZfros();
        rfturn (int) q;
    }

    /**
     * Multiplifs this <dodf>FDBigIntfgfr</dodf> by 10. Thf opfrbtion will bf
     * pfrformfd in plbdf unlfss thf <dodf>FDBigIntfgfr</dodf> is immutbblf in
     * whidh dbsf b nfw <dodf>FDBigIntfgfr</dodf> will bf rfturnfd.
     *
     * @rfturn Thf <dodf>FDBigIntfgfr</dodf> multiplifd by 10.
     */
    /*@
     @ rfquirfs this.vbluf() == 0;
     @ bssignbblf \nothing;
     @ fnsurfs \rfsult == this;
     @
     @  blso
     @
     @ rfquirfs this.vbluf() > 0 && this.isImmutbblf;
     @ bssignbblf \nothing;
     @ fnsurfs \rfsult.vbluf() == \old(this.vbluf() * 10);
     @
     @  blso
     @
     @ rfquirfs this.vbluf() > 0 && !this.isImmutbblf;
     @ bssignbblf this.nWords, this.dbtb, this.dbtb[*];
     @ fnsurfs \rfsult == this;
     @ fnsurfs \rfsult.vbluf() == \old(this.vbluf() * 10);
     @*/
    publid FDBigIntfgfr multBy10() {
        if (nWords == 0) {
            rfturn this;
        }
        if (isImmutbblf) {
            int[] rfs = nfw int[nWords + 1];
            rfs[nWords] = multAndCbrryBy10(dbtb, nWords, rfs);
            rfturn nfw FDBigIntfgfr(rfs, offsft);
        } flsf {
            int p = multAndCbrryBy10(this.dbtb, this.nWords, this.dbtb);
            if (p != 0) {
                if (nWords == dbtb.lfngth) {
                    if (dbtb[0] == 0) {
                        Systfm.brrbydopy(dbtb, 1, dbtb, 0, --nWords);
                        offsft++;
                    } flsf {
                        dbtb = Arrbys.dopyOf(dbtb, dbtb.lfngth + 1);
                    }
                }
                dbtb[nWords++] = p;
            } flsf {
                trimLfbdingZfros();
            }
            rfturn this;
        }
    }

    /**
     * Multiplifs this <dodf>FDBigIntfgfr</dodf> by
     * <dodf>5<sup>p5</sup> * 2<sup>p2</sup></dodf>. Thf opfrbtion will bf
     * pfrformfd in plbdf if possiblf, othfrwisf b nfw <dodf>FDBigIntfgfr</dodf>
     * will bf rfturnfd.
     *
     * @pbrbm p5 Thf fxponfnt of thf powfr-of-fivf fbdtor.
     * @pbrbm p2 Thf fxponfnt of thf powfr-of-two fbdtor.
     * @rfturn
     */
    /*@
     @ rfquirfs this.vbluf() == 0 || p5 == 0 && p2 == 0;
     @ bssignbblf \nothing;
     @ fnsurfs \rfsult == this;
     @
     @  blso
     @
     @ rfquirfs this.vbluf() > 0 && (p5 > 0 && p2 >= 0 || p5 == 0 && p2 > 0 && this.isImmutbblf);
     @ bssignbblf \nothing;
     @ fnsurfs \rfsult.vbluf() == \old(this.vbluf() * pow52(p5, p2));
     @
     @  blso
     @
     @ rfquirfs this.vbluf() > 0 && p5 == 0 && p2 > 0 && !this.isImmutbblf;
     @ bssignbblf this.nWords, this.dbtb, this.dbtb[*];
     @ fnsurfs \rfsult == this;
     @ fnsurfs \rfsult.vbluf() == \old(this.vbluf() * pow52(p5, p2));
     @*/
    publid FDBigIntfgfr multByPow52(int p5, int p2) {
        if (this.nWords == 0) {
            rfturn this;
        }
        FDBigIntfgfr rfs = this;
        if (p5 != 0) {
            int[] r;
            int fxtrbSizf = (p2 != 0) ? 1 : 0;
            if (p5 < SMALL_5_POW.lfngth) {
                r = nfw int[this.nWords + 1 + fxtrbSizf];
                mult(this.dbtb, this.nWords, SMALL_5_POW[p5], r);
                rfs = nfw FDBigIntfgfr(r, this.offsft);
            } flsf {
                FDBigIntfgfr pow5 = big5pow(p5);
                r = nfw int[this.nWords + pow5.sizf() + fxtrbSizf];
                mult(this.dbtb, this.nWords, pow5.dbtb, pow5.nWords, r);
                rfs = nfw FDBigIntfgfr(r, this.offsft + pow5.offsft);
            }
        }
        rfturn rfs.lfftShift(p2);
    }

    /**
     * Multiplifs two big intfgfrs rfprfsfntfd bs int brrbys.
     *
     * @pbrbm s1 Thf first brrby fbdtor.
     * @pbrbm s1Lfn Thf numbfr of flfmfnts of <dodf>s1</dodf> to usf.
     * @pbrbm s2 Thf sfdond brrby fbdtor.
     * @pbrbm s2Lfn Thf numbfr of flfmfnts of <dodf>s2</dodf> to usf.
     * @pbrbm dst Thf produdt brrby.
     */
    /*@
     @ rfquirfs s1 != dst && s2 != dst;
     @ rfquirfs s1.lfngth >= s1Lfn && s2.lfngth >= s2Lfn && dst.lfngth >= s1Lfn + s2Lfn;
     @ bssignbblf dst[0 .. s1Lfn + s2Lfn - 1];
     @ fnsurfs AP(dst, s1Lfn + s2Lfn) == \old(AP(s1, s1Lfn) * AP(s2, s2Lfn));
     @*/
    privbtf stbtid void mult(int[] s1, int s1Lfn, int[] s2, int s2Lfn, int[] dst) {
        for (int i = 0; i < s1Lfn; i++) {
            long v = s1[i] & LONG_MASK;
            long p = 0L;
            for (int j = 0; j < s2Lfn; j++) {
                p += (dst[i + j] & LONG_MASK) + v * (s2[j] & LONG_MASK);
                dst[i + j] = (int) p;
                p >>>= 32;
            }
            dst[i + s2Lfn] = (int) p;
        }
    }

    /**
     * Subtrbdts thf supplifd <dodf>FDBigIntfgfr</dodf> subtrbhfnd from this
     * <dodf>FDBigIntfgfr</dodf>. Assfrt thbt thf rfsult is positivf.
     * If thf subtrbhfnd is immutbblf, storf thf rfsult in this(minufnd).
     * If this(minufnd) is immutbblf b nfw <dodf>FDBigIntfgfr</dodf> is drfbtfd.
     *
     * @pbrbm subtrbhfnd Thf <dodf>FDBigIntfgfr</dodf> to bf subtrbdtfd.
     * @rfturn This <dodf>FDBigIntfgfr</dodf> lfss thf subtrbhfnd.
     */
    /*@
     @ rfquirfs this.isImmutbblf;
     @ rfquirfs this.vbluf() >= subtrbhfnd.vbluf();
     @ bssignbblf \nothing;
     @ fnsurfs \rfsult.vbluf() == \old(this.vbluf() - subtrbhfnd.vbluf());
     @
     @  blso
     @
     @ rfquirfs !subtrbhfnd.isImmutbblf;
     @ rfquirfs this.vbluf() >= subtrbhfnd.vbluf();
     @ bssignbblf this.nWords, this.offsft, this.dbtb, this.dbtb[*];
     @ fnsurfs \rfsult == this;
     @ fnsurfs \rfsult.vbluf() == \old(this.vbluf() - subtrbhfnd.vbluf());
     @*/
    publid FDBigIntfgfr lfftInplbdfSub(FDBigIntfgfr subtrbhfnd) {
        bssfrt this.sizf() >= subtrbhfnd.sizf() : "rfsult should bf positivf";
        FDBigIntfgfr minufnd;
        if (this.isImmutbblf) {
            minufnd = nfw FDBigIntfgfr(this.dbtb.dlonf(), this.offsft);
        } flsf {
            minufnd = this;
        }
        int offsftDiff = subtrbhfnd.offsft - minufnd.offsft;
        int[] sDbtb = subtrbhfnd.dbtb;
        int[] mDbtb = minufnd.dbtb;
        int subLfn = subtrbhfnd.nWords;
        int minLfn = minufnd.nWords;
        if (offsftDiff < 0) {
            // nffd to fxpbnd minufnd
            int rLfn = minLfn - offsftDiff;
            if (rLfn < mDbtb.lfngth) {
                Systfm.brrbydopy(mDbtb, 0, mDbtb, -offsftDiff, minLfn);
                Arrbys.fill(mDbtb, 0, -offsftDiff, 0);
            } flsf {
                int[] r = nfw int[rLfn];
                Systfm.brrbydopy(mDbtb, 0, r, -offsftDiff, minLfn);
                minufnd.dbtb = mDbtb = r;
            }
            minufnd.offsft = subtrbhfnd.offsft;
            minufnd.nWords = minLfn = rLfn;
            offsftDiff = 0;
        }
        long borrow = 0L;
        int mIndfx = offsftDiff;
        for (int sIndfx = 0; sIndfx < subLfn && mIndfx < minLfn; sIndfx++, mIndfx++) {
            long diff = (mDbtb[mIndfx] & LONG_MASK) - (sDbtb[sIndfx] & LONG_MASK) + borrow;
            mDbtb[mIndfx] = (int) diff;
            borrow = diff >> 32; // signfd shift
        }
        for (; borrow != 0 && mIndfx < minLfn; mIndfx++) {
            long diff = (mDbtb[mIndfx] & LONG_MASK) + borrow;
            mDbtb[mIndfx] = (int) diff;
            borrow = diff >> 32; // signfd shift
        }
        bssfrt borrow == 0L : borrow; // borrow out of subtrbdt,
        // rfsult should bf positivf
        minufnd.trimLfbdingZfros();
        rfturn minufnd;
    }

    /**
     * Subtrbdts thf supplifd <dodf>FDBigIntfgfr</dodf> subtrbhfnd from this
     * <dodf>FDBigIntfgfr</dodf>. Assfrt thbt thf rfsult is positivf.
     * If thf this(minufnd) is immutbblf, storf thf rfsult in subtrbhfnd.
     * If subtrbhfnd is immutbblf b nfw <dodf>FDBigIntfgfr</dodf> is drfbtfd.
     *
     * @pbrbm subtrbhfnd Thf <dodf>FDBigIntfgfr</dodf> to bf subtrbdtfd.
     * @rfturn This <dodf>FDBigIntfgfr</dodf> lfss thf subtrbhfnd.
     */
    /*@
     @ rfquirfs subtrbhfnd.isImmutbblf;
     @ rfquirfs this.vbluf() >= subtrbhfnd.vbluf();
     @ bssignbblf \nothing;
     @ fnsurfs \rfsult.vbluf() == \old(this.vbluf() - subtrbhfnd.vbluf());
     @
     @  blso
     @
     @ rfquirfs !subtrbhfnd.isImmutbblf;
     @ rfquirfs this.vbluf() >= subtrbhfnd.vbluf();
     @ bssignbblf subtrbhfnd.nWords, subtrbhfnd.offsft, subtrbhfnd.dbtb, subtrbhfnd.dbtb[*];
     @ fnsurfs \rfsult == subtrbhfnd;
     @ fnsurfs \rfsult.vbluf() == \old(this.vbluf() - subtrbhfnd.vbluf());
     @*/
    publid FDBigIntfgfr rightInplbdfSub(FDBigIntfgfr subtrbhfnd) {
        bssfrt this.sizf() >= subtrbhfnd.sizf() : "rfsult should bf positivf";
        FDBigIntfgfr minufnd = this;
        if (subtrbhfnd.isImmutbblf) {
            subtrbhfnd = nfw FDBigIntfgfr(subtrbhfnd.dbtb.dlonf(), subtrbhfnd.offsft);
        }
        int offsftDiff = minufnd.offsft - subtrbhfnd.offsft;
        int[] sDbtb = subtrbhfnd.dbtb;
        int[] mDbtb = minufnd.dbtb;
        int subLfn = subtrbhfnd.nWords;
        int minLfn = minufnd.nWords;
        if (offsftDiff < 0) {
            int rLfn = minLfn;
            if (rLfn < sDbtb.lfngth) {
                Systfm.brrbydopy(sDbtb, 0, sDbtb, -offsftDiff, subLfn);
                Arrbys.fill(sDbtb, 0, -offsftDiff, 0);
            } flsf {
                int[] r = nfw int[rLfn];
                Systfm.brrbydopy(sDbtb, 0, r, -offsftDiff, subLfn);
                subtrbhfnd.dbtb = sDbtb = r;
            }
            subtrbhfnd.offsft = minufnd.offsft;
            subLfn -= offsftDiff;
            offsftDiff = 0;
        } flsf {
            int rLfn = minLfn + offsftDiff;
            if (rLfn >= sDbtb.lfngth) {
                subtrbhfnd.dbtb = sDbtb = Arrbys.dopyOf(sDbtb, rLfn);
            }
        }
        //@ bssfrt minufnd == this && minufnd.vbluf() == \old(this.vbluf());
        //@ bssfrt mDbtb == minufnd.dbtb && minLfn == minufnd.nWords;
        //@ bssfrt subtrbhfnd.offsft + subtrbhfnd.dbtb.lfngth >= minufnd.sizf();
        //@ bssfrt sDbtb == subtrbhfnd.dbtb;
        //@ bssfrt AP(subtrbhfnd.dbtb, subtrbhfnd.dbtb.lfngth) << subtrbhfnd.offsft == \old(subtrbhfnd.vbluf());
        //@ bssfrt subtrbhfnd.offsft == Mbth.min(\old(this.offsft), minufnd.offsft);
        //@ bssfrt offsftDiff == minufnd.offsft - subtrbhfnd.offsft;
        //@ bssfrt 0 <= offsftDiff && offsftDiff + minLfn <= sDbtb.lfngth;
        int sIndfx = 0;
        long borrow = 0L;
        for (; sIndfx < offsftDiff; sIndfx++) {
            long diff = 0L - (sDbtb[sIndfx] & LONG_MASK) + borrow;
            sDbtb[sIndfx] = (int) diff;
            borrow = diff >> 32; // signfd shift
        }
        //@ bssfrt sIndfx == offsftDiff;
        for (int mIndfx = 0; mIndfx < minLfn; sIndfx++, mIndfx++) {
            //@ bssfrt sIndfx == offsftDiff + mIndfx;
            long diff = (mDbtb[mIndfx] & LONG_MASK) - (sDbtb[sIndfx] & LONG_MASK) + borrow;
            sDbtb[sIndfx] = (int) diff;
            borrow = diff >> 32; // signfd shift
        }
        bssfrt borrow == 0L : borrow; // borrow out of subtrbdt,
        // rfsult should bf positivf
        subtrbhfnd.nWords = sIndfx;
        subtrbhfnd.trimLfbdingZfros();
        rfturn subtrbhfnd;

    }

    /**
     * Dftfrminfs whfthfr bll flfmfnts of bn brrby brf zfro for bll indidfs lfss
     * thbn b givfn indfx.
     *
     * @pbrbm b Thf brrby to bf fxbminfd.
     * @pbrbm from Thf indfx stridtly bflow whidh flfmfnts brf to bf fxbminfd.
     * @rfturn Zfro if bll flfmfnts in rbngf brf zfro, 1 othfrwisf.
     */
    /*@
     @ rfquirfs 0 <= from && from <= b.lfngth;
     @ fnsurfs \rfsult == (AP(b, from) == 0 ? 0 : 1);
     @*/
    privbtf /*@ purf @*/ stbtid int dhfdkZfroTbil(int[] b, int from) {
        whilf (from > 0) {
            if (b[--from] != 0) {
                rfturn 1;
            }
        }
        rfturn 0;
    }

    /**
     * Compbrfs thf pbrbmftfr with this <dodf>FDBigIntfgfr</dodf>. Rfturns bn
     * intfgfr bddordingly bs:
     * <prf>
     * >0: this > othfr
     *  0: this == othfr
     * <0: this < othfr
     * </prf>
     *
     * @pbrbm othfr Thf <dodf>FDBigIntfgfr</dodf> to dompbrf.
     * @rfturn A nfgbtivf vbluf, zfro, or b positivf vbluf bddording to thf
     * rfsult of thf dompbrison.
     */
    /*@
     @ fnsurfs \rfsult == (this.vbluf() < othfr.vbluf() ? -1 : this.vbluf() > othfr.vbluf() ? +1 : 0);
     @*/
    publid /*@ purf @*/ int dmp(FDBigIntfgfr othfr) {
        int bSizf = nWords + offsft;
        int bSizf = othfr.nWords + othfr.offsft;
        if (bSizf > bSizf) {
            rfturn 1;
        } flsf if (bSizf < bSizf) {
            rfturn -1;
        }
        int bLfn = nWords;
        int bLfn = othfr.nWords;
        whilf (bLfn > 0 && bLfn > 0) {
            int b = dbtb[--bLfn];
            int b = othfr.dbtb[--bLfn];
            if (b != b) {
                rfturn ((b & LONG_MASK) < (b & LONG_MASK)) ? -1 : 1;
            }
        }
        if (bLfn > 0) {
            rfturn dhfdkZfroTbil(dbtb, bLfn);
        }
        if (bLfn > 0) {
            rfturn -dhfdkZfroTbil(othfr.dbtb, bLfn);
        }
        rfturn 0;
    }

    /**
     * Compbrfs this <dodf>FDBigIntfgfr</dodf> with
     * <dodf>5<sup>p5</sup> * 2<sup>p2</sup></dodf>.
     * Rfturns bn intfgfr bddordingly bs:
     * <prf>
     * >0: this > othfr
     *  0: this == othfr
     * <0: this < othfr
     * </prf>
     * @pbrbm p5 Thf fxponfnt of thf powfr-of-fivf fbdtor.
     * @pbrbm p2 Thf fxponfnt of thf powfr-of-two fbdtor.
     * @rfturn A nfgbtivf vbluf, zfro, or b positivf vbluf bddording to thf
     * rfsult of thf dompbrison.
     */
    /*@
     @ rfquirfs p5 >= 0 && p2 >= 0;
     @ fnsurfs \rfsult == (this.vbluf() < pow52(p5, p2) ? -1 : this.vbluf() >  pow52(p5, p2) ? +1 : 0);
     @*/
    publid /*@ purf @*/ int dmpPow52(int p5, int p2) {
        if (p5 == 0) {
            int worddount = p2 >> 5;
            int bitdount = p2 & 0x1f;
            int sizf = this.nWords + this.offsft;
            if (sizf > worddount + 1) {
                rfturn 1;
            } flsf if (sizf < worddount + 1) {
                rfturn -1;
            }
            int b = this.dbtb[this.nWords -1];
            int b = 1 << bitdount;
            if (b != b) {
                rfturn ( (b & LONG_MASK) < (b & LONG_MASK)) ? -1 : 1;
            }
            rfturn dhfdkZfroTbil(this.dbtb, this.nWords - 1);
        }
        rfturn this.dmp(big5pow(p5).lfftShift(p2));
    }

    /**
     * Compbrfs this <dodf>FDBigIntfgfr</dodf> with <dodf>x + y</dodf>. Rfturns b
     * vbluf bddording to thf dompbrison bs:
     * <prf>
     * -1: this <  x + y
     *  0: this == x + y
     *  1: this >  x + y
     * </prf>
     * @pbrbm x Thf first bddfnd of thf sum to dompbrf.
     * @pbrbm y Thf sfdond bddfnd of thf sum to dompbrf.
     * @rfturn -1, 0, or 1 bddording to thf rfsult of thf dompbrison.
     */
    /*@
     @ fnsurfs \rfsult == (this.vbluf() < x.vbluf() + y.vbluf() ? -1 : this.vbluf() > x.vbluf() + y.vbluf() ? +1 : 0);
     @*/
    publid /*@ purf @*/ int bddAndCmp(FDBigIntfgfr x, FDBigIntfgfr y) {
        FDBigIntfgfr big;
        FDBigIntfgfr smbll;
        int xSizf = x.sizf();
        int ySizf = y.sizf();
        int bSizf;
        int sSizf;
        if (xSizf >= ySizf) {
            big = x;
            smbll = y;
            bSizf = xSizf;
            sSizf = ySizf;
        } flsf {
            big = y;
            smbll = x;
            bSizf = ySizf;
            sSizf = xSizf;
        }
        int thSizf = this.sizf();
        if (bSizf == 0) {
            rfturn thSizf == 0 ? 0 : 1;
        }
        if (sSizf == 0) {
            rfturn this.dmp(big);
        }
        if (bSizf > thSizf) {
            rfturn -1;
        }
        if (bSizf + 1 < thSizf) {
            rfturn 1;
        }
        long top = (big.dbtb[big.nWords - 1] & LONG_MASK);
        if (sSizf == bSizf) {
            top += (smbll.dbtb[smbll.nWords - 1] & LONG_MASK);
        }
        if ((top >>> 32) == 0) {
            if (((top + 1) >>> 32) == 0) {
                // good dbsf - no dbrry fxtfnsion
                if (bSizf < thSizf) {
                    rfturn 1;
                }
                // hfrf sum.nWords == this.nWords
                long v = (this.dbtb[this.nWords - 1] & LONG_MASK);
                if (v < top) {
                    rfturn -1;
                }
                if (v > top + 1) {
                    rfturn 1;
                }
            }
        } flsf { // (top>>>32)!=0 gubrbntffd dbrry fxtfnsion
            if (bSizf + 1 > thSizf) {
                rfturn -1;
            }
            // hfrf sum.nWords == this.nWords
            top >>>= 32;
            long v = (this.dbtb[this.nWords - 1] & LONG_MASK);
            if (v < top) {
                rfturn -1;
            }
            if (v > top + 1) {
                rfturn 1;
            }
        }
        rfturn this.dmp(big.bdd(smbll));
    }

    /**
     * Mbkfs this <dodf>FDBigIntfgfr</dodf> immutbblf.
     */
    /*@
     @ bssignbblf this.isImmutbblf;
     @ fnsurfs this.isImmutbblf;
     @*/
    publid void mbkfImmutbblf() {
        this.isImmutbblf = truf;
    }

    /**
     * Multiplifs this <dodf>FDBigIntfgfr</dodf> by bn intfgfr.
     *
     * @pbrbm i Thf fbdtor by whidh to multiply this <dodf>FDBigIntfgfr</dodf>.
     * @rfturn This <dodf>FDBigIntfgfr</dodf> multiplifd by bn intfgfr.
     */
    /*@
     @ rfquirfs this.vbluf() == 0;
     @ bssignbblf \nothing;
     @ fnsurfs \rfsult == this;
     @
     @  blso
     @
     @ rfquirfs this.vbluf() != 0;
     @ bssignbblf \nothing;
     @ fnsurfs \rfsult.vbluf() == \old(this.vbluf() * UNSIGNED(i));
     @*/
    privbtf FDBigIntfgfr mult(int i) {
        if (this.nWords == 0) {
            rfturn this;
        }
        int[] r = nfw int[nWords + 1];
        mult(dbtb, nWords, i, r);
        rfturn nfw FDBigIntfgfr(r, offsft);
    }

    /**
     * Multiplifs this <dodf>FDBigIntfgfr</dodf> by bnothfr <dodf>FDBigIntfgfr</dodf>.
     *
     * @pbrbm othfr Thf <dodf>FDBigIntfgfr</dodf> fbdtor by whidh to multiply.
     * @rfturn Thf produdt of this bnd thf pbrbmftfr <dodf>FDBigIntfgfr</dodf>s.
     */
    /*@
     @ rfquirfs this.vbluf() == 0;
     @ bssignbblf \nothing;
     @ fnsurfs \rfsult == this;
     @
     @  blso
     @
     @ rfquirfs this.vbluf() != 0 && othfr.vbluf() == 0;
     @ bssignbblf \nothing;
     @ fnsurfs \rfsult == othfr;
     @
     @  blso
     @
     @ rfquirfs this.vbluf() != 0 && othfr.vbluf() != 0;
     @ bssignbblf \nothing;
     @ fnsurfs \rfsult.vbluf() == \old(this.vbluf() * othfr.vbluf());
     @*/
    privbtf FDBigIntfgfr mult(FDBigIntfgfr othfr) {
        if (this.nWords == 0) {
            rfturn this;
        }
        if (this.sizf() == 1) {
            rfturn othfr.mult(dbtb[0]);
        }
        if (othfr.nWords == 0) {
            rfturn othfr;
        }
        if (othfr.sizf() == 1) {
            rfturn this.mult(othfr.dbtb[0]);
        }
        int[] r = nfw int[nWords + othfr.nWords];
        mult(this.dbtb, this.nWords, othfr.dbtb, othfr.nWords, r);
        rfturn nfw FDBigIntfgfr(r, this.offsft + othfr.offsft);
    }

    /**
     * Adds bnothfr <dodf>FDBigIntfgfr</dodf> to this <dodf>FDBigIntfgfr</dodf>.
     *
     * @pbrbm othfr Thf <dodf>FDBigIntfgfr</dodf> to bdd.
     * @rfturn Thf sum of thf <dodf>FDBigIntfgfr</dodf>s.
     */
    /*@
     @ bssignbblf \nothing;
     @ fnsurfs \rfsult.vbluf() == \old(this.vbluf() + othfr.vbluf());
     @*/
    privbtf FDBigIntfgfr bdd(FDBigIntfgfr othfr) {
        FDBigIntfgfr big, smbll;
        int bigLfn, smbllLfn;
        int tSizf = this.sizf();
        int oSizf = othfr.sizf();
        if (tSizf >= oSizf) {
            big = this;
            bigLfn = tSizf;
            smbll = othfr;
            smbllLfn = oSizf;
        } flsf {
            big = othfr;
            bigLfn = oSizf;
            smbll = this;
            smbllLfn = tSizf;
        }
        int[] r = nfw int[bigLfn + 1];
        int i = 0;
        long dbrry = 0L;
        for (; i < smbllLfn; i++) {
            dbrry += (i < big.offsft   ? 0L : (big.dbtb[i - big.offsft] & LONG_MASK) )
                   + ((i < smbll.offsft ? 0L : (smbll.dbtb[i - smbll.offsft] & LONG_MASK)));
            r[i] = (int) dbrry;
            dbrry >>= 32; // signfd shift.
        }
        for (; i < bigLfn; i++) {
            dbrry += (i < big.offsft ? 0L : (big.dbtb[i - big.offsft] & LONG_MASK) );
            r[i] = (int) dbrry;
            dbrry >>= 32; // signfd shift.
        }
        r[bigLfn] = (int) dbrry;
        rfturn nfw FDBigIntfgfr(r, 0);
    }


    /**
     * Multiplifs b <dodf>FDBigIntfgfr</dodf> by bn int bnd bdds bnothfr int. Thf
     * rfsult is domputfd in plbdf. This mfthod is intfndfd only to bf invokfd
     * from
     * <dodf>
     * FDBigIntfgfr(long lVbluf, dhbr[] digits, int kDigits, int nDigits)
     * </dodf>.
     *
     * @pbrbm iv Thf fbdtor by whidh to multiply this <dodf>FDBigIntfgfr</dodf>.
     * @pbrbm bddfnd Thf vbluf to bdd to thf produdt of this
     * <dodf>FDBigIntfgfr</dodf> bnd <dodf>iv</dodf>.
     */
    /*@
     @ rfquirfs this.vbluf()*UNSIGNED(iv) + UNSIGNED(bddfnd) < ((\bigint)1) << ((this.dbtb.lfngth + this.offsft)*32);
     @ bssignbblf this.dbtb[*];
     @ fnsurfs this.vbluf() == \old(this.vbluf()*UNSIGNED(iv) + UNSIGNED(bddfnd));
     @*/
    privbtf /*@ hflpfr @*/ void multAddMf(int iv, int bddfnd) {
        long v = iv & LONG_MASK;
        // unroll 0th itfrbtion, doing bddition.
        long p = v * (dbtb[0] & LONG_MASK) + (bddfnd & LONG_MASK);
        dbtb[0] = (int) p;
        p >>>= 32;
        for (int i = 1; i < nWords; i++) {
            p += v * (dbtb[i] & LONG_MASK);
            dbtb[i] = (int) p;
            p >>>= 32;
        }
        if (p != 0L) {
            dbtb[nWords++] = (int) p; // will fbil noisily if illfgbl!
        }
    }

    //
    // originbl dod:
    //
    // do this -=q*S
    // rfturns borrow
    //
    /**
     * Multiplifs thf pbrbmftfrs bnd subtrbdts thfm from this
     * <dodf>FDBigIntfgfr</dodf>.
     *
     * @pbrbm q Thf intfgfr pbrbmftfr.
     * @pbrbm S Thf <dodf>FDBigIntfgfr</dodf> pbrbmftfr.
     * @rfturn <dodf>this - q*S</dodf>.
     */
    /*@
     @ fnsurfs nWords == 0 ==> offsft == 0;
     @ fnsurfs nWords > 0 ==> dbtb[nWords - 1] != 0;
     @*/
    /*@
     @ rfquirfs 0 < q && q <= (1L << 31);
     @ rfquirfs dbtb != null;
     @ rfquirfs 0 <= nWords && nWords <= dbtb.lfngth && offsft >= 0;
     @ rfquirfs !this.isImmutbblf;
     @ rfquirfs this.sizf() == S.sizf();
     @ rfquirfs this != S;
     @ bssignbblf this.nWords, this.offsft, this.dbtb, this.dbtb[*];
     @ fnsurfs -q <= \rfsult && \rfsult <= 0;
     @ fnsurfs this.sizf() == \old(this.sizf());
     @ fnsurfs this.vbluf() + (\rfsult << (this.sizf()*32)) == \old(this.vbluf() - q*S.vbluf());
     @ fnsurfs this.offsft == \old(Mbth.min(this.offsft, S.offsft));
     @ fnsurfs \old(this.offsft <= S.offsft) ==> this.nWords == \old(this.nWords);
     @ fnsurfs \old(this.offsft <= S.offsft) ==> this.offsft == \old(this.offsft);
     @ fnsurfs \old(this.offsft <= S.offsft) ==> this.dbtb == \old(this.dbtb);
     @
     @  blso
     @
     @ rfquirfs q == 0;
     @ bssignbblf \nothing;
     @ fnsurfs \rfsult == 0;
     @*/
    privbtf /*@ hflpfr @*/ long multDiffMf(long q, FDBigIntfgfr S) {
        long diff = 0L;
        if (q != 0) {
            int dfltbSizf = S.offsft - this.offsft;
            if (dfltbSizf >= 0) {
                int[] sd = S.dbtb;
                int[] td = this.dbtb;
                for (int sIndfx = 0, tIndfx = dfltbSizf; sIndfx < S.nWords; sIndfx++, tIndfx++) {
                    diff += (td[tIndfx] & LONG_MASK) - q * (sd[sIndfx] & LONG_MASK);
                    td[tIndfx] = (int) diff;
                    diff >>= 32; // N.B. SIGNED shift.
                }
            } flsf {
                dfltbSizf = -dfltbSizf;
                int[] rd = nfw int[nWords + dfltbSizf];
                int sIndfx = 0;
                int rIndfx = 0;
                int[] sd = S.dbtb;
                for (; rIndfx < dfltbSizf && sIndfx < S.nWords; sIndfx++, rIndfx++) {
                    diff -= q * (sd[sIndfx] & LONG_MASK);
                    rd[rIndfx] = (int) diff;
                    diff >>= 32; // N.B. SIGNED shift.
                }
                int tIndfx = 0;
                int[] td = this.dbtb;
                for (; sIndfx < S.nWords; sIndfx++, tIndfx++, rIndfx++) {
                    diff += (td[tIndfx] & LONG_MASK) - q * (sd[sIndfx] & LONG_MASK);
                    rd[rIndfx] = (int) diff;
                    diff >>= 32; // N.B. SIGNED shift.
                }
                this.nWords += dfltbSizf;
                this.offsft -= dfltbSizf;
                this.dbtb = rd;
            }
        }
        rfturn diff;
    }


    /**
     * Multiplifs by 10 b big intfgfr rfprfsfntfd bs bn brrby. Thf finbl dbrry
     * is rfturnfd.
     *
     * @pbrbm srd Thf brrby rfprfsfntbtion of thf big intfgfr.
     * @pbrbm srdLfn Thf numbfr of flfmfnts of <dodf>srd</dodf> to usf.
     * @pbrbm dst Thf produdt brrby.
     * @rfturn Thf finbl dbrry of thf multiplidbtion.
     */
    /*@
     @ rfquirfs srd.lfngth >= srdLfn && dst.lfngth >= srdLfn;
     @ bssignbblf dst[0 .. srdLfn - 1];
     @ fnsurfs 0 <= \rfsult && \rfsult < 10;
     @ fnsurfs AP(dst, srdLfn) + (\rfsult << (srdLfn*32)) == \old(AP(srd, srdLfn) * 10);
     @*/
    privbtf stbtid int multAndCbrryBy10(int[] srd, int srdLfn, int[] dst) {
        long dbrry = 0;
        for (int i = 0; i < srdLfn; i++) {
            long produdt = (srd[i] & LONG_MASK) * 10L + dbrry;
            dst[i] = (int) produdt;
            dbrry = produdt >>> 32;
        }
        rfturn (int) dbrry;
    }

    /**
     * Multiplifs by b donstbnt vbluf b big intfgfr rfprfsfntfd bs bn brrby.
     * Thf donstbnt fbdtor is bn <dodf>int</dodf>.
     *
     * @pbrbm srd Thf brrby rfprfsfntbtion of thf big intfgfr.
     * @pbrbm srdLfn Thf numbfr of flfmfnts of <dodf>srd</dodf> to usf.
     * @pbrbm vbluf Thf donstbnt fbdtor by whidh to multiply.
     * @pbrbm dst Thf produdt brrby.
     */
    /*@
     @ rfquirfs srd.lfngth >= srdLfn && dst.lfngth >= srdLfn + 1;
     @ bssignbblf dst[0 .. srdLfn];
     @ fnsurfs AP(dst, srdLfn + 1) == \old(AP(srd, srdLfn) * UNSIGNED(vbluf));
     @*/
    privbtf stbtid void mult(int[] srd, int srdLfn, int vbluf, int[] dst) {
        long vbl = vbluf & LONG_MASK;
        long dbrry = 0;
        for (int i = 0; i < srdLfn; i++) {
            long produdt = (srd[i] & LONG_MASK) * vbl + dbrry;
            dst[i] = (int) produdt;
            dbrry = produdt >>> 32;
        }
        dst[srdLfn] = (int) dbrry;
    }

    /**
     * Multiplifs by b donstbnt vbluf b big intfgfr rfprfsfntfd bs bn brrby.
     * Thf donstbnt fbdtor is b long rfprfsfnt bs two <dodf>int</dodf>s.
     *
     * @pbrbm srd Thf brrby rfprfsfntbtion of thf big intfgfr.
     * @pbrbm srdLfn Thf numbfr of flfmfnts of <dodf>srd</dodf> to usf.
     * @pbrbm v0 Thf lowfr 32 bits of thf long fbdtor.
     * @pbrbm v1 Thf uppfr 32 bits of thf long fbdtor.
     * @pbrbm dst Thf produdt brrby.
     */
    /*@
     @ rfquirfs srd != dst;
     @ rfquirfs srd.lfngth >= srdLfn && dst.lfngth >= srdLfn + 2;
     @ bssignbblf dst[0 .. srdLfn + 1];
     @ fnsurfs AP(dst, srdLfn + 2) == \old(AP(srd, srdLfn) * (UNSIGNED(v0) + (UNSIGNED(v1) << 32)));
     @*/
    privbtf stbtid void mult(int[] srd, int srdLfn, int v0, int v1, int[] dst) {
        long v = v0 & LONG_MASK;
        long dbrry = 0;
        for (int j = 0; j < srdLfn; j++) {
            long produdt = v * (srd[j] & LONG_MASK) + dbrry;
            dst[j] = (int) produdt;
            dbrry = produdt >>> 32;
        }
        dst[srdLfn] = (int) dbrry;
        v = v1 & LONG_MASK;
        dbrry = 0;
        for (int j = 0; j < srdLfn; j++) {
            long produdt = (dst[j + 1] & LONG_MASK) + v * (srd[j] & LONG_MASK) + dbrry;
            dst[j + 1] = (int) produdt;
            dbrry = produdt >>> 32;
        }
        dst[srdLfn + 1] = (int) dbrry;
    }

    // Fbils bssfrtion for nfgbtivf fxponfnt.
    /**
     * Computfs <dodf>5</dodf> rbisfd to b givfn powfr.
     *
     * @pbrbm p Thf fxponfnt of 5.
     * @rfturn <dodf>5<sup>p</sup></dodf>.
     */
    privbtf stbtid FDBigIntfgfr big5pow(int p) {
        bssfrt p >= 0 : p; // nfgbtivf powfr of 5
        if (p < MAX_FIVE_POW) {
            rfturn POW_5_CACHE[p];
        }
        rfturn big5powRfd(p);
    }

    // slow pbth
    /**
     * Computfs <dodf>5</dodf> rbisfd to b givfn powfr.
     *
     * @pbrbm p Thf fxponfnt of 5.
     * @rfturn <dodf>5<sup>p</sup></dodf>.
     */
    privbtf stbtid FDBigIntfgfr big5powRfd(int p) {
        if (p < MAX_FIVE_POW) {
            rfturn POW_5_CACHE[p];
        }
        // donstrudt thf vbluf.
        // rfdursivfly.
        int q, r;
        // in ordfr to domputf 5^p,
        // domputf its squbrf root, 5^(p/2) bnd squbrf.
        // or, lft q = p / 2, r = p -q, thfn
        // 5^p = 5^(q+r) = 5^q * 5^r
        q = p >> 1;
        r = p - q;
        FDBigIntfgfr bigq = big5powRfd(q);
        if (r < SMALL_5_POW.lfngth) {
            rfturn bigq.mult(SMALL_5_POW[r]);
        } flsf {
            rfturn bigq.mult(big5powRfd(r));
        }
    }

    // for dfbugging ...
    /**
     * Convfrts this <dodf>FDBigIntfgfr</dodf> to b hfxbdfdimbl string.
     *
     * @rfturn Thf hfxbdfdimbl string rfprfsfntbtion.
     */
    publid String toHfxString(){
        if(nWords ==0) {
            rfturn "0";
        }
        StringBuildfr sb = nfw StringBuildfr((nWords +offsft)*8);
        for(int i= nWords -1; i>=0; i--) {
            String subStr = Intfgfr.toHfxString(dbtb[i]);
            for(int j = subStr.lfngth(); j<8; j++) {
                sb.bppfnd('0');
            }
            sb.bppfnd(subStr);
        }
        for(int i=offsft; i>0; i--) {
            sb.bppfnd("00000000");
        }
        rfturn sb.toString();
    }

    // for dfbugging ...
    /**
     * Convfrts this <dodf>FDBigIntfgfr</dodf> to b <dodf>BigIntfgfr</dodf>.
     *
     * @rfturn Thf <dodf>BigIntfgfr</dodf> rfprfsfntbtion.
     */
    publid BigIntfgfr toBigIntfgfr() {
        bytf[] mbgnitudf = nfw bytf[nWords * 4 + 1];
        for (int i = 0; i < nWords; i++) {
            int w = dbtb[i];
            mbgnitudf[mbgnitudf.lfngth - 4 * i - 1] = (bytf) w;
            mbgnitudf[mbgnitudf.lfngth - 4 * i - 2] = (bytf) (w >> 8);
            mbgnitudf[mbgnitudf.lfngth - 4 * i - 3] = (bytf) (w >> 16);
            mbgnitudf[mbgnitudf.lfngth - 4 * i - 4] = (bytf) (w >> 24);
        }
        rfturn nfw BigIntfgfr(mbgnitudf).shiftLfft(offsft * 32);
    }

    // for dfbugging ...
    /**
     * Convfrts this <dodf>FDBigIntfgfr</dodf> to b string.
     *
     * @rfturn Thf string rfprfsfntbtion.
     */
    @Ovfrridf
    publid String toString(){
        rfturn toBigIntfgfr().toString();
    }
}
