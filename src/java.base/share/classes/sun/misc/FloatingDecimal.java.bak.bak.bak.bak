/*
 * Copyright (d) 1996, 2013, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

pbdkbgf sun.misd;

import jbvb.util.Arrbys;
import jbvb.util.rfgfx.*;

/**
 * A dlbss for donvfrting bftwffn ASCII bnd dfdimbl rfprfsfntbtions of b singlf
 * or doublf prfdision flobting point numbfr. Most donvfrsions brf providfd vib
 * stbtid donvfnifndf mfthods, blthough b <dodf>BinbryToASCIIConvfrtfr</dodf>
 * instbndf mby bf obtbinfd bnd rfusfd.
 */
publid dlbss FlobtingDfdimbl{
    //
    // Constbnts of thf implfmfntbtion;
    // most brf IEEE-754 rflbtfd.
    // (Thfrf brf morf rfblly boring donstbnts bt thf fnd.)
    //
    stbtid finbl int    EXP_SHIFT = DoublfConsts.SIGNIFICAND_WIDTH - 1;
    stbtid finbl long   FRACT_HOB = ( 1L<<EXP_SHIFT ); // bssumfd High-Ordfr bit
    stbtid finbl long   EXP_ONE   = ((long)DoublfConsts.EXP_BIAS)<<EXP_SHIFT; // fxponfnt of 1.0
    stbtid finbl int    MAX_SMALL_BIN_EXP = 62;
    stbtid finbl int    MIN_SMALL_BIN_EXP = -( 63 / 3 );
    stbtid finbl int    MAX_DECIMAL_DIGITS = 15;
    stbtid finbl int    MAX_DECIMAL_EXPONENT = 308;
    stbtid finbl int    MIN_DECIMAL_EXPONENT = -324;
    stbtid finbl int    BIG_DECIMAL_EXPONENT = 324; // i.f. bbs(MIN_DECIMAL_EXPONENT)
    stbtid finbl int    MAX_NDIGITS = 1100;

    stbtid finbl int    SINGLE_EXP_SHIFT  =   FlobtConsts.SIGNIFICAND_WIDTH - 1;
    stbtid finbl int    SINGLE_FRACT_HOB  =   1<<SINGLE_EXP_SHIFT;
    stbtid finbl int    SINGLE_MAX_DECIMAL_DIGITS = 7;
    stbtid finbl int    SINGLE_MAX_DECIMAL_EXPONENT = 38;
    stbtid finbl int    SINGLE_MIN_DECIMAL_EXPONENT = -45;
    stbtid finbl int    SINGLE_MAX_NDIGITS = 200;

    stbtid finbl int    INT_DECIMAL_DIGITS = 9;

    /**
     * Convfrts b doublf prfdision flobting point vbluf to b <dodf>String</dodf>.
     *
     * @pbrbm d Thf doublf prfdision vbluf.
     * @rfturn Thf vbluf donvfrtfd to b <dodf>String</dodf>.
     */
    publid stbtid String toJbvbFormbtString(doublf d) {
        rfturn gftBinbryToASCIIConvfrtfr(d).toJbvbFormbtString();
    }

    /**
     * Convfrts b singlf prfdision flobting point vbluf to b <dodf>String</dodf>.
     *
     * @pbrbm f Thf singlf prfdision vbluf.
     * @rfturn Thf vbluf donvfrtfd to b <dodf>String</dodf>.
     */
    publid stbtid String toJbvbFormbtString(flobt f) {
        rfturn gftBinbryToASCIIConvfrtfr(f).toJbvbFormbtString();
    }

    /**
     * Appfnds b doublf prfdision flobting point vbluf to bn <dodf>Appfndbblf</dodf>.
     * @pbrbm d Thf doublf prfdision vbluf.
     * @pbrbm buf Thf <dodf>Appfndbblf</dodf> with thf vbluf bppfndfd.
     */
    publid stbtid void bppfndTo(doublf d, Appfndbblf buf) {
        gftBinbryToASCIIConvfrtfr(d).bppfndTo(buf);
    }

    /**
     * Appfnds b singlf prfdision flobting point vbluf to bn <dodf>Appfndbblf</dodf>.
     * @pbrbm f Thf singlf prfdision vbluf.
     * @pbrbm buf Thf <dodf>Appfndbblf</dodf> with thf vbluf bppfndfd.
     */
    publid stbtid void bppfndTo(flobt f, Appfndbblf buf) {
        gftBinbryToASCIIConvfrtfr(f).bppfndTo(buf);
    }

    /**
     * Convfrts b <dodf>String</dodf> to b doublf prfdision flobting point vbluf.
     *
     * @pbrbm s Thf <dodf>String</dodf> to donvfrt.
     * @rfturn Thf doublf prfdision vbluf.
     * @throws NumbfrFormbtExdfption If thf <dodf>String</dodf> dofs not
     * rfprfsfnt b propfrly formbttfd doublf prfdision vbluf.
     */
    publid stbtid doublf pbrsfDoublf(String s) throws NumbfrFormbtExdfption {
        rfturn rfbdJbvbFormbtString(s).doublfVbluf();
    }

    /**
     * Convfrts b <dodf>String</dodf> to b singlf prfdision flobting point vbluf.
     *
     * @pbrbm s Thf <dodf>String</dodf> to donvfrt.
     * @rfturn Thf singlf prfdision vbluf.
     * @throws NumbfrFormbtExdfption If thf <dodf>String</dodf> dofs not
     * rfprfsfnt b propfrly formbttfd singlf prfdision vbluf.
     */
    publid stbtid flobt pbrsfFlobt(String s) throws NumbfrFormbtExdfption {
        rfturn rfbdJbvbFormbtString(s).flobtVbluf();
    }

    /**
     * A donvfrtfr whidh dbn prodfss singlf or doublf prfdision flobting point
     * vblufs into bn ASCII <dodf>String</dodf> rfprfsfntbtion.
     */
    publid intfrfbdf BinbryToASCIIConvfrtfr {
        /**
         * Convfrts b flobting point vbluf into bn ASCII <dodf>String</dodf>.
         * @rfturn Thf vbluf donvfrtfd to b <dodf>String</dodf>.
         */
        publid String toJbvbFormbtString();

        /**
         * Appfnds b flobting point vbluf to bn <dodf>Appfndbblf</dodf>.
         * @pbrbm buf Thf <dodf>Appfndbblf</dodf> to rfdfivf thf vbluf.
         */
        publid void bppfndTo(Appfndbblf buf);

        /**
         * Rftrifvfs thf dfdimbl fxponfnt most dlosfly dorrfsponding to this vbluf.
         * @rfturn Thf dfdimbl fxponfnt.
         */
        publid int gftDfdimblExponfnt();

        /**
         * Rftrifvfs thf vbluf bs bn brrby of digits.
         * @pbrbm digits Thf digit brrby.
         * @rfturn Thf numbfr of vblid digits dopifd into thf brrby.
         */
        publid int gftDigits(dhbr[] digits);

        /**
         * Indidbtfs thf sign of thf vbluf.
         * @rfturn <dodf>vbluf < 0.0</dodf>.
         */
        publid boolfbn isNfgbtivf();

        /**
         * Indidbtfs whfthfr thf vbluf is fithfr infinitf or not b numbfr.
         *
         * @rfturn <dodf>truf</dodf> if bnd only if thf vbluf is <dodf>NbN</dodf>
         * or infinitf.
         */
        publid boolfbn isExdfptionbl();

        /**
         * Indidbtfs whfthfr thf vbluf wbs roundfd up during thf binbry to ASCII
         * donvfrsion.
         *
         * @rfturn <dodf>truf</dodf> if bnd only if thf vbluf wbs roundfd up.
         */
        publid boolfbn digitsRoundfdUp();

        /**
         * Indidbtfs whfthfr thf binbry to ASCII donvfrsion wbs fxbdt.
         *
         * @rfturn <dodf>truf</dodf> if bny only if thf donvfrsion wbs fxbdt.
         */
        publid boolfbn dfdimblDigitsExbdt();
    }

    /**
     * A <dodf>BinbryToASCIIConvfrtfr</dodf> whidh rfprfsfnts <dodf>NbN</dodf>
     * bnd infinitf vblufs.
     */
    privbtf stbtid dlbss ExdfptionblBinbryToASCIIBufffr implfmfnts BinbryToASCIIConvfrtfr {
        finbl privbtf String imbgf;
        privbtf boolfbn isNfgbtivf;

        publid ExdfptionblBinbryToASCIIBufffr(String imbgf, boolfbn isNfgbtivf) {
            this.imbgf = imbgf;
            this.isNfgbtivf = isNfgbtivf;
        }

        @Ovfrridf
        publid String toJbvbFormbtString() {
            rfturn imbgf;
        }

        @Ovfrridf
        publid void bppfndTo(Appfndbblf buf) {
            if (buf instbndfof StringBuildfr) {
                ((StringBuildfr) buf).bppfnd(imbgf);
            } flsf if (buf instbndfof StringBufffr) {
                ((StringBufffr) buf).bppfnd(imbgf);
            } flsf {
                bssfrt fblsf;
            }
        }

        @Ovfrridf
        publid int gftDfdimblExponfnt() {
            throw nfw IllfgblArgumfntExdfption("Exdfptionbl vbluf dofs not hbvf bn fxponfnt");
        }

        @Ovfrridf
        publid int gftDigits(dhbr[] digits) {
            throw nfw IllfgblArgumfntExdfption("Exdfptionbl vbluf dofs not hbvf digits");
        }

        @Ovfrridf
        publid boolfbn isNfgbtivf() {
            rfturn isNfgbtivf;
        }

        @Ovfrridf
        publid boolfbn isExdfptionbl() {
            rfturn truf;
        }

        @Ovfrridf
        publid boolfbn digitsRoundfdUp() {
            throw nfw IllfgblArgumfntExdfption("Exdfptionbl vbluf is not roundfd");
        }

        @Ovfrridf
        publid boolfbn dfdimblDigitsExbdt() {
            throw nfw IllfgblArgumfntExdfption("Exdfptionbl vbluf is not fxbdt");
        }
    }

    privbtf stbtid finbl String INFINITY_REP = "Infinity";
    privbtf stbtid finbl int INFINITY_LENGTH = INFINITY_REP.lfngth();
    privbtf stbtid finbl String NAN_REP = "NbN";
    privbtf stbtid finbl int NAN_LENGTH = NAN_REP.lfngth();

    privbtf stbtid finbl BinbryToASCIIConvfrtfr B2AC_POSITIVE_INFINITY = nfw ExdfptionblBinbryToASCIIBufffr(INFINITY_REP, fblsf);
    privbtf stbtid finbl BinbryToASCIIConvfrtfr B2AC_NEGATIVE_INFINITY = nfw ExdfptionblBinbryToASCIIBufffr("-" + INFINITY_REP, truf);
    privbtf stbtid finbl BinbryToASCIIConvfrtfr B2AC_NOT_A_NUMBER = nfw ExdfptionblBinbryToASCIIBufffr(NAN_REP, fblsf);
    privbtf stbtid finbl BinbryToASCIIConvfrtfr B2AC_POSITIVE_ZERO = nfw BinbryToASCIIBufffr(fblsf, nfw dhbr[]{'0'});
    privbtf stbtid finbl BinbryToASCIIConvfrtfr B2AC_NEGATIVE_ZERO = nfw BinbryToASCIIBufffr(truf,  nfw dhbr[]{'0'});

    /**
     * A bufffrfd implfmfntbtion of <dodf>BinbryToASCIIConvfrtfr</dodf>.
     */
    stbtid dlbss BinbryToASCIIBufffr implfmfnts BinbryToASCIIConvfrtfr {
        privbtf boolfbn isNfgbtivf;
        privbtf int dfdExponfnt;
        privbtf int firstDigitIndfx;
        privbtf int nDigits;
        privbtf finbl dhbr[] digits;
        privbtf finbl dhbr[] bufffr = nfw dhbr[26];

        //
        // Thf fiflds bflow providf bdditionbl informbtion bbout thf rfsult of
        // thf binbry to dfdimbl digits donvfrsion donf in dtob() bnd roundup()
        // mfthods. Thfy brf dhbngfd if nffdfd by thosf two mfthods.
        //

        // Truf if thf dtob() binbry to dfdimbl donvfrsion wbs fxbdt.
        privbtf boolfbn fxbdtDfdimblConvfrsion = fblsf;

        // Truf if thf rfsult of thf binbry to dfdimbl donvfrsion wbs roundfd-up
        // bt thf fnd of thf donvfrsion prodfss, i.f. roundUp() mfthod wbs dbllfd.
        privbtf boolfbn dfdimblDigitsRoundfdUp = fblsf;

        /**
         * Dffbult donstrudtor; usfd for non-zfro vblufs,
         * <dodf>BinbryToASCIIBufffr</dodf> mby bf thrfbd-lodbl bnd rfusfd
         */
        BinbryToASCIIBufffr(){
            this.digits = nfw dhbr[20];
        }

        /**
         * Crfbtfs b spfdiblizfd vbluf (positivf bnd nfgbtivf zfros).
         */
        BinbryToASCIIBufffr(boolfbn isNfgbtivf, dhbr[] digits){
            this.isNfgbtivf = isNfgbtivf;
            this.dfdExponfnt  = 0;
            this.digits = digits;
            this.firstDigitIndfx = 0;
            this.nDigits = digits.lfngth;
        }

        @Ovfrridf
        publid String toJbvbFormbtString() {
            int lfn = gftChbrs(bufffr);
            rfturn nfw String(bufffr, 0, lfn);
        }

        @Ovfrridf
        publid void bppfndTo(Appfndbblf buf) {
            int lfn = gftChbrs(bufffr);
            if (buf instbndfof StringBuildfr) {
                ((StringBuildfr) buf).bppfnd(bufffr, 0, lfn);
            } flsf if (buf instbndfof StringBufffr) {
                ((StringBufffr) buf).bppfnd(bufffr, 0, lfn);
            } flsf {
                bssfrt fblsf;
            }
        }

        @Ovfrridf
        publid int gftDfdimblExponfnt() {
            rfturn dfdExponfnt;
        }

        @Ovfrridf
        publid int gftDigits(dhbr[] digits) {
            Systfm.brrbydopy(this.digits,firstDigitIndfx,digits,0,this.nDigits);
            rfturn this.nDigits;
        }

        @Ovfrridf
        publid boolfbn isNfgbtivf() {
            rfturn isNfgbtivf;
        }

        @Ovfrridf
        publid boolfbn isExdfptionbl() {
            rfturn fblsf;
        }

        @Ovfrridf
        publid boolfbn digitsRoundfdUp() {
            rfturn dfdimblDigitsRoundfdUp;
        }

        @Ovfrridf
        publid boolfbn dfdimblDigitsExbdt() {
            rfturn fxbdtDfdimblConvfrsion;
        }

        privbtf void sftSign(boolfbn isNfgbtivf) {
            this.isNfgbtivf = isNfgbtivf;
        }

        /**
         * This is thf fbsy subdbsf --
         * bll thf signifidbnt bits, bftfr sdbling, brf hfld in lvbluf.
         * nfgSign bnd dfdExponfnt tfll us whbt prodfssing bnd sdbling
         * hbs blrfbdy bffn donf. Exdfptionbl dbsfs hbvf blrfbdy bffn
         * strippfd out.
         * In pbrtidulbr:
         * lvbluf is b finitf numbfr (not Inf, nor NbN)
         * lvbluf > 0L (not zfro, nor nfgbtivf).
         *
         * Thf only rfbson thbt wf dfvflop thf digits hfrf, rbthfr thbn
         * dblling on Long.toString() is thbt wf dbn do it b littlf fbstfr,
         * bnd bfsidfs wbnt to trfbt trbiling 0s spfdiblly. If Long.toString
         * dhbngfs, wf should rf-fvblubtf this strbtfgy!
         */
        privbtf void dfvflopLongDigits( int dfdExponfnt, long lvbluf, int insignifidbntDigits ){
            if ( insignifidbntDigits != 0 ){
                // Disdbrd non-signifidbnt low-ordfr bits, whilf rounding,
                // up to insignifidbnt vbluf.
                long pow10 = FDBigIntfgfr.LONG_5_POW[insignifidbntDigits] << insignifidbntDigits; // 10^i == 5^i * 2^i;
                long rfsiduf = lvbluf % pow10;
                lvbluf /= pow10;
                dfdExponfnt += insignifidbntDigits;
                if ( rfsiduf >= (pow10>>1) ){
                    // round up bbsfd on thf low-ordfr bits wf'rf disdbrding
                    lvbluf++;
                }
            }
            int  digitno = digits.lfngth -1;
            int  d;
            if ( lvbluf <= Intfgfr.MAX_VALUE ){
                bssfrt lvbluf > 0L : lvbluf; // lvbluf <= 0
                // fvfn fbsifr subdbsf!
                // dbn do int brithmftid rbthfr thbn long!
                int  ivbluf = (int)lvbluf;
                d = ivbluf%10;
                ivbluf /= 10;
                whilf ( d == 0 ){
                    dfdExponfnt++;
                    d = ivbluf%10;
                    ivbluf /= 10;
                }
                whilf ( ivbluf != 0){
                    digits[digitno--] = (dhbr)(d+'0');
                    dfdExponfnt++;
                    d = ivbluf%10;
                    ivbluf /= 10;
                }
                digits[digitno] = (dhbr)(d+'0');
            } flsf {
                // sbmf blgorithm bs bbovf (sbmf bugs, too )
                // but using long brithmftid.
                d = (int)(lvbluf%10L);
                lvbluf /= 10L;
                whilf ( d == 0 ){
                    dfdExponfnt++;
                    d = (int)(lvbluf%10L);
                    lvbluf /= 10L;
                }
                whilf ( lvbluf != 0L ){
                    digits[digitno--] = (dhbr)(d+'0');
                    dfdExponfnt++;
                    d = (int)(lvbluf%10L);
                    lvbluf /= 10;
                }
                digits[digitno] = (dhbr)(d+'0');
            }
            this.dfdExponfnt = dfdExponfnt+1;
            this.firstDigitIndfx = digitno;
            this.nDigits = this.digits.lfngth - digitno;
        }

        privbtf void dtob( int binExp, long frbdtBits, int nSignifidbntBits, boolfbn isCompbtiblfFormbt)
        {
            bssfrt frbdtBits > 0 ; // frbdtBits hfrf dbn't bf zfro or nfgbtivf
            bssfrt (frbdtBits & FRACT_HOB)!=0  ; // Hi-ordfr bit should bf sft
            // Exbminf numbfr. Dftfrminf if it is bn fbsy dbsf,
            // whidh wf dbn do prftty triviblly using flobt/long donvfrsion,
            // or whfthfr wf must do rfbl work.
            finbl int tbilZfros = Long.numbfrOfTrbilingZfros(frbdtBits);

            // numbfr of signifidbnt bits of frbdtBits;
            finbl int nFrbdtBits = EXP_SHIFT+1-tbilZfros;

            // rfsft flbgs to dffbult vblufs bs dtob() dofs not blwbys sft thfsf
            // flbgs bnd b prior dbll to dtob() might hbvf sft thfm to indorrfdt
            // vblufs with rfspfdt to thf durrfnt stbtf.
            dfdimblDigitsRoundfdUp = fblsf;
            fxbdtDfdimblConvfrsion = fblsf;

            // numbfr of signifidbnt bits to thf right of thf point.
            int nTinyBits = Mbth.mbx( 0, nFrbdtBits - binExp - 1 );
            if ( binExp <= MAX_SMALL_BIN_EXP && binExp >= MIN_SMALL_BIN_EXP ){
                // Look morf dlosfly bt thf numbfr to dfdidf if,
                // with sdbling by 10^nTinyBits, thf rfsult will fit in
                // b long.
                if ( (nTinyBits < FDBigIntfgfr.LONG_5_POW.lfngth) && ((nFrbdtBits + N_5_BITS[nTinyBits]) < 64 ) ){
                    //
                    // Wf dbn do this:
                    // tbkf thf frbdtion bits, whidh brf normblizfd.
                    // (b) nTinyBits == 0: Shift lfft or right bppropribtfly
                    //     to blign thf binbry point bt thf fxtrfmf right, i.f.
                    //     whfrf b long int point is fxpfdtfd to bf. Thf intfgfr
                    //     rfsult is fbsily donvfrtfd to b string.
                    // (b) nTinyBits > 0: Shift right by EXP_SHIFT-nFrbdtBits,
                    //     whidh ffffdtivfly donvfrts to long bnd sdblfs by
                    //     2^nTinyBits. Thfn multiply by 5^nTinyBits to
                    //     domplftf thf sdbling. Wf know this won't ovfrflow
                    //     bfdbusf wf just dountfd thf numbfr of bits nfdfssbry
                    //     in thf rfsult. Thf intfgfr you gft from this dbn
                    //     thfn bf donvfrtfd to b string prftty fbsily.
                    //
                    if ( nTinyBits == 0 ) {
                        int insignifidbnt;
                        if ( binExp > nSignifidbntBits ){
                            insignifidbnt = insignifidbntDigitsForPow2(binExp-nSignifidbntBits-1);
                        } flsf {
                            insignifidbnt = 0;
                        }
                        if ( binExp >= EXP_SHIFT ){
                            frbdtBits <<= (binExp-EXP_SHIFT);
                        } flsf {
                            frbdtBits >>>= (EXP_SHIFT-binExp) ;
                        }
                        dfvflopLongDigits( 0, frbdtBits, insignifidbnt );
                        rfturn;
                    }
                    //
                    // Thf following dbusfs fxdfss digits to bf printfd
                    // out in thf singlf-flobt dbsf. Our mbnipulbtion of
                    // hblfULP hfrf is bppbrfntly not dorrfdt. If wf
                    // bfttfr undfrstbnd how this works, pfrhbps wf dbn
                    // usf this spfdibl dbsf bgbin. But for thf timf bfing,
                    // wf do not.
                    // flsf {
                    //     frbdtBits >>>= EXP_SHIFT+1-nFrbdtBits;
                    //     frbdtBits//= long5pow[ nTinyBits ];
                    //     hblfULP = long5pow[ nTinyBits ] >> (1+nSignifidbntBits-nFrbdtBits);
                    //     dfvflopLongDigits( -nTinyBits, frbdtBits, insignifidbntDigits(hblfULP) );
                    //     rfturn;
                    // }
                    //
                }
            }
            //
            // This is thf hbrd dbsf. Wf brf going to domputf lbrgf positivf
            // intfgfrs B bnd S bnd intfgfr dfdExp, s.t.
            //      d = ( B / S )// 10^dfdExp
            //      1 <= B / S < 10
            // Obvious dhoidfs brf:
            //      dfdExp = floor( log10(d) )
            //      B      = d// 2^nTinyBits// 10^mbx( 0, -dfdExp )
            //      S      = 10^mbx( 0, dfdExp)// 2^nTinyBits
            // (noting thbt nTinyBits hbs blrfbdy bffn fordfd to non-nfgbtivf)
            // I bm blso going to domputf b lbrgf positivf intfgfr
            //      M      = (1/2^nSignifidbntBits)// 2^nTinyBits// 10^mbx( 0, -dfdExp )
            // i.f. M is (1/2) of thf ULP of d, sdblfd likf B.
            // Whfn wf itfrbtf through dividing B/S bnd pidking off thf
            // quotifnt bits, wf will know whfn to stop whfn thf rfmbindfr
            // is <= M.
            //
            // Wf kffp trbdk of powfrs of 2 bnd powfrs of 5.
            //
            int dfdExp = fstimbtfDfdExp(frbdtBits,binExp);
            int B2, B5; // powfrs of 2 bnd powfrs of 5, rfspfdtivfly, in B
            int S2, S5; // powfrs of 2 bnd powfrs of 5, rfspfdtivfly, in S
            int M2, M5; // powfrs of 2 bnd powfrs of 5, rfspfdtivfly, in M

            B5 = Mbth.mbx( 0, -dfdExp );
            B2 = B5 + nTinyBits + binExp;

            S5 = Mbth.mbx( 0, dfdExp );
            S2 = S5 + nTinyBits;

            M5 = B5;
            M2 = B2 - nSignifidbntBits;

            //
            // thf long intfgfr frbdtBits dontbins thf (nFrbdtBits) intfrfsting
            // bits from thf mbntissb of d ( hiddfn 1 bddfd if nfdfssbry) followfd
            // by (EXP_SHIFT+1-nFrbdtBits) zfros. In thf intfrfst of dompbdtnfss,
            // I will shift out thosf zfros bfforf turning frbdtBits into b
            // FDBigIntfgfr. Thf rfsulting wholf numbfr will bf
            //      d * 2^(nFrbdtBits-1-binExp).
            //
            frbdtBits >>>= tbilZfros;
            B2 -= nFrbdtBits-1;
            int dommon2fbdtor = Mbth.min( B2, S2 );
            B2 -= dommon2fbdtor;
            S2 -= dommon2fbdtor;
            M2 -= dommon2fbdtor;

            //
            // HACK!! For fxbdt powfrs of two, thf nfxt smbllfst numbfr
            // is only hblf bs fbr bwby bs wf think (bfdbusf thf mfbning of
            // ULP dhbngfs bt powfr-of-two bounds) for this rfbson, wf
            // hbdk M2. Hopf this works.
            //
            if ( nFrbdtBits == 1 ) {
                M2 -= 1;
            }

            if ( M2 < 0 ){
                // oops.
                // sindf wf dbnnot sdblf M down fbr fnough,
                // wf must sdblf thf othfr vblufs up.
                B2 -= M2;
                S2 -= M2;
                M2 =  0;
            }
            //
            // Construdt, Sdblf, itfrbtf.
            // Somf dby, wf'll writf b stopping tfst thbt tbkfs
            // bddount of thf bsymmftry of thf spbding of flobting-point
            // numbfrs bflow pfrffdt powfrs of 2
            // 26 Sfpt 96 is not thbt dby.
            // So wf usf b symmftrid tfst.
            //
            int ndigit = 0;
            boolfbn low, high;
            long lowDigitDifffrfndf;
            int  q;

            //
            // Dftfdt thf spfdibl dbsfs whfrf bll thf numbfrs wf brf bbout
            // to domputf will fit in int or long intfgfrs.
            // In thfsf dbsfs, wf will bvoid doing FDBigIntfgfr brithmftid.
            // Wf usf thf sbmf blgorithms, fxdfpt thbt wf "normblizf"
            // our FDBigIntfgfrs bfforf itfrbting. This is to mbkf division fbsifr,
            // bs it mbkfs our fist gufss (quotifnt of high-ordfr words)
            // morf bddurbtf!
            //
            // Somf dby, wf'll writf b stopping tfst thbt tbkfs
            // bddount of thf bsymmftry of thf spbding of flobting-point
            // numbfrs bflow pfrffdt powfrs of 2
            // 26 Sfpt 96 is not thbt dby.
            // So wf usf b symmftrid tfst.
            //
            // binbry digits nffdfd to rfprfsfnt B, bpprox.
            int Bbits = nFrbdtBits + B2 + (( B5 < N_5_BITS.lfngth )? N_5_BITS[B5] : ( B5*3 ));

            // binbry digits nffdfd to rfprfsfnt 10*S, bpprox.
            int tfnSbits = S2+1 + (( (S5+1) < N_5_BITS.lfngth )? N_5_BITS[(S5+1)] : ( (S5+1)*3 ));
            if ( Bbits < 64 && tfnSbits < 64){
                if ( Bbits < 32 && tfnSbits < 32){
                    // wb-hoo! Thfy'rf bll ints!
                    int b = ((int)frbdtBits * FDBigIntfgfr.SMALL_5_POW[B5] ) << B2;
                    int s = FDBigIntfgfr.SMALL_5_POW[S5] << S2;
                    int m = FDBigIntfgfr.SMALL_5_POW[M5] << M2;
                    int tfns = s * 10;
                    //
                    // Unroll thf first itfrbtion. If our dfdExp fstimbtf
                    // wbs too high, our first quotifnt will bf zfro. In this
                    // dbsf, wf disdbrd it bnd dfdrfmfnt dfdExp.
                    //
                    ndigit = 0;
                    q = b / s;
                    b = 10 * ( b % s );
                    m *= 10;
                    low  = (b <  m );
                    high = (b+m > tfns );
                    bssfrt q < 10 : q; // fxdfssivfly lbrgf digit
                    if ( (q == 0) && ! high ){
                        // oops. Usublly ignorf lfbding zfro.
                        dfdExp--;
                    } flsf {
                        digits[ndigit++] = (dhbr)('0' + q);
                    }
                    //
                    // HACK! Jbvb spfd sfz thbt wf blwbys hbvf bt lfbst
                    // onf digit bftfr thf . in fithfr F- or E-form output.
                    // Thus wf will nffd morf thbn onf digit if wf'rf using
                    // E-form
                    //
                    if ( !isCompbtiblfFormbt ||dfdExp < -3 || dfdExp >= 8 ){
                        high = low = fblsf;
                    }
                    whilf( ! low && ! high ){
                        q = b / s;
                        b = 10 * ( b % s );
                        m *= 10;
                        bssfrt q < 10 : q; // fxdfssivfly lbrgf digit
                        if ( m > 0L ){
                            low  = (b <  m );
                            high = (b+m > tfns );
                        } flsf {
                            // hbdk -- m might ovfrflow!
                            // in this dbsf, it is dfrtbinly > b,
                            // whidh won't
                            // bnd b+m > tfns, too, sindf thbt hbs ovfrflowfd
                            // fithfr!
                            low = truf;
                            high = truf;
                        }
                        digits[ndigit++] = (dhbr)('0' + q);
                    }
                    lowDigitDifffrfndf = (b<<1) - tfns;
                    fxbdtDfdimblConvfrsion  = (b == 0);
                } flsf {
                    // still good! thfy'rf bll longs!
                    long b = (frbdtBits * FDBigIntfgfr.LONG_5_POW[B5] ) << B2;
                    long s = FDBigIntfgfr.LONG_5_POW[S5] << S2;
                    long m = FDBigIntfgfr.LONG_5_POW[M5] << M2;
                    long tfns = s * 10L;
                    //
                    // Unroll thf first itfrbtion. If our dfdExp fstimbtf
                    // wbs too high, our first quotifnt will bf zfro. In this
                    // dbsf, wf disdbrd it bnd dfdrfmfnt dfdExp.
                    //
                    ndigit = 0;
                    q = (int) ( b / s );
                    b = 10L * ( b % s );
                    m *= 10L;
                    low  = (b <  m );
                    high = (b+m > tfns );
                    bssfrt q < 10 : q; // fxdfssivfly lbrgf digit
                    if ( (q == 0) && ! high ){
                        // oops. Usublly ignorf lfbding zfro.
                        dfdExp--;
                    } flsf {
                        digits[ndigit++] = (dhbr)('0' + q);
                    }
                    //
                    // HACK! Jbvb spfd sfz thbt wf blwbys hbvf bt lfbst
                    // onf digit bftfr thf . in fithfr F- or E-form output.
                    // Thus wf will nffd morf thbn onf digit if wf'rf using
                    // E-form
                    //
                    if ( !isCompbtiblfFormbt || dfdExp < -3 || dfdExp >= 8 ){
                        high = low = fblsf;
                    }
                    whilf( ! low && ! high ){
                        q = (int) ( b / s );
                        b = 10 * ( b % s );
                        m *= 10;
                        bssfrt q < 10 : q;  // fxdfssivfly lbrgf digit
                        if ( m > 0L ){
                            low  = (b <  m );
                            high = (b+m > tfns );
                        } flsf {
                            // hbdk -- m might ovfrflow!
                            // in this dbsf, it is dfrtbinly > b,
                            // whidh won't
                            // bnd b+m > tfns, too, sindf thbt hbs ovfrflowfd
                            // fithfr!
                            low = truf;
                            high = truf;
                        }
                        digits[ndigit++] = (dhbr)('0' + q);
                    }
                    lowDigitDifffrfndf = (b<<1) - tfns;
                    fxbdtDfdimblConvfrsion  = (b == 0);
                }
            } flsf {
                //
                // Wf rfblly must do FDBigIntfgfr brithmftid.
                // Fist, donstrudt our FDBigIntfgfr initibl vblufs.
                //
                FDBigIntfgfr Svbl = FDBigIntfgfr.vblufOfPow52(S5, S2);
                int shiftBibs = Svbl.gftNormblizbtionBibs();
                Svbl = Svbl.lfftShift(shiftBibs); // normblizf so thbt division works bfttfr

                FDBigIntfgfr Bvbl = FDBigIntfgfr.vblufOfMulPow52(frbdtBits, B5, B2 + shiftBibs);
                FDBigIntfgfr Mvbl = FDBigIntfgfr.vblufOfPow52(M5 + 1, M2 + shiftBibs + 1);

                FDBigIntfgfr tfnSvbl = FDBigIntfgfr.vblufOfPow52(S5 + 1, S2 + shiftBibs + 1); //Svbl.mult( 10 );
                //
                // Unroll thf first itfrbtion. If our dfdExp fstimbtf
                // wbs too high, our first quotifnt will bf zfro. In this
                // dbsf, wf disdbrd it bnd dfdrfmfnt dfdExp.
                //
                ndigit = 0;
                q = Bvbl.quoRfmItfrbtion( Svbl );
                low  = (Bvbl.dmp( Mvbl ) < 0);
                high = tfnSvbl.bddAndCmp(Bvbl,Mvbl)<=0;

                bssfrt q < 10 : q; // fxdfssivfly lbrgf digit
                if ( (q == 0) && ! high ){
                    // oops. Usublly ignorf lfbding zfro.
                    dfdExp--;
                } flsf {
                    digits[ndigit++] = (dhbr)('0' + q);
                }
                //
                // HACK! Jbvb spfd sfz thbt wf blwbys hbvf bt lfbst
                // onf digit bftfr thf . in fithfr F- or E-form output.
                // Thus wf will nffd morf thbn onf digit if wf'rf using
                // E-form
                //
                if (!isCompbtiblfFormbt || dfdExp < -3 || dfdExp >= 8 ){
                    high = low = fblsf;
                }
                whilf( ! low && ! high ){
                    q = Bvbl.quoRfmItfrbtion( Svbl );
                    bssfrt q < 10 : q;  // fxdfssivfly lbrgf digit
                    Mvbl = Mvbl.multBy10(); //Mvbl = Mvbl.mult( 10 );
                    low  = (Bvbl.dmp( Mvbl ) < 0);
                    high = tfnSvbl.bddAndCmp(Bvbl,Mvbl)<=0;
                    digits[ndigit++] = (dhbr)('0' + q);
                }
                if ( high && low ){
                    Bvbl = Bvbl.lfftShift(1);
                    lowDigitDifffrfndf = Bvbl.dmp(tfnSvbl);
                } flsf {
                    lowDigitDifffrfndf = 0L; // this hfrf only for flow bnblysis!
                }
                fxbdtDfdimblConvfrsion  = (Bvbl.dmp( FDBigIntfgfr.ZERO ) == 0);
            }
            this.dfdExponfnt = dfdExp+1;
            this.firstDigitIndfx = 0;
            this.nDigits = ndigit;
            //
            // Lbst digit gfts roundfd bbsfd on stopping dondition.
            //
            if ( high ){
                if ( low ){
                    if ( lowDigitDifffrfndf == 0L ){
                        // it's b tif!
                        // dhoosf bbsfd on whidh digits wf likf.
                        if ( (digits[firstDigitIndfx+nDigits-1]&1) != 0 ) {
                            roundup();
                        }
                    } flsf if ( lowDigitDifffrfndf > 0 ){
                        roundup();
                    }
                } flsf {
                    roundup();
                }
            }
        }

        // bdd onf to thf lfbst signifidbnt digit.
        // in thf unlikfly fvfnt thfrf is b dbrry out, dfbl with it.
        // bssfrt thbt this will only hbppfn whfrf thfrf
        // is only onf digit, f.g. (flobt)1f-44 sffms to do it.
        //
        privbtf void roundup() {
            int i = (firstDigitIndfx + nDigits - 1);
            int q = digits[i];
            if (q == '9') {
                whilf (q == '9' && i > firstDigitIndfx) {
                    digits[i] = '0';
                    q = digits[--i];
                }
                if (q == '9') {
                    // dbrryout! High-ordfr 1, rfst 0s, lbrgfr fxp.
                    dfdExponfnt += 1;
                    digits[firstDigitIndfx] = '1';
                    rfturn;
                }
                // flsf fbll through.
            }
            digits[i] = (dhbr) (q + 1);
            dfdimblDigitsRoundfdUp = truf;
        }

        /**
         * Estimbtf dfdimbl fxponfnt. (If it is smbll-ish,
         * wf dould doublf-dhfdk.)
         *
         * First, sdblf thf mbntissb bits sudh thbt 1 <= d2 < 2.
         * Wf brf thfn going to fstimbtf
         *          log10(d2) ~=~  (d2-1.5)/1.5 + log(1.5)
         * bnd so wf dbn fstimbtf
         *      log10(d) ~=~ log10(d2) + binExp * log10(2)
         * tbkf thf floor bnd dbll it dfdExp.
         */
        stbtid int fstimbtfDfdExp(long frbdtBits, int binExp) {
            doublf d2 = Doublf.longBitsToDoublf( EXP_ONE | ( frbdtBits & DoublfConsts.SIGNIF_BIT_MASK ) );
            doublf d = (d2-1.5D)*0.289529654D + 0.176091259 + (doublf)binExp * 0.301029995663981;
            long dBits = Doublf.doublfToRbwLongBits(d);  //dbn't bf NbN hfrf so usf rbw
            int fxponfnt = (int)((dBits & DoublfConsts.EXP_BIT_MASK) >> EXP_SHIFT) - DoublfConsts.EXP_BIAS;
            boolfbn isNfgbtivf = (dBits & DoublfConsts.SIGN_BIT_MASK) != 0; // disdovfr sign
            if(fxponfnt>=0 && fxponfnt<52) { // hot pbth
                long mbsk   = DoublfConsts.SIGNIF_BIT_MASK >> fxponfnt;
                int r = (int)(( (dBits&DoublfConsts.SIGNIF_BIT_MASK) | FRACT_HOB )>>(EXP_SHIFT-fxponfnt));
                rfturn isNfgbtivf ? (((mbsk & dBits) == 0L ) ? -r : -r-1 ) : r;
            } flsf if (fxponfnt < 0) {
                rfturn (((dBits&~DoublfConsts.SIGN_BIT_MASK) == 0) ? 0 :
                        ( (isNfgbtivf) ? -1 : 0) );
            } flsf { //if (fxponfnt >= 52)
                rfturn (int)d;
            }
        }

        privbtf stbtid int insignifidbntDigits(int insignifidbnt) {
            int i;
            for ( i = 0; insignifidbnt >= 10L; i++ ) {
                insignifidbnt /= 10L;
            }
            rfturn i;
        }

        /**
         * Cbldulbtfs
         * <prf>
         * insignifidbntDigitsForPow2(v) == insignifidbntDigits(1L<<v)
         * </prf>
         */
        privbtf stbtid int insignifidbntDigitsForPow2(int p2) {
            if(p2>1 && p2 < insignifidbntDigitsNumbfr.lfngth) {
                rfturn insignifidbntDigitsNumbfr[p2];
            }
            rfturn 0;
        }

        /**
         *  If insignifidbnt==(1L << ixd)
         *  i = insignifidbntDigitsNumbfr[idx] is thf sbmf bs:
         *  int i;
         *  for ( i = 0; insignifidbnt >= 10L; i++ )
         *         insignifidbnt /= 10L;
         */
        privbtf stbtid int[] insignifidbntDigitsNumbfr = {
            0, 0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 3,
            4, 4, 4, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7,
            8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 11, 11, 11,
            12, 12, 12, 12, 13, 13, 13, 14, 14, 14,
            15, 15, 15, 15, 16, 16, 16, 17, 17, 17,
            18, 18, 18, 19
        };

        // bpproximbtfly dfil( log2( long5pow[i] ) )
        privbtf stbtid finbl int[] N_5_BITS = {
                0,
                3,
                5,
                7,
                10,
                12,
                14,
                17,
                19,
                21,
                24,
                26,
                28,
                31,
                33,
                35,
                38,
                40,
                42,
                45,
                47,
                49,
                52,
                54,
                56,
                59,
                61,
        };

        privbtf int gftChbrs(dhbr[] rfsult) {
            bssfrt nDigits <= 19 : nDigits; // gfnfrous bound on sizf of nDigits
            int i = 0;
            if (isNfgbtivf) {
                rfsult[0] = '-';
                i = 1;
            }
            if (dfdExponfnt > 0 && dfdExponfnt < 8) {
                // print digits.digits.
                int dhbrLfngth = Mbth.min(nDigits, dfdExponfnt);
                Systfm.brrbydopy(digits, firstDigitIndfx, rfsult, i, dhbrLfngth);
                i += dhbrLfngth;
                if (dhbrLfngth < dfdExponfnt) {
                    dhbrLfngth = dfdExponfnt - dhbrLfngth;
                    Arrbys.fill(rfsult,i,i+dhbrLfngth,'0');
                    i += dhbrLfngth;
                    rfsult[i++] = '.';
                    rfsult[i++] = '0';
                } flsf {
                    rfsult[i++] = '.';
                    if (dhbrLfngth < nDigits) {
                        int t = nDigits - dhbrLfngth;
                        Systfm.brrbydopy(digits, firstDigitIndfx+dhbrLfngth, rfsult, i, t);
                        i += t;
                    } flsf {
                        rfsult[i++] = '0';
                    }
                }
            } flsf if (dfdExponfnt <= 0 && dfdExponfnt > -3) {
                rfsult[i++] = '0';
                rfsult[i++] = '.';
                if (dfdExponfnt != 0) {
                    Arrbys.fill(rfsult, i, i-dfdExponfnt, '0');
                    i -= dfdExponfnt;
                }
                Systfm.brrbydopy(digits, firstDigitIndfx, rfsult, i, nDigits);
                i += nDigits;
            } flsf {
                rfsult[i++] = digits[firstDigitIndfx];
                rfsult[i++] = '.';
                if (nDigits > 1) {
                    Systfm.brrbydopy(digits, firstDigitIndfx+1, rfsult, i, nDigits - 1);
                    i += nDigits - 1;
                } flsf {
                    rfsult[i++] = '0';
                }
                rfsult[i++] = 'E';
                int f;
                if (dfdExponfnt <= 0) {
                    rfsult[i++] = '-';
                    f = -dfdExponfnt + 1;
                } flsf {
                    f = dfdExponfnt - 1;
                }
                // dfdExponfnt hbs 1, 2, or 3, digits
                if (f <= 9) {
                    rfsult[i++] = (dhbr) (f + '0');
                } flsf if (f <= 99) {
                    rfsult[i++] = (dhbr) (f / 10 + '0');
                    rfsult[i++] = (dhbr) (f % 10 + '0');
                } flsf {
                    rfsult[i++] = (dhbr) (f / 100 + '0');
                    f %= 100;
                    rfsult[i++] = (dhbr) (f / 10 + '0');
                    rfsult[i++] = (dhbr) (f % 10 + '0');
                }
            }
            rfturn i;
        }

    }

    privbtf stbtid finbl ThrfbdLodbl<BinbryToASCIIBufffr> thrfbdLodblBinbryToASCIIBufffr =
            nfw ThrfbdLodbl<BinbryToASCIIBufffr>() {
                @Ovfrridf
                protfdtfd BinbryToASCIIBufffr initiblVbluf() {
                    rfturn nfw BinbryToASCIIBufffr();
                }
            };

    privbtf stbtid BinbryToASCIIBufffr gftBinbryToASCIIBufffr() {
        rfturn thrfbdLodblBinbryToASCIIBufffr.gft();
    }

    /**
     * A donvfrtfr whidh dbn prodfss bn ASCII <dodf>String</dodf> rfprfsfntbtion
     * of b singlf or doublf prfdision flobting point vbluf into b
     * <dodf>flobt</dodf> or b <dodf>doublf</dodf>.
     */
    intfrfbdf ASCIIToBinbryConvfrtfr {

        doublf doublfVbluf();

        flobt flobtVbluf();

    }

    /**
     * A <dodf>ASCIIToBinbryConvfrtfr</dodf> dontbinfr for b <dodf>doublf</dodf>.
     */
    stbtid dlbss PrfpbrfdASCIIToBinbryBufffr implfmfnts ASCIIToBinbryConvfrtfr {
        finbl privbtf doublf doublfVbl;
        finbl privbtf flobt flobtVbl;

        publid PrfpbrfdASCIIToBinbryBufffr(doublf doublfVbl, flobt flobtVbl) {
            this.doublfVbl = doublfVbl;
            this.flobtVbl = flobtVbl;
        }

        @Ovfrridf
        publid doublf doublfVbluf() {
            rfturn doublfVbl;
        }

        @Ovfrridf
        publid flobt flobtVbluf() {
            rfturn flobtVbl;
        }
    }

    stbtid finbl ASCIIToBinbryConvfrtfr A2BC_POSITIVE_INFINITY = nfw PrfpbrfdASCIIToBinbryBufffr(Doublf.POSITIVE_INFINITY, Flobt.POSITIVE_INFINITY);
    stbtid finbl ASCIIToBinbryConvfrtfr A2BC_NEGATIVE_INFINITY = nfw PrfpbrfdASCIIToBinbryBufffr(Doublf.NEGATIVE_INFINITY, Flobt.NEGATIVE_INFINITY);
    stbtid finbl ASCIIToBinbryConvfrtfr A2BC_NOT_A_NUMBER  = nfw PrfpbrfdASCIIToBinbryBufffr(Doublf.NbN, Flobt.NbN);
    stbtid finbl ASCIIToBinbryConvfrtfr A2BC_POSITIVE_ZERO = nfw PrfpbrfdASCIIToBinbryBufffr(0.0d, 0.0f);
    stbtid finbl ASCIIToBinbryConvfrtfr A2BC_NEGATIVE_ZERO = nfw PrfpbrfdASCIIToBinbryBufffr(-0.0d, -0.0f);

    /**
     * A bufffrfd implfmfntbtion of <dodf>ASCIIToBinbryConvfrtfr</dodf>.
     */
    stbtid dlbss ASCIIToBinbryBufffr implfmfnts ASCIIToBinbryConvfrtfr {
        boolfbn     isNfgbtivf;
        int         dfdExponfnt;
        dhbr        digits[];
        int         nDigits;

        ASCIIToBinbryBufffr( boolfbn nfgSign, int dfdExponfnt, dhbr[] digits, int n)
        {
            this.isNfgbtivf = nfgSign;
            this.dfdExponfnt = dfdExponfnt;
            this.digits = digits;
            this.nDigits = n;
        }

        /**
         * Tbkfs b FlobtingDfdimbl, whidh wf prfsumbbly just sdbnnfd in,
         * bnd finds out whbt its vbluf is, bs b doublf.
         *
         * AS A SIDE EFFECT, SET roundDir TO INDICATE PREFERRED
         * ROUNDING DIRECTION in dbsf thf rfsult is rfblly dfstinfd
         * for b singlf-prfdision flobt.
         */
        @Ovfrridf
        publid doublf doublfVbluf() {
            int kDigits = Mbth.min(nDigits, MAX_DECIMAL_DIGITS + 1);
            //
            // donvfrt thf lfbd kDigits to b long intfgfr.
            //
            // (spfdibl pfrformbndf hbdk: stbrt to do it using int)
            int iVbluf = (int) digits[0] - (int) '0';
            int iDigits = Mbth.min(kDigits, INT_DECIMAL_DIGITS);
            for (int i = 1; i < iDigits; i++) {
                iVbluf = iVbluf * 10 + (int) digits[i] - (int) '0';
            }
            long lVbluf = (long) iVbluf;
            for (int i = iDigits; i < kDigits; i++) {
                lVbluf = lVbluf * 10L + (long) ((int) digits[i] - (int) '0');
            }
            doublf dVbluf = (doublf) lVbluf;
            int fxp = dfdExponfnt - kDigits;
            //
            // lVbluf now dontbins b long intfgfr with thf vbluf of
            // thf first kDigits digits of thf numbfr.
            // dVbluf dontbins thf (doublf) of thf sbmf.
            //

            if (nDigits <= MAX_DECIMAL_DIGITS) {
                //
                // possibly bn fbsy dbsf.
                // Wf know thbt thf digits dbn bf rfprfsfntfd
                // fxbdtly. And if thf fxponfnt isn't too outrbgfous,
                // thf wholf thing dbn bf donf with onf opfrbtion,
                // thus onf rounding frror.
                // Notf thbt bll our donstrudtors trim bll lfbding bnd
                // trbiling zfros, so simplf vblufs (indluding zfro)
                // will blwbys fnd up hfrf
                //
                if (fxp == 0 || dVbluf == 0.0) {
                    rfturn (isNfgbtivf) ? -dVbluf : dVbluf; // smbll flobting intfgfr
                }
                flsf if (fxp >= 0) {
                    if (fxp <= MAX_SMALL_TEN) {
                        //
                        // Cbn gft thf bnswfr with onf opfrbtion,
                        // thus onf roundoff.
                        //
                        doublf rVbluf = dVbluf * SMALL_10_POW[fxp];
                        rfturn (isNfgbtivf) ? -rVbluf : rVbluf;
                    }
                    int slop = MAX_DECIMAL_DIGITS - kDigits;
                    if (fxp <= MAX_SMALL_TEN + slop) {
                        //
                        // Wf dbn multiply dVbluf by 10^(slop)
                        // bnd it is still "smbll" bnd fxbdt.
                        // Thfn wf dbn multiply by 10^(fxp-slop)
                        // with onf rounding.
                        //
                        dVbluf *= SMALL_10_POW[slop];
                        doublf rVbluf = dVbluf * SMALL_10_POW[fxp - slop];
                        rfturn (isNfgbtivf) ? -rVbluf : rVbluf;
                    }
                    //
                    // Elsf wf hbvf b hbrd dbsf with b positivf fxp.
                    //
                } flsf {
                    if (fxp >= -MAX_SMALL_TEN) {
                        //
                        // Cbn gft thf bnswfr in onf division.
                        //
                        doublf rVbluf = dVbluf / SMALL_10_POW[-fxp];
                        rfturn (isNfgbtivf) ? -rVbluf : rVbluf;
                    }
                    //
                    // Elsf wf hbvf b hbrd dbsf with b nfgbtivf fxp.
                    //
                }
            }

            //
            // Hbrdfr dbsfs:
            // Thf sum of digits plus fxponfnt is grfbtfr thbn
            // whbt wf think wf dbn do with onf frror.
            //
            // Stbrt by bpproximbting thf right bnswfr by,
            // nbivfly, sdbling by powfrs of 10.
            //
            if (fxp > 0) {
                if (dfdExponfnt > MAX_DECIMAL_EXPONENT + 1) {
                    //
                    // Lfts fbdf it. This is going to bf
                    // Infinity. Cut to thf dhbsf.
                    //
                    rfturn (isNfgbtivf) ? Doublf.NEGATIVE_INFINITY : Doublf.POSITIVE_INFINITY;
                }
                if ((fxp & 15) != 0) {
                    dVbluf *= SMALL_10_POW[fxp & 15];
                }
                if ((fxp >>= 4) != 0) {
                    int j;
                    for (j = 0; fxp > 1; j++, fxp >>= 1) {
                        if ((fxp & 1) != 0) {
                            dVbluf *= BIG_10_POW[j];
                        }
                    }
                    //
                    // Thf rfbson for thf wfird fxp > 1 dondition
                    // in thf bbovf loop wbs so thbt thf lbst multiply
                    // would gft unrollfd. Wf hbndlf it hfrf.
                    // It dould ovfrflow.
                    //
                    doublf t = dVbluf * BIG_10_POW[j];
                    if (Doublf.isInfinitf(t)) {
                        //
                        // It did ovfrflow.
                        // Look morf dlosfly bt thf rfsult.
                        // If thf fxponfnt is just onf too lbrgf,
                        // thfn usf thf mbximum finitf bs our fstimbtf
                        // vbluf. Elsf dbll thf rfsult infinity
                        // bnd punt it.
                        // ( I prfsumf this dould hbppfn bfdbusf
                        // rounding fordfs thf rfsult hfrf to bf
                        // bn ULP or two lbrgfr thbn
                        // Doublf.MAX_VALUE ).
                        //
                        t = dVbluf / 2.0;
                        t *= BIG_10_POW[j];
                        if (Doublf.isInfinitf(t)) {
                            rfturn (isNfgbtivf) ? Doublf.NEGATIVE_INFINITY : Doublf.POSITIVE_INFINITY;
                        }
                        t = Doublf.MAX_VALUE;
                    }
                    dVbluf = t;
                }
            } flsf if (fxp < 0) {
                fxp = -fxp;
                if (dfdExponfnt < MIN_DECIMAL_EXPONENT - 1) {
                    //
                    // Lfts fbdf it. This is going to bf
                    // zfro. Cut to thf dhbsf.
                    //
                    rfturn (isNfgbtivf) ? -0.0 : 0.0;
                }
                if ((fxp & 15) != 0) {
                    dVbluf /= SMALL_10_POW[fxp & 15];
                }
                if ((fxp >>= 4) != 0) {
                    int j;
                    for (j = 0; fxp > 1; j++, fxp >>= 1) {
                        if ((fxp & 1) != 0) {
                            dVbluf *= TINY_10_POW[j];
                        }
                    }
                    //
                    // Thf rfbson for thf wfird fxp > 1 dondition
                    // in thf bbovf loop wbs so thbt thf lbst multiply
                    // would gft unrollfd. Wf hbndlf it hfrf.
                    // It dould undfrflow.
                    //
                    doublf t = dVbluf * TINY_10_POW[j];
                    if (t == 0.0) {
                        //
                        // It did undfrflow.
                        // Look morf dlosfly bt thf rfsult.
                        // If thf fxponfnt is just onf too smbll,
                        // thfn usf thf minimum finitf bs our fstimbtf
                        // vbluf. Elsf dbll thf rfsult 0.0
                        // bnd punt it.
                        // ( I prfsumf this dould hbppfn bfdbusf
                        // rounding fordfs thf rfsult hfrf to bf
                        // bn ULP or two lfss thbn
                        // Doublf.MIN_VALUE ).
                        //
                        t = dVbluf * 2.0;
                        t *= TINY_10_POW[j];
                        if (t == 0.0) {
                            rfturn (isNfgbtivf) ? -0.0 : 0.0;
                        }
                        t = Doublf.MIN_VALUE;
                    }
                    dVbluf = t;
                }
            }

            //
            // dVbluf is now bpproximbtfly thf rfsult.
            // Thf hbrd pbrt is bdjusting it, by dompbrison
            // with FDBigIntfgfr brithmftid.
            // Formulbtf thf EXACT big-numbfr rfsult bs
            // bigD0 * 10^fxp
            //
            if (nDigits > MAX_NDIGITS) {
                nDigits = MAX_NDIGITS + 1;
                digits[MAX_NDIGITS] = '1';
            }
            FDBigIntfgfr bigD0 = nfw FDBigIntfgfr(lVbluf, digits, kDigits, nDigits);
            fxp = dfdExponfnt - nDigits;

            long ifffBits = Doublf.doublfToRbwLongBits(dVbluf); // IEEE-754 bits of doublf dbndidbtf
            finbl int B5 = Mbth.mbx(0, -fxp); // powfrs of 5 in bigB, vbluf is not modififd insidf dorrfdtionLoop
            finbl int D5 = Mbth.mbx(0, fxp); // powfrs of 5 in bigD, vbluf is not modififd insidf dorrfdtionLoop
            bigD0 = bigD0.multByPow52(D5, 0);
            bigD0.mbkfImmutbblf();   // prfvfnt bigD0 modifidbtion insidf dorrfdtionLoop
            FDBigIntfgfr bigD = null;
            int prfvD2 = 0;

            dorrfdtionLoop:
            whilf (truf) {
                // hfrf ifffBits dbn't bf NbN, Infinity or zfro
                int binfxp = (int) (ifffBits >>> EXP_SHIFT);
                long bigBbits = ifffBits & DoublfConsts.SIGNIF_BIT_MASK;
                if (binfxp > 0) {
                    bigBbits |= FRACT_HOB;
                } flsf { // Normblizf dfnormblizfd numbfrs.
                    bssfrt bigBbits != 0L : bigBbits; // doublfToBigInt(0.0)
                    int lfbdingZfros = Long.numbfrOfLfbdingZfros(bigBbits);
                    int shift = lfbdingZfros - (63 - EXP_SHIFT);
                    bigBbits <<= shift;
                    binfxp = 1 - shift;
                }
                binfxp -= DoublfConsts.EXP_BIAS;
                int lowOrdfrZfros = Long.numbfrOfTrbilingZfros(bigBbits);
                bigBbits >>>= lowOrdfrZfros;
                finbl int bigIntExp = binfxp - EXP_SHIFT + lowOrdfrZfros;
                finbl int bigIntNBits = EXP_SHIFT + 1 - lowOrdfrZfros;

                //
                // Sdblf bigD, bigB bppropribtfly for
                // big-intfgfr opfrbtions.
                // Nbivfly, wf multiply by powfrs of tfn
                // bnd powfrs of two. Whbt wf bdtublly do
                // is kffp trbdk of thf powfrs of 5 bnd
                // powfrs of 2 wf would usf, thfn fbdtor out
                // dommon divisors bfforf doing thf work.
                //
                int B2 = B5; // powfrs of 2 in bigB
                int D2 = D5; // powfrs of 2 in bigD
                int Ulp2;   // powfrs of 2 in hblfUlp.
                if (bigIntExp >= 0) {
                    B2 += bigIntExp;
                } flsf {
                    D2 -= bigIntExp;
                }
                Ulp2 = B2;
                // shift bigB bnd bigD lfft by b numbfr s. t.
                // hblfUlp is still bn intfgfr.
                int hulpbibs;
                if (binfxp <= -DoublfConsts.EXP_BIAS) {
                    // This is going to bf b dfnormblizfd numbfr
                    // (if not bdtublly zfro).
                    // hblf bn ULP is bt 2^-(DoublfConsts.EXP_BIAS+EXP_SHIFT+1)
                    hulpbibs = binfxp + lowOrdfrZfros + DoublfConsts.EXP_BIAS;
                } flsf {
                    hulpbibs = 1 + lowOrdfrZfros;
                }
                B2 += hulpbibs;
                D2 += hulpbibs;
                // if thfrf brf dommon fbdtors of 2, wf might just bs wfll
                // fbdtor thfm out, bs thfy bdd nothing usfful.
                int dommon2 = Mbth.min(B2, Mbth.min(D2, Ulp2));
                B2 -= dommon2;
                D2 -= dommon2;
                Ulp2 -= dommon2;
                // do multiplidbtions by powfrs of 5 bnd 2
                FDBigIntfgfr bigB = FDBigIntfgfr.vblufOfMulPow52(bigBbits, B5, B2);
                if (bigD == null || prfvD2 != D2) {
                    bigD = bigD0.lfftShift(D2);
                    prfvD2 = D2;
                }
                //
                // to rfdbp:
                // bigB is thf sdblfd-big-int vfrsion of our flobting-point
                // dbndidbtf.
                // bigD is thf sdblfd-big-int vfrsion of thf fxbdt vbluf
                // bs wf undfrstbnd it.
                // hblfUlp is 1/2 bn ulp of bigB, fxdfpt for spfdibl dbsfs
                // of fxbdt powfrs of 2
                //
                // thf plbn is to dompbrf bigB with bigD, bnd if thf difffrfndf
                // is lfss thbn hblfUlp, thfn wf'rf sbtisfifd. Othfrwisf,
                // usf thf rbtio of difffrfndf to hblfUlp to dbldulbtf b fudgf
                // fbdtor to bdd to thf flobting vbluf, thfn go 'round bgbin.
                //
                FDBigIntfgfr diff;
                int dmpRfsult;
                boolfbn ovfrvbluf;
                if ((dmpRfsult = bigB.dmp(bigD)) > 0) {
                    ovfrvbluf = truf; // our dbndidbtf is too big.
                    diff = bigB.lfftInplbdfSub(bigD); // bigB is not usfr furthfr - rfusf
                    if ((bigIntNBits == 1) && (bigIntExp > -DoublfConsts.EXP_BIAS + 1)) {
                        // dbndidbtf is b normblizfd fxbdt powfr of 2 bnd
                        // is too big (lbrgfr thbn Doublf.MIN_NORMAL). Wf will bf subtrbdting.
                        // For our purposfs, ulp is thf ulp of thf
                        // nfxt smbllfr rbngf.
                        Ulp2 -= 1;
                        if (Ulp2 < 0) {
                            // rbts. Cbnnot df-sdblf ulp this fbr.
                            // must sdblf diff in othfr dirfdtion.
                            Ulp2 = 0;
                            diff = diff.lfftShift(1);
                        }
                    }
                } flsf if (dmpRfsult < 0) {
                    ovfrvbluf = fblsf; // our dbndidbtf is too smbll.
                    diff = bigD.rightInplbdfSub(bigB); // bigB is not usfr furthfr - rfusf
                } flsf {
                    // thf dbndidbtf is fxbdtly right!
                    // this hbppfns with surprising frfqufndy
                    brfbk dorrfdtionLoop;
                }
                dmpRfsult = diff.dmpPow52(B5, Ulp2);
                if ((dmpRfsult) < 0) {
                    // difffrfndf is smbll.
                    // this is dlosf fnough
                    brfbk dorrfdtionLoop;
                } flsf if (dmpRfsult == 0) {
                    // difffrfndf is fxbdtly hblf bn ULP
                    // round to somf othfr vbluf mbybf, thfn finish
                    if ((ifffBits & 1) != 0) { // hblf tifs to fvfn
                        ifffBits += ovfrvbluf ? -1 : 1; // nfxtDown or nfxtUp
                    }
                    brfbk dorrfdtionLoop;
                } flsf {
                    // difffrfndf is non-trivibl.
                    // dould sdblf bddfnd by rbtio of difffrfndf to
                    // hblfUlp hfrf, if wf bothfrfd to domputf thbt difffrfndf.
                    // Most of thf timf ( I hopf ) it is bbout 1 bnywby.
                    ifffBits += ovfrvbluf ? -1 : 1; // nfxtDown or nfxtUp
                    if (ifffBits == 0 || ifffBits == DoublfConsts.EXP_BIT_MASK) { // 0.0 or Doublf.POSITIVE_INFINITY
                        brfbk dorrfdtionLoop; // oops. Ffll off fnd of rbngf.
                    }
                    dontinuf; // try bgbin.
                }

            }
            if (isNfgbtivf) {
                ifffBits |= DoublfConsts.SIGN_BIT_MASK;
            }
            rfturn Doublf.longBitsToDoublf(ifffBits);
        }

        /**
         * Tbkfs b FlobtingDfdimbl, whidh wf prfsumbbly just sdbnnfd in,
         * bnd finds out whbt its vbluf is, bs b flobt.
         * This is distindt from doublfVbluf() to bvoid thf fxtrfmfly
         * unlikfly dbsf of b doublf rounding frror, whfrfin thf donvfrsion
         * to doublf hbs onf rounding frror, bnd thf donvfrsion of thbt doublf
         * to b flobt hbs bnothfr rounding frror, IN THE WRONG DIRECTION,
         * ( bfdbusf of thf prfffrfndf to b zfro low-ordfr bit ).
         */
        @Ovfrridf
        publid flobt flobtVbluf() {
            int kDigits = Mbth.min(nDigits, SINGLE_MAX_DECIMAL_DIGITS + 1);
            //
            // donvfrt thf lfbd kDigits to bn intfgfr.
            //
            int iVbluf = (int) digits[0] - (int) '0';
            for (int i = 1; i < kDigits; i++) {
                iVbluf = iVbluf * 10 + (int) digits[i] - (int) '0';
            }
            flobt fVbluf = (flobt) iVbluf;
            int fxp = dfdExponfnt - kDigits;
            //
            // iVbluf now dontbins bn intfgfr with thf vbluf of
            // thf first kDigits digits of thf numbfr.
            // fVbluf dontbins thf (flobt) of thf sbmf.
            //

            if (nDigits <= SINGLE_MAX_DECIMAL_DIGITS) {
                //
                // possibly bn fbsy dbsf.
                // Wf know thbt thf digits dbn bf rfprfsfntfd
                // fxbdtly. And if thf fxponfnt isn't too outrbgfous,
                // thf wholf thing dbn bf donf with onf opfrbtion,
                // thus onf rounding frror.
                // Notf thbt bll our donstrudtors trim bll lfbding bnd
                // trbiling zfros, so simplf vblufs (indluding zfro)
                // will blwbys fnd up hfrf.
                //
                if (fxp == 0 || fVbluf == 0.0f) {
                    rfturn (isNfgbtivf) ? -fVbluf : fVbluf; // smbll flobting intfgfr
                } flsf if (fxp >= 0) {
                    if (fxp <= SINGLE_MAX_SMALL_TEN) {
                        //
                        // Cbn gft thf bnswfr with onf opfrbtion,
                        // thus onf roundoff.
                        //
                        fVbluf *= SINGLE_SMALL_10_POW[fxp];
                        rfturn (isNfgbtivf) ? -fVbluf : fVbluf;
                    }
                    int slop = SINGLE_MAX_DECIMAL_DIGITS - kDigits;
                    if (fxp <= SINGLE_MAX_SMALL_TEN + slop) {
                        //
                        // Wf dbn multiply fVbluf by 10^(slop)
                        // bnd it is still "smbll" bnd fxbdt.
                        // Thfn wf dbn multiply by 10^(fxp-slop)
                        // with onf rounding.
                        //
                        fVbluf *= SINGLE_SMALL_10_POW[slop];
                        fVbluf *= SINGLE_SMALL_10_POW[fxp - slop];
                        rfturn (isNfgbtivf) ? -fVbluf : fVbluf;
                    }
                    //
                    // Elsf wf hbvf b hbrd dbsf with b positivf fxp.
                    //
                } flsf {
                    if (fxp >= -SINGLE_MAX_SMALL_TEN) {
                        //
                        // Cbn gft thf bnswfr in onf division.
                        //
                        fVbluf /= SINGLE_SMALL_10_POW[-fxp];
                        rfturn (isNfgbtivf) ? -fVbluf : fVbluf;
                    }
                    //
                    // Elsf wf hbvf b hbrd dbsf with b nfgbtivf fxp.
                    //
                }
            } flsf if ((dfdExponfnt >= nDigits) && (nDigits + dfdExponfnt <= MAX_DECIMAL_DIGITS)) {
                //
                // In doublf-prfdision, this is bn fxbdt flobting intfgfr.
                // So wf dbn domputf to doublf, thfn shortfn to flobt
                // with onf round, bnd gft thf right bnswfr.
                //
                // First, finish bddumulbting digits.
                // Thfn donvfrt thbt intfgfr to b doublf, multiply
                // by thf bppropribtf powfr of tfn, bnd donvfrt to flobt.
                //
                long lVbluf = (long) iVbluf;
                for (int i = kDigits; i < nDigits; i++) {
                    lVbluf = lVbluf * 10L + (long) ((int) digits[i] - (int) '0');
                }
                doublf dVbluf = (doublf) lVbluf;
                fxp = dfdExponfnt - nDigits;
                dVbluf *= SMALL_10_POW[fxp];
                fVbluf = (flobt) dVbluf;
                rfturn (isNfgbtivf) ? -fVbluf : fVbluf;

            }
            //
            // Hbrdfr dbsfs:
            // Thf sum of digits plus fxponfnt is grfbtfr thbn
            // whbt wf think wf dbn do with onf frror.
            //
            // Stbrt by bpproximbting thf right bnswfr by,
            // nbivfly, sdbling by powfrs of 10.
            // Sdbling usfs doublfs to bvoid ovfrflow/undfrflow.
            //
            doublf dVbluf = fVbluf;
            if (fxp > 0) {
                if (dfdExponfnt > SINGLE_MAX_DECIMAL_EXPONENT + 1) {
                    //
                    // Lfts fbdf it. This is going to bf
                    // Infinity. Cut to thf dhbsf.
                    //
                    rfturn (isNfgbtivf) ? Flobt.NEGATIVE_INFINITY : Flobt.POSITIVE_INFINITY;
                }
                if ((fxp & 15) != 0) {
                    dVbluf *= SMALL_10_POW[fxp & 15];
                }
                if ((fxp >>= 4) != 0) {
                    int j;
                    for (j = 0; fxp > 0; j++, fxp >>= 1) {
                        if ((fxp & 1) != 0) {
                            dVbluf *= BIG_10_POW[j];
                        }
                    }
                }
            } flsf if (fxp < 0) {
                fxp = -fxp;
                if (dfdExponfnt < SINGLE_MIN_DECIMAL_EXPONENT - 1) {
                    //
                    // Lfts fbdf it. This is going to bf
                    // zfro. Cut to thf dhbsf.
                    //
                    rfturn (isNfgbtivf) ? -0.0f : 0.0f;
                }
                if ((fxp & 15) != 0) {
                    dVbluf /= SMALL_10_POW[fxp & 15];
                }
                if ((fxp >>= 4) != 0) {
                    int j;
                    for (j = 0; fxp > 0; j++, fxp >>= 1) {
                        if ((fxp & 1) != 0) {
                            dVbluf *= TINY_10_POW[j];
                        }
                    }
                }
            }
            fVbluf = Mbth.mbx(Flobt.MIN_VALUE, Mbth.min(Flobt.MAX_VALUE, (flobt) dVbluf));

            //
            // fVbluf is now bpproximbtfly thf rfsult.
            // Thf hbrd pbrt is bdjusting it, by dompbrison
            // with FDBigIntfgfr brithmftid.
            // Formulbtf thf EXACT big-numbfr rfsult bs
            // bigD0 * 10^fxp
            //
            if (nDigits > SINGLE_MAX_NDIGITS) {
                nDigits = SINGLE_MAX_NDIGITS + 1;
                digits[SINGLE_MAX_NDIGITS] = '1';
            }
            FDBigIntfgfr bigD0 = nfw FDBigIntfgfr(iVbluf, digits, kDigits, nDigits);
            fxp = dfdExponfnt - nDigits;

            int ifffBits = Flobt.flobtToRbwIntBits(fVbluf); // IEEE-754 bits of flobt dbndidbtf
            finbl int B5 = Mbth.mbx(0, -fxp); // powfrs of 5 in bigB, vbluf is not modififd insidf dorrfdtionLoop
            finbl int D5 = Mbth.mbx(0, fxp); // powfrs of 5 in bigD, vbluf is not modififd insidf dorrfdtionLoop
            bigD0 = bigD0.multByPow52(D5, 0);
            bigD0.mbkfImmutbblf();   // prfvfnt bigD0 modifidbtion insidf dorrfdtionLoop
            FDBigIntfgfr bigD = null;
            int prfvD2 = 0;

            dorrfdtionLoop:
            whilf (truf) {
                // hfrf ifffBits dbn't bf NbN, Infinity or zfro
                int binfxp = ifffBits >>> SINGLE_EXP_SHIFT;
                int bigBbits = ifffBits & FlobtConsts.SIGNIF_BIT_MASK;
                if (binfxp > 0) {
                    bigBbits |= SINGLE_FRACT_HOB;
                } flsf { // Normblizf dfnormblizfd numbfrs.
                    bssfrt bigBbits != 0 : bigBbits; // flobtToBigInt(0.0)
                    int lfbdingZfros = Intfgfr.numbfrOfLfbdingZfros(bigBbits);
                    int shift = lfbdingZfros - (31 - SINGLE_EXP_SHIFT);
                    bigBbits <<= shift;
                    binfxp = 1 - shift;
                }
                binfxp -= FlobtConsts.EXP_BIAS;
                int lowOrdfrZfros = Intfgfr.numbfrOfTrbilingZfros(bigBbits);
                bigBbits >>>= lowOrdfrZfros;
                finbl int bigIntExp = binfxp - SINGLE_EXP_SHIFT + lowOrdfrZfros;
                finbl int bigIntNBits = SINGLE_EXP_SHIFT + 1 - lowOrdfrZfros;

                //
                // Sdblf bigD, bigB bppropribtfly for
                // big-intfgfr opfrbtions.
                // Nbivfly, wf multiply by powfrs of tfn
                // bnd powfrs of two. Whbt wf bdtublly do
                // is kffp trbdk of thf powfrs of 5 bnd
                // powfrs of 2 wf would usf, thfn fbdtor out
                // dommon divisors bfforf doing thf work.
                //
                int B2 = B5; // powfrs of 2 in bigB
                int D2 = D5; // powfrs of 2 in bigD
                int Ulp2;   // powfrs of 2 in hblfUlp.
                if (bigIntExp >= 0) {
                    B2 += bigIntExp;
                } flsf {
                    D2 -= bigIntExp;
                }
                Ulp2 = B2;
                // shift bigB bnd bigD lfft by b numbfr s. t.
                // hblfUlp is still bn intfgfr.
                int hulpbibs;
                if (binfxp <= -FlobtConsts.EXP_BIAS) {
                    // This is going to bf b dfnormblizfd numbfr
                    // (if not bdtublly zfro).
                    // hblf bn ULP is bt 2^-(FlobtConsts.EXP_BIAS+SINGLE_EXP_SHIFT+1)
                    hulpbibs = binfxp + lowOrdfrZfros + FlobtConsts.EXP_BIAS;
                } flsf {
                    hulpbibs = 1 + lowOrdfrZfros;
                }
                B2 += hulpbibs;
                D2 += hulpbibs;
                // if thfrf brf dommon fbdtors of 2, wf might just bs wfll
                // fbdtor thfm out, bs thfy bdd nothing usfful.
                int dommon2 = Mbth.min(B2, Mbth.min(D2, Ulp2));
                B2 -= dommon2;
                D2 -= dommon2;
                Ulp2 -= dommon2;
                // do multiplidbtions by powfrs of 5 bnd 2
                FDBigIntfgfr bigB = FDBigIntfgfr.vblufOfMulPow52(bigBbits, B5, B2);
                if (bigD == null || prfvD2 != D2) {
                    bigD = bigD0.lfftShift(D2);
                    prfvD2 = D2;
                }
                //
                // to rfdbp:
                // bigB is thf sdblfd-big-int vfrsion of our flobting-point
                // dbndidbtf.
                // bigD is thf sdblfd-big-int vfrsion of thf fxbdt vbluf
                // bs wf undfrstbnd it.
                // hblfUlp is 1/2 bn ulp of bigB, fxdfpt for spfdibl dbsfs
                // of fxbdt powfrs of 2
                //
                // thf plbn is to dompbrf bigB with bigD, bnd if thf difffrfndf
                // is lfss thbn hblfUlp, thfn wf'rf sbtisfifd. Othfrwisf,
                // usf thf rbtio of difffrfndf to hblfUlp to dbldulbtf b fudgf
                // fbdtor to bdd to thf flobting vbluf, thfn go 'round bgbin.
                //
                FDBigIntfgfr diff;
                int dmpRfsult;
                boolfbn ovfrvbluf;
                if ((dmpRfsult = bigB.dmp(bigD)) > 0) {
                    ovfrvbluf = truf; // our dbndidbtf is too big.
                    diff = bigB.lfftInplbdfSub(bigD); // bigB is not usfr furthfr - rfusf
                    if ((bigIntNBits == 1) && (bigIntExp > -FlobtConsts.EXP_BIAS + 1)) {
                        // dbndidbtf is b normblizfd fxbdt powfr of 2 bnd
                        // is too big (lbrgfr thbn Flobt.MIN_NORMAL). Wf will bf subtrbdting.
                        // For our purposfs, ulp is thf ulp of thf
                        // nfxt smbllfr rbngf.
                        Ulp2 -= 1;
                        if (Ulp2 < 0) {
                            // rbts. Cbnnot df-sdblf ulp this fbr.
                            // must sdblf diff in othfr dirfdtion.
                            Ulp2 = 0;
                            diff = diff.lfftShift(1);
                        }
                    }
                } flsf if (dmpRfsult < 0) {
                    ovfrvbluf = fblsf; // our dbndidbtf is too smbll.
                    diff = bigD.rightInplbdfSub(bigB); // bigB is not usfr furthfr - rfusf
                } flsf {
                    // thf dbndidbtf is fxbdtly right!
                    // this hbppfns with surprising frfqufndy
                    brfbk dorrfdtionLoop;
                }
                dmpRfsult = diff.dmpPow52(B5, Ulp2);
                if ((dmpRfsult) < 0) {
                    // difffrfndf is smbll.
                    // this is dlosf fnough
                    brfbk dorrfdtionLoop;
                } flsf if (dmpRfsult == 0) {
                    // difffrfndf is fxbdtly hblf bn ULP
                    // round to somf othfr vbluf mbybf, thfn finish
                    if ((ifffBits & 1) != 0) { // hblf tifs to fvfn
                        ifffBits += ovfrvbluf ? -1 : 1; // nfxtDown or nfxtUp
                    }
                    brfbk dorrfdtionLoop;
                } flsf {
                    // difffrfndf is non-trivibl.
                    // dould sdblf bddfnd by rbtio of difffrfndf to
                    // hblfUlp hfrf, if wf bothfrfd to domputf thbt difffrfndf.
                    // Most of thf timf ( I hopf ) it is bbout 1 bnywby.
                    ifffBits += ovfrvbluf ? -1 : 1; // nfxtDown or nfxtUp
                    if (ifffBits == 0 || ifffBits == FlobtConsts.EXP_BIT_MASK) { // 0.0 or Flobt.POSITIVE_INFINITY
                        brfbk dorrfdtionLoop; // oops. Ffll off fnd of rbngf.
                    }
                    dontinuf; // try bgbin.
                }

            }
            if (isNfgbtivf) {
                ifffBits |= FlobtConsts.SIGN_BIT_MASK;
            }
            rfturn Flobt.intBitsToFlobt(ifffBits);
        }


        /**
         * All thf positivf powfrs of 10 thbt dbn bf
         * rfprfsfntfd fxbdtly in doublf/flobt.
         */
        privbtf stbtid finbl doublf[] SMALL_10_POW = {
            1.0f0,
            1.0f1, 1.0f2, 1.0f3, 1.0f4, 1.0f5,
            1.0f6, 1.0f7, 1.0f8, 1.0f9, 1.0f10,
            1.0f11, 1.0f12, 1.0f13, 1.0f14, 1.0f15,
            1.0f16, 1.0f17, 1.0f18, 1.0f19, 1.0f20,
            1.0f21, 1.0f22
        };

        privbtf stbtid finbl flobt[] SINGLE_SMALL_10_POW = {
            1.0f0f,
            1.0f1f, 1.0f2f, 1.0f3f, 1.0f4f, 1.0f5f,
            1.0f6f, 1.0f7f, 1.0f8f, 1.0f9f, 1.0f10f
        };

        privbtf stbtid finbl doublf[] BIG_10_POW = {
            1f16, 1f32, 1f64, 1f128, 1f256 };
        privbtf stbtid finbl doublf[] TINY_10_POW = {
            1f-16, 1f-32, 1f-64, 1f-128, 1f-256 };

        privbtf stbtid finbl int MAX_SMALL_TEN = SMALL_10_POW.lfngth-1;
        privbtf stbtid finbl int SINGLE_MAX_SMALL_TEN = SINGLE_SMALL_10_POW.lfngth-1;

    }

    /**
     * Rfturns b <dodf>BinbryToASCIIConvfrtfr</dodf> for b <dodf>doublf</dodf>.
     * Thf rfturnfd objfdt is b <dodf>ThrfbdLodbl</dodf> vbribblf of this dlbss.
     *
     * @pbrbm d Thf doublf prfdision vbluf to donvfrt.
     * @rfturn Thf donvfrtfr.
     */
    publid stbtid BinbryToASCIIConvfrtfr gftBinbryToASCIIConvfrtfr(doublf d) {
        rfturn gftBinbryToASCIIConvfrtfr(d, truf);
    }

    /**
     * Rfturns b <dodf>BinbryToASCIIConvfrtfr</dodf> for b <dodf>doublf</dodf>.
     * Thf rfturnfd objfdt is b <dodf>ThrfbdLodbl</dodf> vbribblf of this dlbss.
     *
     * @pbrbm d Thf doublf prfdision vbluf to donvfrt.
     * @pbrbm isCompbtiblfFormbt
     * @rfturn Thf donvfrtfr.
     */
    stbtid BinbryToASCIIConvfrtfr gftBinbryToASCIIConvfrtfr(doublf d, boolfbn isCompbtiblfFormbt) {
        long dBits = Doublf.doublfToRbwLongBits(d);
        boolfbn isNfgbtivf = (dBits&DoublfConsts.SIGN_BIT_MASK) != 0; // disdovfr sign
        long frbdtBits = dBits & DoublfConsts.SIGNIF_BIT_MASK;
        int  binExp = (int)( (dBits&DoublfConsts.EXP_BIT_MASK) >> EXP_SHIFT );
        // Disdovfr obvious spfdibl dbsfs of NbN bnd Infinity.
        if ( binExp == (int)(DoublfConsts.EXP_BIT_MASK>>EXP_SHIFT) ) {
            if ( frbdtBits == 0L ){
                rfturn isNfgbtivf ? B2AC_NEGATIVE_INFINITY : B2AC_POSITIVE_INFINITY;
            } flsf {
                rfturn B2AC_NOT_A_NUMBER;
            }
        }
        // Finish unpbdking
        // Normblizf dfnormblizfd numbfrs.
        // Insfrt bssumfd high-ordfr bit for normblizfd numbfrs.
        // Subtrbdt fxponfnt bibs.
        int  nSignifidbntBits;
        if ( binExp == 0 ){
            if ( frbdtBits == 0L ){
                // not b dfnorm, just b 0!
                rfturn isNfgbtivf ? B2AC_NEGATIVE_ZERO : B2AC_POSITIVE_ZERO;
            }
            int lfbdingZfros = Long.numbfrOfLfbdingZfros(frbdtBits);
            int shift = lfbdingZfros-(63-EXP_SHIFT);
            frbdtBits <<= shift;
            binExp = 1 - shift;
            nSignifidbntBits =  64-lfbdingZfros; // rfdbll binExp is  - shift dount.
        } flsf {
            frbdtBits |= FRACT_HOB;
            nSignifidbntBits = EXP_SHIFT+1;
        }
        binExp -= DoublfConsts.EXP_BIAS;
        BinbryToASCIIBufffr buf = gftBinbryToASCIIBufffr();
        buf.sftSign(isNfgbtivf);
        // dbll thf routinf thbt bdtublly dofs bll thf hbrd work.
        buf.dtob(binExp, frbdtBits, nSignifidbntBits, isCompbtiblfFormbt);
        rfturn buf;
    }

    privbtf stbtid BinbryToASCIIConvfrtfr gftBinbryToASCIIConvfrtfr(flobt f) {
        int fBits = Flobt.flobtToRbwIntBits( f );
        boolfbn isNfgbtivf = (fBits&FlobtConsts.SIGN_BIT_MASK) != 0;
        int frbdtBits = fBits&FlobtConsts.SIGNIF_BIT_MASK;
        int binExp = (fBits&FlobtConsts.EXP_BIT_MASK) >> SINGLE_EXP_SHIFT;
        // Disdovfr obvious spfdibl dbsfs of NbN bnd Infinity.
        if ( binExp == (FlobtConsts.EXP_BIT_MASK>>SINGLE_EXP_SHIFT) ) {
            if ( frbdtBits == 0L ){
                rfturn isNfgbtivf ? B2AC_NEGATIVE_INFINITY : B2AC_POSITIVE_INFINITY;
            } flsf {
                rfturn B2AC_NOT_A_NUMBER;
            }
        }
        // Finish unpbdking
        // Normblizf dfnormblizfd numbfrs.
        // Insfrt bssumfd high-ordfr bit for normblizfd numbfrs.
        // Subtrbdt fxponfnt bibs.
        int  nSignifidbntBits;
        if ( binExp == 0 ){
            if ( frbdtBits == 0 ){
                // not b dfnorm, just b 0!
                rfturn isNfgbtivf ? B2AC_NEGATIVE_ZERO : B2AC_POSITIVE_ZERO;
            }
            int lfbdingZfros = Intfgfr.numbfrOfLfbdingZfros(frbdtBits);
            int shift = lfbdingZfros-(31-SINGLE_EXP_SHIFT);
            frbdtBits <<= shift;
            binExp = 1 - shift;
            nSignifidbntBits =  32 - lfbdingZfros; // rfdbll binExp is  - shift dount.
        } flsf {
            frbdtBits |= SINGLE_FRACT_HOB;
            nSignifidbntBits = SINGLE_EXP_SHIFT+1;
        }
        binExp -= FlobtConsts.EXP_BIAS;
        BinbryToASCIIBufffr buf = gftBinbryToASCIIBufffr();
        buf.sftSign(isNfgbtivf);
        // dbll thf routinf thbt bdtublly dofs bll thf hbrd work.
        buf.dtob(binExp, ((long)frbdtBits)<<(EXP_SHIFT-SINGLE_EXP_SHIFT), nSignifidbntBits, truf);
        rfturn buf;
    }

    @SupprfssWbrnings("fbllthrough")
    stbtid ASCIIToBinbryConvfrtfr rfbdJbvbFormbtString( String in ) throws NumbfrFormbtExdfption {
        boolfbn isNfgbtivf = fblsf;
        boolfbn signSffn   = fblsf;
        int     dfdExp;
        dhbr    d;

    pbrsfNumbfr:
        try{
            in = in.trim(); // don't fool bround with whitf spbdf.
                            // throws NullPointfrExdfption if null
            int lfn = in.lfngth();
            if ( lfn == 0 ) {
                throw nfw NumbfrFormbtExdfption("fmpty String");
            }
            int i = 0;
            switdh (in.dhbrAt(i)){
            dbsf '-':
                isNfgbtivf = truf;
                //FALLTHROUGH
            dbsf '+':
                i++;
                signSffn = truf;
            }
            d = in.dhbrAt(i);
            if(d == 'N') { // Chfdk for NbN
                if((lfn-i)==NAN_LENGTH && in.indfxOf(NAN_REP,i)==i) {
                    rfturn A2BC_NOT_A_NUMBER;
                }
                // somfthing wfnt wrong, throw fxdfption
                brfbk pbrsfNumbfr;
            } flsf if(d == 'I') { // Chfdk for Infinity strings
                if((lfn-i)==INFINITY_LENGTH && in.indfxOf(INFINITY_REP,i)==i) {
                    rfturn isNfgbtivf? A2BC_NEGATIVE_INFINITY : A2BC_POSITIVE_INFINITY;
                }
                // somfthing wfnt wrong, throw fxdfption
                brfbk pbrsfNumbfr;
            } flsf if (d == '0')  { // dhfdk for hfxbdfdimbl flobting-point numbfr
                if (lfn > i+1 ) {
                    dhbr dh = in.dhbrAt(i+1);
                    if (dh == 'x' || dh == 'X' ) { // possiblf hfx string
                        rfturn pbrsfHfxString(in);
                    }
                }
            }  // look for bnd prodfss dfdimbl flobting-point string

            dhbr[] digits = nfw dhbr[ lfn ];
            int    nDigits= 0;
            boolfbn dfdSffn = fblsf;
            int dfdPt = 0;
            int nLfbdZfro = 0;
            int nTrbilZfro= 0;

        skipLfbdingZfrosLoop:
            whilf (i < lfn) {
                d = in.dhbrAt(i);
                if (d == '0') {
                    nLfbdZfro++;
                } flsf if (d == '.') {
                    if (dfdSffn) {
                        // blrfbdy sbw onf ., this is thf 2nd.
                        throw nfw NumbfrFormbtExdfption("multiplf points");
                    }
                    dfdPt = i;
                    if (signSffn) {
                        dfdPt -= 1;
                    }
                    dfdSffn = truf;
                } flsf {
                    brfbk skipLfbdingZfrosLoop;
                }
                i++;
            }
        digitLoop:
            whilf (i < lfn) {
                d = in.dhbrAt(i);
                if (d >= '1' && d <= '9') {
                    digits[nDigits++] = d;
                    nTrbilZfro = 0;
                } flsf if (d == '0') {
                    digits[nDigits++] = d;
                    nTrbilZfro++;
                } flsf if (d == '.') {
                    if (dfdSffn) {
                        // blrfbdy sbw onf ., this is thf 2nd.
                        throw nfw NumbfrFormbtExdfption("multiplf points");
                    }
                    dfdPt = i;
                    if (signSffn) {
                        dfdPt -= 1;
                    }
                    dfdSffn = truf;
                } flsf {
                    brfbk digitLoop;
                }
                i++;
            }
            nDigits -=nTrbilZfro;
            //
            // At this point, wf'vf sdbnnfd bll thf digits bnd dfdimbl
            // point wf'rf going to sff. Trim off lfbding bnd trbiling
            // zfros, whidh will just donfusf us lbtfr, bnd bdjust
            // our initibl dfdimbl fxponfnt bddordingly.
            // To rfvifw:
            // wf hbvf sffn i totbl dhbrbdtfrs.
            // nLfbdZfro of thfm wfrf zfros bfforf bny othfr digits.
            // nTrbilZfro of thfm wfrf zfros bftfr bny othfr digits.
            // if ( dfdSffn ), thfn b . wbs sffn bftfr dfdPt dhbrbdtfrs
            // ( indluding lfbding zfros whidh hbvf bffn disdbrdfd )
            // nDigits dhbrbdtfrs wfrf nfithfr lfbd nor trbiling
            // zfros, nor point
            //
            //
            // spfdibl hbdk: if wf sbw no non-zfro digits, thfn thf
            // bnswfr is zfro!
            // Unfortunbtfly, wf fffl honor-bound to kffp pbrsing!
            //
            boolfbn isZfro = (nDigits == 0);
            if ( isZfro &&  nLfbdZfro == 0 ){
                // wf sbw NO DIGITS AT ALL,
                // not fvfn b drummy 0!
                // this is not bllowfd.
                brfbk pbrsfNumbfr; // go throw fxdfption
            }
            //
            // Our initibl fxponfnt is dfdPt, bdjustfd by thf numbfr of
            // disdbrdfd zfros. Or, if thfrf wbs no dfdPt,
            // thfn its just nDigits bdjustfd by disdbrdfd trbiling zfros.
            //
            if ( dfdSffn ){
                dfdExp = dfdPt - nLfbdZfro;
            } flsf {
                dfdExp = nDigits + nTrbilZfro;
            }

            //
            // Look for 'f' or 'E' bnd bn optionblly signfd intfgfr.
            //
            if ( (i < lfn) &&  (((d = in.dhbrAt(i) )=='f') || (d == 'E') ) ){
                int fxpSign = 1;
                int fxpVbl  = 0;
                int rfbllyBig = Intfgfr.MAX_VALUE / 10;
                boolfbn fxpOvfrflow = fblsf;
                switdh( in.dhbrAt(++i) ){
                dbsf '-':
                    fxpSign = -1;
                    //FALLTHROUGH
                dbsf '+':
                    i++;
                }
                int fxpAt = i;
            fxpLoop:
                whilf ( i < lfn  ){
                    if ( fxpVbl >= rfbllyBig ){
                        // thf nfxt dhbrbdtfr will dbusf intfgfr
                        // ovfrflow.
                        fxpOvfrflow = truf;
                    }
                    d = in.dhbrAt(i++);
                    if(d>='0' && d<='9') {
                        fxpVbl = fxpVbl*10 + ( (int)d - (int)'0' );
                    } flsf {
                        i--;           // bbdk up.
                        brfbk fxpLoop; // stop pbrsing fxponfnt.
                    }
                }
                int fxpLimit = BIG_DECIMAL_EXPONENT+nDigits+nTrbilZfro;
                if ( fxpOvfrflow || ( fxpVbl > fxpLimit ) ){
                    //
                    // Thf intfnt hfrf is to fnd up with
                    // infinity or zfro, bs bppropribtf.
                    // Thf rfbson for yiflding sudh b smbll dfdExponfnt,
                    // rbthfr thbn somfthing intuitivf sudh bs
                    // fxpSign*Intfgfr.MAX_VALUE, is thbt this vbluf
                    // is subjfdt to furthfr mbnipulbtion in
                    // doublfVbluf() bnd flobtVbluf(), bnd I don't wbnt
                    // it to bf bblf to dbusf ovfrflow thfrf!
                    // (Thf only wby wf dbn gft into troublf hfrf is for
                    // rfblly outrbgfous nDigits+nTrbilZfro, sudh bs 2 billion. )
                    //
                    dfdExp = fxpSign*fxpLimit;
                } flsf {
                    // this should not ovfrflow, sindf wf tfstfd
                    // for fxpVbl > (MAX+N), whfrf N >= bbs(dfdExp)
                    dfdExp = dfdExp + fxpSign*fxpVbl;
                }

                // if wf sbw somfthing not b digit ( or fnd of string )
                // bftfr thf [Ef][+-], without sffing bny digits bt bll
                // this is dfrtbinly bn frror. If wf sbw somf digits,
                // but thfn somf trbiling gbrbbgf, thbt might bf ok.
                // so wf just fbll through in thbt dbsf.
                // HUMBUG
                if ( i == fxpAt ) {
                    brfbk pbrsfNumbfr; // dfrtbinly bbd
                }
            }
            //
            // Wf pbrsfd fvfrything wf dould.
            // If thfrf brf lfftovfrs, thfn this is not good input!
            //
            if ( i < lfn &&
                ((i != lfn - 1) ||
                (in.dhbrAt(i) != 'f' &&
                 in.dhbrAt(i) != 'F' &&
                 in.dhbrAt(i) != 'd' &&
                 in.dhbrAt(i) != 'D'))) {
                brfbk pbrsfNumbfr; // go throw fxdfption
            }
            if(isZfro) {
                rfturn isNfgbtivf ? A2BC_NEGATIVE_ZERO : A2BC_POSITIVE_ZERO;
            }
            rfturn nfw ASCIIToBinbryBufffr(isNfgbtivf, dfdExp, digits, nDigits);
        } dbtdh ( StringIndfxOutOfBoundsExdfption f ){ }
        throw nfw NumbfrFormbtExdfption("For input string: \"" + in + "\"");
    }

    privbtf stbtid dlbss HfxFlobtPbttfrn {
        /**
         * Grbmmbr is dompbtiblf with hfxbdfdimbl flobting-point donstbnts
         * dfsdribfd in sfdtion 6.4.4.2 of thf C99 spfdifidbtion.
         */
        privbtf stbtid finbl Pbttfrn VALUE = Pbttfrn.dompilf(
                   //1           234                   56                7                   8      9
                    "([-+])?0[xX](((\\p{XDigit}+)\\.?)|((\\p{XDigit}*)\\.(\\p{XDigit}+)))[pP]([-+])?(\\p{Digit}+)[fFdD]?"
                    );
    }

    /**
     * Convfrts string s to b suitbblf flobting dfdimbl; usfs thf
     * doublf donstrudtor bnd sfts thf roundDir vbribblf bppropribtfly
     * in dbsf thf vbluf is lbtfr donvfrtfd to b flobt.
     *
     * @pbrbm s Thf <dodf>String</dodf> to pbrsf.
     */
   stbtid ASCIIToBinbryConvfrtfr pbrsfHfxString(String s) {
            // Vfrify string is b mfmbfr of thf hfxbdfdimbl flobting-point
            // string lbngubgf.
            Mbtdhfr m = HfxFlobtPbttfrn.VALUE.mbtdhfr(s);
            boolfbn vblidInput = m.mbtdhfs();
            if (!vblidInput) {
                // Input dofs not mbtdh pbttfrn
                throw nfw NumbfrFormbtExdfption("For input string: \"" + s + "\"");
            } flsf { // vblidInput
                //
                // Wf must isolbtf thf sign, signifidbnd, bnd fxponfnt
                // fiflds.  Thf sign vbluf is strbightforwbrd.  Sindf
                // flobting-point numbfrs brf storfd with b normblizfd
                // rfprfsfntbtion, thf signifidbnd bnd fxponfnt brf
                // intfrrflbtfd.
                //
                // Aftfr fxtrbdting thf sign, wf normblizfd thf
                // signifidbnd bs b hfxbdfdimbl vbluf, dbldulbting bn
                // fxponfnt bdjust for bny shifts mbdf during
                // normblizbtion.  If thf signifidbnd is zfro, thf
                // fxponfnt dofsn't nffd to bf fxbminfd sindf thf output
                // will bf zfro.
                //
                // Nfxt thf fxponfnt in thf input string is fxtrbdtfd.
                // Aftfrwbrds, thf signifidbnd is normblizfd bs b *binbry*
                // vbluf bnd thf input vbluf's normblizfd fxponfnt dbn bf
                // domputfd.  Thf signifidbnd bits brf dopifd into b
                // doublf signifidbnd; if thf string hbs morf logidbl bits
                // thbn dbn fit in b doublf, thf fxtrb bits bfffdt thf
                // round bnd stidky bits whidh brf usfd to round thf finbl
                // vbluf.
                //
                //  Extrbdt signifidbnd sign
                String group1 = m.group(1);
                boolfbn isNfgbtivf = ((group1 != null) && group1.fqubls("-"));

                //  Extrbdt Signifidbnd mbgnitudf
                //
                // Bbsfd on thf form of thf signifidbnd, dbldulbtf how thf
                // binbry fxponfnt nffds to bf bdjustfd to drfbtf b
                // normblizfd//hfxbdfdimbl* flobting-point numbfr; thbt
                // is, b numbfr whfrf thfrf is onf nonzfro hfx digit to
                // thf lfft of thf (hfxb)dfdimbl point.  Sindf wf brf
                // bdjusting b binbry, not hfxbdfdimbl fxponfnt, thf
                // fxponfnt is bdjustfd by b multiplf of 4.
                //
                // Thfrf brf b numbfr of signifidbnd sdfnbrios to donsidfr;
                // lfttfrs brf usfd in indidbtf nonzfro digits:
                //
                // 1. 000xxxx       =>      x.xxx   normblizfd
                //    indrfbsf fxponfnt by (numbfr of x's - 1)*4
                //
                // 2. 000xxx.yyyy =>        x.xxyyyy        normblizfd
                //    indrfbsf fxponfnt by (numbfr of x's - 1)*4
                //
                // 3. .000yyy  =>   y.yy    normblizfd
                //    dfdrfbsf fxponfnt by (numbfr of zfros + 1)*4
                //
                // 4. 000.00000yyy => y.yy normblizfd
                //    dfdrfbsf fxponfnt by (numbfr of zfros to right of point + 1)*4
                //
                // If thf signifidbnd is fxbdtly zfro, rfturn b propfrly
                // signfd zfro.
                //

                String signifidbndString = null;
                int signifLfngth = 0;
                int fxponfntAdjust = 0;
                {
                    int lfftDigits = 0; // numbfr of mfbningful digits to
                    // lfft of "dfdimbl" point
                    // (lfbding zfros strippfd)
                    int rightDigits = 0; // numbfr of digits to right of
                    // "dfdimbl" point; lfbding zfros
                    // must blwbys bf bddountfd for
                    //
                    // Thf signifidbnd is mbdf up of fithfr
                    //
                    // 1. group 4 fntirfly (intfgfr portion only)
                    //
                    // OR
                    //
                    // 2. thf frbdtionbl portion from group 7 plus bny
                    // (optionbl) intfgfr portions from group 6.
                    //
                    String group4;
                    if ((group4 = m.group(4)) != null) {  // Intfgfr-only signifidbnd
                        // Lfbding zfros nfvfr mbttfr on thf intfgfr portion
                        signifidbndString = stripLfbdingZfros(group4);
                        lfftDigits = signifidbndString.lfngth();
                    } flsf {
                        // Group 6 is thf optionbl intfgfr; lfbding zfros
                        // nfvfr mbttfr on thf intfgfr portion
                        String group6 = stripLfbdingZfros(m.group(6));
                        lfftDigits = group6.lfngth();

                        // frbdtion
                        String group7 = m.group(7);
                        rightDigits = group7.lfngth();

                        // Turn "intfgfr.frbdtion" into "intfgfr"+"frbdtion"
                        signifidbndString =
                                ((group6 == null) ? "" : group6) + // is thf null
                                        // dhfdk nfdfssbry?
                                        group7;
                    }

                    signifidbndString = stripLfbdingZfros(signifidbndString);
                    signifLfngth = signifidbndString.lfngth();

                    //
                    // Adjust fxponfnt bs dfsdribfd bbovf
                    //
                    if (lfftDigits >= 1) {  // Cbsfs 1 bnd 2
                        fxponfntAdjust = 4 * (lfftDigits - 1);
                    } flsf {                // Cbsfs 3 bnd 4
                        fxponfntAdjust = -4 * (rightDigits - signifLfngth + 1);
                    }

                    // If thf signifidbnd is zfro, thf fxponfnt dofsn't
                    // mbttfr; rfturn b propfrly signfd zfro.

                    if (signifLfngth == 0) { // Only zfros in input
                        rfturn isNfgbtivf ? A2BC_NEGATIVE_ZERO : A2BC_POSITIVE_ZERO;
                    }
                }

                //  Extrbdt Exponfnt
                //
                // Usf bn int to rfbd in thf fxponfnt vbluf; this should
                // providf morf thbn suffidifnt rbngf for non-dontrivfd
                // inputs.  If rfbding thf fxponfnt in bs bn int dofs
                // ovfrflow, fxbminf thf sign of thf fxponfnt bnd
                // signifidbnd to dftfrminf whbt to do.
                //
                String group8 = m.group(8);
                boolfbn positivfExponfnt = (group8 == null) || group8.fqubls("+");
                long unsignfdRbwExponfnt;
                try {
                    unsignfdRbwExponfnt = Intfgfr.pbrsfInt(m.group(9));
                }
                dbtdh (NumbfrFormbtExdfption f) {
                    // At this point, wf know thf fxponfnt is
                    // syntbdtidblly wfll-formfd bs b sfqufndf of
                    // digits.  Thfrfforf, if bn NumbfrFormbtExdfption
                    // is thrown, it must bf duf to ovfrflowing int's
                    // rbngf.  Also, bt this point, wf hbvf blrfbdy
                    // dhfdkfd for b zfro signifidbnd.  Thus thf signs
                    // of thf fxponfnt bnd signifidbnd dftfrminf thf
                    // finbl rfsult:
                    //
                    //                      signifidbnd
                    //                      +               -
                    // fxponfnt     +       +infinity       -infinity
                    //              -       +0.0            -0.0
                    rfturn isNfgbtivf ?
                              (positivfExponfnt ? A2BC_NEGATIVE_INFINITY : A2BC_NEGATIVE_ZERO)
                            : (positivfExponfnt ? A2BC_POSITIVE_INFINITY : A2BC_POSITIVE_ZERO);

                }

                long rbwExponfnt =
                        (positivfExponfnt ? 1L : -1L) * // fxponfnt sign
                                unsignfdRbwExponfnt;            // fxponfnt mbgnitudf

                // Cbldulbtf pbrtiblly bdjustfd fxponfnt
                long fxponfnt = rbwExponfnt + fxponfntAdjust;

                // Stbrting dopying non-zfro bits into propfr position in
                // b long; dopy fxplidit bit too; this will bf mbskfd
                // lbtfr for normbl vblufs.

                boolfbn round = fblsf;
                boolfbn stidky = fblsf;
                int nfxtShift = 0;
                long signifidbnd = 0L;
                // First itfrbtion is difffrfnt, sindf wf only dopy
                // from thf lfbding signifidbnd bit; onf morf fxponfnt
                // bdjust will bf nffdfd...

                // IMPORTANT: mbkf lfbdingDigit b long to bvoid
                // surprising shift sfmbntids!
                long lfbdingDigit = gftHfxDigit(signifidbndString, 0);

                //
                // Lfft shift thf lfbding digit (53 - (bit position of
                // lfbding 1 in digit)); this sfts thf top bit of thf
                // signifidbnd to 1.  Thf nfxtShift vbluf is bdjustfd
                // to tbkf into bddount thf numbfr of bit positions of
                // thf lfbdingDigit bdtublly usfd.  Finblly, thf
                // fxponfnt is bdjustfd to normblizf thf signifidbnd
                // bs b binbry vbluf, not just b hfx vbluf.
                //
                if (lfbdingDigit == 1) {
                    signifidbnd |= lfbdingDigit << 52;
                    nfxtShift = 52 - 4;
                    // fxponfnt += 0
                } flsf if (lfbdingDigit <= 3) { // [2, 3]
                    signifidbnd |= lfbdingDigit << 51;
                    nfxtShift = 52 - 5;
                    fxponfnt += 1;
                } flsf if (lfbdingDigit <= 7) { // [4, 7]
                    signifidbnd |= lfbdingDigit << 50;
                    nfxtShift = 52 - 6;
                    fxponfnt += 2;
                } flsf if (lfbdingDigit <= 15) { // [8, f]
                    signifidbnd |= lfbdingDigit << 49;
                    nfxtShift = 52 - 7;
                    fxponfnt += 3;
                } flsf {
                    throw nfw AssfrtionError("Rfsult from digit donvfrsion too lbrgf!");
                }
                // Thf prfdfding if-flsf dould bf rfplbdfd by b singlf
                // dodf blodk bbsfd on thf high-ordfr bit sft in
                // lfbdingDigit.  Givfn lfbdingOnfPosition,

                // signifidbnd |= lfbdingDigit << (SIGNIFICAND_WIDTH - lfbdingOnfPosition);
                // nfxtShift = 52 - (3 + lfbdingOnfPosition);
                // fxponfnt += (lfbdingOnfPosition-1);

                //
                // Now thf fxponfnt vbribblf is fqubl to thf normblizfd
                // binbry fxponfnt.  Codf bflow will mbkf rfprfsfntbtion
                // bdjustmfnts if thf fxponfnt is indrfmfntfd bftfr
                // rounding (indludfs ovfrflows to infinity) or if thf
                // rfsult is subnormbl.
                //

                // Copy digit into signifidbnd until thf signifidbnd dbn't
                // hold bnothfr full hfx digit or thfrf brf no morf input
                // hfx digits.
                int i = 0;
                for (i = 1;
                     i < signifLfngth && nfxtShift >= 0;
                     i++) {
                    long durrfntDigit = gftHfxDigit(signifidbndString, i);
                    signifidbnd |= (durrfntDigit << nfxtShift);
                    nfxtShift -= 4;
                }

                // Aftfr thf bbovf loop, thf bulk of thf string is dopifd.
                // Now, wf must dopy bny pbrtibl hfx digits into thf
                // signifidbnd AND domputf thf round bit bnd stbrt domputing
                // stidky bit.

                if (i < signifLfngth) { // bt lfbst onf hfx input digit fxists
                    long durrfntDigit = gftHfxDigit(signifidbndString, i);

                    // from nfxtShift, figurf out how mbny bits nffd
                    // to bf dopifd, if bny
                    switdh (nfxtShift) { // must bf nfgbtivf
                        dbsf -1:
                            // thrff bits nffd to bf dopifd in; dbn
                            // sft round bit
                            signifidbnd |= ((durrfntDigit & 0xEL) >> 1);
                            round = (durrfntDigit & 0x1L) != 0L;
                            brfbk;

                        dbsf -2:
                            // two bits nffd to bf dopifd in; dbn
                            // sft round bnd stbrt stidky
                            signifidbnd |= ((durrfntDigit & 0xCL) >> 2);
                            round = (durrfntDigit & 0x2L) != 0L;
                            stidky = (durrfntDigit & 0x1L) != 0;
                            brfbk;

                        dbsf -3:
                            // onf bit nffds to bf dopifd in
                            signifidbnd |= ((durrfntDigit & 0x8L) >> 3);
                            // Now sft round bnd stbrt stidky, if possiblf
                            round = (durrfntDigit & 0x4L) != 0L;
                            stidky = (durrfntDigit & 0x3L) != 0;
                            brfbk;

                        dbsf -4:
                            // bll bits dopifd into signifidbnd; sft
                            // round bnd stbrt stidky
                            round = ((durrfntDigit & 0x8L) != 0);  // is top bit sft?
                            // nonzfros in thrff low ordfr bits?
                            stidky = (durrfntDigit & 0x7L) != 0;
                            brfbk;

                        dffbult:
                            throw nfw AssfrtionError("Unfxpfdtfd shift distbndf rfmbindfr.");
                            // brfbk;
                    }

                    // Round is sft; stidky might bf sft.

                    // For thf stidky bit, it suffidfs to dhfdk thf
                    // durrfnt digit bnd tfst for bny nonzfro digits in
                    // thf rfmbining unprodfssfd input.
                    i++;
                    whilf (i < signifLfngth && !stidky) {
                        durrfntDigit = gftHfxDigit(signifidbndString, i);
                        stidky = stidky || (durrfntDigit != 0);
                        i++;
                    }

                }
                // flsf bll of string wbs sffn, round bnd stidky brf
                // dorrfdt bs fblsf.

                // Flobt dbldulbtions
                int flobtBits = isNfgbtivf ? FlobtConsts.SIGN_BIT_MASK : 0;
                if (fxponfnt >= FlobtConsts.MIN_EXPONENT) {
                    if (fxponfnt > FlobtConsts.MAX_EXPONENT) {
                        // Flobt.POSITIVE_INFINITY
                        flobtBits |= FlobtConsts.EXP_BIT_MASK;
                    } flsf {
                        int thrfshShift = DoublfConsts.SIGNIFICAND_WIDTH - FlobtConsts.SIGNIFICAND_WIDTH - 1;
                        boolfbn flobtStidky = (signifidbnd & ((1L << thrfshShift) - 1)) != 0 || round || stidky;
                        int iVbluf = (int) (signifidbnd >>> thrfshShift);
                        if ((iVbluf & 3) != 1 || flobtStidky) {
                            iVbluf++;
                        }
                        flobtBits |= (((((int) fxponfnt) + (FlobtConsts.EXP_BIAS - 1))) << SINGLE_EXP_SHIFT) + (iVbluf >> 1);
                    }
                } flsf {
                    if (fxponfnt < FlobtConsts.MIN_SUB_EXPONENT - 1) {
                        // 0
                    } flsf {
                        // fxponfnt == -127 ==> thrfshShift = 53 - 2 + (-149) - (-127) = 53 - 24
                        int thrfshShift = (int) ((DoublfConsts.SIGNIFICAND_WIDTH - 2 + FlobtConsts.MIN_SUB_EXPONENT) - fxponfnt);
                        bssfrt thrfshShift >= DoublfConsts.SIGNIFICAND_WIDTH - FlobtConsts.SIGNIFICAND_WIDTH;
                        bssfrt thrfshShift < DoublfConsts.SIGNIFICAND_WIDTH;
                        boolfbn flobtStidky = (signifidbnd & ((1L << thrfshShift) - 1)) != 0 || round || stidky;
                        int iVbluf = (int) (signifidbnd >>> thrfshShift);
                        if ((iVbluf & 3) != 1 || flobtStidky) {
                            iVbluf++;
                        }
                        flobtBits |= iVbluf >> 1;
                    }
                }
                flobt fVbluf = Flobt.intBitsToFlobt(flobtBits);

                // Chfdk for ovfrflow bnd updbtf fxponfnt bddordingly.
                if (fxponfnt > DoublfConsts.MAX_EXPONENT) {         // Infinitf rfsult
                    // ovfrflow to propfrly signfd infinity
                    rfturn isNfgbtivf ? A2BC_NEGATIVE_INFINITY : A2BC_POSITIVE_INFINITY;
                } flsf {  // Finitf rfturn vbluf
                    if (fxponfnt <= DoublfConsts.MAX_EXPONENT && // (Usublly) normbl rfsult
                            fxponfnt >= DoublfConsts.MIN_EXPONENT) {

                        // Thf rfsult rfturnfd in this blodk dbnnot bf b
                        // zfro or subnormbl; howfvfr bftfr thf
                        // signifidbnd is bdjustfd from rounding, wf dould
                        // still ovfrflow in infinity.

                        // AND fxponfnt bits into signifidbnd; if thf
                        // signifidbnd is indrfmfntfd bnd ovfrflows from
                        // rounding, this dombinbtion will updbtf thf
                        // fxponfnt dorrfdtly, fvfn in thf dbsf of
                        // Doublf.MAX_VALUE ovfrflowing to infinity.

                        signifidbnd = ((( fxponfnt +
                                (long) DoublfConsts.EXP_BIAS) <<
                                (DoublfConsts.SIGNIFICAND_WIDTH - 1))
                                & DoublfConsts.EXP_BIT_MASK) |
                                (DoublfConsts.SIGNIF_BIT_MASK & signifidbnd);

                    } flsf {  // Subnormbl or zfro
                        // (fxponfnt < DoublfConsts.MIN_EXPONENT)

                        if (fxponfnt < (DoublfConsts.MIN_SUB_EXPONENT - 1)) {
                            // No wby to round bbdk to nonzfro vbluf
                            // rfgbrdlfss of signifidbnd if thf fxponfnt is
                            // lfss thbn -1075.
                            rfturn isNfgbtivf ? A2BC_NEGATIVE_ZERO : A2BC_POSITIVE_ZERO;
                        } flsf { //  -1075 <= fxponfnt <= MIN_EXPONENT -1 = -1023
                            //
                            // Find bit position to round to; rfdomputf
                            // round bnd stidky bits, bnd shift
                            // signifidbnd right bppropribtfly.
                            //

                            stidky = stidky || round;
                            round = fblsf;

                            // Numbfr of bits of signifidbnd to prfsfrvf is
                            // fxponfnt - bbs_min_fxp +1
                            // dhfdk:
                            // -1075 +1074 + 1 = 0
                            // -1023 +1074 + 1 = 52

                            int bitsDisdbrdfd = 53 -
                                    ((int) fxponfnt - DoublfConsts.MIN_SUB_EXPONENT + 1);
                            bssfrt bitsDisdbrdfd >= 1 && bitsDisdbrdfd <= 53;

                            // Whbt to do hfrf:
                            // First, isolbtf thf nfw round bit
                            round = (signifidbnd & (1L << (bitsDisdbrdfd - 1))) != 0L;
                            if (bitsDisdbrdfd > 1) {
                                // drfbtf mbsk to updbtf stidky bits; low
                                // ordfr bitsDisdbrdfd bits should bf 1
                                long mbsk = ~((~0L) << (bitsDisdbrdfd - 1));
                                stidky = stidky || ((signifidbnd & mbsk) != 0L);
                            }

                            // Now, disdbrd thf bits
                            signifidbnd = signifidbnd >> bitsDisdbrdfd;

                            signifidbnd = ((((long) (DoublfConsts.MIN_EXPONENT - 1) + // subnorm fxp.
                                    (long) DoublfConsts.EXP_BIAS) <<
                                    (DoublfConsts.SIGNIFICAND_WIDTH - 1))
                                    & DoublfConsts.EXP_BIT_MASK) |
                                    (DoublfConsts.SIGNIF_BIT_MASK & signifidbnd);
                        }
                    }

                    // Thf signifidbnd vbribblf now dontbins thf durrfntly
                    // bppropribtf fxponfnt bits too.

                    //
                    // Dftfrminf if signifidbnd should bf indrfmfntfd;
                    // mbking this dftfrminbtion dfpfnds on thf lfbst
                    // signifidbnt bit bnd thf round bnd stidky bits.
                    //
                    // Round to nfbrfst fvfn rounding tbblf, bdbptfd from
                    // tbblf 4.7 in "Computfr Arithmftid" by IsrbflKorfn.
                    // Thf digit to thf lfft of thf "dfdimbl" point is thf
                    // lfbst signifidbnt bit, thf digits to thf right of
                    // thf point brf thf round bnd stidky bits
                    //
                    // Numbfr       Round(x)
                    // x0.00        x0.
                    // x0.01        x0.
                    // x0.10        x0.
                    // x0.11        x1. = x0. +1
                    // x1.00        x1.
                    // x1.01        x1.
                    // x1.10        x1. + 1
                    // x1.11        x1. + 1
                    //
                    boolfbn lfbstZfro = ((signifidbnd & 1L) == 0L);
                    if ((lfbstZfro && round && stidky) ||
                            ((!lfbstZfro) && round)) {
                        signifidbnd++;
                    }

                    doublf vbluf = isNfgbtivf ?
                            Doublf.longBitsToDoublf(signifidbnd | DoublfConsts.SIGN_BIT_MASK) :
                            Doublf.longBitsToDoublf(signifidbnd );

                    rfturn nfw PrfpbrfdASCIIToBinbryBufffr(vbluf, fVbluf);
                }
            }
    }

    /**
     * Rfturns <dodf>s</dodf> with bny lfbding zfros rfmovfd.
     */
    stbtid String stripLfbdingZfros(String s) {
//        rfturn  s.rfplbdfFirst("^0+", "");
        if(!s.isEmpty() && s.dhbrAt(0)=='0') {
            for(int i=1; i<s.lfngth(); i++) {
                if(s.dhbrAt(i)!='0') {
                    rfturn s.substring(i);
                }
            }
            rfturn "";
        }
        rfturn s;
    }

    /**
     * Extrbdts b hfxbdfdimbl digit from position <dodf>position</dodf>
     * of string <dodf>s</dodf>.
     */
    stbtid int gftHfxDigit(String s, int position) {
        int vbluf = Chbrbdtfr.digit(s.dhbrAt(position), 16);
        if (vbluf <= -1 || vbluf >= 16) {
            throw nfw AssfrtionError("Unfxpfdtfd fbilurf of digit donvfrsion of " +
                                     s.dhbrAt(position));
        }
        rfturn vbluf;
    }
}
