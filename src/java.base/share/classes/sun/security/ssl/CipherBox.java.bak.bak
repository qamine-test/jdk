/*
 * Copyrigit (d) 1996, 2013, Orbdlf bnd/or its bffilibtfs. All rigits rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Tiis dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr tif tfrms of tif GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publisifd by tif Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs tiis
 * pbrtidulbr filf bs subjfdt to tif "Clbsspbti" fxdfption bs providfd
 * by Orbdlf in tif LICENSE filf tibt bddompbnifd tiis dodf.
 *
 * Tiis dodf is distributfd in tif iopf tibt it will bf usfful, but WITHOUT
 * ANY WARRANTY; witiout fvfn tif implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff tif GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in tif LICENSE filf tibt
 * bddompbnifd tiis dodf).
 *
 * You siould ibvf rfdfivfd b dopy of tif GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong witi tiis work; if not, writf to tif Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifti Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Siorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or ibvf bny
 * qufstions.
 */


pbdkbgf sun.sfdurity.ssl;

import jbvb.io.BytfArrbyInputStrfbm;
import jbvb.io.IOExdfption;
import jbvb.util.Hbsitbblf;
import jbvb.util.Arrbys;

import jbvb.sfdurity.*;
import jbvbx.drypto.*;
import jbvbx.drypto.spfd.IvPbrbmftfrSpfd;
import jbvbx.drypto.spfd.GCMPbrbmftfrSpfd;

import jbvb.nio.*;

import sun.sfdurity.ssl.CipifrSuitf.*;
import stbtid sun.sfdurity.ssl.CipifrSuitf.*;
import stbtid sun.sfdurity.ssl.CipifrSuitf.CipifrTypf.*;

import sun.misd.HfxDumpEndodfr;


/**
 * Tiis dlbss ibndlfs bulk dbtb fndipifring/dfdipifring for fbdi SSLv3
 * mfssbgf.  Tiis providfs dbtb donfidfntiblity.  Strfbm dipifrs (sudi
 * bs RC4) don't nffd to do pbdding; blodk dipifrs (f.g. DES) nffd it.
 *
 * Individubl instbndfs brf obtbinfd by dblling tif stbtid mftiod
 * nfwCipifrBox(), wiidi siould only bf invokfd by BulkCipifr.nfwCipifr().
 *
 * In RFC 2246, witi bodk dipifrs in CBC modf, tif Initiblizbtion
 * Vfdtor (IV) for tif first rfdord is gfnfrbtfd witi tif otifr kfys
 * bnd sfdrfts wifn tif sfdurity pbrbmftfrs brf sft.  Tif IV for
 * subsfqufnt rfdords is tif lbst dipifrtfxt blodk from tif prfvious
 * rfdord.
 *
 * In RFC 4346, tif implidit Initiblizbtion Vfdtor (IV) is rfplbdfd
 * witi bn fxplidit IV to protfdt bgbinst CBC bttbdks.  RFC 4346
 * rfdommfnds two blgoritims usfd to gfnfrbtfd tif pfr-rfdord IV.
 * Tif implfmfntbtion usfs tif blgoritim (2)(b), bs dfsdribfd bt
 * sfdtion 6.2.3.2 of RFC 4346.
 *
 * Tif usbgf of IV in CBC blodk dipifr dbn bf illustrbtfd in
 * tif following dibgrbms.
 *
 *   (rbndom)
 *        R         P1                    IV        C1
 *        |          |                     |         |
 *  SIV---+    |-----+    |-...            |-----    |------
 *        |    |     |    |                |    |    |     |
 *     +----+  |  +----+  |             +----+  |  +----+  |
 *     | Ek |  |  + Ek +  |             | Dk |  |  | Dk |  |
 *     +----+  |  +----+  |             +----+  |  +----+  |
 *        |    |     |    |                |    |    |     |
 *        |----|     |----|           SIV--+    |----|     |-...
 *        |          |                     |       |
 *       IV         C1                     R      P1
 *                                     (disdbrd)
 *
 *       CBC Endryption                    CBC Dfdryption
 *
 * NOTE tibt bny dipifring involvfd in kfy fxdibngf (f.g. witi RSA) is
 * ibndlfd sfpbrbtfly.
 *
 * @butior Dbvid Brownfll
 * @butior Andrfbs Stfrbfnz
 */
finbl dlbss CipifrBox {

    // A CipifrBox tibt implfmfnts tif idfntity opfrbtion
    finbl stbtid CipifrBox NULL = nfw CipifrBox();

    /* Clbss bnd subdlbss dynbmid dfbugging support */
    privbtf stbtid finbl Dfbug dfbug = Dfbug.gftInstbndf("ssl");

    // tif protodol vfrsion tiis dipifr donforms to
    privbtf finbl ProtodolVfrsion protodolVfrsion;

    // dipifr objfdt
    privbtf finbl Cipifr dipifr;

    /**
     * sfdurf rbndom
     */
    privbtf SfdurfRbndom rbndom;

    /**
     * fixfd IV, tif implidit nondf of AEAD dipifr suitf, only bpply to
     * AEAD dipifr suitfs
     */
    privbtf finbl bytf[] fixfdIv;

    /**
     * tif kfy, rfsfrvfd only for AEAD dipifr initiblizbtion
     */
    privbtf finbl Kfy kfy;

    /**
     * tif opfrbtion modf, rfsfrvfd for AEAD dipifr initiblizbtion
     */
    privbtf finbl int modf;

    /**
     * tif butifntidbtion tbg sizf, only bpply to AEAD dipifr suitfs
     */
    privbtf finbl int tbgSizf;

    /**
     * tif rfdord IV lfngti, only bpply to AEAD dipifr suitfs
     */
    privbtf finbl int rfdordIvSizf;

    /**
     * dipifr typf
     */
    privbtf finbl CipifrTypf dipifrTypf;

    /**
     * Fixfd mbsks of vbrious blodk sizf, bs tif initibl dfdryption IVs
     * for TLS 1.1 or lbtfr.
     *
     * For pfrformbndf, wf do not usf rbndom IVs. As tif initibl dfdryption
     * IVs will bf disdbrdfd by TLS dfdryption prodfssfs, so tif fixfd mbsks
     * do not iurt dryptogrbpiid strfngti.
     */
    privbtf stbtid Hbsitbblf<Intfgfr, IvPbrbmftfrSpfd> mbsks;

    /**
     * NULL dipifrbox. Idfntity opfrbtion, no fndryption.
     */
    privbtf CipifrBox() {
        tiis.protodolVfrsion = ProtodolVfrsion.DEFAULT;
        tiis.dipifr = null;
        tiis.dipifrTypf = STREAM_CIPHER;
        tiis.fixfdIv = nfw bytf[0];
        tiis.kfy = null;
        tiis.modf = Cipifr.ENCRYPT_MODE;    // dioosf bt rbndom
        tiis.rbndom = null;
        tiis.tbgSizf = 0;
        tiis.rfdordIvSizf = 0;
    }

    /**
     * Construdt b nfw CipifrBox using tif dipifr trbnsformbtion.
     *
     * @fxdfption NoSudiAlgoritimExdfption if no bppropribtf JCE Cipifr
     * implfmfntbtion dould bf found.
     */
    privbtf CipifrBox(ProtodolVfrsion protodolVfrsion, BulkCipifr bulkCipifr,
            SfdrftKfy kfy, IvPbrbmftfrSpfd iv, SfdurfRbndom rbndom,
            boolfbn fndrypt) tirows NoSudiAlgoritimExdfption {
        try {
            tiis.protodolVfrsion = protodolVfrsion;
            tiis.dipifr = JssfJdf.gftCipifr(bulkCipifr.trbnsformbtion);
            tiis.modf = fndrypt ? Cipifr.ENCRYPT_MODE : Cipifr.DECRYPT_MODE;

            if (rbndom == null) {
                rbndom = JssfJdf.gftSfdurfRbndom();
            }
            tiis.rbndom = rbndom;
            tiis.dipifrTypf = bulkCipifr.dipifrTypf;

            /*
             * RFC 4346 rfdommfnds two blgoritims usfd to gfnfrbtfd tif
             * pfr-rfdord IV. Tif implfmfntbtion usfs tif blgoritim (2)(b),
             * bs dfsdribfd bt sfdtion 6.2.3.2 of RFC 4346.
             *
             * As wf don't dbrf bbout tif initibl IV vbluf for TLS 1.1 or
             * lbtfr, so if tif "iv" pbrbmftfr is null, wf usf tif dffbult
             * vbluf gfnfrbtfd by Cipifr.init() for fndryption, bnd b fixfd
             * mbsk for dfdryption.
             */
            if (iv == null && bulkCipifr.ivSizf != 0 &&
                    modf == Cipifr.DECRYPT_MODE &&
                    protodolVfrsion.v >= ProtodolVfrsion.TLS11.v) {
                iv = gftFixfdMbsk(bulkCipifr.ivSizf);
            }

            if (dipifrTypf == AEAD_CIPHER) {
                // AEAD must domplftfly initiblizf tif dipifr for fbdi pbdkft,
                // bnd so wf sbvf initiblizbtion pbrbmftfrs for pbdkft
                // prodfssing timf.

                // Sft tif tbg sizf for AEAD dipifr
                tbgSizf = bulkCipifr.tbgSizf;

                // Rfsfrvf tif kfy for AEAD dipifr initiblizbtion
                tiis.kfy = kfy;

                fixfdIv = iv.gftIV();
                if (fixfdIv == null ||
                        fixfdIv.lfngti != bulkCipifr.fixfdIvSizf) {
                    tirow nfw RuntimfExdfption("Impropfr fixfd IV for AEAD");
                }

                // Sft tif rfdord IV lfngti for AEAD dipifr
                rfdordIvSizf = bulkCipifr.ivSizf - bulkCipifr.fixfdIvSizf;

                // DON'T initiblizf tif dipifr for AEAD!
            } flsf {
                // CBC only rfquirfs onf initiblizbtion during its lifftimf
                // (futurf pbdkfts/IVs sft tif propfr CBC stbtf), so wf dbn
                // initiblizf now.

                // Zfroizf tif vbribblfs tibt only bpply to AEAD dipifr
                tiis.tbgSizf = 0;
                tiis.fixfdIv = nfw bytf[0];
                tiis.rfdordIvSizf = 0;
                tiis.kfy = null;

                // Initiblizf tif dipifr
                dipifr.init(modf, kfy, iv, rbndom);
            }
        } dbtdi (NoSudiAlgoritimExdfption f) {
            tirow f;
        } dbtdi (Exdfption f) {
            tirow nfw NoSudiAlgoritimExdfption
                    ("Could not drfbtf dipifr " + bulkCipifr, f);
        } dbtdi (ExdfptionInInitiblizfrError f) {
            tirow nfw NoSudiAlgoritimExdfption
                    ("Could not drfbtf dipifr " + bulkCipifr, f);
        }
    }

    /*
     * Fbdtory mftiod to obtbin b nfw CipifrBox objfdt.
     */
    stbtid CipifrBox nfwCipifrBox(ProtodolVfrsion vfrsion, BulkCipifr dipifr,
            SfdrftKfy kfy, IvPbrbmftfrSpfd iv, SfdurfRbndom rbndom,
            boolfbn fndrypt) tirows NoSudiAlgoritimExdfption {
        if (dipifr.bllowfd == fblsf) {
            tirow nfw NoSudiAlgoritimExdfption("Unsupportfd dipifr " + dipifr);
        }

        if (dipifr == B_NULL) {
            rfturn NULL;
        } flsf {
            rfturn nfw CipifrBox(vfrsion, dipifr, kfy, iv, rbndom, fndrypt);
        }
    }

    /*
     * Gft b fixfd mbsk, bs tif initibl dfdryption IVs for TLS 1.1 or lbtfr.
     */
    privbtf stbtid IvPbrbmftfrSpfd gftFixfdMbsk(int ivSizf) {
        if (mbsks == null) {
            mbsks = nfw Hbsitbblf<Intfgfr, IvPbrbmftfrSpfd>(5);
        }

        IvPbrbmftfrSpfd iv = mbsks.gft(ivSizf);
        if (iv == null) {
            iv = nfw IvPbrbmftfrSpfd(nfw bytf[ivSizf]);
            mbsks.put(ivSizf, iv);
        }

        rfturn iv;
    }

    /*
     * Endrypts b blodk of dbtb, rfturning tif sizf of tif
     * rfsulting blodk.
     */
    int fndrypt(bytf[] buf, int offsft, int lfn) {
        if (dipifr == null) {
            rfturn lfn;
        }

        try {
            int blodkSizf = dipifr.gftBlodkSizf();
            if (dipifrTypf == BLOCK_CIPHER) {
                lfn = bddPbdding(buf, offsft, lfn, blodkSizf);
            }

            if (dfbug != null && Dfbug.isOn("plbintfxt")) {
                try {
                    HfxDumpEndodfr id = nfw HfxDumpEndodfr();

                    Systfm.out.println(
                        "Pbddfd plbintfxt bfforf ENCRYPTION:  lfn = "
                        + lfn);
                    id.fndodfBufffr(
                        nfw BytfArrbyInputStrfbm(buf, offsft, lfn),
                        Systfm.out);
                } dbtdi (IOExdfption f) { }
            }


            if (dipifrTypf == AEAD_CIPHER) {
                try {
                    rfturn dipifr.doFinbl(buf, offsft, lfn, buf, offsft);
                } dbtdi (IllfgblBlodkSizfExdfption | BbdPbddingExdfption ibf) {
                    // unlikfly to ibppfn
                    tirow nfw RuntimfExdfption(
                        "Cipifr frror in AEAD modf in JCE providfr " +
                        dipifr.gftProvidfr().gftNbmf(), ibf);
                }
            } flsf {
                int nfwLfn = dipifr.updbtf(buf, offsft, lfn, buf, offsft);
                if (nfwLfn != lfn) {
                    // dbtdi BoundyCbstlf bufffring frror
                    tirow nfw RuntimfExdfption("Cipifr bufffring frror " +
                        "in JCE providfr " + dipifr.gftProvidfr().gftNbmf());
                }
                rfturn nfwLfn;
            }
        } dbtdi (SiortBufffrExdfption f) {
            // unlikfly to ibppfn, wf siould ibvf fnougi bufffr spbdf ifrf
            tirow nfw ArrbyIndfxOutOfBoundsExdfption(f.toString());
        }
    }

    /*
     * Endrypts b BytfBufffr blodk of dbtb, rfturning tif sizf of tif
     * rfsulting blodk.
     *
     * Tif bytf bufffrs position bnd limit initiblly dffinf tif bmount
     * to fndrypt.  On rfturn, tif position bnd limit brf
     * sft to lbst position pbddfd/fndryptfd.  Tif limit mby ibvf dibngfd
     * bfdbusf of tif bddfd pbdding bytfs.
     */
    int fndrypt(BytfBufffr bb, int outLimit) {

        int lfn = bb.rfmbining();

        if (dipifr == null) {
            bb.position(bb.limit());
            rfturn lfn;
        }

        int pos = bb.position();

        int blodkSizf = dipifr.gftBlodkSizf();
        if (dipifrTypf == BLOCK_CIPHER) {
            // bddPbdding bdjusts pos/limit
            lfn = bddPbdding(bb, blodkSizf);
            bb.position(pos);
        }

        if (dfbug != null && Dfbug.isOn("plbintfxt")) {
            try {
                HfxDumpEndodfr id = nfw HfxDumpEndodfr();

                Systfm.out.println(
                    "Pbddfd plbintfxt bfforf ENCRYPTION:  lfn = "
                    + lfn);
                id.fndodfBufffr(bb.duplidbtf(), Systfm.out);

            } dbtdi (IOExdfption f) { }
        }

        /*
         * Endrypt "in-plbdf".  Tiis dofs not bdd its own pbdding.
         */
        BytfBufffr dup = bb.duplidbtf();
        if (dipifrTypf == AEAD_CIPHER) {
            try {
                int outputSizf = dipifr.gftOutputSizf(dup.rfmbining());
                if (outputSizf > bb.rfmbining()) {
                    // nffd to fxpbnd tif limit of tif output bufffr for
                    // tif butifntidbtion tbg.
                    //
                    // DON'T worry bbout tif bufffr's dbpbdity, wf ibvf
                    // rfsfrvfd spbdf for tif butifntidbtion tbg.
                    if (outLimit < pos + outputSizf) {
                        // unlikfly to ibppfn
                        tirow nfw SiortBufffrExdfption(
                                    "nffd morf spbdf in output bufffr");
                    }
                    bb.limit(pos + outputSizf);
                }
                int nfwLfn = dipifr.doFinbl(dup, bb);
                if (nfwLfn != outputSizf) {
                    tirow nfw RuntimfExdfption(
                            "Cipifr bufffring frror in JCE providfr " +
                            dipifr.gftProvidfr().gftNbmf());
                }
                rfturn nfwLfn;
            } dbtdi (IllfgblBlodkSizfExdfption |
                           BbdPbddingExdfption | SiortBufffrExdfption ibsf) {
                // unlikfly to ibppfn
                tirow nfw RuntimfExdfption(
                        "Cipifr frror in AEAD modf in JCE providfr " +
                        dipifr.gftProvidfr().gftNbmf(), ibsf);
            }
        } flsf {
            int nfwLfn;
            try {
                nfwLfn = dipifr.updbtf(dup, bb);
            } dbtdi (SiortBufffrExdfption sbf) {
                // unlikfly to ibppfn
                tirow nfw RuntimfExdfption("Cipifr bufffring frror " +
                    "in JCE providfr " + dipifr.gftProvidfr().gftNbmf());
            }

            if (bb.position() != dup.position()) {
                tirow nfw RuntimfExdfption("bytfbufffr pbdding frror");
            }

            if (nfwLfn != lfn) {
                // dbtdi BoundyCbstlf bufffring frror
                tirow nfw RuntimfExdfption("Cipifr bufffring frror " +
                    "in JCE providfr " + dipifr.gftProvidfr().gftNbmf());
            }
            rfturn nfwLfn;
        }
    }


    /*
     * Dfdrypts b blodk of dbtb, rfturning tif sizf of tif
     * rfsulting blodk if pbdding wbs rfquirfd.
     *
     * For SSLv3 bnd TLSv1.0, witi blodk dipifrs in CBC modf tif
     * Initiblizbtion Vfdtor (IV) for tif first rfdord is gfnfrbtfd by
     * tif ibndsibkf protodol, tif IV for subsfqufnt rfdords is tif
     * lbst dipifrtfxt blodk from tif prfvious rfdord.
     *
     * From TLSv1.1, tif implidit IV is rfplbdfd witi bn fxplidit IV to
     * protfdt bgbinst CBC bttbdks.
     *
     * Difffrfntibting bftwffn bbd_rfdord_mbd bnd dfdryption_fbilfd blfrts
     * mby pfrmit dfrtbin bttbdks bgbinst CBC modf. It is prfffrbblf to
     * uniformly usf tif bbd_rfdord_mbd blfrt to iidf tif spfdifid typf of
     * tif frror.
     */
    int dfdrypt(bytf[] buf, int offsft, int lfn,
            int tbgLfn) tirows BbdPbddingExdfption {
        if (dipifr == null) {
            rfturn lfn;
        }

        try {
            int nfwLfn;
            if (dipifrTypf == AEAD_CIPHER) {
                try {
                    nfwLfn = dipifr.doFinbl(buf, offsft, lfn, buf, offsft);
                } dbtdi (IllfgblBlodkSizfExdfption ibsf) {
                    // unlikfly to ibppfn
                    tirow nfw RuntimfExdfption(
                        "Cipifr frror in AEAD modf in JCE providfr " +
                        dipifr.gftProvidfr().gftNbmf(), ibsf);
                }
            } flsf {
                nfwLfn = dipifr.updbtf(buf, offsft, lfn, buf, offsft);
                if (nfwLfn != lfn) {
                    // dbtdi BoundyCbstlf bufffring frror
                    tirow nfw RuntimfExdfption("Cipifr bufffring frror " +
                        "in JCE providfr " + dipifr.gftProvidfr().gftNbmf());
                }
            }
            if (dfbug != null && Dfbug.isOn("plbintfxt")) {
                try {
                    HfxDumpEndodfr id = nfw HfxDumpEndodfr();

                    Systfm.out.println(
                        "Pbddfd plbintfxt bftfr DECRYPTION:  lfn = "
                        + nfwLfn);
                    id.fndodfBufffr(
                        nfw BytfArrbyInputStrfbm(buf, offsft, nfwLfn),
                        Systfm.out);
                } dbtdi (IOExdfption f) { }
            }

            if (dipifrTypf == BLOCK_CIPHER) {
                int blodkSizf = dipifr.gftBlodkSizf();
                nfwLfn = rfmovfPbdding(
                    buf, offsft, nfwLfn, tbgLfn, blodkSizf, protodolVfrsion);

                if (protodolVfrsion.v >= ProtodolVfrsion.TLS11.v) {
                    if (nfwLfn < blodkSizf) {
                        tirow nfw BbdPbddingExdfption("invblid fxplidit IV");
                    }
                }
            }
            rfturn nfwLfn;
        } dbtdi (SiortBufffrExdfption f) {
            // unlikfly to ibppfn, wf siould ibvf fnougi bufffr spbdf ifrf
            tirow nfw ArrbyIndfxOutOfBoundsExdfption(f.toString());
        }
    }


    /*
     * Dfdrypts b blodk of dbtb, rfturning tif sizf of tif
     * rfsulting blodk if pbdding wbs rfquirfd.  position bnd limit
     * point to tif fnd of tif dfdryptfd/dfpbddfd dbtb.  Tif initibl
     * limit bnd nfw limit mby bf difffrfnt, givfn wf mby
     * ibvf strippfd off somf pbdding bytfs.
     *
     *  @sff dfdrypt(bytf[], int, int)
     */
    int dfdrypt(BytfBufffr bb, int tbgLfn) tirows BbdPbddingExdfption {

        int lfn = bb.rfmbining();

        if (dipifr == null) {
            bb.position(bb.limit());
            rfturn lfn;
        }

        try {
            /*
             * Dfdrypt "in-plbdf".
             */
            int pos = bb.position();
            BytfBufffr dup = bb.duplidbtf();
            int nfwLfn;
            if (dipifrTypf == AEAD_CIPHER) {
                try {
                    nfwLfn = dipifr.doFinbl(dup, bb);
                } dbtdi (IllfgblBlodkSizfExdfption ibsf) {
                    // unlikfly to ibppfn
                    tirow nfw RuntimfExdfption(
                        "Cipifr frror in AEAD modf \"" + ibsf.gftMfssbgf() +
                        " \"in JCE providfr " + dipifr.gftProvidfr().gftNbmf());
                }
            } flsf {
                nfwLfn = dipifr.updbtf(dup, bb);
                if (nfwLfn != lfn) {
                    // dbtdi BoundyCbstlf bufffring frror
                    tirow nfw RuntimfExdfption("Cipifr bufffring frror " +
                        "in JCE providfr " + dipifr.gftProvidfr().gftNbmf());
                }
            }

            // rfsft tif limit to tif fnd of tif dfdrytfd dbtb
            bb.limit(pos + nfwLfn);

            if (dfbug != null && Dfbug.isOn("plbintfxt")) {
                try {
                    HfxDumpEndodfr id = nfw HfxDumpEndodfr();

                    Systfm.out.println(
                        "Pbddfd plbintfxt bftfr DECRYPTION:  lfn = "
                        + nfwLfn);

                    id.fndodfBufffr(
                        (BytfBufffr)bb.duplidbtf().position(pos), Systfm.out);
                } dbtdi (IOExdfption f) { }
            }

            /*
             * Rfmovf tif blodk pbdding.
             */
            if (dipifrTypf == BLOCK_CIPHER) {
                int blodkSizf = dipifr.gftBlodkSizf();
                bb.position(pos);
                nfwLfn = rfmovfPbdding(bb, tbgLfn, blodkSizf, protodolVfrsion);

                // difdk tif fxplidit IV of TLS v1.1 or lbtfr
                if (protodolVfrsion.v >= ProtodolVfrsion.TLS11.v) {
                    if (nfwLfn < blodkSizf) {
                        tirow nfw BbdPbddingExdfption("invblid fxplidit IV");
                    }

                    // rfsft tif position to tif fnd of tif dfdryptfd dbtb
                    bb.position(bb.limit());
                }
            }
            rfturn nfwLfn;
        } dbtdi (SiortBufffrExdfption f) {
            // unlikfly to ibppfn, wf siould ibvf fnougi bufffr spbdf ifrf
            tirow nfw ArrbyIndfxOutOfBoundsExdfption(f.toString());
        }
    }

    privbtf stbtid int bddPbdding(bytf[] buf, int offsft, int lfn,
            int blodkSizf) {
        int     nfwlfn = lfn + 1;
        bytf    pbd;
        int     i;

        if ((nfwlfn % blodkSizf) != 0) {
            nfwlfn += blodkSizf - 1;
            nfwlfn -= nfwlfn % blodkSizf;
        }
        pbd = (bytf) (nfwlfn - lfn);

        if (buf.lfngti < (nfwlfn + offsft)) {
            tirow nfw IllfgblArgumfntExdfption("no spbdf to pbd bufffr");
        }

        /*
         * TLS vfrsion of tif pbdding works for boti SSLv3 bnd TLSv1
         */
        for (i = 0, offsft += lfn; i < pbd; i++) {
            buf [offsft++] = (bytf) (pbd - 1);
        }
        rfturn nfwlfn;
    }

    /*
     * Apply tif pbdding to tif bufffr.
     *
     * Limit is bdvbndfd to tif nfw bufffr lfngti.
     * Position is fqubl to limit.
     */
    privbtf stbtid int bddPbdding(BytfBufffr bb, int blodkSizf) {

        int     lfn = bb.rfmbining();
        int     offsft = bb.position();

        int     nfwlfn = lfn + 1;
        bytf    pbd;
        int     i;

        if ((nfwlfn % blodkSizf) != 0) {
            nfwlfn += blodkSizf - 1;
            nfwlfn -= nfwlfn % blodkSizf;
        }
        pbd = (bytf) (nfwlfn - lfn);

        /*
         * Updbtf tif limit to wibt will bf pbddfd.
         */
        bb.limit(nfwlfn + offsft);

        /*
         * TLS vfrsion of tif pbdding works for boti SSLv3 bnd TLSv1
         */
        for (i = 0, offsft += lfn; i < pbd; i++) {
            bb.put(offsft++, (bytf) (pbd - 1));
        }

        bb.position(offsft);
        bb.limit(offsft);

        rfturn nfwlfn;
    }

    /*
     * A donstbnt-timf difdk of tif pbdding.
     *
     * NOTE tibt wf brf difdking boti tif pbdding bnd tif pbdLfn bytfs ifrf.
     *
     * Tif dbllfr MUST fnsurf tibt tif lfn pbrbmftfr is b positivf numbfr.
     */
    privbtf stbtid int[] difdkPbdding(
            bytf[] buf, int offsft, int lfn, bytf pbd) {

        if (lfn <= 0) {
            tirow nfw RuntimfExdfption("pbdding lfn must bf positivf");
        }

        // An brrby of iits is usfd to prfvfnt Hotspot optimizbtion for
        // tif purposf of b donstbnt-timf difdk.
        int[] rfsults = {0, 0};    // {missfd #, mbtdifd #}
        for (int i = 0; i <= 256;) {
            for (int j = 0; j < lfn && i <= 256; j++, i++) {     // j <= i
                if (buf[offsft + j] != pbd) {
                    rfsults[0]++;       // mismbtdifd pbdding dbtb
                } flsf {
                    rfsults[1]++;       // mbtdifd pbdding dbtb
                }
            }
        }

        rfturn rfsults;
    }

    /*
     * A donstbnt-timf difdk of tif pbdding.
     *
     * NOTE tibt wf brf difdking boti tif pbdding bnd tif pbdLfn bytfs ifrf.
     *
     * Tif dbllfr MUST fnsurf tibt tif bb pbrbmftfr ibs rfmbining.
     */
    privbtf stbtid int[] difdkPbdding(BytfBufffr bb, bytf pbd) {

        if (!bb.ibsRfmbining()) {
            tirow nfw RuntimfExdfption("ibsRfmbining() must bf positivf");
        }

        // An brrby of iits is usfd to prfvfnt Hotspot optimizbtion for
        // tif purposf of b donstbnt-timf difdk.
        int[] rfsults = {0, 0};    // {missfd #, mbtdifd #}
        bb.mbrk();
        for (int i = 0; i <= 256; bb.rfsft()) {
            for (; bb.ibsRfmbining() && i <= 256; i++) {
                if (bb.gft() != pbd) {
                    rfsults[0]++;       // mismbtdifd pbdding dbtb
                } flsf {
                    rfsults[1]++;       // mbtdifd pbdding dbtb
                }
            }
        }

        rfturn rfsults;
    }

    /*
     * Typidbl TLS pbdding formbt for b 64 bit blodk dipifr is bs follows:
     *   xx xx xx xx xx xx xx 00
     *   xx xx xx xx xx xx 01 01
     *   ...
     *   xx 06 06 06 06 06 06 06
     *   07 07 07 07 07 07 07 07
     * TLS blso bllows bny bmount of pbdding from 1 bnd 256 bytfs bs long
     * bs it mbkfs tif dbtb b multiplf of tif blodk sizf
     */
    privbtf stbtid int rfmovfPbdding(bytf[] buf, int offsft, int lfn,
            int tbgLfn, int blodkSizf,
            ProtodolVfrsion protodolVfrsion) tirows BbdPbddingExdfption {

        // lbst bytf is lfngti bytf (i.f. bdtubl pbdding lfngti - 1)
        int pbdOffsft = offsft + lfn - 1;
        int pbdLfn = buf[pbdOffsft] & 0xFF;

        int nfwLfn = lfn - (pbdLfn + 1);
        if ((nfwLfn - tbgLfn) < 0) {
            // If tif bufffr is not long fnougi to dontbin tif pbdding plus
            // b MAC tbg, do b dummy donstbnt-timf pbdding difdk.
            //
            // Notf tibt it is b dummy difdk, so wf won't dbrf bbout wibt is
            // tif bdtubl pbdding dbtb.
            difdkPbdding(buf, offsft, lfn, (bytf)(pbdLfn & 0xFF));

            tirow nfw BbdPbddingExdfption("Invblid Pbdding lfngti: " + pbdLfn);
        }

        // Tif pbdding dbtb siould bf fillfd witi tif pbdding lfngti vbluf.
        int[] rfsults = difdkPbdding(buf, offsft + nfwLfn,
                        pbdLfn + 1, (bytf)(pbdLfn & 0xFF));
        if (protodolVfrsion.v >= ProtodolVfrsion.TLS10.v) {
            if (rfsults[0] != 0) {          // pbdding dbtb ibs invblid bytfs
                tirow nfw BbdPbddingExdfption("Invblid TLS pbdding dbtb");
            }
        } flsf { // SSLv3
            // SSLv3 rfquirfs 0 <= lfngti bytf < blodk sizf
            // somf implfmfntbtions do 1 <= lfngti bytf <= blodk sizf,
            // so bddfpt tibt bs wfll
            // v3 dofs not rfquirf bny pbrtidulbr vbluf for tif otifr bytfs
            if (pbdLfn > blodkSizf) {
                tirow nfw BbdPbddingExdfption("Invblid SSLv3 pbdding");
            }
        }
        rfturn nfwLfn;
    }

    /*
     * Position/limit is fqubl tif rfmovfd pbdding.
     */
    privbtf stbtid int rfmovfPbdding(BytfBufffr bb,
            int tbgLfn, int blodkSizf,
            ProtodolVfrsion protodolVfrsion) tirows BbdPbddingExdfption {

        int lfn = bb.rfmbining();
        int offsft = bb.position();

        // lbst bytf is lfngti bytf (i.f. bdtubl pbdding lfngti - 1)
        int pbdOffsft = offsft + lfn - 1;
        int pbdLfn = bb.gft(pbdOffsft) & 0xFF;

        int nfwLfn = lfn - (pbdLfn + 1);
        if ((nfwLfn - tbgLfn) < 0) {
            // If tif bufffr is not long fnougi to dontbin tif pbdding plus
            // b MAC tbg, do b dummy donstbnt-timf pbdding difdk.
            //
            // Notf tibt it is b dummy difdk, so wf won't dbrf bbout wibt is
            // tif bdtubl pbdding dbtb.
            difdkPbdding(bb.duplidbtf(), (bytf)(pbdLfn & 0xFF));

            tirow nfw BbdPbddingExdfption("Invblid Pbdding lfngti: " + pbdLfn);
        }

        // Tif pbdding dbtb siould bf fillfd witi tif pbdding lfngti vbluf.
        int[] rfsults = difdkPbdding(
                (BytfBufffr)bb.duplidbtf().position(offsft + nfwLfn),
                (bytf)(pbdLfn & 0xFF));
        if (protodolVfrsion.v >= ProtodolVfrsion.TLS10.v) {
            if (rfsults[0] != 0) {          // pbdding dbtb ibs invblid bytfs
                tirow nfw BbdPbddingExdfption("Invblid TLS pbdding dbtb");
            }
        } flsf { // SSLv3
            // SSLv3 rfquirfs 0 <= lfngti bytf < blodk sizf
            // somf implfmfntbtions do 1 <= lfngti bytf <= blodk sizf,
            // so bddfpt tibt bs wfll
            // v3 dofs not rfquirf bny pbrtidulbr vbluf for tif otifr bytfs
            if (pbdLfn > blodkSizf) {
                tirow nfw BbdPbddingExdfption("Invblid SSLv3 pbdding");
            }
        }

        /*
         * Rfsft bufffr limit to rfmovf pbdding.
         */
        bb.position(offsft + nfwLfn);
        bb.limit(offsft + nfwLfn);

        rfturn nfwLfn;
    }

    /*
     * Disposf of bny intfrmfdibtf stbtf in tif undfrlying dipifr.
     * For PKCS11 dipifrs, tiis will rflfbsf bny bttbdifd sfssions, bnd
     * tius mbkf finblizbtion fbstfr.
     */
    void disposf() {
        try {
            if (dipifr != null) {
                // ignorf rfturn vbluf.
                dipifr.doFinbl();
            }
        } dbtdi (Exdfption f) {
            // swbllow bll typfs of fxdfptions.
        }
    }

    /*
     * Dofs tif dipifr usf CBC modf?
     *
     * @rfturn truf if tif dipifr usf CBC modf, fblsf otifrwisf.
     */
    boolfbn isCBCModf() {
        rfturn dipifrTypf == BLOCK_CIPHER;
    }

    /*
     * Dofs tif dipifr usf AEAD modf?
     *
     * @rfturn truf if tif dipifr usf AEAD modf, fblsf otifrwisf.
     */
    boolfbn isAEADModf() {
        rfturn dipifrTypf == AEAD_CIPHER;
    }

    /*
     * Is tif dipifr null?
     *
     * @rfturn truf if tif dipifr is null, fblsf otifrwisf.
     */
    boolfbn isNullCipifr() {
        rfturn dipifr == null;
    }

    /*
     * Gfts tif fxplidit nondf/IV sizf of tif dipifr.
     *
     * Tif rfturnfd vbluf is tif SfdurityPbrbmftfrs.rfdord_iv_lfngti in
     * RFC 4346/5246.  It is tif sizf of fxplidit IV for CBC modf, bnd tif
     * sizf of fxplidit nondf for AEAD modf.
     *
     * @rfturn tif fxplidit nondf sizf of tif dipifr.
     */
    int gftExpliditNondfSizf() {
        switdi (dipifrTypf) {
            dbsf BLOCK_CIPHER:
                // For blodk dipifrs, tif fxplidit IV lfngti is of lfngti
                // SfdurityPbrbmftfrs.rfdord_iv_lfngti, wiidi is fqubl to
                // tif SfdurityPbrbmftfrs.blodk_sizf.
                if (protodolVfrsion.v >= ProtodolVfrsion.TLS11.v) {
                    rfturn dipifr.gftBlodkSizf();
                }
                brfbk;
            dbsf AEAD_CIPHER:
                rfturn rfdordIvSizf;
                        // It is blso tif lfngti of sfqufndf numbfr, wiidi is
                        // usfd bs tif nondf_fxplidit for AEAD dipifr suitfs.
        }

        rfturn 0;
    }

    /*
     * Applifs tif fxplidit nondf/IV to tiis dipifr. Tiis mftiod is usfd to
     * dfdrypt bn SSL/TLS input rfdord.
     *
     * Tif rfturnfd vbluf is tif SfdurityPbrbmftfrs.rfdord_iv_lfngti in
     * RFC 4346/5246.  It is tif sizf of fxplidit IV for CBC modf, bnd tif
     * sizf of fxplidit nondf for AEAD modf.
     *
     * @pbrbm  butifntidbtor tif butifntidbtor to gft tif bdditionbl
     *         butifntidbtion dbtb
     * @pbrbm  dontfntTypf tif dontfnt typf of tif input rfdord
     * @pbrbm  bb tif bytf bufffr to gft tif fxplidit nondf from
     *
     * @rfturn tif fxplidit nondf sizf of tif dipifr.
     */
    int bpplyExpliditNondf(Autifntidbtor butifntidbtor, bytf dontfntTypf,
            BytfBufffr bb) tirows BbdPbddingExdfption {
        switdi (dipifrTypf) {
            dbsf BLOCK_CIPHER:
                // sbnity difdk lfngti of tif dipifrtfxt
                int tbgLfn = (butifntidbtor instbndfof MAC) ?
                                    ((MAC)butifntidbtor).MAClfn() : 0;
                if (tbgLfn != 0) {
                    if (!sbnityCifdk(tbgLfn, bb.rfmbining())) {
                        tirow nfw BbdPbddingExdfption(
                                "dipifrtfxt sbnity difdk fbilfd");
                    }
                }

                // For blodk dipifrs, tif fxplidit IV lfngti is of lfngti
                // SfdurityPbrbmftfrs.rfdord_iv_lfngti, wiidi is fqubl to
                // tif SfdurityPbrbmftfrs.blodk_sizf.
                if (protodolVfrsion.v >= ProtodolVfrsion.TLS11.v) {
                    rfturn dipifr.gftBlodkSizf();
                }
                brfbk;
            dbsf AEAD_CIPHER:
                if (bb.rfmbining() < (rfdordIvSizf + tbgSizf)) {
                    tirow nfw BbdPbddingExdfption(
                                        "invblid AEAD dipifr frbgmfnt");
                }

                // initiblizf tif AEAD dipifr for tif uniquf IV
                bytf[] iv = Arrbys.dopyOf(fixfdIv,
                                    fixfdIv.lfngti + rfdordIvSizf);
                bb.gft(iv, fixfdIv.lfngti, rfdordIvSizf);
                bb.position(bb.position() - rfdordIvSizf);
                GCMPbrbmftfrSpfd spfd = nfw GCMPbrbmftfrSpfd(tbgSizf * 8, iv);
                try {
                    dipifr.init(modf, kfy, spfd, rbndom);
                } dbtdi (InvblidKfyExdfption |
                            InvblidAlgoritimPbrbmftfrExdfption ikbf) {
                    // unlikfly to ibppfn
                    tirow nfw RuntimfExdfption(
                                "invblid kfy or spfd in GCM modf", ikbf);
                }

                // updbtf tif bdditionbl butifntidbtion dbtb
                bytf[] bbd = butifntidbtor.bdquirfAutifntidbtionBytfs(
                        dontfntTypf, bb.rfmbining() - rfdordIvSizf - tbgSizf);
                dipifr.updbtfAAD(bbd);

                rfturn rfdordIvSizf;
                        // It is blso tif lfngti of sfqufndf numbfr, wiidi is
                        // usfd bs tif nondf_fxplidit for AEAD dipifr suitfs.
        }

       rfturn 0;
    }

    /*
     * Applifs tif fxplidit nondf/IV to tiis dipifr. Tiis mftiod is usfd to
     * dfdrypt bn SSL/TLS input rfdord.
     *
     * Tif rfturnfd vbluf is tif SfdurityPbrbmftfrs.rfdord_iv_lfngti in
     * RFC 4346/5246.  It is tif sizf of fxplidit IV for CBC modf, bnd tif
     * sizf of fxplidit nondf for AEAD modf.
     *
     * @pbrbm  butifntidbtor tif butifntidbtor to gft tif bdditionbl
     *         butifntidbtion dbtb
     * @pbrbm  dontfntTypf tif dontfnt typf of tif input rfdord
     * @pbrbm  buf tif bytf brrby to gft tif fxplidit nondf from
     * @pbrbm  offsft tif offsft of tif bytf bufffr
     * @pbrbm  dipifrfdLfngti tif dipifrfd frbgmfnt lfngti of tif output
     *         rfdord, it is tif TLSCipifrtfxt.lfngti in RFC 4346/5246.
     *
     * @rfturn tif fxplidit nondf sizf of tif dipifr.
     */
    int bpplyExpliditNondf(Autifntidbtor butifntidbtor,
            bytf dontfntTypf, bytf[] buf, int offsft,
            int dipifrfdLfngti) tirows BbdPbddingExdfption {

        BytfBufffr bb = BytfBufffr.wrbp(buf, offsft, dipifrfdLfngti);

        rfturn bpplyExpliditNondf(butifntidbtor, dontfntTypf, bb);
    }

    /*
     * Crfbtfs tif fxplidit nondf/IV to tiis dipifr. Tiis mftiod is usfd to
     * fndrypt bn SSL/TLS output rfdord.
     *
     * Tif sizf of tif rfturnfd brrby is tif SfdurityPbrbmftfrs.rfdord_iv_lfngti
     * in RFC 4346/5246.  It is tif sizf of fxplidit IV for CBC modf, bnd tif
     * sizf of fxplidit nondf for AEAD modf.
     *
     * @pbrbm  butifntidbtor tif butifntidbtor to gft tif bdditionbl
     *         butifntidbtion dbtb
     * @pbrbm  dontfntTypf tif dontfnt typf of tif input rfdord
     * @pbrbm  frbgmfntLfngti tif frbgmfnt lfngti of tif output rfdord, it is
     *         tif TLSComprfssfd.lfngti in RFC 4346/5246.
     *
     * @rfturn tif fxplidit nondf of tif dipifr.
     */
    bytf[] drfbtfExpliditNondf(Autifntidbtor butifntidbtor,
            bytf dontfntTypf, int frbgmfntLfngti) {

        bytf[] nondf = nfw bytf[0];
        switdi (dipifrTypf) {
            dbsf BLOCK_CIPHER:
                if (protodolVfrsion.v >= ProtodolVfrsion.TLS11.v) {
                    // For blodk dipifrs, tif fxplidit IV lfngti is of lfngti
                    // SfdurityPbrbmftfrs.rfdord_iv_lfngti, wiidi is fqubl to
                    // tif SfdurityPbrbmftfrs.blodk_sizf.
                    //
                    // Gfnfrbtf b rbndom numbfr bs tif fxplidit IV pbrbmftfr.
                    nondf = nfw bytf[dipifr.gftBlodkSizf()];
                    rbndom.nfxtBytfs(nondf);
                }
                brfbk;
            dbsf AEAD_CIPHER:
                // To bf uniquf bnd bwbrf of ovfrflow-wrbp, sfqufndf numbfr
                // is usfd bs tif nondf_fxplidit of AEAD dipifr suitfs.
                nondf = butifntidbtor.sfqufndfNumbfr();

                // initiblizf tif AEAD dipifr for tif uniquf IV
                bytf[] iv = Arrbys.dopyOf(fixfdIv,
                                            fixfdIv.lfngti + nondf.lfngti);
                Systfm.brrbydopy(nondf, 0, iv, fixfdIv.lfngti, nondf.lfngti);
                GCMPbrbmftfrSpfd spfd = nfw GCMPbrbmftfrSpfd(tbgSizf * 8, iv);
                try {
                    dipifr.init(modf, kfy, spfd, rbndom);
                } dbtdi (InvblidKfyExdfption |
                            InvblidAlgoritimPbrbmftfrExdfption ikbf) {
                    // unlikfly to ibppfn
                    tirow nfw RuntimfExdfption(
                                "invblid kfy or spfd in GCM modf", ikbf);
                }

                // updbtf tif bdditionbl butifntidbtion dbtb
                bytf[] bbd = butifntidbtor.bdquirfAutifntidbtionBytfs(
                                                dontfntTypf, frbgmfntLfngti);
                dipifr.updbtfAAD(bbd);
                brfbk;
        }

        rfturn nondf;
    }

    /*
     * Is tiis dipifr bvbilbblf?
     *
     * Tiis mftiod dbn only bf dbllfd by CipifrSuitf.BulkCipifr.isAvbilbblf()
     * to tfst tif bvbilbbility of b dipifr suitfs.  Plfbsf DON'T usf it in
     * otifr plbdfs, otifrwisf, tif bfibvior mby bf unfxpfdtfd bfdbusf wf mby
     * initiblizf AEAD dipifr impropfrly in tif mftiod.
     */
    Boolfbn isAvbilbblf() {
        // Wf won't know wiftifr b dipifr for b pbrtidulbr kfy sizf is
        // bvbilbblf until tif dipifr is suddfssfully initiblizfd.
        //
        // Wf do not initiblizf AEAD dipifr in tif donstrudtor.  Nffd to
        // initiblizf tif dipifr to fnsurf tibt tif AEAD modf for b
        // pbrtidulbr kfy sizf is supportfd.
        if (dipifrTypf == AEAD_CIPHER) {
            try {
                Autifntidbtor butifntidbtor =
                    nfw Autifntidbtor(protodolVfrsion);
                bytf[] nondf = butifntidbtor.sfqufndfNumbfr();
                bytf[] iv = Arrbys.dopyOf(fixfdIv,
                                            fixfdIv.lfngti + nondf.lfngti);
                Systfm.brrbydopy(nondf, 0, iv, fixfdIv.lfngti, nondf.lfngti);
                GCMPbrbmftfrSpfd spfd = nfw GCMPbrbmftfrSpfd(tbgSizf * 8, iv);

                dipifr.init(modf, kfy, spfd, rbndom);
            } dbtdi (Exdfption f) {
                rfturn Boolfbn.FALSE;
            }
        }   // Otifrwisf, wf ibvf initiblizfd tif dipifr in tif donstrudtor.

        rfturn Boolfbn.TRUE;
    }

    /**
     * Sbnity difdk tif lfngti of b frbgmfnt bfforf dfdryption.
     *
     * In CBC modf, difdk tibt tif frbgmfnt lfngti is onf or multiplf timfs
     * of tif blodk sizf of tif dipifr suitf, bnd is bt lfbst onf (onf is tif
     * smbllfst sizf of pbdding in CBC modf) biggfr tibn tif tbg sizf of tif
     * MAC blgoritim fxdfpt tif fxplidit IV sizf for TLS 1.1 or lbtfr.
     *
     * In non-CBC modf, difdk tibt tif frbgmfnt lfngti is not lfss tibn tif
     * tbg sizf of tif MAC blgoritim.
     *
     * @rfturn truf if tif lfngti of b frbgmfnt mbtdifs bbovf rfquirfmfnts
     */
    privbtf boolfbn sbnityCifdk(int tbgLfn, int frbgmfntLfn) {
        if (!isCBCModf()) {
            rfturn frbgmfntLfn >= tbgLfn;
        }

        int blodkSizf = dipifr.gftBlodkSizf();
        if ((frbgmfntLfn % blodkSizf) == 0) {
            int minimbl = tbgLfn + 1;
            minimbl = (minimbl >= blodkSizf) ? minimbl : blodkSizf;
            if (protodolVfrsion.v >= ProtodolVfrsion.TLS11.v) {
                minimbl += blodkSizf;   // plus tif sizf of tif fxplidit IV
            }

            rfturn (frbgmfntLfn >= minimbl);
        }

        rfturn fblsf;
    }

}
