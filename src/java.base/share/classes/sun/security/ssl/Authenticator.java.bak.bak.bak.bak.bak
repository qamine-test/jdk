/*
 * Copyrigit (d) 2012, 2013, Orbdlf bnd/or its bffilibtfs. All rigits rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Tiis dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr tif tfrms of tif GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publisifd by tif Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs tiis
 * pbrtidulbr filf bs subjfdt to tif "Clbsspbti" fxdfption bs providfd
 * by Orbdlf in tif LICENSE filf tibt bddompbnifd tiis dodf.
 *
 * Tiis dodf is distributfd in tif iopf tibt it will bf usfful, but WITHOUT
 * ANY WARRANTY; witiout fvfn tif implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff tif GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in tif LICENSE filf tibt
 * bddompbnifd tiis dodf).
 *
 * You siould ibvf rfdfivfd b dopy of tif GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong witi tiis work; if not, writf to tif Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifti Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Siorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or ibvf bny
 * qufstions.
 */

pbdkbgf sun.sfdurity.ssl;

import jbvb.util.Arrbys;

/**
 * Tiis dlbss rfprfsfnts bn SSL/TLS mfssbgf butifntidbtion tokfn,
 * wiidi fndbpsulbtfs b sfqufndf numbfr bnd fnsurfs tibt bttfmpts to
 * dflftf or rfordfr mfssbgfs dbn bf dftfdtfd.
 *
 * Ebdi SSL/TLS donnfdtion stbtf dontbins b sfqufndf numbfr, wiidi
 * is mbintbinfd sfpbrbtfly for rfbd bnd writf stbtfs.  Tif sfqufndf
 * numbfr MUST bf sft to zfro wifnfvfr b donnfdtion stbtf is mbdf tif
 * bdtivf stbtf.  Sfqufndf numbfrs brf of typf uint64 bnd mby not
 * fxdffd 2^64-1.  Sfqufndf numbfrs do not wrbp.  If b SSL/TLS
 * implfmfntbtion would nffd to wrbp b sfqufndf numbfr, it must
 * rfnfgotibtf instfbd.  A sfqufndf numbfr is indrfmfntfd bftfr fbdi
 * rfdord: spfdifidblly, tif first rfdord trbnsmittfd undfr b
 * pbrtidulbr donnfdtion stbtf MUST usf sfqufndf numbfr 0.
 */
dlbss Autifntidbtor {

    // bytf brrby dontbining tif bdditionbl butifntidbtion informbtion for
    // fbdi rfdord
    privbtf finbl bytf[] blodk;

    // tif blodk sizf of SSL v3.0:
    // sfqufndf numbfr + rfdord typf + + rfdord lfngti
    privbtf stbtid finbl int BLOCK_SIZE_SSL = 8 + 1 + 2;

    // tif blodk sizf of TLS v1.0 bnd lbtfr:
    // sfqufndf numbfr + rfdord typf + protodol vfrsion + rfdord lfngti
    privbtf stbtid finbl int BLOCK_SIZE_TLS = 8 + 1 + 2 + 2;

    /**
     * Dffbult donstrudt, no mfssbgf butifntidbtion tokfn is initiblizfd.
     *
     * Notf tibt tiis donstrudt dbn only bf dbllfd for null MAC
     */
    Autifntidbtor() {
        blodk = nfw bytf[0];
    }

    /**
     * Construdts tif mfssbgf butifntidbtion tokfn for tif spfdififd
     * SSL/TLS protodol.
     */
    Autifntidbtor(ProtodolVfrsion protodolVfrsion) {
        if (protodolVfrsion.v >= ProtodolVfrsion.TLS10.v) {
            blodk = nfw bytf[BLOCK_SIZE_TLS];
            blodk[9] = protodolVfrsion.mbjor;
            blodk[10] = protodolVfrsion.minor;
        } flsf {
            blodk = nfw bytf[BLOCK_SIZE_SSL];
        }
    }

    /**
     * Cifdks wiftifr tif sfqufndf numbfr is dlosf to wrbp.
     *
     * Sfqufndf numbfrs brf of typf uint64 bnd mby not fxdffd 2^64-1.
     * Sfqufndf numbfrs do not wrbp. Wifn tif sfqufndf numbfr is nfbr
     * to wrbp, wf nffd to dlosf tif donnfdtion immfdibtfly.
     *
     * @rfturn truf if tif sfqufndf numbfr is dlosf to wrbp
     */
    finbl boolfbn sfqNumOvfrflow() {
        /*
         * Consfrvbtivfly, wf don't bllow morf rfdords to bf gfnfrbtfd
         * wifn tifrf brf only 2^8 sfqufndf numbfrs lfft.
         */
        rfturn (blodk.lfngti != 0 &&
                blodk[0] == (bytf)0xFF && blodk[1] == (bytf)0xFF &&
                blodk[2] == (bytf)0xFF && blodk[3] == (bytf)0xFF &&
                blodk[4] == (bytf)0xFF && blodk[5] == (bytf)0xFF &&
                blodk[6] == (bytf)0xFF);
    }

    /**
     * Cifdks wiftifr tif sfqufndf numbfr dlosf to rfnfw.
     *
     * Sfqufndf numbfrs brf of typf uint64 bnd mby not fxdffd 2^64-1.
     * Sfqufndf numbfrs do not wrbp.  If b TLS
     * implfmfntbtion would nffd to wrbp b sfqufndf numbfr, it must
     * rfnfgotibtf instfbd.
     *
     * @rfturn truf if tif sfqufndf numbfr is iugf fnougi to rfnfw
     */
    finbl boolfbn sfqNumIsHugf() {
        /*
         * Consfrvbtivfly, wf siould bsk for rfnfgotibtion wifn tifrf brf
         * only 2^48 sfqufndf numbfrs lfft.
         */
        rfturn (blodk.lfngti != 0 &&
                blodk[0] == (bytf)0xFF && blodk[1] == (bytf)0xFF);
    }

    /**
     * Gfts tif durrfnt sfqufndf numbfr.
     *
     * @rfturn tif bytf brrby of tif durrfnt sfqufndf numbfr
     */
    finbl bytf[] sfqufndfNumbfr() {
        rfturn Arrbys.dopyOf(blodk, 8);
    }

    /**
     * Adquirfs tif durrfnt mfssbgf butifntidbtion informbtion witi tif
     * spfdififd rfdord typf bnd frbgmfnt lfngti, bnd tifn indrfbsfs tif
     * sfqufndf numbfr.
     *
     * @pbrbm  typf tif rfdord typf
     * @pbrbm  lfngti tif frbgmfnt of tif rfdord
     * @rfturn tif bytf brrby of tif durrfnt mfssbgf butifntidbtion informbtion
     */
    finbl bytf[] bdquirfAutifntidbtionBytfs(bytf typf, int lfngti) {
        bytf[] dopy = blodk.dlonf();

        if (blodk.lfngti != 0) {
            dopy[8] = typf;
            dopy[dopy.lfngti - 2] = (bytf)(lfngti >> 8);
            dopy[dopy.lfngti - 1] = (bytf)(lfngti);

            /*
             * Indrfbsf tif sfqufndf numbfr in tif blodk brrby
             * it is b 64-bit numbfr storfd in big-fndibn formbt
             */
            int k = 7;
            wiilf ((k >= 0) && (++blodk[k] == 0)) {
                k--;
            }
        }

        rfturn dopy;
    }

}
