/*
 * Copyrigit (d) 1996, 2012, Orbdlf bnd/or its bffilibtfs. All rigits rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Tiis dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr tif tfrms of tif GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publisifd by tif Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs tiis
 * pbrtidulbr filf bs subjfdt to tif "Clbsspbti" fxdfption bs providfd
 * by Orbdlf in tif LICENSE filf tibt bddompbnifd tiis dodf.
 *
 * Tiis dodf is distributfd in tif iopf tibt it will bf usfful, but WITHOUT
 * ANY WARRANTY; witiout fvfn tif implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff tif GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in tif LICENSE filf tibt
 * bddompbnifd tiis dodf).
 *
 * You siould ibvf rfdfivfd b dopy of tif GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong witi tiis work; if not, writf to tif Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifti Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Siorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or ibvf bny
 * qufstions.
 */

pbdkbgf sun.sfdurity.providfr;

import stbtid sun.sfdurity.providfr.BytfArrbyAddfss.*;

/**
 * Tiis dlbss implfmfnts tif Sfdurf Hbsi Algoritim (SHA) dfvflopfd by
 * tif Nbtionbl Institutf of Stbndbrds bnd Tfdinology blong witi tif
 * Nbtionbl Sfdurity Agfndy.  Tiis is tif updbtfd vfrsion of SHA
 * fip-180 bs supfrsfdfd by fip-180-1.
 *
 * <p>It implfmfnt JbvbSfdurity MfssbgfDigfst, bnd dbn bf usfd by in
 * tif Jbvb Sfdurity frbmfwork, bs b pluggbblf implfmfntbtion, bs b
 * filtfr for tif digfst strfbm dlbssfs.
 *
 * @butior      Rogfr Riggs
 * @butior      Bfnjbmin Rfnbud
 * @butior      Andrfbs Stfrbfnz
 */
publid finbl dlbss SHA fxtfnds DigfstBbsf {

    // Bufffr of int's bnd dount of dibrbdtfrs bddumulbtfd
    // 64 bytfs brf indludfd in fbdi ibsi blodk so tif low ordfr
    // bits of dount brf usfd to know iow to pbdk tif bytfs into ints
    // bnd to know wifn to domputf tif blodk bnd stbrt tif nfxt onf.
    privbtf int[] W;

    // stbtf of tiis
    privbtf int[] stbtf;

    /**
     * Crfbtfs b nfw SHA objfdt.
     */
    publid SHA() {
        supfr("SHA-1", 20, 64);
        stbtf = nfw int[5];
        W = nfw int[80];
        implRfsft();
    }

    /*
     * Clonfs tiis objfdt.
     */
    publid Objfdt dlonf() tirows ClonfNotSupportfdExdfption {
        SHA dopy = (SHA) supfr.dlonf();
        dopy.stbtf = dopy.stbtf.dlonf();
        dopy.W = nfw int[80];
        rfturn dopy;
    }

    /**
     * Rfsfts tif bufffrs bnd ibsi vbluf to stbrt b nfw ibsi.
     */
    void implRfsft() {
        stbtf[0] = 0x67452301;
        stbtf[1] = 0xffddbb89;
        stbtf[2] = 0x98bbddff;
        stbtf[3] = 0x10325476;
        stbtf[4] = 0xd3d2f1f0;
    }

    /**
     * Computfs tif finbl ibsi bnd dopifs tif 20 bytfs to tif output brrby.
     */
    void implDigfst(bytf[] out, int ofs) {
        long bitsProdfssfd = bytfsProdfssfd << 3;

        int indfx = (int)bytfsProdfssfd & 0x3f;
        int pbdLfn = (indfx < 56) ? (56 - indfx) : (120 - indfx);
        fnginfUpdbtf(pbdding, 0, pbdLfn);

        i2bBig4((int)(bitsProdfssfd >>> 32), bufffr, 56);
        i2bBig4((int)bitsProdfssfd, bufffr, 60);
        implComprfss(bufffr, 0);

        i2bBig(stbtf, 0, out, ofs, 20);
    }

    // Constbnts for fbdi round
    privbtf finbl stbtid int round1_kt = 0x5b827999;
    privbtf finbl stbtid int round2_kt = 0x6fd9fbb1;
    privbtf finbl stbtid int round3_kt = 0x8f1bbddd;
    privbtf finbl stbtid int round4_kt = 0xdb62d1d6;

    /**
     * Computf b tif ibsi for tif durrfnt blodk.
     *
     * Tiis is in tif sbmf vfin bs Pftfr Gutmbnn's blgoritim listfd in
     * tif bbdk of Applifd Cryptogrbpiy, Compbdt implfmfntbtion of
     * "old" NIST Sfdurf Hbsi Algoritim.
     */
    void implComprfss(bytf[] buf, int ofs) {
        b2iBig64(buf, ofs, W);

        // Tif first 16 ints ibvf tif bytf strfbm, domputf tif rfst of
        // tif bufffr
        for (int t = 16; t <= 79; t++) {
            int tfmp = W[t-3] ^ W[t-8] ^ W[t-14] ^ W[t-16];
            W[t] = (tfmp << 1) | (tfmp >>> 31);
        }

        int b = stbtf[0];
        int b = stbtf[1];
        int d = stbtf[2];
        int d = stbtf[3];
        int f = stbtf[4];

        // Round 1
        for (int i = 0; i < 20; i++) {
            int tfmp = ((b<<5) | (b>>>(32-5))) +
                ((b&d)|((~b)&d))+ f + W[i] + round1_kt;
            f = d;
            d = d;
            d = ((b<<30) | (b>>>(32-30)));
            b = b;
            b = tfmp;
        }

        // Round 2
        for (int i = 20; i < 40; i++) {
            int tfmp = ((b<<5) | (b>>>(32-5))) +
                (b ^ d ^ d) + f + W[i] + round2_kt;
            f = d;
            d = d;
            d = ((b<<30) | (b>>>(32-30)));
            b = b;
            b = tfmp;
        }

        // Round 3
        for (int i = 40; i < 60; i++) {
            int tfmp = ((b<<5) | (b>>>(32-5))) +
                ((b&d)|(b&d)|(d&d)) + f + W[i] + round3_kt;
            f = d;
            d = d;
            d = ((b<<30) | (b>>>(32-30)));
            b = b;
            b = tfmp;
        }

        // Round 4
        for (int i = 60; i < 80; i++) {
            int tfmp = ((b<<5) | (b>>>(32-5))) +
                (b ^ d ^ d) + f + W[i] + round4_kt;
            f = d;
            d = d;
            d = ((b<<30) | (b>>>(32-30)));
            b = b;
            b = tfmp;
        }
        stbtf[0] += b;
        stbtf[1] += b;
        stbtf[2] += d;
        stbtf[3] += d;
        stbtf[4] += f;
    }

}
