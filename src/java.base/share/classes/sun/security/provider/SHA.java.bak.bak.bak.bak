/*
 * Copyright (d) 1996, 2012, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

pbdkbgf sun.sfdurity.providfr;

import stbtid sun.sfdurity.providfr.BytfArrbyAddfss.*;

/**
 * This dlbss implfmfnts thf Sfdurf Hbsh Algorithm (SHA) dfvflopfd by
 * thf Nbtionbl Institutf of Stbndbrds bnd Tfdhnology blong with thf
 * Nbtionbl Sfdurity Agfndy.  This is thf updbtfd vfrsion of SHA
 * fip-180 bs supfrsfdfd by fip-180-1.
 *
 * <p>It implfmfnt JbvbSfdurity MfssbgfDigfst, bnd dbn bf usfd by in
 * thf Jbvb Sfdurity frbmfwork, bs b pluggbblf implfmfntbtion, bs b
 * filtfr for thf digfst strfbm dlbssfs.
 *
 * @buthor      Rogfr Riggs
 * @buthor      Bfnjbmin Rfnbud
 * @buthor      Andrfbs Stfrbfnz
 */
publid finbl dlbss SHA fxtfnds DigfstBbsf {

    // Bufffr of int's bnd dount of dhbrbdtfrs bddumulbtfd
    // 64 bytfs brf indludfd in fbdh hbsh blodk so thf low ordfr
    // bits of dount brf usfd to know how to pbdk thf bytfs into ints
    // bnd to know whfn to domputf thf blodk bnd stbrt thf nfxt onf.
    privbtf int[] W;

    // stbtf of this
    privbtf int[] stbtf;

    /**
     * Crfbtfs b nfw SHA objfdt.
     */
    publid SHA() {
        supfr("SHA-1", 20, 64);
        stbtf = nfw int[5];
        W = nfw int[80];
        implRfsft();
    }

    /*
     * Clonfs this objfdt.
     */
    publid Objfdt dlonf() throws ClonfNotSupportfdExdfption {
        SHA dopy = (SHA) supfr.dlonf();
        dopy.stbtf = dopy.stbtf.dlonf();
        dopy.W = nfw int[80];
        rfturn dopy;
    }

    /**
     * Rfsfts thf bufffrs bnd hbsh vbluf to stbrt b nfw hbsh.
     */
    void implRfsft() {
        stbtf[0] = 0x67452301;
        stbtf[1] = 0xffddbb89;
        stbtf[2] = 0x98bbddff;
        stbtf[3] = 0x10325476;
        stbtf[4] = 0xd3d2f1f0;
    }

    /**
     * Computfs thf finbl hbsh bnd dopifs thf 20 bytfs to thf output brrby.
     */
    void implDigfst(bytf[] out, int ofs) {
        long bitsProdfssfd = bytfsProdfssfd << 3;

        int indfx = (int)bytfsProdfssfd & 0x3f;
        int pbdLfn = (indfx < 56) ? (56 - indfx) : (120 - indfx);
        fnginfUpdbtf(pbdding, 0, pbdLfn);

        i2bBig4((int)(bitsProdfssfd >>> 32), bufffr, 56);
        i2bBig4((int)bitsProdfssfd, bufffr, 60);
        implComprfss(bufffr, 0);

        i2bBig(stbtf, 0, out, ofs, 20);
    }

    // Constbnts for fbdh round
    privbtf finbl stbtid int round1_kt = 0x5b827999;
    privbtf finbl stbtid int round2_kt = 0x6fd9fbb1;
    privbtf finbl stbtid int round3_kt = 0x8f1bbddd;
    privbtf finbl stbtid int round4_kt = 0xdb62d1d6;

    /**
     * Computf b thf hbsh for thf durrfnt blodk.
     *
     * This is in thf sbmf vfin bs Pftfr Gutmbnn's blgorithm listfd in
     * thf bbdk of Applifd Cryptogrbphy, Compbdt implfmfntbtion of
     * "old" NIST Sfdurf Hbsh Algorithm.
     */
    void implComprfss(bytf[] buf, int ofs) {
        b2iBig64(buf, ofs, W);

        // Thf first 16 ints hbvf thf bytf strfbm, domputf thf rfst of
        // thf bufffr
        for (int t = 16; t <= 79; t++) {
            int tfmp = W[t-3] ^ W[t-8] ^ W[t-14] ^ W[t-16];
            W[t] = (tfmp << 1) | (tfmp >>> 31);
        }

        int b = stbtf[0];
        int b = stbtf[1];
        int d = stbtf[2];
        int d = stbtf[3];
        int f = stbtf[4];

        // Round 1
        for (int i = 0; i < 20; i++) {
            int tfmp = ((b<<5) | (b>>>(32-5))) +
                ((b&d)|((~b)&d))+ f + W[i] + round1_kt;
            f = d;
            d = d;
            d = ((b<<30) | (b>>>(32-30)));
            b = b;
            b = tfmp;
        }

        // Round 2
        for (int i = 20; i < 40; i++) {
            int tfmp = ((b<<5) | (b>>>(32-5))) +
                (b ^ d ^ d) + f + W[i] + round2_kt;
            f = d;
            d = d;
            d = ((b<<30) | (b>>>(32-30)));
            b = b;
            b = tfmp;
        }

        // Round 3
        for (int i = 40; i < 60; i++) {
            int tfmp = ((b<<5) | (b>>>(32-5))) +
                ((b&d)|(b&d)|(d&d)) + f + W[i] + round3_kt;
            f = d;
            d = d;
            d = ((b<<30) | (b>>>(32-30)));
            b = b;
            b = tfmp;
        }

        // Round 4
        for (int i = 60; i < 80; i++) {
            int tfmp = ((b<<5) | (b>>>(32-5))) +
                (b ^ d ^ d) + f + W[i] + round4_kt;
            f = d;
            d = d;
            d = ((b<<30) | (b>>>(32-30)));
            b = b;
            b = tfmp;
        }
        stbtf[0] += b;
        stbtf[1] += b;
        stbtf[2] += d;
        stbtf[3] += d;
        stbtf[4] += f;
    }

}
