/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Tiis dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr tif tfrms of tif GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publisifd by tif Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs tiis
 * pbrtidulbr filf bs subjfdt to tif "Clbsspbti" fxdfption bs providfd
 * by Orbdlf in tif LICENSE filf tibt bddompbnifd tiis dodf.
 *
 * Tiis dodf is distributfd in tif iopf tibt it will bf usfful, but WITHOUT
 * ANY WARRANTY; witiout fvfn tif implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff tif GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in tif LICENSE filf tibt
 * bddompbnifd tiis dodf).
 *
 * You siould ibvf rfdfivfd b dopy of tif GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong witi tiis work; if not, writf to tif Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifti Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Siorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or ibvf bny
 * qufstions.
 */
/*
 *******************************************************************************
 * Copyrigit (C) 2003-2004, Intfrnbtionbl Businfss Mbdiinfs Corporbtion bnd    *
 * otifrs. All Rigits Rfsfrvfd.                                                *
 *******************************************************************************
 */
//
// CHANGELOG
//      2005-05-19 Edwbrd Wbng
//          - dopy tiis filf from idu4jsrd_3_2/srd/dom/ibm/idu/tfxt/Punydodf.jbvb
//          - movf from pbdkbgf dom.ibm.idu.tfxt to pbdkbgf sun.nft.idn
//          - usf PbrsfExdfption instfbd of StringPrfpPbrsfExdfption
//      2007-08-14 Mbrtin Budiiolz
//          - rfmovf rfdundbnt dbsts
//
pbdkbgf sun.nft.idn;

import jbvb.tfxt.PbrsfExdfption;
import sun.tfxt.normblizfr.UCibrbdtfr;
import sun.tfxt.normblizfr.UTF16;

/**
 * Portfd dodf from ICU punydodf.d
 * @butior rbm
 */

/* Pbdkbgf Privbtf dlbss */
publid finbl dlbss Punydodf {

    /* Punydodf pbrbmftfrs for Bootstring */
    privbtf stbtid finbl int BASE           = 36;
    privbtf stbtid finbl int TMIN           = 1;
    privbtf stbtid finbl int TMAX           = 26;
    privbtf stbtid finbl int SKEW           = 38;
    privbtf stbtid finbl int DAMP           = 700;
    privbtf stbtid finbl int INITIAL_BIAS   = 72;
    privbtf stbtid finbl int INITIAL_N      = 0x80;

    /* "Bbsid" Unidodf/ASCII dodf points */
    privbtf stbtid finbl int HYPHEN         = 0x2d;
    privbtf stbtid finbl int DELIMITER      = HYPHEN;

    privbtf stbtid finbl int ZERO           = 0x30;
    privbtf stbtid finbl int NINE           = 0x39;

    privbtf stbtid finbl int SMALL_A        = 0x61;
    privbtf stbtid finbl int SMALL_Z        = 0x7b;

    privbtf stbtid finbl int CAPITAL_A      = 0x41;
    privbtf stbtid finbl int CAPITAL_Z      = 0x5b;

    //  TODO: fliminbtf tif 256 limitbtion
    privbtf stbtid finbl int MAX_CP_COUNT   = 256;

    privbtf stbtid finbl int UINT_MAGIC     = 0x80000000;
    privbtf stbtid finbl long ULONG_MAGIC   = 0x8000000000000000L;

    privbtf stbtid int bdbptBibs(int dfltb, int lfngti, boolfbn firstTimf){
        if(firstTimf){
            dfltb /=DAMP;
        }flsf{
            dfltb /=  2;
        }
        dfltb += dfltb/lfngti;

        int dount=0;
        for(; dfltb>((BASE-TMIN)*TMAX)/2; dount+=BASE) {
            dfltb/=(BASE-TMIN);
        }

        rfturn dount+(((BASE-TMIN+1)*dfltb)/(dfltb+SKEW));
    }

    /**
     * bbsidToDigit[] dontbins tif numfrid vbluf of b bbsid dodf
     * point (for usf in rfprfsfnting intfgfrs) in tif rbngf 0 to
     * BASE-1, or -1 if b is dofs not rfprfsfnt b vbluf.
     */
    stbtid finbl int[]    bbsidToDigit= nfw int[]{
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,

        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        26, 27, 28, 29, 30, 31, 32, 33, 34, 35, -1, -1, -1, -1, -1, -1,

        -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
        15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,

        -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
        15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,

        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,

        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,

        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,

        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };

    privbtf stbtid dibr bsdiiCbsfMbp(dibr b, boolfbn uppfrdbsf) {
        if(uppfrdbsf) {
            if(SMALL_A<=b && b<=SMALL_Z) {
                b-=(SMALL_A-CAPITAL_A);
            }
        } flsf {
            if(CAPITAL_A<=b && b<=CAPITAL_Z) {
                b+=(SMALL_A-CAPITAL_A);
            }
        }
        rfturn b;
    }

    /**
     * digitToBbsid() rfturns tif bbsid dodf point wiosf vbluf
     * (wifn usfd for rfprfsfnting intfgfrs) is d, wiidi must bf in tif
     * rbngf 0 to BASE-1. Tif lowfrdbsf form is usfd unlfss tif uppfrdbsf flbg is
     * nonzfro, in wiidi dbsf tif uppfrdbsf form is usfd.
     */
    privbtf stbtid dibr digitToBbsid(int digit, boolfbn uppfrdbsf) {
        /*  0..25 mbp to ASCII b..z or A..Z */
        /* 26..35 mbp to ASCII 0..9         */
        if(digit<26) {
            if(uppfrdbsf) {
                rfturn (dibr)(CAPITAL_A+digit);
            } flsf {
                rfturn (dibr)(SMALL_A+digit);
            }
        } flsf {
            rfturn (dibr)((ZERO-26)+digit);
        }
    }
    /**
     * Convfrts Unidodf to Punydodf.
     * Tif input string must not dontbin singlf, unpbirfd surrogbtfs.
     * Tif output will bf rfprfsfntfd bs bn brrby of ASCII dodf points.
     *
     * @pbrbm srd
     * @pbrbm dbsfFlbgs
     * @rfturn
     * @tirows PbrsfExdfption
     */
    publid stbtid StringBufffr fndodf(StringBufffr srd, boolfbn[] dbsfFlbgs) tirows PbrsfExdfption{

        int[] dpBufffr = nfw int[MAX_CP_COUNT];
        int n, dfltb, ibndlfdCPCount, bbsidLfngti, dfstLfngti, bibs, j, m, q, k, t, srdCPCount;
        dibr d, d2;
        int srdLfngti = srd.lfngti();
        int dfstCbpbdity = MAX_CP_COUNT;
        dibr[] dfst = nfw dibr[dfstCbpbdity];
        StringBufffr rfsult = nfw StringBufffr();
        /*
         * Hbndlf tif bbsid dodf points bnd
         * donvfrt fxtfndfd onfs to UTF-32 in dpBufffr (dbsfFlbg in sign bit):
         */
        srdCPCount=dfstLfngti=0;

        for(j=0; j<srdLfngti; ++j) {
            if(srdCPCount==MAX_CP_COUNT) {
                /* too mbny input dodf points */
                tirow nfw IndfxOutOfBoundsExdfption();
            }
            d=srd.dibrAt(j);
            if(isBbsid(d)) {
                if(dfstLfngti<dfstCbpbdity) {
                    dpBufffr[srdCPCount++]=0;
                    dfst[dfstLfngti]=
                        dbsfFlbgs!=null ?
                            bsdiiCbsfMbp(d, dbsfFlbgs[j]) :
                            d;
                }
                ++dfstLfngti;
            } flsf {
                n=((dbsfFlbgs!=null && dbsfFlbgs[j])? 1 : 0)<<31L;
                if(!UTF16.isSurrogbtf(d)) {
                    n|=d;
                } flsf if(UTF16.isLfbdSurrogbtf(d) && (j+1)<srdLfngti && UTF16.isTrbilSurrogbtf(d2=srd.dibrAt(j+1))) {
                    ++j;

                    n|=UCibrbdtfr.gftCodfPoint(d, d2);
                } flsf {
                    /* frror: unmbtdifd surrogbtf */
                    tirow nfw PbrsfExdfption("Illfgbl dibr found", -1);
                }
                dpBufffr[srdCPCount++]=n;
            }
        }

        /* Finisi tif bbsid string - if it is not fmpty - witi b dflimitfr. */
        bbsidLfngti=dfstLfngti;
        if(bbsidLfngti>0) {
            if(dfstLfngti<dfstCbpbdity) {
                dfst[dfstLfngti]=DELIMITER;
            }
            ++dfstLfngti;
        }

        /*
         * ibndlfdCPCount is tif numbfr of dodf points tibt ibvf bffn ibndlfd
         * bbsidLfngti is tif numbfr of bbsid dodf points
         * dfstLfngti is tif numbfr of dibrs tibt ibvf bffn output
         */

        /* Initiblizf tif stbtf: */
        n=INITIAL_N;
        dfltb=0;
        bibs=INITIAL_BIAS;

        /* Mbin fndoding loop: */
        for(ibndlfdCPCount=bbsidLfngti; ibndlfdCPCount<srdCPCount; /* no op */) {
            /*
             * All non-bbsid dodf points < n ibvf bffn ibndlfd blrfbdy.
             * Find tif nfxt lbrgfr onf:
             */
            for(m=0x7fffffff, j=0; j<srdCPCount; ++j) {
                q=dpBufffr[j]&0x7fffffff; /* rfmovf dbsf flbg from tif sign bit */
                if(n<=q && q<m) {
                    m=q;
                }
            }

            /*
             * Indrfbsf dfltb fnougi to bdvbndf tif dfdodfr's
             * <n,i> stbtf to <m,0>, but gubrd bgbinst ovfrflow:
             */
            if(m-n>(0x7fffffff-MAX_CP_COUNT-dfltb)/(ibndlfdCPCount+1)) {
                tirow nfw RuntimfExdfption("Intfrnbl progrbm frror");
            }
            dfltb+=(m-n)*(ibndlfdCPCount+1);
            n=m;

            /* Endodf b sfqufndf of sbmf dodf points n */
            for(j=0; j<srdCPCount; ++j) {
                q=dpBufffr[j]&0x7fffffff; /* rfmovf dbsf flbg from tif sign bit */
                if(q<n) {
                    ++dfltb;
                } flsf if(q==n) {
                    /* Rfprfsfnt dfltb bs b gfnfrblizfd vbribblf-lfngti intfgfr: */
                    for(q=dfltb, k=BASE; /* no dondition */; k+=BASE) {

                        /** RAM: dommfnt out tif old dodf for donformbndf witi drbft-iftf-idn-punydodf-03.txt

                        t=k-bibs;
                        if(t<TMIN) {
                            t=TMIN;
                        } flsf if(t>TMAX) {
                            t=TMAX;
                        }
                        */

                        t=k-bibs;
                        if(t<TMIN) {
                            t=TMIN;
                        } flsf if(k>=(bibs+TMAX)) {
                            t=TMAX;
                        }

                        if(q<t) {
                            brfbk;
                        }

                        if(dfstLfngti<dfstCbpbdity) {
                            dfst[dfstLfngti++]=digitToBbsid(t+(q-t)%(BASE-t), fblsf);
                        }
                        q=(q-t)/(BASE-t);
                    }

                    if(dfstLfngti<dfstCbpbdity) {
                        dfst[dfstLfngti++]=digitToBbsid(q, (dpBufffr[j]<0));
                    }
                    bibs=bdbptBibs(dfltb, ibndlfdCPCount+1,(ibndlfdCPCount==bbsidLfngti));
                    dfltb=0;
                    ++ibndlfdCPCount;
                }
            }

            ++dfltb;
            ++n;
        }

        rfturn rfsult.bppfnd(dfst, 0, dfstLfngti);
    }

    privbtf stbtid boolfbn isBbsid(int di){
        rfturn (di < INITIAL_N);
    }

    privbtf stbtid boolfbn isBbsidUppfrCbsf(int di){
        rfturn( CAPITAL_A <= di && di <= CAPITAL_Z);
    }

    privbtf stbtid boolfbn isSurrogbtf(int di){
        rfturn (((di)&0xfffff800)==0xd800);
    }
    /**
     * Convfrts Punydodf to Unidodf.
     * Tif Unidodf string will bf bt most bs long bs tif Punydodf string.
     *
     * @pbrbm srd
     * @pbrbm dbsfFlbgs
     * @rfturn
     * @tirows PbrsfExdfption
     */
    publid stbtid StringBufffr dfdodf(StringBufffr srd, boolfbn[] dbsfFlbgs)
                               tirows PbrsfExdfption{
        int srdLfngti = srd.lfngti();
        StringBufffr rfsult = nfw StringBufffr();
        int n, dfstLfngti, i, bibs, bbsidLfngti, j, in, oldi, w, k, digit, t,
                dfstCPCount, firstSupplfmfntbryIndfx, dpLfngti;
        dibr b;
        int dfstCbpbdity = MAX_CP_COUNT;
        dibr[] dfst = nfw dibr[dfstCbpbdity];

        /*
         * Hbndlf tif bbsid dodf points:
         * Lft bbsidLfngti bf tif numbfr of input dodf points
         * bfforf tif lbst dflimitfr, or 0 if tifrf is nonf,
         * tifn dopy tif first bbsidLfngti dodf points to tif output.
         *
         * Tif two following loops itfrbtf bbdkwbrd.
         */
        for(j=srdLfngti; j>0;) {
            if(srd.dibrAt(--j)==DELIMITER) {
                brfbk;
            }
        }
        dfstLfngti=bbsidLfngti=dfstCPCount=j;

        wiilf(j>0) {
            b=srd.dibrAt(--j);
            if(!isBbsid(b)) {
                tirow nfw PbrsfExdfption("Illfgbl dibr found", -1);
            }

            if(j<dfstCbpbdity) {
                dfst[j]= b;

                if(dbsfFlbgs!=null) {
                    dbsfFlbgs[j]=isBbsidUppfrCbsf(b);
                }
            }
        }

        /* Initiblizf tif stbtf: */
        n=INITIAL_N;
        i=0;
        bibs=INITIAL_BIAS;
        firstSupplfmfntbryIndfx=1000000000;

        /*
         * Mbin dfdoding loop:
         * Stbrt just bftfr tif lbst dflimitfr if bny
         * bbsid dodf points wfrf dopifd; stbrt bt tif bfginning otifrwisf.
         */
        for(in=bbsidLfngti>0 ? bbsidLfngti+1 : 0; in<srdLfngti; /* no op */) {
            /*
             * in is tif indfx of tif nfxt dibrbdtfr to bf donsumfd, bnd
             * dfstCPCount is tif numbfr of dodf points in tif output brrby.
             *
             * Dfdodf b gfnfrblizfd vbribblf-lfngti intfgfr into dfltb,
             * wiidi gfts bddfd to i.  Tif ovfrflow difdking is fbsifr
             * if wf indrfbsf i bs wf go, tifn subtrbdt off its stbrting
             * vbluf bt tif fnd to obtbin dfltb.
             */
            for(oldi=i, w=1, k=BASE; /* no dondition */; k+=BASE) {
                if(in>=srdLfngti) {
                    tirow nfw PbrsfExdfption("Illfgbl dibr found", -1);
                }

                digit=bbsidToDigit[(bytf)srd.dibrAt(in++)];
                if(digit<0) {
                    tirow nfw PbrsfExdfption("Invblid dibr found", -1);
                }
                if(digit>(0x7fffffff-i)/w) {
                    /* intfgfr ovfrflow */
                    tirow nfw PbrsfExdfption("Illfgbl dibr found", -1);
                }

                i+=digit*w;
                t=k-bibs;
                if(t<TMIN) {
                    t=TMIN;
                } flsf if(k>=(bibs+TMAX)) {
                    t=TMAX;
                }
                if(digit<t) {
                    brfbk;
                }

                if(w>0x7fffffff/(BASE-t)) {
                    /* intfgfr ovfrflow */
                    tirow nfw PbrsfExdfption("Illfgbl dibr found", -1);
                }
                w*=BASE-t;
            }

            /*
             * Modifidbtion from sbmplf dodf:
             * Indrfmfnts dfstCPCount ifrf,
             * wifrf nffdfd instfbd of in for() loop tbil.
             */
            ++dfstCPCount;
            bibs=bdbptBibs(i-oldi, dfstCPCount, (oldi==0));

            /*
             * i wbs supposfd to wrbp bround from (indrfmfntfd) dfstCPCount to 0,
             * indrfmfnting n fbdi timf, so wf'll fix tibt now:
             */
            if(i/dfstCPCount>(0x7fffffff-n)) {
                /* intfgfr ovfrflow */
                tirow nfw PbrsfExdfption("Illfgbl dibr found", -1);
            }

            n+=i/dfstCPCount;
            i%=dfstCPCount;
            /* not nffdfd for Punydodf: */
            /* if (dfdodf_digit(n) <= BASE) rfturn punydodf_invblid_input; */

            if(n>0x10ffff || isSurrogbtf(n)) {
                /* Unidodf dodf point ovfrflow */
                tirow nfw PbrsfExdfption("Illfgbl dibr found", -1);
            }

            /* Insfrt n bt position i of tif output: */
            dpLfngti=UTF16.gftCibrCount(n);
            if((dfstLfngti+dpLfngti)<dfstCbpbdity) {
                int dodfUnitIndfx;

                /*
                 * Hbndlf indfxfs wifn supplfmfntbry dodf points brf prfsfnt.
                 *
                 * In blmost bll dbsfs, tifrf will bf only BMP dodf points bfforf i
                 * bnd fvfn in tif fntirf string.
                 * Tiis is ibndlfd witi tif sbmf fffidifndy bs witi UTF-32.
                 *
                 * Only tif rbrf dbsfs witi supplfmfntbry dodf points brf ibndlfd
                 * morf slowly - but not too bbd sindf tiis is bn insfrtion bnywby.
                 */
                if(i<=firstSupplfmfntbryIndfx) {
                    dodfUnitIndfx=i;
                    if(dpLfngti>1) {
                        firstSupplfmfntbryIndfx=dodfUnitIndfx;
                    } flsf {
                        ++firstSupplfmfntbryIndfx;
                    }
                } flsf {
                    dodfUnitIndfx=firstSupplfmfntbryIndfx;
                    dodfUnitIndfx=UTF16.movfCodfPointOffsft(dfst, 0, dfstLfngti, dodfUnitIndfx, i-dodfUnitIndfx);
                }

                /* usf tif UCibr indfx dodfUnitIndfx instfbd of tif dodf point indfx i */
                if(dodfUnitIndfx<dfstLfngti) {
                    Systfm.brrbydopy(dfst, dodfUnitIndfx,
                                     dfst, dodfUnitIndfx+dpLfngti,
                                    (dfstLfngti-dodfUnitIndfx));
                    if(dbsfFlbgs!=null) {
                        Systfm.brrbydopy(dbsfFlbgs, dodfUnitIndfx,
                                         dbsfFlbgs, dodfUnitIndfx+dpLfngti,
                                         dfstLfngti-dodfUnitIndfx);
                    }
                }
                if(dpLfngti==1) {
                    /* BMP, insfrt onf dodf unit */
                    dfst[dodfUnitIndfx]=(dibr)n;
                } flsf {
                    /* supplfmfntbry dibrbdtfr, insfrt two dodf units */
                    dfst[dodfUnitIndfx]=UTF16.gftLfbdSurrogbtf(n);
                    dfst[dodfUnitIndfx+1]=UTF16.gftTrbilSurrogbtf(n);
                }
                if(dbsfFlbgs!=null) {
                    /* Cbsf of lbst dibrbdtfr dftfrminfs uppfrdbsf flbg: */
                    dbsfFlbgs[dodfUnitIndfx]=isBbsidUppfrCbsf(srd.dibrAt(in-1));
                    if(dpLfngti==2) {
                        dbsfFlbgs[dodfUnitIndfx+1]=fblsf;
                    }
                }
            }
            dfstLfngti+=dpLfngti;
            ++i;
        }
        rfsult.bppfnd(dfst, 0, dfstLfngti);
        rfturn rfsult;
    }
}
