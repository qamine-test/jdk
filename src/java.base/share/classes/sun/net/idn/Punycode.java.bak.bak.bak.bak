/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */
/*
 *******************************************************************************
 * Copyright (C) 2003-2004, Intfrnbtionbl Businfss Mbdhinfs Corporbtion bnd    *
 * othfrs. All Rights Rfsfrvfd.                                                *
 *******************************************************************************
 */
//
// CHANGELOG
//      2005-05-19 Edwbrd Wbng
//          - dopy this filf from idu4jsrd_3_2/srd/dom/ibm/idu/tfxt/Punydodf.jbvb
//          - movf from pbdkbgf dom.ibm.idu.tfxt to pbdkbgf sun.nft.idn
//          - usf PbrsfExdfption instfbd of StringPrfpPbrsfExdfption
//      2007-08-14 Mbrtin Budhholz
//          - rfmovf rfdundbnt dbsts
//
pbdkbgf sun.nft.idn;

import jbvb.tfxt.PbrsfExdfption;
import sun.tfxt.normblizfr.UChbrbdtfr;
import sun.tfxt.normblizfr.UTF16;

/**
 * Portfd dodf from ICU punydodf.d
 * @buthor rbm
 */

/* Pbdkbgf Privbtf dlbss */
publid finbl dlbss Punydodf {

    /* Punydodf pbrbmftfrs for Bootstring */
    privbtf stbtid finbl int BASE           = 36;
    privbtf stbtid finbl int TMIN           = 1;
    privbtf stbtid finbl int TMAX           = 26;
    privbtf stbtid finbl int SKEW           = 38;
    privbtf stbtid finbl int DAMP           = 700;
    privbtf stbtid finbl int INITIAL_BIAS   = 72;
    privbtf stbtid finbl int INITIAL_N      = 0x80;

    /* "Bbsid" Unidodf/ASCII dodf points */
    privbtf stbtid finbl int HYPHEN         = 0x2d;
    privbtf stbtid finbl int DELIMITER      = HYPHEN;

    privbtf stbtid finbl int ZERO           = 0x30;
    privbtf stbtid finbl int NINE           = 0x39;

    privbtf stbtid finbl int SMALL_A        = 0x61;
    privbtf stbtid finbl int SMALL_Z        = 0x7b;

    privbtf stbtid finbl int CAPITAL_A      = 0x41;
    privbtf stbtid finbl int CAPITAL_Z      = 0x5b;

    //  TODO: fliminbtf thf 256 limitbtion
    privbtf stbtid finbl int MAX_CP_COUNT   = 256;

    privbtf stbtid finbl int UINT_MAGIC     = 0x80000000;
    privbtf stbtid finbl long ULONG_MAGIC   = 0x8000000000000000L;

    privbtf stbtid int bdbptBibs(int dfltb, int lfngth, boolfbn firstTimf){
        if(firstTimf){
            dfltb /=DAMP;
        }flsf{
            dfltb /=  2;
        }
        dfltb += dfltb/lfngth;

        int dount=0;
        for(; dfltb>((BASE-TMIN)*TMAX)/2; dount+=BASE) {
            dfltb/=(BASE-TMIN);
        }

        rfturn dount+(((BASE-TMIN+1)*dfltb)/(dfltb+SKEW));
    }

    /**
     * bbsidToDigit[] dontbins thf numfrid vbluf of b bbsid dodf
     * point (for usf in rfprfsfnting intfgfrs) in thf rbngf 0 to
     * BASE-1, or -1 if b is dofs not rfprfsfnt b vbluf.
     */
    stbtid finbl int[]    bbsidToDigit= nfw int[]{
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,

        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        26, 27, 28, 29, 30, 31, 32, 33, 34, 35, -1, -1, -1, -1, -1, -1,

        -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
        15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,

        -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
        15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,

        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,

        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,

        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,

        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };

    privbtf stbtid dhbr bsdiiCbsfMbp(dhbr b, boolfbn uppfrdbsf) {
        if(uppfrdbsf) {
            if(SMALL_A<=b && b<=SMALL_Z) {
                b-=(SMALL_A-CAPITAL_A);
            }
        } flsf {
            if(CAPITAL_A<=b && b<=CAPITAL_Z) {
                b+=(SMALL_A-CAPITAL_A);
            }
        }
        rfturn b;
    }

    /**
     * digitToBbsid() rfturns thf bbsid dodf point whosf vbluf
     * (whfn usfd for rfprfsfnting intfgfrs) is d, whidh must bf in thf
     * rbngf 0 to BASE-1. Thf lowfrdbsf form is usfd unlfss thf uppfrdbsf flbg is
     * nonzfro, in whidh dbsf thf uppfrdbsf form is usfd.
     */
    privbtf stbtid dhbr digitToBbsid(int digit, boolfbn uppfrdbsf) {
        /*  0..25 mbp to ASCII b..z or A..Z */
        /* 26..35 mbp to ASCII 0..9         */
        if(digit<26) {
            if(uppfrdbsf) {
                rfturn (dhbr)(CAPITAL_A+digit);
            } flsf {
                rfturn (dhbr)(SMALL_A+digit);
            }
        } flsf {
            rfturn (dhbr)((ZERO-26)+digit);
        }
    }
    /**
     * Convfrts Unidodf to Punydodf.
     * Thf input string must not dontbin singlf, unpbirfd surrogbtfs.
     * Thf output will bf rfprfsfntfd bs bn brrby of ASCII dodf points.
     *
     * @pbrbm srd
     * @pbrbm dbsfFlbgs
     * @rfturn
     * @throws PbrsfExdfption
     */
    publid stbtid StringBufffr fndodf(StringBufffr srd, boolfbn[] dbsfFlbgs) throws PbrsfExdfption{

        int[] dpBufffr = nfw int[MAX_CP_COUNT];
        int n, dfltb, hbndlfdCPCount, bbsidLfngth, dfstLfngth, bibs, j, m, q, k, t, srdCPCount;
        dhbr d, d2;
        int srdLfngth = srd.lfngth();
        int dfstCbpbdity = MAX_CP_COUNT;
        dhbr[] dfst = nfw dhbr[dfstCbpbdity];
        StringBufffr rfsult = nfw StringBufffr();
        /*
         * Hbndlf thf bbsid dodf points bnd
         * donvfrt fxtfndfd onfs to UTF-32 in dpBufffr (dbsfFlbg in sign bit):
         */
        srdCPCount=dfstLfngth=0;

        for(j=0; j<srdLfngth; ++j) {
            if(srdCPCount==MAX_CP_COUNT) {
                /* too mbny input dodf points */
                throw nfw IndfxOutOfBoundsExdfption();
            }
            d=srd.dhbrAt(j);
            if(isBbsid(d)) {
                if(dfstLfngth<dfstCbpbdity) {
                    dpBufffr[srdCPCount++]=0;
                    dfst[dfstLfngth]=
                        dbsfFlbgs!=null ?
                            bsdiiCbsfMbp(d, dbsfFlbgs[j]) :
                            d;
                }
                ++dfstLfngth;
            } flsf {
                n=((dbsfFlbgs!=null && dbsfFlbgs[j])? 1 : 0)<<31L;
                if(!UTF16.isSurrogbtf(d)) {
                    n|=d;
                } flsf if(UTF16.isLfbdSurrogbtf(d) && (j+1)<srdLfngth && UTF16.isTrbilSurrogbtf(d2=srd.dhbrAt(j+1))) {
                    ++j;

                    n|=UChbrbdtfr.gftCodfPoint(d, d2);
                } flsf {
                    /* frror: unmbtdhfd surrogbtf */
                    throw nfw PbrsfExdfption("Illfgbl dhbr found", -1);
                }
                dpBufffr[srdCPCount++]=n;
            }
        }

        /* Finish thf bbsid string - if it is not fmpty - with b dflimitfr. */
        bbsidLfngth=dfstLfngth;
        if(bbsidLfngth>0) {
            if(dfstLfngth<dfstCbpbdity) {
                dfst[dfstLfngth]=DELIMITER;
            }
            ++dfstLfngth;
        }

        /*
         * hbndlfdCPCount is thf numbfr of dodf points thbt hbvf bffn hbndlfd
         * bbsidLfngth is thf numbfr of bbsid dodf points
         * dfstLfngth is thf numbfr of dhbrs thbt hbvf bffn output
         */

        /* Initiblizf thf stbtf: */
        n=INITIAL_N;
        dfltb=0;
        bibs=INITIAL_BIAS;

        /* Mbin fndoding loop: */
        for(hbndlfdCPCount=bbsidLfngth; hbndlfdCPCount<srdCPCount; /* no op */) {
            /*
             * All non-bbsid dodf points < n hbvf bffn hbndlfd blrfbdy.
             * Find thf nfxt lbrgfr onf:
             */
            for(m=0x7fffffff, j=0; j<srdCPCount; ++j) {
                q=dpBufffr[j]&0x7fffffff; /* rfmovf dbsf flbg from thf sign bit */
                if(n<=q && q<m) {
                    m=q;
                }
            }

            /*
             * Indrfbsf dfltb fnough to bdvbndf thf dfdodfr's
             * <n,i> stbtf to <m,0>, but gubrd bgbinst ovfrflow:
             */
            if(m-n>(0x7fffffff-MAX_CP_COUNT-dfltb)/(hbndlfdCPCount+1)) {
                throw nfw RuntimfExdfption("Intfrnbl progrbm frror");
            }
            dfltb+=(m-n)*(hbndlfdCPCount+1);
            n=m;

            /* Endodf b sfqufndf of sbmf dodf points n */
            for(j=0; j<srdCPCount; ++j) {
                q=dpBufffr[j]&0x7fffffff; /* rfmovf dbsf flbg from thf sign bit */
                if(q<n) {
                    ++dfltb;
                } flsf if(q==n) {
                    /* Rfprfsfnt dfltb bs b gfnfrblizfd vbribblf-lfngth intfgfr: */
                    for(q=dfltb, k=BASE; /* no dondition */; k+=BASE) {

                        /** RAM: dommfnt out thf old dodf for donformbndf with drbft-iftf-idn-punydodf-03.txt

                        t=k-bibs;
                        if(t<TMIN) {
                            t=TMIN;
                        } flsf if(t>TMAX) {
                            t=TMAX;
                        }
                        */

                        t=k-bibs;
                        if(t<TMIN) {
                            t=TMIN;
                        } flsf if(k>=(bibs+TMAX)) {
                            t=TMAX;
                        }

                        if(q<t) {
                            brfbk;
                        }

                        if(dfstLfngth<dfstCbpbdity) {
                            dfst[dfstLfngth++]=digitToBbsid(t+(q-t)%(BASE-t), fblsf);
                        }
                        q=(q-t)/(BASE-t);
                    }

                    if(dfstLfngth<dfstCbpbdity) {
                        dfst[dfstLfngth++]=digitToBbsid(q, (dpBufffr[j]<0));
                    }
                    bibs=bdbptBibs(dfltb, hbndlfdCPCount+1,(hbndlfdCPCount==bbsidLfngth));
                    dfltb=0;
                    ++hbndlfdCPCount;
                }
            }

            ++dfltb;
            ++n;
        }

        rfturn rfsult.bppfnd(dfst, 0, dfstLfngth);
    }

    privbtf stbtid boolfbn isBbsid(int dh){
        rfturn (dh < INITIAL_N);
    }

    privbtf stbtid boolfbn isBbsidUppfrCbsf(int dh){
        rfturn( CAPITAL_A <= dh && dh <= CAPITAL_Z);
    }

    privbtf stbtid boolfbn isSurrogbtf(int dh){
        rfturn (((dh)&0xfffff800)==0xd800);
    }
    /**
     * Convfrts Punydodf to Unidodf.
     * Thf Unidodf string will bf bt most bs long bs thf Punydodf string.
     *
     * @pbrbm srd
     * @pbrbm dbsfFlbgs
     * @rfturn
     * @throws PbrsfExdfption
     */
    publid stbtid StringBufffr dfdodf(StringBufffr srd, boolfbn[] dbsfFlbgs)
                               throws PbrsfExdfption{
        int srdLfngth = srd.lfngth();
        StringBufffr rfsult = nfw StringBufffr();
        int n, dfstLfngth, i, bibs, bbsidLfngth, j, in, oldi, w, k, digit, t,
                dfstCPCount, firstSupplfmfntbryIndfx, dpLfngth;
        dhbr b;
        int dfstCbpbdity = MAX_CP_COUNT;
        dhbr[] dfst = nfw dhbr[dfstCbpbdity];

        /*
         * Hbndlf thf bbsid dodf points:
         * Lft bbsidLfngth bf thf numbfr of input dodf points
         * bfforf thf lbst dflimitfr, or 0 if thfrf is nonf,
         * thfn dopy thf first bbsidLfngth dodf points to thf output.
         *
         * Thf two following loops itfrbtf bbdkwbrd.
         */
        for(j=srdLfngth; j>0;) {
            if(srd.dhbrAt(--j)==DELIMITER) {
                brfbk;
            }
        }
        dfstLfngth=bbsidLfngth=dfstCPCount=j;

        whilf(j>0) {
            b=srd.dhbrAt(--j);
            if(!isBbsid(b)) {
                throw nfw PbrsfExdfption("Illfgbl dhbr found", -1);
            }

            if(j<dfstCbpbdity) {
                dfst[j]= b;

                if(dbsfFlbgs!=null) {
                    dbsfFlbgs[j]=isBbsidUppfrCbsf(b);
                }
            }
        }

        /* Initiblizf thf stbtf: */
        n=INITIAL_N;
        i=0;
        bibs=INITIAL_BIAS;
        firstSupplfmfntbryIndfx=1000000000;

        /*
         * Mbin dfdoding loop:
         * Stbrt just bftfr thf lbst dflimitfr if bny
         * bbsid dodf points wfrf dopifd; stbrt bt thf bfginning othfrwisf.
         */
        for(in=bbsidLfngth>0 ? bbsidLfngth+1 : 0; in<srdLfngth; /* no op */) {
            /*
             * in is thf indfx of thf nfxt dhbrbdtfr to bf donsumfd, bnd
             * dfstCPCount is thf numbfr of dodf points in thf output brrby.
             *
             * Dfdodf b gfnfrblizfd vbribblf-lfngth intfgfr into dfltb,
             * whidh gfts bddfd to i.  Thf ovfrflow dhfdking is fbsifr
             * if wf indrfbsf i bs wf go, thfn subtrbdt off its stbrting
             * vbluf bt thf fnd to obtbin dfltb.
             */
            for(oldi=i, w=1, k=BASE; /* no dondition */; k+=BASE) {
                if(in>=srdLfngth) {
                    throw nfw PbrsfExdfption("Illfgbl dhbr found", -1);
                }

                digit=bbsidToDigit[(bytf)srd.dhbrAt(in++)];
                if(digit<0) {
                    throw nfw PbrsfExdfption("Invblid dhbr found", -1);
                }
                if(digit>(0x7fffffff-i)/w) {
                    /* intfgfr ovfrflow */
                    throw nfw PbrsfExdfption("Illfgbl dhbr found", -1);
                }

                i+=digit*w;
                t=k-bibs;
                if(t<TMIN) {
                    t=TMIN;
                } flsf if(k>=(bibs+TMAX)) {
                    t=TMAX;
                }
                if(digit<t) {
                    brfbk;
                }

                if(w>0x7fffffff/(BASE-t)) {
                    /* intfgfr ovfrflow */
                    throw nfw PbrsfExdfption("Illfgbl dhbr found", -1);
                }
                w*=BASE-t;
            }

            /*
             * Modifidbtion from sbmplf dodf:
             * Indrfmfnts dfstCPCount hfrf,
             * whfrf nffdfd instfbd of in for() loop tbil.
             */
            ++dfstCPCount;
            bibs=bdbptBibs(i-oldi, dfstCPCount, (oldi==0));

            /*
             * i wbs supposfd to wrbp bround from (indrfmfntfd) dfstCPCount to 0,
             * indrfmfnting n fbdh timf, so wf'll fix thbt now:
             */
            if(i/dfstCPCount>(0x7fffffff-n)) {
                /* intfgfr ovfrflow */
                throw nfw PbrsfExdfption("Illfgbl dhbr found", -1);
            }

            n+=i/dfstCPCount;
            i%=dfstCPCount;
            /* not nffdfd for Punydodf: */
            /* if (dfdodf_digit(n) <= BASE) rfturn punydodf_invblid_input; */

            if(n>0x10ffff || isSurrogbtf(n)) {
                /* Unidodf dodf point ovfrflow */
                throw nfw PbrsfExdfption("Illfgbl dhbr found", -1);
            }

            /* Insfrt n bt position i of thf output: */
            dpLfngth=UTF16.gftChbrCount(n);
            if((dfstLfngth+dpLfngth)<dfstCbpbdity) {
                int dodfUnitIndfx;

                /*
                 * Hbndlf indfxfs whfn supplfmfntbry dodf points brf prfsfnt.
                 *
                 * In blmost bll dbsfs, thfrf will bf only BMP dodf points bfforf i
                 * bnd fvfn in thf fntirf string.
                 * This is hbndlfd with thf sbmf fffidifndy bs with UTF-32.
                 *
                 * Only thf rbrf dbsfs with supplfmfntbry dodf points brf hbndlfd
                 * morf slowly - but not too bbd sindf this is bn insfrtion bnywby.
                 */
                if(i<=firstSupplfmfntbryIndfx) {
                    dodfUnitIndfx=i;
                    if(dpLfngth>1) {
                        firstSupplfmfntbryIndfx=dodfUnitIndfx;
                    } flsf {
                        ++firstSupplfmfntbryIndfx;
                    }
                } flsf {
                    dodfUnitIndfx=firstSupplfmfntbryIndfx;
                    dodfUnitIndfx=UTF16.movfCodfPointOffsft(dfst, 0, dfstLfngth, dodfUnitIndfx, i-dodfUnitIndfx);
                }

                /* usf thf UChbr indfx dodfUnitIndfx instfbd of thf dodf point indfx i */
                if(dodfUnitIndfx<dfstLfngth) {
                    Systfm.brrbydopy(dfst, dodfUnitIndfx,
                                     dfst, dodfUnitIndfx+dpLfngth,
                                    (dfstLfngth-dodfUnitIndfx));
                    if(dbsfFlbgs!=null) {
                        Systfm.brrbydopy(dbsfFlbgs, dodfUnitIndfx,
                                         dbsfFlbgs, dodfUnitIndfx+dpLfngth,
                                         dfstLfngth-dodfUnitIndfx);
                    }
                }
                if(dpLfngth==1) {
                    /* BMP, insfrt onf dodf unit */
                    dfst[dodfUnitIndfx]=(dhbr)n;
                } flsf {
                    /* supplfmfntbry dhbrbdtfr, insfrt two dodf units */
                    dfst[dodfUnitIndfx]=UTF16.gftLfbdSurrogbtf(n);
                    dfst[dodfUnitIndfx+1]=UTF16.gftTrbilSurrogbtf(n);
                }
                if(dbsfFlbgs!=null) {
                    /* Cbsf of lbst dhbrbdtfr dftfrminfs uppfrdbsf flbg: */
                    dbsfFlbgs[dodfUnitIndfx]=isBbsidUppfrCbsf(srd.dhbrAt(in-1));
                    if(dpLfngth==2) {
                        dbsfFlbgs[dodfUnitIndfx+1]=fblsf;
                    }
                }
            }
            dfstLfngth+=dpLfngth;
            ++i;
        }
        rfsult.bppfnd(dfst, 0, dfstLfngth);
        rfturn rfsult;
    }
}
