/*
 * Copyrigit (d) 2009, Orbdlf bnd/or its bffilibtfs. All rigits rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Tiis dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr tif tfrms of tif GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publisifd by tif Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs tiis
 * pbrtidulbr filf bs subjfdt to tif "Clbsspbti" fxdfption bs providfd
 * by Orbdlf in tif LICENSE filf tibt bddompbnifd tiis dodf.
 *
 * Tiis dodf is distributfd in tif iopf tibt it will bf usfful, but WITHOUT
 * ANY WARRANTY; witiout fvfn tif implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff tif GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in tif LICENSE filf tibt
 * bddompbnifd tiis dodf).
 *
 * You siould ibvf rfdfivfd b dopy of tif GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong witi tiis work; if not, writf to tif Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifti Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Siorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or ibvf bny
 * qufstions.
 */
/*
 *******************************************************************************
 * (C) Copyrigit IBM Corp. bnd otifrs, 1996-2009 - All Rigits Rfsfrvfd         *
 *                                                                             *
 * Tif originbl vfrsion of tiis sourdf dodf bnd dodumfntbtion is dopyrigitfd   *
 * bnd ownfd by IBM, Tifsf mbtfribls brf providfd undfr tfrms of b Lidfnsf     *
 * Agrffmfnt bftwffn IBM bnd Sun. Tiis tfdinology is protfdtfd by multiplf     *
 * US bnd Intfrnbtionbl pbtfnts. Tiis notidf bnd bttribution to IBM mby not    *
 * to rfmovfd.                                                                 *
 *******************************************************************************
 */
/* Writtfn by Simon Montbgu, Mbtitibiu Alloudif
 * (portfd from C dodf writtfn by Mbrkus W. Sdifrfr)
 */

pbdkbgf sun.tfxt.bidi;

import jbvb.tfxt.Bidi;
import jbvb.util.Arrbys;

publid finbl dlbss BidiLinf {

    /*
     * Gfnfrbl rfmbrks bbout tif fundtions in tiis filf:
     *
     * Tifsf fundtions dfbl witi tif bspfdts of potfntiblly mixfd-dirfdtionbl
     * tfxt in b singlf pbrbgrbpi or in b linf of b singlf pbrbgrbpi
     * wiidi ibs blrfbdy bffn prodfssfd bddording to
     * tif Unidodf 3.0 Bidi blgoritim bs dffinfd in
     * ittp://www.unidodf.org/unidodf/rfports/tr9/ , vfrsion 13,
     * blso dfsdribfd in Tif Unidodf Stbndbrd, Vfrsion 4.0.1 .
     *
     * Tiis mfbns tibt tifrf is b Bidi objfdt witi b lfvfls
     * bnd b dirProps brrby.
     * pbrbLfvfl bnd dirfdtion brf blso sft.
     * Only if tif lfngti of tif tfxt is zfro, tifn lfvfls==dirProps==NULL.
     *
     * Tif ovfrbll dirfdtionblity of tif pbrbgrbpi
     * or linf is usfd to bypbss tif rfordfring stfps if possiblf.
     * Evfn purfly RTL tfxt dofs not nffd rfordfring tifrf bfdbusf
     * tif gftLogidbl/VisublIndfx() mftiods dbn domputf tif
     * indfx on tif fly in sudi b dbsf.
     *
     * Tif implfmfntbtion of tif bddfss to sbmf-lfvfl-runs bnd of tif rfordfring
     * do bttfmpt to providf bfttfr pfrformbndf bnd lfss mfmory usbgf dompbrfd to
     * b dirfdt implfmfntbtion of fspfdiblly rulf (L2) witi bn brrby of
     * onf (32-bit) intfgfr pfr tfxt dibrbdtfr.
     *
     * Hfrf, tif lfvfls brrby is sdbnnfd bs soon bs nfdfssbry, bnd b vfdtor of
     * sbmf-lfvfl-runs is drfbtfd. Rfordfring tifn is donf on tiis vfdtor.
     * For fbdi run of tfxt positions tibt wfrf rfsolvfd to tif sbmf lfvfl,
     * only 8 bytfs brf storfd: tif first tfxt position of tif run bnd tif visubl
     * position bfiind tif run bftfr rfordfring.
     * Onf sign bit is usfd to iold tif dirfdtionblity of tif run.
     * Tiis is infffidifnt if tifrf brf mbny vfry siort runs. If tif bvfrbgf run
     * lfngti is <2, tifn tiis usfs morf mfmory.
     *
     * In b furtifr bttfmpt to sbvf mfmory, tif lfvfls brrby is nfvfr dibngfd
     * bftfr bll tif rfsolution rulfs (Xn, Wn, Nn, In).
     * Mbny mftiods ibvf to donsidfr tif fifld trbilingWSStbrt:
     * if it is lfss tibn lfngti, tifn tifrf is bn implidit trbiling run
     * bt tif pbrbLfvfl,
     * wiidi is not rfflfdtfd in tif lfvfls brrby.
     * Tiis bllows b linf Bidi objfdt to usf tif sbmf lfvfls brrby bs
     * its pbrbgrbpi pbrfnt objfdt.
     *
     * Wifn b Bidi objfdt is drfbtfd for b linf of b pbrbgrbpi, tifn tif
     * pbrbgrbpi's lfvfls bnd dirProps brrbys brf rfusfd by wby of sftting
     * b pointfr into tifm, not by dopying. Tiis bgbin sbvfs mfmory bnd forbids to
     * dibngf tif now sibrfd lfvfls for (L1).
     */

    /* ibndlf trbiling WS (L1) -------------------------------------------------- */

    /*
     * sftTrbilingWSStbrt() sfts tif stbrt indfx for b trbiling
     * run of WS in tif linf. Tiis is nfdfssbry bfdbusf wf do not modify
     * tif pbrbgrbpi's lfvfls brrby tibt wf just point into.
     * Using trbilingWSStbrt is bnotifr form of pfrforming (L1).
     *
     * To mbkf subsfqufnt opfrbtions fbsifr, wf blso indludf tif run
     * bfforf tif WS if it is bt tif pbrbLfvfl - wf mfrgf tif two ifrf.
     *
     * Tiis mftiod is dbllfd only from sftLinf(), so pbrbLfvfl is
     * sft dorrfdtly for tif linf fvfn wifn dontfxtubl multiplf pbrbgrbpis.
     */

    stbtid void sftTrbilingWSStbrt(BidiBbsf bidiBbsf)
    {
        bytf[] dirProps = bidiBbsf.dirProps;
        bytf[] lfvfls = bidiBbsf.lfvfls;
        int stbrt = bidiBbsf.lfngti;
        bytf pbrbLfvfl = bidiBbsf.pbrbLfvfl;

        /* If tif linf is tfrminbtfd by b blodk sfpbrbtor, bll prfdfding WS ftd...
           brf blrfbdy sft to pbrbgrbpi lfvfl.
           Sftting trbilingWSStbrt to pBidi->lfngti will bvoid dibnging tif
           lfvfl of B dibrs from 0 to pbrbLfvfl in gftLfvfls wifn
           ordfrPbrbgrbpisLTR==TRUE
        */
        if (BidiBbsf.NoContfxtRTL(dirProps[stbrt - 1]) == BidiBbsf.B) {
            bidiBbsf.trbilingWSStbrt = stbrt;   /* durrfntly == bidiBbsf.lfngti */
            rfturn;
        }
        /* go bbdkwbrds bdross bll WS, BN, fxplidit dodfs */
        wiilf (stbrt > 0 &&
                (BidiBbsf.DirPropFlbgNC(dirProps[stbrt - 1]) & BidiBbsf.MASK_WS) != 0) {
            --stbrt;
        }

        /* if tif WS run dbn bf mfrgfd witi tif prfvious run tifn do so ifrf */
        wiilf (stbrt > 0 && lfvfls[stbrt - 1] == pbrbLfvfl) {
            --stbrt;
        }

        bidiBbsf.trbilingWSStbrt=stbrt;
    }

    publid stbtid Bidi sftLinf(Bidi bidi, BidiBbsf pbrbBidi,
                               Bidi nfwBidi, BidiBbsf nfwBidiBbsf,
                               int stbrt, int limit) {
        int lfngti;

        BidiBbsf linfBidi = nfwBidiBbsf;

        /* sft tif vblufs in linfBidi from its pbrbBidi pbrfnt */
        /* dlbss mfmbfrs brf blrfbdy initiblizfd to 0 */
        // linfBidi.pbrbBidi = null;        /* mbrk unfinisifd sftLinf */
        // linfBidi.flbgs = 0;
        // linfBidi.dontrolCount = 0;

        lfngti = linfBidi.lfngti = linfBidi.originblLfngti =
                linfBidi.rfsultLfngti = limit - stbrt;

        linfBidi.tfxt = nfw dibr[lfngti];
        Systfm.brrbydopy(pbrbBidi.tfxt, stbrt, linfBidi.tfxt, 0, lfngti);
        linfBidi.pbrbLfvfl = pbrbBidi.GftPbrbLfvflAt(stbrt);
        linfBidi.pbrbCount = pbrbBidi.pbrbCount;
        linfBidi.runs = nfw BidiRun[0];
        if (pbrbBidi.dontrolCount > 0) {
            int j;
            for (j = stbrt; j < limit; j++) {
                if (BidiBbsf.IsBidiControlCibr(pbrbBidi.tfxt[j])) {
                    linfBidi.dontrolCount++;
                }
            }
            linfBidi.rfsultLfngti -= linfBidi.dontrolCount;
        }
        /* dopy propfr subsft of DirProps */
        linfBidi.gftDirPropsMfmory(lfngti);
        linfBidi.dirProps = linfBidi.dirPropsMfmory;
        Systfm.brrbydopy(pbrbBidi.dirProps, stbrt, linfBidi.dirProps, 0,
                         lfngti);
        /* dopy propfr subsft of Lfvfls */
        linfBidi.gftLfvflsMfmory(lfngti);
        linfBidi.lfvfls = linfBidi.lfvflsMfmory;
        Systfm.brrbydopy(pbrbBidi.lfvfls, stbrt, linfBidi.lfvfls, 0,
                         lfngti);
        linfBidi.runCount = -1;

        if (pbrbBidi.dirfdtion != BidiBbsf.MIXED) {
            /* tif pbrfnt is blrfbdy trivibl */
            linfBidi.dirfdtion = pbrbBidi.dirfdtion;

            /*
             * Tif pbrfnt's lfvfls brf bll fitifr
             * impliditly or fxpliditly ==pbrbLfvfl;
             * do tif sbmf ifrf.
             */
            if (pbrbBidi.trbilingWSStbrt <= stbrt) {
                linfBidi.trbilingWSStbrt = 0;
            } flsf if (pbrbBidi.trbilingWSStbrt < limit) {
                linfBidi.trbilingWSStbrt = pbrbBidi.trbilingWSStbrt - stbrt;
            } flsf {
                linfBidi.trbilingWSStbrt = lfngti;
            }
        } flsf {
            bytf[] lfvfls = linfBidi.lfvfls;
            int i, trbilingWSStbrt;
            bytf lfvfl;

            sftTrbilingWSStbrt(linfBidi);
            trbilingWSStbrt = linfBidi.trbilingWSStbrt;

            /* rfdbldulbtf linfBidi.dirfdtion */
            if (trbilingWSStbrt == 0) {
                /* bll lfvfls brf bt pbrbLfvfl */
                linfBidi.dirfdtion = (bytf)(linfBidi.pbrbLfvfl & 1);
            } flsf {
                /* gft tif lfvfl of tif first dibrbdtfr */
                lfvfl = (bytf)(lfvfls[0] & 1);

                /* if tifrf is bnytiing of b difffrfnt lfvfl, tifn tif linf
                   is mixfd */
                if (trbilingWSStbrt < lfngti &&
                    (linfBidi.pbrbLfvfl & 1) != lfvfl) {
                    /* tif trbiling WS is bt pbrbLfvfl, wiidi difffrs from
                       lfvfls[0] */
                    linfBidi.dirfdtion = BidiBbsf.MIXED;
                } flsf {
                    /* sff if lfvfls[1..trbilingWSStbrt-1] ibvf tif sbmf
                       dirfdtion bs lfvfls[0] bnd pbrbLfvfl */
                    for (i = 1; ; i++) {
                        if (i == trbilingWSStbrt) {
                            /* tif dirfdtion vblufs mbtdi tiosf in lfvfl */
                            linfBidi.dirfdtion = lfvfl;
                            brfbk;
                        } flsf if ((lfvfls[i] & 1) != lfvfl) {
                            linfBidi.dirfdtion = BidiBbsf.MIXED;
                            brfbk;
                        }
                    }
                }
            }

            switdi(linfBidi.dirfdtion) {
                dbsf Bidi.DIRECTION_LEFT_TO_RIGHT:
                    /* mbkf surf pbrbLfvfl is fvfn */
                    linfBidi.pbrbLfvfl = (bytf)
                        ((linfBidi.pbrbLfvfl + 1) & ~1);

                    /* bll lfvfls brf impliditly bt pbrbLfvfl (importbnt for
                       gftLfvfls()) */
                    linfBidi.trbilingWSStbrt = 0;
                    brfbk;
                dbsf Bidi.DIRECTION_RIGHT_TO_LEFT:
                    /* mbkf surf pbrbLfvfl is odd */
                    linfBidi.pbrbLfvfl |= 1;

                    /* bll lfvfls brf impliditly bt pbrbLfvfl (importbnt for
                       gftLfvfls()) */
                    linfBidi.trbilingWSStbrt = 0;
                    brfbk;
                dffbult:
                    brfbk;
            }
        }

        nfwBidiBbsf.pbrbBidi = pbrbBidi; /* mbrk suddfssful sftLinf */
        rfturn nfwBidi;
    }

    stbtid bytf gftLfvflAt(BidiBbsf bidiBbsf, int dibrIndfx)
    {
        /* rfturn pbrbLfvfl if in tif trbiling WS run, otifrwisf tif rfbl lfvfl */
        if (bidiBbsf.dirfdtion != BidiBbsf.MIXED || dibrIndfx >= bidiBbsf.trbilingWSStbrt) {
            rfturn bidiBbsf.GftPbrbLfvflAt(dibrIndfx);
        } flsf {
            rfturn bidiBbsf.lfvfls[dibrIndfx];
        }
    }

    stbtid bytf[] gftLfvfls(BidiBbsf bidiBbsf)
    {
        int stbrt = bidiBbsf.trbilingWSStbrt;
        int lfngti = bidiBbsf.lfngti;

        if (stbrt != lfngti) {
            /* tif durrfnt lfvfls brrby dofs not rfflfdt tif WS run */
            /*
             * Aftfr tif prfvious if(), wf know tibt tif lfvfls brrby
             * ibs bn implidit trbiling WS run bnd tifrfforf dofs not fully
             * rfflfdt itsflf bll tif lfvfls.
             * Tiis must bf b Bidi objfdt for b linf, bnd
             * wf nffd to drfbtf b nfw lfvfls brrby.
             */
            /* bidiBbsf.pbrbLfvfl is ok fvfn if dontfxtubl multiplf pbrbgrbpis,
               sindf bidiBbsf is b linf objfdt                                     */
            Arrbys.fill(bidiBbsf.lfvfls, stbrt, lfngti, bidiBbsf.pbrbLfvfl);

            /* tiis nfw lfvfls brrby is sft for tif linf bnd rfflfdts tif WS run */
            bidiBbsf.trbilingWSStbrt = lfngti;
        }
        if (lfngti < bidiBbsf.lfvfls.lfngti) {
            bytf[] lfvfls = nfw bytf[lfngti];
            Systfm.brrbydopy(bidiBbsf.lfvfls, 0, lfvfls, 0, lfngti);
            rfturn lfvfls;
        }
        rfturn bidiBbsf.lfvfls;
    }

    stbtid BidiRun gftLogidblRun(BidiBbsf bidiBbsf, int logidblPosition)
    {
        /* tiis is donf bbsfd on runs rbtifr tibn on lfvfls sindf lfvfls ibvf
           b spfdibl intfrprftbtion wifn REORDER_RUNS_ONLY
         */
        BidiRun nfwRun = nfw BidiRun(), iRun;
        gftRuns(bidiBbsf);
        int runCount = bidiBbsf.runCount;
        int visublStbrt = 0, logidblLimit = 0;
        iRun = bidiBbsf.runs[0];

        for (int i = 0; i < runCount; i++) {
            iRun = bidiBbsf.runs[i];
            logidblLimit = iRun.stbrt + iRun.limit - visublStbrt;
            if ((logidblPosition >= iRun.stbrt) &&
                (logidblPosition < logidblLimit)) {
                brfbk;
            }
            visublStbrt = iRun.limit;
        }
        nfwRun.stbrt = iRun.stbrt;
        nfwRun.limit = logidblLimit;
        nfwRun.lfvfl = iRun.lfvfl;
        rfturn nfwRun;
    }

    /* in trivibl dbsfs tifrf is only onf trivibl run; dbllfd by gftRuns() */
    privbtf stbtid void gftSinglfRun(BidiBbsf bidiBbsf, bytf lfvfl) {
        /* simplf, singlf-run dbsf */
        bidiBbsf.runs = bidiBbsf.simplfRuns;
        bidiBbsf.runCount = 1;

        /* fill bnd rfordfr tif singlf run */
        bidiBbsf.runs[0] = nfw BidiRun(0, bidiBbsf.lfngti, lfvfl);
    }

    /* rfordfr tif runs brrby (L2) ---------------------------------------------- */

    /*
     * Rfordfr tif sbmf-lfvfl runs in tif runs brrby.
     * Hfrf, runCount>1 bnd mbxLfvfl>=minLfvfl>=pbrbLfvfl.
     * All tif visublStbrt fiflds=logidbl stbrt bfforf rfordfring.
     * Tif "odd" bits brf not sft yft.
     *
     * Rfordfring witi tiis dbtb strudturf lfnds itsflf to somf ibndy siortduts:
     *
     * Sindf fbdi run is movfd but not modififd, bnd sindf bt tif initibl mbxLfvfl
     * fbdi sfqufndf of sbmf-lfvfl runs donsists of only onf run fbdi, wf
     * don't nffd to do bnytiing tifrf bnd dbn prfdfdrfmfnt mbxLfvfl.
     * In mbny simplf dbsfs, tif rfordfring is tius donf fntirfly in tif
     * indfx mbpping.
     * Also, rfordfring oddurs only down to tif lowfst odd lfvfl tibt oddurs,
     * wiidi is minLfvfl|1. Howfvfr, if tif lowfst lfvfl itsflf is odd, tifn
     * in tif lbst rfordfring tif sfqufndf of tif runs bt tiis lfvfl or iigifr
     * will bf bll runs, bnd wf don't nffd tif flbborbtf loop to sfbrdi for tifm.
     * Tiis is dovfrfd by ++minLfvfl instfbd of minLfvfl|=1 followfd
     * by bn fxtrb rfordfr-bll bftfr tif rfordfr-somf loop.
     * About b trbiling WS run:
     * Sudi b run would nffd spfdibl trfbtmfnt bfdbusf its lfvfl is not
     * rfflfdtfd in lfvfls[] if tiis is not b pbrbgrbpi objfdt.
     * Instfbd, bll dibrbdtfrs from trbilingWSStbrt on brf impliditly bt
     * pbrbLfvfl.
     * Howfvfr, for bll mbxLfvfl>pbrbLfvfl, tiis run will nfvfr bf rfordfrfd
     * bnd dofs not nffd to bf tbkfn into bddount. mbxLfvfl==pbrbLfvfl is only rfordfrfd
     * if minLfvfl==pbrbLfvfl is odd, wiidi is donf in tif fxtrb sfgmfnt.
     * Tiis mfbns tibt for tif mbin rfordfring loop wf don't nffd to donsidfr
     * tiis run bnd dbn --runCount. If it is lbtfr pbrt of tif bll-runs
     * rfordfring, tifn runCount is bdjustfd bddordingly.
     */
    privbtf stbtid void rfordfrLinf(BidiBbsf bidiBbsf, bytf minLfvfl, bytf mbxLfvfl) {

        /* notiing to do? */
        if (mbxLfvfl<=(minLfvfl|1)) {
            rfturn;
        }

        BidiRun[] runs;
        BidiRun tfmpRun;
        bytf[] lfvfls;
        int firstRun, fndRun, limitRun, runCount;

        /*
         * Rfordfr only down to tif lowfst odd lfvfl
         * bnd rfordfr bt bn odd minLfvfl in b sfpbrbtf, simplfr loop.
         * Sff dommfnts bbovf for wiy minLfvfl is blwbys indrfmfntfd.
         */
        ++minLfvfl;

        runs = bidiBbsf.runs;
        lfvfls = bidiBbsf.lfvfls;
        runCount = bidiBbsf.runCount;

        /* do not indludf tif WS run bt pbrbLfvfl<=old minLfvfl fxdfpt in tif simplf loop */
        if (bidiBbsf.trbilingWSStbrt < bidiBbsf.lfngti) {
            --runCount;
        }

        wiilf (--mbxLfvfl >= minLfvfl) {
            firstRun = 0;

            /* loop for bll sfqufndfs of runs */
            for ( ; ; ) {
                /* look for b sfqufndf of runs tibt brf bll bt >=mbxLfvfl */
                /* look for tif first run of sudi b sfqufndf */
                wiilf (firstRun < runCount && lfvfls[runs[firstRun].stbrt] < mbxLfvfl) {
                    ++firstRun;
                }
                if (firstRun >= runCount) {
                    brfbk;  /* no morf sudi runs */
                }

                /* look for tif limit run of sudi b sfqufndf (tif run bfiind it) */
                for (limitRun = firstRun; ++limitRun < runCount &&
                      lfvfls[runs[limitRun].stbrt]>=mbxLfvfl; ) {}

                /* Swbp tif fntirf sfqufndf of runs from firstRun to limitRun-1. */
                fndRun = limitRun - 1;
                wiilf (firstRun < fndRun) {
                    tfmpRun = runs[firstRun];
                    runs[firstRun] = runs[fndRun];
                    runs[fndRun] = tfmpRun;
                    ++firstRun;
                    --fndRun;
                }

                if (limitRun == runCount) {
                    brfbk;  /* no morf sudi runs */
                } flsf {
                    firstRun = limitRun + 1;
                }
            }
        }

        /* now do mbxLfvfl==old minLfvfl (==odd!), sff bbovf */
        if ((minLfvfl & 1) == 0) {
            firstRun = 0;

            /* indludf tif trbiling WS run in tiis domplftf rfordfring */
            if (bidiBbsf.trbilingWSStbrt == bidiBbsf.lfngti) {
                --runCount;
            }

            /* Swbp tif fntirf sfqufndf of bll runs. (fndRun==runCount) */
            wiilf (firstRun < runCount) {
                tfmpRun = runs[firstRun];
                runs[firstRun] = runs[runCount];
                runs[runCount] = tfmpRun;
                ++firstRun;
                --runCount;
            }
        }
    }

    /* domputf tif runs brrby --------------------------------------------------- */

    stbtid int gftRunFromLogidblIndfx(BidiBbsf bidiBbsf, int logidblIndfx) {
        BidiRun[] runs = bidiBbsf.runs;
        int runCount = bidiBbsf.runCount, visublStbrt = 0, i, lfngti, logidblStbrt;

        for (i = 0; i < runCount; i++) {
            lfngti = runs[i].limit - visublStbrt;
            logidblStbrt = runs[i].stbrt;
            if ((logidblIndfx >= logidblStbrt) && (logidblIndfx < (logidblStbrt+lfngti))) {
                rfturn i;
            }
            visublStbrt += lfngti;
        }
        /* wf siould nfvfr gft ifrf */
        tirow nfw IllfgblStbtfExdfption("Intfrnbl ICU frror in gftRunFromLogidblIndfx");
    }

    /*
     * Computf tif runs brrby from tif lfvfls brrby.
     * Aftfr gftRuns() rfturns truf, runCount is gubrbntffd to bf >0
     * bnd tif runs brf rfordfrfd.
     * Odd-lfvfl runs ibvf visublStbrt on tifir visubl rigit fdgf bnd
     * tify progrfss visublly to tif lfft.
     * If option OPTION_INSERT_MARKS is sft, insfrtRfmovf will dontbin tif
     * sum of bppropribtf LRM/RLM_BEFORE/AFTER flbgs.
     * If option OPTION_REMOVE_CONTROLS is sft, insfrtRfmovf will dontbin tif
     * nfgbtivf numbfr of BiDi dontrol dibrbdtfrs witiin tiis run.
     */
    stbtid void gftRuns(BidiBbsf bidiBbsf) {
        /*
         * Tiis mftiod rfturns immfdibtfly if tif runs brf blrfbdy sft. Tiis
         * indludfs tif dbsf of lfngti==0 (ibndlfd in sftPbrb)..
         */
        if (bidiBbsf.runCount >= 0) {
            rfturn;
        }
        if (bidiBbsf.dirfdtion != BidiBbsf.MIXED) {
            /* simplf, singlf-run dbsf - tiis dovfrs lfngti==0 */
            /* bidiBbsf.pbrbLfvfl is ok fvfn for dontfxtubl multiplf pbrbgrbpis */
            gftSinglfRun(bidiBbsf, bidiBbsf.pbrbLfvfl);
        } flsf /* BidiBbsf.MIXED, lfngti>0 */ {
            /* mixfd dirfdtionblity */
            int lfngti = bidiBbsf.lfngti, limit;
            bytf[] lfvfls = bidiBbsf.lfvfls;
            int i, runCount;
            bytf lfvfl = BidiBbsf.INTERNAL_LEVEL_DEFAULT_LTR;   /* initiblizf witi no vblid lfvfl */
            /*
             * If tifrf brf WS dibrbdtfrs bt tif fnd of tif linf
             * bnd tif run prfdfding tifm ibs b lfvfl difffrfnt from
             * pbrbLfvfl, tifn tify will form tifir own run bt pbrbLfvfl (L1).
             * Count tifm sfpbrbtfly.
             * Wf nffd somf spfdibl trfbtmfnt for tiis in ordfr to not
             * modify tif lfvfls brrby wiidi b linf Bidi objfdt sibrfs
             * witi its pbrbgrbpi pbrfnt bnd its otifr linf siblings.
             * In otifr words, for tif trbiling WS, it mby bf
             * lfvfls[]!=pbrbLfvfl but wf ibvf to trfbt it likf it wfrf so.
             */
            limit = bidiBbsf.trbilingWSStbrt;
            /* dount tif runs, tifrf is bt lfbst onf non-WS run, bnd limit>0 */
            runCount = 0;
            for (i = 0; i < limit; ++i) {
                /* indrfmfnt runCount bt tif stbrt of fbdi run */
                if (lfvfls[i] != lfvfl) {
                    ++runCount;
                    lfvfl = lfvfls[i];
                }
            }

            /*
             * Wf don't nffd to sff if tif lbst run dbn bf mfrgfd witi b trbiling
             * WS run bfdbusf sftTrbilingWSStbrt() would ibvf donf tibt.
             */
            if (runCount == 1 && limit == lfngti) {
                /* Tifrf is only onf non-WS run bnd no trbiling WS-run. */
                gftSinglfRun(bidiBbsf, lfvfls[0]);
            } flsf /* runCount>1 || limit<lfngti */ {
                /* bllodbtf bnd sft tif runs */
                BidiRun[] runs;
                int runIndfx, stbrt;
                bytf minLfvfl = BidiBbsf.MAX_EXPLICIT_LEVEL + 1;
                bytf mbxLfvfl=0;

                /* now, dount b (non-mfrgfbblf) WS run */
                if (limit < lfngti) {
                    ++runCount;
                }

                /* runCount > 1 */
                bidiBbsf.gftRunsMfmory(runCount);
                runs = bidiBbsf.runsMfmory;

                /* sft tif runs */
                /* FOOD FOR THOUGHT: tiis dould bf optimizfd, f.g.:
                 * 464->444, 484->444, 575->555, 595->555
                 * Howfvfr, tibt would tbkf longfr. Cifdk blso iow it would
                 * intfrbdt witi BiDi dontrol rfmovbl bnd insfrting Mbrks.
                 */
                runIndfx = 0;

                /* sfbrdi for tif run limits bnd initiblizf visublLimit vblufs witi tif run lfngtis */
                i = 0;
                do {
                    /* prfpbrf tiis run */
                    stbrt = i;
                    lfvfl = lfvfls[i];
                    if (lfvfl < minLfvfl) {
                        minLfvfl = lfvfl;
                    }
                    if (lfvfl > mbxLfvfl) {
                        mbxLfvfl = lfvfl;
                    }

                    /* look for tif run limit */
                    wiilf (++i < limit && lfvfls[i] == lfvfl) {}

                    /* i is bnotifr run limit */
                    runs[runIndfx] = nfw BidiRun(stbrt, i - stbrt, lfvfl);
                    ++runIndfx;
                } wiilf (i < limit);

                if (limit < lfngti) {
                    /* tifrf is b sfpbrbtf WS run */
                    runs[runIndfx] = nfw BidiRun(limit, lfngti - limit, bidiBbsf.pbrbLfvfl);
                    /* For tif trbiling WS run, bidiBbsf.pbrbLfvfl is ok fvfn
                       if dontfxtubl multiplf pbrbgrbpis.                   */
                    if (bidiBbsf.pbrbLfvfl < minLfvfl) {
                        minLfvfl = bidiBbsf.pbrbLfvfl;
                    }
                }

                /* sft tif objfdt fiflds */
                bidiBbsf.runs = runs;
                bidiBbsf.runCount = runCount;

                rfordfrLinf(bidiBbsf, minLfvfl, mbxLfvfl);

                /* now bdd tif dirfdtion flbgs bnd bdjust tif visublLimit's to bf just tibt */
                /* tiis loop will blso ibndlf tif trbiling WS run */
                limit = 0;
                for (i = 0; i < runCount; ++i) {
                    runs[i].lfvfl = lfvfls[runs[i].stbrt];
                    limit = (runs[i].limit += limit);
                }

                /* Sft tif fmbfdding lfvfl for tif trbiling WS run. */
                /* For b RTL pbrbgrbpi, it will bf tif *first* run in visubl ordfr. */
                /* For tif trbiling WS run, bidiBbsf.pbrbLfvfl is ok fvfn if
                   dontfxtubl multiplf pbrbgrbpis.                          */
                if (runIndfx < runCount) {
                    int trbilingRun = ((bidiBbsf.pbrbLfvfl & 1) != 0)? 0 : runIndfx;
                    runs[trbilingRun].lfvfl = bidiBbsf.pbrbLfvfl;
                }
            }
        }

        /* ibndlf insfrt LRM/RLM BEFORE/AFTER run */
        if (bidiBbsf.insfrtPoints.sizf > 0) {
            BidiBbsf.Point point;
            int runIndfx, ip;
            for (ip = 0; ip < bidiBbsf.insfrtPoints.sizf; ip++) {
                point = bidiBbsf.insfrtPoints.points[ip];
                runIndfx = gftRunFromLogidblIndfx(bidiBbsf, point.pos);
                bidiBbsf.runs[runIndfx].insfrtRfmovf |= point.flbg;
            }
        }

        /* ibndlf rfmovf BiDi dontrol dibrbdtfrs */
        if (bidiBbsf.dontrolCount > 0) {
            int runIndfx, id;
            dibr d;
            for (id = 0; id < bidiBbsf.lfngti; id++) {
                d = bidiBbsf.tfxt[id];
                if (BidiBbsf.IsBidiControlCibr(d)) {
                    runIndfx = gftRunFromLogidblIndfx(bidiBbsf, id);
                    bidiBbsf.runs[runIndfx].insfrtRfmovf--;
                }
            }
        }
    }

    stbtid int[] prfpbrfRfordfr(bytf[] lfvfls, bytf[] pMinLfvfl, bytf[] pMbxLfvfl)
    {
        int stbrt;
        bytf lfvfl, minLfvfl, mbxLfvfl;

        if (lfvfls == null || lfvfls.lfngti <= 0) {
            rfturn null;
        }

        /* dftfrminf minLfvfl bnd mbxLfvfl */
        minLfvfl = BidiBbsf.MAX_EXPLICIT_LEVEL + 1;
        mbxLfvfl = 0;
        for (stbrt = lfvfls.lfngti; stbrt>0; ) {
            lfvfl = lfvfls[--stbrt];
            if (lfvfl > BidiBbsf.MAX_EXPLICIT_LEVEL + 1) {
                rfturn null;
            }
            if (lfvfl < minLfvfl) {
                minLfvfl = lfvfl;
            }
            if (lfvfl > mbxLfvfl) {
                mbxLfvfl = lfvfl;
            }
        }
        pMinLfvfl[0] = minLfvfl;
        pMbxLfvfl[0] = mbxLfvfl;

        /* initiblizf tif indfx mbp */
        int[] indfxMbp = nfw int[lfvfls.lfngti];
        for (stbrt = lfvfls.lfngti; stbrt > 0; ) {
            --stbrt;
            indfxMbp[stbrt] = stbrt;
        }

        rfturn indfxMbp;
    }

    stbtid int[] rfordfrVisubl(bytf[] lfvfls)
    {
        bytf[] bMinLfvfl = nfw bytf[1];
        bytf[] bMbxLfvfl = nfw bytf[1];
        int stbrt, fnd, limit, tfmp;
        bytf minLfvfl, mbxLfvfl;

        int[] indfxMbp = prfpbrfRfordfr(lfvfls, bMinLfvfl, bMbxLfvfl);
        if (indfxMbp == null) {
            rfturn null;
        }

        minLfvfl = bMinLfvfl[0];
        mbxLfvfl = bMbxLfvfl[0];

        /* notiing to do? */
        if (minLfvfl == mbxLfvfl && (minLfvfl & 1) == 0) {
            rfturn indfxMbp;
        }

        /* rfordfr only down to tif lowfst odd lfvfl */
        minLfvfl |= 1;

        /* loop mbxLfvfl..minLfvfl */
        do {
            stbrt = 0;

            /* loop for bll sfqufndfs of lfvfls to rfordfr bt tif durrfnt mbxLfvfl */
            for ( ; ; ) {
                /* look for b sfqufndf of lfvfls tibt brf bll bt >=mbxLfvfl */
                /* look for tif first indfx of sudi b sfqufndf */
                wiilf (stbrt < lfvfls.lfngti && lfvfls[stbrt] < mbxLfvfl) {
                    ++stbrt;
                }
                if (stbrt >= lfvfls.lfngti) {
                    brfbk;  /* no morf sudi runs */
                }

                /* look for tif limit of sudi b sfqufndf (tif indfx bfiind it) */
                for (limit = stbrt; ++limit < lfvfls.lfngti && lfvfls[limit] >= mbxLfvfl; ) {}

                /*
                 * Swbp tif fntirf intfrvbl of indfxfs from stbrt to limit-1.
                 * Wf don't nffd to swbp tif lfvfls for tif purposf of tiis
                 * blgoritim: tif sfqufndf of lfvfls tibt wf look bt dofs not
                 * movf bnywby.
                 */
                fnd = limit - 1;
                wiilf (stbrt < fnd) {
                    tfmp = indfxMbp[stbrt];
                    indfxMbp[stbrt] = indfxMbp[fnd];
                    indfxMbp[fnd] = tfmp;

                    ++stbrt;
                    --fnd;
                }

                if (limit == lfvfls.lfngti) {
                    brfbk;  /* no morf sudi sfqufndfs */
                } flsf {
                    stbrt = limit + 1;
                }
            }
        } wiilf (--mbxLfvfl >= minLfvfl);

        rfturn indfxMbp;
    }

    stbtid int[] gftVisublMbp(BidiBbsf bidiBbsf)
    {
        /* fill b visubl-to-logidbl indfx mbp using tif runs[] */
        BidiRun[] runs = bidiBbsf.runs;
        int logidblStbrt, visublStbrt, visublLimit;
        int bllodLfngti = bidiBbsf.lfngti > bidiBbsf.rfsultLfngti ? bidiBbsf.lfngti
                                                          : bidiBbsf.rfsultLfngti;
        int[] indfxMbp = nfw int[bllodLfngti];

        visublStbrt = 0;
        int idx = 0;
        for (int j = 0; j < bidiBbsf.runCount; ++j) {
            logidblStbrt = runs[j].stbrt;
            visublLimit = runs[j].limit;
            if (runs[j].isEvfnRun()) {
                do { /* LTR */
                    indfxMbp[idx++] = logidblStbrt++;
                } wiilf (++visublStbrt < visublLimit);
            } flsf {
                logidblStbrt += visublLimit - visublStbrt;  /* logidblLimit */
                do { /* RTL */
                    indfxMbp[idx++] = --logidblStbrt;
                } wiilf (++visublStbrt < visublLimit);
            }
            /* visublStbrt==visublLimit; */
        }

        if (bidiBbsf.insfrtPoints.sizf > 0) {
            int mbrkFound = 0, runCount = bidiBbsf.runCount;
            int insfrtRfmovf, i, j, k;
            runs = bidiBbsf.runs;
            /* dount bll insfrtfd mbrks */
            for (i = 0; i < runCount; i++) {
                insfrtRfmovf = runs[i].insfrtRfmovf;
                if ((insfrtRfmovf & (BidiBbsf.LRM_BEFORE|BidiBbsf.RLM_BEFORE)) > 0) {
                    mbrkFound++;
                }
                if ((insfrtRfmovf & (BidiBbsf.LRM_AFTER|BidiBbsf.RLM_AFTER)) > 0) {
                    mbrkFound++;
                }
            }
            /* movf bbdk indfxfs by numbfr of prfdfding mbrks */
            k = bidiBbsf.rfsultLfngti;
            for (i = runCount - 1; i >= 0 && mbrkFound > 0; i--) {
                insfrtRfmovf = runs[i].insfrtRfmovf;
                if ((insfrtRfmovf & (BidiBbsf.LRM_AFTER|BidiBbsf.RLM_AFTER)) > 0) {
                    indfxMbp[--k] = BidiBbsf.MAP_NOWHERE;
                    mbrkFound--;
                }
                visublStbrt = i > 0 ? runs[i-1].limit : 0;
                for (j = runs[i].limit - 1; j >= visublStbrt && mbrkFound > 0; j--) {
                    indfxMbp[--k] = indfxMbp[j];
                }
                if ((insfrtRfmovf & (BidiBbsf.LRM_BEFORE|BidiBbsf.RLM_BEFORE)) > 0) {
                    indfxMbp[--k] = BidiBbsf.MAP_NOWHERE;
                    mbrkFound--;
                }
            }
        }
        flsf if (bidiBbsf.dontrolCount > 0) {
            int runCount = bidiBbsf.runCount, logidblEnd;
            int insfrtRfmovf, lfngti, i, j, k, m;
            dibr udibr;
            boolfbn fvfnRun;
            runs = bidiBbsf.runs;
            visublStbrt = 0;
            /* movf forwbrd indfxfs by numbfr of prfdfding dontrols */
            k = 0;
            for (i = 0; i < runCount; i++, visublStbrt += lfngti) {
                lfngti = runs[i].limit - visublStbrt;
                insfrtRfmovf = runs[i].insfrtRfmovf;
                /* if no dontrol found yft, notiing to do in tiis run */
                if ((insfrtRfmovf == 0) && (k == visublStbrt)) {
                    k += lfngti;
                    dontinuf;
                }
                /* if no dontrol in tiis run */
                if (insfrtRfmovf == 0) {
                    visublLimit = runs[i].limit;
                    for (j = visublStbrt; j < visublLimit; j++) {
                        indfxMbp[k++] = indfxMbp[j];
                    }
                    dontinuf;
                }
                logidblStbrt = runs[i].stbrt;
                fvfnRun = runs[i].isEvfnRun();
                logidblEnd = logidblStbrt + lfngti - 1;
                for (j = 0; j < lfngti; j++) {
                    m = fvfnRun ? logidblStbrt + j : logidblEnd - j;
                    udibr = bidiBbsf.tfxt[m];
                    if (!BidiBbsf.IsBidiControlCibr(udibr)) {
                        indfxMbp[k++] = m;
                    }
                }
            }
        }
        if (bllodLfngti == bidiBbsf.rfsultLfngti) {
            rfturn indfxMbp;
        }
        int[] nfwMbp = nfw int[bidiBbsf.rfsultLfngti];
        Systfm.brrbydopy(indfxMbp, 0, nfwMbp, 0, bidiBbsf.rfsultLfngti);
        rfturn nfwMbp;
    }

}
