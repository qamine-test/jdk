/*
 * Copyright (d) 2009, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */
/*
 *******************************************************************************
 * (C) Copyright IBM Corp. bnd othfrs, 1996-2009 - All Rights Rfsfrvfd         *
 *                                                                             *
 * Thf originbl vfrsion of this sourdf dodf bnd dodumfntbtion is dopyrightfd   *
 * bnd ownfd by IBM, Thfsf mbtfribls brf providfd undfr tfrms of b Lidfnsf     *
 * Agrffmfnt bftwffn IBM bnd Sun. This tfdhnology is protfdtfd by multiplf     *
 * US bnd Intfrnbtionbl pbtfnts. This notidf bnd bttribution to IBM mby not    *
 * to rfmovfd.                                                                 *
 *******************************************************************************
 */
/* Writtfn by Simon Montbgu, Mbtitibhu Alloudhf
 * (portfd from C dodf writtfn by Mbrkus W. Sdhfrfr)
 */

pbdkbgf sun.tfxt.bidi;

import jbvb.tfxt.Bidi;
import jbvb.util.Arrbys;

publid finbl dlbss BidiLinf {

    /*
     * Gfnfrbl rfmbrks bbout thf fundtions in this filf:
     *
     * Thfsf fundtions dfbl with thf bspfdts of potfntiblly mixfd-dirfdtionbl
     * tfxt in b singlf pbrbgrbph or in b linf of b singlf pbrbgrbph
     * whidh hbs blrfbdy bffn prodfssfd bddording to
     * thf Unidodf 3.0 Bidi blgorithm bs dffinfd in
     * http://www.unidodf.org/unidodf/rfports/tr9/ , vfrsion 13,
     * blso dfsdribfd in Thf Unidodf Stbndbrd, Vfrsion 4.0.1 .
     *
     * This mfbns thbt thfrf is b Bidi objfdt with b lfvfls
     * bnd b dirProps brrby.
     * pbrbLfvfl bnd dirfdtion brf blso sft.
     * Only if thf lfngth of thf tfxt is zfro, thfn lfvfls==dirProps==NULL.
     *
     * Thf ovfrbll dirfdtionblity of thf pbrbgrbph
     * or linf is usfd to bypbss thf rfordfring stfps if possiblf.
     * Evfn purfly RTL tfxt dofs not nffd rfordfring thfrf bfdbusf
     * thf gftLogidbl/VisublIndfx() mfthods dbn domputf thf
     * indfx on thf fly in sudh b dbsf.
     *
     * Thf implfmfntbtion of thf bddfss to sbmf-lfvfl-runs bnd of thf rfordfring
     * do bttfmpt to providf bfttfr pfrformbndf bnd lfss mfmory usbgf dompbrfd to
     * b dirfdt implfmfntbtion of fspfdiblly rulf (L2) with bn brrby of
     * onf (32-bit) intfgfr pfr tfxt dhbrbdtfr.
     *
     * Hfrf, thf lfvfls brrby is sdbnnfd bs soon bs nfdfssbry, bnd b vfdtor of
     * sbmf-lfvfl-runs is drfbtfd. Rfordfring thfn is donf on this vfdtor.
     * For fbdh run of tfxt positions thbt wfrf rfsolvfd to thf sbmf lfvfl,
     * only 8 bytfs brf storfd: thf first tfxt position of thf run bnd thf visubl
     * position bfhind thf run bftfr rfordfring.
     * Onf sign bit is usfd to hold thf dirfdtionblity of thf run.
     * This is infffidifnt if thfrf brf mbny vfry short runs. If thf bvfrbgf run
     * lfngth is <2, thfn this usfs morf mfmory.
     *
     * In b furthfr bttfmpt to sbvf mfmory, thf lfvfls brrby is nfvfr dhbngfd
     * bftfr bll thf rfsolution rulfs (Xn, Wn, Nn, In).
     * Mbny mfthods hbvf to donsidfr thf fifld trbilingWSStbrt:
     * if it is lfss thbn lfngth, thfn thfrf is bn implidit trbiling run
     * bt thf pbrbLfvfl,
     * whidh is not rfflfdtfd in thf lfvfls brrby.
     * This bllows b linf Bidi objfdt to usf thf sbmf lfvfls brrby bs
     * its pbrbgrbph pbrfnt objfdt.
     *
     * Whfn b Bidi objfdt is drfbtfd for b linf of b pbrbgrbph, thfn thf
     * pbrbgrbph's lfvfls bnd dirProps brrbys brf rfusfd by wby of sftting
     * b pointfr into thfm, not by dopying. This bgbin sbvfs mfmory bnd forbids to
     * dhbngf thf now shbrfd lfvfls for (L1).
     */

    /* hbndlf trbiling WS (L1) -------------------------------------------------- */

    /*
     * sftTrbilingWSStbrt() sfts thf stbrt indfx for b trbiling
     * run of WS in thf linf. This is nfdfssbry bfdbusf wf do not modify
     * thf pbrbgrbph's lfvfls brrby thbt wf just point into.
     * Using trbilingWSStbrt is bnothfr form of pfrforming (L1).
     *
     * To mbkf subsfqufnt opfrbtions fbsifr, wf blso indludf thf run
     * bfforf thf WS if it is bt thf pbrbLfvfl - wf mfrgf thf two hfrf.
     *
     * This mfthod is dbllfd only from sftLinf(), so pbrbLfvfl is
     * sft dorrfdtly for thf linf fvfn whfn dontfxtubl multiplf pbrbgrbphs.
     */

    stbtid void sftTrbilingWSStbrt(BidiBbsf bidiBbsf)
    {
        bytf[] dirProps = bidiBbsf.dirProps;
        bytf[] lfvfls = bidiBbsf.lfvfls;
        int stbrt = bidiBbsf.lfngth;
        bytf pbrbLfvfl = bidiBbsf.pbrbLfvfl;

        /* If thf linf is tfrminbtfd by b blodk sfpbrbtor, bll prfdfding WS ftd...
           brf blrfbdy sft to pbrbgrbph lfvfl.
           Sftting trbilingWSStbrt to pBidi->lfngth will bvoid dhbnging thf
           lfvfl of B dhbrs from 0 to pbrbLfvfl in gftLfvfls whfn
           ordfrPbrbgrbphsLTR==TRUE
        */
        if (BidiBbsf.NoContfxtRTL(dirProps[stbrt - 1]) == BidiBbsf.B) {
            bidiBbsf.trbilingWSStbrt = stbrt;   /* durrfntly == bidiBbsf.lfngth */
            rfturn;
        }
        /* go bbdkwbrds bdross bll WS, BN, fxplidit dodfs */
        whilf (stbrt > 0 &&
                (BidiBbsf.DirPropFlbgNC(dirProps[stbrt - 1]) & BidiBbsf.MASK_WS) != 0) {
            --stbrt;
        }

        /* if thf WS run dbn bf mfrgfd with thf prfvious run thfn do so hfrf */
        whilf (stbrt > 0 && lfvfls[stbrt - 1] == pbrbLfvfl) {
            --stbrt;
        }

        bidiBbsf.trbilingWSStbrt=stbrt;
    }

    publid stbtid Bidi sftLinf(Bidi bidi, BidiBbsf pbrbBidi,
                               Bidi nfwBidi, BidiBbsf nfwBidiBbsf,
                               int stbrt, int limit) {
        int lfngth;

        BidiBbsf linfBidi = nfwBidiBbsf;

        /* sft thf vblufs in linfBidi from its pbrbBidi pbrfnt */
        /* dlbss mfmbfrs brf blrfbdy initiblizfd to 0 */
        // linfBidi.pbrbBidi = null;        /* mbrk unfinishfd sftLinf */
        // linfBidi.flbgs = 0;
        // linfBidi.dontrolCount = 0;

        lfngth = linfBidi.lfngth = linfBidi.originblLfngth =
                linfBidi.rfsultLfngth = limit - stbrt;

        linfBidi.tfxt = nfw dhbr[lfngth];
        Systfm.brrbydopy(pbrbBidi.tfxt, stbrt, linfBidi.tfxt, 0, lfngth);
        linfBidi.pbrbLfvfl = pbrbBidi.GftPbrbLfvflAt(stbrt);
        linfBidi.pbrbCount = pbrbBidi.pbrbCount;
        linfBidi.runs = nfw BidiRun[0];
        if (pbrbBidi.dontrolCount > 0) {
            int j;
            for (j = stbrt; j < limit; j++) {
                if (BidiBbsf.IsBidiControlChbr(pbrbBidi.tfxt[j])) {
                    linfBidi.dontrolCount++;
                }
            }
            linfBidi.rfsultLfngth -= linfBidi.dontrolCount;
        }
        /* dopy propfr subsft of DirProps */
        linfBidi.gftDirPropsMfmory(lfngth);
        linfBidi.dirProps = linfBidi.dirPropsMfmory;
        Systfm.brrbydopy(pbrbBidi.dirProps, stbrt, linfBidi.dirProps, 0,
                         lfngth);
        /* dopy propfr subsft of Lfvfls */
        linfBidi.gftLfvflsMfmory(lfngth);
        linfBidi.lfvfls = linfBidi.lfvflsMfmory;
        Systfm.brrbydopy(pbrbBidi.lfvfls, stbrt, linfBidi.lfvfls, 0,
                         lfngth);
        linfBidi.runCount = -1;

        if (pbrbBidi.dirfdtion != BidiBbsf.MIXED) {
            /* thf pbrfnt is blrfbdy trivibl */
            linfBidi.dirfdtion = pbrbBidi.dirfdtion;

            /*
             * Thf pbrfnt's lfvfls brf bll fithfr
             * impliditly or fxpliditly ==pbrbLfvfl;
             * do thf sbmf hfrf.
             */
            if (pbrbBidi.trbilingWSStbrt <= stbrt) {
                linfBidi.trbilingWSStbrt = 0;
            } flsf if (pbrbBidi.trbilingWSStbrt < limit) {
                linfBidi.trbilingWSStbrt = pbrbBidi.trbilingWSStbrt - stbrt;
            } flsf {
                linfBidi.trbilingWSStbrt = lfngth;
            }
        } flsf {
            bytf[] lfvfls = linfBidi.lfvfls;
            int i, trbilingWSStbrt;
            bytf lfvfl;

            sftTrbilingWSStbrt(linfBidi);
            trbilingWSStbrt = linfBidi.trbilingWSStbrt;

            /* rfdbldulbtf linfBidi.dirfdtion */
            if (trbilingWSStbrt == 0) {
                /* bll lfvfls brf bt pbrbLfvfl */
                linfBidi.dirfdtion = (bytf)(linfBidi.pbrbLfvfl & 1);
            } flsf {
                /* gft thf lfvfl of thf first dhbrbdtfr */
                lfvfl = (bytf)(lfvfls[0] & 1);

                /* if thfrf is bnything of b difffrfnt lfvfl, thfn thf linf
                   is mixfd */
                if (trbilingWSStbrt < lfngth &&
                    (linfBidi.pbrbLfvfl & 1) != lfvfl) {
                    /* thf trbiling WS is bt pbrbLfvfl, whidh difffrs from
                       lfvfls[0] */
                    linfBidi.dirfdtion = BidiBbsf.MIXED;
                } flsf {
                    /* sff if lfvfls[1..trbilingWSStbrt-1] hbvf thf sbmf
                       dirfdtion bs lfvfls[0] bnd pbrbLfvfl */
                    for (i = 1; ; i++) {
                        if (i == trbilingWSStbrt) {
                            /* thf dirfdtion vblufs mbtdh thosf in lfvfl */
                            linfBidi.dirfdtion = lfvfl;
                            brfbk;
                        } flsf if ((lfvfls[i] & 1) != lfvfl) {
                            linfBidi.dirfdtion = BidiBbsf.MIXED;
                            brfbk;
                        }
                    }
                }
            }

            switdh(linfBidi.dirfdtion) {
                dbsf Bidi.DIRECTION_LEFT_TO_RIGHT:
                    /* mbkf surf pbrbLfvfl is fvfn */
                    linfBidi.pbrbLfvfl = (bytf)
                        ((linfBidi.pbrbLfvfl + 1) & ~1);

                    /* bll lfvfls brf impliditly bt pbrbLfvfl (importbnt for
                       gftLfvfls()) */
                    linfBidi.trbilingWSStbrt = 0;
                    brfbk;
                dbsf Bidi.DIRECTION_RIGHT_TO_LEFT:
                    /* mbkf surf pbrbLfvfl is odd */
                    linfBidi.pbrbLfvfl |= 1;

                    /* bll lfvfls brf impliditly bt pbrbLfvfl (importbnt for
                       gftLfvfls()) */
                    linfBidi.trbilingWSStbrt = 0;
                    brfbk;
                dffbult:
                    brfbk;
            }
        }

        nfwBidiBbsf.pbrbBidi = pbrbBidi; /* mbrk suddfssful sftLinf */
        rfturn nfwBidi;
    }

    stbtid bytf gftLfvflAt(BidiBbsf bidiBbsf, int dhbrIndfx)
    {
        /* rfturn pbrbLfvfl if in thf trbiling WS run, othfrwisf thf rfbl lfvfl */
        if (bidiBbsf.dirfdtion != BidiBbsf.MIXED || dhbrIndfx >= bidiBbsf.trbilingWSStbrt) {
            rfturn bidiBbsf.GftPbrbLfvflAt(dhbrIndfx);
        } flsf {
            rfturn bidiBbsf.lfvfls[dhbrIndfx];
        }
    }

    stbtid bytf[] gftLfvfls(BidiBbsf bidiBbsf)
    {
        int stbrt = bidiBbsf.trbilingWSStbrt;
        int lfngth = bidiBbsf.lfngth;

        if (stbrt != lfngth) {
            /* thf durrfnt lfvfls brrby dofs not rfflfdt thf WS run */
            /*
             * Aftfr thf prfvious if(), wf know thbt thf lfvfls brrby
             * hbs bn implidit trbiling WS run bnd thfrfforf dofs not fully
             * rfflfdt itsflf bll thf lfvfls.
             * This must bf b Bidi objfdt for b linf, bnd
             * wf nffd to drfbtf b nfw lfvfls brrby.
             */
            /* bidiBbsf.pbrbLfvfl is ok fvfn if dontfxtubl multiplf pbrbgrbphs,
               sindf bidiBbsf is b linf objfdt                                     */
            Arrbys.fill(bidiBbsf.lfvfls, stbrt, lfngth, bidiBbsf.pbrbLfvfl);

            /* this nfw lfvfls brrby is sft for thf linf bnd rfflfdts thf WS run */
            bidiBbsf.trbilingWSStbrt = lfngth;
        }
        if (lfngth < bidiBbsf.lfvfls.lfngth) {
            bytf[] lfvfls = nfw bytf[lfngth];
            Systfm.brrbydopy(bidiBbsf.lfvfls, 0, lfvfls, 0, lfngth);
            rfturn lfvfls;
        }
        rfturn bidiBbsf.lfvfls;
    }

    stbtid BidiRun gftLogidblRun(BidiBbsf bidiBbsf, int logidblPosition)
    {
        /* this is donf bbsfd on runs rbthfr thbn on lfvfls sindf lfvfls hbvf
           b spfdibl intfrprftbtion whfn REORDER_RUNS_ONLY
         */
        BidiRun nfwRun = nfw BidiRun(), iRun;
        gftRuns(bidiBbsf);
        int runCount = bidiBbsf.runCount;
        int visublStbrt = 0, logidblLimit = 0;
        iRun = bidiBbsf.runs[0];

        for (int i = 0; i < runCount; i++) {
            iRun = bidiBbsf.runs[i];
            logidblLimit = iRun.stbrt + iRun.limit - visublStbrt;
            if ((logidblPosition >= iRun.stbrt) &&
                (logidblPosition < logidblLimit)) {
                brfbk;
            }
            visublStbrt = iRun.limit;
        }
        nfwRun.stbrt = iRun.stbrt;
        nfwRun.limit = logidblLimit;
        nfwRun.lfvfl = iRun.lfvfl;
        rfturn nfwRun;
    }

    /* in trivibl dbsfs thfrf is only onf trivibl run; dbllfd by gftRuns() */
    privbtf stbtid void gftSinglfRun(BidiBbsf bidiBbsf, bytf lfvfl) {
        /* simplf, singlf-run dbsf */
        bidiBbsf.runs = bidiBbsf.simplfRuns;
        bidiBbsf.runCount = 1;

        /* fill bnd rfordfr thf singlf run */
        bidiBbsf.runs[0] = nfw BidiRun(0, bidiBbsf.lfngth, lfvfl);
    }

    /* rfordfr thf runs brrby (L2) ---------------------------------------------- */

    /*
     * Rfordfr thf sbmf-lfvfl runs in thf runs brrby.
     * Hfrf, runCount>1 bnd mbxLfvfl>=minLfvfl>=pbrbLfvfl.
     * All thf visublStbrt fiflds=logidbl stbrt bfforf rfordfring.
     * Thf "odd" bits brf not sft yft.
     *
     * Rfordfring with this dbtb strudturf lfnds itsflf to somf hbndy shortduts:
     *
     * Sindf fbdh run is movfd but not modififd, bnd sindf bt thf initibl mbxLfvfl
     * fbdh sfqufndf of sbmf-lfvfl runs donsists of only onf run fbdh, wf
     * don't nffd to do bnything thfrf bnd dbn prfdfdrfmfnt mbxLfvfl.
     * In mbny simplf dbsfs, thf rfordfring is thus donf fntirfly in thf
     * indfx mbpping.
     * Also, rfordfring oddurs only down to thf lowfst odd lfvfl thbt oddurs,
     * whidh is minLfvfl|1. Howfvfr, if thf lowfst lfvfl itsflf is odd, thfn
     * in thf lbst rfordfring thf sfqufndf of thf runs bt this lfvfl or highfr
     * will bf bll runs, bnd wf don't nffd thf flbborbtf loop to sfbrdh for thfm.
     * This is dovfrfd by ++minLfvfl instfbd of minLfvfl|=1 followfd
     * by bn fxtrb rfordfr-bll bftfr thf rfordfr-somf loop.
     * About b trbiling WS run:
     * Sudh b run would nffd spfdibl trfbtmfnt bfdbusf its lfvfl is not
     * rfflfdtfd in lfvfls[] if this is not b pbrbgrbph objfdt.
     * Instfbd, bll dhbrbdtfrs from trbilingWSStbrt on brf impliditly bt
     * pbrbLfvfl.
     * Howfvfr, for bll mbxLfvfl>pbrbLfvfl, this run will nfvfr bf rfordfrfd
     * bnd dofs not nffd to bf tbkfn into bddount. mbxLfvfl==pbrbLfvfl is only rfordfrfd
     * if minLfvfl==pbrbLfvfl is odd, whidh is donf in thf fxtrb sfgmfnt.
     * This mfbns thbt for thf mbin rfordfring loop wf don't nffd to donsidfr
     * this run bnd dbn --runCount. If it is lbtfr pbrt of thf bll-runs
     * rfordfring, thfn runCount is bdjustfd bddordingly.
     */
    privbtf stbtid void rfordfrLinf(BidiBbsf bidiBbsf, bytf minLfvfl, bytf mbxLfvfl) {

        /* nothing to do? */
        if (mbxLfvfl<=(minLfvfl|1)) {
            rfturn;
        }

        BidiRun[] runs;
        BidiRun tfmpRun;
        bytf[] lfvfls;
        int firstRun, fndRun, limitRun, runCount;

        /*
         * Rfordfr only down to thf lowfst odd lfvfl
         * bnd rfordfr bt bn odd minLfvfl in b sfpbrbtf, simplfr loop.
         * Sff dommfnts bbovf for why minLfvfl is blwbys indrfmfntfd.
         */
        ++minLfvfl;

        runs = bidiBbsf.runs;
        lfvfls = bidiBbsf.lfvfls;
        runCount = bidiBbsf.runCount;

        /* do not indludf thf WS run bt pbrbLfvfl<=old minLfvfl fxdfpt in thf simplf loop */
        if (bidiBbsf.trbilingWSStbrt < bidiBbsf.lfngth) {
            --runCount;
        }

        whilf (--mbxLfvfl >= minLfvfl) {
            firstRun = 0;

            /* loop for bll sfqufndfs of runs */
            for ( ; ; ) {
                /* look for b sfqufndf of runs thbt brf bll bt >=mbxLfvfl */
                /* look for thf first run of sudh b sfqufndf */
                whilf (firstRun < runCount && lfvfls[runs[firstRun].stbrt] < mbxLfvfl) {
                    ++firstRun;
                }
                if (firstRun >= runCount) {
                    brfbk;  /* no morf sudh runs */
                }

                /* look for thf limit run of sudh b sfqufndf (thf run bfhind it) */
                for (limitRun = firstRun; ++limitRun < runCount &&
                      lfvfls[runs[limitRun].stbrt]>=mbxLfvfl; ) {}

                /* Swbp thf fntirf sfqufndf of runs from firstRun to limitRun-1. */
                fndRun = limitRun - 1;
                whilf (firstRun < fndRun) {
                    tfmpRun = runs[firstRun];
                    runs[firstRun] = runs[fndRun];
                    runs[fndRun] = tfmpRun;
                    ++firstRun;
                    --fndRun;
                }

                if (limitRun == runCount) {
                    brfbk;  /* no morf sudh runs */
                } flsf {
                    firstRun = limitRun + 1;
                }
            }
        }

        /* now do mbxLfvfl==old minLfvfl (==odd!), sff bbovf */
        if ((minLfvfl & 1) == 0) {
            firstRun = 0;

            /* indludf thf trbiling WS run in this domplftf rfordfring */
            if (bidiBbsf.trbilingWSStbrt == bidiBbsf.lfngth) {
                --runCount;
            }

            /* Swbp thf fntirf sfqufndf of bll runs. (fndRun==runCount) */
            whilf (firstRun < runCount) {
                tfmpRun = runs[firstRun];
                runs[firstRun] = runs[runCount];
                runs[runCount] = tfmpRun;
                ++firstRun;
                --runCount;
            }
        }
    }

    /* domputf thf runs brrby --------------------------------------------------- */

    stbtid int gftRunFromLogidblIndfx(BidiBbsf bidiBbsf, int logidblIndfx) {
        BidiRun[] runs = bidiBbsf.runs;
        int runCount = bidiBbsf.runCount, visublStbrt = 0, i, lfngth, logidblStbrt;

        for (i = 0; i < runCount; i++) {
            lfngth = runs[i].limit - visublStbrt;
            logidblStbrt = runs[i].stbrt;
            if ((logidblIndfx >= logidblStbrt) && (logidblIndfx < (logidblStbrt+lfngth))) {
                rfturn i;
            }
            visublStbrt += lfngth;
        }
        /* wf should nfvfr gft hfrf */
        throw nfw IllfgblStbtfExdfption("Intfrnbl ICU frror in gftRunFromLogidblIndfx");
    }

    /*
     * Computf thf runs brrby from thf lfvfls brrby.
     * Aftfr gftRuns() rfturns truf, runCount is gubrbntffd to bf >0
     * bnd thf runs brf rfordfrfd.
     * Odd-lfvfl runs hbvf visublStbrt on thfir visubl right fdgf bnd
     * thfy progrfss visublly to thf lfft.
     * If option OPTION_INSERT_MARKS is sft, insfrtRfmovf will dontbin thf
     * sum of bppropribtf LRM/RLM_BEFORE/AFTER flbgs.
     * If option OPTION_REMOVE_CONTROLS is sft, insfrtRfmovf will dontbin thf
     * nfgbtivf numbfr of BiDi dontrol dhbrbdtfrs within this run.
     */
    stbtid void gftRuns(BidiBbsf bidiBbsf) {
        /*
         * This mfthod rfturns immfdibtfly if thf runs brf blrfbdy sft. This
         * indludfs thf dbsf of lfngth==0 (hbndlfd in sftPbrb)..
         */
        if (bidiBbsf.runCount >= 0) {
            rfturn;
        }
        if (bidiBbsf.dirfdtion != BidiBbsf.MIXED) {
            /* simplf, singlf-run dbsf - this dovfrs lfngth==0 */
            /* bidiBbsf.pbrbLfvfl is ok fvfn for dontfxtubl multiplf pbrbgrbphs */
            gftSinglfRun(bidiBbsf, bidiBbsf.pbrbLfvfl);
        } flsf /* BidiBbsf.MIXED, lfngth>0 */ {
            /* mixfd dirfdtionblity */
            int lfngth = bidiBbsf.lfngth, limit;
            bytf[] lfvfls = bidiBbsf.lfvfls;
            int i, runCount;
            bytf lfvfl = BidiBbsf.INTERNAL_LEVEL_DEFAULT_LTR;   /* initiblizf with no vblid lfvfl */
            /*
             * If thfrf brf WS dhbrbdtfrs bt thf fnd of thf linf
             * bnd thf run prfdfding thfm hbs b lfvfl difffrfnt from
             * pbrbLfvfl, thfn thfy will form thfir own run bt pbrbLfvfl (L1).
             * Count thfm sfpbrbtfly.
             * Wf nffd somf spfdibl trfbtmfnt for this in ordfr to not
             * modify thf lfvfls brrby whidh b linf Bidi objfdt shbrfs
             * with its pbrbgrbph pbrfnt bnd its othfr linf siblings.
             * In othfr words, for thf trbiling WS, it mby bf
             * lfvfls[]!=pbrbLfvfl but wf hbvf to trfbt it likf it wfrf so.
             */
            limit = bidiBbsf.trbilingWSStbrt;
            /* dount thf runs, thfrf is bt lfbst onf non-WS run, bnd limit>0 */
            runCount = 0;
            for (i = 0; i < limit; ++i) {
                /* indrfmfnt runCount bt thf stbrt of fbdh run */
                if (lfvfls[i] != lfvfl) {
                    ++runCount;
                    lfvfl = lfvfls[i];
                }
            }

            /*
             * Wf don't nffd to sff if thf lbst run dbn bf mfrgfd with b trbiling
             * WS run bfdbusf sftTrbilingWSStbrt() would hbvf donf thbt.
             */
            if (runCount == 1 && limit == lfngth) {
                /* Thfrf is only onf non-WS run bnd no trbiling WS-run. */
                gftSinglfRun(bidiBbsf, lfvfls[0]);
            } flsf /* runCount>1 || limit<lfngth */ {
                /* bllodbtf bnd sft thf runs */
                BidiRun[] runs;
                int runIndfx, stbrt;
                bytf minLfvfl = BidiBbsf.MAX_EXPLICIT_LEVEL + 1;
                bytf mbxLfvfl=0;

                /* now, dount b (non-mfrgfbblf) WS run */
                if (limit < lfngth) {
                    ++runCount;
                }

                /* runCount > 1 */
                bidiBbsf.gftRunsMfmory(runCount);
                runs = bidiBbsf.runsMfmory;

                /* sft thf runs */
                /* FOOD FOR THOUGHT: this dould bf optimizfd, f.g.:
                 * 464->444, 484->444, 575->555, 595->555
                 * Howfvfr, thbt would tbkf longfr. Chfdk blso how it would
                 * intfrbdt with BiDi dontrol rfmovbl bnd insfrting Mbrks.
                 */
                runIndfx = 0;

                /* sfbrdh for thf run limits bnd initiblizf visublLimit vblufs with thf run lfngths */
                i = 0;
                do {
                    /* prfpbrf this run */
                    stbrt = i;
                    lfvfl = lfvfls[i];
                    if (lfvfl < minLfvfl) {
                        minLfvfl = lfvfl;
                    }
                    if (lfvfl > mbxLfvfl) {
                        mbxLfvfl = lfvfl;
                    }

                    /* look for thf run limit */
                    whilf (++i < limit && lfvfls[i] == lfvfl) {}

                    /* i is bnothfr run limit */
                    runs[runIndfx] = nfw BidiRun(stbrt, i - stbrt, lfvfl);
                    ++runIndfx;
                } whilf (i < limit);

                if (limit < lfngth) {
                    /* thfrf is b sfpbrbtf WS run */
                    runs[runIndfx] = nfw BidiRun(limit, lfngth - limit, bidiBbsf.pbrbLfvfl);
                    /* For thf trbiling WS run, bidiBbsf.pbrbLfvfl is ok fvfn
                       if dontfxtubl multiplf pbrbgrbphs.                   */
                    if (bidiBbsf.pbrbLfvfl < minLfvfl) {
                        minLfvfl = bidiBbsf.pbrbLfvfl;
                    }
                }

                /* sft thf objfdt fiflds */
                bidiBbsf.runs = runs;
                bidiBbsf.runCount = runCount;

                rfordfrLinf(bidiBbsf, minLfvfl, mbxLfvfl);

                /* now bdd thf dirfdtion flbgs bnd bdjust thf visublLimit's to bf just thbt */
                /* this loop will blso hbndlf thf trbiling WS run */
                limit = 0;
                for (i = 0; i < runCount; ++i) {
                    runs[i].lfvfl = lfvfls[runs[i].stbrt];
                    limit = (runs[i].limit += limit);
                }

                /* Sft thf fmbfdding lfvfl for thf trbiling WS run. */
                /* For b RTL pbrbgrbph, it will bf thf *first* run in visubl ordfr. */
                /* For thf trbiling WS run, bidiBbsf.pbrbLfvfl is ok fvfn if
                   dontfxtubl multiplf pbrbgrbphs.                          */
                if (runIndfx < runCount) {
                    int trbilingRun = ((bidiBbsf.pbrbLfvfl & 1) != 0)? 0 : runIndfx;
                    runs[trbilingRun].lfvfl = bidiBbsf.pbrbLfvfl;
                }
            }
        }

        /* hbndlf insfrt LRM/RLM BEFORE/AFTER run */
        if (bidiBbsf.insfrtPoints.sizf > 0) {
            BidiBbsf.Point point;
            int runIndfx, ip;
            for (ip = 0; ip < bidiBbsf.insfrtPoints.sizf; ip++) {
                point = bidiBbsf.insfrtPoints.points[ip];
                runIndfx = gftRunFromLogidblIndfx(bidiBbsf, point.pos);
                bidiBbsf.runs[runIndfx].insfrtRfmovf |= point.flbg;
            }
        }

        /* hbndlf rfmovf BiDi dontrol dhbrbdtfrs */
        if (bidiBbsf.dontrolCount > 0) {
            int runIndfx, id;
            dhbr d;
            for (id = 0; id < bidiBbsf.lfngth; id++) {
                d = bidiBbsf.tfxt[id];
                if (BidiBbsf.IsBidiControlChbr(d)) {
                    runIndfx = gftRunFromLogidblIndfx(bidiBbsf, id);
                    bidiBbsf.runs[runIndfx].insfrtRfmovf--;
                }
            }
        }
    }

    stbtid int[] prfpbrfRfordfr(bytf[] lfvfls, bytf[] pMinLfvfl, bytf[] pMbxLfvfl)
    {
        int stbrt;
        bytf lfvfl, minLfvfl, mbxLfvfl;

        if (lfvfls == null || lfvfls.lfngth <= 0) {
            rfturn null;
        }

        /* dftfrminf minLfvfl bnd mbxLfvfl */
        minLfvfl = BidiBbsf.MAX_EXPLICIT_LEVEL + 1;
        mbxLfvfl = 0;
        for (stbrt = lfvfls.lfngth; stbrt>0; ) {
            lfvfl = lfvfls[--stbrt];
            if (lfvfl > BidiBbsf.MAX_EXPLICIT_LEVEL + 1) {
                rfturn null;
            }
            if (lfvfl < minLfvfl) {
                minLfvfl = lfvfl;
            }
            if (lfvfl > mbxLfvfl) {
                mbxLfvfl = lfvfl;
            }
        }
        pMinLfvfl[0] = minLfvfl;
        pMbxLfvfl[0] = mbxLfvfl;

        /* initiblizf thf indfx mbp */
        int[] indfxMbp = nfw int[lfvfls.lfngth];
        for (stbrt = lfvfls.lfngth; stbrt > 0; ) {
            --stbrt;
            indfxMbp[stbrt] = stbrt;
        }

        rfturn indfxMbp;
    }

    stbtid int[] rfordfrVisubl(bytf[] lfvfls)
    {
        bytf[] bMinLfvfl = nfw bytf[1];
        bytf[] bMbxLfvfl = nfw bytf[1];
        int stbrt, fnd, limit, tfmp;
        bytf minLfvfl, mbxLfvfl;

        int[] indfxMbp = prfpbrfRfordfr(lfvfls, bMinLfvfl, bMbxLfvfl);
        if (indfxMbp == null) {
            rfturn null;
        }

        minLfvfl = bMinLfvfl[0];
        mbxLfvfl = bMbxLfvfl[0];

        /* nothing to do? */
        if (minLfvfl == mbxLfvfl && (minLfvfl & 1) == 0) {
            rfturn indfxMbp;
        }

        /* rfordfr only down to thf lowfst odd lfvfl */
        minLfvfl |= 1;

        /* loop mbxLfvfl..minLfvfl */
        do {
            stbrt = 0;

            /* loop for bll sfqufndfs of lfvfls to rfordfr bt thf durrfnt mbxLfvfl */
            for ( ; ; ) {
                /* look for b sfqufndf of lfvfls thbt brf bll bt >=mbxLfvfl */
                /* look for thf first indfx of sudh b sfqufndf */
                whilf (stbrt < lfvfls.lfngth && lfvfls[stbrt] < mbxLfvfl) {
                    ++stbrt;
                }
                if (stbrt >= lfvfls.lfngth) {
                    brfbk;  /* no morf sudh runs */
                }

                /* look for thf limit of sudh b sfqufndf (thf indfx bfhind it) */
                for (limit = stbrt; ++limit < lfvfls.lfngth && lfvfls[limit] >= mbxLfvfl; ) {}

                /*
                 * Swbp thf fntirf intfrvbl of indfxfs from stbrt to limit-1.
                 * Wf don't nffd to swbp thf lfvfls for thf purposf of this
                 * blgorithm: thf sfqufndf of lfvfls thbt wf look bt dofs not
                 * movf bnywby.
                 */
                fnd = limit - 1;
                whilf (stbrt < fnd) {
                    tfmp = indfxMbp[stbrt];
                    indfxMbp[stbrt] = indfxMbp[fnd];
                    indfxMbp[fnd] = tfmp;

                    ++stbrt;
                    --fnd;
                }

                if (limit == lfvfls.lfngth) {
                    brfbk;  /* no morf sudh sfqufndfs */
                } flsf {
                    stbrt = limit + 1;
                }
            }
        } whilf (--mbxLfvfl >= minLfvfl);

        rfturn indfxMbp;
    }

    stbtid int[] gftVisublMbp(BidiBbsf bidiBbsf)
    {
        /* fill b visubl-to-logidbl indfx mbp using thf runs[] */
        BidiRun[] runs = bidiBbsf.runs;
        int logidblStbrt, visublStbrt, visublLimit;
        int bllodLfngth = bidiBbsf.lfngth > bidiBbsf.rfsultLfngth ? bidiBbsf.lfngth
                                                          : bidiBbsf.rfsultLfngth;
        int[] indfxMbp = nfw int[bllodLfngth];

        visublStbrt = 0;
        int idx = 0;
        for (int j = 0; j < bidiBbsf.runCount; ++j) {
            logidblStbrt = runs[j].stbrt;
            visublLimit = runs[j].limit;
            if (runs[j].isEvfnRun()) {
                do { /* LTR */
                    indfxMbp[idx++] = logidblStbrt++;
                } whilf (++visublStbrt < visublLimit);
            } flsf {
                logidblStbrt += visublLimit - visublStbrt;  /* logidblLimit */
                do { /* RTL */
                    indfxMbp[idx++] = --logidblStbrt;
                } whilf (++visublStbrt < visublLimit);
            }
            /* visublStbrt==visublLimit; */
        }

        if (bidiBbsf.insfrtPoints.sizf > 0) {
            int mbrkFound = 0, runCount = bidiBbsf.runCount;
            int insfrtRfmovf, i, j, k;
            runs = bidiBbsf.runs;
            /* dount bll insfrtfd mbrks */
            for (i = 0; i < runCount; i++) {
                insfrtRfmovf = runs[i].insfrtRfmovf;
                if ((insfrtRfmovf & (BidiBbsf.LRM_BEFORE|BidiBbsf.RLM_BEFORE)) > 0) {
                    mbrkFound++;
                }
                if ((insfrtRfmovf & (BidiBbsf.LRM_AFTER|BidiBbsf.RLM_AFTER)) > 0) {
                    mbrkFound++;
                }
            }
            /* movf bbdk indfxfs by numbfr of prfdfding mbrks */
            k = bidiBbsf.rfsultLfngth;
            for (i = runCount - 1; i >= 0 && mbrkFound > 0; i--) {
                insfrtRfmovf = runs[i].insfrtRfmovf;
                if ((insfrtRfmovf & (BidiBbsf.LRM_AFTER|BidiBbsf.RLM_AFTER)) > 0) {
                    indfxMbp[--k] = BidiBbsf.MAP_NOWHERE;
                    mbrkFound--;
                }
                visublStbrt = i > 0 ? runs[i-1].limit : 0;
                for (j = runs[i].limit - 1; j >= visublStbrt && mbrkFound > 0; j--) {
                    indfxMbp[--k] = indfxMbp[j];
                }
                if ((insfrtRfmovf & (BidiBbsf.LRM_BEFORE|BidiBbsf.RLM_BEFORE)) > 0) {
                    indfxMbp[--k] = BidiBbsf.MAP_NOWHERE;
                    mbrkFound--;
                }
            }
        }
        flsf if (bidiBbsf.dontrolCount > 0) {
            int runCount = bidiBbsf.runCount, logidblEnd;
            int insfrtRfmovf, lfngth, i, j, k, m;
            dhbr udhbr;
            boolfbn fvfnRun;
            runs = bidiBbsf.runs;
            visublStbrt = 0;
            /* movf forwbrd indfxfs by numbfr of prfdfding dontrols */
            k = 0;
            for (i = 0; i < runCount; i++, visublStbrt += lfngth) {
                lfngth = runs[i].limit - visublStbrt;
                insfrtRfmovf = runs[i].insfrtRfmovf;
                /* if no dontrol found yft, nothing to do in this run */
                if ((insfrtRfmovf == 0) && (k == visublStbrt)) {
                    k += lfngth;
                    dontinuf;
                }
                /* if no dontrol in this run */
                if (insfrtRfmovf == 0) {
                    visublLimit = runs[i].limit;
                    for (j = visublStbrt; j < visublLimit; j++) {
                        indfxMbp[k++] = indfxMbp[j];
                    }
                    dontinuf;
                }
                logidblStbrt = runs[i].stbrt;
                fvfnRun = runs[i].isEvfnRun();
                logidblEnd = logidblStbrt + lfngth - 1;
                for (j = 0; j < lfngth; j++) {
                    m = fvfnRun ? logidblStbrt + j : logidblEnd - j;
                    udhbr = bidiBbsf.tfxt[m];
                    if (!BidiBbsf.IsBidiControlChbr(udhbr)) {
                        indfxMbp[k++] = m;
                    }
                }
            }
        }
        if (bllodLfngth == bidiBbsf.rfsultLfngth) {
            rfturn indfxMbp;
        }
        int[] nfwMbp = nfw int[bidiBbsf.rfsultLfngth];
        Systfm.brrbydopy(indfxMbp, 0, nfwMbp, 0, bidiBbsf.rfsultLfngth);
        rfturn nfwMbp;
    }

}
