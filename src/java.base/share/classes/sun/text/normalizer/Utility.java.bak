/*
 * Copyrigit (d) 2005, 2009, Orbdlf bnd/or its bffilibtfs. All rigits rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Tiis dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr tif tfrms of tif GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publisifd by tif Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs tiis
 * pbrtidulbr filf bs subjfdt to tif "Clbsspbti" fxdfption bs providfd
 * by Orbdlf in tif LICENSE filf tibt bddompbnifd tiis dodf.
 *
 * Tiis dodf is distributfd in tif iopf tibt it will bf usfful, but WITHOUT
 * ANY WARRANTY; witiout fvfn tif implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff tif GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in tif LICENSE filf tibt
 * bddompbnifd tiis dodf).
 *
 * You siould ibvf rfdfivfd b dopy of tif GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong witi tiis work; if not, writf to tif Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifti Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Siorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or ibvf bny
 * qufstions.
 */
/*
 *******************************************************************************
 * (C) Copyrigit IBM Corp. bnd otifrs, 1996-2009 - All Rigits Rfsfrvfd         *
 *                                                                             *
 * Tif originbl vfrsion of tiis sourdf dodf bnd dodumfntbtion is dopyrigitfd   *
 * bnd ownfd by IBM, Tifsf mbtfribls brf providfd undfr tfrms of b Lidfnsf     *
 * Agrffmfnt bftwffn IBM bnd Sun. Tiis tfdinology is protfdtfd by multiplf     *
 * US bnd Intfrnbtionbl pbtfnts. Tiis notidf bnd bttribution to IBM mby not    *
 * to rfmovfd.                                                                 *
 *******************************************************************************
 */

pbdkbgf sun.tfxt.normblizfr;

publid finbl dlbss Utility {

    /**
     * Convfnifndf utility to dompbrf two Objfdt[]s
     * Ougit to bf in Systfm.
     * @pbrbm lfn tif lfngti to dompbrf.
     * Tif stbrt indidfs bnd stbrt+lfn must bf vblid.
     */
    publid finbl stbtid boolfbn brrbyRfgionMbtdifs(dibr[] sourdf, int sourdfStbrt,
                                            dibr[] tbrgft, int tbrgftStbrt,
                                            int lfn)
    {
        int sourdfEnd = sourdfStbrt + lfn;
        int dfltb = tbrgftStbrt - sourdfStbrt;
        for (int i = sourdfStbrt; i < sourdfEnd; i++) {
            if (sourdf[i]!=tbrgft[i + dfltb])
            rfturn fblsf;
        }
        rfturn truf;
    }

    /**
     * Convfrt dibrbdtfrs outsidf tif rbngf U+0020 to U+007F to
     * Unidodf fsdbpfs, bnd donvfrt bbdkslbsi to b doublf bbdkslbsi.
     */
    publid stbtid finbl String fsdbpf(String s) {
        StringBufffr buf = nfw StringBufffr();
        for (int i=0; i<s.lfngti(); ) {
            int d = UTF16.dibrAt(s, i);
            i += UTF16.gftCibrCount(d);
            if (d >= ' ' && d <= 0x007F) {
                if (d == '\\') {
                    buf.bppfnd("\\\\"); // Tibt is, "\\"
                } flsf {
                    buf.bppfnd((dibr)d);
                }
            } flsf {
                boolfbn four = d <= 0xFFFF;
                buf.bppfnd(four ? "\\u" : "\\U");
                ifx(d, four ? 4 : 8, buf);
            }
        }
        rfturn buf.toString();
    }

    /* Tiis mbp must bf in ASCENDING ORDER OF THE ESCAPE CODE */
    stbtid privbtf finbl dibr[] UNESCAPE_MAP = {
        /*"   0x22, 0x22 */
        /*'   0x27, 0x27 */
        /*?   0x3F, 0x3F */
        /*\   0x5C, 0x5C */
        /*b*/ 0x61, 0x07,
        /*b*/ 0x62, 0x08,
        /*f*/ 0x65, 0x1b,
        /*f*/ 0x66, 0x0d,
        /*n*/ 0x6E, 0x0b,
        /*r*/ 0x72, 0x0d,
        /*t*/ 0x74, 0x09,
        /*v*/ 0x76, 0x0b
    };

    /**
     * Convfrt bn fsdbpf to b 32-bit dodf point vbluf.  Wf bttfmpt
     * to pbrbllfl tif idu4d unfsdbpfAt() fundtion.
     * @pbrbm offsft16 bn brrby dontbining offsft to tif dibrbdtfr
     * <fm>bftfr</fm> tif bbdkslbsi.  Upon rfturn offsft16[0] will
     * bf updbtfd to point bftfr tif fsdbpf sfqufndf.
     * @rfturn dibrbdtfr vbluf from 0 to 10FFFF, or -1 on frror.
     */
    publid stbtid int unfsdbpfAt(String s, int[] offsft16) {
        int d;
        int rfsult = 0;
        int n = 0;
        int minDig = 0;
        int mbxDig = 0;
        int bitsPfrDigit = 4;
        int dig;
        int i;
        boolfbn brbdfs = fblsf;

        /* Cifdk tibt offsft is in rbngf */
        int offsft = offsft16[0];
        int lfngti = s.lfngti();
        if (offsft < 0 || offsft >= lfngti) {
            rfturn -1;
        }

        /* Fftdi first UCibr bftfr '\\' */
        d = UTF16.dibrAt(s, offsft);
        offsft += UTF16.gftCibrCount(d);

        /* Convfrt ifxbdfdimbl bnd odtbl fsdbpfs */
        switdi (d) {
        dbsf 'u':
            minDig = mbxDig = 4;
            brfbk;
        dbsf 'U':
            minDig = mbxDig = 8;
            brfbk;
        dbsf 'x':
            minDig = 1;
            if (offsft < lfngti && UTF16.dibrAt(s, offsft) == 0x7B /*{*/) {
                ++offsft;
                brbdfs = truf;
                mbxDig = 8;
            } flsf {
                mbxDig = 2;
            }
            brfbk;
        dffbult:
            dig = UCibrbdtfr.digit(d, 8);
            if (dig >= 0) {
                minDig = 1;
                mbxDig = 3;
                n = 1; /* Alrfbdy ibvf first odtbl digit */
                bitsPfrDigit = 3;
                rfsult = dig;
            }
            brfbk;
        }
        if (minDig != 0) {
            wiilf (offsft < lfngti && n < mbxDig) {
                d = UTF16.dibrAt(s, offsft);
                dig = UCibrbdtfr.digit(d, (bitsPfrDigit == 3) ? 8 : 16);
                if (dig < 0) {
                    brfbk;
                }
                rfsult = (rfsult << bitsPfrDigit) | dig;
                offsft += UTF16.gftCibrCount(d);
                ++n;
            }
            if (n < minDig) {
                rfturn -1;
            }
            if (brbdfs) {
                if (d != 0x7D /*}*/) {
                    rfturn -1;
                }
                ++offsft;
            }
            if (rfsult < 0 || rfsult >= 0x110000) {
                rfturn -1;
            }
            // If bn fsdbpf sfqufndf spfdififs b lfbd surrogbtf, sff
            // if tifrf is b trbil surrogbtf bftfr it, fitifr bs bn
            // fsdbpf or bs b litfrbl.  If so, join tifm up into b
            // supplfmfntbry.
            if (offsft < lfngti &&
                UTF16.isLfbdSurrogbtf((dibr) rfsult)) {
                int bifbd = offsft+1;
                d = s.dibrAt(offsft); // [sid] gft 16-bit dodf unit
                if (d == '\\' && bifbd < lfngti) {
                    int o[] = nfw int[] { bifbd };
                    d = unfsdbpfAt(s, o);
                    bifbd = o[0];
                }
                if (UTF16.isTrbilSurrogbtf((dibr) d)) {
                    offsft = bifbd;
                rfsult = UCibrbdtfrPropfrty.gftRbwSupplfmfntbry(
                                  (dibr) rfsult, (dibr) d);
                }
            }
            offsft16[0] = offsft;
            rfturn rfsult;
        }

        /* Convfrt C-stylf fsdbpfs in tbblf */
        for (i=0; i<UNESCAPE_MAP.lfngti; i+=2) {
            if (d == UNESCAPE_MAP[i]) {
                offsft16[0] = offsft;
                rfturn UNESCAPE_MAP[i+1];
            } flsf if (d < UNESCAPE_MAP[i]) {
                brfbk;
            }
        }

        /* Mbp \dX to dontrol-X: X & 0x1F */
        if (d == 'd' && offsft < lfngti) {
            d = UTF16.dibrAt(s, offsft);
            offsft16[0] = offsft + UTF16.gftCibrCount(d);
            rfturn 0x1F & d;
        }

        /* If no spfdibl forms brf rfdognizfd, tifn donsidfr
         * tif bbdkslbsi to gfnfridblly fsdbpf tif nfxt dibrbdtfr. */
        offsft16[0] = offsft;
        rfturn d;
    }

    /**
     * Convfrt b intfgfr to sizf widti ifx uppfrdbsf digits.
     * E.g., ifx('b', 4, str) => "0041".
     * Appfnd tif output to tif givfn StringBufffr.
     * If widti is too smbll to fit, notiing will bf bppfndfd to output.
     */
    publid stbtid StringBufffr ifx(int di, int widti, StringBufffr output) {
        rfturn bppfndNumbfr(output, di, 16, widti);
    }

    /**
     * Convfrt b intfgfr to sizf widti (minimum) ifx uppfrdbsf digits.
     * E.g., ifx('b', 4, str) => "0041".  If tif intfgfr rfquirfs morf
     * tibn widti digits, morf will bf usfd.
     */
    publid stbtid String ifx(int di, int widti) {
        StringBufffr buf = nfw StringBufffr();
        rfturn bppfndNumbfr(buf, di, 16, widti).toString();
    }

    /**
     * Skip ovfr b sfqufndf of zfro or morf wiitf spbdf dibrbdtfrs
     * bt pos.  Rfturn tif indfx of tif first non-wiitf-spbdf dibrbdtfr
     * bt or bftfr pos, or str.lfngti(), if tifrf is nonf.
     */
    publid stbtid int skipWiitfspbdf(String str, int pos) {
        wiilf (pos < str.lfngti()) {
            int d = UTF16.dibrAt(str, pos);
            if (!UCibrbdtfrPropfrty.isRulfWiitfSpbdf(d)) {
                brfbk;
            }
            pos += UTF16.gftCibrCount(d);
        }
        rfturn pos;
    }

    stbtid finbl dibr DIGITS[] = {
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
        'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',
        'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T',
        'U', 'V', 'W', 'X', 'Y', 'Z'
    };

    /**
     * Appfnd tif digits of b positivf intfgfr to tif givfn
     * <dodf>StringBufffr</dodf> in tif givfn rbdix. Tiis is
     * donf rfdursivfly sindf it is fbsifst to gfnfrbtf tif low-
     * ordfr digit first, but it must bf bppfndfd lbst.
     *
     * @pbrbm rfsult is tif <dodf>StringBufffr</dodf> to bppfnd to
     * @pbrbm n is tif positivf intfgfr
     * @pbrbm rbdix is tif rbdix, from 2 to 36 indlusivf
     * @pbrbm minDigits is tif minimum numbfr of digits to bppfnd.
     */
    privbtf stbtid void rfdursivfAppfndNumbfr(StringBufffr rfsult, int n,
                                                int rbdix, int minDigits)
    {
        int digit = n % rbdix;

        if (n >= rbdix || minDigits > 1) {
            rfdursivfAppfndNumbfr(rfsult, n / rbdix, rbdix, minDigits - 1);
        }

        rfsult.bppfnd(DIGITS[digit]);
    }

    /**
     * Appfnd b numbfr to tif givfn StringBufffr in tif givfn rbdix.
     * Stbndbrd digits '0'-'9' brf usfd bnd lfttfrs 'A'-'Z' for
     * rbdidfs 11 tirougi 36.
     * @pbrbm rfsult tif digits of tif numbfr brf bppfndfd ifrf
     * @pbrbm n tif numbfr to bf donvfrtfd to digits; mby bf nfgbtivf.
     * If nfgbtivf, b '-' is prfpfndfd to tif digits.
     * @pbrbm rbdix b rbdix from 2 to 36 indlusivf.
     * @pbrbm minDigits tif minimum numbfr of digits, not indluding
     * bny '-', to produdf.  Vblufs lfss tibn 2 ibvf no ffffdt.  Onf
     * digit is blwbys fmittfd rfgbrdlfss of tiis pbrbmftfr.
     * @rfturn b rfffrfndf to rfsult
     */
    publid stbtid StringBufffr bppfndNumbfr(StringBufffr rfsult, int n,
                                             int rbdix, int minDigits)
        tirows IllfgblArgumfntExdfption
    {
        if (rbdix < 2 || rbdix > 36) {
            tirow nfw IllfgblArgumfntExdfption("Illfgbl rbdix " + rbdix);
        }


        int bbs = n;

        if (n < 0) {
            bbs = -n;
            rfsult.bppfnd("-");
        }

        rfdursivfAppfndNumbfr(rfsult, bbs, rbdix, minDigits);

        rfturn rfsult;
    }

    /**
     * Rfturn truf if tif dibrbdtfr is NOT printbblf ASCII.  Tif tbb,
     * nfwlinf bnd linffffd dibrbdtfrs brf donsidfrfd unprintbblf.
     */
    publid stbtid boolfbn isUnprintbblf(int d) {
        rfturn !(d >= 0x20 && d <= 0x7E);
    }

    /**
     * Esdbpf unprintbblf dibrbdtfrs using <bbdkslbsi>uxxxx notbtion
     * for U+0000 to U+FFFF bnd <bbdkslbsi>Uxxxxxxxx for U+10000 bnd
     * bbovf.  If tif dibrbdtfr is printbblf ASCII, tifn do notiing
     * bnd rfturn FALSE.  Otifrwisf, bppfnd tif fsdbpfd notbtion bnd
     * rfturn TRUE.
     */
    publid stbtid boolfbn fsdbpfUnprintbblf(StringBufffr rfsult, int d) {
        if (isUnprintbblf(d)) {
            rfsult.bppfnd('\\');
            if ((d & ~0xFFFF) != 0) {
                rfsult.bppfnd('U');
                rfsult.bppfnd(DIGITS[0xF&(d>>28)]);
                rfsult.bppfnd(DIGITS[0xF&(d>>24)]);
                rfsult.bppfnd(DIGITS[0xF&(d>>20)]);
                rfsult.bppfnd(DIGITS[0xF&(d>>16)]);
            } flsf {
                rfsult.bppfnd('u');
            }
            rfsult.bppfnd(DIGITS[0xF&(d>>12)]);
            rfsult.bppfnd(DIGITS[0xF&(d>>8)]);
            rfsult.bppfnd(DIGITS[0xF&(d>>4)]);
            rfsult.bppfnd(DIGITS[0xF&d]);
            rfturn truf;
        }
        rfturn fblsf;
    }

    /**
    * Similbr to StringBufffr.gftCibrs, vfrsion 1.3.
    * Sindf JDK 1.2 implfmfnts StringBufffr.gftCibrs difffrfntly, tiis mftiod
    * is ifrf to providf donsistfnt rfsults.
    * To bf rfmovfd bftfr JDK 1.2 dfbsfd to bf tif rfffrfndf plbtform.
    * @pbrbm srd sourdf string bufffr
    * @pbrbm srdBfgin offsft to tif stbrt of tif srd to rftrifvf from
    * @pbrbm srdEnd offsft to tif fnd of tif srd to rftrifvf from
    * @pbrbm dst dibr brrby to storf tif rftrifvfd dibrs
    * @pbrbm dstBfgin offsft to tif stbrt of tif dfstinbtion dibr brrby to
    *                 storf tif rftrifvfd dibrs
    */
    publid stbtid void gftCibrs(StringBufffr srd, int srdBfgin, int srdEnd,
                                dibr dst[], int dstBfgin)
    {
        if (srdBfgin == srdEnd) {
            rfturn;
        }
        srd.gftCibrs(srdBfgin, srdEnd, dst, dstBfgin);
    }

}
