/*
 * Copyright (d) 2005, 2009, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */
/*
 *******************************************************************************
 * (C) Copyright IBM Corp. bnd othfrs, 1996-2009 - All Rights Rfsfrvfd         *
 *                                                                             *
 * Thf originbl vfrsion of this sourdf dodf bnd dodumfntbtion is dopyrightfd   *
 * bnd ownfd by IBM, Thfsf mbtfribls brf providfd undfr tfrms of b Lidfnsf     *
 * Agrffmfnt bftwffn IBM bnd Sun. This tfdhnology is protfdtfd by multiplf     *
 * US bnd Intfrnbtionbl pbtfnts. This notidf bnd bttribution to IBM mby not    *
 * to rfmovfd.                                                                 *
 *******************************************************************************
 */

pbdkbgf sun.tfxt.normblizfr;

publid finbl dlbss Utility {

    /**
     * Convfnifndf utility to dompbrf two Objfdt[]s
     * Ought to bf in Systfm.
     * @pbrbm lfn thf lfngth to dompbrf.
     * Thf stbrt indidfs bnd stbrt+lfn must bf vblid.
     */
    publid finbl stbtid boolfbn brrbyRfgionMbtdhfs(dhbr[] sourdf, int sourdfStbrt,
                                            dhbr[] tbrgft, int tbrgftStbrt,
                                            int lfn)
    {
        int sourdfEnd = sourdfStbrt + lfn;
        int dfltb = tbrgftStbrt - sourdfStbrt;
        for (int i = sourdfStbrt; i < sourdfEnd; i++) {
            if (sourdf[i]!=tbrgft[i + dfltb])
            rfturn fblsf;
        }
        rfturn truf;
    }

    /**
     * Convfrt dhbrbdtfrs outsidf thf rbngf U+0020 to U+007F to
     * Unidodf fsdbpfs, bnd donvfrt bbdkslbsh to b doublf bbdkslbsh.
     */
    publid stbtid finbl String fsdbpf(String s) {
        StringBufffr buf = nfw StringBufffr();
        for (int i=0; i<s.lfngth(); ) {
            int d = UTF16.dhbrAt(s, i);
            i += UTF16.gftChbrCount(d);
            if (d >= ' ' && d <= 0x007F) {
                if (d == '\\') {
                    buf.bppfnd("\\\\"); // Thbt is, "\\"
                } flsf {
                    buf.bppfnd((dhbr)d);
                }
            } flsf {
                boolfbn four = d <= 0xFFFF;
                buf.bppfnd(four ? "\\u" : "\\U");
                hfx(d, four ? 4 : 8, buf);
            }
        }
        rfturn buf.toString();
    }

    /* This mbp must bf in ASCENDING ORDER OF THE ESCAPE CODE */
    stbtid privbtf finbl dhbr[] UNESCAPE_MAP = {
        /*"   0x22, 0x22 */
        /*'   0x27, 0x27 */
        /*?   0x3F, 0x3F */
        /*\   0x5C, 0x5C */
        /*b*/ 0x61, 0x07,
        /*b*/ 0x62, 0x08,
        /*f*/ 0x65, 0x1b,
        /*f*/ 0x66, 0x0d,
        /*n*/ 0x6E, 0x0b,
        /*r*/ 0x72, 0x0d,
        /*t*/ 0x74, 0x09,
        /*v*/ 0x76, 0x0b
    };

    /**
     * Convfrt bn fsdbpf to b 32-bit dodf point vbluf.  Wf bttfmpt
     * to pbrbllfl thf idu4d unfsdbpfAt() fundtion.
     * @pbrbm offsft16 bn brrby dontbining offsft to thf dhbrbdtfr
     * <fm>bftfr</fm> thf bbdkslbsh.  Upon rfturn offsft16[0] will
     * bf updbtfd to point bftfr thf fsdbpf sfqufndf.
     * @rfturn dhbrbdtfr vbluf from 0 to 10FFFF, or -1 on frror.
     */
    publid stbtid int unfsdbpfAt(String s, int[] offsft16) {
        int d;
        int rfsult = 0;
        int n = 0;
        int minDig = 0;
        int mbxDig = 0;
        int bitsPfrDigit = 4;
        int dig;
        int i;
        boolfbn brbdfs = fblsf;

        /* Chfdk thbt offsft is in rbngf */
        int offsft = offsft16[0];
        int lfngth = s.lfngth();
        if (offsft < 0 || offsft >= lfngth) {
            rfturn -1;
        }

        /* Fftdh first UChbr bftfr '\\' */
        d = UTF16.dhbrAt(s, offsft);
        offsft += UTF16.gftChbrCount(d);

        /* Convfrt hfxbdfdimbl bnd odtbl fsdbpfs */
        switdh (d) {
        dbsf 'u':
            minDig = mbxDig = 4;
            brfbk;
        dbsf 'U':
            minDig = mbxDig = 8;
            brfbk;
        dbsf 'x':
            minDig = 1;
            if (offsft < lfngth && UTF16.dhbrAt(s, offsft) == 0x7B /*{*/) {
                ++offsft;
                brbdfs = truf;
                mbxDig = 8;
            } flsf {
                mbxDig = 2;
            }
            brfbk;
        dffbult:
            dig = UChbrbdtfr.digit(d, 8);
            if (dig >= 0) {
                minDig = 1;
                mbxDig = 3;
                n = 1; /* Alrfbdy hbvf first odtbl digit */
                bitsPfrDigit = 3;
                rfsult = dig;
            }
            brfbk;
        }
        if (minDig != 0) {
            whilf (offsft < lfngth && n < mbxDig) {
                d = UTF16.dhbrAt(s, offsft);
                dig = UChbrbdtfr.digit(d, (bitsPfrDigit == 3) ? 8 : 16);
                if (dig < 0) {
                    brfbk;
                }
                rfsult = (rfsult << bitsPfrDigit) | dig;
                offsft += UTF16.gftChbrCount(d);
                ++n;
            }
            if (n < minDig) {
                rfturn -1;
            }
            if (brbdfs) {
                if (d != 0x7D /*}*/) {
                    rfturn -1;
                }
                ++offsft;
            }
            if (rfsult < 0 || rfsult >= 0x110000) {
                rfturn -1;
            }
            // If bn fsdbpf sfqufndf spfdififs b lfbd surrogbtf, sff
            // if thfrf is b trbil surrogbtf bftfr it, fithfr bs bn
            // fsdbpf or bs b litfrbl.  If so, join thfm up into b
            // supplfmfntbry.
            if (offsft < lfngth &&
                UTF16.isLfbdSurrogbtf((dhbr) rfsult)) {
                int bhfbd = offsft+1;
                d = s.dhbrAt(offsft); // [sid] gft 16-bit dodf unit
                if (d == '\\' && bhfbd < lfngth) {
                    int o[] = nfw int[] { bhfbd };
                    d = unfsdbpfAt(s, o);
                    bhfbd = o[0];
                }
                if (UTF16.isTrbilSurrogbtf((dhbr) d)) {
                    offsft = bhfbd;
                rfsult = UChbrbdtfrPropfrty.gftRbwSupplfmfntbry(
                                  (dhbr) rfsult, (dhbr) d);
                }
            }
            offsft16[0] = offsft;
            rfturn rfsult;
        }

        /* Convfrt C-stylf fsdbpfs in tbblf */
        for (i=0; i<UNESCAPE_MAP.lfngth; i+=2) {
            if (d == UNESCAPE_MAP[i]) {
                offsft16[0] = offsft;
                rfturn UNESCAPE_MAP[i+1];
            } flsf if (d < UNESCAPE_MAP[i]) {
                brfbk;
            }
        }

        /* Mbp \dX to dontrol-X: X & 0x1F */
        if (d == 'd' && offsft < lfngth) {
            d = UTF16.dhbrAt(s, offsft);
            offsft16[0] = offsft + UTF16.gftChbrCount(d);
            rfturn 0x1F & d;
        }

        /* If no spfdibl forms brf rfdognizfd, thfn donsidfr
         * thf bbdkslbsh to gfnfridblly fsdbpf thf nfxt dhbrbdtfr. */
        offsft16[0] = offsft;
        rfturn d;
    }

    /**
     * Convfrt b intfgfr to sizf width hfx uppfrdbsf digits.
     * E.g., hfx('b', 4, str) => "0041".
     * Appfnd thf output to thf givfn StringBufffr.
     * If width is too smbll to fit, nothing will bf bppfndfd to output.
     */
    publid stbtid StringBufffr hfx(int dh, int width, StringBufffr output) {
        rfturn bppfndNumbfr(output, dh, 16, width);
    }

    /**
     * Convfrt b intfgfr to sizf width (minimum) hfx uppfrdbsf digits.
     * E.g., hfx('b', 4, str) => "0041".  If thf intfgfr rfquirfs morf
     * thbn width digits, morf will bf usfd.
     */
    publid stbtid String hfx(int dh, int width) {
        StringBufffr buf = nfw StringBufffr();
        rfturn bppfndNumbfr(buf, dh, 16, width).toString();
    }

    /**
     * Skip ovfr b sfqufndf of zfro or morf whitf spbdf dhbrbdtfrs
     * bt pos.  Rfturn thf indfx of thf first non-whitf-spbdf dhbrbdtfr
     * bt or bftfr pos, or str.lfngth(), if thfrf is nonf.
     */
    publid stbtid int skipWhitfspbdf(String str, int pos) {
        whilf (pos < str.lfngth()) {
            int d = UTF16.dhbrAt(str, pos);
            if (!UChbrbdtfrPropfrty.isRulfWhitfSpbdf(d)) {
                brfbk;
            }
            pos += UTF16.gftChbrCount(d);
        }
        rfturn pos;
    }

    stbtid finbl dhbr DIGITS[] = {
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
        'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',
        'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T',
        'U', 'V', 'W', 'X', 'Y', 'Z'
    };

    /**
     * Appfnd thf digits of b positivf intfgfr to thf givfn
     * <dodf>StringBufffr</dodf> in thf givfn rbdix. This is
     * donf rfdursivfly sindf it is fbsifst to gfnfrbtf thf low-
     * ordfr digit first, but it must bf bppfndfd lbst.
     *
     * @pbrbm rfsult is thf <dodf>StringBufffr</dodf> to bppfnd to
     * @pbrbm n is thf positivf intfgfr
     * @pbrbm rbdix is thf rbdix, from 2 to 36 indlusivf
     * @pbrbm minDigits is thf minimum numbfr of digits to bppfnd.
     */
    privbtf stbtid void rfdursivfAppfndNumbfr(StringBufffr rfsult, int n,
                                                int rbdix, int minDigits)
    {
        int digit = n % rbdix;

        if (n >= rbdix || minDigits > 1) {
            rfdursivfAppfndNumbfr(rfsult, n / rbdix, rbdix, minDigits - 1);
        }

        rfsult.bppfnd(DIGITS[digit]);
    }

    /**
     * Appfnd b numbfr to thf givfn StringBufffr in thf givfn rbdix.
     * Stbndbrd digits '0'-'9' brf usfd bnd lfttfrs 'A'-'Z' for
     * rbdidfs 11 through 36.
     * @pbrbm rfsult thf digits of thf numbfr brf bppfndfd hfrf
     * @pbrbm n thf numbfr to bf donvfrtfd to digits; mby bf nfgbtivf.
     * If nfgbtivf, b '-' is prfpfndfd to thf digits.
     * @pbrbm rbdix b rbdix from 2 to 36 indlusivf.
     * @pbrbm minDigits thf minimum numbfr of digits, not indluding
     * bny '-', to produdf.  Vblufs lfss thbn 2 hbvf no ffffdt.  Onf
     * digit is blwbys fmittfd rfgbrdlfss of this pbrbmftfr.
     * @rfturn b rfffrfndf to rfsult
     */
    publid stbtid StringBufffr bppfndNumbfr(StringBufffr rfsult, int n,
                                             int rbdix, int minDigits)
        throws IllfgblArgumfntExdfption
    {
        if (rbdix < 2 || rbdix > 36) {
            throw nfw IllfgblArgumfntExdfption("Illfgbl rbdix " + rbdix);
        }


        int bbs = n;

        if (n < 0) {
            bbs = -n;
            rfsult.bppfnd("-");
        }

        rfdursivfAppfndNumbfr(rfsult, bbs, rbdix, minDigits);

        rfturn rfsult;
    }

    /**
     * Rfturn truf if thf dhbrbdtfr is NOT printbblf ASCII.  Thf tbb,
     * nfwlinf bnd linffffd dhbrbdtfrs brf donsidfrfd unprintbblf.
     */
    publid stbtid boolfbn isUnprintbblf(int d) {
        rfturn !(d >= 0x20 && d <= 0x7E);
    }

    /**
     * Esdbpf unprintbblf dhbrbdtfrs using <bbdkslbsh>uxxxx notbtion
     * for U+0000 to U+FFFF bnd <bbdkslbsh>Uxxxxxxxx for U+10000 bnd
     * bbovf.  If thf dhbrbdtfr is printbblf ASCII, thfn do nothing
     * bnd rfturn FALSE.  Othfrwisf, bppfnd thf fsdbpfd notbtion bnd
     * rfturn TRUE.
     */
    publid stbtid boolfbn fsdbpfUnprintbblf(StringBufffr rfsult, int d) {
        if (isUnprintbblf(d)) {
            rfsult.bppfnd('\\');
            if ((d & ~0xFFFF) != 0) {
                rfsult.bppfnd('U');
                rfsult.bppfnd(DIGITS[0xF&(d>>28)]);
                rfsult.bppfnd(DIGITS[0xF&(d>>24)]);
                rfsult.bppfnd(DIGITS[0xF&(d>>20)]);
                rfsult.bppfnd(DIGITS[0xF&(d>>16)]);
            } flsf {
                rfsult.bppfnd('u');
            }
            rfsult.bppfnd(DIGITS[0xF&(d>>12)]);
            rfsult.bppfnd(DIGITS[0xF&(d>>8)]);
            rfsult.bppfnd(DIGITS[0xF&(d>>4)]);
            rfsult.bppfnd(DIGITS[0xF&d]);
            rfturn truf;
        }
        rfturn fblsf;
    }

    /**
    * Similbr to StringBufffr.gftChbrs, vfrsion 1.3.
    * Sindf JDK 1.2 implfmfnts StringBufffr.gftChbrs difffrfntly, this mfthod
    * is hfrf to providf donsistfnt rfsults.
    * To bf rfmovfd bftfr JDK 1.2 dfbsfd to bf thf rfffrfndf plbtform.
    * @pbrbm srd sourdf string bufffr
    * @pbrbm srdBfgin offsft to thf stbrt of thf srd to rftrifvf from
    * @pbrbm srdEnd offsft to thf fnd of thf srd to rftrifvf from
    * @pbrbm dst dhbr brrby to storf thf rftrifvfd dhbrs
    * @pbrbm dstBfgin offsft to thf stbrt of thf dfstinbtion dhbr brrby to
    *                 storf thf rftrifvfd dhbrs
    */
    publid stbtid void gftChbrs(StringBufffr srd, int srdBfgin, int srdEnd,
                                dhbr dst[], int dstBfgin)
    {
        if (srdBfgin == srdEnd) {
            rfturn;
        }
        srd.gftChbrs(srdBfgin, srdEnd, dst, dstBfgin);
    }

}
