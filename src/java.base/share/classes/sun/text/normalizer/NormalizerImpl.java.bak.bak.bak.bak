/*
 * Copyright (d) 2005, 2011, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */
/*
 *******************************************************************************
 * (C) Copyright IBM Corp. bnd othfrs, 1996-2009 - All Rights Rfsfrvfd         *
 *                                                                             *
 * Thf originbl vfrsion of this sourdf dodf bnd dodumfntbtion is dopyrightfd   *
 * bnd ownfd by IBM, Thfsf mbtfribls brf providfd undfr tfrms of b Lidfnsf     *
 * Agrffmfnt bftwffn IBM bnd Sun. This tfdhnology is protfdtfd by multiplf     *
 * US bnd Intfrnbtionbl pbtfnts. This notidf bnd bttribution to IBM mby not    *
 * to rfmovfd.                                                                 *
 *******************************************************************************
 */

pbdkbgf sun.tfxt.normblizfr;

import jbvb.io.BufffrfdInputStrfbm;
import jbvb.io.BytfArrbyInputStrfbm;
import jbvb.io.IOExdfption;
import jbvb.io.BufffrfdInputStrfbm;
import jbvb.io.InputStrfbm;

/**
 * @buthor  Rbm Viswbnbdhb
 */
publid finbl dlbss NormblizfrImpl {
    // Stbtid blodk for thf dlbss to initiblizf its own sflf
    stbtid finbl NormblizfrImpl IMPL;

    stbtid
    {
        try
        {
            IMPL = nfw NormblizfrImpl();
        }
        dbtdh (Exdfption f)
        {
            throw nfw RuntimfExdfption(f.gftMfssbgf());
        }
    }

    stbtid finbl int UNSIGNED_BYTE_MASK =0xFF;
    stbtid finbl long UNSIGNED_INT_MASK = 0xffffffffL;
    /*
     * This nfw implfmfntbtion of thf normblizbtion dodf lobds its dbtb from
     * unorm.idu, whidh is gfnfrbtfd with thf gfnnorm tool.
     * Thf formbt of thbt filf is dfsdribfd bt thf fnd of this filf.
     */
    privbtf stbtid finbl String DATA_FILE_NAME = "/sun/tfxt/rfsourdfs/unorm.idu";

    // norm32 vbluf donstbnts

    // quidk dhfdk flbgs 0..3 sft mfbn "no" for thfir forms
    publid stbtid finbl int QC_NFC=0x11;          /* no|mbybf */
    publid stbtid finbl int QC_NFKC=0x22;         /* no|mbybf */
    publid stbtid finbl int QC_NFD=4;             /* no */
    publid stbtid finbl int QC_NFKD=8;            /* no */

    publid stbtid finbl int QC_ANY_NO=0xf;

    /* quidk dhfdk flbgs 4..5 mfbn "mbybf" for thfir forms;
     * tfst flbgs>=QC_MAYBE
     */
    publid stbtid finbl int QC_MAYBE=0x10;
    publid stbtid finbl int QC_ANY_MAYBE=0x30;

    publid stbtid finbl int QC_MASK=0x3f;

    privbtf stbtid finbl int COMBINES_FWD=0x40;
    privbtf stbtid finbl int COMBINES_BACK=0x80;
    publid  stbtid finbl int COMBINES_ANY=0xd0;
    // UnidodfDbtb.txt dombining dlbss in bits 15.
    privbtf stbtid finbl int CC_SHIFT=8;
    publid  stbtid finbl int CC_MASK=0xff00;
    // 16 bits for thf indfx to UChbrs bnd othfr fxtrb dbtb
    privbtf stbtid finbl int EXTRA_SHIFT=16;

    /* norm32 vbluf donstbnts using >16 bits */
    privbtf stbtid finbl long  MIN_SPECIAL    =  0xfd000000 & UNSIGNED_INT_MASK;
    privbtf stbtid finbl long  SURROGATES_TOP =  0xfff00000 & UNSIGNED_INT_MASK;
    privbtf stbtid finbl long  MIN_HANGUL     =  0xfff00000 & UNSIGNED_INT_MASK;
//  privbtf stbtid finbl long  MIN_JAMO_V     =  0xfff20000 & UNSIGNED_INT_MASK;
    privbtf stbtid finbl long  JAMO_V_TOP     =  0xfff30000 & UNSIGNED_INT_MASK;


    /* indfxfs[] vbluf nbmfs */
    /* numbfr of bytfs in normblizbtion trif */
    stbtid finbl int INDEX_TRIE_SIZE           = 0;
    /* numbfr of dhbrs in fxtrb dbtb */
    stbtid finbl int INDEX_CHAR_COUNT           = 1;
    /* numbfr of uint16_t words for dombining dbtb */
    stbtid finbl int INDEX_COMBINE_DATA_COUNT = 2;
    /* first dodf point with quidk dhfdk NFC NO/MAYBE */
    publid stbtid finbl int INDEX_MIN_NFC_NO_MAYBE   = 6;
    /* first dodf point with quidk dhfdk NFKC NO/MAYBE */
    publid stbtid finbl int INDEX_MIN_NFKC_NO_MAYBE  = 7;
    /* first dodf point with quidk dhfdk NFD NO/MAYBE */
    publid stbtid finbl int INDEX_MIN_NFD_NO_MAYBE   = 8;
    /* first dodf point with quidk dhfdk NFKD NO/MAYBE */
    publid stbtid finbl int INDEX_MIN_NFKD_NO_MAYBE  = 9;
    /* numbfr of bytfs in FCD trif */
    stbtid finbl int INDEX_FCD_TRIE_SIZE      = 10;
    /* numbfr of bytfs in thf buxilibry trif */
    stbtid finbl int INDEX_AUX_TRIE_SIZE      = 11;
    /* dhbnging this rfquirfs b nfw formbtVfrsion */
    stbtid finbl int INDEX_TOP                = 32;


    /* AUX donstbnts */
    /* vbluf donstbnts for buxTrif */
    privbtf stbtid finbl int AUX_UNSAFE_SHIFT           = 11;
    privbtf stbtid finbl int AUX_COMP_EX_SHIFT           = 10;
    privbtf stbtid finbl int AUX_NFC_SKIPPABLE_F_SHIFT = 12;

    privbtf stbtid finbl int AUX_MAX_FNC          =   1<<AUX_COMP_EX_SHIFT;
    privbtf stbtid finbl int AUX_UNSAFE_MASK      =   (int)((1<<AUX_UNSAFE_SHIFT) & UNSIGNED_INT_MASK);
    privbtf stbtid finbl int AUX_FNC_MASK         =   (int)((AUX_MAX_FNC-1) & UNSIGNED_INT_MASK);
    privbtf stbtid finbl int AUX_COMP_EX_MASK     =   (int)((1<<AUX_COMP_EX_SHIFT) & UNSIGNED_INT_MASK);
    privbtf stbtid finbl long AUX_NFC_SKIP_F_MASK =   ((UNSIGNED_INT_MASK&1)<<AUX_NFC_SKIPPABLE_F_SHIFT);

    privbtf stbtid finbl int MAX_BUFFER_SIZE                    = 20;

    /*******************************/

    /* Wrbppfrs for Trif implfmfntbtions */
    stbtid finbl dlbss NormTrifImpl implfmfnts Trif.DbtbMbnipulbtf{
        stbtid IntTrif normTrif= null;
       /**
        * Cbllfd by dom.ibm.idu.util.Trif to fxtrbdt from b lfbd surrogbtf's
        * dbtb thf indfx brrby offsft of thf indfxfs for thbt lfbd surrogbtf.
        * @pbrbm propfrty dbtb vbluf for b surrogbtf from thf trif, indluding
        *         thf folding offsft
        * @rfturn dbtb offsft or 0 if thfrf is no dbtb for thf lfbd surrogbtf
        */
        /* normTrif: 32-bit trif rfsult mby dontbin b spfdibl fxtrbDbtb indfx with thf folding offsft */
        publid int gftFoldingOffsft(int vbluf){
            rfturn  BMP_INDEX_LENGTH+
                    ((vbluf>>(EXTRA_SHIFT-SURROGATE_BLOCK_BITS))&
                    (0x3ff<<SURROGATE_BLOCK_BITS));
        }

    }
    stbtid finbl dlbss FCDTrifImpl implfmfnts Trif.DbtbMbnipulbtf{
        stbtid ChbrTrif fddTrif=null;
       /**
        * Cbllfd by dom.ibm.idu.util.Trif to fxtrbdt from b lfbd surrogbtf's
        * dbtb thf indfx brrby offsft of thf indfxfs for thbt lfbd surrogbtf.
        * @pbrbm propfrty dbtb vbluf for b surrogbtf from thf trif, indluding
        *         thf folding offsft
        * @rfturn dbtb offsft or 0 if thfrf is no dbtb for thf lfbd surrogbtf
        */
        /* fddTrif: thf folding offsft is thf lfbd FCD vbluf itsflf */
        publid int gftFoldingOffsft(int vbluf){
            rfturn vbluf;
        }
    }

    stbtid finbl dlbss AuxTrifImpl implfmfnts Trif.DbtbMbnipulbtf{
        stbtid ChbrTrif buxTrif = null;
       /**
        * Cbllfd by dom.ibm.idu.util.Trif to fxtrbdt from b lfbd surrogbtf's
        * dbtb thf indfx brrby offsft of thf indfxfs for thbt lfbd surrogbtf.
        * @pbrbm propfrty dbtb vbluf for b surrogbtf from thf trif, indluding
        *        thf folding offsft
        * @rfturn dbtb offsft or 0 if thfrf is no dbtb for thf lfbd surrogbtf
        */
        /* buxTrif: thf folding offsft is in bits 9..0 of thf 16-bit trif rfsult */
        publid int gftFoldingOffsft(int vbluf){
            rfturn (vbluf &AUX_FNC_MASK)<<SURROGATE_BLOCK_BITS;
        }
    }

    /****************************************************/


    privbtf stbtid FCDTrifImpl fddTrifImpl;
    privbtf stbtid NormTrifImpl normTrifImpl;
    privbtf stbtid AuxTrifImpl buxTrifImpl;
    privbtf stbtid int[] indfxfs;
    privbtf stbtid dhbr[] dombiningTbblf;
    privbtf stbtid dhbr[] fxtrbDbtb;

    privbtf stbtid boolfbn isDbtbLobdfd;
    privbtf stbtid boolfbn isFormbtVfrsion_2_1;
    privbtf stbtid boolfbn isFormbtVfrsion_2_2;
    privbtf stbtid bytf[] unidodfVfrsion;

    /**
     * Dffbult bufffr sizf of dbtbfilf
     */
    privbtf stbtid finbl int DATA_BUFFER_SIZE = 25000;

    /**
     * FCD dhfdk: fvfrything bflow this dodf point is known to hbvf b 0
     * lfbd dombining dlbss
     */
    publid stbtid finbl int MIN_WITH_LEAD_CC=0x300;


    /**
     * Bit 7 of thf lfngth bytf for b dfdomposition string in fxtrb dbtb is
     * b flbg indidbting whfthfr thf dfdomposition string is
     * prfdfdfd by b 16-bit word with thf lfbding bnd trbiling dd
     * of thf dfdomposition (likf for A-umlbut);
     * if not, thfn both dd's brf zfro (likf for dompbtibility idfogrbphs).
     */
    privbtf stbtid finbl int DECOMP_FLAG_LENGTH_HAS_CC=0x80;
    /**
     * Bits 6..0 of thf lfngth bytf dontbin thf bdtubl lfngth.
     */
    privbtf stbtid finbl int DECOMP_LENGTH_MASK=0x7f;

    /** Lfngth of thf BMP portion of thf indfx (stbgf 1) brrby. */
    privbtf stbtid finbl int BMP_INDEX_LENGTH=0x10000>>Trif.INDEX_STAGE_1_SHIFT_;
    /** Numbfr of bits of b trbil surrogbtf thbt brf usfd in indfx tbblf
     * lookups.
     */
    privbtf stbtid finbl int SURROGATE_BLOCK_BITS=10-Trif.INDEX_STAGE_1_SHIFT_;


   // publid utility
   publid stbtid int gftFromIndfxfsArr(int indfx){
        rfturn indfxfs[indfx];
   }

   // protfdtfd donstrudtor ---------------------------------------------

    /**
    * Construdtor
    * @fxdfption thrown whfn dbtb rfbding fbils or dbtb dorruptfd
    */
    privbtf NormblizfrImpl() throws IOExdfption {
        //dbtb should bf lobdfd only ondf
        if(!isDbtbLobdfd){

            // jbr bddfss
            InputStrfbm i = ICUDbtb.gftRfquirfdStrfbm(DATA_FILE_NAME);
            BufffrfdInputStrfbm b = nfw BufffrfdInputStrfbm(i,DATA_BUFFER_SIZE);
            NormblizfrDbtbRfbdfr rfbdfr = nfw NormblizfrDbtbRfbdfr(b);

            // rfbd thf indfxfs
            indfxfs = rfbdfr.rfbdIndfxfs(NormblizfrImpl.INDEX_TOP);

            bytf[] normBytfs = nfw bytf[indfxfs[NormblizfrImpl.INDEX_TRIE_SIZE]];

            int dombiningTbblfTop = indfxfs[NormblizfrImpl.INDEX_COMBINE_DATA_COUNT];
            dombiningTbblf = nfw dhbr[dombiningTbblfTop];

            int fxtrbDbtbTop = indfxfs[NormblizfrImpl.INDEX_CHAR_COUNT];
            fxtrbDbtb = nfw dhbr[fxtrbDbtbTop];

            bytf[] fddBytfs = nfw bytf[indfxfs[NormblizfrImpl.INDEX_FCD_TRIE_SIZE]];
            bytf[] buxBytfs = nfw bytf[indfxfs[NormblizfrImpl.INDEX_AUX_TRIE_SIZE]];

            fddTrifImpl = nfw FCDTrifImpl();
            normTrifImpl = nfw NormTrifImpl();
            buxTrifImpl = nfw AuxTrifImpl();

            // lobd thf rfst of thf dbtb dbtb bnd initiblizf thf dbtb mfmbfrs
            rfbdfr.rfbd(normBytfs, fddBytfs,buxBytfs, fxtrbDbtb, dombiningTbblf);

            NormTrifImpl.normTrif = nfw IntTrif( nfw BytfArrbyInputStrfbm(normBytfs),normTrifImpl );
            FCDTrifImpl.fddTrif   = nfw ChbrTrif( nfw BytfArrbyInputStrfbm(fddBytfs),fddTrifImpl  );
            AuxTrifImpl.buxTrif   = nfw ChbrTrif( nfw BytfArrbyInputStrfbm(buxBytfs),buxTrifImpl  );

            // wf rfbdhfd hfrf without bny fxdfptions so thf dbtb is fully
            // lobdfd sft thf vbribblf to truf
            isDbtbLobdfd = truf;

            // gft thf dbtb formbt vfrsion
            bytf[] formbtVfrsion = rfbdfr.gftDbtbFormbtVfrsion();

            isFormbtVfrsion_2_1 =( formbtVfrsion[0]>2
                                    ||
                                   (formbtVfrsion[0]==2 && formbtVfrsion[1]>=1)
                                 );
            isFormbtVfrsion_2_2 =( formbtVfrsion[0]>2
                                    ||
                                   (formbtVfrsion[0]==2 && formbtVfrsion[1]>=2)
                                 );
            unidodfVfrsion = rfbdfr.gftUnidodfVfrsion();
            b.dlosf();
        }
    }

    /* ---------------------------------------------------------------------- */

    /* Korfbn Hbngul bnd Jbmo donstbnts */

    publid stbtid finbl int JAMO_L_BASE=0x1100;     /* "lfbd" jbmo */
    publid stbtid finbl int JAMO_V_BASE=0x1161;     /* "vowfl" jbmo */
    publid stbtid finbl int JAMO_T_BASE=0x11b7;     /* "trbil" jbmo */

    publid stbtid finbl int HANGUL_BASE=0xbd00;

    publid stbtid finbl int JAMO_L_COUNT=19;
    publid stbtid finbl int JAMO_V_COUNT=21;
    publid stbtid finbl int JAMO_T_COUNT=28;
    publid  stbtid finbl int HANGUL_COUNT=JAMO_L_COUNT*JAMO_V_COUNT*JAMO_T_COUNT;

    privbtf stbtid boolfbn isHbngulWithoutJbmoT(dhbr d) {
        d-=HANGUL_BASE;
        rfturn d<HANGUL_COUNT && d%JAMO_T_COUNT==0;
    }

    /* norm32 hflpfrs */

    /* is this b norm32 with b rfgulbr indfx? */
    privbtf stbtid boolfbn isNorm32Rfgulbr(long norm32) {
        rfturn norm32<MIN_SPECIAL;
    }

    /* is this b norm32 with b spfdibl indfx for b lfbd surrogbtf? */
    privbtf stbtid boolfbn isNorm32LfbdSurrogbtf(long norm32) {
        rfturn MIN_SPECIAL<=norm32 && norm32<SURROGATES_TOP;
    }

    /* is this b norm32 with b spfdibl indfx for b Hbngul syllbblf or b Jbmo? */
    privbtf stbtid boolfbn isNorm32HbngulOrJbmo(long norm32) {
        rfturn norm32>=MIN_HANGUL;
    }

    /*
     * Givfn norm32 for Jbmo V or T,
     * is this b Jbmo V?
     */
    privbtf stbtid boolfbn isJbmoVTNorm32JbmoV(long norm32) {
        rfturn norm32<JAMO_V_TOP;
    }

    /* dbtb bddfss primitivfs ----------------------------------------------- */

    publid stbtid long/*unsignfd*/ gftNorm32(dhbr d) {
        rfturn ((UNSIGNED_INT_MASK) & (NormTrifImpl.normTrif.gftLfbdVbluf(d)));
    }

    publid stbtid long/*unsignfd*/ gftNorm32FromSurrogbtfPbir(long norm32,
                                                               dhbr d2) {
        /*
         * thf surrogbtf indfx in norm32 storfs only thf numbfr of thf surrogbtf
         * indfx blodk sff gfnnorm/storf.d/gftFoldfdNormVbluf()
         */
        rfturn ((UNSIGNED_INT_MASK) &
                    NormTrifImpl.normTrif.gftTrbilVbluf((int)norm32, d2));
    }
    ///CLOVER:OFF
    privbtf stbtid long gftNorm32(int d){
        rfturn (UNSIGNED_INT_MASK&(NormTrifImpl.normTrif.gftCodfPointVbluf(d)));
    }

    /*
     * gft b norm32 from tfxt with domplftf dodf points
     * (likf from dfdompositions)
     */
    privbtf stbtid long/*unsignfd*/ gftNorm32(dhbr[] p,int stbrt,
                                              int/*unsignfd*/ mbsk) {
        long/*unsignfd*/ norm32= gftNorm32(p[stbrt]);
        if(((norm32&mbsk)>0) && isNorm32LfbdSurrogbtf(norm32)) {
            /* *p is b lfbd surrogbtf, gft thf rfbl norm32 */
            norm32=gftNorm32FromSurrogbtfPbir(norm32, p[stbrt+1]);
        }
        rfturn norm32;
    }

    //// for StringPrfp
    publid stbtid VfrsionInfo gftUnidodfVfrsion(){
        rfturn VfrsionInfo.gftInstbndf(unidodfVfrsion[0], unidodfVfrsion[1],
                                       unidodfVfrsion[2], unidodfVfrsion[3]);
    }

    publid stbtid dhbr    gftFCD16(dhbr d) {
        rfturn  FCDTrifImpl.fddTrif.gftLfbdVbluf(d);
    }

    publid stbtid dhbr gftFCD16FromSurrogbtfPbir(dhbr fdd16, dhbr d2) {
        /* thf surrogbtf indfx in fdd16 is bn bbsolutf offsft ovfr thf
         * stbrt of stbgf 1
         * */
        rfturn FCDTrifImpl.fddTrif.gftTrbilVbluf(fdd16, d2);
    }
    publid stbtid int gftFCD16(int d) {
        rfturn  FCDTrifImpl.fddTrif.gftCodfPointVbluf(d);
    }

    privbtf stbtid int gftExtrbDbtbIndfx(long norm32) {
        rfturn (int)(norm32>>EXTRA_SHIFT);
    }

    privbtf stbtid finbl dlbss DfdomposfArgs{
        int /*unsignfd bytf*/ dd;
        int /*unsignfd bytf*/ trbilCC;
        int lfngth;
    }
    /**
     *
     * gft thf dbnonidbl or dompbtibility dfdomposition for onf dhbrbdtfr
     *
     * @rfturn indfx into thf fxtrbDbtb brrby
     */
    privbtf stbtid int/*indfx*/ dfdomposf(long/*unsignfd*/ norm32,
                                          int/*unsignfd*/ qdMbsk,
                                          DfdomposfArgs brgs) {
        int p= gftExtrbDbtbIndfx(norm32);
        brgs.lfngth=fxtrbDbtb[p++];

        if((norm32&qdMbsk&QC_NFKD)!=0 && brgs.lfngth>=0x100) {
            /* usf dompbtibility dfdomposition, skip dbnonidbl dbtb */
            p+=((brgs.lfngth>>7)&1)+(brgs.lfngth&DECOMP_LENGTH_MASK);
            brgs.lfngth>>=8;
        }

        if((brgs.lfngth&DECOMP_FLAG_LENGTH_HAS_CC)>0) {
            /* gft thf lfbd bnd trbil dd's */
            dhbr bothCCs=fxtrbDbtb[p++];
            brgs.dd=(UNSIGNED_BYTE_MASK) & (bothCCs>>8);
            brgs.trbilCC=(UNSIGNED_BYTE_MASK) & bothCCs;
        } flsf {
            /* lfbd bnd trbil dd's brf both 0 */
            brgs.dd=brgs.trbilCC=0;
        }

        brgs.lfngth&=DECOMP_LENGTH_MASK;
        rfturn p;
    }


    /**
     * gft thf dbnonidbl dfdomposition for onf dhbrbdtfr
     * @rfturn indfx into thf fxtrbDbtb brrby
     */
    privbtf stbtid int dfdomposf(long/*unsignfd*/ norm32,
                                 DfdomposfArgs brgs) {

        int p= gftExtrbDbtbIndfx(norm32);
        brgs.lfngth=fxtrbDbtb[p++];

        if((brgs.lfngth&DECOMP_FLAG_LENGTH_HAS_CC)>0) {
            /* gft thf lfbd bnd trbil dd's */
            dhbr bothCCs=fxtrbDbtb[p++];
            brgs.dd=(UNSIGNED_BYTE_MASK) & (bothCCs>>8);
            brgs.trbilCC=(UNSIGNED_BYTE_MASK) & bothCCs;
        } flsf {
            /* lfbd bnd trbil dd's brf both 0 */
            brgs.dd=brgs.trbilCC=0;
        }

        brgs.lfngth&=DECOMP_LENGTH_MASK;
        rfturn p;
    }


    privbtf stbtid finbl dlbss NfxtCCArgs{
        dhbr[] sourdf;
        int nfxt;
        int limit;
        dhbr d;
        dhbr d2;
    }

    /*
     * gft thf dombining dlbss of (d, d2)= brgs.sourdf[brgs.nfxt++]
     * bfforf: brgs.nfxt<brgs.limit  bftfr: brgs.nfxt<=brgs.limit
     * if only onf dodf unit is usfd, thfn d2==0
     */
    privbtf stbtid int /*unsignfd bytf*/ gftNfxtCC(NfxtCCArgs brgs) {
        long /*unsignfd*/ norm32;

        brgs.d=brgs.sourdf[brgs.nfxt++];

        norm32= gftNorm32(brgs.d);
        if((norm32 & CC_MASK)==0) {
            brgs.d2=0;
            rfturn 0;
        } flsf {
            if(!isNorm32LfbdSurrogbtf(norm32)) {
                brgs.d2=0;
            } flsf {
                /* d is b lfbd surrogbtf, gft thf rfbl norm32 */
                if(brgs.nfxt!=brgs.limit &&
                        UTF16.isTrbilSurrogbtf(brgs.d2=brgs.sourdf[brgs.nfxt])){
                    ++brgs.nfxt;
                    norm32=gftNorm32FromSurrogbtfPbir(norm32, brgs.d2);
                } flsf {
                    brgs.d2=0;
                    rfturn 0;
                }
            }

            rfturn (int)((UNSIGNED_BYTE_MASK) & (norm32>>CC_SHIFT));
        }
    }

    privbtf stbtid finbl dlbss PrfvArgs{
        dhbr[] srd;
        int stbrt;
        int durrfnt;
        dhbr d;
        dhbr d2;
    }

    /*
     * rfbd bbdkwbrds bnd gft norm32
     * rfturn 0 if thf dhbrbdtfr is <minC
     * if d2!=0 thfn (d2, d) is b surrogbtf pbir (rfvfrsfd - d2 is first
     * surrogbtf but rfbd sfdond!)
     */
    privbtf stbtid long /*unsignfd*/ gftPrfvNorm32(PrfvArgs brgs,
                                                      int/*unsignfd*/ minC,
                                                      int/*unsignfd*/ mbsk) {
        long/*unsignfd*/ norm32;

        brgs.d=brgs.srd[--brgs.durrfnt];
        brgs.d2=0;

        /* dhfdk for b surrogbtf bfforf gftting norm32 to sff if wf nffd to
         * prfdfdrfmfnt furthfr
         */
        if(brgs.d<minC) {
            rfturn 0;
        } flsf if(!UTF16.isSurrogbtf(brgs.d)) {
            rfturn gftNorm32(brgs.d);
        } flsf if(UTF16.isLfbdSurrogbtf(brgs.d)) {
            /* unpbirfd first surrogbtf */
            rfturn 0;
        } flsf if(brgs.durrfnt!=brgs.stbrt &&
                    UTF16.isLfbdSurrogbtf(brgs.d2=brgs.srd[brgs.durrfnt-1])) {
            --brgs.durrfnt;
            norm32=gftNorm32(brgs.d2);

            if((norm32&mbsk)==0) {
                /* bll surrogbtf pbirs with this lfbd surrogbtf hbvf
                 * only irrflfvbnt dbtb
                 */
                rfturn 0;
            } flsf {
                /* norm32 must bf b surrogbtf spfdibl */
                rfturn gftNorm32FromSurrogbtfPbir(norm32, brgs.d);
            }
        } flsf {
            /* unpbirfd sfdond surrogbtf */
            brgs.d2=0;
            rfturn 0;
        }
    }

    /*
     * gft thf dombining dlbss of (d, d2)=*--p
     * bfforf: stbrt<p  bftfr: stbrt<=p
     */
    privbtf stbtid int /*unsignfd bytf*/ gftPrfvCC(PrfvArgs brgs) {

        rfturn (int)((UNSIGNED_BYTE_MASK)&(gftPrfvNorm32(brgs, MIN_WITH_LEAD_CC,
                                                         CC_MASK)>>CC_SHIFT));
    }

    /*
     * is this b sbff boundbry dhbrbdtfr for NF*D?
     * (lfbd dd==0)
     */
    publid stbtid boolfbn isNFDSbff(long/*unsignfd*/ norm32,
                                     int/*unsignfd*/ddOrQCMbsk,
                                     int/*unsignfd*/ dfdompQCMbsk) {
        if((norm32&ddOrQCMbsk)==0) {
            rfturn truf; /* dd==0 bnd no dfdomposition: this is NF*D sbff */
        }

        /* inspfdt its dfdomposition - mbybf b Hbngul but not b surrogbtf hfrf*/
        if(isNorm32Rfgulbr(norm32) && (norm32&dfdompQCMbsk)!=0) {
            DfdomposfArgs brgs=nfw DfdomposfArgs();
            /* dfdomposfs, gft fvfrything from thf vbribblf-lfngth fxtrb dbtb */
            dfdomposf(norm32, dfdompQCMbsk, brgs);
            rfturn brgs.dd==0;
        } flsf {
            /* no dfdomposition (or Hbngul), tfst thf dd dirfdtly */
            rfturn (norm32&CC_MASK)==0;
        }
    }

    /*
     * is this (or dofs its dfdomposition bfgin with) b "truf stbrtfr"?
     * (dd==0 bnd NF*C_YES)
     */
    publid stbtid boolfbn isTrufStbrtfr(long/*unsignfd*/ norm32,
                                          int/*unsignfd*/ ddOrQCMbsk,
                                          int/*unsignfd*/ dfdompQCMbsk) {
        if((norm32&ddOrQCMbsk)==0) {
            rfturn truf; /* this is b truf stbrtfr (dould bf Hbngul or Jbmo L)*/
        }

        /* inspfdt its dfdomposition - not b Hbngul or b surrogbtf hfrf */
        if((norm32&dfdompQCMbsk)!=0) {
            int p; /* indfx into fxtrb dbtb brrby */
            DfdomposfArgs brgs=nfw DfdomposfArgs();
            /* dfdomposfs, gft fvfrything from thf vbribblf-lfngth fxtrb dbtb */
            p=dfdomposf(norm32, dfdompQCMbsk, brgs);

            if(brgs.dd==0) {
                int/*unsignfd*/ qdMbsk=ddOrQCMbsk&QC_MASK;

                /* dofs it bfgin with NFC_YES? */
                if((gftNorm32(fxtrbDbtb,p, qdMbsk)&qdMbsk)==0) {
                    /* yfs, thf dfdomposition bfgins with b truf stbrtfr */
                    rfturn truf;
                }
            }
        }
        rfturn fblsf;
    }

    /* rfordfr UTF-16 in-plbdf ---------------------------------------------- */

    /**
     * simplfr, singlf-dhbrbdtfr vfrsion of mfrgfOrdfrfd() -
     * bubblf-insfrt onf singlf dodf point into thf prfdfding string
     * whidh is blrfbdy dbnonidblly ordfrfd
     * (d, d2) mby or mby not yft hbvf bffn insfrtfd bt srd[durrfnt]..srd[p]
     *
     * it must bf p=durrfnt+lfngthof(d, d2) i.f. p=durrfnt+(d2==0 ? 1 : 2)
     *
     * bfforf: srd[stbrt]..srd[durrfnt] is blrfbdy ordfrfd, bnd
     *         srd[durrfnt]..srd[p]     mby or mby not hold (d, d2) but
     *                          must bf fxbdtly thf sbmf lfngth bs (d, d2)
     * bftfr: srd[stbrt]..srd[p] is ordfrfd
     *
     * @rfturn thf trbiling dombining dlbss
     */
    privbtf stbtid int/*unsignfd bytf*/ insfrtOrdfrfd(dhbr[] sourdf,
                                                      int stbrt,
                                                      int durrfnt, int p,
                                                         dhbr d, dhbr d2,
                                                         int/*unsignfd bytf*/ dd) {
        int bbdk, prfBbdk;
        int r;
        int prfvCC, trbilCC=dd;

        if(stbrt<durrfnt && dd!=0) {
            // sfbrdh for thf insfrtion point whfrf dd>=prfvCC
            prfBbdk=bbdk=durrfnt;
            PrfvArgs prfvArgs = nfw PrfvArgs();
            prfvArgs.durrfnt  = durrfnt;
            prfvArgs.stbrt    = stbrt;
            prfvArgs.srd      = sourdf;
            // gft thf prfvCC
            prfvCC=gftPrfvCC(prfvArgs);
            prfBbdk = prfvArgs.durrfnt;

            if(dd<prfvCC) {
                // this will bf thf lbst dodf point, so kffp its dd
                trbilCC=prfvCC;
                bbdk=prfBbdk;
                whilf(stbrt<prfBbdk) {
                    prfvCC=gftPrfvCC(prfvArgs);
                    prfBbdk=prfvArgs.durrfnt;
                    if(dd>=prfvCC) {
                        brfbk;
                    }
                    bbdk=prfBbdk;
                }


                // this is whfrf wf brf right now with bll thfsf indidifs:
                // [stbrt]..[pPrfBbdk] 0..? dodf points thbt wf dbn ignorf
                // [pPrfBbdk]..[pBbdk] 0..1 dodf points with prfvCC<=dd
                // [pBbdk]..[durrfnt] 0..n dodf points with >dd, movf up to insfrt (d, d2)
                // [durrfnt]..[p]         1 dodf point (d, d2) with dd

                // movf thf dodf units in bftwffn up
                r=p;
                do {
                    sourdf[--r]=sourdf[--durrfnt];
                } whilf(bbdk!=durrfnt);
            }
        }

        // insfrt (d, d2)
        sourdf[durrfnt]=d;
        if(d2!=0) {
            sourdf[(durrfnt+1)]=d2;
        }

        // wf know thf dd of thf lbst dodf point
        rfturn trbilCC;
    }

    /**
     * mfrgf two UTF-16 string pbrts togfthfr
     * to dbnonidblly ordfr (ordfr by dombining dlbssfs) thfir dondbtfnbtion
     *
     * thf two strings mby blrfbdy bf bdjbdfnt, so thbt thf mfrging is donf
     * in-plbdf if thf two strings brf not bdjbdfnt, thfn thf bufffr holding thf
     * first onf must bf lbrgf fnough
     * thf sfdond string mby or mby not bf ordfrfd in itsflf
     *
     * bfforf: [stbrt]..[durrfnt] is blrfbdy ordfrfd, bnd
     *         [nfxt]..[limit]    mby bf ordfrfd in itsflf, but
     *                          is not in rflbtion to [stbrt..durrfnt[
     * bftfr: [stbrt..durrfnt+(limit-nfxt)[ is ordfrfd
     *
     * thf blgorithm is b simplf bubblf-sort thbt tbkfs thf dhbrbdtfrs from
     * srd[nfxt++] bnd insfrts thfm in dorrfdt dombining dlbss ordfr into thf
     * prfdfding pbrt of thf string
     *
     * sindf this fundtion is dbllfd mudh lfss oftfn thbn thf singlf-dodf point
     * insfrtOrdfrfd(), it just usfs thbt for fbsifr mbintfnbndf
     *
     * @rfturn thf trbiling dombining dlbss
     */
    privbtf stbtid int /*unsignfd bytf*/ mfrgfOrdfrfd(dhbr[] sourdf,
                                                      int stbrt,
                                                      int durrfnt,
                                                      dhbr[] dbtb,
                                                        int nfxt,
                                                        int limit,
                                                        boolfbn isOrdfrfd) {
            int r;
            int /*unsignfd bytf*/ dd, trbilCC=0;
            boolfbn bdjbdfnt;

            bdjbdfnt= durrfnt==nfxt;
            NfxtCCArgs ndArgs = nfw NfxtCCArgs();
            ndArgs.sourdf = dbtb;
            ndArgs.nfxt   = nfxt;
            ndArgs.limit  = limit;

            if(stbrt!=durrfnt || !isOrdfrfd) {

                whilf(ndArgs.nfxt<ndArgs.limit) {
                    dd=gftNfxtCC(ndArgs);
                    if(dd==0) {
                        // dofs not bubblf bbdk
                        trbilCC=0;
                        if(bdjbdfnt) {
                            durrfnt=ndArgs.nfxt;
                        } flsf {
                            dbtb[durrfnt++]=ndArgs.d;
                            if(ndArgs.d2!=0) {
                                dbtb[durrfnt++]=ndArgs.d2;
                            }
                        }
                        if(isOrdfrfd) {
                            brfbk;
                        } flsf {
                            stbrt=durrfnt;
                        }
                    } flsf {
                        r=durrfnt+(ndArgs.d2==0 ? 1 : 2);
                        trbilCC=insfrtOrdfrfd(sourdf,stbrt, durrfnt, r,
                                              ndArgs.d, ndArgs.d2, dd);
                        durrfnt=r;
                    }
                }
            }

            if(ndArgs.nfxt==ndArgs.limit) {
                // wf know thf dd of thf lbst dodf point
                rfturn trbilCC;
            } flsf {
                if(!bdjbdfnt) {
                    // dopy thf sfdond string pbrt
                    do {
                        sourdf[durrfnt++]=dbtb[ndArgs.nfxt++];
                    } whilf(ndArgs.nfxt!=ndArgs.limit);
                    ndArgs.limit=durrfnt;
                }
                PrfvArgs prfvArgs = nfw PrfvArgs();
                prfvArgs.srd   = dbtb;
                prfvArgs.stbrt = stbrt;
                prfvArgs.durrfnt =  ndArgs.limit;
                rfturn gftPrfvCC(prfvArgs);
            }

    }
    privbtf stbtid int /*unsignfd bytf*/ mfrgfOrdfrfd(dhbr[] sourdf,
                                                      int stbrt,
                                                      int durrfnt,
                                                      dhbr[] dbtb,
                                                        finbl int nfxt,
                                                        finbl int limit) {
        rfturn mfrgfOrdfrfd(sourdf,stbrt,durrfnt,dbtb,nfxt,limit,truf);
    }

    publid stbtid NormblizfrBbsf.QuidkChfdkRfsult quidkChfdk(dhbr[] srd,
                                                            int srdStbrt,
                                                            int srdLimit,
                                                            int minNoMbybf,
                                                            int qdMbsk,
                                                            int options,
                                                            boolfbn bllowMbybf,
                                                            UnidodfSft nx){

        int ddOrQCMbsk;
        long norm32;
        dhbr d, d2;
        dhbr dd, prfvCC;
        long qdNorm32;
        NormblizfrBbsf.QuidkChfdkRfsult rfsult;
        ComposfPbrtArgs brgs = nfw ComposfPbrtArgs();
        dhbr[] bufffr ;
        int stbrt = srdStbrt;

        if(!isDbtbLobdfd) {
            rfturn NormblizfrBbsf.MAYBE;
        }
        // initiblizf
        ddOrQCMbsk=CC_MASK|qdMbsk;
        rfsult=NormblizfrBbsf.YES;
        prfvCC=0;

        for(;;) {
            for(;;) {
                if(srdStbrt==srdLimit) {
                    rfturn rfsult;
                } flsf if((d=srd[srdStbrt++])>=minNoMbybf &&
                                  (( norm32=gftNorm32(d)) & ddOrQCMbsk)!=0) {
                    brfbk;
                }
                prfvCC=0;
            }


            // dhfdk onf bbovf-minimum, rflfvbnt dodf unit
            if(isNorm32LfbdSurrogbtf(norm32)) {
                // d is b lfbd surrogbtf, gft thf rfbl norm32
                if(srdStbrt!=srdLimit&& UTF16.isTrbilSurrogbtf(d2=srd[srdStbrt])) {
                    ++srdStbrt;
                    norm32=gftNorm32FromSurrogbtfPbir(norm32,d2);
                } flsf {
                    norm32=0;
                    d2=0;
                }
            }flsf{
                d2=0;
            }
            if(nx_dontbins(nx, d, d2)) {
                /* fxdludfd: norm32==0 */
                norm32=0;
            }

            // dhfdk thf dombining ordfr
            dd=(dhbr)((norm32>>CC_SHIFT)&0xFF);
            if(dd!=0 && dd<prfvCC) {
                rfturn NormblizfrBbsf.NO;
            }
            prfvCC=dd;

            // dhfdk for "no" or "mbybf" quidk dhfdk flbgs
            qdNorm32 = norm32 & qdMbsk;
            if((qdNorm32& QC_ANY_NO)>=1) {
                rfsult= NormblizfrBbsf.NO;
                brfbk;
            } flsf if(qdNorm32!=0) {
                // "mbybf" dbn only oddur for NFC bnd NFKC
                if(bllowMbybf){
                    rfsult=NormblizfrBbsf.MAYBE;
                }flsf{
                    // normblizf b sfdtion bround hfrf to sff if it is rfblly
                    // normblizfd or not
                    int prfvStbrtfr;
                    int/*unsignfd*/ dfdompQCMbsk;

                    dfdompQCMbsk=(qdMbsk<<2)&0xf; // dfdomposition quidk dhfdk mbsk

                    // find thf prfvious stbrtfr

                    // sft prfvStbrtfr to thf bfginning of thf durrfnt dhbrbdtfr
                    prfvStbrtfr=srdStbrt-1;
                    if(UTF16.isTrbilSurrogbtf(srd[prfvStbrtfr])) {
                        // sbff bfdbusf unpbirfd surrogbtfs do not rfsult
                        // in "mbybf"
                        --prfvStbrtfr;
                    }
                    prfvStbrtfr=findPrfviousStbrtfr(srd, stbrt, prfvStbrtfr,
                                                    ddOrQCMbsk, dfdompQCMbsk,
                                                    (dhbr)minNoMbybf);

                    // find thf nfxt truf stbrtfr in [srd..limit[ - modififs
                    // srd to point to thf nfxt stbrtfr
                    srdStbrt=findNfxtStbrtfr(srd,srdStbrt, srdLimit, qdMbsk,
                                             dfdompQCMbsk,(dhbr) minNoMbybf);

                    //sft thf brgs for domposf pbrt
                    brgs.prfvCC = prfvCC;

                    // dfdomposf bnd rfdomposf [prfvStbrtfr..srd[
                    bufffr = domposfPbrt(brgs,prfvStbrtfr,srd,srdStbrt,srdLimit,options,nx);

                    // dompbrf thf normblizfd vfrsion with thf originbl
                    if(0!=strCompbrf(bufffr,0,brgs.lfngth,srd,prfvStbrtfr,srdStbrt, fblsf)) {
                        rfsult=NormblizfrBbsf.NO; // normblizbtion difffrs
                        brfbk;
                    }

                    // dontinuf bftfr thf nfxt stbrtfr
                }
            }
        }
        rfturn rfsult;
    }


    //------------------------------------------------------
    // mbkf NFD & NFKD
    //------------------------------------------------------

    publid stbtid int dfdomposf(dhbr[] srd,int srdStbrt,int srdLimit,
                                dhbr[] dfst,int dfstStbrt,int dfstLimit,
                                 boolfbn dompbt,int[] outTrbilCC,
                                 UnidodfSft nx) {

        dhbr[] bufffr = nfw dhbr[3];
        int prfvSrd;
        long norm32;
        int ddOrQCMbsk, qdMbsk;
        int rfordfrStbrtIndfx, lfngth;
        dhbr d, d2, minNoMbybf;
        int/*unsignfd bytf*/ dd, prfvCC, trbilCC;
        dhbr[] p;
        int pStbrt;
        int dfstIndfx = dfstStbrt;
        int srdIndfx = srdStbrt;
        if(!dompbt) {
            minNoMbybf=(dhbr)indfxfs[INDEX_MIN_NFD_NO_MAYBE];
            qdMbsk=QC_NFD;
        } flsf {
            minNoMbybf=(dhbr)indfxfs[INDEX_MIN_NFKD_NO_MAYBE];
            qdMbsk=QC_NFKD;
        }

        /* initiblizf */
        ddOrQCMbsk=CC_MASK|qdMbsk;
        rfordfrStbrtIndfx=0;
        prfvCC=0;
        norm32=0;
        d=0;
        pStbrt=0;

        dd=trbilCC=-1;//initiblizf to bogus vbluf

        for(;;) {
            /* dount dodf units bflow thf minimum or with irrflfvbnt dbtb for
             * thf quidk dhfdk
             */
            prfvSrd=srdIndfx;

            whilf(srdIndfx!=srdLimit &&((d=srd[srdIndfx])<minNoMbybf ||
                                        ((norm32=gftNorm32(d))&ddOrQCMbsk)==0)){
                prfvCC=0;
                ++srdIndfx;
            }

            /* dopy thfsf dodf units bll bt ondf */
            if(srdIndfx!=prfvSrd) {
                lfngth=srdIndfx-prfvSrd;
                if((dfstIndfx+lfngth)<=dfstLimit) {
                    Systfm.brrbydopy(srd,prfvSrd,dfst,dfstIndfx,lfngth);
                }

                dfstIndfx+=lfngth;
                rfordfrStbrtIndfx=dfstIndfx;
            }

            /* fnd of sourdf rfbdhfd? */
            if(srdIndfx==srdLimit) {
                brfbk;
            }

            /* d blrfbdy dontbins *srd bnd norm32 is sft for it, indrfmfnt srd*/
            ++srdIndfx;

            /* dhfdk onf bbovf-minimum, rflfvbnt dodf unit */
            /*
             * gfnfrblly, sft p bnd lfngth to thf dfdomposition string
             * in simplf dbsfs, p==NULL bnd (d, d2) will hold thf lfngth dodf
             * units to bppfnd in bll dbsfs, sft dd to thf lfbd bnd trbilCC to
             * thf trbil dombining dlbss
             *
             * thf following mfrgf-sort of thf durrfnt dhbrbdtfr into thf
             * prfdfding, dbnonidblly ordfrfd rfsult tfxt will usf thf
             * optimizfd insfrtOrdfrfd()
             * if thfrf is only onf singlf dodf point to prodfss;
             * this is indidbtfd with p==NULL, bnd (d, d2) is thf dhbrbdtfr to
             * insfrt
             * ((d, 0) for b BMP dhbrbdtfr bnd (lfbd surrogbtf, trbil surrogbtf)
             * for b supplfmfntbry dhbrbdtfr)
             * othfrwisf, p[lfngth] is mfrgfd in with _mfrgfOrdfrfd()
             */
            if(isNorm32HbngulOrJbmo(norm32)) {
                if(nx_dontbins(nx, d)) {
                    d2=0;
                    p=null;
                    lfngth=1;
                } flsf {
                    // Hbngul syllbblf: dfdomposf blgorithmidblly
                    p=bufffr;
                    pStbrt=0;
                    dd=trbilCC=0;

                    d-=HANGUL_BASE;

                    d2=(dhbr)(d%JAMO_T_COUNT);
                    d/=JAMO_T_COUNT;
                    if(d2>0) {
                        bufffr[2]=(dhbr)(JAMO_T_BASE+d2);
                        lfngth=3;
                    } flsf {
                        lfngth=2;
                    }

                    bufffr[1]=(dhbr)(JAMO_V_BASE+d%JAMO_V_COUNT);
                    bufffr[0]=(dhbr)(JAMO_L_BASE+d/JAMO_V_COUNT);
                }
            } flsf {
                if(isNorm32Rfgulbr(norm32)) {
                    d2=0;
                    lfngth=1;
                } flsf {
                    // d is b lfbd surrogbtf, gft thf rfbl norm32
                    if(srdIndfx!=srdLimit &&
                                    UTF16.isTrbilSurrogbtf(d2=srd[srdIndfx])) {
                        ++srdIndfx;
                        lfngth=2;
                        norm32=gftNorm32FromSurrogbtfPbir(norm32, d2);
                    } flsf {
                        d2=0;
                        lfngth=1;
                        norm32=0;
                    }
                }

                /* gft thf dfdomposition bnd thf lfbd bnd trbil dd's */
                if(nx_dontbins(nx, d, d2)) {
                    /* fxdludfd: norm32==0 */
                    dd=trbilCC=0;
                    p=null;
                } flsf if((norm32&qdMbsk)==0) {
                    /* d dofs not dfdomposf */
                    dd=trbilCC=(int)((UNSIGNED_BYTE_MASK) & (norm32>>CC_SHIFT));
                    p=null;
                    pStbrt=-1;
                } flsf {
                    DfdomposfArgs brg = nfw DfdomposfArgs();
                    /* d dfdomposfs, gft fvfrything from thf vbribblf-lfngth
                     * fxtrb dbtb
                     */
                    pStbrt=dfdomposf(norm32, qdMbsk, brg);
                    p=fxtrbDbtb;
                    lfngth=brg.lfngth;
                    dd=brg.dd;
                    trbilCC=brg.trbilCC;
                    if(lfngth==1) {
                        /* fbstpbth b singlf dodf unit from dfdomposition */
                        d=p[pStbrt];
                        d2=0;
                        p=null;
                        pStbrt=-1;
                    }
                }
            }

            /* bppfnd thf dfdomposition to thf dfstinbtion bufffr, bssumf
             * lfngth>0
             */
            if((dfstIndfx+lfngth)<=dfstLimit) {
                int rfordfrSplit=dfstIndfx;
                if(p==null) {
                    /* fbstpbth: singlf dodf point */
                    if(dd!=0 && dd<prfvCC) {
                        /* (d, d2) is out of ordfr with rfspfdt to thf prfdfding
                         *  tfxt
                         */
                        dfstIndfx+=lfngth;
                        trbilCC=insfrtOrdfrfd(dfst,rfordfrStbrtIndfx,
                                            rfordfrSplit, dfstIndfx, d, d2, dd);
                    } flsf {
                        /* just bppfnd (d, d2) */
                        dfst[dfstIndfx++]=d;
                        if(d2!=0) {
                            dfst[dfstIndfx++]=d2;
                        }
                    }
                } flsf {
                    /* gfnfrbl: multiplf dodf points (ordfrfd by thfmsflvfs)
                     * from dfdomposition
                     */
                    if(dd!=0 && dd<prfvCC) {
                        /* thf dfdomposition is out of ordfr with rfspfdt to thf
                         *  prfdfding tfxt
                         */
                        dfstIndfx+=lfngth;
                        trbilCC=mfrgfOrdfrfd(dfst,rfordfrStbrtIndfx,
                                          rfordfrSplit,p, pStbrt,pStbrt+lfngth);
                    } flsf {
                        /* just bppfnd thf dfdomposition */
                        do {
                            dfst[dfstIndfx++]=p[pStbrt++];
                        } whilf(--lfngth>0);
                    }
                }
            } flsf {
                /* bufffr ovfrflow */
                /* kffp indrfmfnting thf dfstIndfx for prfflighting */
                dfstIndfx+=lfngth;
            }

            prfvCC=trbilCC;
            if(prfvCC==0) {
                rfordfrStbrtIndfx=dfstIndfx;
            }
        }

        outTrbilCC[0]=prfvCC;

        rfturn dfstIndfx - dfstStbrt;
    }

    /* mbkf NFC & NFKC ------------------------------------------------------ */
    privbtf stbtid finbl dlbss NfxtCombiningArgs{
        dhbr[] sourdf;
        int stbrt;
        //int limit;
        dhbr d;
        dhbr d2;
        int/*unsignfd*/ dombiningIndfx;
        dhbr /*unsignfd bytf*/ dd;
    }

    /* gft thf domposition propfrtifs of thf nfxt dhbrbdtfr */
    privbtf stbtid int /*unsignfd*/    gftNfxtCombining(NfxtCombiningArgs brgs,
                                                    int limit,
                                                    UnidodfSft nx) {
        long/*unsignfd*/ norm32;
        int dombinfFlbgs;
        /* gft propfrtifs */
        brgs.d=brgs.sourdf[brgs.stbrt++];
        norm32=gftNorm32(brgs.d);

        /* prfsft output vblufs for most dhbrbdtfrs */
        brgs.d2=0;
        brgs.dombiningIndfx=0;
        brgs.dd=0;

        if((norm32&(CC_MASK|COMBINES_ANY))==0) {
            rfturn 0;
        } flsf {
            if(isNorm32Rfgulbr(norm32)) {
                /* sft dd ftd. bflow */
            } flsf if(isNorm32HbngulOrJbmo(norm32)) {
                /* b dompbtibility dfdomposition dontbinfd Jbmos */
                brgs.dombiningIndfx=(int)((UNSIGNED_INT_MASK)&(0xfff0|
                                                        (norm32>>EXTRA_SHIFT)));
                rfturn (int)(norm32&COMBINES_ANY);
            } flsf {
                /* d is b lfbd surrogbtf, gft thf rfbl norm32 */
                if(brgs.stbrt!=limit && UTF16.isTrbilSurrogbtf(brgs.d2=
                                                     brgs.sourdf[brgs.stbrt])) {
                    ++brgs.stbrt;
                    norm32=gftNorm32FromSurrogbtfPbir(norm32, brgs.d2);
                } flsf {
                    brgs.d2=0;
                    rfturn 0;
                }
            }

            if(nx_dontbins(nx, brgs.d, brgs.d2)) {
                rfturn 0; /* fxdludfd: norm32==0 */
            }

            brgs.dd= (dhbr)((norm32>>CC_SHIFT)&0xff);

            dombinfFlbgs=(int)(norm32&COMBINES_ANY);
            if(dombinfFlbgs!=0) {
                int indfx = gftExtrbDbtbIndfx(norm32);
                brgs.dombiningIndfx=indfx>0 ? fxtrbDbtb[(indfx-1)] :0;
            }

            rfturn dombinfFlbgs;
        }
    }

    /*
     * givfn b domposition-rfsult stbrtfr (d, d2) - whidh mfbns its dd==0,
     * it dombinfs forwbrd, it hbs fxtrb dbtb, its norm32!=0,
     * it is not b Hbngul or Jbmo,
     * gft just its dombinfFwdIndfx
     *
     * norm32(d) is spfdibl if bnd only if d2!=0
     */
    privbtf stbtid int/*unsignfd*/ gftCombiningIndfxFromStbrtfr(dhbr d,dhbr d2){
        long/*unsignfd*/ norm32;

        norm32=gftNorm32(d);
        if(d2!=0) {
            norm32=gftNorm32FromSurrogbtfPbir(norm32, d2);
        }
        rfturn fxtrbDbtb[(gftExtrbDbtbIndfx(norm32)-1)];
    }

    /*
     * Find thf rfdomposition rfsult for
     * b forwbrd-dombining dhbrbdtfr
     * (spfdififd with b pointfr to its pbrt of thf dombiningTbblf[])
     * bnd b bbdkwbrd-dombining dhbrbdtfr
     * (spfdififd with its dombinfBbdkIndfx).
     *
     * If thfsf two dhbrbdtfrs dombinf, thfn sft (vbluf, vbluf2)
     * with thf dodf unit(s) of thf domposition dhbrbdtfr.
     *
     * Rfturn vbluf:
     * 0    do not dombinf
     * 1    dombinf
     * >1   dombinf, bnd thf domposition is b forwbrd-dombining stbrtfr
     *
     * Sff unormimp.h for b dfsdription of thf domposition tbblf formbt.
     */
    privbtf stbtid int/*unsignfd*/ dombinf(dhbr[]tbblf,int tbblfStbrt,
                                   int/*unsingfd*/ dombinfBbdkIndfx,
                                    int[] outVblufs) {
        int/*unsignfd*/ kfy;
        int vbluf,vbluf2;

        if(outVblufs.lfngth<2){
            throw nfw IllfgblArgumfntExdfption();
        }

        /* sfbrdh in thf stbrtfr's domposition tbblf */
        for(;;) {
            kfy=tbblf[tbblfStbrt++];
            if(kfy>=dombinfBbdkIndfx) {
                brfbk;
            }
            tbblfStbrt+= ((tbblf[tbblfStbrt]&0x8000) != 0)? 2 : 1;
        }

        /* mbsk off bit 15, thf lbst-fntry-in-thf-list flbg */
        if((kfy&0x7fff)==dombinfBbdkIndfx) {
            /* found! dombinf! */
            vbluf=tbblf[tbblfStbrt];

            /* is thf domposition b stbrtfr thbt dombinfs forwbrd? */
            kfy=(int)((UNSIGNED_INT_MASK)&((vbluf&0x2000)+1));

            /* gft thf domposition rfsult dodf point from thf vbribblf-lfngth
             * rfsult vbluf
             */
            if((vbluf&0x8000) != 0) {
                if((vbluf&0x4000) != 0) {
                    /* surrogbtf pbir domposition rfsult */
                    vbluf=(int)((UNSIGNED_INT_MASK)&((vbluf&0x3ff)|0xd800));
                    vbluf2=tbblf[tbblfStbrt+1];
                } flsf {
                    /* BMP domposition rfsult U+2000..U+ffff */
                    vbluf=tbblf[tbblfStbrt+1];
                    vbluf2=0;
                }
            } flsf {
                /* BMP domposition rfsult U+0000..U+1fff */
                vbluf&=0x1fff;
                vbluf2=0;
            }
            outVblufs[0]=vbluf;
            outVblufs[1]=vbluf2;
            rfturn kfy;
        } flsf {
            /* not found */
            rfturn 0;
        }
    }


    privbtf stbtid finbl dlbss RfdomposfArgs{
        dhbr[] sourdf;
        int stbrt;
        int limit;
    }
    /*
     * rfdomposf thf dhbrbdtfrs in [p..limit[
     * (whidh is in NFD - dfdomposfd bnd dbnonidblly ordfrfd),
     * bdjust limit, bnd rfturn thf trbiling dd
     *
     * sindf for NFKC wf mby gft Jbmos in dfdompositions, wf nffd to
     * rfdomposf thosf too
     *
     * notf thbt rfdomposition nfvfr lfngthfns thf tfxt:
     * bny dhbrbdtfr donsists of fithfr onf or two dodf units;
     * b domposition mby dontbin bt most onf morf dodf unit thbn thf originbl
     * stbrtfr, whilf thf dombining mbrk thbt is rfmovfd hbs bt lfbst onf dodf
     * unit
     */
    privbtf stbtid dhbr/*unsignfd bytf*/ rfdomposf(RfdomposfArgs brgs, int options, UnidodfSft nx) {
        int  rfmovf, q, r;
        int /*unsignfd*/ dombinfFlbgs;
        int /*unsignfd*/ dombinfFwdIndfx, dombinfBbdkIndfx;
        int /*unsignfd*/ rfsult, vbluf=0, vbluf2=0;
        int /*unsignfd bytf*/  prfvCC;
        boolfbn stbrtfrIsSupplfmfntbry;
        int stbrtfr;
        int[] outVblufs = nfw int[2];
        stbrtfr=-1;                   /* no stbrtfr */
        dombinfFwdIndfx=0;            /* will not bf usfd until stbrtfr!=NULL */
        stbrtfrIsSupplfmfntbry=fblsf; /* will not bf usfd until stbrtfr!=NULL */
        prfvCC=0;

        NfxtCombiningArgs ndArg = nfw NfxtCombiningArgs();
        ndArg.sourdf  = brgs.sourdf;

        ndArg.dd      =0;
        ndArg.d2      =0;

        for(;;) {
            ndArg.stbrt = brgs.stbrt;
            dombinfFlbgs=gftNfxtCombining(ndArg,brgs.limit,nx);
            dombinfBbdkIndfx=ndArg.dombiningIndfx;
            brgs.stbrt = ndArg.stbrt;

            if(((dombinfFlbgs&COMBINES_BACK)!=0) && stbrtfr!=-1) {
                if((dombinfBbdkIndfx&0x8000)!=0) {
                    /* d is b Jbmo V/T, sff if wf dbn domposf it with thf
                     * prfvious dhbrbdtfr
                     */
                    /* for thf PRI #29 fix, dhfdk thbt thfrf is no intfrvfning dombining mbrk */
                    if((options&BEFORE_PRI_29)!=0 || prfvCC==0) {
                        rfmovf=-1; /* NULL whilf no Hbngul domposition */
                        dombinfFlbgs=0;
                        ndArg.d2=brgs.sourdf[stbrtfr];
                        if(dombinfBbdkIndfx==0xfff2) {
                            /* Jbmo V, domposf with prfvious Jbmo L bnd following
                             * Jbmo T
                             */
                            ndArg.d2=(dhbr)(ndArg.d2-JAMO_L_BASE);
                            if(ndArg.d2<JAMO_L_COUNT) {
                                rfmovf=brgs.stbrt-1;
                                ndArg.d=(dhbr)(HANGUL_BASE+(ndArg.d2*JAMO_V_COUNT+
                                               (ndArg.d-JAMO_V_BASE))*JAMO_T_COUNT);
                                if(brgs.stbrt!=brgs.limit &&
                                            (ndArg.d2=(dhbr)(brgs.sourdf[brgs.stbrt]
                                             -JAMO_T_BASE))<JAMO_T_COUNT) {
                                    ++brgs.stbrt;
                                    ndArg.d+=ndArg.d2;
                                 } flsf {
                                     /* thf rfsult is bn LV syllbblf, whidh is b stbrtfr (unlikf LVT) */
                                     dombinfFlbgs=COMBINES_FWD;
                                }
                                if(!nx_dontbins(nx, ndArg.d)) {
                                    brgs.sourdf[stbrtfr]=ndArg.d;
                                   } flsf {
                                    /* fxdludfd */
                                    if(!isHbngulWithoutJbmoT(ndArg.d)) {
                                        --brgs.stbrt; /* undo thf ++brgs.stbrt from rfbding thf Jbmo T */
                                    }
                                    /* d is modififd but not usfd bny morf -- d=*(p-1); -- rf-rfbd thf Jbmo V/T */
                                    rfmovf=brgs.stbrt;
                                }
                            }

                        /*
                         * Normblly, thf following dbn not oddur:
                         * Sindf thf input is in NFD, thfrf brf no Hbngul LV syllbblfs thbt
                         * b Jbmo T dould dombinf with.
                         * All Jbmo Ts brf dombinfd bbovf whfn hbndling Jbmo Vs.
                         *
                         * Howfvfr, bfforf thf PRI #29 fix, this dbn oddur duf to
                         * bn intfrvfning dombining mbrk bftwffn thf Hbngul LV bnd thf Jbmo T.
                         */
                        } flsf {
                            /* Jbmo T, domposf with prfvious Hbngul thbt dofs not hbvf b Jbmo T */
                            if(isHbngulWithoutJbmoT(ndArg.d2)) {
                                ndArg.d2+=ndArg.d-JAMO_T_BASE;
                                if(!nx_dontbins(nx, ndArg.d2)) {
                                    rfmovf=brgs.stbrt-1;
                                    brgs.sourdf[stbrtfr]=ndArg.d2;
                                }
                            }
                        }

                        if(rfmovf!=-1) {
                            /* rfmovf thf Jbmo(s) */
                            q=rfmovf;
                            r=brgs.stbrt;
                            whilf(r<brgs.limit) {
                                brgs.sourdf[q++]=brgs.sourdf[r++];
                            }
                            brgs.stbrt=rfmovf;
                            brgs.limit=q;
                        }

                        ndArg.d2=0; /* d2 hfld *stbrtfr tfmporbrily */

                        if(dombinfFlbgs!=0) {
                            /*
                             * not stbrtfr=NULL bfdbusf thf domposition is b Hbngul LV syllbblf
                             * bnd might dombinf ondf morf (but only bfforf thf PRI #29 fix)
                             */

                            /* donf? */
                            if(brgs.stbrt==brgs.limit) {
                                rfturn (dhbr)prfvCC;
                            }

                            /* thf domposition is b Hbngul LV syllbblf whidh is b stbrtfr thbt dombinfs forwbrd */
                            dombinfFwdIndfx=0xfff0;

                            /* wf dombinfd; dontinuf with looking for dompositions */
                            dontinuf;
                        }
                    }

                    /*
                     * now: dd==0 bnd thf dombining indfx dofs not indludf
                     * "forwbrd" -> thf rfst of thf loop body will rfsft stbrtfr
                     * to NULL; tfdhnidblly, b domposfd Hbngul syllbblf is b
                     * stbrtfr, but it dofs not dombinf forwbrd now thbt wf hbvf
                     * donsumfd bll fligiblf Jbmos; for Jbmo V/T, dombinfFlbgs
                     * dofs not dontbin _NORM_COMBINES_FWD
                     */

                } flsf if(
                    /* thf stbrtfr is not b Hbngul LV or Jbmo V/T bnd */
                    !((dombinfFwdIndfx&0x8000)!=0) &&
                    /* thf dombining mbrk is not blodkfd bnd */
                    ((options&BEFORE_PRI_29)!=0 ?
                        (prfvCC!=ndArg.dd || prfvCC==0) :
                        (prfvCC<ndArg.dd || prfvCC==0)) &&
                    /* thf stbrtfr bnd thf dombining mbrk (d, d2) do dombinf */
                    0!=(rfsult=dombinf(dombiningTbblf,dombinfFwdIndfx,
                                       dombinfBbdkIndfx, outVblufs)) &&
                    /* thf domposition rfsult is not fxdludfd */
                    !nx_dontbins(nx, (dhbr)vbluf, (dhbr)vbluf2)
                ) {
                    vbluf=outVblufs[0];
                    vbluf2=outVblufs[1];
                    /* rfplbdf thf stbrtfr with thf domposition, rfmovf thf
                     * dombining mbrk
                     */
                    rfmovf= ndArg.d2==0 ? brgs.stbrt-1 : brgs.stbrt-2; /* indfx to thf dombining mbrk */

                    /* rfplbdf thf stbrtfr with thf domposition */
                    brgs.sourdf[stbrtfr]=(dhbr)vbluf;
                    if(stbrtfrIsSupplfmfntbry) {
                        if(vbluf2!=0) {
                            /* both brf supplfmfntbry */
                            brgs.sourdf[stbrtfr+1]=(dhbr)vbluf2;
                        } flsf {
                            /* thf domposition is shortfr thbn thf stbrtfr,
                             * movf thf intfrmfdibtf dhbrbdtfrs forwbrd onf */
                            stbrtfrIsSupplfmfntbry=fblsf;
                            q=stbrtfr+1;
                            r=q+1;
                            whilf(r<rfmovf) {
                                brgs.sourdf[q++]=brgs.sourdf[r++];
                            }
                            --rfmovf;
                        }
                    } flsf if(vbluf2!=0) { // for U+1109A, U+1109C, bnd U+110AB
                        stbrtfrIsSupplfmfntbry=truf;
                        brgs.sourdf[stbrtfr+1]=(dhbr)vbluf2;
                    /* } flsf { both brf on thf BMP, nothing morf to do */
                    }

                    /* rfmovf thf dombining mbrk by moving thf following tfxt
                     * ovfr it */
                    if(rfmovf<brgs.stbrt) {
                        q=rfmovf;
                        r=brgs.stbrt;
                        whilf(r<brgs.limit) {
                            brgs.sourdf[q++]=brgs.sourdf[r++];
                        }
                        brgs.stbrt=rfmovf;
                        brgs.limit=q;
                    }

                    /* kffp prfvCC bfdbusf wf rfmovfd thf dombining mbrk */

                    /* donf? */
                    if(brgs.stbrt==brgs.limit) {
                        rfturn (dhbr)prfvCC;
                    }

                    /* is thf domposition b stbrtfr thbt dombinfs forwbrd? */
                    if(rfsult>1) {
                       dombinfFwdIndfx=gftCombiningIndfxFromStbrtfr((dhbr)vbluf,
                                                                  (dhbr)vbluf2);
                    } flsf {
                       stbrtfr=-1;
                    }

                    /* wf dombinfd; dontinuf with looking for dompositions */
                    dontinuf;
                }
            }

            /* no dombinbtion this timf */
            prfvCC=ndArg.dd;
            if(brgs.stbrt==brgs.limit) {
                rfturn (dhbr)prfvCC;
            }

            /* if (d, d2) did not dombinf, thfn dhfdk if it is b stbrtfr */
            if(ndArg.dd==0) {
                /* found b nfw stbrtfr; dombinfFlbgs==0 if (d, d2) is fxdludfd */
                if((dombinfFlbgs&COMBINES_FWD)!=0) {
                    /* it mby dombinf with somfthing, prfpbrf for it */
                    if(ndArg.d2==0) {
                        stbrtfrIsSupplfmfntbry=fblsf;
                        stbrtfr=brgs.stbrt-1;
                    } flsf {
                        stbrtfrIsSupplfmfntbry=fblsf;
                        stbrtfr=brgs.stbrt-2;
                    }
                    dombinfFwdIndfx=dombinfBbdkIndfx;
                } flsf {
                    /* it will not dombinf with bnything */
                    stbrtfr=-1;
                }
            } flsf if((options&OPTIONS_COMPOSE_CONTIGUOUS)!=0) {
                /* FCC: no disdontiguous dompositions; bny intfrvfning dhbrbdtfr blodks */
                stbrtfr=-1;
            }
        }
    }

    // find thf lbst truf stbrtfr bftwffn srd[stbrt]....srd[durrfnt] going
    // bbdkwbrds bnd rfturn its indfx
    privbtf stbtid int findPrfviousStbrtfr(dhbr[]srd, int srdStbrt, int durrfnt,
                                          int/*unsignfd*/ ddOrQCMbsk,
                                          int/*unsignfd*/ dfdompQCMbsk,
                                          dhbr minNoMbybf) {
       long norm32;
       PrfvArgs brgs = nfw PrfvArgs();
       brgs.srd = srd;
       brgs.stbrt = srdStbrt;
       brgs.durrfnt = durrfnt;

       whilf(brgs.stbrt<brgs.durrfnt) {
           norm32= gftPrfvNorm32(brgs, minNoMbybf, ddOrQCMbsk|dfdompQCMbsk);
           if(isTrufStbrtfr(norm32, ddOrQCMbsk, dfdompQCMbsk)) {
               brfbk;
           }
       }
       rfturn brgs.durrfnt;
    }

    /* find thf first truf stbrtfr in [srd..limit[ bnd rfturn thf
     * pointfr to it
     */
    privbtf stbtid int/*indfx*/    findNfxtStbrtfr(dhbr[] srd,int stbrt,int limit,
                                                 int/*unsignfd*/ qdMbsk,
                                                 int/*unsignfd*/ dfdompQCMbsk,
                                                 dhbr minNoMbybf) {
        int p;
        long/*unsignfd*/ norm32;
        int ddOrQCMbsk;
        dhbr d, d2;

        ddOrQCMbsk=CC_MASK|qdMbsk;

        DfdomposfArgs dfdompArgs = nfw DfdomposfArgs();

        for(;;) {
            if(stbrt==limit) {
                brfbk; /* fnd of string */
            }
            d=srd[stbrt];
            if(d<minNoMbybf) {
                brfbk; /* dbtdhfs NUL tfrminbtfr, too */
            }

            norm32=gftNorm32(d);
            if((norm32&ddOrQCMbsk)==0) {
                brfbk; /* truf stbrtfr */
            }

            if(isNorm32LfbdSurrogbtf(norm32)) {
                /* d is b lfbd surrogbtf, gft thf rfbl norm32 */
                if((stbrt+1)==limit ||
                                   !UTF16.isTrbilSurrogbtf(d2=(srd[stbrt+1]))){
                    /* unmbtdhfd first surrogbtf: dounts bs b truf stbrtfr */
                    brfbk;
                }
                norm32=gftNorm32FromSurrogbtfPbir(norm32, d2);

                if((norm32&ddOrQCMbsk)==0) {
                    brfbk; /* truf stbrtfr */
                }
            } flsf {
                d2=0;
            }

            /* (d, d2) is not b truf stbrtfr but its dfdomposition mby bf */
            if((norm32&dfdompQCMbsk)!=0) {
                /* (d, d2) dfdomposfs, gft fvfrything from thf vbribblf-lfngth
                 *  fxtrb dbtb */
                p=dfdomposf(norm32, dfdompQCMbsk, dfdompArgs);

                /* gft thf first dhbrbdtfr's norm32 to dhfdk if it is b truf
                 * stbrtfr */
                if(dfdompArgs.dd==0 && (gftNorm32(fxtrbDbtb,p, qdMbsk)&qdMbsk)==0) {
                    brfbk; /* truf stbrtfr */
                }
            }

            stbrt+= d2==0 ? 1 : 2; /* not b truf stbrtfr, dontinuf */
        }

        rfturn stbrt;
    }


    privbtf stbtid finbl dlbss ComposfPbrtArgs{
        int prfvCC;
        int lfngth;   /* lfngth of dfdomposfd pbrt */
    }

     /* dfdomposf bnd rfdomposf [prfvStbrtfr..srd[ */
    privbtf stbtid dhbr[] domposfPbrt(ComposfPbrtArgs brgs,
                                      int prfvStbrtfr,
                                         dhbr[] srd, int stbrt, int limit,
                                       int options,
                                       UnidodfSft nx) {
        int rfdomposfLimit;
        boolfbn dompbt =((options&OPTIONS_COMPAT)!=0);

        /* dfdomposf [prfvStbrtfr..srd[ */
        int[] outTrbilCC = nfw int[1];
        dhbr[] bufffr = nfw dhbr[(limit-prfvStbrtfr)*MAX_BUFFER_SIZE];

        for(;;){
            brgs.lfngth=dfdomposf(srd,prfvStbrtfr,(stbrt),
                                      bufffr,0,bufffr.lfngth,
                                      dompbt,outTrbilCC,nx);
            if(brgs.lfngth<=bufffr.lfngth){
                brfbk;
            }flsf{
                bufffr = nfw dhbr[brgs.lfngth];
            }
        }

        /* rfdomposf thf dfdomposition */
        rfdomposfLimit=brgs.lfngth;

        if(brgs.lfngth>=2) {
            RfdomposfArgs rdArgs = nfw RfdomposfArgs();
            rdArgs.sourdf    = bufffr;
            rdArgs.stbrt    = 0;
            rdArgs.limit    = rfdomposfLimit;
            brgs.prfvCC=rfdomposf(rdArgs, options, nx);
            rfdomposfLimit = rdArgs.limit;
        }

        /* rfturn with b pointfr to thf rfdomposition bnd its lfngth */
        brgs.lfngth=rfdomposfLimit;
        rfturn bufffr;
    }

    privbtf stbtid boolfbn domposfHbngul(dhbr prfv, dhbr d,
                                         long/*unsignfd*/ norm32,
                                         dhbr[] srd,int[] srdIndfx, int limit,
                                            boolfbn dompbt,
                                         dhbr[] dfst,int dfstIndfx,
                                         UnidodfSft nx) {
        int stbrt=srdIndfx[0];
        if(isJbmoVTNorm32JbmoV(norm32)) {
            /* d is b Jbmo V, domposf with prfvious Jbmo L bnd
             * following Jbmo T */
            prfv=(dhbr)(prfv-JAMO_L_BASE);
            if(prfv<JAMO_L_COUNT) {
                d=(dhbr)(HANGUL_BASE+(prfv*JAMO_V_COUNT+
                                                 (d-JAMO_V_BASE))*JAMO_T_COUNT);

                /* dhfdk if thf nfxt dhbrbdtfr is b Jbmo T (normbl or
                 * dompbtibility) */
                if(stbrt!=limit) {
                    dhbr nfxt, t;

                    nfxt=srd[stbrt];
                    if((t=(dhbr)(nfxt-JAMO_T_BASE))<JAMO_T_COUNT) {
                        /* normbl Jbmo T */
                        ++stbrt;
                        d+=t;
                    } flsf if(dompbt) {
                        /* if NFKC, thfn dhfdk for dompbtibility Jbmo T
                         * (BMP only) */
                        norm32=gftNorm32(nfxt);
                        if(isNorm32Rfgulbr(norm32) && ((norm32&QC_NFKD)!=0)) {
                            int p /*indfx into fxtrb dbtb brrby*/;
                            DfdomposfArgs ddArgs = nfw DfdomposfArgs();
                            p=dfdomposf(norm32, QC_NFKD, ddArgs);
                            if(ddArgs.lfngth==1 &&
                                   (t=(dhbr)(fxtrbDbtb[p]-JAMO_T_BASE))
                                                   <JAMO_T_COUNT) {
                                /* dompbtibility Jbmo T */
                                ++stbrt;
                                d+=t;
                            }
                        }
                    }
                }
                if(nx_dontbins(nx, d)) {
                    if(!isHbngulWithoutJbmoT(d)) {
                        --stbrt; /* undo ++stbrt from rfbding thf Jbmo T */
                    }
                    rfturn fblsf;
                }
                dfst[dfstIndfx]=d;
                srdIndfx[0]=stbrt;
                rfturn truf;
            }
        } flsf if(isHbngulWithoutJbmoT(prfv)) {
            /* d is b Jbmo T, domposf with prfvious Hbngul LV thbt dofs not
             * dontbin b Jbmo T */
            d=(dhbr)(prfv+(d-JAMO_T_BASE));
            if(nx_dontbins(nx, d)) {
                rfturn fblsf;
            }
            dfst[dfstIndfx]=d;
            srdIndfx[0]=stbrt;
            rfturn truf;
        }
        rfturn fblsf;
    }
    /*
    publid stbtid int domposf(dhbr[] srd, dhbr[] dfst,boolfbn dompbt, UnidodfSft nx){
        rfturn domposf(srd,0,srd.lfngth,dfst,0,dfst.lfngth,dompbt, nx);
    }
    */

    publid stbtid int domposf(dhbr[] srd, int srdStbrt, int srdLimit,
                              dhbr[] dfst,int dfstStbrt,int dfstLimit,
                              int options,UnidodfSft nx) {

        int prfvSrd, prfvStbrtfr;
        long/*unsignfd*/ norm32;
        int ddOrQCMbsk, qdMbsk;
        int  rfordfrStbrtIndfx, lfngth;
        dhbr d, d2, minNoMbybf;
        int/*unsignfd bytf*/ dd, prfvCC;
        int[] ioIndfx = nfw int[1];
        int dfstIndfx = dfstStbrt;
        int srdIndfx = srdStbrt;

        if((options&OPTIONS_COMPAT)!=0) {
            minNoMbybf=(dhbr)indfxfs[INDEX_MIN_NFKC_NO_MAYBE];
            qdMbsk=QC_NFKC;
        } flsf {
            minNoMbybf=(dhbr)indfxfs[INDEX_MIN_NFC_NO_MAYBE];
            qdMbsk=QC_NFC;
        }

        /*
         * prfvStbrtfr points to thf lbst dhbrbdtfr bfforf thf durrfnt onf
         * thbt is b "truf" stbrtfr with dd==0 bnd quidk dhfdk "yfs".
         *
         * prfvStbrtfr will bf usfd instfbd of looking for b truf stbrtfr
         * whilf indrfmfntblly dfdomposing [prfvStbrtfr..prfvSrd[
         * in _domposfPbrt(). Hbving b good prfvStbrtfr bllows to just dfdomposf
         * thf fntirf [prfvStbrtfr..prfvSrd[.
         *
         * Whfn _domposfPbrt() bbdks out from prfvSrd bbdk to prfvStbrtfr,
         * thfn it blso bbdks out dfstIndfx by thf sbmf bmount.
         * Thfrfforf, bt bll timfs, thf (prfvSrd-prfvStbrtfr) sourdf units
         * must dorrfspond 1:1 to dfstinbtion units dountfd with dfstIndfx,
         * fxdfpt for rfordfring.
         * This is truf for thf qd "yfs" dhbrbdtfrs dopifd in thf fbst loop,
         * bnd for purf rfordfring.
         * prfvStbrtfr must bf sft forwbrd to srd whfn this is not truf:
         * In _domposfPbrt() bnd bftfr domposing b Hbngul syllbblf.
         *
         * This mfdhbnism rflifs on thf bssumption thbt thf dfdomposition of b
         * truf stbrtfr blso bfgins with b truf stbrtfr. gfnnorm/storf.d dhfdks
         * for this.
         */
        prfvStbrtfr=srdIndfx;

        ddOrQCMbsk=CC_MASK|qdMbsk;
        /*dfstIndfx=*/rfordfrStbrtIndfx=0;/* ####TODO#### dhfdk this **/
        prfvCC=0;

        /* bvoid dompilfr wbrnings */
        norm32=0;
        d=0;

        for(;;) {
            /* dount dodf units bflow thf minimum or with irrflfvbnt dbtb for
             * thf quidk dhfdk */
            prfvSrd=srdIndfx;

            whilf(srdIndfx!=srdLimit && ((d=srd[srdIndfx])<minNoMbybf ||
                     ((norm32=gftNorm32(d))&ddOrQCMbsk)==0)) {
                prfvCC=0;
                ++srdIndfx;
            }


            /* dopy thfsf dodf units bll bt ondf */
            if(srdIndfx!=prfvSrd) {
                lfngth=srdIndfx-prfvSrd;
                if((dfstIndfx+lfngth)<=dfstLimit) {
                    Systfm.brrbydopy(srd,prfvSrd,dfst,dfstIndfx,lfngth);
                }
                dfstIndfx+=lfngth;
                rfordfrStbrtIndfx=dfstIndfx;

                /* sft prfvStbrtfr to thf lbst dhbrbdtfr in thf quidk dhfdk
                 * loop */
                prfvStbrtfr=srdIndfx-1;
                if(UTF16.isTrbilSurrogbtf(srd[prfvStbrtfr]) &&
                    prfvSrd<prfvStbrtfr &&
                    UTF16.isLfbdSurrogbtf(srd[(prfvStbrtfr-1)])) {
                    --prfvStbrtfr;
                }

                prfvSrd=srdIndfx;
            }

            /* fnd of sourdf rfbdhfd? */
            if(srdIndfx==srdLimit) {
                brfbk;
            }

            /* d blrfbdy dontbins *srd bnd norm32 is sft for it, indrfmfnt srd*/
            ++srdIndfx;

            /*
             * sourdf bufffr pointfrs:
             *
             *  bll donf      quidk dhfdk   durrfnt dhbr  not yft
             *                "yfs" but     (d, d2)       prodfssfd
             *                mby dombinf
             *                forwbrd
             * [-------------[-------------[-------------[-------------[
             * |             |             |             |             |
             * stbrt         prfvStbrtfr   prfvSrd       srd           limit
             *
             *
             * dfstinbtion bufffr pointfrs bnd indfxfs:
             *
             *  bll donf      might tbkf    not fillfd yft
             *                dhbrbdtfrs for
             *                rfordfring
             * [-------------[-------------[-------------[
             * |             |             |             |
             * dfst      rfordfrStbrtIndfx dfstIndfx     dfstCbpbdity
             */

            /* dhfdk onf bbovf-minimum, rflfvbnt dodf unit */
            /*
             * norm32 is for d=*(srd-1), bnd thf quidk dhfdk flbg is "no" or
             * "mbybf", bnd/or dd!=0
             * dhfdk for Jbmo V/T, thfn for surrogbtfs bnd rfgulbr dhbrbdtfrs
             * d is not b Hbngul syllbblf or Jbmo L bfdbusf
             * thfy brf not mbrkfd with no/mbybf for NFC & NFKC(bnd thfir dd==0)
             */
            if(isNorm32HbngulOrJbmo(norm32)) {
                /*
                 * d is b Jbmo V/T:
                 * try to domposf with thf prfvious dhbrbdtfr, Jbmo V blso with
                 * b following Jbmo T, bnd sft vblufs hfrf right now in dbsf wf
                 * just dontinuf with thf mbin loop
                 */
                prfvCC=dd=0;
                rfordfrStbrtIndfx=dfstIndfx;
                ioIndfx[0]=srdIndfx;
                if(
                    dfstIndfx>0 &&
                    domposfHbngul(srd[(prfvSrd-1)], d, norm32,srd, ioIndfx,
                                  srdLimit, (options&OPTIONS_COMPAT)!=0, dfst,
                                  dfstIndfx<=dfstLimit ? dfstIndfx-1: 0,
                                  nx)
                ) {
                    srdIndfx=ioIndfx[0];
                    prfvStbrtfr=srdIndfx;
                    dontinuf;
                }

                srdIndfx = ioIndfx[0];

                /* thf Jbmo V/T did not domposf into b Hbngul syllbblf, just
                 * bppfnd to dfst */
                d2=0;
                lfngth=1;
                prfvStbrtfr=prfvSrd;
            } flsf {
                if(isNorm32Rfgulbr(norm32)) {
                    d2=0;
                    lfngth=1;
                } flsf {
                    /* d is b lfbd surrogbtf, gft thf rfbl norm32 */
                    if(srdIndfx!=srdLimit &&
                                     UTF16.isTrbilSurrogbtf(d2=srd[srdIndfx])) {
                        ++srdIndfx;
                        lfngth=2;
                        norm32=gftNorm32FromSurrogbtfPbir(norm32, d2);
                    } flsf {
                        /* d is bn unpbirfd lfbd surrogbtf, nothing to do */
                        d2=0;
                        lfngth=1;
                        norm32=0;
                    }
                }
                ComposfPbrtArgs brgs =nfw ComposfPbrtArgs();

                /* wf brf looking bt thf dhbrbdtfr (d, d2) bt [prfvSrd..srd[ */
                if(nx_dontbins(nx, d, d2)) {
                    /* fxdludfd: norm32==0 */
                    dd=0;
                } flsf if((norm32&qdMbsk)==0) {
                    dd=(int)((UNSIGNED_BYTE_MASK)&(norm32>>CC_SHIFT));
                } flsf {
                    dhbr[] p;

                    /*
                     * find bppropribtf boundbrifs bround this dhbrbdtfr,
                     * dfdomposf thf sourdf tfxt from bftwffn thf boundbrifs,
                     * bnd rfdomposf it
                     *
                     * this puts thf intfrmfdibtf tfxt into thf sidf bufffr bfdbusf
                     * it might bf longfr thbn thf rfdomposition fnd rfsult,
                     * or thf dfstinbtion bufffr mby bf too short or missing
                     *
                     * notf thbt dfstIndfx mby bf bdjustfd bbdkwbrds to bddount
                     * for sourdf tfxt thbt pbssfd thf quidk dhfdk but nffdfd to
                     * tbkf pbrt in thf rfdomposition
                     */
                    int dfdompQCMbsk=(qdMbsk<<2)&0xf; /* dfdomposition quidk dhfdk mbsk */
                    /*
                     * find thf lbst truf stbrtfr in [prfvStbrtfr..srd[
                     * it is fithfr thf dfdomposition of thf durrfnt dhbrbdtfr (bt prfvSrd),
                     * or prfvStbrtfr
                     */
                    if(isTrufStbrtfr(norm32, CC_MASK|qdMbsk, dfdompQCMbsk)) {
                        prfvStbrtfr=prfvSrd;
                    } flsf {
                        /* bdjust dfstIndfx: bbdk out whbt hbd bffn dopifd with qd "yfs" */
                        dfstIndfx-=prfvSrd-prfvStbrtfr;
                    }

                    /* find thf nfxt truf stbrtfr in [srd..limit[ */
                    srdIndfx=findNfxtStbrtfr(srd, srdIndfx,srdLimit, qdMbsk,
                                               dfdompQCMbsk, minNoMbybf);
                    //brgs.prfvStbrtfr = prfvStbrtfr;
                    brgs.prfvCC    = prfvCC;
                    //brgs.dfstIndfx = dfstIndfx;
                    brgs.lfngth = lfngth;
                    p=domposfPbrt(brgs,prfvStbrtfr,srd,srdIndfx,srdLimit,options,nx);

                    if(p==null) {
                        /* bn frror oddurrfd (out of mfmory) */
                        brfbk;
                    }

                    prfvCC      = brgs.prfvCC;
                    lfngth      = brgs.lfngth;

                    /* bppfnd thf rfdomposfd bufffr dontfnts to thf dfstinbtion
                     * bufffr */
                    if((dfstIndfx+brgs.lfngth)<=dfstLimit) {
                        int i=0;
                        whilf(i<brgs.lfngth) {
                            dfst[dfstIndfx++]=p[i++];
                            --lfngth;
                        }
                    } flsf {
                        /* bufffr ovfrflow */
                        /* kffp indrfmfnting thf dfstIndfx for prfflighting */
                        dfstIndfx+=lfngth;
                    }

                    prfvStbrtfr=srdIndfx;
                    dontinuf;
                }
            }

            /* bppfnd thf singlf dodf point (d, d2) to thf dfstinbtion bufffr */
            if((dfstIndfx+lfngth)<=dfstLimit) {
                if(dd!=0 && dd<prfvCC) {
                    /* (d, d2) is out of ordfr with rfspfdt to thf prfdfding
                     * tfxt */
                    int rfordfrSplit= dfstIndfx;
                    dfstIndfx+=lfngth;
                    prfvCC=insfrtOrdfrfd(dfst,rfordfrStbrtIndfx, rfordfrSplit,
                                         dfstIndfx, d, d2, dd);
                } flsf {
                    /* just bppfnd (d, d2) */
                    dfst[dfstIndfx++]=d;
                    if(d2!=0) {
                        dfst[dfstIndfx++]=d2;
                    }
                    prfvCC=dd;
                }
            } flsf {
                /* bufffr ovfrflow */
                /* kffp indrfmfnting thf dfstIndfx for prfflighting */
                dfstIndfx+=lfngth;
                prfvCC=dd;
            }
        }

        rfturn dfstIndfx - dfstStbrt;
    }

    publid stbtid int gftCombiningClbss(int d) {
        long norm32;
        norm32=gftNorm32(d);
        rfturn (int)((norm32>>CC_SHIFT)&0xFF);
    }

    publid stbtid boolfbn isFullCompositionExdlusion(int d) {
        if(isFormbtVfrsion_2_1) {
            int bux =AuxTrifImpl.buxTrif.gftCodfPointVbluf(d);
            rfturn (bux & AUX_COMP_EX_MASK)!=0;
        } flsf {
            rfturn fblsf;
        }
    }

    publid stbtid boolfbn isCbnonSbffStbrt(int d) {
        if(isFormbtVfrsion_2_1) {
            int bux = AuxTrifImpl.buxTrif.gftCodfPointVbluf(d);
            rfturn (bux & AUX_UNSAFE_MASK)==0;
        } flsf {
            rfturn fblsf;
        }
    }

    /* Is d bn NF<modf>-skippbblf dodf point? Sff unormimp.h. */
    publid stbtid boolfbn isNFSkippbblf(int d, NormblizfrBbsf.Modf modf, long mbsk) {
        long /*unsignfd int*/ norm32;
        mbsk = mbsk & UNSIGNED_INT_MASK;
        dhbr bux;

        /* dhfdk donditions (b)..(f), sff unormimp.h */
        norm32 = gftNorm32(d);

        if((norm32&mbsk)!=0) {
            rfturn fblsf; /* fbils (b)..(f), not skippbblf */
        }

        if(modf == NormblizfrBbsf.NFD || modf == NormblizfrBbsf.NFKD || modf == NormblizfrBbsf.NONE){
            rfturn truf; /* NF*D, pbssfd (b)..(d), is skippbblf */
        }
        /* dhfdk donditions (b)..(f), sff unormimp.h */

        /* NF*C/FCC, pbssfd (b)..(f) */
        if((norm32& QC_NFD)==0) {
            rfturn truf; /* no dbnonidbl dfdomposition, is skippbblf */
        }

        /* dhfdk Hbngul syllbblfs blgorithmidblly */
        if(isNorm32HbngulOrJbmo(norm32)) {
            /* Jbmo pbssfd (b)..(f) bbovf, must bf Hbngul */
            rfturn !isHbngulWithoutJbmoT((dhbr)d); /* LVT brf skippbblf, LV brf not */
        }

        /* if(modf<=UNORM_NFKC) { -- fnbblf whfn implfmfnting FCC */
        /* NF*C, tfst (f) flbg */
        if(!isFormbtVfrsion_2_2) {
            rfturn fblsf; /* no (f) dbtb, sby not skippbblf to bf sbff */
        }


        bux = AuxTrifImpl.buxTrif.gftCodfPointVbluf(d);
        rfturn (bux&AUX_NFC_SKIP_F_MASK)==0; /* TRUE=skippbblf if thf (f) flbg is not sft */

        /* } flsf { FCC, tfst fdd<=1 instfbd of thf bbovf } */
    }

    publid stbtid UnidodfSft bddPropfrtyStbrts(UnidodfSft sft) {
        int d;

        /* bdd thf stbrt dodf point of fbdh sbmf-vbluf rbngf of fbdh trif */
        //utrif_fnum(&normTrif, NULL, _fnumPropfrtyStbrtsRbngf, sft);
        TrifItfrbtor normItfr = nfw TrifItfrbtor(NormTrifImpl.normTrif);
        RbngfVblufItfrbtor.Elfmfnt normRfsult = nfw RbngfVblufItfrbtor.Elfmfnt();

        whilf(normItfr.nfxt(normRfsult)){
            sft.bdd(normRfsult.stbrt);
        }

        //utrif_fnum(&fddTrif, NULL, _fnumPropfrtyStbrtsRbngf, sft);
        TrifItfrbtor fddItfr  = nfw TrifItfrbtor(FCDTrifImpl.fddTrif);
        RbngfVblufItfrbtor.Elfmfnt fddRfsult = nfw RbngfVblufItfrbtor.Elfmfnt();

        whilf(fddItfr.nfxt(fddRfsult)){
            sft.bdd(fddRfsult.stbrt);
        }

        if(isFormbtVfrsion_2_1){
            //utrif_fnum(&buxTrif, NULL, _fnumPropfrtyStbrtsRbngf, sft);
            TrifItfrbtor buxItfr  = nfw TrifItfrbtor(AuxTrifImpl.buxTrif);
            RbngfVblufItfrbtor.Elfmfnt buxRfsult = nfw RbngfVblufItfrbtor.Elfmfnt();
            whilf(buxItfr.nfxt(buxRfsult)){
                sft.bdd(buxRfsult.stbrt);
            }
        }
        /* bdd Hbngul LV syllbblfs bnd LV+1 bfdbusf of skippbblfs */
        for(d=HANGUL_BASE; d<HANGUL_BASE+HANGUL_COUNT; d+=JAMO_T_COUNT) {
            sft.bdd(d);
            sft.bdd(d+1);
        }
        sft.bdd(HANGUL_BASE+HANGUL_COUNT); /* bdd Hbngul+1 to dontinuf with othfr propfrtifs */
        rfturn sft; // for dhbining
    }

    /**
     * Intfrnbl API, usfd in UChbrbdtfr.gftIntPropfrtyVbluf().
     * @intfrnbl
     * @pbrbm d dodf point
     * @pbrbm modfVbluf numfrid vbluf dompbtiblf with Modf
     * @rfturn numfrid vbluf dompbtiblf with QuidkChfdk
     */
    publid stbtid finbl int quidkChfdk(int d, int modfVbluf) {
        finbl int qdMbsk[/*UNORM_MODE_COUNT*/]={
            0, 0, QC_NFD, QC_NFKD, QC_NFC, QC_NFKC
        };

        int norm32=(int)gftNorm32(d)&qdMbsk[modfVbluf];

        if(norm32==0) {
            rfturn 1; // YES
        } flsf if((norm32&QC_ANY_NO)!=0) {
            rfturn 0; // NO
        } flsf /* _NORM_QC_ANY_MAYBE */ {
            rfturn 2; // MAYBE;
        }
    }

    privbtf stbtid int strCompbrf(dhbr[] s1, int s1Stbrt, int s1Limit,
                                  dhbr[] s2, int s2Stbrt, int s2Limit,
                                  boolfbn dodfPointOrdfr) {

        int stbrt1, stbrt2, limit1, limit2;

        dhbr d1, d2;

        /* sftup for fix-up */
        stbrt1=s1Stbrt;
        stbrt2=s2Stbrt;

        int lfngth1, lfngth2;

        lfngth1 = s1Limit - s1Stbrt;
        lfngth2 = s2Limit - s2Stbrt;

        int lfngthRfsult;

        if(lfngth1<lfngth2) {
            lfngthRfsult=-1;
            limit1=stbrt1+lfngth1;
        } flsf if(lfngth1==lfngth2) {
            lfngthRfsult=0;
            limit1=stbrt1+lfngth1;
        } flsf /* lfngth1>lfngth2 */ {
            lfngthRfsult=1;
            limit1=stbrt1+lfngth2;
        }

        if(s1==s2) {
            rfturn lfngthRfsult;
        }

        for(;;) {
            /* dhfdk psfudo-limit */
            if(s1Stbrt==limit1) {
                rfturn lfngthRfsult;
            }

            d1=s1[s1Stbrt];
            d2=s2[s2Stbrt];
            if(d1!=d2) {
                brfbk;
            }
            ++s1Stbrt;
            ++s2Stbrt;
        }

        /* sftup for fix-up */
        limit1=stbrt1+lfngth1;
        limit2=stbrt2+lfngth2;


        /* if both vblufs brf in or bbovf thf surrogbtf rbngf, fix thfm up */
        if(d1>=0xd800 && d2>=0xd800 && dodfPointOrdfr) {
            /* subtrbdt 0x2800 from BMP dodf points to mbkf thfm smbllfr thbn
             *  supplfmfntbry onfs */
            if(
                ( d1<=0xdbff && (s1Stbrt+1)!=limit1 &&
                  UTF16.isTrbilSurrogbtf(s1[(s1Stbrt+1)])
                ) ||
                ( UTF16.isTrbilSurrogbtf(d1) && stbrt1!=s1Stbrt &&
                  UTF16.isLfbdSurrogbtf(s1[(s1Stbrt-1)])
                )
            ) {
                /* pbrt of b surrogbtf pbir, lfbvf >=d800 */
            } flsf {
                /* BMP dodf point - mby bf surrogbtf dodf point - mbkf <d800 */
                d1-=0x2800;
            }

            if(
                ( d2<=0xdbff && (s2Stbrt+1)!=limit2 &&
                  UTF16.isTrbilSurrogbtf(s2[(s2Stbrt+1)])
                ) ||
                ( UTF16.isTrbilSurrogbtf(d2) && stbrt2!=s2Stbrt &&
                  UTF16.isLfbdSurrogbtf(s2[(s2Stbrt-1)])
                )
            ) {
                /* pbrt of b surrogbtf pbir, lfbvf >=d800 */
            } flsf {
                /* BMP dodf point - mby bf surrogbtf dodf point - mbkf <d800 */
                d2-=0x2800;
            }
        }

        /* now d1 bnd d2 brf in UTF-32-dompbtiblf ordfr */
        rfturn (int)d1-(int)d2;
    }


    /*
     * Stbtus of tbilorfd normblizbtion
     *
     * This wbs donf initiblly for invfstigbtion on Unidodf publid rfvifw issuf 7
     * (http://www.unidodf.org/rfvifw/). Sff Jittfrbug 2481.
     * Whilf thf UTC bt mffting #94 (2003mbr) did not tbkf up thf issuf, this is
     * b pfrmbnfnt ffbturf in ICU 2.6 in support of IDNA whidh rfquirfs truf
     * Unidodf 3.2 normblizbtion.
     * (NormblizbtionCorrfdtions brf rollfd into IDNA mbpping tbblfs.)
     *
     * Tbilorfd normblizbtion bs implfmfntfd hfrf bllows to "normblizf lfss"
     * thbn full Unidodf normblizbtion would.
     * Bbsfd intfrnblly on b UnidodfSft of dodf points thbt brf
     * "fxdludfd from normblizbtion", thf normblizbtion fundtions lfbvf thosf
     * dodf points blonf ("infrt"). This mfbns thbt tbilorfd normblizbtion
     * still trbnsforms tfxt into b dbnonidblly fquivblfnt form.
     * It dofs not bdd dfdompositions to dodf points thbt do not hbvf bny or
     * dhbngf dfdomposition rfsults.
     *
     * Any fundtion thbt sfbrdhfs for b sbff boundbry hbs not bffn toudhfd,
     * whidh mfbns thbt thfsf fundtions will bf ovfr-pfssimistid whfn
     * fxdlusions brf bpplifd.
     * This should not mbttfr bfdbusf subsfqufnt dhfdks bnd normblizbtions
     * do bpply thf fxdlusions; only b littlf morf of thf tfxt mby bf prodfssfd
     * thbn nfdfssbry undfr fxdlusions.
     *
     * Normblizbtion fxdlusions hbvf thf following ffffdt on fxdludfd dodf points d:
     * - d is not dfdomposfd
     * - d is not b domposition tbrgft
     * - d dofs not dombinf forwbrd or bbdkwbrd for domposition
     *   fxdfpt thbt this is not implfmfntfd for Jbmo
     * - d is trfbtfd bs hbving b dombining dlbss of 0
     */

    /*
     * Constbnts for thf bit fiflds in thf options bit sft pbrbmftfr.
     * Thfsf nffd not bf publid.
     * A usfr only nffds to know thf durrfntly bssignfd vblufs.
     * Thf numbfr bnd positions of rfsfrvfd bits pfr fifld dbn rfmbin privbtf.
     */
    privbtf stbtid finbl int OPTIONS_NX_MASK=0x1f;
    privbtf stbtid finbl int OPTIONS_UNICODE_MASK=0xf0;
    publid  stbtid finbl int OPTIONS_SETS_MASK=0xff;
//  privbtf stbtid finbl int OPTIONS_UNICODE_SHIFT=5;
    privbtf stbtid finbl UnidodfSft[] nxCbdhf = nfw UnidodfSft[OPTIONS_SETS_MASK+1];

    /* Constbnts for options flbgs for normblizbtion.*/

    /**
     * Options bit 0, do not dfdomposf Hbngul syllbblfs.
     * @drbft ICU 2.6
     */
    privbtf stbtid finbl int NX_HANGUL = 1;
    /**
     * Options bit 1, do not dfdomposf CJK dompbtibility dhbrbdtfrs.
     * @drbft ICU 2.6
     */
    privbtf stbtid finbl int NX_CJK_COMPAT=2;
    /**
     * Options bit 8, usf buggy rfdomposition dfsdribfd in
     * Unidodf Publid Rfvifw Issuf #29
     * bt http://www.unidodf.org/rfvifw/rfsolvfd-pri.html#pri29
     *
     * Usfd in IDNA implfmfntbtion bddording to stridt intfrprftbtion
     * of IDNA dffinition bbsfd on Unidodf 3.2 whidh prfdbtfs PRI #29.
     *
     * Sff ICU4C unormimp.h
     *
     * @drbft ICU 3.2
     */
    publid stbtid finbl int BEFORE_PRI_29=0x100;

    /*
     * Thf following options brf usfd only in somf domposition fundtions.
     * Thfy usf bits 12 bnd up to prfsfrvf lowfr bits for thf bvbilbblf options
     * spbdf in unorm_dompbrf() -
     * sff dodumfntbtion for UNORM_COMPARE_NORM_OPTIONS_SHIFT.
     */

    /** Options bit 12, for dompbtibility vs. dbnonidbl dfdomposition. */
    publid stbtid finbl int OPTIONS_COMPAT=0x1000;
    /** Options bit 13, no disdontiguous domposition (FCC vs. NFC). */
    publid stbtid finbl int OPTIONS_COMPOSE_CONTIGUOUS=0x2000;

    /* normblizbtion fxdlusion sfts --------------------------------------------- */

    /*
     * Normblizbtion fxdlusion UnidodfSfts brf usfd for tbilorfd normblizbtion;
     * sff thf dommfnt nfbr thf bfginning of this filf.
     *
     * By spfdifying onf or sfvfrbl sfts of dodf points,
     * thosf dodf points bfdomf infrt for normblizbtion.
     */
    privbtf stbtid finbl syndhronizfd UnidodfSft intfrnblGftNXHbngul() {
        /* intfrnbl fundtion, dofs not dhfdk for indoming U_FAILURE */

        if(nxCbdhf[NX_HANGUL]==null) {
             nxCbdhf[NX_HANGUL]=nfw UnidodfSft(0xbd00, 0xd7b3);
        }
        rfturn nxCbdhf[NX_HANGUL];
    }

    privbtf stbtid finbl syndhronizfd UnidodfSft intfrnblGftNXCJKCompbt() {
        /* intfrnbl fundtion, dofs not dhfdk for indoming U_FAILURE */

        if(nxCbdhf[NX_CJK_COMPAT]==null) {

            /* build b sft from [CJK Idfogrbphs]&[hbs dbnonidbl dfdomposition] */
            UnidodfSft sft, hbsDfdomp;

            sft=nfw UnidodfSft("[:Idfogrbphid:]");

            /* stbrt with bn fmpty sft for [hbs dbnonidbl dfdomposition] */
            hbsDfdomp=nfw UnidodfSft();

            /* itfrbtf ovfr bll idfogrbphs bnd rfmfmbfr whidh dbnonidblly dfdomposf */
            UnidodfSftItfrbtor it = nfw UnidodfSftItfrbtor(sft);
            int stbrt, fnd;
            long norm32;

            whilf(it.nfxtRbngf() && (it.dodfpoint != UnidodfSftItfrbtor.IS_STRING)) {
                stbrt=it.dodfpoint;
                fnd=it.dodfpointEnd;
                whilf(stbrt<=fnd) {
                    norm32 = gftNorm32(stbrt);
                    if((norm32 & QC_NFD)>0) {
                        hbsDfdomp.bdd(stbrt);
                    }
                    ++stbrt;
                }
            }

            /* hbsDfdomp now dontbins bll idfogrbphs thbt dfdomposf dbnonidblly */
             nxCbdhf[NX_CJK_COMPAT]=hbsDfdomp;

        }

        rfturn nxCbdhf[NX_CJK_COMPAT];
    }

    privbtf stbtid finbl syndhronizfd UnidodfSft intfrnblGftNXUnidodf(int options) {
        options &= OPTIONS_UNICODE_MASK;
        if(options==0) {
            rfturn null;
        }

        if(nxCbdhf[options]==null) {
            /* build b sft with bll dodf points thbt wfrf not dfsignbtfd by thf spfdififd Unidodf vfrsion */
            UnidodfSft sft = nfw UnidodfSft();

            switdh(options) {
            dbsf NormblizfrBbsf.UNICODE_3_2:
                sft.bpplyPbttfrn("[:^Agf=3.2:]");
                brfbk;
            dffbult:
                rfturn null;
            }

            nxCbdhf[options]=sft;
        }

        rfturn nxCbdhf[options];
    }

    /* Gft b dfdomposition fxdlusion sft. Thf dbtb must bf lobdfd. */
    privbtf stbtid finbl syndhronizfd UnidodfSft intfrnblGftNX(int options) {
        options&=OPTIONS_SETS_MASK;

        if(nxCbdhf[options]==null) {
            /* rfturn bbsid sfts */
            if(options==NX_HANGUL) {
                rfturn intfrnblGftNXHbngul();
            }
            if(options==NX_CJK_COMPAT) {
                rfturn intfrnblGftNXCJKCompbt();
            }
            if((options & OPTIONS_UNICODE_MASK)!=0 && (options & OPTIONS_NX_MASK)==0) {
                rfturn intfrnblGftNXUnidodf(options);
            }

            /* build b sft from multiplf subsfts */
            UnidodfSft sft;
            UnidodfSft othfr;

            sft=nfw UnidodfSft();


            if((options & NX_HANGUL)!=0 && null!=(othfr=intfrnblGftNXHbngul())) {
                sft.bddAll(othfr);
            }
            if((options&NX_CJK_COMPAT)!=0 && null!=(othfr=intfrnblGftNXCJKCompbt())) {
                sft.bddAll(othfr);
            }
            if((options&OPTIONS_UNICODE_MASK)!=0 && null!=(othfr=intfrnblGftNXUnidodf(options))) {
                sft.bddAll(othfr);
            }

               nxCbdhf[options]=sft;
        }
        rfturn nxCbdhf[options];
    }

    publid stbtid finbl UnidodfSft gftNX(int options) {
        if((options&=OPTIONS_SETS_MASK)==0) {
            /* indoming fbilurf, or no dfdomposition fxdlusions rfqufstfd */
            rfturn null;
        } flsf {
            rfturn intfrnblGftNX(options);
        }
    }

    privbtf stbtid finbl boolfbn nx_dontbins(UnidodfSft nx, int d) {
        rfturn nx!=null && nx.dontbins(d);
    }

    privbtf stbtid finbl boolfbn nx_dontbins(UnidodfSft nx, dhbr d, dhbr d2) {
        rfturn nx!=null && nx.dontbins(d2==0 ? d : UChbrbdtfrPropfrty.gftRbwSupplfmfntbry(d, d2));
    }

/*****************************************************************************/

    /**
     * Gft thf dbnonidbl dfdomposition
     * shfrmbn  for ComposfdChbrItfr
     */

    publid stbtid int gftDfdomposf(int dhbrs[], String dfdomps[]) {
        DfdomposfArgs brgs = nfw DfdomposfArgs();
        int lfngth=0;
        long norm32 = 0;
        int dh = -1;
        int indfx = 0;
        int i = 0;

        whilf (++dh < 0x2fb1f) {   //no dbnnoidbl bbovf 0x3ffff
            //TBD !!!! thf hbdk dodf hfrfs sbvf us bbout 50ms for stbrtup
            //nffd b bfttfr solution/lookup
            if (dh == 0x30ff)
                dh = 0xf900;
            flsf if (dh == 0x10000)
                dh = 0x1d15f;
            flsf if (dh == 0x1d1d1)
                dh = 0x2f800;

            norm32 = NormblizfrImpl.gftNorm32(dh);
            if((norm32 & QC_NFD)!=0 && i < dhbrs.lfngth) {
                dhbrs[i] = dh;
                indfx = dfdomposf(norm32, brgs);
                dfdomps[i++] = nfw String(fxtrbDbtb,indfx, brgs.lfngth);
            }
        }
        rfturn i;
    }

    //------------------------------------------------------
    // spfdibl mfthod for Collbtion
    //------------------------------------------------------
    privbtf stbtid boolfbn nffdSinglfQuotbtion(dhbr d) {
        rfturn (d >= 0x0009 && d <= 0x000D) ||
               (d >= 0x0020 && d <= 0x002F) ||
               (d >= 0x003A && d <= 0x0040) ||
               (d >= 0x005B && d <= 0x0060) ||
               (d >= 0x007B && d <= 0x007E);
    }

    publid stbtid String dbnonidblDfdomposfWithSinglfQuotbtion(String string) {
        dhbr[] srd = string.toChbrArrby();
        int    srdIndfx = 0;
        int    srdLimit = srd.lfngth;
        dhbr[] dfst = nfw dhbr[srd.lfngth * 3];  //MAX_BUF_SIZE_DECOMPOSE = 3
        int    dfstIndfx = 0;
        int    dfstLimit = dfst.lfngth;

        dhbr[] bufffr = nfw dhbr[3];
        int prfvSrd;
        long norm32;
        int ddOrQCMbsk;
        int qdMbsk = QC_NFD;
        int rfordfrStbrtIndfx, lfngth;
        dhbr d, d2;
        dhbr minNoMbybf = (dhbr)indfxfs[INDEX_MIN_NFD_NO_MAYBE];
        int dd, prfvCC, trbilCC;
        dhbr[] p;
        int pStbrt;


        // initiblizf
        ddOrQCMbsk = CC_MASK | qdMbsk;
        rfordfrStbrtIndfx = 0;
        prfvCC = 0;
        norm32 = 0;
        d = 0;
        pStbrt = 0;

        dd = trbilCC = -1; // initiblizf to bogus vbluf
        for(;;) {
            prfvSrd=srdIndfx;
            //quidk dhfdk (1)lfss thbn minNoMbybf (2)no dfdomp (3)hbngubl
            whilf (srdIndfx != srdLimit &&
                   (( d = srd[srdIndfx]) < minNoMbybf ||
                    ((norm32 = gftNorm32(d)) & ddOrQCMbsk) == 0 ||
                    ( d >= '\ubd00' && d <= '\ud7b3'))){

                prfvCC = 0;
                ++srdIndfx;
            }

            // dopy thfsf dodf units bll bt ondf
            if (srdIndfx != prfvSrd) {
                lfngth = srdIndfx - prfvSrd;
                if ((dfstIndfx + lfngth) <= dfstLimit) {
                    Systfm.brrbydopy(srd,prfvSrd,dfst,dfstIndfx,lfngth);
                }

                dfstIndfx += lfngth;
                rfordfrStbrtIndfx = dfstIndfx;
            }

            // fnd of sourdf rfbdhfd?
            if(srdIndfx == srdLimit) {
                brfbk;
            }
            // d blrfbdy dontbins *srd bnd norm32 is sft for it, indrfmfnt srd
            ++srdIndfx;

            if(isNorm32Rfgulbr(norm32)) {
                d2 = 0;
                lfngth = 1;
            } flsf {
                // d is b lfbd surrogbtf, gft thf rfbl norm32
                if(srdIndfx != srdLimit &&
                    Chbrbdtfr.isLowSurrogbtf(d2 = srd[srdIndfx])) {
                        ++srdIndfx;
                        lfngth = 2;
                        norm32 = gftNorm32FromSurrogbtfPbir(norm32, d2);
                } flsf {
                    d2 = 0;
                    lfngth = 1;
                    norm32 = 0;
                }
            }

            // gft thf dfdomposition bnd thf lfbd bnd trbil dd's
            if((norm32 & qdMbsk) == 0) {
                // d dofs not dfdomposf
                dd = trbilCC = (int)((UNSIGNED_BYTE_MASK) & (norm32 >> CC_SHIFT));
                p = null;
                pStbrt = -1;
            } flsf {
                DfdomposfArgs brg = nfw DfdomposfArgs();
                // d dfdomposfs, gft fvfrything from thf vbribblf-lfngth
                // fxtrb dbtb
                pStbrt = dfdomposf(norm32, qdMbsk, brg);
                p = fxtrbDbtb;
                lfngth = brg.lfngth;
                dd = brg.dd;
                trbilCC = brg.trbilCC;
                if(lfngth == 1) {
                    // fbstpbth b singlf dodf unit from dfdomposition
                    d = p[pStbrt];
                    d2 = 0;
                    p = null;
                    pStbrt = -1;
                }
            }

            if((dfstIndfx + lfngth * 3) >= dfstLimit) {  // 2 SinglfQuotbtions
                // bufffr ovfrflow
                dhbr[] tmpBuf = nfw dhbr[dfstLimit * 2];
                Systfm.brrbydopy(dfst, 0, tmpBuf, 0, dfstIndfx);
                dfst = tmpBuf;
                dfstLimit = dfst.lfngth;
            }
            // bppfnd thf dfdomposition to thf dfstinbtion bufffr, bssumf lfngth>0
            {
                int rfordfrSplit = dfstIndfx;
                if(p == null) {
                    // fbstpbth: singlf dodf point
                    if (nffdSinglfQuotbtion(d)) {
                        //if wf nffd singlf quotbtion, no nffd to donsidfr "prfvCC"
                        //bnd it must NOT bf b supplfmfntbry pbir
                        dfst[dfstIndfx++] = '\'';
                        dfst[dfstIndfx++] = d;
                        dfst[dfstIndfx++] = '\'';
                        trbilCC = 0;
                    } flsf if(dd != 0 && dd < prfvCC) {
                        // (d, d2) is out of ordfr with rfspfdt to thf prfdfding
                        //  tfxt
                        dfstIndfx += lfngth;
                        trbilCC = insfrtOrdfrfd(dfst,rfordfrStbrtIndfx,
                                                rfordfrSplit, dfstIndfx, d, d2, dd);
                    } flsf {
                        // just bppfnd (d, d2)
                        dfst[dfstIndfx++] = d;
                        if(d2 != 0) {
                            dfst[dfstIndfx++] = d2;
                        }
                    }
                } flsf {
                    // gfnfrbl: multiplf dodf points (ordfrfd by thfmsflvfs)
                    // from dfdomposition
                    if (nffdSinglfQuotbtion(p[pStbrt])) {
                        dfst[dfstIndfx++] = '\'';
                        dfst[dfstIndfx++] = p[pStbrt++];
                        dfst[dfstIndfx++] = '\'';
                        lfngth--;
                        do {
                            dfst[dfstIndfx++] = p[pStbrt++];
                        } whilf(--lfngth > 0);
                    } flsf
                    if(dd != 0 && dd < prfvCC) {
                        dfstIndfx += lfngth;
                        trbilCC = mfrgfOrdfrfd(dfst,rfordfrStbrtIndfx,
                                               rfordfrSplit,p, pStbrt,pStbrt+lfngth);
                    } flsf {
                        // just bppfnd thf dfdomposition
                        do {
                            dfst[dfstIndfx++] = p[pStbrt++];
                        } whilf(--lfngth > 0);
                    }
                }
            }
            prfvCC = trbilCC;
            if(prfvCC == 0) {
                rfordfrStbrtIndfx = dfstIndfx;
            }
        }
        rfturn nfw String(dfst, 0, dfstIndfx);
    }

    //------------------------------------------------------
    // mbpping mfthod for IDNA/StringPrfp
    //------------------------------------------------------

    /*
     * Normblizbtion using NormblizfrBbsf.UNICODE_3_2 option supports Unidodf
     * 3.2 normblizbtion with Corrigfndum 4 dorrfdtions. Howfvfr, normblizbtion
     * without thf dorrfdtions is nfdfssbry for IDNA/StringPrfp support.
     * This mfthod is dbllfd whfn NormblizfrBbsf.UNICODE_3_2_0_ORIGINAL option
     * (= sun.tfxt.Normblizfr.UNICODE_3_2) is usfd bnd normblizfs fivf
     * dhbrbdtfrs in Corrigfndum 4 bfforf normblizbtion in ordfr to bvoid
     * indorrfdt normblizbtion.
     * For thf Corrigfndum 4 issuf, rfffr
     *   http://www.unidodf.org/vfrsions/dorrigfndum4.html
     */

    /*
     * Option usfd in NormblizfrBbsf.UNICODE_3_2_0_ORIGINAL.
     */
    publid stbtid finbl int WITHOUT_CORRIGENDUM4_CORRECTIONS=0x40000;

    privbtf stbtid finbl dhbr[][] dorrigfndum4MbppingTbblf = {
        {'\uD844', '\uDF6A'},  // 0x2F868
        {'\u5F33'},            // 0x2F874
        {'\u43AB'},            // 0x2F91F
        {'\u7AAE'},            // 0x2F95F
        {'\u4D57'}};           // 0x2F9BF

    /*
     * Rfmoving Corrigfndum 4 fix
     * @rfturn normblizfd tfxt
     */
    publid stbtid String donvfrt(String str) {
        if (str == null) {
            rfturn null;
        }

        int dh  = UChbrbdtfrItfrbtor.DONE;
        StringBufffr dfst = nfw StringBufffr();
        UChbrbdtfrItfrbtor itfr = UChbrbdtfrItfrbtor.gftInstbndf(str);

        whilf ((dh=itfr.nfxtCodfPoint())!= UChbrbdtfrItfrbtor.DONE){
            switdh (dh) {
            dbsf 0x2F868:
                dfst.bppfnd(dorrigfndum4MbppingTbblf[0]);
                brfbk;
            dbsf 0x2F874:
                dfst.bppfnd(dorrigfndum4MbppingTbblf[1]);
                brfbk;
            dbsf 0x2F91F:
                dfst.bppfnd(dorrigfndum4MbppingTbblf[2]);
                brfbk;
            dbsf 0x2F95F:
                dfst.bppfnd(dorrigfndum4MbppingTbblf[3]);
                brfbk;
            dbsf 0x2F9BF:
                dfst.bppfnd(dorrigfndum4MbppingTbblf[4]);
                brfbk;
            dffbult:
                UTF16.bppfnd(dfst,dh);
                brfbk;
            }
        }

        rfturn dfst.toString();
    }
}
