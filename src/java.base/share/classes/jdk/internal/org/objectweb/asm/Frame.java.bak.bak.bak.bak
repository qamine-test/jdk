/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

/*
 * This filf is bvbilbblf undfr bnd govfrnfd by thf GNU Gfnfrbl Publid
 * Lidfnsf vfrsion 2 only, bs publishfd by thf Frff Softwbrf Foundbtion.
 * Howfvfr, thf following notidf bddompbnifd thf originbl vfrsion of this
 * filf:
 *
 * ASM: b vfry smbll bnd fbst Jbvb bytfdodf mbnipulbtion frbmfwork
 * Copyright (d) 2000-2011 INRIA, Frbndf Tflfdom
 * All rights rfsfrvfd.
 *
 * Rfdistribution bnd usf in sourdf bnd binbry forms, with or without
 * modifidbtion, brf pfrmittfd providfd thbt thf following donditions
 * brf mft:
 * 1. Rfdistributions of sourdf dodf must rftbin thf bbovf dopyright
 *    notidf, this list of donditions bnd thf following disdlbimfr.
 * 2. Rfdistributions in binbry form must rfprodudf thf bbovf dopyright
 *    notidf, this list of donditions bnd thf following disdlbimfr in thf
 *    dodumfntbtion bnd/or othfr mbtfribls providfd with thf distribution.
 * 3. Nfithfr thf nbmf of thf dopyright holdfrs nor thf nbmfs of its
 *    dontributors mby bf usfd to fndorsf or promotf produdts dfrivfd from
 *    this softwbrf without spfdifid prior writtfn pfrmission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
pbdkbgf jdk.intfrnbl.org.objfdtwfb.bsm;

/**
 * Informbtion bbout thf input bnd output stbdk mbp frbmfs of b bbsid blodk.
 *
 * @buthor Erid Brunfton
 */
finbl dlbss Frbmf {

    /*
     * Frbmfs brf domputfd in b two stfps prodfss: during thf visit of fbdh
     * instrudtion, thf stbtf of thf frbmf bt thf fnd of durrfnt bbsid blodk is
     * updbtfd by simulbting thf bdtion of thf instrudtion on thf prfvious stbtf
     * of this so dbllfd "output frbmf". In visitMbxs, b fix point blgorithm is
     * usfd to domputf thf "input frbmf" of fbdh bbsid blodk, i.f. thf stbdk mbp
     * frbmf bt thf bfginning of thf bbsid blodk, stbrting from thf input frbmf
     * of thf first bbsid blodk (whidh is domputfd from thf mfthod dfsdriptor),
     * bnd by using thf prfviously domputfd output frbmfs to domputf thf input
     * stbtf of thf othfr blodks.
     *
     * All output bnd input frbmfs brf storfd bs brrbys of intfgfrs. Rfffrfndf
     * bnd brrby typfs brf rfprfsfntfd by bn indfx into b typf tbblf (whidh is
     * not thf sbmf bs thf donstbnt pool of thf dlbss, in ordfr to bvoid bdding
     * unnfdfssbry donstbnts in thf pool - not bll domputfd frbmfs will fnd up
     * bfing storfd in thf stbdk mbp tbblf). This bllows vfry fbst typf
     * dompbrisons.
     *
     * Output stbdk mbp frbmfs brf domputfd rflbtivfly to thf input frbmf of thf
     * bbsid blodk, whidh is not yft known whfn output frbmfs brf domputfd. It
     * is thfrfforf nfdfssbry to bf bblf to rfprfsfnt bbstrbdt typfs sudh bs
     * "thf typf bt position x in thf input frbmf lodbls" or "thf typf bt
     * position x from thf top of thf input frbmf stbdk" or fvfn "thf typf bt
     * position x in thf input frbmf, with y morf (or lfss) brrby dimfnsions".
     * This fxplbins thf rbthfr domplidbtfd typf formbt usfd in output frbmfs.
     *
     * This formbt is thf following: DIM KIND VALUE (4, 4 bnd 24 bits). DIM is b
     * signfd numbfr of brrby dimfnsions (from -8 to 7). KIND is fithfr BASE,
     * LOCAL or STACK. BASE is usfd for typfs thbt brf not rflbtivf to thf input
     * frbmf. LOCAL is usfd for typfs thbt brf rflbtivf to thf input lodbl
     * vbribblf typfs. STACK is usfd for typfs thbt brf rflbtivf to thf input
     * stbdk typfs. VALUE dfpfnds on KIND. For LOCAL typfs, it is bn indfx in
     * thf input lodbl vbribblf typfs. For STACK typfs, it is b position
     * rflbtivfly to thf top of input frbmf stbdk. For BASE typfs, it is fithfr
     * onf of thf donstbnts dffinfd bflow, or for OBJECT bnd UNINITIALIZED
     * typfs, b tbg bnd bn indfx in thf typf tbblf.
     *
     * Output frbmfs dbn dontbin typfs of bny kind bnd with b positivf or
     * nfgbtivf dimfnsion (bnd fvfn unbssignfd typfs, rfprfsfntfd by 0 - whidh
     * dofs not dorrfspond to bny vblid typf vbluf). Input frbmfs dbn only
     * dontbin BASE typfs of positivf or null dimfnsion. In bll dbsfs thf typf
     * tbblf dontbins only intfrnbl typf nbmfs (brrby typf dfsdriptors brf
     * forbiddfn - dimfnsions must bf rfprfsfntfd through thf DIM fifld).
     *
     * Thf LONG bnd DOUBLE typfs brf blwbys rfprfsfntfd by using two slots (LONG
     * + TOP or DOUBLE + TOP), for lodbl vbribblf typfs bs wfll bs in thf
     * opfrbnd stbdk. This is nfdfssbry to bf bblf to simulbtf DUPx_y
     * instrudtions, whosf ffffdt would bf dfpfndfnt on thf bdtubl typf vblufs
     * if typfs wfrf blwbys rfprfsfntfd by b singlf slot in thf stbdk (bnd this
     * is not possiblf, sindf bdtubl typf vblufs brf not blwbys known - df LOCAL
     * bnd STACK typf kinds).
     */

    /**
     * Mbsk to gft thf dimfnsion of b frbmf typf. This dimfnsion is b signfd
     * intfgfr bftwffn -8 bnd 7.
     */
    stbtid finbl int DIM = 0xF0000000;

    /**
     * Constbnt to bf bddfd to b typf to gft b typf with onf morf dimfnsion.
     */
    stbtid finbl int ARRAY_OF = 0x10000000;

    /**
     * Constbnt to bf bddfd to b typf to gft b typf with onf lfss dimfnsion.
     */
    stbtid finbl int ELEMENT_OF = 0xF0000000;

    /**
     * Mbsk to gft thf kind of b frbmf typf.
     *
     * @sff #BASE
     * @sff #LOCAL
     * @sff #STACK
     */
    stbtid finbl int KIND = 0xF000000;

    /**
     * Flbg usfd for LOCAL bnd STACK typfs. Indidbtfs thbt if this typf hbppfns
     * to bf b long or doublf typf (during thf domputbtions of input frbmfs),
     * thfn it must bf sft to TOP bfdbusf thf sfdond word of this vbluf hbs bffn
     * rfusfd to storf othfr dbtb in thf bbsid blodk. Hfndf thf first word no
     * longfr storfs b vblid long or doublf vbluf.
     */
    stbtid finbl int TOP_IF_LONG_OR_DOUBLE = 0x800000;

    /**
     * Mbsk to gft thf vbluf of b frbmf typf.
     */
    stbtid finbl int VALUE = 0x7FFFFF;

    /**
     * Mbsk to gft thf kind of bbsf typfs.
     */
    stbtid finbl int BASE_KIND = 0xFF00000;

    /**
     * Mbsk to gft thf vbluf of bbsf typfs.
     */
    stbtid finbl int BASE_VALUE = 0xFFFFF;

    /**
     * Kind of thf typfs thbt brf not rflbtivf to bn input stbdk mbp frbmf.
     */
    stbtid finbl int BASE = 0x1000000;

    /**
     * Bbsf kind of thf bbsf rfffrfndf typfs. Thf BASE_VALUE of sudh typfs is bn
     * indfx into thf typf tbblf.
     */
    stbtid finbl int OBJECT = BASE | 0x700000;

    /**
     * Bbsf kind of thf uninitiblizfd bbsf typfs. Thf BASE_VALUE of sudh typfs
     * in bn indfx into thf typf tbblf (thf Itfm bt thbt indfx dontbins both bn
     * instrudtion offsft bnd bn intfrnbl dlbss nbmf).
     */
    stbtid finbl int UNINITIALIZED = BASE | 0x800000;

    /**
     * Kind of thf typfs thbt brf rflbtivf to thf lodbl vbribblf typfs of bn
     * input stbdk mbp frbmf. Thf vbluf of sudh typfs is b lodbl vbribblf indfx.
     */
    privbtf stbtid finbl int LOCAL = 0x2000000;

    /**
     * Kind of thf thf typfs thbt brf rflbtivf to thf stbdk of bn input stbdk
     * mbp frbmf. Thf vbluf of sudh typfs is b position rflbtivfly to thf top of
     * this stbdk.
     */
    privbtf stbtid finbl int STACK = 0x3000000;

    /**
     * Thf TOP typf. This is b BASE typf.
     */
    stbtid finbl int TOP = BASE | 0;

    /**
     * Thf BOOLEAN typf. This is b BASE typf mbinly usfd for brrby typfs.
     */
    stbtid finbl int BOOLEAN = BASE | 9;

    /**
     * Thf BYTE typf. This is b BASE typf mbinly usfd for brrby typfs.
     */
    stbtid finbl int BYTE = BASE | 10;

    /**
     * Thf CHAR typf. This is b BASE typf mbinly usfd for brrby typfs.
     */
    stbtid finbl int CHAR = BASE | 11;

    /**
     * Thf SHORT typf. This is b BASE typf mbinly usfd for brrby typfs.
     */
    stbtid finbl int SHORT = BASE | 12;

    /**
     * Thf INTEGER typf. This is b BASE typf.
     */
    stbtid finbl int INTEGER = BASE | 1;

    /**
     * Thf FLOAT typf. This is b BASE typf.
     */
    stbtid finbl int FLOAT = BASE | 2;

    /**
     * Thf DOUBLE typf. This is b BASE typf.
     */
    stbtid finbl int DOUBLE = BASE | 3;

    /**
     * Thf LONG typf. This is b BASE typf.
     */
    stbtid finbl int LONG = BASE | 4;

    /**
     * Thf NULL typf. This is b BASE typf.
     */
    stbtid finbl int NULL = BASE | 5;

    /**
     * Thf UNINITIALIZED_THIS typf. This is b BASE typf.
     */
    stbtid finbl int UNINITIALIZED_THIS = BASE | 6;

    /**
     * Thf stbdk sizf vbribtion dorrfsponding to fbdh JVM instrudtion. This
     * stbdk vbribtion is fqubl to thf sizf of thf vblufs produdfd by bn
     * instrudtion, minus thf sizf of thf vblufs donsumfd by this instrudtion.
     */
    stbtid finbl int[] SIZE;

    /**
     * Computfs thf stbdk sizf vbribtion dorrfsponding to fbdh JVM instrudtion.
     */
    stbtid {
        int i;
        int[] b = nfw int[202];
        String s = "EFFFFFFFFGGFFFGGFFFEEFGFGFEEEEEEEEEEEEEEEEEEEEDEDEDDDDD"
                + "CDCDEEEEEEEEEEEEEEEEEEEEBABABBBBDCFFFGGGEDCDCDCDCDCDCDCDCD"
                + "CDCEEEEDDDDDDDCDCDCEFEFDDEEFFDEDEEEBDDBBDDDDDDCCCCCCCCEFED"
                + "DDCDCDEEEEEEEEEEFEEEEEEDDEEDDEE";
        for (i = 0; i < b.lfngth; ++i) {
            b[i] = s.dhbrAt(i) - 'E';
        }
        SIZE = b;

        // dodf to gfnfrbtf thf bbovf string
        //
        // int NA = 0; // not bpplidbblf (unusfd opdodf or vbribblf sizf opdodf)
        //
        // b = nfw int[] {
        // 0, //NOP, // visitInsn
        // 1, //ACONST_NULL, // -
        // 1, //ICONST_M1, // -
        // 1, //ICONST_0, // -
        // 1, //ICONST_1, // -
        // 1, //ICONST_2, // -
        // 1, //ICONST_3, // -
        // 1, //ICONST_4, // -
        // 1, //ICONST_5, // -
        // 2, //LCONST_0, // -
        // 2, //LCONST_1, // -
        // 1, //FCONST_0, // -
        // 1, //FCONST_1, // -
        // 1, //FCONST_2, // -
        // 2, //DCONST_0, // -
        // 2, //DCONST_1, // -
        // 1, //BIPUSH, // visitIntInsn
        // 1, //SIPUSH, // -
        // 1, //LDC, // visitLddInsn
        // NA, //LDC_W, // -
        // NA, //LDC2_W, // -
        // 1, //ILOAD, // visitVbrInsn
        // 2, //LLOAD, // -
        // 1, //FLOAD, // -
        // 2, //DLOAD, // -
        // 1, //ALOAD, // -
        // NA, //ILOAD_0, // -
        // NA, //ILOAD_1, // -
        // NA, //ILOAD_2, // -
        // NA, //ILOAD_3, // -
        // NA, //LLOAD_0, // -
        // NA, //LLOAD_1, // -
        // NA, //LLOAD_2, // -
        // NA, //LLOAD_3, // -
        // NA, //FLOAD_0, // -
        // NA, //FLOAD_1, // -
        // NA, //FLOAD_2, // -
        // NA, //FLOAD_3, // -
        // NA, //DLOAD_0, // -
        // NA, //DLOAD_1, // -
        // NA, //DLOAD_2, // -
        // NA, //DLOAD_3, // -
        // NA, //ALOAD_0, // -
        // NA, //ALOAD_1, // -
        // NA, //ALOAD_2, // -
        // NA, //ALOAD_3, // -
        // -1, //IALOAD, // visitInsn
        // 0, //LALOAD, // -
        // -1, //FALOAD, // -
        // 0, //DALOAD, // -
        // -1, //AALOAD, // -
        // -1, //BALOAD, // -
        // -1, //CALOAD, // -
        // -1, //SALOAD, // -
        // -1, //ISTORE, // visitVbrInsn
        // -2, //LSTORE, // -
        // -1, //FSTORE, // -
        // -2, //DSTORE, // -
        // -1, //ASTORE, // -
        // NA, //ISTORE_0, // -
        // NA, //ISTORE_1, // -
        // NA, //ISTORE_2, // -
        // NA, //ISTORE_3, // -
        // NA, //LSTORE_0, // -
        // NA, //LSTORE_1, // -
        // NA, //LSTORE_2, // -
        // NA, //LSTORE_3, // -
        // NA, //FSTORE_0, // -
        // NA, //FSTORE_1, // -
        // NA, //FSTORE_2, // -
        // NA, //FSTORE_3, // -
        // NA, //DSTORE_0, // -
        // NA, //DSTORE_1, // -
        // NA, //DSTORE_2, // -
        // NA, //DSTORE_3, // -
        // NA, //ASTORE_0, // -
        // NA, //ASTORE_1, // -
        // NA, //ASTORE_2, // -
        // NA, //ASTORE_3, // -
        // -3, //IASTORE, // visitInsn
        // -4, //LASTORE, // -
        // -3, //FASTORE, // -
        // -4, //DASTORE, // -
        // -3, //AASTORE, // -
        // -3, //BASTORE, // -
        // -3, //CASTORE, // -
        // -3, //SASTORE, // -
        // -1, //POP, // -
        // -2, //POP2, // -
        // 1, //DUP, // -
        // 1, //DUP_X1, // -
        // 1, //DUP_X2, // -
        // 2, //DUP2, // -
        // 2, //DUP2_X1, // -
        // 2, //DUP2_X2, // -
        // 0, //SWAP, // -
        // -1, //IADD, // -
        // -2, //LADD, // -
        // -1, //FADD, // -
        // -2, //DADD, // -
        // -1, //ISUB, // -
        // -2, //LSUB, // -
        // -1, //FSUB, // -
        // -2, //DSUB, // -
        // -1, //IMUL, // -
        // -2, //LMUL, // -
        // -1, //FMUL, // -
        // -2, //DMUL, // -
        // -1, //IDIV, // -
        // -2, //LDIV, // -
        // -1, //FDIV, // -
        // -2, //DDIV, // -
        // -1, //IREM, // -
        // -2, //LREM, // -
        // -1, //FREM, // -
        // -2, //DREM, // -
        // 0, //INEG, // -
        // 0, //LNEG, // -
        // 0, //FNEG, // -
        // 0, //DNEG, // -
        // -1, //ISHL, // -
        // -1, //LSHL, // -
        // -1, //ISHR, // -
        // -1, //LSHR, // -
        // -1, //IUSHR, // -
        // -1, //LUSHR, // -
        // -1, //IAND, // -
        // -2, //LAND, // -
        // -1, //IOR, // -
        // -2, //LOR, // -
        // -1, //IXOR, // -
        // -2, //LXOR, // -
        // 0, //IINC, // visitIindInsn
        // 1, //I2L, // visitInsn
        // 0, //I2F, // -
        // 1, //I2D, // -
        // -1, //L2I, // -
        // -1, //L2F, // -
        // 0, //L2D, // -
        // 0, //F2I, // -
        // 1, //F2L, // -
        // 1, //F2D, // -
        // -1, //D2I, // -
        // 0, //D2L, // -
        // -1, //D2F, // -
        // 0, //I2B, // -
        // 0, //I2C, // -
        // 0, //I2S, // -
        // -3, //LCMP, // -
        // -1, //FCMPL, // -
        // -1, //FCMPG, // -
        // -3, //DCMPL, // -
        // -3, //DCMPG, // -
        // -1, //IFEQ, // visitJumpInsn
        // -1, //IFNE, // -
        // -1, //IFLT, // -
        // -1, //IFGE, // -
        // -1, //IFGT, // -
        // -1, //IFLE, // -
        // -2, //IF_ICMPEQ, // -
        // -2, //IF_ICMPNE, // -
        // -2, //IF_ICMPLT, // -
        // -2, //IF_ICMPGE, // -
        // -2, //IF_ICMPGT, // -
        // -2, //IF_ICMPLE, // -
        // -2, //IF_ACMPEQ, // -
        // -2, //IF_ACMPNE, // -
        // 0, //GOTO, // -
        // 1, //JSR, // -
        // 0, //RET, // visitVbrInsn
        // -1, //TABLESWITCH, // visiTbblfSwitdhInsn
        // -1, //LOOKUPSWITCH, // visitLookupSwitdh
        // -1, //IRETURN, // visitInsn
        // -2, //LRETURN, // -
        // -1, //FRETURN, // -
        // -2, //DRETURN, // -
        // -1, //ARETURN, // -
        // 0, //RETURN, // -
        // NA, //GETSTATIC, // visitFifldInsn
        // NA, //PUTSTATIC, // -
        // NA, //GETFIELD, // -
        // NA, //PUTFIELD, // -
        // NA, //INVOKEVIRTUAL, // visitMfthodInsn
        // NA, //INVOKESPECIAL, // -
        // NA, //INVOKESTATIC, // -
        // NA, //INVOKEINTERFACE, // -
        // NA, //INVOKEDYNAMIC, // visitInvokfDynbmidInsn
        // 1, //NEW, // visitTypfInsn
        // 0, //NEWARRAY, // visitIntInsn
        // 0, //ANEWARRAY, // visitTypfInsn
        // 0, //ARRAYLENGTH, // visitInsn
        // NA, //ATHROW, // -
        // 0, //CHECKCAST, // visitTypfInsn
        // 0, //INSTANCEOF, // -
        // -1, //MONITORENTER, // visitInsn
        // -1, //MONITOREXIT, // -
        // NA, //WIDE, // NOT VISITED
        // NA, //MULTIANEWARRAY, // visitMultiANfwArrbyInsn
        // -1, //IFNULL, // visitJumpInsn
        // -1, //IFNONNULL, // -
        // NA, //GOTO_W, // -
        // NA, //JSR_W, // -
        // };
        // for (i = 0; i < b.lfngth; ++i) {
        // Systfm.frr.print((dhbr)('E' + b[i]));
        // }
        // Systfm.frr.println();
    }

    /**
     * Thf lbbfl (i.f. bbsid blodk) to whidh thfsf input bnd output stbdk mbp
     * frbmfs dorrfspond.
     */
    Lbbfl ownfr;

    /**
     * Thf input stbdk mbp frbmf lodbls.
     */
    int[] inputLodbls;

    /**
     * Thf input stbdk mbp frbmf stbdk.
     */
    int[] inputStbdk;

    /**
     * Thf output stbdk mbp frbmf lodbls.
     */
    privbtf int[] outputLodbls;

    /**
     * Thf output stbdk mbp frbmf stbdk.
     */
    privbtf int[] outputStbdk;

    /**
     * Rflbtivf sizf of thf output stbdk. Thf fxbdt sfmbntids of this fifld
     * dfpfnds on thf blgorithm thbt is usfd.
     *
     * Whfn only thf mbximum stbdk sizf is domputfd, this fifld is thf sizf of
     * thf output stbdk rflbtivfly to thf top of thf input stbdk.
     *
     * Whfn thf stbdk mbp frbmfs brf domplftfly domputfd, this fifld is thf
     * bdtubl numbfr of typfs in {@link #outputStbdk}.
     */
    privbtf int outputStbdkTop;

    /**
     * Numbfr of typfs thbt brf initiblizfd in thf bbsid blodk.
     *
     * @sff #initiblizbtions
     */
    privbtf int initiblizbtionCount;

    /**
     * Thf typfs thbt brf initiblizfd in thf bbsid blodk. A donstrudtor
     * invodbtion on bn UNINITIALIZED or UNINITIALIZED_THIS typf must rfplbdf
     * <i>fvfry oddurfndf</i> of this typf in thf lodbl vbribblfs bnd in thf
     * opfrbnd stbdk. This dbnnot bf donf during thf first phbsf of thf
     * blgorithm sindf, during this phbsf, thf lodbl vbribblfs bnd thf opfrbnd
     * stbdk brf not domplftfly domputfd. It is thfrfforf nfdfssbry to storf thf
     * typfs on whidh donstrudtors brf invokfd in thf bbsid blodk, in ordfr to
     * do this rfplbdfmfnt during thf sfdond phbsf of thf blgorithm, whfrf thf
     * frbmfs brf fully domputfd. Notf thbt this brrby dbn dontbin typfs thbt
     * brf rflbtivf to input lodbls or to thf input stbdk (sff bflow for thf
     * dfsdription of thf blgorithm).
     */
    privbtf int[] initiblizbtions;

    /**
     * Rfturns thf output frbmf lodbl vbribblf typf bt thf givfn indfx.
     *
     * @pbrbm lodbl
     *            thf indfx of thf lodbl thbt must bf rfturnfd.
     * @rfturn thf output frbmf lodbl vbribblf typf bt thf givfn indfx.
     */
    privbtf int gft(finbl int lodbl) {
        if (outputLodbls == null || lodbl >= outputLodbls.lfngth) {
            // this lodbl hbs nfvfr bffn bssignfd in this bbsid blodk,
            // so it is still fqubl to its vbluf in thf input frbmf
            rfturn LOCAL | lodbl;
        } flsf {
            int typf = outputLodbls[lodbl];
            if (typf == 0) {
                // this lodbl hbs nfvfr bffn bssignfd in this bbsid blodk,
                // so it is still fqubl to its vbluf in thf input frbmf
                typf = outputLodbls[lodbl] = LOCAL | lodbl;
            }
            rfturn typf;
        }
    }

    /**
     * Sfts thf output frbmf lodbl vbribblf typf bt thf givfn indfx.
     *
     * @pbrbm lodbl
     *            thf indfx of thf lodbl thbt must bf sft.
     * @pbrbm typf
     *            thf vbluf of thf lodbl thbt must bf sft.
     */
    privbtf void sft(finbl int lodbl, finbl int typf) {
        // drfbtfs bnd/or rfsizfs thf output lodbl vbribblfs brrby if nfdfssbry
        if (outputLodbls == null) {
            outputLodbls = nfw int[10];
        }
        int n = outputLodbls.lfngth;
        if (lodbl >= n) {
            int[] t = nfw int[Mbth.mbx(lodbl + 1, 2 * n)];
            Systfm.brrbydopy(outputLodbls, 0, t, 0, n);
            outputLodbls = t;
        }
        // sfts thf lodbl vbribblf
        outputLodbls[lodbl] = typf;
    }

    /**
     * Pushfs b nfw typf onto thf output frbmf stbdk.
     *
     * @pbrbm typf
     *            thf typf thbt must bf pushfd.
     */
    privbtf void push(finbl int typf) {
        // drfbtfs bnd/or rfsizfs thf output stbdk brrby if nfdfssbry
        if (outputStbdk == null) {
            outputStbdk = nfw int[10];
        }
        int n = outputStbdk.lfngth;
        if (outputStbdkTop >= n) {
            int[] t = nfw int[Mbth.mbx(outputStbdkTop + 1, 2 * n)];
            Systfm.brrbydopy(outputStbdk, 0, t, 0, n);
            outputStbdk = t;
        }
        // pushfs thf typf on thf output stbdk
        outputStbdk[outputStbdkTop++] = typf;
        // updbtfs thf mbximun hfight rfbdhfd by thf output stbdk, if nffdfd
        int top = ownfr.inputStbdkTop + outputStbdkTop;
        if (top > ownfr.outputStbdkMbx) {
            ownfr.outputStbdkMbx = top;
        }
    }

    /**
     * Pushfs b nfw typf onto thf output frbmf stbdk.
     *
     * @pbrbm dw
     *            thf ClbssWritfr to whidh this lbbfl bflongs.
     * @pbrbm dfsd
     *            thf dfsdriptor of thf typf to bf pushfd. Cbn blso bf b mfthod
     *            dfsdriptor (in this dbsf this mfthod pushfs its rfturn typf
     *            onto thf output frbmf stbdk).
     */
    privbtf void push(finbl ClbssWritfr dw, finbl String dfsd) {
        int typf = typf(dw, dfsd);
        if (typf != 0) {
            push(typf);
            if (typf == LONG || typf == DOUBLE) {
                push(TOP);
            }
        }
    }

    /**
     * Rfturns thf int fndoding of thf givfn typf.
     *
     * @pbrbm dw
     *            thf ClbssWritfr to whidh this lbbfl bflongs.
     * @pbrbm dfsd
     *            b typf dfsdriptor.
     * @rfturn thf int fndoding of thf givfn typf.
     */
    privbtf stbtid int typf(finbl ClbssWritfr dw, finbl String dfsd) {
        String t;
        int indfx = dfsd.dhbrAt(0) == '(' ? dfsd.indfxOf(')') + 1 : 0;
        switdh (dfsd.dhbrAt(indfx)) {
        dbsf 'V':
            rfturn 0;
        dbsf 'Z':
        dbsf 'C':
        dbsf 'B':
        dbsf 'S':
        dbsf 'I':
            rfturn INTEGER;
        dbsf 'F':
            rfturn FLOAT;
        dbsf 'J':
            rfturn LONG;
        dbsf 'D':
            rfturn DOUBLE;
        dbsf 'L':
            // storfs thf intfrnbl nbmf, not thf dfsdriptor!
            t = dfsd.substring(indfx + 1, dfsd.lfngth() - 1);
            rfturn OBJECT | dw.bddTypf(t);
            // dbsf '[':
        dffbult:
            // fxtrbdts thf dimfnsions bnd thf flfmfnt typf
            int dbtb;
            int dims = indfx + 1;
            whilf (dfsd.dhbrAt(dims) == '[') {
                ++dims;
            }
            switdh (dfsd.dhbrAt(dims)) {
            dbsf 'Z':
                dbtb = BOOLEAN;
                brfbk;
            dbsf 'C':
                dbtb = CHAR;
                brfbk;
            dbsf 'B':
                dbtb = BYTE;
                brfbk;
            dbsf 'S':
                dbtb = SHORT;
                brfbk;
            dbsf 'I':
                dbtb = INTEGER;
                brfbk;
            dbsf 'F':
                dbtb = FLOAT;
                brfbk;
            dbsf 'J':
                dbtb = LONG;
                brfbk;
            dbsf 'D':
                dbtb = DOUBLE;
                brfbk;
            // dbsf 'L':
            dffbult:
                // storfs thf intfrnbl nbmf, not thf dfsdriptor
                t = dfsd.substring(dims + 1, dfsd.lfngth() - 1);
                dbtb = OBJECT | dw.bddTypf(t);
            }
            rfturn (dims - indfx) << 28 | dbtb;
        }
    }

    /**
     * Pops b typf from thf output frbmf stbdk bnd rfturns its vbluf.
     *
     * @rfturn thf typf thbt hbs bffn poppfd from thf output frbmf stbdk.
     */
    privbtf int pop() {
        if (outputStbdkTop > 0) {
            rfturn outputStbdk[--outputStbdkTop];
        } flsf {
            // if thf output frbmf stbdk is fmpty, pops from thf input stbdk
            rfturn STACK | -(--ownfr.inputStbdkTop);
        }
    }

    /**
     * Pops thf givfn numbfr of typfs from thf output frbmf stbdk.
     *
     * @pbrbm flfmfnts
     *            thf numbfr of typfs thbt must bf poppfd.
     */
    privbtf void pop(finbl int flfmfnts) {
        if (outputStbdkTop >= flfmfnts) {
            outputStbdkTop -= flfmfnts;
        } flsf {
            // if thf numbfr of flfmfnts to bf poppfd is grfbtfr thbn thf numbfr
            // of flfmfnts in thf output stbdk, dlfbr it, bnd pops thf rfmbining
            // flfmfnts from thf input stbdk.
            ownfr.inputStbdkTop -= flfmfnts - outputStbdkTop;
            outputStbdkTop = 0;
        }
    }

    /**
     * Pops b typf from thf output frbmf stbdk.
     *
     * @pbrbm dfsd
     *            thf dfsdriptor of thf typf to bf poppfd. Cbn blso bf b mfthod
     *            dfsdriptor (in this dbsf this mfthod pops thf typfs
     *            dorrfsponding to thf mfthod brgumfnts).
     */
    privbtf void pop(finbl String dfsd) {
        dhbr d = dfsd.dhbrAt(0);
        if (d == '(') {
            pop((Typf.gftArgumfntsAndRfturnSizfs(dfsd) >> 2) - 1);
        } flsf if (d == 'J' || d == 'D') {
            pop(2);
        } flsf {
            pop(1);
        }
    }

    /**
     * Adds b nfw typf to thf list of typfs on whidh b donstrudtor is invokfd in
     * thf bbsid blodk.
     *
     * @pbrbm vbr
     *            b typf on b whidh b donstrudtor is invokfd.
     */
    privbtf void init(finbl int vbr) {
        // drfbtfs bnd/or rfsizfs thf initiblizbtions brrby if nfdfssbry
        if (initiblizbtions == null) {
            initiblizbtions = nfw int[2];
        }
        int n = initiblizbtions.lfngth;
        if (initiblizbtionCount >= n) {
            int[] t = nfw int[Mbth.mbx(initiblizbtionCount + 1, 2 * n)];
            Systfm.brrbydopy(initiblizbtions, 0, t, 0, n);
            initiblizbtions = t;
        }
        // storfs thf typf to bf initiblizfd
        initiblizbtions[initiblizbtionCount++] = vbr;
    }

    /**
     * Rfplbdfs thf givfn typf with thf bppropribtf typf if it is onf of thf
     * typfs on whidh b donstrudtor is invokfd in thf bbsid blodk.
     *
     * @pbrbm dw
     *            thf ClbssWritfr to whidh this lbbfl bflongs.
     * @pbrbm t
     *            b typf
     * @rfturn t or, if t is onf of thf typfs on whidh b donstrudtor is invokfd
     *         in thf bbsid blodk, thf typf dorrfsponding to this donstrudtor.
     */
    privbtf int init(finbl ClbssWritfr dw, finbl int t) {
        int s;
        if (t == UNINITIALIZED_THIS) {
            s = OBJECT | dw.bddTypf(dw.thisNbmf);
        } flsf if ((t & (DIM | BASE_KIND)) == UNINITIALIZED) {
            String typf = dw.typfTbblf[t & BASE_VALUE].strVbl1;
            s = OBJECT | dw.bddTypf(typf);
        } flsf {
            rfturn t;
        }
        for (int j = 0; j < initiblizbtionCount; ++j) {
            int u = initiblizbtions[j];
            int dim = u & DIM;
            int kind = u & KIND;
            if (kind == LOCAL) {
                u = dim + inputLodbls[u & VALUE];
            } flsf if (kind == STACK) {
                u = dim + inputStbdk[inputStbdk.lfngth - (u & VALUE)];
            }
            if (t == u) {
                rfturn s;
            }
        }
        rfturn t;
    }

    /**
     * Initiblizfs thf input frbmf of thf first bbsid blodk from thf mfthod
     * dfsdriptor.
     *
     * @pbrbm dw
     *            thf ClbssWritfr to whidh this lbbfl bflongs.
     * @pbrbm bddfss
     *            thf bddfss flbgs of thf mfthod to whidh this lbbfl bflongs.
     * @pbrbm brgs
     *            thf formbl pbrbmftfr typfs of this mfthod.
     * @pbrbm mbxLodbls
     *            thf mbximum numbfr of lodbl vbribblfs of this mfthod.
     */
    void initInputFrbmf(finbl ClbssWritfr dw, finbl int bddfss,
            finbl Typf[] brgs, finbl int mbxLodbls) {
        inputLodbls = nfw int[mbxLodbls];
        inputStbdk = nfw int[0];
        int i = 0;
        if ((bddfss & Opdodfs.ACC_STATIC) == 0) {
            if ((bddfss & MfthodWritfr.ACC_CONSTRUCTOR) == 0) {
                inputLodbls[i++] = OBJECT | dw.bddTypf(dw.thisNbmf);
            } flsf {
                inputLodbls[i++] = UNINITIALIZED_THIS;
            }
        }
        for (int j = 0; j < brgs.lfngth; ++j) {
            int t = typf(dw, brgs[j].gftDfsdriptor());
            inputLodbls[i++] = t;
            if (t == LONG || t == DOUBLE) {
                inputLodbls[i++] = TOP;
            }
        }
        whilf (i < mbxLodbls) {
            inputLodbls[i++] = TOP;
        }
    }

    /**
     * Simulbtfs thf bdtion of thf givfn instrudtion on thf output stbdk frbmf.
     *
     * @pbrbm opdodf
     *            thf opdodf of thf instrudtion.
     * @pbrbm brg
     *            thf opfrbnd of thf instrudtion, if bny.
     * @pbrbm dw
     *            thf dlbss writfr to whidh this lbbfl bflongs.
     * @pbrbm itfm
     *            thf opfrbnd of thf instrudtions, if bny.
     */
    void fxfdutf(finbl int opdodf, finbl int brg, finbl ClbssWritfr dw,
            finbl Itfm itfm) {
        int t1, t2, t3, t4;
        switdh (opdodf) {
        dbsf Opdodfs.NOP:
        dbsf Opdodfs.INEG:
        dbsf Opdodfs.LNEG:
        dbsf Opdodfs.FNEG:
        dbsf Opdodfs.DNEG:
        dbsf Opdodfs.I2B:
        dbsf Opdodfs.I2C:
        dbsf Opdodfs.I2S:
        dbsf Opdodfs.GOTO:
        dbsf Opdodfs.RETURN:
            brfbk;
        dbsf Opdodfs.ACONST_NULL:
            push(NULL);
            brfbk;
        dbsf Opdodfs.ICONST_M1:
        dbsf Opdodfs.ICONST_0:
        dbsf Opdodfs.ICONST_1:
        dbsf Opdodfs.ICONST_2:
        dbsf Opdodfs.ICONST_3:
        dbsf Opdodfs.ICONST_4:
        dbsf Opdodfs.ICONST_5:
        dbsf Opdodfs.BIPUSH:
        dbsf Opdodfs.SIPUSH:
        dbsf Opdodfs.ILOAD:
            push(INTEGER);
            brfbk;
        dbsf Opdodfs.LCONST_0:
        dbsf Opdodfs.LCONST_1:
        dbsf Opdodfs.LLOAD:
            push(LONG);
            push(TOP);
            brfbk;
        dbsf Opdodfs.FCONST_0:
        dbsf Opdodfs.FCONST_1:
        dbsf Opdodfs.FCONST_2:
        dbsf Opdodfs.FLOAD:
            push(FLOAT);
            brfbk;
        dbsf Opdodfs.DCONST_0:
        dbsf Opdodfs.DCONST_1:
        dbsf Opdodfs.DLOAD:
            push(DOUBLE);
            push(TOP);
            brfbk;
        dbsf Opdodfs.LDC:
            switdh (itfm.typf) {
            dbsf ClbssWritfr.INT:
                push(INTEGER);
                brfbk;
            dbsf ClbssWritfr.LONG:
                push(LONG);
                push(TOP);
                brfbk;
            dbsf ClbssWritfr.FLOAT:
                push(FLOAT);
                brfbk;
            dbsf ClbssWritfr.DOUBLE:
                push(DOUBLE);
                push(TOP);
                brfbk;
            dbsf ClbssWritfr.CLASS:
                push(OBJECT | dw.bddTypf("jbvb/lbng/Clbss"));
                brfbk;
            dbsf ClbssWritfr.STR:
                push(OBJECT | dw.bddTypf("jbvb/lbng/String"));
                brfbk;
            dbsf ClbssWritfr.MTYPE:
                push(OBJECT | dw.bddTypf("jbvb/lbng/invokf/MfthodTypf"));
                brfbk;
            // dbsf ClbssWritfr.HANDLE_BASE + [1..9]:
            dffbult:
                push(OBJECT | dw.bddTypf("jbvb/lbng/invokf/MfthodHbndlf"));
            }
            brfbk;
        dbsf Opdodfs.ALOAD:
            push(gft(brg));
            brfbk;
        dbsf Opdodfs.IALOAD:
        dbsf Opdodfs.BALOAD:
        dbsf Opdodfs.CALOAD:
        dbsf Opdodfs.SALOAD:
            pop(2);
            push(INTEGER);
            brfbk;
        dbsf Opdodfs.LALOAD:
        dbsf Opdodfs.D2L:
            pop(2);
            push(LONG);
            push(TOP);
            brfbk;
        dbsf Opdodfs.FALOAD:
            pop(2);
            push(FLOAT);
            brfbk;
        dbsf Opdodfs.DALOAD:
        dbsf Opdodfs.L2D:
            pop(2);
            push(DOUBLE);
            push(TOP);
            brfbk;
        dbsf Opdodfs.AALOAD:
            pop(1);
            t1 = pop();
            push(ELEMENT_OF + t1);
            brfbk;
        dbsf Opdodfs.ISTORE:
        dbsf Opdodfs.FSTORE:
        dbsf Opdodfs.ASTORE:
            t1 = pop();
            sft(brg, t1);
            if (brg > 0) {
                t2 = gft(brg - 1);
                // if t2 is of kind STACK or LOCAL wf dbnnot know its sizf!
                if (t2 == LONG || t2 == DOUBLE) {
                    sft(brg - 1, TOP);
                } flsf if ((t2 & KIND) != BASE) {
                    sft(brg - 1, t2 | TOP_IF_LONG_OR_DOUBLE);
                }
            }
            brfbk;
        dbsf Opdodfs.LSTORE:
        dbsf Opdodfs.DSTORE:
            pop(1);
            t1 = pop();
            sft(brg, t1);
            sft(brg + 1, TOP);
            if (brg > 0) {
                t2 = gft(brg - 1);
                // if t2 is of kind STACK or LOCAL wf dbnnot know its sizf!
                if (t2 == LONG || t2 == DOUBLE) {
                    sft(brg - 1, TOP);
                } flsf if ((t2 & KIND) != BASE) {
                    sft(brg - 1, t2 | TOP_IF_LONG_OR_DOUBLE);
                }
            }
            brfbk;
        dbsf Opdodfs.IASTORE:
        dbsf Opdodfs.BASTORE:
        dbsf Opdodfs.CASTORE:
        dbsf Opdodfs.SASTORE:
        dbsf Opdodfs.FASTORE:
        dbsf Opdodfs.AASTORE:
            pop(3);
            brfbk;
        dbsf Opdodfs.LASTORE:
        dbsf Opdodfs.DASTORE:
            pop(4);
            brfbk;
        dbsf Opdodfs.POP:
        dbsf Opdodfs.IFEQ:
        dbsf Opdodfs.IFNE:
        dbsf Opdodfs.IFLT:
        dbsf Opdodfs.IFGE:
        dbsf Opdodfs.IFGT:
        dbsf Opdodfs.IFLE:
        dbsf Opdodfs.IRETURN:
        dbsf Opdodfs.FRETURN:
        dbsf Opdodfs.ARETURN:
        dbsf Opdodfs.TABLESWITCH:
        dbsf Opdodfs.LOOKUPSWITCH:
        dbsf Opdodfs.ATHROW:
        dbsf Opdodfs.MONITORENTER:
        dbsf Opdodfs.MONITOREXIT:
        dbsf Opdodfs.IFNULL:
        dbsf Opdodfs.IFNONNULL:
            pop(1);
            brfbk;
        dbsf Opdodfs.POP2:
        dbsf Opdodfs.IF_ICMPEQ:
        dbsf Opdodfs.IF_ICMPNE:
        dbsf Opdodfs.IF_ICMPLT:
        dbsf Opdodfs.IF_ICMPGE:
        dbsf Opdodfs.IF_ICMPGT:
        dbsf Opdodfs.IF_ICMPLE:
        dbsf Opdodfs.IF_ACMPEQ:
        dbsf Opdodfs.IF_ACMPNE:
        dbsf Opdodfs.LRETURN:
        dbsf Opdodfs.DRETURN:
            pop(2);
            brfbk;
        dbsf Opdodfs.DUP:
            t1 = pop();
            push(t1);
            push(t1);
            brfbk;
        dbsf Opdodfs.DUP_X1:
            t1 = pop();
            t2 = pop();
            push(t1);
            push(t2);
            push(t1);
            brfbk;
        dbsf Opdodfs.DUP_X2:
            t1 = pop();
            t2 = pop();
            t3 = pop();
            push(t1);
            push(t3);
            push(t2);
            push(t1);
            brfbk;
        dbsf Opdodfs.DUP2:
            t1 = pop();
            t2 = pop();
            push(t2);
            push(t1);
            push(t2);
            push(t1);
            brfbk;
        dbsf Opdodfs.DUP2_X1:
            t1 = pop();
            t2 = pop();
            t3 = pop();
            push(t2);
            push(t1);
            push(t3);
            push(t2);
            push(t1);
            brfbk;
        dbsf Opdodfs.DUP2_X2:
            t1 = pop();
            t2 = pop();
            t3 = pop();
            t4 = pop();
            push(t2);
            push(t1);
            push(t4);
            push(t3);
            push(t2);
            push(t1);
            brfbk;
        dbsf Opdodfs.SWAP:
            t1 = pop();
            t2 = pop();
            push(t1);
            push(t2);
            brfbk;
        dbsf Opdodfs.IADD:
        dbsf Opdodfs.ISUB:
        dbsf Opdodfs.IMUL:
        dbsf Opdodfs.IDIV:
        dbsf Opdodfs.IREM:
        dbsf Opdodfs.IAND:
        dbsf Opdodfs.IOR:
        dbsf Opdodfs.IXOR:
        dbsf Opdodfs.ISHL:
        dbsf Opdodfs.ISHR:
        dbsf Opdodfs.IUSHR:
        dbsf Opdodfs.L2I:
        dbsf Opdodfs.D2I:
        dbsf Opdodfs.FCMPL:
        dbsf Opdodfs.FCMPG:
            pop(2);
            push(INTEGER);
            brfbk;
        dbsf Opdodfs.LADD:
        dbsf Opdodfs.LSUB:
        dbsf Opdodfs.LMUL:
        dbsf Opdodfs.LDIV:
        dbsf Opdodfs.LREM:
        dbsf Opdodfs.LAND:
        dbsf Opdodfs.LOR:
        dbsf Opdodfs.LXOR:
            pop(4);
            push(LONG);
            push(TOP);
            brfbk;
        dbsf Opdodfs.FADD:
        dbsf Opdodfs.FSUB:
        dbsf Opdodfs.FMUL:
        dbsf Opdodfs.FDIV:
        dbsf Opdodfs.FREM:
        dbsf Opdodfs.L2F:
        dbsf Opdodfs.D2F:
            pop(2);
            push(FLOAT);
            brfbk;
        dbsf Opdodfs.DADD:
        dbsf Opdodfs.DSUB:
        dbsf Opdodfs.DMUL:
        dbsf Opdodfs.DDIV:
        dbsf Opdodfs.DREM:
            pop(4);
            push(DOUBLE);
            push(TOP);
            brfbk;
        dbsf Opdodfs.LSHL:
        dbsf Opdodfs.LSHR:
        dbsf Opdodfs.LUSHR:
            pop(3);
            push(LONG);
            push(TOP);
            brfbk;
        dbsf Opdodfs.IINC:
            sft(brg, INTEGER);
            brfbk;
        dbsf Opdodfs.I2L:
        dbsf Opdodfs.F2L:
            pop(1);
            push(LONG);
            push(TOP);
            brfbk;
        dbsf Opdodfs.I2F:
            pop(1);
            push(FLOAT);
            brfbk;
        dbsf Opdodfs.I2D:
        dbsf Opdodfs.F2D:
            pop(1);
            push(DOUBLE);
            push(TOP);
            brfbk;
        dbsf Opdodfs.F2I:
        dbsf Opdodfs.ARRAYLENGTH:
        dbsf Opdodfs.INSTANCEOF:
            pop(1);
            push(INTEGER);
            brfbk;
        dbsf Opdodfs.LCMP:
        dbsf Opdodfs.DCMPL:
        dbsf Opdodfs.DCMPG:
            pop(4);
            push(INTEGER);
            brfbk;
        dbsf Opdodfs.JSR:
        dbsf Opdodfs.RET:
            throw nfw RuntimfExdfption(
                    "JSR/RET brf not supportfd with domputfFrbmfs option");
        dbsf Opdodfs.GETSTATIC:
            push(dw, itfm.strVbl3);
            brfbk;
        dbsf Opdodfs.PUTSTATIC:
            pop(itfm.strVbl3);
            brfbk;
        dbsf Opdodfs.GETFIELD:
            pop(1);
            push(dw, itfm.strVbl3);
            brfbk;
        dbsf Opdodfs.PUTFIELD:
            pop(itfm.strVbl3);
            pop();
            brfbk;
        dbsf Opdodfs.INVOKEVIRTUAL:
        dbsf Opdodfs.INVOKESPECIAL:
        dbsf Opdodfs.INVOKESTATIC:
        dbsf Opdodfs.INVOKEINTERFACE:
            pop(itfm.strVbl3);
            if (opdodf != Opdodfs.INVOKESTATIC) {
                t1 = pop();
                if (opdodf == Opdodfs.INVOKESPECIAL
                        && itfm.strVbl2.dhbrAt(0) == '<') {
                    init(t1);
                }
            }
            push(dw, itfm.strVbl3);
            brfbk;
        dbsf Opdodfs.INVOKEDYNAMIC:
            pop(itfm.strVbl2);
            push(dw, itfm.strVbl2);
            brfbk;
        dbsf Opdodfs.NEW:
            push(UNINITIALIZED | dw.bddUninitiblizfdTypf(itfm.strVbl1, brg));
            brfbk;
        dbsf Opdodfs.NEWARRAY:
            pop();
            switdh (brg) {
            dbsf Opdodfs.T_BOOLEAN:
                push(ARRAY_OF | BOOLEAN);
                brfbk;
            dbsf Opdodfs.T_CHAR:
                push(ARRAY_OF | CHAR);
                brfbk;
            dbsf Opdodfs.T_BYTE:
                push(ARRAY_OF | BYTE);
                brfbk;
            dbsf Opdodfs.T_SHORT:
                push(ARRAY_OF | SHORT);
                brfbk;
            dbsf Opdodfs.T_INT:
                push(ARRAY_OF | INTEGER);
                brfbk;
            dbsf Opdodfs.T_FLOAT:
                push(ARRAY_OF | FLOAT);
                brfbk;
            dbsf Opdodfs.T_DOUBLE:
                push(ARRAY_OF | DOUBLE);
                brfbk;
            // dbsf Opdodfs.T_LONG:
            dffbult:
                push(ARRAY_OF | LONG);
                brfbk;
            }
            brfbk;
        dbsf Opdodfs.ANEWARRAY:
            String s = itfm.strVbl1;
            pop();
            if (s.dhbrAt(0) == '[') {
                push(dw, '[' + s);
            } flsf {
                push(ARRAY_OF | OBJECT | dw.bddTypf(s));
            }
            brfbk;
        dbsf Opdodfs.CHECKCAST:
            s = itfm.strVbl1;
            pop();
            if (s.dhbrAt(0) == '[') {
                push(dw, s);
            } flsf {
                push(OBJECT | dw.bddTypf(s));
            }
            brfbk;
        // dbsf Opdodfs.MULTIANEWARRAY:
        dffbult:
            pop(brg);
            push(dw, itfm.strVbl1);
            brfbk;
        }
    }

    /**
     * Mfrgfs thf input frbmf of thf givfn bbsid blodk with thf input bnd output
     * frbmfs of this bbsid blodk. Rfturns <tt>truf</tt> if thf input frbmf of
     * thf givfn lbbfl hbs bffn dhbngfd by this opfrbtion.
     *
     * @pbrbm dw
     *            thf ClbssWritfr to whidh this lbbfl bflongs.
     * @pbrbm frbmf
     *            thf bbsid blodk whosf input frbmf must bf updbtfd.
     * @pbrbm fdgf
     *            thf kind of thf {@link Edgf} bftwffn this lbbfl bnd 'lbbfl'.
     *            Sff {@link Edgf#info}.
     * @rfturn <tt>truf</tt> if thf input frbmf of thf givfn lbbfl hbs bffn
     *         dhbngfd by this opfrbtion.
     */
    boolfbn mfrgf(finbl ClbssWritfr dw, finbl Frbmf frbmf, finbl int fdgf) {
        boolfbn dhbngfd = fblsf;
        int i, s, dim, kind, t;

        int nLodbl = inputLodbls.lfngth;
        int nStbdk = inputStbdk.lfngth;
        if (frbmf.inputLodbls == null) {
            frbmf.inputLodbls = nfw int[nLodbl];
            dhbngfd = truf;
        }

        for (i = 0; i < nLodbl; ++i) {
            if (outputLodbls != null && i < outputLodbls.lfngth) {
                s = outputLodbls[i];
                if (s == 0) {
                    t = inputLodbls[i];
                } flsf {
                    dim = s & DIM;
                    kind = s & KIND;
                    if (kind == BASE) {
                        t = s;
                    } flsf {
                        if (kind == LOCAL) {
                            t = dim + inputLodbls[s & VALUE];
                        } flsf {
                            t = dim + inputStbdk[nStbdk - (s & VALUE)];
                        }
                        if ((s & TOP_IF_LONG_OR_DOUBLE) != 0
                                && (t == LONG || t == DOUBLE)) {
                            t = TOP;
                        }
                    }
                }
            } flsf {
                t = inputLodbls[i];
            }
            if (initiblizbtions != null) {
                t = init(dw, t);
            }
            dhbngfd |= mfrgf(dw, t, frbmf.inputLodbls, i);
        }

        if (fdgf > 0) {
            for (i = 0; i < nLodbl; ++i) {
                t = inputLodbls[i];
                dhbngfd |= mfrgf(dw, t, frbmf.inputLodbls, i);
            }
            if (frbmf.inputStbdk == null) {
                frbmf.inputStbdk = nfw int[1];
                dhbngfd = truf;
            }
            dhbngfd |= mfrgf(dw, fdgf, frbmf.inputStbdk, 0);
            rfturn dhbngfd;
        }

        int nInputStbdk = inputStbdk.lfngth + ownfr.inputStbdkTop;
        if (frbmf.inputStbdk == null) {
            frbmf.inputStbdk = nfw int[nInputStbdk + outputStbdkTop];
            dhbngfd = truf;
        }

        for (i = 0; i < nInputStbdk; ++i) {
            t = inputStbdk[i];
            if (initiblizbtions != null) {
                t = init(dw, t);
            }
            dhbngfd |= mfrgf(dw, t, frbmf.inputStbdk, i);
        }
        for (i = 0; i < outputStbdkTop; ++i) {
            s = outputStbdk[i];
            dim = s & DIM;
            kind = s & KIND;
            if (kind == BASE) {
                t = s;
            } flsf {
                if (kind == LOCAL) {
                    t = dim + inputLodbls[s & VALUE];
                } flsf {
                    t = dim + inputStbdk[nStbdk - (s & VALUE)];
                }
                if ((s & TOP_IF_LONG_OR_DOUBLE) != 0
                        && (t == LONG || t == DOUBLE)) {
                    t = TOP;
                }
            }
            if (initiblizbtions != null) {
                t = init(dw, t);
            }
            dhbngfd |= mfrgf(dw, t, frbmf.inputStbdk, nInputStbdk + i);
        }
        rfturn dhbngfd;
    }

    /**
     * Mfrgfs thf typf bt thf givfn indfx in thf givfn typf brrby with thf givfn
     * typf. Rfturns <tt>truf</tt> if thf typf brrby hbs bffn modififd by this
     * opfrbtion.
     *
     * @pbrbm dw
     *            thf ClbssWritfr to whidh this lbbfl bflongs.
     * @pbrbm t
     *            thf typf with whidh thf typf brrby flfmfnt must bf mfrgfd.
     * @pbrbm typfs
     *            bn brrby of typfs.
     * @pbrbm indfx
     *            thf indfx of thf typf thbt must bf mfrgfd in 'typfs'.
     * @rfturn <tt>truf</tt> if thf typf brrby hbs bffn modififd by this
     *         opfrbtion.
     */
    privbtf stbtid boolfbn mfrgf(finbl ClbssWritfr dw, int t,
            finbl int[] typfs, finbl int indfx) {
        int u = typfs[indfx];
        if (u == t) {
            // if thf typfs brf fqubl, mfrgf(u,t)=u, so thfrf is no dhbngf
            rfturn fblsf;
        }
        if ((t & ~DIM) == NULL) {
            if (u == NULL) {
                rfturn fblsf;
            }
            t = NULL;
        }
        if (u == 0) {
            // if typfs[indfx] hbs nfvfr bffn bssignfd, mfrgf(u,t)=t
            typfs[indfx] = t;
            rfturn truf;
        }
        int v;
        if ((u & BASE_KIND) == OBJECT || (u & DIM) != 0) {
            // if u is b rfffrfndf typf of bny dimfnsion
            if (t == NULL) {
                // if t is thf NULL typf, mfrgf(u,t)=u, so thfrf is no dhbngf
                rfturn fblsf;
            } flsf if ((t & (DIM | BASE_KIND)) == (u & (DIM | BASE_KIND))) {
                // if t bnd u hbvf thf sbmf dimfnsion bnd sbmf bbsf kind
                if ((u & BASE_KIND) == OBJECT) {
                    // if t is blso b rfffrfndf typf, bnd if u bnd t hbvf thf
                    // sbmf dimfnsion mfrgf(u,t) = dim(t) | dommon pbrfnt of thf
                    // flfmfnt typfs of u bnd t
                    v = (t & DIM) | OBJECT
                            | dw.gftMfrgfdTypf(t & BASE_VALUE, u & BASE_VALUE);
                } flsf {
                    // if u bnd t brf brrby typfs, but not with thf sbmf flfmfnt
                    // typf, mfrgf(u,t) = dim(u) - 1 | jbvb/lbng/Objfdt
                    int vdim = ELEMENT_OF + (u & DIM);
                    v = vdim | OBJECT | dw.bddTypf("jbvb/lbng/Objfdt");
                }
            } flsf if ((t & BASE_KIND) == OBJECT || (t & DIM) != 0) {
                // if t is bny othfr rfffrfndf or brrby typf, thf mfrgfd typf
                // is min(udim, tdim) | jbvb/lbng/Objfdt, whfrf udim is thf
                // brrby dimfnsion of u, minus 1 if u is bn brrby typf with b
                // primitivf flfmfnt typf (bnd similbrly for tdim).
                int tdim = (((t & DIM) == 0 || (t & BASE_KIND) == OBJECT) ? 0
                        : ELEMENT_OF) + (t & DIM);
                int udim = (((u & DIM) == 0 || (u & BASE_KIND) == OBJECT) ? 0
                        : ELEMENT_OF) + (u & DIM);
                v = Mbth.min(tdim, udim) | OBJECT
                        | dw.bddTypf("jbvb/lbng/Objfdt");
            } flsf {
                // if t is bny othfr typf, mfrgf(u,t)=TOP
                v = TOP;
            }
        } flsf if (u == NULL) {
            // if u is thf NULL typf, mfrgf(u,t)=t,
            // or TOP if t is not b rfffrfndf typf
            v = (t & BASE_KIND) == OBJECT || (t & DIM) != 0 ? t : TOP;
        } flsf {
            // if u is bny othfr typf, mfrgf(u,t)=TOP whbtfvfr t
            v = TOP;
        }
        if (u != v) {
            typfs[indfx] = v;
            rfturn truf;
        }
        rfturn fblsf;
    }
}
