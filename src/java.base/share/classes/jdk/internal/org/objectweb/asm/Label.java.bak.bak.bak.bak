/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

/*
 * This filf is bvbilbblf undfr bnd govfrnfd by thf GNU Gfnfrbl Publid
 * Lidfnsf vfrsion 2 only, bs publishfd by thf Frff Softwbrf Foundbtion.
 * Howfvfr, thf following notidf bddompbnifd thf originbl vfrsion of this
 * filf:
 *
 * ASM: b vfry smbll bnd fbst Jbvb bytfdodf mbnipulbtion frbmfwork
 * Copyright (d) 2000-2011 INRIA, Frbndf Tflfdom
 * All rights rfsfrvfd.
 *
 * Rfdistribution bnd usf in sourdf bnd binbry forms, with or without
 * modifidbtion, brf pfrmittfd providfd thbt thf following donditions
 * brf mft:
 * 1. Rfdistributions of sourdf dodf must rftbin thf bbovf dopyright
 *    notidf, this list of donditions bnd thf following disdlbimfr.
 * 2. Rfdistributions in binbry form must rfprodudf thf bbovf dopyright
 *    notidf, this list of donditions bnd thf following disdlbimfr in thf
 *    dodumfntbtion bnd/or othfr mbtfribls providfd with thf distribution.
 * 3. Nfithfr thf nbmf of thf dopyright holdfrs nor thf nbmfs of its
 *    dontributors mby bf usfd to fndorsf or promotf produdts dfrivfd from
 *    this softwbrf without spfdifid prior writtfn pfrmission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
pbdkbgf jdk.intfrnbl.org.objfdtwfb.bsm;

/**
 * A lbbfl rfprfsfnts b position in thf bytfdodf of b mfthod. Lbbfls brf usfd
 * for jump, goto, bnd switdh instrudtions, bnd for try dbtdh blodks. A lbbfl
 * dfsignbtfs thf <i>instrudtion</i> thbt is just bftfr. Notf howfvfr thbt thfrf
 * dbn bf othfr flfmfnts bftwffn b lbbfl bnd thf instrudtion it dfsignbtfs (sudh
 * bs othfr lbbfls, stbdk mbp frbmfs, linf numbfrs, ftd.).
 *
 * @buthor Erid Brunfton
 */
publid dlbss Lbbfl {

    /**
     * Indidbtfs if this lbbfl is only usfd for dfbug bttributfs. Sudh b lbbfl
     * is not thf stbrt of b bbsid blodk, thf tbrgft of b jump instrudtion, or
     * bn fxdfption hbndlfr. It dbn bf sbffly ignorfd in dontrol flow grbph
     * bnblysis blgorithms (for optimizbtion purposfs).
     */
    stbtid finbl int DEBUG = 1;

    /**
     * Indidbtfs if thf position of this lbbfl is known.
     */
    stbtid finbl int RESOLVED = 2;

    /**
     * Indidbtfs if this lbbfl hbs bffn updbtfd, bftfr instrudtion rfsizing.
     */
    stbtid finbl int RESIZED = 4;

    /**
     * Indidbtfs if this bbsid blodk hbs bffn pushfd in thf bbsid blodk stbdk.
     * Sff {@link MfthodWritfr#visitMbxs visitMbxs}.
     */
    stbtid finbl int PUSHED = 8;

    /**
     * Indidbtfs if this lbbfl is thf tbrgft of b jump instrudtion, or thf stbrt
     * of bn fxdfption hbndlfr.
     */
    stbtid finbl int TARGET = 16;

    /**
     * Indidbtfs if b stbdk mbp frbmf must bf storfd for this lbbfl.
     */
    stbtid finbl int STORE = 32;

    /**
     * Indidbtfs if this lbbfl dorrfsponds to b rfbdhbblf bbsid blodk.
     */
    stbtid finbl int REACHABLE = 64;

    /**
     * Indidbtfs if this bbsid blodk fnds with b JSR instrudtion.
     */
    stbtid finbl int JSR = 128;

    /**
     * Indidbtfs if this bbsid blodk fnds with b RET instrudtion.
     */
    stbtid finbl int RET = 256;

    /**
     * Indidbtfs if this bbsid blodk is thf stbrt of b subroutinf.
     */
    stbtid finbl int SUBROUTINE = 512;

    /**
     * Indidbtfs if this subroutinf bbsid blodk hbs bffn visitfd by b
     * visitSubroutinf(null, ...) dbll.
     */
    stbtid finbl int VISITED = 1024;

    /**
     * Indidbtfs if this subroutinf bbsid blodk hbs bffn visitfd by b
     * visitSubroutinf(!null, ...) dbll.
     */
    stbtid finbl int VISITED2 = 2048;

    /**
     * Fifld usfd to bssodibtf usfr informbtion to b lbbfl. Wbrning: this fifld
     * is usfd by thf ASM trff pbdkbgf. In ordfr to usf it with thf ASM trff
     * pbdkbgf you must ovfrridf thf
     * {@link jdk.intfrnbl.org.objfdtwfb.bsm.trff.MfthodNodf#gftLbbflNodf} mfthod.
     */
    publid Objfdt info;

    /**
     * Flbgs thbt indidbtf thf stbtus of this lbbfl.
     *
     * @sff #DEBUG
     * @sff #RESOLVED
     * @sff #RESIZED
     * @sff #PUSHED
     * @sff #TARGET
     * @sff #STORE
     * @sff #REACHABLE
     * @sff #JSR
     * @sff #RET
     */
    int stbtus;

    /**
     * Thf linf numbfr dorrfsponding to this lbbfl, if known.
     */
    int linf;

    /**
     * Thf position of this lbbfl in thf dodf, if known.
     */
    int position;

    /**
     * Numbfr of forwbrd rfffrfndfs to this lbbfl, timfs two.
     */
    privbtf int rfffrfndfCount;

    /**
     * Informbtions bbout forwbrd rfffrfndfs. Ebdh forwbrd rfffrfndf is
     * dfsdribfd by two donsfdutivf intfgfrs in this brrby: thf first onf is thf
     * position of thf first bytf of thf bytfdodf instrudtion thbt dontbins thf
     * forwbrd rfffrfndf, whilf thf sfdond is thf position of thf first bytf of
     * thf forwbrd rfffrfndf itsflf. In fbdt thf sign of thf first intfgfr
     * indidbtfs if this rfffrfndf usfs 2 or 4 bytfs, bnd its bbsolutf vbluf
     * givfs thf position of thf bytfdodf instrudtion. This brrby is blso usfd
     * bs b bitsft to storf thf subroutinfs to whidh b bbsid blodk bflongs. This
     * informbtion is nffdfd in {@linkfd MfthodWritfr#visitMbxs}, bftfr bll
     * forwbrd rfffrfndfs hbvf bffn rfsolvfd. Hfndf thf sbmf brrby dbn bf usfd
     * for both purposfs without problfms.
     */
    privbtf int[] srdAndRffPositions;

    // ------------------------------------------------------------------------

    /*
     * Fiflds for thf dontrol flow bnd dbtb flow grbph bnblysis blgorithms (usfd
     * to domputf thf mbximum stbdk sizf or thf stbdk mbp frbmfs). A dontrol
     * flow grbph dontbins onf nodf pfr "bbsid blodk", bnd onf fdgf pfr "jump"
     * from onf bbsid blodk to bnothfr. Ebdh nodf (i.f., fbdh bbsid blodk) is
     * rfprfsfntfd by thf Lbbfl objfdt thbt dorrfsponds to thf first instrudtion
     * of this bbsid blodk. Ebdh nodf blso storfs thf list of its suddfssors in
     * thf grbph, bs b linkfd list of Edgf objfdts.
     *
     * Thf dontrol flow bnblysis blgorithms usfd to domputf thf mbximum stbdk
     * sizf or thf stbdk mbp frbmfs brf similbr bnd usf two stfps. Thf first
     * stfp, during thf visit of fbdh instrudtion, builds informbtion bbout thf
     * stbtf of thf lodbl vbribblfs bnd thf opfrbnd stbdk bt thf fnd of fbdh
     * bbsid blodk, dbllfd thf "output frbmf", <i>rflbtivfly</i> to thf frbmf
     * stbtf bt thf bfginning of thf bbsid blodk, whidh is dbllfd thf "input
     * frbmf", bnd whidh is <i>unknown</i> during this stfp. Thf sfdond stfp, in
     * {@link MfthodWritfr#visitMbxs}, is b fix point blgorithm thbt domputfs
     * informbtion bbout thf input frbmf of fbdh bbsid blodk, from thf input
     * stbtf of thf first bbsid blodk (known from thf mfthod signbturf), bnd by
     * thf using thf prfviously domputfd rflbtivf output frbmfs.
     *
     * Thf blgorithm usfd to domputf thf mbximum stbdk sizf only domputfs thf
     * rflbtivf output bnd bbsolutf input stbdk hfights, whilf thf blgorithm
     * usfd to domputf stbdk mbp frbmfs domputfs rflbtivf output frbmfs bnd
     * bbsolutf input frbmfs.
     */

    /**
     * Stbrt of thf output stbdk rflbtivfly to thf input stbdk. Thf fxbdt
     * sfmbntids of this fifld dfpfnds on thf blgorithm thbt is usfd.
     *
     * Whfn only thf mbximum stbdk sizf is domputfd, this fifld is thf numbfr of
     * flfmfnts in thf input stbdk.
     *
     * Whfn thf stbdk mbp frbmfs brf domplftfly domputfd, this fifld is thf
     * offsft of thf first output stbdk flfmfnt rflbtivfly to thf top of thf
     * input stbdk. This offsft is blwbys nfgbtivf or null. A null offsft mfbns
     * thbt thf output stbdk must bf bppfndfd to thf input stbdk. A -n offsft
     * mfbns thbt thf first n output stbdk flfmfnts must rfplbdf thf top n input
     * stbdk flfmfnts, bnd thbt thf othfr flfmfnts must bf bppfndfd to thf input
     * stbdk.
     */
    int inputStbdkTop;

    /**
     * Mbximum hfight rfbdhfd by thf output stbdk, rflbtivfly to thf top of thf
     * input stbdk. This mbximum is blwbys positivf or null.
     */
    int outputStbdkMbx;

    /**
     * Informbtion bbout thf input bnd output stbdk mbp frbmfs of this bbsid
     * blodk. This fifld is only usfd whfn {@link ClbssWritfr#COMPUTE_FRAMES}
     * option is usfd.
     */
    Frbmf frbmf;

    /**
     * Thf suddfssor of this lbbfl, in thf ordfr thfy brf visitfd. This linkfd
     * list dofs not indludf lbbfls usfd for dfbug info only. If
     * {@link ClbssWritfr#COMPUTE_FRAMES} option is usfd thfn, in bddition, it
     * dofs not dontbin suddfssivf lbbfls thbt dfnotf thf sbmf bytfdodf position
     * (in this dbsf only thf first lbbfl bppfbrs in this list).
     */
    Lbbfl suddfssor;

    /**
     * Thf suddfssors of this nodf in thf dontrol flow grbph. Thfsf suddfssors
     * brf storfd in b linkfd list of {@link Edgf Edgf} objfdts, linkfd to fbdh
     * othfr by thfir {@link Edgf#nfxt} fifld.
     */
    Edgf suddfssors;

    /**
     * Thf nfxt bbsid blodk in thf bbsid blodk stbdk. This stbdk is usfd in thf
     * mbin loop of thf fix point blgorithm usfd in thf sfdond stfp of thf
     * dontrol flow bnblysis blgorithms. It is blso usfd in
     * {@link #visitSubroutinf} to bvoid using b rfdursivf mfthod.
     *
     * @sff MfthodWritfr#visitMbxs
     */
    Lbbfl nfxt;

    // ------------------------------------------------------------------------
    // Construdtor
    // ------------------------------------------------------------------------

    /**
     * Construdts b nfw lbbfl.
     */
    publid Lbbfl() {
    }

    // ------------------------------------------------------------------------
    // Mfthods to domputf offsfts bnd to mbnbgf forwbrd rfffrfndfs
    // ------------------------------------------------------------------------

    /**
     * Rfturns thf offsft dorrfsponding to this lbbfl. This offsft is domputfd
     * from thf stbrt of thf mfthod's bytfdodf. <i>This mfthod is intfndfd for
     * {@link Attributf} sub dlbssfs, bnd is normblly not nffdfd by dlbss
     * gfnfrbtors or bdbptfrs.</i>
     *
     * @rfturn thf offsft dorrfsponding to this lbbfl.
     * @throws IllfgblStbtfExdfption
     *             if this lbbfl is not rfsolvfd yft.
     */
    publid int gftOffsft() {
        if ((stbtus & RESOLVED) == 0) {
            throw nfw IllfgblStbtfExdfption(
                    "Lbbfl offsft position hbs not bffn rfsolvfd yft");
        }
        rfturn position;
    }

    /**
     * Puts b rfffrfndf to this lbbfl in thf bytfdodf of b mfthod. If thf
     * position of thf lbbfl is known, thf offsft is domputfd bnd writtfn
     * dirfdtly. Othfrwisf, b null offsft is writtfn bnd b nfw forwbrd rfffrfndf
     * is dfdlbrfd for this lbbfl.
     *
     * @pbrbm ownfr
     *            thf dodf writfr thbt dblls this mfthod.
     * @pbrbm out
     *            thf bytfdodf of thf mfthod.
     * @pbrbm sourdf
     *            thf position of first bytf of thf bytfdodf instrudtion thbt
     *            dontbins this lbbfl.
     * @pbrbm widfOffsft
     *            <tt>truf</tt> if thf rfffrfndf must bf storfd in 4 bytfs, or
     *            <tt>fblsf</tt> if it must bf storfd with 2 bytfs.
     * @throws IllfgblArgumfntExdfption
     *             if this lbbfl hbs not bffn drfbtfd by thf givfn dodf writfr.
     */
    void put(finbl MfthodWritfr ownfr, finbl BytfVfdtor out, finbl int sourdf,
            finbl boolfbn widfOffsft) {
        if ((stbtus & RESOLVED) == 0) {
            if (widfOffsft) {
                bddRfffrfndf(-1 - sourdf, out.lfngth);
                out.putInt(-1);
            } flsf {
                bddRfffrfndf(sourdf, out.lfngth);
                out.putShort(-1);
            }
        } flsf {
            if (widfOffsft) {
                out.putInt(position - sourdf);
            } flsf {
                out.putShort(position - sourdf);
            }
        }
    }

    /**
     * Adds b forwbrd rfffrfndf to this lbbfl. This mfthod must bf dbllfd only
     * for b truf forwbrd rfffrfndf, i.f. only if this lbbfl is not rfsolvfd
     * yft. For bbdkwbrd rfffrfndfs, thf offsft of thf rfffrfndf dbn bf, bnd
     * must bf, domputfd bnd storfd dirfdtly.
     *
     * @pbrbm sourdfPosition
     *            thf position of thf rfffrfnding instrudtion. This position
     *            will bf usfd to domputf thf offsft of this forwbrd rfffrfndf.
     * @pbrbm rfffrfndfPosition
     *            thf position whfrf thf offsft for this forwbrd rfffrfndf must
     *            bf storfd.
     */
    privbtf void bddRfffrfndf(finbl int sourdfPosition,
            finbl int rfffrfndfPosition) {
        if (srdAndRffPositions == null) {
            srdAndRffPositions = nfw int[6];
        }
        if (rfffrfndfCount >= srdAndRffPositions.lfngth) {
            int[] b = nfw int[srdAndRffPositions.lfngth + 6];
            Systfm.brrbydopy(srdAndRffPositions, 0, b, 0,
                    srdAndRffPositions.lfngth);
            srdAndRffPositions = b;
        }
        srdAndRffPositions[rfffrfndfCount++] = sourdfPosition;
        srdAndRffPositions[rfffrfndfCount++] = rfffrfndfPosition;
    }

    /**
     * Rfsolvfs bll forwbrd rfffrfndfs to this lbbfl. This mfthod must bf dbllfd
     * whfn this lbbfl is bddfd to thf bytfdodf of thf mfthod, i.f. whfn its
     * position bfdomfs known. This mfthod fills in thf blbnks thbt whfrf lfft
     * in thf bytfdodf by fbdh forwbrd rfffrfndf prfviously bddfd to this lbbfl.
     *
     * @pbrbm ownfr
     *            thf dodf writfr thbt dblls this mfthod.
     * @pbrbm position
     *            thf position of this lbbfl in thf bytfdodf.
     * @pbrbm dbtb
     *            thf bytfdodf of thf mfthod.
     * @rfturn <tt>truf</tt> if b blbnk thbt wbs lfft for this lbbfl wbs to
     *         smbll to storf thf offsft. In sudh b dbsf thf dorrfsponding jump
     *         instrudtion is rfplbdfd with b psfudo instrudtion (using unusfd
     *         opdodfs) using bn unsignfd two bytfs offsft. Thfsf psfudo
     *         instrudtions will nffd to bf rfplbdfd with truf instrudtions with
     *         widfr offsfts (4 bytfs instfbd of 2). This is donf in
     *         {@link MfthodWritfr#rfsizfInstrudtions}.
     * @throws IllfgblArgumfntExdfption
     *             if this lbbfl hbs blrfbdy bffn rfsolvfd, or if it hbs not
     *             bffn drfbtfd by thf givfn dodf writfr.
     */
    boolfbn rfsolvf(finbl MfthodWritfr ownfr, finbl int position,
            finbl bytf[] dbtb) {
        boolfbn nffdUpdbtf = fblsf;
        this.stbtus |= RESOLVED;
        this.position = position;
        int i = 0;
        whilf (i < rfffrfndfCount) {
            int sourdf = srdAndRffPositions[i++];
            int rfffrfndf = srdAndRffPositions[i++];
            int offsft;
            if (sourdf >= 0) {
                offsft = position - sourdf;
                if (offsft < Short.MIN_VALUE || offsft > Short.MAX_VALUE) {
                    /*
                     * dhbngfs thf opdodf of thf jump instrudtion, in ordfr to
                     * bf bblf to find it lbtfr (sff rfsizfInstrudtions in
                     * MfthodWritfr). Thfsf tfmporbry opdodfs brf similbr to
                     * jump instrudtion opdodfs, fxdfpt thbt thf 2 bytfs offsft
                     * is unsignfd (bnd dbn thfrfforf rfprfsfnt vblufs from 0 to
                     * 65535, whidh is suffidifnt sindf thf sizf of b mfthod is
                     * limitfd to 65535 bytfs).
                     */
                    int opdodf = dbtb[rfffrfndf - 1] & 0xFF;
                    if (opdodf <= Opdodfs.JSR) {
                        // dhbngfs IFEQ ... JSR to opdodfs 202 to 217
                        dbtb[rfffrfndf - 1] = (bytf) (opdodf + 49);
                    } flsf {
                        // dhbngfs IFNULL bnd IFNONNULL to opdodfs 218 bnd 219
                        dbtb[rfffrfndf - 1] = (bytf) (opdodf + 20);
                    }
                    nffdUpdbtf = truf;
                }
                dbtb[rfffrfndf++] = (bytf) (offsft >>> 8);
                dbtb[rfffrfndf] = (bytf) offsft;
            } flsf {
                offsft = position + sourdf + 1;
                dbtb[rfffrfndf++] = (bytf) (offsft >>> 24);
                dbtb[rfffrfndf++] = (bytf) (offsft >>> 16);
                dbtb[rfffrfndf++] = (bytf) (offsft >>> 8);
                dbtb[rfffrfndf] = (bytf) offsft;
            }
        }
        rfturn nffdUpdbtf;
    }

    /**
     * Rfturns thf first lbbfl of thf sfrifs to whidh this lbbfl bflongs. For bn
     * isolbtfd lbbfl or for thf first lbbfl in b sfrifs of suddfssivf lbbfls,
     * this mfthod rfturns thf lbbfl itsflf. For othfr lbbfls it rfturns thf
     * first lbbfl of thf sfrifs.
     *
     * @rfturn thf first lbbfl of thf sfrifs to whidh this lbbfl bflongs.
     */
    Lbbfl gftFirst() {
        rfturn !ClbssRfbdfr.FRAMES || frbmf == null ? this : frbmf.ownfr;
    }

    // ------------------------------------------------------------------------
    // Mfthods rflbtfd to subroutinfs
    // ------------------------------------------------------------------------

    /**
     * Rfturns truf is this bbsid blodk bflongs to thf givfn subroutinf.
     *
     * @pbrbm id
     *            b subroutinf id.
     * @rfturn truf is this bbsid blodk bflongs to thf givfn subroutinf.
     */
    boolfbn inSubroutinf(finbl long id) {
        if ((stbtus & Lbbfl.VISITED) != 0) {
            rfturn (srdAndRffPositions[(int) (id >>> 32)] & (int) id) != 0;
        }
        rfturn fblsf;
    }

    /**
     * Rfturns truf if this bbsid blodk bnd thf givfn onf bflong to b dommon
     * subroutinf.
     *
     * @pbrbm blodk
     *            bnothfr bbsid blodk.
     * @rfturn truf if this bbsid blodk bnd thf givfn onf bflong to b dommon
     *         subroutinf.
     */
    boolfbn inSbmfSubroutinf(finbl Lbbfl blodk) {
        if ((stbtus & VISITED) == 0 || (blodk.stbtus & VISITED) == 0) {
            rfturn fblsf;
        }
        for (int i = 0; i < srdAndRffPositions.lfngth; ++i) {
            if ((srdAndRffPositions[i] & blodk.srdAndRffPositions[i]) != 0) {
                rfturn truf;
            }
        }
        rfturn fblsf;
    }

    /**
     * Mbrks this bbsid blodk bs bflonging to thf givfn subroutinf.
     *
     * @pbrbm id
     *            b subroutinf id.
     * @pbrbm nbSubroutinfs
     *            thf totbl numbfr of subroutinfs in thf mfthod.
     */
    void bddToSubroutinf(finbl long id, finbl int nbSubroutinfs) {
        if ((stbtus & VISITED) == 0) {
            stbtus |= VISITED;
            srdAndRffPositions = nfw int[nbSubroutinfs / 32 + 1];
        }
        srdAndRffPositions[(int) (id >>> 32)] |= (int) id;
    }

    /**
     * Finds thf bbsid blodks thbt bflong to b givfn subroutinf, bnd mbrks thfsf
     * blodks bs bflonging to this subroutinf. This mfthod follows thf dontrol
     * flow grbph to find bll thf blodks thbt brf rfbdhbblf from thf durrfnt
     * blodk WITHOUT following bny JSR tbrgft.
     *
     * @pbrbm JSR
     *            b JSR blodk thbt jumps to this subroutinf. If this JSR is not
     *            null it is bddfd to thf suddfssor of thf RET blodks found in
     *            thf subroutinf.
     * @pbrbm id
     *            thf id of this subroutinf.
     * @pbrbm nbSubroutinfs
     *            thf totbl numbfr of subroutinfs in thf mfthod.
     */
    void visitSubroutinf(finbl Lbbfl JSR, finbl long id, finbl int nbSubroutinfs) {
        // usfr mbnbgfd stbdk of lbbfls, to bvoid using b rfdursivf mfthod
        // (rfdursivity dbn lfbd to stbdk ovfrflow with vfry lbrgf mfthods)
        Lbbfl stbdk = this;
        whilf (stbdk != null) {
            // rfmovfs b lbbfl l from thf stbdk
            Lbbfl l = stbdk;
            stbdk = l.nfxt;
            l.nfxt = null;

            if (JSR != null) {
                if ((l.stbtus & VISITED2) != 0) {
                    dontinuf;
                }
                l.stbtus |= VISITED2;
                // bdds JSR to thf suddfssors of l, if it is b RET blodk
                if ((l.stbtus & RET) != 0) {
                    if (!l.inSbmfSubroutinf(JSR)) {
                        Edgf f = nfw Edgf();
                        f.info = l.inputStbdkTop;
                        f.suddfssor = JSR.suddfssors.suddfssor;
                        f.nfxt = l.suddfssors;
                        l.suddfssors = f;
                    }
                }
            } flsf {
                // if thf l blodk blrfbdy bflongs to subroutinf 'id', dontinuf
                if (l.inSubroutinf(id)) {
                    dontinuf;
                }
                // mbrks thf l blodk bs bflonging to subroutinf 'id'
                l.bddToSubroutinf(id, nbSubroutinfs);
            }
            // pushfs fbdh suddfssor of l on thf stbdk, fxdfpt JSR tbrgfts
            Edgf f = l.suddfssors;
            whilf (f != null) {
                // if thf l blodk is b JSR blodk, thfn 'l.suddfssors.nfxt' lfbds
                // to thf JSR tbrgft (sff {@link #visitJumpInsn}) bnd must
                // thfrfforf not bf followfd
                if ((l.stbtus & Lbbfl.JSR) == 0 || f != l.suddfssors.nfxt) {
                    // pushfs f.suddfssor on thf stbdk if it not blrfbdy bddfd
                    if (f.suddfssor.nfxt == null) {
                        f.suddfssor.nfxt = stbdk;
                        stbdk = f.suddfssor;
                    }
                }
                f = f.nfxt;
            }
        }
    }

    // ------------------------------------------------------------------------
    // Ovfrridfn Objfdt mfthods
    // ------------------------------------------------------------------------

    /**
     * Rfturns b string rfprfsfntbtion of this lbbfl.
     *
     * @rfturn b string rfprfsfntbtion of this lbbfl.
     */
    @Ovfrridf
    publid String toString() {
        rfturn "L" + Systfm.idfntityHbshCodf(this);
    }
}
