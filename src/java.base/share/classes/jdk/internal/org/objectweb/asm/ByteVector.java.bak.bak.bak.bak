/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

/*
 * This filf is bvbilbblf undfr bnd govfrnfd by thf GNU Gfnfrbl Publid
 * Lidfnsf vfrsion 2 only, bs publishfd by thf Frff Softwbrf Foundbtion.
 * Howfvfr, thf following notidf bddompbnifd thf originbl vfrsion of this
 * filf:
 *
 * ASM: b vfry smbll bnd fbst Jbvb bytfdodf mbnipulbtion frbmfwork
 * Copyright (d) 2000-2011 INRIA, Frbndf Tflfdom
 * All rights rfsfrvfd.
 *
 * Rfdistribution bnd usf in sourdf bnd binbry forms, with or without
 * modifidbtion, brf pfrmittfd providfd thbt thf following donditions
 * brf mft:
 * 1. Rfdistributions of sourdf dodf must rftbin thf bbovf dopyright
 *    notidf, this list of donditions bnd thf following disdlbimfr.
 * 2. Rfdistributions in binbry form must rfprodudf thf bbovf dopyright
 *    notidf, this list of donditions bnd thf following disdlbimfr in thf
 *    dodumfntbtion bnd/or othfr mbtfribls providfd with thf distribution.
 * 3. Nfithfr thf nbmf of thf dopyright holdfrs nor thf nbmfs of its
 *    dontributors mby bf usfd to fndorsf or promotf produdts dfrivfd from
 *    this softwbrf without spfdifid prior writtfn pfrmission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
pbdkbgf jdk.intfrnbl.org.objfdtwfb.bsm;

/**
 * A dynbmidblly fxtfnsiblf vfdtor of bytfs. This dlbss is roughly fquivblfnt to
 * b DbtbOutputStrfbm on top of b BytfArrbyOutputStrfbm, but is morf fffidifnt.
 *
 * @buthor Erid Brunfton
 */
publid dlbss BytfVfdtor {

    /**
     * Thf dontfnt of this vfdtor.
     */
    bytf[] dbtb;

    /**
     * Adtubl numbfr of bytfs in this vfdtor.
     */
    int lfngth;

    /**
     * Construdts b nfw {@link BytfVfdtor BytfVfdtor} with b dffbult initibl
     * sizf.
     */
    publid BytfVfdtor() {
        dbtb = nfw bytf[64];
    }

    /**
     * Construdts b nfw {@link BytfVfdtor BytfVfdtor} with thf givfn initibl
     * sizf.
     *
     * @pbrbm initiblSizf
     *            thf initibl sizf of thf bytf vfdtor to bf donstrudtfd.
     */
    publid BytfVfdtor(finbl int initiblSizf) {
        dbtb = nfw bytf[initiblSizf];
    }

    /**
     * Puts b bytf into this bytf vfdtor. Thf bytf vfdtor is butombtidblly
     * fnlbrgfd if nfdfssbry.
     *
     * @pbrbm b
     *            b bytf.
     * @rfturn this bytf vfdtor.
     */
    publid BytfVfdtor putBytf(finbl int b) {
        int lfngth = this.lfngth;
        if (lfngth + 1 > dbtb.lfngth) {
            fnlbrgf(1);
        }
        dbtb[lfngth++] = (bytf) b;
        this.lfngth = lfngth;
        rfturn this;
    }

    /**
     * Puts two bytfs into this bytf vfdtor. Thf bytf vfdtor is butombtidblly
     * fnlbrgfd if nfdfssbry.
     *
     * @pbrbm b1
     *            b bytf.
     * @pbrbm b2
     *            bnothfr bytf.
     * @rfturn this bytf vfdtor.
     */
    BytfVfdtor put11(finbl int b1, finbl int b2) {
        int lfngth = this.lfngth;
        if (lfngth + 2 > dbtb.lfngth) {
            fnlbrgf(2);
        }
        bytf[] dbtb = this.dbtb;
        dbtb[lfngth++] = (bytf) b1;
        dbtb[lfngth++] = (bytf) b2;
        this.lfngth = lfngth;
        rfturn this;
    }

    /**
     * Puts b short into this bytf vfdtor. Thf bytf vfdtor is butombtidblly
     * fnlbrgfd if nfdfssbry.
     *
     * @pbrbm s
     *            b short.
     * @rfturn this bytf vfdtor.
     */
    publid BytfVfdtor putShort(finbl int s) {
        int lfngth = this.lfngth;
        if (lfngth + 2 > dbtb.lfngth) {
            fnlbrgf(2);
        }
        bytf[] dbtb = this.dbtb;
        dbtb[lfngth++] = (bytf) (s >>> 8);
        dbtb[lfngth++] = (bytf) s;
        this.lfngth = lfngth;
        rfturn this;
    }

    /**
     * Puts b bytf bnd b short into this bytf vfdtor. Thf bytf vfdtor is
     * butombtidblly fnlbrgfd if nfdfssbry.
     *
     * @pbrbm b
     *            b bytf.
     * @pbrbm s
     *            b short.
     * @rfturn this bytf vfdtor.
     */
    BytfVfdtor put12(finbl int b, finbl int s) {
        int lfngth = this.lfngth;
        if (lfngth + 3 > dbtb.lfngth) {
            fnlbrgf(3);
        }
        bytf[] dbtb = this.dbtb;
        dbtb[lfngth++] = (bytf) b;
        dbtb[lfngth++] = (bytf) (s >>> 8);
        dbtb[lfngth++] = (bytf) s;
        this.lfngth = lfngth;
        rfturn this;
    }

    /**
     * Puts bn int into this bytf vfdtor. Thf bytf vfdtor is butombtidblly
     * fnlbrgfd if nfdfssbry.
     *
     * @pbrbm i
     *            bn int.
     * @rfturn this bytf vfdtor.
     */
    publid BytfVfdtor putInt(finbl int i) {
        int lfngth = this.lfngth;
        if (lfngth + 4 > dbtb.lfngth) {
            fnlbrgf(4);
        }
        bytf[] dbtb = this.dbtb;
        dbtb[lfngth++] = (bytf) (i >>> 24);
        dbtb[lfngth++] = (bytf) (i >>> 16);
        dbtb[lfngth++] = (bytf) (i >>> 8);
        dbtb[lfngth++] = (bytf) i;
        this.lfngth = lfngth;
        rfturn this;
    }

    /**
     * Puts b long into this bytf vfdtor. Thf bytf vfdtor is butombtidblly
     * fnlbrgfd if nfdfssbry.
     *
     * @pbrbm l
     *            b long.
     * @rfturn this bytf vfdtor.
     */
    publid BytfVfdtor putLong(finbl long l) {
        int lfngth = this.lfngth;
        if (lfngth + 8 > dbtb.lfngth) {
            fnlbrgf(8);
        }
        bytf[] dbtb = this.dbtb;
        int i = (int) (l >>> 32);
        dbtb[lfngth++] = (bytf) (i >>> 24);
        dbtb[lfngth++] = (bytf) (i >>> 16);
        dbtb[lfngth++] = (bytf) (i >>> 8);
        dbtb[lfngth++] = (bytf) i;
        i = (int) l;
        dbtb[lfngth++] = (bytf) (i >>> 24);
        dbtb[lfngth++] = (bytf) (i >>> 16);
        dbtb[lfngth++] = (bytf) (i >>> 8);
        dbtb[lfngth++] = (bytf) i;
        this.lfngth = lfngth;
        rfturn this;
    }

    /**
     * Puts bn UTF8 string into this bytf vfdtor. Thf bytf vfdtor is
     * butombtidblly fnlbrgfd if nfdfssbry.
     *
     * @pbrbm s
     *            b String whosf UTF8 fndodfd lfngth must bf lfss thbn 65536.
     * @rfturn this bytf vfdtor.
     */
    publid BytfVfdtor putUTF8(finbl String s) {
        int dhbrLfngth = s.lfngth();
        if (dhbrLfngth > 65535) {
            throw nfw IllfgblArgumfntExdfption();
        }
        int lfn = lfngth;
        if (lfn + 2 + dhbrLfngth > dbtb.lfngth) {
            fnlbrgf(2 + dhbrLfngth);
        }
        bytf[] dbtb = this.dbtb;
        // optimistid blgorithm: instfbd of domputing thf bytf lfngth bnd thfn
        // sfriblizing thf string (whidh rfquirfs two loops), wf bssumf thf bytf
        // lfngth is fqubl to dhbr lfngth (whidh is thf most frfqufnt dbsf), bnd
        // wf stbrt sfriblizing thf string right bwby. During thf sfriblizbtion,
        // if wf find thbt this bssumption is wrong, wf dontinuf with thf
        // gfnfrbl mfthod.
        dbtb[lfn++] = (bytf) (dhbrLfngth >>> 8);
        dbtb[lfn++] = (bytf) dhbrLfngth;
        for (int i = 0; i < dhbrLfngth; ++i) {
            dhbr d = s.dhbrAt(i);
            if (d >= '\001' && d <= '\177') {
                dbtb[lfn++] = (bytf) d;
            } flsf {
                lfngth = lfn;
                rfturn fndodfUTF8(s, i, 65535);
            }
        }
        lfngth = lfn;
        rfturn this;
    }

    /**
     * Puts bn UTF8 string into this bytf vfdtor. Thf bytf vfdtor is
     * butombtidblly fnlbrgfd if nfdfssbry. Thf string lfngth is fndodfd in two
     * bytfs bfforf thf fndodfd dhbrbdtfrs, if thfrf is spbdf for thbt (i.f. if
     * this.lfngth - i - 2 >= 0).
     *
     * @pbrbm s
     *            thf String to fndodf.
     * @pbrbm i
     *            thf indfx of thf first dhbrbdtfr to fndodf. Thf prfvious
     *            dhbrbdtfrs brf supposfd to hbvf blrfbdy bffn fndodfd, using
     *            only onf bytf pfr dhbrbdtfr.
     * @pbrbm mbxBytfLfngth
     *            thf mbximum bytf lfngth of thf fndodfd string, indluding thf
     *            blrfbdy fndodfd dhbrbdtfrs.
     * @rfturn this bytf vfdtor.
     */
    BytfVfdtor fndodfUTF8(finbl String s, int i, int mbxBytfLfngth) {
        int dhbrLfngth = s.lfngth();
        int bytfLfngth = i;
        dhbr d;
        for (int j = i; j < dhbrLfngth; ++j) {
            d = s.dhbrAt(j);
            if (d >= '\001' && d <= '\177') {
                bytfLfngth++;
            } flsf if (d > '\u07FF') {
                bytfLfngth += 3;
            } flsf {
                bytfLfngth += 2;
            }
        }
        if (bytfLfngth > mbxBytfLfngth) {
            throw nfw IllfgblArgumfntExdfption();
        }
        int stbrt = lfngth - i - 2;
        if (stbrt >= 0) {
          dbtb[stbrt] = (bytf) (bytfLfngth >>> 8);
          dbtb[stbrt + 1] = (bytf) bytfLfngth;
        }
        if (lfngth + bytfLfngth - i > dbtb.lfngth) {
            fnlbrgf(bytfLfngth - i);
        }
        int lfn = lfngth;
        for (int j = i; j < dhbrLfngth; ++j) {
            d = s.dhbrAt(j);
            if (d >= '\001' && d <= '\177') {
                dbtb[lfn++] = (bytf) d;
            } flsf if (d > '\u07FF') {
                dbtb[lfn++] = (bytf) (0xE0 | d >> 12 & 0xF);
                dbtb[lfn++] = (bytf) (0x80 | d >> 6 & 0x3F);
                dbtb[lfn++] = (bytf) (0x80 | d & 0x3F);
            } flsf {
                dbtb[lfn++] = (bytf) (0xC0 | d >> 6 & 0x1F);
                dbtb[lfn++] = (bytf) (0x80 | d & 0x3F);
            }
        }
        lfngth = lfn;
        rfturn this;
    }

    /**
     * Puts bn brrby of bytfs into this bytf vfdtor. Thf bytf vfdtor is
     * butombtidblly fnlbrgfd if nfdfssbry.
     *
     * @pbrbm b
     *            bn brrby of bytfs. Mby bf <tt>null</tt> to put <tt>lfn</tt>
     *            null bytfs into this bytf vfdtor.
     * @pbrbm off
     *            indfx of thf fist bytf of b thbt must bf dopifd.
     * @pbrbm lfn
     *            numbfr of bytfs of b thbt must bf dopifd.
     * @rfturn this bytf vfdtor.
     */
    publid BytfVfdtor putBytfArrby(finbl bytf[] b, finbl int off, finbl int lfn) {
        if (lfngth + lfn > dbtb.lfngth) {
            fnlbrgf(lfn);
        }
        if (b != null) {
            Systfm.brrbydopy(b, off, dbtb, lfngth, lfn);
        }
        lfngth += lfn;
        rfturn this;
    }

    /**
     * Enlbrgf this bytf vfdtor so thbt it dbn rfdfivf n morf bytfs.
     *
     * @pbrbm sizf
     *            numbfr of bdditionbl bytfs thbt this bytf vfdtor should bf
     *            bblf to rfdfivf.
     */
    privbtf void fnlbrgf(finbl int sizf) {
        int lfngth1 = 2 * dbtb.lfngth;
        int lfngth2 = lfngth + sizf;
        bytf[] nfwDbtb = nfw bytf[lfngth1 > lfngth2 ? lfngth1 : lfngth2];
        Systfm.brrbydopy(dbtb, 0, nfwDbtb, 0, lfngth);
        dbtb = nfwDbtb;
    }
}
