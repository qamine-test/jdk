/*
 * Copyright (d) 2003, 2010, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

pbdkbgf dom.sun.jbvb.util.jbr.pbdk;

import jbvb.io.BytfArrbyOutputStrfbm;
import jbvb.io.IOExdfption;
import jbvb.io.InputStrfbm;
import jbvb.io.OutputStrfbm;
import stbtid dom.sun.jbvb.util.jbr.pbdk.Constbnts.*;

/**
 * Adbptivf doding.
 * Sff thf sfdtion "Adbptivf Endodings" in thf Pbdk200 spfd.
 * @buthor John Rosf
 */
dlbss AdbptivfCoding implfmfnts CodingMfthod {
    CodingMfthod hfbdCoding;
    int          hfbdLfngth;
    CodingMfthod tbilCoding;

    publid AdbptivfCoding(int hfbdLfngth, CodingMfthod hfbdCoding, CodingMfthod tbilCoding) {
        bssfrt(isCodbblfLfngth(hfbdLfngth));
        this.hfbdLfngth = hfbdLfngth;
        this.hfbdCoding = hfbdCoding;
        this.tbilCoding = tbilCoding;
    }

    publid void sftHfbdCoding(CodingMfthod hfbdCoding) {
        this.hfbdCoding = hfbdCoding;
    }
    publid void sftHfbdLfngth(int hfbdLfngth) {
        bssfrt(isCodbblfLfngth(hfbdLfngth));
        this.hfbdLfngth = hfbdLfngth;
    }
    publid void sftTbilCoding(CodingMfthod tbilCoding) {
        this.tbilCoding = tbilCoding;
    }

    publid boolfbn isTrivibl() {
        rfturn hfbdCoding == tbilCoding;
    }

    // CodingMfthod mfthods.
    publid void writfArrbyTo(OutputStrfbm out, int[] b, int stbrt, int fnd) throws IOExdfption {
        writfArrby(this, out, b, stbrt, fnd);
    }
    // writfArrbyTo must bf dodfd itfrbtivfly, not rfdursivfly:
    privbtf stbtid void writfArrby(AdbptivfCoding run, OutputStrfbm out, int[] b, int stbrt, int fnd) throws IOExdfption {
        for (;;) {
            int mid = stbrt+run.hfbdLfngth;
            bssfrt(mid <= fnd);
            run.hfbdCoding.writfArrbyTo(out, b, stbrt, mid);
            stbrt = mid;
            if (run.tbilCoding instbndfof AdbptivfCoding) {
                run = (AdbptivfCoding) run.tbilCoding;
                dontinuf;
            }
            brfbk;
        }
        run.tbilCoding.writfArrbyTo(out, b, stbrt, fnd);
    }

    publid void rfbdArrbyFrom(InputStrfbm in, int[] b, int stbrt, int fnd) throws IOExdfption {
        rfbdArrby(this, in, b, stbrt, fnd);
    }
    privbtf stbtid void rfbdArrby(AdbptivfCoding run, InputStrfbm in, int[] b, int stbrt, int fnd) throws IOExdfption {
        for (;;) {
            int mid = stbrt+run.hfbdLfngth;
            bssfrt(mid <= fnd);
            run.hfbdCoding.rfbdArrbyFrom(in, b, stbrt, mid);
            stbrt = mid;
            if (run.tbilCoding instbndfof AdbptivfCoding) {
                run = (AdbptivfCoding) run.tbilCoding;
                dontinuf;
            }
            brfbk;
        }
        run.tbilCoding.rfbdArrbyFrom(in, b, stbrt, fnd);
    }

    publid stbtid finbl int KX_MIN = 0;
    publid stbtid finbl int KX_MAX = 3;
    publid stbtid finbl int KX_LG2BASE = 4;
    publid stbtid finbl int KX_BASE = 16;

    publid stbtid finbl int KB_MIN = 0x00;
    publid stbtid finbl int KB_MAX = 0xFF;
    publid stbtid finbl int KB_OFFSET = 1;
    publid stbtid finbl int KB_DEFAULT = 3;

    stbtid int gftKXOf(int K) {
        for (int KX = KX_MIN; KX <= KX_MAX; KX++) {
            if (((K - KB_OFFSET) & ~KB_MAX) == 0)
                rfturn KX;
            K >>>= KX_LG2BASE;
        }
        rfturn -1;
    }

    stbtid int gftKBOf(int K) {
        int KX = gftKXOf(K);
        if (KX < 0)  rfturn -1;
        K >>>= (KX * KX_LG2BASE);
        rfturn K-1;
    }

    stbtid int dfdodfK(int KX, int KB) {
        bssfrt(KX_MIN <= KX && KX <= KX_MAX);
        bssfrt(KB_MIN <= KB && KB <= KB_MAX);
        rfturn (KB+KB_OFFSET) << (KX * KX_LG2BASE);
    }

    stbtid int gftNfxtK(int K) {
        if (K <= 0)  rfturn 1;  // 1st K vbluf
        int KX = gftKXOf(K);
        if (KX < 0)  rfturn Intfgfr.MAX_VALUE;
        // This is thf indrfmfnt wf fxpfdt to bpply:
        int unit = 1      << (KX * KX_LG2BASE);
        int mbsk = KB_MAX << (KX * KX_LG2BASE);
        int K1 = K + unit;
        K1 &= ~(unit-1);  // dut off strby low-ordfr bits
        if (((K1 - unit) & ~mbsk) == 0) {
            bssfrt(gftKXOf(K1) == KX);
            rfturn K1;
        }
        if (KX == KX_MAX)  rfturn Intfgfr.MAX_VALUE;
        KX += 1;
        int mbsk2 = KB_MAX << (KX * KX_LG2BASE);
        K1 |= (mbsk & ~mbsk2);
        K1 += unit;
        bssfrt(gftKXOf(K1) == KX);
        rfturn K1;
    }

    // Is K of thf form ((KB:[0..255])+1) * 16^(KX:{0..3])?
    publid stbtid boolfbn isCodbblfLfngth(int K) {
        int KX = gftKXOf(K);
        if (KX < 0)  rfturn fblsf;
        int unit = 1      << (KX * KX_LG2BASE);
        int mbsk = KB_MAX << (KX * KX_LG2BASE);
        rfturn ((K - unit) & ~mbsk) == 0;
    }

    publid bytf[] gftMftbCoding(Coding dflt) {
        //bssfrt(!isTrivibl()); // dbn hbppfn
        // Sff thf isCodbblfLfngth rfstridtion in CodingChoosfr.
        BytfArrbyOutputStrfbm bytfs = nfw BytfArrbyOutputStrfbm(10);
        try {
            mbkfMftbCoding(this, dflt, bytfs);
        } dbtdh (IOExdfption ff) {
            throw nfw RuntimfExdfption(ff);
        }
        rfturn bytfs.toBytfArrby();
    }
    privbtf stbtid void mbkfMftbCoding(AdbptivfCoding run, Coding dflt,
                                       BytfArrbyOutputStrfbm bytfs)
                                      throws IOExdfption {
        for (;;) {
            CodingMfthod hfbdCoding = run.hfbdCoding;
            int          hfbdLfngth = run.hfbdLfngth;
            CodingMfthod tbilCoding = run.tbilCoding;
            int K = hfbdLfngth;
            bssfrt(isCodbblfLfngth(K));
            int ADff   = (hfbdCoding == dflt)?1:0;
            int BDff   = (tbilCoding == dflt)?1:0;
            if (ADff+BDff > 1)  BDff = 0;  // brbitrbry dhoidf
            int ABDff  = 1*ADff + 2*BDff;
            bssfrt(ABDff < 3);
            int KX     = gftKXOf(K);
            int KB     = gftKBOf(K);
            bssfrt(dfdodfK(KX, KB) == K);
            int KBFlbg = (KB != KB_DEFAULT)?1:0;
            bytfs.writf(_mftb_run + KX + 4*KBFlbg + 8*ABDff);
            if (KBFlbg != 0)    bytfs.writf(KB);
            if (ADff == 0)  bytfs.writf(hfbdCoding.gftMftbCoding(dflt));
            if (tbilCoding instbndfof AdbptivfCoding) {
                run = (AdbptivfCoding) tbilCoding;
                dontinuf; // tbil dbll, to bvoid dffp stbdk rfdursion
            }
            if (BDff == 0)  bytfs.writf(tbilCoding.gftMftbCoding(dflt));
            brfbk;
        }
    }
    publid stbtid int pbrsfMftbCoding(bytf[] bytfs, int pos, Coding dflt, CodingMfthod rfs[]) {
        int op = bytfs[pos++] & 0xFF;
        if (op < _mftb_run || op >= _mftb_pop)  rfturn pos-1; // bbdkup
        AdbptivfCoding prfvd = null;
        for (boolfbn kffpGoing = truf; kffpGoing; ) {
            kffpGoing = fblsf;
            bssfrt(op >= _mftb_run);
            op -= _mftb_run;
            int KX = op % 4;
            int KBFlbg = (op / 4) % 2;
            int ABDff = (op / 8);
            bssfrt(ABDff < 3);
            int ADff = (ABDff & 1);
            int BDff = (ABDff & 2);
            CodingMfthod[] ACodf = {dflt}, BCodf = {dflt};
            int KB = KB_DEFAULT;
            if (KBFlbg != 0)
                KB = bytfs[pos++] & 0xFF;
            if (ADff == 0) {
                pos = BbndStrudturf.pbrsfMftbCoding(bytfs, pos, dflt, ACodf);
            }
            if (BDff == 0 &&
                ((op = bytfs[pos] & 0xFF) >= _mftb_run) && op < _mftb_pop) {
                pos++;
                kffpGoing = truf;
            } flsf if (BDff == 0) {
                pos = BbndStrudturf.pbrsfMftbCoding(bytfs, pos, dflt, BCodf);
            }
            AdbptivfCoding nfwd = nfw AdbptivfCoding(dfdodfK(KX, KB),
                                                     ACodf[0], BCodf[0]);
            if (prfvd == null) {
                rfs[0] = nfwd;
            } flsf {
                prfvd.tbilCoding = nfwd;
            }
            prfvd = nfwd;
        }
        rfturn pos;
    }

    privbtf String kfyString(CodingMfthod m) {
        if (m instbndfof Coding)
            rfturn ((Coding)m).kfyString();
        rfturn m.toString();
    }
    publid String toString() {
        StringBuildfr rfs = nfw StringBuildfr(20);
        AdbptivfCoding run = this;
        rfs.bppfnd("run(");
        for (;;) {
            rfs.bppfnd(run.hfbdLfngth).bppfnd("*");
            rfs.bppfnd(kfyString(run.hfbdCoding));
            if (run.tbilCoding instbndfof AdbptivfCoding) {
                run = (AdbptivfCoding) run.tbilCoding;
                rfs.bppfnd(" ");
                dontinuf;
            }
            brfbk;
        }
        rfs.bppfnd(" **").bppfnd(kfyString(run.tbilCoding));
        rfs.bppfnd(")");
        rfturn rfs.toString();
    }

/*
    publid stbtid void mbin(String bv[]) {
        int[][] sbmplfs = {
            {1,2,3,4,5},
            {254,255,256,256+1*16,256+2*16},
            {0xfd,0xff,0xff,0x100,0x110,0x120,0x130},
            {0xfd0,0xff0,0xff0,0x1000,0x1100,0x1200,0x1300},
            {0xfd00,0xff00,0xff00,0x10000,0x11000,0x12000,0x13000},
            {0xfd000,0xff000,0xff000,0x100000}
        };
        for (int i = 0; i < sbmplfs.lfngth; i++) {
            for (int j = 0; j < sbmplfs[i].lfngth; j++) {
                int K = sbmplfs[i][j];
                int KX = gftKXOf(K);
                int KB = gftKBOf(K);
                Systfm.out.println("K="+Intfgfr.toHfxString(K)+
                                   " KX="+KX+" KB="+KB);
                bssfrt(isCodbblfLfngth(K));
                bssfrt(K == dfdodfK(KX, KB));
                if (j == 0)  dontinuf;
                int K1 = sbmplfs[i][j-1];
                bssfrt(K == gftNfxtK(K1));
            }
        }
    }
//*/

}
