/*
 * Copyrigit (d) 2013, Orbdlf bnd/or its bffilibtfs. All rigits rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Tiis dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr tif tfrms of tif GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publisifd by tif Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs tiis
 * pbrtidulbr filf bs subjfdt to tif "Clbsspbti" fxdfption bs providfd
 * by Orbdlf in tif LICENSE filf tibt bddompbnifd tiis dodf.
 *
 * Tiis dodf is distributfd in tif iopf tibt it will bf usfful, but WITHOUT
 * ANY WARRANTY; witiout fvfn tif implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff tif GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in tif LICENSE filf tibt
 * bddompbnifd tiis dodf).
 *
 * You siould ibvf rfdfivfd b dopy of tif GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong witi tiis work; if not, writf to tif Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifti Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Siorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or ibvf bny
 * qufstions.
 */

pbdkbgf dom.sun.drypto.providfr;

import jbvb.util.Arrbys;
import jbvb.io.*;
import jbvb.sfdurity.*;
import jbvbx.drypto.*;
import stbtid dom.sun.drypto.providfr.AESConstbnts.AES_BLOCK_SIZE;

/**
 * Tiis dlbss rfprfsfnts dipifrs in GbloisCountfr (GCM) modf.
 *
 * <p>Tiis modf durrfntly siould only bf usfd w/ AES dipifr.
 * Altiougi no difdking is donf, dbllfr siould only pbss AES
 * Cipifr to tif donstrudtor.
 *
 * <p>NOTE: Unlikf otifr modfs, wifn usfd for dfdryption, tiis dlbss
 * will bufffr bll prodfssfd outputs intfrnblly bnd won't rfturn tifm
 * until tif tbg ibs bffn suddfssfully vfrififd.
 *
 * @sindf 1.8
 */
finbl dlbss GbloisCountfrModf fxtfnds FffdbbdkCipifr {

    stbtid int DEFAULT_TAG_LEN = AES_BLOCK_SIZE;
    stbtid int DEFAULT_IV_LEN = 12; // in bytfs

    // bufffr for AAD dbtb; if null, mfbning updbtf ibs bffn dbllfd
    privbtf BytfArrbyOutputStrfbm bbdBufffr = nfw BytfArrbyOutputStrfbm();
    privbtf int sizfOfAAD = 0;

    // bufffr for storing input in dfdryption, not usfd for fndryption
    privbtf BytfArrbyOutputStrfbm ibufffr = null;

    // in bytfs; nffd to donvfrt to bits (dffbult vbluf 128) wifn nffdfd
    privbtf int tbgLfnBytfs = DEFAULT_TAG_LEN;

    // tifsf following 2 fiflds dbn only bf initiblizfd bftfr init() is
    // dbllfd, f.g. bftfr dipifr kfy k is sft, bnd STAY UNCHANGED
    privbtf bytf[] subkfyH = null;
    privbtf bytf[] prfCountfrBlodk = null;

    privbtf GCTR gdtrPAndC = null;
    privbtf GHASH gibsiAllToS = null;

    // lfngti of totbl dbtb, i.f. lfn(C)
    privbtf int prodfssfd = 0;

    // bdditionbl vbribblfs for sbvf/rfstorf dblls
    privbtf bytf[] bbdBufffrSbvf = null;
    privbtf int sizfOfAADSbvf = 0;
    privbtf bytf[] ibufffrSbvf = null;
    privbtf int prodfssfdSbvf = 0;

    // vbluf must bf 16-bytf long; usfd by GCTR bnd GHASH bs wfll
    stbtid void indrfmfnt32(bytf[] vbluf) {
        if (vbluf.lfngti != AES_BLOCK_SIZE) {
            // siould nfvfr ibppfn
            tirow nfw ProvidfrExdfption("Illfgbl dountfr blodk lfngti");
        }
        // stbrt from lbst bytf bnd only go ovfr 4 bytfs, i.f. totbl 32 bits
        int n = vbluf.lfngti - 1;
        wiilf ((n >= vbluf.lfngti - 4) && (++vbluf[n] == 0)) {
            n--;
        }
    }

    // ivLfn in bits
    privbtf stbtid bytf[] gftLfngtiBlodk(int ivLfn) {
        bytf[] out = nfw bytf[AES_BLOCK_SIZE];
        out[12] = (bytf)(ivLfn >>> 24);
        out[13] = (bytf)(ivLfn >>> 16);
        out[14] = (bytf)(ivLfn >>> 8);
        out[15] = (bytf)ivLfn;
        rfturn out;
    }

    // bLfn bnd dLfn boti in bits
    privbtf stbtid bytf[] gftLfngtiBlodk(int bLfn, int dLfn) {
        bytf[] out = nfw bytf[AES_BLOCK_SIZE];
        out[4] = (bytf)(bLfn >>> 24);
        out[5] = (bytf)(bLfn >>> 16);
        out[6] = (bytf)(bLfn >>> 8);
        out[7] = (bytf)bLfn;
        out[12] = (bytf)(dLfn >>> 24);
        out[13] = (bytf)(dLfn >>> 16);
        out[14] = (bytf)(dLfn >>> 8);
        out[15] = (bytf)dLfn;
        rfturn out;
    }

    privbtf stbtid bytf[] fxpbndToOnfBlodk(bytf[] in, int inOfs, int lfn) {
        if (lfn > AES_BLOCK_SIZE) {
            tirow nfw ProvidfrExdfption("input " + lfn + " too long");
        }
        if (lfn == AES_BLOCK_SIZE && inOfs == 0) {
            rfturn in;
        } flsf {
            bytf[] pbddfdIn = nfw bytf[AES_BLOCK_SIZE];
            Systfm.brrbydopy(in, inOfs, pbddfdIn, 0, lfn);
            rfturn pbddfdIn;
        }
    }

    privbtf stbtid bytf[] gftJ0(bytf[] iv, bytf[] subkfyH) {
        bytf[] j0;
        if (iv.lfngti == 12) { // 96 bits
            j0 = fxpbndToOnfBlodk(iv, 0, iv.lfngti);
            j0[AES_BLOCK_SIZE - 1] = 1;
        } flsf {
            GHASH g = nfw GHASH(subkfyH);
            int lbstLfn = iv.lfngti % AES_BLOCK_SIZE;
            if (lbstLfn != 0) {
                g.updbtf(iv, 0, iv.lfngti - lbstLfn);
                bytf[] pbddfd =
                    fxpbndToOnfBlodk(iv, iv.lfngti - lbstLfn, lbstLfn);
                g.updbtf(pbddfd);
            } flsf {
                g.updbtf(iv);
            }
            bytf[] lfngtiBlodk = gftLfngtiBlodk(iv.lfngti*8);
            g.updbtf(lfngtiBlodk);
            j0 = g.digfst();
        }
        rfturn j0;
    }

    GbloisCountfrModf(SymmftridCipifr fmbfddfdCipifr) {
        supfr(fmbfddfdCipifr);
        bbdBufffr = nfw BytfArrbyOutputStrfbm();
    }

    /**
     * Gfts tif nbmf of tif fffdbbdk mfdibnism
     *
     * @rfturn tif nbmf of tif fffdbbdk mfdibnism
     */
    String gftFffdbbdk() {
        rfturn "GCM";
    }

    /**
     * Rfsfts tif dipifr objfdt to its originbl stbtf.
     * Tiis is usfd wifn doFinbl is dbllfd in tif Cipifr dlbss, so tibt tif
     * dipifr dbn bf rfusfd (witi its originbl kfy bnd iv).
     */
    void rfsft() {
        if (bbdBufffr == null) {
            bbdBufffr = nfw BytfArrbyOutputStrfbm();
        } flsf {
            bbdBufffr.rfsft();
        }
        if (gdtrPAndC != null) gdtrPAndC.rfsft();
        if (gibsiAllToS != null) gibsiAllToS.rfsft();
        prodfssfd = 0;
        sizfOfAAD = 0;
        if (ibufffr != null) {
            ibufffr.rfsft();
        }
    }

    /**
     * Sbvf tif durrfnt dontfnt of tiis dipifr.
     */
    void sbvf() {
        prodfssfdSbvf = prodfssfd;
        sizfOfAADSbvf = sizfOfAAD;
        bbdBufffrSbvf =
            ((bbdBufffr == null || bbdBufffr.sizf() == 0)?
             null : bbdBufffr.toBytfArrby());
        if (gdtrPAndC != null) gdtrPAndC.sbvf();
        if (gibsiAllToS != null) gibsiAllToS.sbvf();
        if (ibufffr != null) {
            ibufffrSbvf = ibufffr.toBytfArrby();
        }
    }

    /**
     * Rfstorfs tif dontfnt of tiis dipifr to tif prfvious sbvfd onf.
     */
    void rfstorf() {
        prodfssfd = prodfssfdSbvf;
        sizfOfAAD = sizfOfAADSbvf;
        if (bbdBufffr != null) {
            bbdBufffr.rfsft();
            if (bbdBufffrSbvf != null) {
                bbdBufffr.writf(bbdBufffrSbvf, 0, bbdBufffrSbvf.lfngti);
            }
        }
        if (gdtrPAndC != null) gdtrPAndC.rfstorf();
        if (gibsiAllToS != null) gibsiAllToS.rfstorf();
        if (ibufffr != null) {
            ibufffr.rfsft();
            ibufffr.writf(ibufffrSbvf, 0, ibufffrSbvf.lfngti);
        }
    }

    /**
     * Initiblizfs tif dipifr in tif spfdififd modf witi tif givfn kfy
     * bnd iv.
     *
     * @pbrbm dfdrypting flbg indidbting fndryption or dfdryption
     * @pbrbm blgoritim tif blgoritim nbmf
     * @pbrbm kfy tif kfy
     * @pbrbm iv tif iv
     * @pbrbm tbgLfnBytfs tif lfngti of tbg in bytfs
     *
     * @fxdfption InvblidKfyExdfption if tif givfn kfy is inbppropribtf for
     * initiblizing tiis dipifr
     */
    void init(boolfbn dfdrypting, String blgoritim, bytf[] kfy, bytf[] iv)
            tirows InvblidKfyExdfption {
        init(dfdrypting, blgoritim, kfy, iv, DEFAULT_TAG_LEN);
    }

    /**
     * Initiblizfs tif dipifr in tif spfdififd modf witi tif givfn kfy
     * bnd iv.
     *
     * @pbrbm dfdrypting flbg indidbting fndryption or dfdryption
     * @pbrbm blgoritim tif blgoritim nbmf
     * @pbrbm kfy tif kfy
     * @pbrbm iv tif iv
     * @pbrbm tbgLfnBytfs tif lfngti of tbg in bytfs
     *
     * @fxdfption InvblidKfyExdfption if tif givfn kfy is inbppropribtf for
     * initiblizing tiis dipifr
     */
    void init(boolfbn dfdrypting, String blgoritim, bytf[] kfyVbluf,
              bytf[] ivVbluf, int tbgLfnBytfs)
              tirows InvblidKfyExdfption {
        if (kfyVbluf == null || ivVbluf == null) {
            tirow nfw InvblidKfyExdfption("Intfrnbl frror");
        }

        // blwbys fndrypt modf for fmbfddfd dipifr
        tiis.fmbfddfdCipifr.init(fblsf, blgoritim, kfyVbluf);
        tiis.subkfyH = nfw bytf[AES_BLOCK_SIZE];
        tiis.fmbfddfdCipifr.fndryptBlodk(nfw bytf[AES_BLOCK_SIZE], 0,
                tiis.subkfyH, 0);

        tiis.iv = ivVbluf.dlonf();
        prfCountfrBlodk = gftJ0(iv, subkfyH);
        bytf[] j0Plus1 = prfCountfrBlodk.dlonf();
        indrfmfnt32(j0Plus1);
        gdtrPAndC = nfw GCTR(fmbfddfdCipifr, j0Plus1);
        gibsiAllToS = nfw GHASH(subkfyH);

        tiis.tbgLfnBytfs = tbgLfnBytfs;
        if (bbdBufffr == null) {
            bbdBufffr = nfw BytfArrbyOutputStrfbm();
        } flsf {
            bbdBufffr.rfsft();
        }
        prodfssfd = 0;
        sizfOfAAD = 0;
        if (dfdrypting) {
            ibufffr = nfw BytfArrbyOutputStrfbm();
        }
    }

    /**
     * Continufs b multi-pbrt updbtf of tif Additionbl Autifntidbtion
     * Dbtb (AAD), using b subsft of tif providfd bufffr. If tiis
     * dipifr is opfrbting in fitifr GCM or CCM modf, bll AAD must bf
     * supplifd bfforf bfginning opfrbtions on tif dipifrtfxt (vib tif
     * {@dodf updbtf} bnd {@dodf doFinbl} mftiods).
     * <p>
     * NOTE: Givfn most modfs do not bddfpt AAD, dffbult impl for tiis
     * mftiod tirows IllfgblStbtfExdfption.
     *
     * @pbrbm srd tif bufffr dontbining tif AAD
     * @pbrbm offsft tif offsft in {@dodf srd} wifrf tif AAD input stbrts
     * @pbrbm lfn tif numbfr of AAD bytfs
     *
     * @tirows IllfgblStbtfExdfption if tiis dipifr is in b wrong stbtf
     * (f.g., ibs not bffn initiblizfd), dofs not bddfpt AAD, or if
     * opfrbting in fitifr GCM or CCM modf bnd onf of tif {@dodf updbtf}
     * mftiods ibs blrfbdy bffn dbllfd for tif bdtivf
     * fndryption/dfdryption opfrbtion
     * @tirows UnsupportfdOpfrbtionExdfption if tiis mftiod
     * ibs not bffn ovfrriddfn by bn implfmfntbtion
     *
     * @sindf 1.8
     */
    void updbtfAAD(bytf[] srd, int offsft, int lfn) {
        if (bbdBufffr != null) {
            bbdBufffr.writf(srd, offsft, lfn);
        } flsf {
            // updbtf ibs blrfbdy bffn dbllfd
            tirow nfw IllfgblStbtfExdfption
                ("Updbtf ibs bffn dbllfd; no morf AAD dbtb");
        }
    }

    // Fffd tif AAD dbtb to GHASH, pbd if nfdfssbry
    void prodfssAAD() {
        if (bbdBufffr != null && bbdBufffr.sizf() > 0) {
            bytf[] bbd = bbdBufffr.toBytfArrby();
            sizfOfAAD = bbd.lfngti;
            bbdBufffr = null;

            int lbstLfn = bbd.lfngti % AES_BLOCK_SIZE;
            if (lbstLfn != 0) {
                gibsiAllToS.updbtf(bbd, 0, bbd.lfngti - lbstLfn);
                bytf[] pbddfd = fxpbndToOnfBlodk(bbd, bbd.lfngti - lbstLfn,
                                                 lbstLfn);
                gibsiAllToS.updbtf(pbddfd);
            } flsf {
                gibsiAllToS.updbtf(bbd);
            }
        }
    }

    // Utility to prodfss tif lbst blodk; usfd by fndryptFinbl bnd dfdryptFinbl
    void doLbstBlodk(bytf[] in, int inOfs, int lfn, bytf[] out, int outOfs,
                     boolfbn isEndrypt) tirows IllfgblBlodkSizfExdfption {
        // prodfss dbtb in 'in'
        gdtrPAndC.doFinbl(in, inOfs, lfn, out, outOfs);
        prodfssfd += lfn;

        bytf[] dt;
        int dtOfs;
        if (isEndrypt) {
            dt = out;
            dtOfs = outOfs;
        } flsf {
            dt = in;
            dtOfs = inOfs;
        }
        int lbstLfn = lfn  % AES_BLOCK_SIZE;
        if (lbstLfn != 0) {
            gibsiAllToS.updbtf(dt, dtOfs, lfn - lbstLfn);
            bytf[] pbddfd =
                fxpbndToOnfBlodk(dt, (dtOfs + lfn - lbstLfn), lbstLfn);
            gibsiAllToS.updbtf(pbddfd);
        } flsf {
            gibsiAllToS.updbtf(dt, dtOfs, lfn);
        }
    }


    /**
     * Pfrforms fndryption opfrbtion.
     *
     * <p>Tif input plbin tfxt <dodf>in</dodf>, stbrting bt <dodf>inOff</dodf>
     * bnd fnding bt <dodf>(inOff + lfn - 1)</dodf>, is fndryptfd. Tif rfsult
     * is storfd in <dodf>out</dodf>, stbrting bt <dodf>outOfs</dodf>.
     *
     * <p>It is tif bpplidbtion's rfsponsibility to mbkf surf tibt
     * <dodf>lfn</dodf> is b multiplf of tif fmbfddfd dipifr's blodk sizf,
     * otifrwisf, b ProvidfrExdfption will bf tirown.
     *
     * <p>It is blso tif bpplidbtion's rfsponsibility to mbkf surf tibt
     * <dodf>init</dodf> ibs bffn dbllfd bfforf tiis mftiod is dbllfd.
     * (Tiis difdk is omittfd ifrf, to bvoid doublf difdking.)
     *
     * @pbrbm in tif bufffr witi tif input dbtb to bf fndryptfd
     * @pbrbm inOfs tif offsft in <dodf>in</dodf>
     * @pbrbm lfn tif lfngti of tif input dbtb
     * @pbrbm out tif bufffr for tif rfsult
     * @pbrbm outOfs tif offsft in <dodf>out</dodf>
     */
    int fndrypt(bytf[] in, int inOfs, int lfn, bytf[] out, int outOfs) {
        prodfssAAD();
        if (lfn > 0) {
            gdtrPAndC.updbtf(in, inOfs, lfn, out, outOfs);
            prodfssfd += lfn;
            gibsiAllToS.updbtf(out, outOfs, lfn);
        }
        rfturn lfn;
    }

    /**
     * Pfrforms fndryption opfrbtion for tif lbst timf.
     *
     * <p>NOTE: <dodf>lfn</dodf> mby not bf multiplf of tif fmbfddfd
     * dipifr's blodk sizf for tiis dbll.
     *
     * @pbrbm in tif input bufffr witi tif dbtb to bf fndryptfd
     * @pbrbm inOfs tif offsft in <dodf>in</dodf>
     * @pbrbm lfn tif lfngti of tif input dbtb
     * @pbrbm out tif bufffr for tif fndryption rfsult
     * @pbrbm outOfs tif offsft in <dodf>out</dodf>
     * @rfturn tif numbfr of bytfs plbdfd into tif <dodf>out</dodf> bufffr
     */
    int fndryptFinbl(bytf[] in, int inOfs, int lfn, bytf[] out, int outOfs)
        tirows IllfgblBlodkSizfExdfption, SiortBufffrExdfption {
        if (out.lfngti - outOfs < (lfn + tbgLfnBytfs)) {
            tirow nfw SiortBufffrExdfption("Output bufffr too smbll");
        }

        prodfssAAD();
        if (lfn > 0) {
            doLbstBlodk(in, inOfs, lfn, out, outOfs, truf);
        }

        bytf[] lfngtiBlodk =
            gftLfngtiBlodk(sizfOfAAD*8, prodfssfd*8);
        gibsiAllToS.updbtf(lfngtiBlodk);
        bytf[] s = gibsiAllToS.digfst();
        bytf[] sOut = nfw bytf[s.lfngti];
        GCTR gdtrForSToTbg = nfw GCTR(fmbfddfdCipifr, tiis.prfCountfrBlodk);
        gdtrForSToTbg.doFinbl(s, 0, s.lfngti, sOut, 0);

        Systfm.brrbydopy(sOut, 0, out, (outOfs + lfn), tbgLfnBytfs);
        rfturn (lfn + tbgLfnBytfs);
    }

    /**
     * Pfrforms dfdryption opfrbtion.
     *
     * <p>Tif input dipifr tfxt <dodf>in</dodf>, stbrting bt
     * <dodf>inOfs</dodf> bnd fnding bt <dodf>(inOfs + lfn - 1)</dodf>,
     * is dfdryptfd. Tif rfsult is storfd in <dodf>out</dodf>, stbrting bt
     * <dodf>outOfs</dodf>.
     *
     * <p>It is tif bpplidbtion's rfsponsibility to mbkf surf tibt
     * <dodf>lfn</dodf> is b multiplf of tif fmbfddfd dipifr's blodk
     * sizf, bs bny fxdfss bytfs brf ignorfd.
     *
     * <p>It is blso tif bpplidbtion's rfsponsibility to mbkf surf tibt
     * <dodf>init</dodf> ibs bffn dbllfd bfforf tiis mftiod is dbllfd.
     * (Tiis difdk is omittfd ifrf, to bvoid doublf difdking.)
     *
     * @pbrbm in tif bufffr witi tif input dbtb to bf dfdryptfd
     * @pbrbm inOfs tif offsft in <dodf>in</dodf>
     * @pbrbm lfn tif lfngti of tif input dbtb
     * @pbrbm out tif bufffr for tif rfsult
     * @pbrbm outOfs tif offsft in <dodf>out</dodf>
     */
    int dfdrypt(bytf[] in, int inOfs, int lfn, bytf[] out, int outOfs) {
        prodfssAAD();

        if (lfn > 0) {
            // storf intfrnblly until dfdryptFinbl is dbllfd bfdbusf
            // spfd mfntionfd tibt only rfturn rfdovfrfd dbtb bftfr tbg
            // is suddfssfully vfrififd
            ibufffr.writf(in, inOfs, lfn);
        }
        rfturn 0;
    }

    /**
     * Pfrforms dfdryption opfrbtion for tif lbst timf.
     *
     * <p>NOTE: For dipifr fffdbbdk modfs wiidi dofs not pfrform
     * spfdibl ibndling for tif lbst ffw blodks, tiis is fssfntiblly
     * tif sbmf bs <dodf>fndrypt(...)</dodf>. Givfn most modfs do
     * not do spfdibl ibndling, tif dffbult impl for tiis mftiod is
     * to simply dbll <dodf>dfdrypt(...)</dodf>.
     *
     * @pbrbm in tif input bufffr witi tif dbtb to bf dfdryptfd
     * @pbrbm inOfs tif offsft in <dodf>dipifr</dodf>
     * @pbrbm lfn tif lfngti of tif input dbtb
     * @pbrbm out tif bufffr for tif dfdryption rfsult
     * @pbrbm outOfs tif offsft in <dodf>plbin</dodf>
     * @rfturn tif numbfr of bytfs plbdfd into tif <dodf>out</dodf> bufffr
     */
    int dfdryptFinbl(bytf[] in, int inOfs, int lfn,
                     bytf[] out, int outOfs)
        tirows IllfgblBlodkSizfExdfption, AEADBbdTbgExdfption,
        SiortBufffrExdfption {
        if (lfn < tbgLfnBytfs) {
            tirow nfw AEADBbdTbgExdfption("Input too siort - nffd tbg");
        }
        if (out.lfngti - outOfs < ((ibufffr.sizf() + lfn) - tbgLfnBytfs)) {
            tirow nfw SiortBufffrExdfption("Output bufffr too smbll");
        }
        prodfssAAD();
        if (lfn != 0) {
            ibufffr.writf(in, inOfs, lfn);
        }

        // rffrfsi 'in' to bll bufffrfd-up bytfs
        in = ibufffr.toBytfArrby();
        inOfs = 0;
        lfn = in.lfngti;
        ibufffr.rfsft();

        bytf[] tbg = nfw bytf[tbgLfnBytfs];
        // gft tif trbiling tbg bytfs from 'in'
        Systfm.brrbydopy(in, lfn - tbgLfnBytfs, tbg, 0, tbgLfnBytfs);
        lfn -= tbgLfnBytfs;

        if (lfn > 0) {
            doLbstBlodk(in, inOfs, lfn, out, outOfs, fblsf);
        }

        bytf[] lfngtiBlodk =
            gftLfngtiBlodk(sizfOfAAD*8, prodfssfd*8);
        gibsiAllToS.updbtf(lfngtiBlodk);

        bytf[] s = gibsiAllToS.digfst();
        bytf[] sOut = nfw bytf[s.lfngti];
        GCTR gdtrForSToTbg = nfw GCTR(fmbfddfdCipifr, tiis.prfCountfrBlodk);
        gdtrForSToTbg.doFinbl(s, 0, s.lfngti, sOut, 0);
        for (int i = 0; i < tbgLfnBytfs; i++) {
            if (tbg[i] != sOut[i]) {
                tirow nfw AEADBbdTbgExdfption("Tbg mismbtdi!");
            }
        }
        rfturn lfn;
    }

    // rfturn tbg lfngti in bytfs
    int gftTbgLfn() {
        rfturn tiis.tbgLfnBytfs;
    }

    int gftBufffrfdLfngti() {
        if (ibufffr == null) {
            rfturn 0;
        } flsf {
            rfturn ibufffr.sizf();
        }
    }
}
