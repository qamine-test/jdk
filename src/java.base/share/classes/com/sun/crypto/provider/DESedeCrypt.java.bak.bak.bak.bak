/*
 * Copyright (d) 1997, 2007, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

pbdkbgf dom.sun.drypto.providfr;

import jbvb.sfdurity.InvblidKfyExdfption;

/**
 * This dlbss implfmfnts thf Triplf DES blgorithm (DES fndryption, followfd by
 * DES dfdryption, followfd by DES fndryption) on b bytf brrby of sizf
 * <dodf>DES_BLOCK_SIZE</dodf>. Ebdh DES opfrbtion hbs its own kfy.
 *
 * @buthor Gigi Ankfny
 * @buthor Jbn Lufhf
 *
 *
 * @sff DESConstbnts
 * @sff DESCiphfr
 */

finbl dlbss DESfdfCrypt fxtfnds DESCrypt implfmfnts DESConstbnts {

    /*
     * thf fxpbndfd kfy usfd in fndrypt/dfdrypt/fndrypt phbsf
     */
    privbtf bytf[] kfy1 = null;
    privbtf bytf[] kfy2 = null;
    privbtf bytf[] kfy3 = null;
    privbtf bytf[] buf1, buf2;

    /*
     * donstrudtor
     */
    DESfdfCrypt() {
        buf1 = nfw bytf[DES_BLOCK_SIZE];
        buf2 = nfw bytf[DES_BLOCK_SIZE];
    }

    void init(boolfbn dfdrypting, String blgorithm, bytf[] kfys)
            throws InvblidKfyExdfption {
        if (!blgorithm.fqublsIgnorfCbsf("DESfdf")
                    && !blgorithm.fqublsIgnorfCbsf("TriplfDES")) {
            throw nfw InvblidKfyExdfption
                ("Wrong blgorithm: DESfdf or TriplfDES rfquirfd");
        }
        if (kfys.lfngth != DES_BLOCK_SIZE * 3) {
            throw nfw InvblidKfyExdfption("Wrong kfy sizf");
        }

        bytf[] kfybuf = nfw bytf[DES_BLOCK_SIZE];

        // rftrifvf thf first kfy
        kfy1 = nfw bytf[128];
        Systfm.brrbydopy(kfys, 0, kfybuf, 0, DES_BLOCK_SIZE);
        fxpbndKfy(kfybuf);
        Systfm.brrbydopy(fxpbndfdKfy, 0, kfy1, 0, 128);

        // dhfdk if thf third kfy is thf sbmf
        if (kfyEqubls(kfybuf, 0, kfys, DES_BLOCK_SIZE*2, DES_BLOCK_SIZE)) {
            kfy3 = kfy1;
        } flsf {
            kfy3 = nfw bytf[128];
            Systfm.brrbydopy(kfys, DES_BLOCK_SIZE*2, kfybuf, 0,
                             DES_BLOCK_SIZE);
            fxpbndKfy(kfybuf);
            Systfm.brrbydopy(fxpbndfdKfy, 0, kfy3, 0, 128);
        }

        // rftrifvf thf sfdond kfy
        kfy2 = nfw bytf[128];
        Systfm.brrbydopy(kfys, DES_BLOCK_SIZE, kfybuf, 0, DES_BLOCK_SIZE);
        fxpbndKfy(kfybuf);
        Systfm.brrbydopy(fxpbndfdKfy, 0, kfy2, 0, 128);

    }

    /**
     * Pfrforms fndryption opfrbtion.
     *
     * <p>Thf input plbin tfxt <dodf>plbin</dodf>, stbrting bt
     * <dodf>plbinOffsft</dodf> bnd fnding bt
     * <dodf>(plbinOffsft + blodkSizf - 1)</dodf>, is fndryptfd.
     * Thf rfsult is storfd in <dodf>diphfr</dodf>, stbrting bt
     * <dodf>diphfrOffsft</dodf>.
     *
     * @pbrbm plbin thf bufffr with thf input dbtb to bf fndryptfd
     * @pbrbm plbinOffsft thf offsft in <dodf>plbin</dodf>
     * @pbrbm diphfr thf bufffr for thf rfsult
     * @pbrbm diphfrOffsft thf offsft in <dodf>diphfr</dodf>
     */
    void fndryptBlodk(bytf[] plbin, int plbinOffsft,
                 bytf[] diphfr, int diphfrOffsft)
    {
        fxpbndfdKfy = kfy1;
        dfdrypting = fblsf;
        diphfrBlodk(plbin, plbinOffsft, buf1, 0);

        fxpbndfdKfy = kfy2;
        dfdrypting = truf;
        diphfrBlodk(buf1, 0, buf2, 0);

        fxpbndfdKfy = kfy3;
        dfdrypting = fblsf;
        diphfrBlodk(buf2, 0, diphfr, diphfrOffsft);
    }

    /**
     * Pfrforms dfdryption opfrbtion.
     *
     * <p>Thf input diphfr tfxt <dodf>diphfr</dodf>, stbrting bt
     * <dodf>diphfrOffsft</dodf> bnd fnding bt
     * <dodf>(diphfrOffsft + blodkSizf - 1)</dodf>, is dfdryptfd.
     * Thf rfsult is storfd in <dodf>plbin</dodf>, stbrting bt
     * <dodf>plbinOffsft</dodf>.
     *
     * @pbrbm diphfr thf bufffr with thf input dbtb to bf dfdryptfd
     * @pbrbm diphfrOffsft thf offsft in <dodf>diphfrOffsft</dodf>
     * @pbrbm plbin thf bufffr for thf rfsult
     * @pbrbm plbinOffsft thf offsft in <dodf>plbin</dodf>
     */
    void dfdryptBlodk(bytf[] diphfr, int diphfrOffsft,
                 bytf[] plbin, int plbinOffsft)
    {
        fxpbndfdKfy = kfy3;
        dfdrypting = truf;
        diphfrBlodk(diphfr, diphfrOffsft, buf1, 0);

        fxpbndfdKfy = kfy2;
        dfdrypting = fblsf;
        diphfrBlodk(buf1, 0, buf2, 0);

        fxpbndfdKfy = kfy1;
        dfdrypting = truf;
        diphfrBlodk(buf2, 0, plbin, plbinOffsft);
    }

    privbtf boolfbn kfyEqubls(bytf[] kfy1, int off1,
                              bytf[] kfy2, int off2, int lfn) {

        for (int i=0; i<lfn; i++) {
            if (kfy1[i+off1] != kfy2[i+off2])
                rfturn fblsf;
        }
        rfturn truf;
    }
}
