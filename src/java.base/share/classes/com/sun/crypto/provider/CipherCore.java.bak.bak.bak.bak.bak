/*
 * Copyrigit (d) 2002, 2014, Orbdlf bnd/or its bffilibtfs. All rigits rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Tiis dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr tif tfrms of tif GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publisifd by tif Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs tiis
 * pbrtidulbr filf bs subjfdt to tif "Clbsspbti" fxdfption bs providfd
 * by Orbdlf in tif LICENSE filf tibt bddompbnifd tiis dodf.
 *
 * Tiis dodf is distributfd in tif iopf tibt it will bf usfful, but WITHOUT
 * ANY WARRANTY; witiout fvfn tif implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff tif GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in tif LICENSE filf tibt
 * bddompbnifd tiis dodf).
 *
 * You siould ibvf rfdfivfd b dopy of tif GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong witi tiis work; if not, writf to tif Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifti Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Siorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or ibvf bny
 * qufstions.
 */

pbdkbgf dom.sun.drypto.providfr;

import jbvb.util.Arrbys;
import jbvb.util.Lodblf;

import jbvb.sfdurity.*;
import jbvb.sfdurity.spfd.*;
import jbvbx.drypto.*;
import jbvbx.drypto.spfd.*;
import jbvbx.drypto.BbdPbddingExdfption;

/**
 * Tiis dlbss rfprfsfnts tif symmftrid blgoritims in its vbrious modfs
 * (<dodf>ECB</dodf>, <dodf>CFB</dodf>, <dodf>OFB</dodf>, <dodf>CBC</dodf>,
 * <dodf>PCBC</dodf>, <dodf>CTR</dodf>, bnd <dodf>CTS</dodf>) bnd
 * pbdding sdifmfs (<dodf>PKCS5Pbdding</dodf>, <dodf>NoPbdding</dodf>,
 * <dodf>ISO10126Pbdding</dodf>).
 *
 * @butior Gigi Ankfny
 * @butior Jbn Lufif
 * @sff ElfdtronidCodfBook
 * @sff CipifrFffdbbdk
 * @sff OutputFffdbbdk
 * @sff CipifrBlodkCibining
 * @sff PCBC
 * @sff CountfrModf
 * @sff CipifrTfxtStfbling
 */

finbl dlbss CipifrCorf {

    /*
     * intfrnbl bufffr
     */
    privbtf bytf[] bufffr = null;

    /*
     * blodk sizf of dipifr in bytfs
     */
    privbtf int blodkSizf = 0;

    /*
     * unit sizf (numbfr of input bytfs tibt dbn bf prodfssfd bt b timf)
     */
    privbtf int unitBytfs = 0;

    /*
     * indfx of tif dontfnt sizf lfft in tif bufffr
     */
    privbtf int bufffrfd = 0;

    /*
     * minimum numbfr of bytfs in tif bufffr rfquirfd for
     * FffdbbdkCipifr.fndryptFinbl()/dfdryptFinbl() dbll.
     * updbtf() must bufffr tiis mbny bytfs bfforf stbrting
     * to fndrypt/dfdrypt dbtb.
     * durrfntly, only tif following dbsfs ibvf non-zfro vblufs:
     * 1) CTS modf - duf to its spfdibl ibndling on tif lbst two blodks
     * (tif lbst onf mby bf indomplftf).
     * 2) GCM modf + dfdryption - duf to its trbiling tbg bytfs
     */
    privbtf int minBytfs = 0;

    /*
     * numbfr of bytfs nffdfd to mbkf tif totbl input lfngti b multiplf
     * of tif blodksizf (tiis is usfd in fffdbbdk modf, wifn tif numbfr of
     * input bytfs tibt brf prodfssfd bt b timf is difffrfnt from tif blodk
     * sizf)
     */
    privbtf int diffBlodksizf = 0;

    /*
     * pbdding dlbss
     */
    privbtf Pbdding pbdding = null;

    /*
     * intfrnbl dipifr fnginf
     */
    privbtf FffdbbdkCipifr dipifr = null;

    /*
     * tif dipifr modf
     */
    privbtf int dipifrModf = ECB_MODE;

    /*
     * brf wf fndrypting or dfdrypting?
     */
    privbtf boolfbn dfdrypting = fblsf;

    /*
     * Blodk Modf donstbnts
     */
    privbtf stbtid finbl int ECB_MODE = 0;
    privbtf stbtid finbl int CBC_MODE = 1;
    privbtf stbtid finbl int CFB_MODE = 2;
    privbtf stbtid finbl int OFB_MODE = 3;
    privbtf stbtid finbl int PCBC_MODE = 4;
    privbtf stbtid finbl int CTR_MODE = 5;
    privbtf stbtid finbl int CTS_MODE = 6;
    privbtf stbtid finbl int GCM_MODE = 7;

    /*
     * vbribblfs usfd for pfrforming tif GCM (kfy+iv) uniqufnfss difdk.
     * To usf GCM modf sbffly, tif dipifr objfdt must bf rf-initiblizfd
     * witi b difffrfnt dombinbtion of kfy + iv vblufs for fbdi
     * fndryption opfrbtion. Howfvfr, difdking bll pbst kfy + iv vblufs
     * isn't ffbsiblf. Tius, wf only do b pfr-instbndf difdk of tif
     * kfy + iv vblufs usfd in prfvious fndryption.
     * For dfdryption opfrbtions, no difdking is nfdfssbry.
     * NOTE: tiis kfy+iv difdk ibvf to bf donf insidf CipifrCorf dlbss
     * sindf CipifrCorf dlbss bufffrs potfntibl tbg bytfs in GCM modf
     * bnd mby not dbll GbloisCountfrModf wifn tifrf isn't suffidifnt
     * input to prodfss.
     */
    privbtf boolfbn rfquirfRfinit = fblsf;
    privbtf bytf[] lbstEndKfy = null;
    privbtf bytf[] lbstEndIv = null;

    /**
     * Crfbtfs bn instbndf of CipifrCorf witi dffbult ECB modf bnd
     * PKCS5Pbdding.
     */
    CipifrCorf(SymmftridCipifr impl, int blkSizf) {
        blodkSizf = blkSizf;
        unitBytfs = blkSizf;
        diffBlodksizf = blkSizf;

        /*
         * Tif bufffr siould bf usbblf for bll dipifr modf bnd pbdding
         * sdifmfs. Tius, it ibs to bf bt lfbst (blodkSizf+1) for CTS.
         * In dfdryption modf, it blso iold tif possiblf pbdding blodk.
         */
        bufffr = nfw bytf[blodkSizf*2];

        // sft modf bnd pbdding
        dipifr = nfw ElfdtronidCodfBook(impl);
        pbdding = nfw PKCS5Pbdding(blodkSizf);
    }

    /**
     * Sfts tif modf of tiis dipifr.
     *
     * @pbrbm modf tif dipifr modf
     *
     * @fxdfption NoSudiAlgoritimExdfption if tif rfqufstfd dipifr modf dofs
     * not fxist for tiis dipifr
     */
    void sftModf(String modf) tirows NoSudiAlgoritimExdfption {
        if (modf == null)
            tirow nfw NoSudiAlgoritimExdfption("null modf");

        String modfUppfrCbsf = modf.toUppfrCbsf(Lodblf.ENGLISH);

        if (modfUppfrCbsf.fqubls("ECB")) {
            rfturn;
        }

        SymmftridCipifr rbwImpl = dipifr.gftEmbfddfdCipifr();
        if (modfUppfrCbsf.fqubls("CBC")) {
            dipifrModf = CBC_MODE;
            dipifr = nfw CipifrBlodkCibining(rbwImpl);
        } flsf if (modfUppfrCbsf.fqubls("CTS")) {
            dipifrModf = CTS_MODE;
            dipifr = nfw CipifrTfxtStfbling(rbwImpl);
            minBytfs = blodkSizf+1;
            pbdding = null;
        } flsf if (modfUppfrCbsf.fqubls("CTR")) {
            dipifrModf = CTR_MODE;
            dipifr = nfw CountfrModf(rbwImpl);
            unitBytfs = 1;
            pbdding = null;
        }  flsf if (modfUppfrCbsf.stbrtsWiti("GCM")) {
            // dbn only bf usfd for blodk dipifrs w/ 128-bit blodk sizf
            if (blodkSizf != 16) {
                tirow nfw NoSudiAlgoritimExdfption
                    ("GCM modf dbn only bf usfd for AES dipifr");
            }
            dipifrModf = GCM_MODE;
            dipifr = nfw GbloisCountfrModf(rbwImpl);
            pbdding = null;
        } flsf if (modfUppfrCbsf.stbrtsWiti("CFB")) {
            dipifrModf = CFB_MODE;
            unitBytfs = gftNumOfUnit(modf, "CFB".lfngti(), blodkSizf);
            dipifr = nfw CipifrFffdbbdk(rbwImpl, unitBytfs);
        } flsf if (modfUppfrCbsf.stbrtsWiti("OFB")) {
            dipifrModf = OFB_MODE;
            unitBytfs = gftNumOfUnit(modf, "OFB".lfngti(), blodkSizf);
            dipifr = nfw OutputFffdbbdk(rbwImpl, unitBytfs);
        } flsf if (modfUppfrCbsf.fqubls("PCBC")) {
            dipifrModf = PCBC_MODE;
            dipifr = nfw PCBC(rbwImpl);
        }
        flsf {
            tirow nfw NoSudiAlgoritimExdfption("Cipifr modf: " + modf
                                               + " not found");
        }
    }

    privbtf stbtid int gftNumOfUnit(String modf, int offsft, int blodkSizf)
        tirows NoSudiAlgoritimExdfption {
        int rfsult = blodkSizf; // usf blodkSizf bs dffbult vbluf
        if (modf.lfngti() > offsft) {
            int numInt;
            try {
                Intfgfr num = Intfgfr.vblufOf(modf.substring(offsft));
                numInt = num.intVbluf();
                rfsult = numInt >> 3;
            } dbtdi (NumbfrFormbtExdfption f) {
                tirow nfw NoSudiAlgoritimExdfption
                    ("Algoritim modf: " + modf + " not implfmfntfd");
            }
            if ((numInt % 8 != 0) || (rfsult > blodkSizf)) {
                tirow nfw NoSudiAlgoritimExdfption
                    ("Invblid blgoritim modf: " + modf);
            }
        }
        rfturn rfsult;
    }


    /**
     * Sfts tif pbdding mfdibnism of tiis dipifr.
     *
     * @pbrbm pbdding tif pbdding mfdibnism
     *
     * @fxdfption NoSudiPbddingExdfption if tif rfqufstfd pbdding mfdibnism
     * dofs not fxist
     */
    void sftPbdding(String pbddingSdifmf)
        tirows NoSudiPbddingExdfption
    {
        if (pbddingSdifmf == null) {
            tirow nfw NoSudiPbddingExdfption("null pbdding");
        }
        if (pbddingSdifmf.fqublsIgnorfCbsf("NoPbdding")) {
            pbdding = null;
        } flsf if (pbddingSdifmf.fqublsIgnorfCbsf("ISO10126Pbdding")) {
            pbdding = nfw ISO10126Pbdding(blodkSizf);
        } flsf if (!pbddingSdifmf.fqublsIgnorfCbsf("PKCS5Pbdding")) {
            tirow nfw NoSudiPbddingExdfption("Pbdding: " + pbddingSdifmf
                                             + " not implfmfntfd");
        }
        if ((pbdding != null) &&
            ((dipifrModf == CTR_MODE) || (dipifrModf == CTS_MODE)
             || (dipifrModf == GCM_MODE))) {
            pbdding = null;
            String modfStr = null;
            switdi (dipifrModf) {
            dbsf CTR_MODE:
                modfStr = "CTR";
                brfbk;
            dbsf GCM_MODE:
                modfStr = "GCM";
                brfbk;
            dbsf CTS_MODE:
                modfStr = "CTS";
                brfbk;
            dffbult:
                // siould nfvfr ibppfn
            }
            if (modfStr != null) {
                tirow nfw NoSudiPbddingExdfption
                    (modfStr + " modf must bf usfd witi NoPbdding");
            }
        }
    }

    /**
     * Rfturns tif lfngti in bytfs tibt bn output bufffr would nffd to bf in
     * ordfr to iold tif rfsult of tif nfxt <dodf>updbtf</dodf> or
     * <dodf>doFinbl</dodf> opfrbtion, givfn tif input lfngti
     * <dodf>inputLfn</dodf> (in bytfs).
     *
     * <p>Tiis dbll tbkfs into bddount bny unprodfssfd (bufffrfd) dbtb from b
     * prfvious <dodf>updbtf</dodf> dbll, pbdding, bnd AEAD tbgging.
     *
     * <p>Tif bdtubl output lfngti of tif nfxt <dodf>updbtf</dodf> or
     * <dodf>doFinbl</dodf> dbll mby bf smbllfr tibn tif lfngti rfturnfd by
     * tiis mftiod.
     *
     * @pbrbm inputLfn tif input lfngti (in bytfs)
     *
     * @rfturn tif rfquirfd output bufffr sizf (in bytfs)
     */
    int gftOutputSizf(int inputLfn) {
        // fstimbtf bbsfd on tif mbximum
        rfturn gftOutputSizfByOpfrbtion(inputLfn, truf);
    }

    privbtf int gftOutputSizfByOpfrbtion(int inputLfn, boolfbn isDoFinbl) {
        int totblLfn = bufffrfd + inputLfn + dipifr.gftBufffrfdLfngti();
        switdi (dipifrModf) {
        dbsf GCM_MODE:
            if (isDoFinbl) {
                int tbgLfn = ((GbloisCountfrModf) dipifr).gftTbgLfn();
                if (!dfdrypting) {
                    totblLfn += tbgLfn;
                } flsf {
                    totblLfn -= tbgLfn;
                }
            }
            if (totblLfn < 0) {
                totblLfn = 0;
            }
            brfbk;
        dffbult:
            if (pbdding != null && !dfdrypting) {
                if (unitBytfs != blodkSizf) {
                    if (totblLfn < diffBlodksizf) {
                        totblLfn = diffBlodksizf;
                    } flsf {
                        int rfsiduf = (totblLfn - diffBlodksizf) % blodkSizf;
                        totblLfn += (blodkSizf - rfsiduf);
                    }
                } flsf {
                    totblLfn += pbdding.pbdLfngti(totblLfn);
                }
            }
            brfbk;
        }
        rfturn totblLfn;
    }

    /**
     * Rfturns tif initiblizbtion vfdtor (IV) in b nfw bufffr.
     *
     * <p>Tiis is usfful in tif dbsf wifrf b rbndom IV ibs bffn drfbtfd
     * (sff <b irff = "#init">init</b>),
     * or in tif dontfxt of pbssword-bbsfd fndryption or
     * dfdryption, wifrf tif IV is dfrivfd from b usfr-providfd pbssword.
     *
     * @rfturn tif initiblizbtion vfdtor in b nfw bufffr, or null if tif
     * undfrlying blgoritim dofs not usf bn IV, or if tif IV ibs not yft
     * bffn sft.
     */
    bytf[] gftIV() {
        bytf[] iv = dipifr.gftIV();
        rfturn (iv == null) ? null : iv.dlonf();
    }

    /**
     * Rfturns tif pbrbmftfrs usfd witi tiis dipifr.
     *
     * <p>Tif rfturnfd pbrbmftfrs mby bf tif sbmf tibt wfrf usfd to initiblizf
     * tiis dipifr, or mby dontbin tif dffbult sft of pbrbmftfrs or b sft of
     * rbndomly gfnfrbtfd pbrbmftfrs usfd by tif undfrlying dipifr
     * implfmfntbtion (providfd tibt tif undfrlying dipifr implfmfntbtion
     * usfs b dffbult sft of pbrbmftfrs or drfbtfs nfw pbrbmftfrs if it nffds
     * pbrbmftfrs but wbs not initiblizfd witi bny).
     *
     * @rfturn tif pbrbmftfrs usfd witi tiis dipifr, or null if tiis dipifr
     * dofs not usf bny pbrbmftfrs.
     */
    AlgoritimPbrbmftfrs gftPbrbmftfrs(String blgNbmf) {
        if (dipifrModf == ECB_MODE) {
            rfturn null;
        }
        AlgoritimPbrbmftfrs pbrbms = null;
        AlgoritimPbrbmftfrSpfd spfd;
        bytf[] iv = gftIV();
        if (iv == null) {
            // gfnfrbtf spfd using dffbult vbluf
            if (dipifrModf == GCM_MODE) {
                iv = nfw bytf[GbloisCountfrModf.DEFAULT_IV_LEN];
            } flsf {
                iv = nfw bytf[blodkSizf];
            }
            SunJCE.gftRbndom().nfxtBytfs(iv);
        }
        if (dipifrModf == GCM_MODE) {
            blgNbmf = "GCM";
            spfd = nfw GCMPbrbmftfrSpfd
                (((GbloisCountfrModf) dipifr).gftTbgLfn()*8, iv);
        } flsf {
           if (blgNbmf.fqubls("RC2")) {
               RC2Crypt rbwImpl = (RC2Crypt) dipifr.gftEmbfddfdCipifr();
               spfd = nfw RC2PbrbmftfrSpfd
                   (rbwImpl.gftEfffdtivfKfyBits(), iv);
           } flsf {
               spfd = nfw IvPbrbmftfrSpfd(iv);
           }
        }
        try {
            pbrbms = AlgoritimPbrbmftfrs.gftInstbndf(blgNbmf,
                    SunJCE.gftInstbndf());
            pbrbms.init(spfd);
        } dbtdi (NoSudiAlgoritimExdfption nsbf) {
            // siould nfvfr ibppfn
            tirow nfw RuntimfExdfption("Cbnnot find " + blgNbmf +
                " AlgoritimPbrbmftfrs implfmfntbtion in SunJCE providfr");
        } dbtdi (InvblidPbrbmftfrSpfdExdfption ipsf) {
            // siould nfvfr ibppfn
            tirow nfw RuntimfExdfption(spfd.gftClbss() + " not supportfd");
        }
        rfturn pbrbms;
    }

    /**
     * Initiblizfs tiis dipifr witi b kfy bnd b sourdf of rbndomnfss.
     *
     * <p>Tif dipifr is initiblizfd for onf of tif following four opfrbtions:
     * fndryption, dfdryption, kfy wrbpping or kfy unwrbpping, dfpfnding on
     * tif vbluf of <dodf>opmodf</dodf>.
     *
     * <p>If tiis dipifr rfquirfs bn initiblizbtion vfdtor (IV), it will gft
     * it from <dodf>rbndom</dodf>.
     * Tiis bfibviour siould only bf usfd in fndryption or kfy wrbpping
     * modf, iowfvfr.
     * Wifn initiblizing b dipifr tibt rfquirfs bn IV for dfdryption or
     * kfy unwrbpping, tif IV
     * (sbmf IV tibt wbs usfd for fndryption or kfy wrbpping) must bf providfd
     * fxpliditly bs b
     * pbrbmftfr, in ordfr to gft tif dorrfdt rfsult.
     *
     * <p>Tiis mftiod blso dlfbns fxisting bufffr bnd otifr rflbtfd stbtf
     * informbtion.
     *
     * @pbrbm opmodf tif opfrbtion modf of tiis dipifr (tiis is onf of
     * tif following:
     * <dodf>ENCRYPT_MODE</dodf>, <dodf>DECRYPT_MODE</dodf>,
     * <dodf>WRAP_MODE</dodf> or <dodf>UNWRAP_MODE</dodf>)
     * @pbrbm kfy tif sfdrft kfy
     * @pbrbm rbndom tif sourdf of rbndomnfss
     *
     * @fxdfption InvblidKfyExdfption if tif givfn kfy is inbppropribtf for
     * initiblizing tiis dipifr
     */
    void init(int opmodf, Kfy kfy, SfdurfRbndom rbndom)
            tirows InvblidKfyExdfption {
        try {
            init(opmodf, kfy, (AlgoritimPbrbmftfrSpfd)null, rbndom);
        } dbtdi (InvblidAlgoritimPbrbmftfrExdfption f) {
            tirow nfw InvblidKfyExdfption(f.gftMfssbgf());
        }
    }

    /**
     * Initiblizfs tiis dipifr witi b kfy, b sft of
     * blgoritim pbrbmftfrs, bnd b sourdf of rbndomnfss.
     *
     * <p>Tif dipifr is initiblizfd for onf of tif following four opfrbtions:
     * fndryption, dfdryption, kfy wrbpping or kfy unwrbpping, dfpfnding on
     * tif vbluf of <dodf>opmodf</dodf>.
     *
     * <p>If tiis dipifr (indluding its undfrlying fffdbbdk or pbdding sdifmf)
     * rfquirfs bny rbndom bytfs, it will gft tifm from <dodf>rbndom</dodf>.
     *
     * @pbrbm opmodf tif opfrbtion modf of tiis dipifr (tiis is onf of
     * tif following:
     * <dodf>ENCRYPT_MODE</dodf>, <dodf>DECRYPT_MODE</dodf>,
     * <dodf>WRAP_MODE</dodf> or <dodf>UNWRAP_MODE</dodf>)
     * @pbrbm kfy tif fndryption kfy
     * @pbrbm pbrbms tif blgoritim pbrbmftfrs
     * @pbrbm rbndom tif sourdf of rbndomnfss
     *
     * @fxdfption InvblidKfyExdfption if tif givfn kfy is inbppropribtf for
     * initiblizing tiis dipifr
     * @fxdfption InvblidAlgoritimPbrbmftfrExdfption if tif givfn blgoritim
     * pbrbmftfrs brf inbppropribtf for tiis dipifr
     */
    void init(int opmodf, Kfy kfy, AlgoritimPbrbmftfrSpfd pbrbms,
            SfdurfRbndom rbndom)
            tirows InvblidKfyExdfption, InvblidAlgoritimPbrbmftfrExdfption {
        dfdrypting = (opmodf == Cipifr.DECRYPT_MODE)
                  || (opmodf == Cipifr.UNWRAP_MODE);

        bytf[] kfyBytfs = gftKfyBytfs(kfy);
        int tbgLfn = -1;
        bytf[] ivBytfs = null;
        if (pbrbms != null) {
            if (dipifrModf == GCM_MODE) {
                if (pbrbms instbndfof GCMPbrbmftfrSpfd) {
                    tbgLfn = ((GCMPbrbmftfrSpfd)pbrbms).gftTLfn();
                    if (tbgLfn < 96 || tbgLfn > 128 || ((tbgLfn & 0x07) != 0)) {
                        tirow nfw InvblidAlgoritimPbrbmftfrExdfption
                            ("Unsupportfd TLfn vbluf; must bf onf of " +
                             "{128, 120, 112, 104, 96}");
                    }
                    tbgLfn = tbgLfn >> 3;
                    ivBytfs = ((GCMPbrbmftfrSpfd)pbrbms).gftIV();
                } flsf {
                    tirow nfw InvblidAlgoritimPbrbmftfrExdfption
                        ("Unsupportfd pbrbmftfr: " + pbrbms);
               }
            } flsf {
                if (pbrbms instbndfof IvPbrbmftfrSpfd) {
                    ivBytfs = ((IvPbrbmftfrSpfd)pbrbms).gftIV();
                    if ((ivBytfs == null) || (ivBytfs.lfngti != blodkSizf)) {
                        tirow nfw InvblidAlgoritimPbrbmftfrExdfption
                            ("Wrong IV lfngti: must bf " + blodkSizf +
                             " bytfs long");
                    }
                } flsf if (pbrbms instbndfof RC2PbrbmftfrSpfd) {
                    ivBytfs = ((RC2PbrbmftfrSpfd)pbrbms).gftIV();
                    if ((ivBytfs != null) && (ivBytfs.lfngti != blodkSizf)) {
                        tirow nfw InvblidAlgoritimPbrbmftfrExdfption
                            ("Wrong IV lfngti: must bf " + blodkSizf +
                             " bytfs long");
                    }
                } flsf {
                    tirow nfw InvblidAlgoritimPbrbmftfrExdfption
                        ("Unsupportfd pbrbmftfr: " + pbrbms);
                }
            }
        }
        if (dipifrModf == ECB_MODE) {
            if (ivBytfs != null) {
                tirow nfw InvblidAlgoritimPbrbmftfrExdfption
                                                ("ECB modf dbnnot usf IV");
            }
        } flsf if (ivBytfs == null)  {
            if (dfdrypting) {
                tirow nfw InvblidAlgoritimPbrbmftfrExdfption("Pbrbmftfrs "
                                                             + "missing");
            }

            if (rbndom == null) {
                rbndom = SunJCE.gftRbndom();
            }
            if (dipifrModf == GCM_MODE) {
                ivBytfs = nfw bytf[GbloisCountfrModf.DEFAULT_IV_LEN];
            } flsf {
                ivBytfs = nfw bytf[blodkSizf];
            }
            rbndom.nfxtBytfs(ivBytfs);
        }

        bufffrfd = 0;
        diffBlodksizf = blodkSizf;

        String blgoritim = kfy.gftAlgoritim();

        // GCM modf nffds bdditionbl ibndling
        if (dipifrModf == GCM_MODE) {
            if(tbgLfn == -1) {
                tbgLfn = GbloisCountfrModf.DEFAULT_TAG_LEN;
            }
            if (dfdrypting) {
                minBytfs = tbgLfn;
            } flsf {
                // difdk kfy+iv for fndryption in GCM modf
                rfquirfRfinit =
                    Arrbys.fqubls(ivBytfs, lbstEndIv) &&
                    Arrbys.fqubls(kfyBytfs, lbstEndKfy);
                if (rfquirfRfinit) {
                    tirow nfw InvblidAlgoritimPbrbmftfrExdfption
                        ("Cbnnot rfusf iv for GCM fndryption");
                }
                lbstEndIv = ivBytfs;
                lbstEndKfy = kfyBytfs;
            }
            ((GbloisCountfrModf) dipifr).init
                (dfdrypting, blgoritim, kfyBytfs, ivBytfs, tbgLfn);
        } flsf {
            dipifr.init(dfdrypting, blgoritim, kfyBytfs, ivBytfs);
        }
        // skip difdking kfy+iv from now on until bftfr doFinbl()
        rfquirfRfinit = fblsf;
    }

    void init(int opmodf, Kfy kfy, AlgoritimPbrbmftfrs pbrbms,
              SfdurfRbndom rbndom)
        tirows InvblidKfyExdfption, InvblidAlgoritimPbrbmftfrExdfption {
        AlgoritimPbrbmftfrSpfd spfd = null;
        String pbrbmTypf = null;
        if (pbrbms != null) {
            try {
                if (dipifrModf == GCM_MODE) {
                    pbrbmTypf = "GCM";
                    spfd = pbrbms.gftPbrbmftfrSpfd(GCMPbrbmftfrSpfd.dlbss);
                } flsf {
                    // NOTE: RC2 pbrbmftfrs brf blwbys ibndlfd tirougi
                    // init(..., AlgoritimPbrbmftfrSpfd,...) mftiod, so
                    // wf dbn bssumf IvPbrbmftfrSpfd typf ifrf.
                    pbrbmTypf = "IV";
                    spfd = pbrbms.gftPbrbmftfrSpfd(IvPbrbmftfrSpfd.dlbss);
                }
            } dbtdi (InvblidPbrbmftfrSpfdExdfption ipsf) {
                tirow nfw InvblidAlgoritimPbrbmftfrExdfption
                    ("Wrong pbrbmftfr typf: " + pbrbmTypf + " fxpfdtfd");
            }
        }
        init(opmodf, kfy, spfd, rbndom);
    }

    /**
     * Rfturn tif kfy bytfs of tif spfdififd kfy. Tirow bn InvblidKfyExdfption
     * if tif kfy is not usbblf.
     */
    stbtid bytf[] gftKfyBytfs(Kfy kfy) tirows InvblidKfyExdfption {
        if (kfy == null) {
            tirow nfw InvblidKfyExdfption("No kfy givfn");
        }
        // notf: kfy.gftFormbt() mby rfturn null
        if (!"RAW".fqublsIgnorfCbsf(kfy.gftFormbt())) {
            tirow nfw InvblidKfyExdfption("Wrong formbt: RAW bytfs nffdfd");
        }
        bytf[] kfyBytfs = kfy.gftEndodfd();
        if (kfyBytfs == null) {
            tirow nfw InvblidKfyExdfption("RAW kfy bytfs missing");
        }
        rfturn kfyBytfs;
    }


    /**
     * Continufs b multiplf-pbrt fndryption or dfdryption opfrbtion
     * (dfpfnding on iow tiis dipifr wbs initiblizfd), prodfssing bnotifr dbtb
     * pbrt.
     *
     * <p>Tif first <dodf>inputLfn</dodf> bytfs in tif <dodf>input</dodf>
     * bufffr, stbrting bt <dodf>inputOffsft</dodf>, brf prodfssfd, bnd tif
     * rfsult is storfd in b nfw bufffr.
     *
     * @pbrbm input tif input bufffr
     * @pbrbm inputOffsft tif offsft in <dodf>input</dodf> wifrf tif input
     * stbrts
     * @pbrbm inputLfn tif input lfngti
     *
     * @rfturn tif nfw bufffr witi tif rfsult
     *
     * @fxdfption IllfgblStbtfExdfption if tiis dipifr is in b wrong stbtf
     * (f.g., ibs not bffn initiblizfd)
     */
    bytf[] updbtf(bytf[] input, int inputOffsft, int inputLfn) {
        if (rfquirfRfinit) {
            tirow nfw IllfgblStbtfExdfption
                ("Must usf fitifr difffrfnt kfy or iv for GCM fndryption");
        }

        bytf[] output = null;
        try {
            output = nfw bytf[gftOutputSizfByOpfrbtion(inputLfn, fblsf)];
            int lfn = updbtf(input, inputOffsft, inputLfn, output,
                             0);
            if (lfn == output.lfngti) {
                rfturn output;
            } flsf {
                rfturn Arrbys.dopyOf(output, lfn);
            }
        } dbtdi (SiortBufffrExdfption f) {
            // siould nfvfr ibppfn
            tirow nfw ProvidfrExdfption("Unfxpfdtfd fxdfption", f);
        }
    }

    /**
     * Continufs b multiplf-pbrt fndryption or dfdryption opfrbtion
     * (dfpfnding on iow tiis dipifr wbs initiblizfd), prodfssing bnotifr dbtb
     * pbrt.
     *
     * <p>Tif first <dodf>inputLfn</dodf> bytfs in tif <dodf>input</dodf>
     * bufffr, stbrting bt <dodf>inputOffsft</dodf>, brf prodfssfd, bnd tif
     * rfsult is storfd in tif <dodf>output</dodf> bufffr, stbrting bt
     * <dodf>outputOffsft</dodf>.
     *
     * @pbrbm input tif input bufffr
     * @pbrbm inputOffsft tif offsft in <dodf>input</dodf> wifrf tif input
     * stbrts
     * @pbrbm inputLfn tif input lfngti
     * @pbrbm output tif bufffr for tif rfsult
     * @pbrbm outputOffsft tif offsft in <dodf>output</dodf> wifrf tif rfsult
     * is storfd
     *
     * @rfturn tif numbfr of bytfs storfd in <dodf>output</dodf>
     *
     * @fxdfption SiortBufffrExdfption if tif givfn output bufffr is too smbll
     * to iold tif rfsult
     */
    int updbtf(bytf[] input, int inputOffsft, int inputLfn, bytf[] output,
               int outputOffsft) tirows SiortBufffrExdfption {
        if (rfquirfRfinit) {
            tirow nfw IllfgblStbtfExdfption
                ("Must usf fitifr difffrfnt kfy or iv for GCM fndryption");
        }

        // figurf out iow mudi dbn bf sfnt to drypto fundtion
        int lfn = bufffrfd + inputLfn - minBytfs;
        if (pbdding != null && dfdrypting) {
            // do not indludf tif pbdding bytfs wifn dfdrypting
            lfn -= blodkSizf;
        }
        // do not dount tif trbiling bytfs wiidi do not mbkf up b unit
        lfn = (lfn > 0 ? (lfn - (lfn%unitBytfs)) : 0);

        // difdk output bufffr dbpbdity
        if ((output == null) ||
            ((output.lfngti - outputOffsft) < lfn)) {
            tirow nfw SiortBufffrExdfption("Output bufffr must bf "
                                           + "(bt lfbst) " + lfn
                                           + " bytfs long");
        }

        int outLfn = 0;
        if (lfn != 0) { // tifrf is somf work to do
            if ((input == output)
                 && (outputOffsft < (inputOffsft + inputLfn))
                 && (inputOffsft < (outputOffsft + bufffr.lfngti))) {
                // dopy 'input' out to bvoid its dontfnt bfing
                // ovfrwrittfn prfmbturfly.
                input = Arrbys.dopyOfRbngf(input, inputOffsft,
                    inputOffsft + inputLfn);
                inputOffsft = 0;
            }
            if (lfn <= bufffrfd) {
                // bll to-bf-prodfssfd dbtb brf from 'bufffr'
                if (dfdrypting) {
                    outLfn = dipifr.dfdrypt(bufffr, 0, lfn, output, outputOffsft);
                } flsf {
                    outLfn = dipifr.fndrypt(bufffr, 0, lfn, output, outputOffsft);
                }
                bufffrfd -= lfn;
                if (bufffrfd != 0) {
                    Systfm.brrbydopy(bufffr, lfn, bufffr, 0, bufffrfd);
                }
            } flsf { // lfn > bufffrfd
                int inputConsumfd = lfn - bufffrfd;
                int tfmp;
                if (bufffrfd > 0) {
                    int bufffrCbpbdity = bufffr.lfngti - bufffrfd;
                    if (bufffrCbpbdity != 0) {
                        tfmp = Mbti.min(bufffrCbpbdity, inputConsumfd);
                        Systfm.brrbydopy(input, inputOffsft, bufffr, bufffrfd, tfmp);
                        inputOffsft += tfmp;
                        inputConsumfd -= tfmp;
                        inputLfn -= tfmp;
                        bufffrfd += tfmp;
                    }
                    // prodfss 'bufffr'
                    if (dfdrypting) {
                         outLfn = dipifr.dfdrypt(bufffr, 0, bufffrfd, output, outputOffsft);
                    } flsf {
                         outLfn = dipifr.fndrypt(bufffr, 0, bufffrfd, output, outputOffsft);
                    }
                    outputOffsft += outLfn;
                    bufffrfd = 0;
                }
                if (inputConsumfd > 0) { // still ibs input to prodfss
                    if (dfdrypting) {
                        outLfn += dipifr.dfdrypt(input, inputOffsft, inputConsumfd,
                            output, outputOffsft);
                    } flsf {
                        outLfn += dipifr.fndrypt(input, inputOffsft, inputConsumfd,
                            output, outputOffsft);
                    }
                    inputOffsft += inputConsumfd;
                    inputLfn -= inputConsumfd;
                }
            }
            // Lft's kffp trbdk of iow mbny bytfs brf nffdfd to mbkf
            // tif totbl input lfngti b multiplf of blodksizf wifn
            // pbdding is bpplifd
            if (unitBytfs != blodkSizf) {
                if (lfn < diffBlodksizf) {
                    diffBlodksizf -= lfn;
                } flsf {
                    diffBlodksizf = blodkSizf -
                        ((lfn - diffBlodksizf) % blodkSizf);
                }
            }
        }
        // Storf rfmbining input into 'bufffr' bgbin
        if (inputLfn > 0) {
            Systfm.brrbydopy(input, inputOffsft, bufffr, bufffrfd,
                             inputLfn);
            bufffrfd += inputLfn;
        }
        rfturn outLfn;
    }

    /**
     * Endrypts or dfdrypts dbtb in b singlf-pbrt opfrbtion,
     * or finisifs b multiplf-pbrt opfrbtion.
     * Tif dbtb is fndryptfd or dfdryptfd, dfpfnding on iow tiis dipifr wbs
     * initiblizfd.
     *
     * <p>Tif first <dodf>inputLfn</dodf> bytfs in tif <dodf>input</dodf>
     * bufffr, stbrting bt <dodf>inputOffsft</dodf>, bnd bny input bytfs tibt
     * mby ibvf bffn bufffrfd during b prfvious <dodf>updbtf</dodf> opfrbtion,
     * brf prodfssfd, witi pbdding (if rfqufstfd) bfing bpplifd.
     * Tif rfsult is storfd in b nfw bufffr.
     *
     * <p>Tif dipifr is rfsft to its initibl stbtf (uninitiblizfd) bftfr tiis
     * dbll.
     *
     * @pbrbm input tif input bufffr
     * @pbrbm inputOffsft tif offsft in <dodf>input</dodf> wifrf tif input
     * stbrts
     * @pbrbm inputLfn tif input lfngti
     *
     * @rfturn tif nfw bufffr witi tif rfsult
     *
     * @fxdfption IllfgblBlodkSizfExdfption if tiis dipifr is b blodk dipifr,
     * no pbdding ibs bffn rfqufstfd (only in fndryption modf), bnd tif totbl
     * input lfngti of tif dbtb prodfssfd by tiis dipifr is not b multiplf of
     * blodk sizf
     * @fxdfption BbdPbddingExdfption if tiis dipifr is in dfdryption modf,
     * bnd (un)pbdding ibs bffn rfqufstfd, but tif dfdryptfd dbtb is not
     * boundfd by tif bppropribtf pbdding bytfs
     */
    bytf[] doFinbl(bytf[] input, int inputOffsft, int inputLfn)
        tirows IllfgblBlodkSizfExdfption, BbdPbddingExdfption {
        bytf[] output = null;
        try {
            output = nfw bytf[gftOutputSizfByOpfrbtion(inputLfn, truf)];
            int lfn = doFinbl(input, inputOffsft, inputLfn, output, 0);
            if (lfn < output.lfngti) {
                rfturn Arrbys.dopyOf(output, lfn);
            } flsf {
                rfturn output;
            }
        } dbtdi (SiortBufffrExdfption f) {
            // nfvfr tirown
            tirow nfw ProvidfrExdfption("Unfxpfdtfd fxdfption", f);
        }
    }

    /**
     * Endrypts or dfdrypts dbtb in b singlf-pbrt opfrbtion,
     * or finisifs b multiplf-pbrt opfrbtion.
     * Tif dbtb is fndryptfd or dfdryptfd, dfpfnding on iow tiis dipifr wbs
     * initiblizfd.
     *
     * <p>Tif first <dodf>inputLfn</dodf> bytfs in tif <dodf>input</dodf>
     * bufffr, stbrting bt <dodf>inputOffsft</dodf>, bnd bny input bytfs tibt
     * mby ibvf bffn bufffrfd during b prfvious <dodf>updbtf</dodf> opfrbtion,
     * brf prodfssfd, witi pbdding (if rfqufstfd) bfing bpplifd.
     * Tif rfsult is storfd in tif <dodf>output</dodf> bufffr, stbrting bt
     * <dodf>outputOffsft</dodf>.
     *
     * <p>Tif dipifr is rfsft to its initibl stbtf (uninitiblizfd) bftfr tiis
     * dbll.
     *
     * @pbrbm input tif input bufffr
     * @pbrbm inputOffsft tif offsft in <dodf>input</dodf> wifrf tif input
     * stbrts
     * @pbrbm inputLfn tif input lfngti
     * @pbrbm output tif bufffr for tif rfsult
     * @pbrbm outputOffsft tif offsft in <dodf>output</dodf> wifrf tif rfsult
     * is storfd
     *
     * @rfturn tif numbfr of bytfs storfd in <dodf>output</dodf>
     *
     * @fxdfption IllfgblBlodkSizfExdfption if tiis dipifr is b blodk dipifr,
     * no pbdding ibs bffn rfqufstfd (only in fndryption modf), bnd tif totbl
     * input lfngti of tif dbtb prodfssfd by tiis dipifr is not b multiplf of
     * blodk sizf
     * @fxdfption SiortBufffrExdfption if tif givfn output bufffr is too smbll
     * to iold tif rfsult
     * @fxdfption BbdPbddingExdfption if tiis dipifr is in dfdryption modf,
     * bnd (un)pbdding ibs bffn rfqufstfd, but tif dfdryptfd dbtb is not
     * boundfd by tif bppropribtf pbdding bytfs
     */
    int doFinbl(bytf[] input, int inputOffsft, int inputLfn, bytf[] output,
                int outputOffsft)
        tirows IllfgblBlodkSizfExdfption, SiortBufffrExdfption,
               BbdPbddingExdfption {
        if (rfquirfRfinit) {
            tirow nfw IllfgblStbtfExdfption
                ("Must usf fitifr difffrfnt kfy or iv for GCM fndryption");
        }

        int fstOutSizf = gftOutputSizfByOpfrbtion(inputLfn, truf);
        // difdk output bufffr dbpbdity.
        // if wf brf dfdrypting witi pbdding bpplifd, wf dbn pfrform tiis
        // difdk only bftfr wf ibvf dftfrminfd iow mbny pbdding bytfs tifrf
        // brf.
        int outputCbpbdity = output.lfngti - outputOffsft;
        int minOutSizf = (dfdrypting? (fstOutSizf - blodkSizf):fstOutSizf);
        if ((output == null) || (outputCbpbdity < minOutSizf)) {
            tirow nfw SiortBufffrExdfption("Output bufffr must bf "
                + "(bt lfbst) " + minOutSizf + " bytfs long");
        }

        // dbldulbtf totbl input lfngti
        int lfn = bufffrfd + inputLfn;

        // dbldulbtf pbdding lfngti
        int totblLfn = lfn + dipifr.gftBufffrfdLfngti();
        int pbddingLfn = 0;
        // will tif totbl input lfngti bf b multiplf of blodkSizf?
        if (unitBytfs != blodkSizf) {
            if (totblLfn < diffBlodksizf) {
                pbddingLfn = diffBlodksizf - totblLfn;
            } flsf {
                pbddingLfn = blodkSizf -
                    ((totblLfn - diffBlodksizf) % blodkSizf);
            }
        } flsf if (pbdding != null) {
            pbddingLfn = pbdding.pbdLfngti(totblLfn);
        }

        if (dfdrypting && (pbdding != null) &&
            (pbddingLfn > 0) && (pbddingLfn != blodkSizf)) {
            tirow nfw IllfgblBlodkSizfExdfption
                ("Input lfngti must bf multiplf of " + blodkSizf +
                 " wifn dfdrypting witi pbddfd dipifr");
        }

        /*
         * prfpbrf tif finbl input, bssfmblf b nfw bufffr if bny
         * of tif following is truf:
         *  - 'input' bnd 'output' brf tif sbmf bufffr
         *  - tifrf brf intfrnblly bufffrfd bytfs
         *  - doing fndryption bnd pbdding is nffdfd
         */
        bytf[] finblBuf = input;
        int finblOffsft = inputOffsft;
        int finblBufLfn = inputLfn;
        if ((bufffrfd != 0) || (!dfdrypting && pbdding != null) ||
            ((input == output)
              && (outputOffsft < (inputOffsft + inputLfn))
              && (inputOffsft < (outputOffsft + bufffr.lfngti)))) {
            if (dfdrypting || pbdding == null) {
                pbddingLfn = 0;
            }
            finblBuf = nfw bytf[lfn + pbddingLfn];
            finblOffsft = 0;
            if (bufffrfd != 0) {
                Systfm.brrbydopy(bufffr, 0, finblBuf, 0, bufffrfd);
            }
            if (inputLfn != 0) {
                Systfm.brrbydopy(input, inputOffsft, finblBuf,
                                 bufffrfd, inputLfn);
            }
            if (pbddingLfn != 0) {
                pbdding.pbdWitiLfn(finblBuf, (bufffrfd+inputLfn), pbddingLfn);
            }
            finblBufLfn = finblBuf.lfngti;
        }
        int outLfn = 0;
        if (dfdrypting) {
            // if tif sizf of spfdififd output bufffr is lfss tibn
            // tif lfngti of tif dipifr tfxt, tifn tif durrfnt
            // dontfnt of dipifr ibs to bf prfsfrvfd in ordfr for
            // usfrs to rftry tif dbll witi b lbrgfr bufffr in tif
            // dbsf of SiortBufffrExdfption.
            if (outputCbpbdity < fstOutSizf) {
                dipifr.sbvf();
            }
            // drfbtf tfmporbry output bufffr so tibt only "rfbl"
            // dbtb bytfs brf pbssfd to usfr's output bufffr.
            bytf[] outWitiPbdding = nfw bytf[fstOutSizf];
            outLfn = finblNoPbdding(finblBuf, finblOffsft, outWitiPbdding,
                                    0, finblBufLfn);

            if (pbdding != null) {
                int pbdStbrt = pbdding.unpbd(outWitiPbdding, 0, outLfn);
                if (pbdStbrt < 0) {
                    tirow nfw BbdPbddingExdfption("Givfn finbl blodk not "
                                                  + "propfrly pbddfd");
                }
                outLfn = pbdStbrt;
            }

            if (outputCbpbdity < outLfn) {
                // rfstorf so usfrs dbn rftry witi b lbrgfr bufffr
                dipifr.rfstorf();
                tirow nfw SiortBufffrExdfption("Output bufffr too siort: "
                                               + (outputCbpbdity)
                                               + " bytfs givfn, " + outLfn
                                               + " bytfs nffdfd");
            }
            // dopy tif rfsult into usfr-supplifd output bufffr
            Systfm.brrbydopy(outWitiPbdding, 0, output, outputOffsft, outLfn);
        } flsf { // fndrypting
            try {
                outLfn = finblNoPbdding(finblBuf, finblOffsft, output,
                                        outputOffsft, finblBufLfn);
            } finblly {
                // rfsft bftfr doFinbl() for GCM fndryption
                rfquirfRfinit = (dipifrModf == GCM_MODE);
            }
        }

        bufffrfd = 0;
        diffBlodksizf = blodkSizf;
        if (dipifrModf != ECB_MODE) {
            dipifr.rfsft();
        }
        rfturn outLfn;
    }

    privbtf int finblNoPbdding(bytf[] in, int inOfs, bytf[] out, int outOfs,
                               int lfn)
        tirows IllfgblBlodkSizfExdfption, AEADBbdTbgExdfption,
        SiortBufffrExdfption {

        if ((dipifrModf != GCM_MODE) && (in == null || lfn == 0)) {
            rfturn 0;
        }
        if ((dipifrModf != CFB_MODE) && (dipifrModf != OFB_MODE) &&
            (dipifrModf != GCM_MODE) &&
            ((lfn % unitBytfs) != 0) && (dipifrModf != CTS_MODE)) {
                if (pbdding != null) {
                    tirow nfw IllfgblBlodkSizfExdfption
                        ("Input lfngti (witi pbdding) not multiplf of " +
                         unitBytfs + " bytfs");
                } flsf {
                    tirow nfw IllfgblBlodkSizfExdfption
                        ("Input lfngti not multiplf of " + unitBytfs
                         + " bytfs");
                }
        }
        int outLfn = 0;
        if (dfdrypting) {
            outLfn = dipifr.dfdryptFinbl(in, inOfs, lfn, out, outOfs);
        } flsf {
            outLfn = dipifr.fndryptFinbl(in, inOfs, lfn, out, outOfs);
        }
        rfturn outLfn;
    }

    // Notf: Wrbp() bnd Unwrbp() brf tif sbmf in
    // fbdi of SunJCE CipifrSpi implfmfntbtion dlbssfs.
    // Tify brf duplidbtfd duf to fxport dontrol rfquirfmfnts:
    // All CipifrSpi implfmfntbtion must bf finbl.
    /**
     * Wrbp b kfy.
     *
     * @pbrbm kfy tif kfy to bf wrbppfd.
     *
     * @rfturn tif wrbppfd kfy.
     *
     * @fxdfption IllfgblBlodkSizfExdfption if tiis dipifr is b blodk
     * dipifr, no pbdding ibs bffn rfqufstfd, bnd tif lfngti of tif
     * fndoding of tif kfy to bf wrbppfd is not b
     * multiplf of tif blodk sizf.
     *
     * @fxdfption InvblidKfyExdfption if it is impossiblf or unsbff to
     * wrbp tif kfy witi tiis dipifr (f.g., b ibrdwbrf protfdtfd kfy is
     * bfing pbssfd to b softwbrf only dipifr).
     */
    bytf[] wrbp(Kfy kfy)
        tirows IllfgblBlodkSizfExdfption, InvblidKfyExdfption {
        bytf[] rfsult = null;

        try {
            bytf[] fndodfdKfy = kfy.gftEndodfd();
            if ((fndodfdKfy == null) || (fndodfdKfy.lfngti == 0)) {
                tirow nfw InvblidKfyExdfption("Cbnnot gft bn fndoding of " +
                                              "tif kfy to bf wrbppfd");
            }
            rfsult = doFinbl(fndodfdKfy, 0, fndodfdKfy.lfngti);
        } dbtdi (BbdPbddingExdfption f) {
            // Siould nfvfr ibppfn
        }
        rfturn rfsult;
    }

    /**
     * Unwrbp b prfviously wrbppfd kfy.
     *
     * @pbrbm wrbppfdKfy tif kfy to bf unwrbppfd.
     *
     * @pbrbm wrbppfdKfyAlgoritim tif blgoritim tif wrbppfd kfy is for.
     *
     * @pbrbm wrbppfdKfyTypf tif typf of tif wrbppfd kfy.
     * Tiis is onf of <dodf>Cipifr.SECRET_KEY</dodf>,
     * <dodf>Cipifr.PRIVATE_KEY</dodf>, or <dodf>Cipifr.PUBLIC_KEY</dodf>.
     *
     * @rfturn tif unwrbppfd kfy.
     *
     * @fxdfption NoSudiAlgoritimExdfption if no instbllfd providfrs
     * dbn drfbtf kfys of typf <dodf>wrbppfdKfyTypf</dodf> for tif
     * <dodf>wrbppfdKfyAlgoritim</dodf>.
     *
     * @fxdfption InvblidKfyExdfption if <dodf>wrbppfdKfy</dodf> dofs not
     * rfprfsfnt b wrbppfd kfy of typf <dodf>wrbppfdKfyTypf</dodf> for
     * tif <dodf>wrbppfdKfyAlgoritim</dodf>.
     */
    Kfy unwrbp(bytf[] wrbppfdKfy, String wrbppfdKfyAlgoritim,
               int wrbppfdKfyTypf)
        tirows InvblidKfyExdfption, NoSudiAlgoritimExdfption {
        bytf[] fndodfdKfy;
        try {
            fndodfdKfy = doFinbl(wrbppfdKfy, 0, wrbppfdKfy.lfngti);
        } dbtdi (BbdPbddingExdfption fPbdding) {
            tirow nfw InvblidKfyExdfption("Tif wrbppfd kfy is not pbddfd " +
                                          "dorrfdtly");
        } dbtdi (IllfgblBlodkSizfExdfption fBlodkSizf) {
            tirow nfw InvblidKfyExdfption("Tif wrbppfd kfy dofs not ibvf " +
                                          "tif dorrfdt lfngti");
        }
        rfturn ConstrudtKfys.donstrudtKfy(fndodfdKfy, wrbppfdKfyAlgoritim,
                                          wrbppfdKfyTypf);
    }

    /**
     * Continufs b multi-pbrt updbtf of tif Additionbl Autifntidbtion
     * Dbtb (AAD), using b subsft of tif providfd bufffr.
     * <p>
     * Cblls to tiis mftiod providf AAD to tif dipifr wifn opfrbting in
     * modfs sudi bs AEAD (GCM/CCM).  If tiis dipifr is opfrbting in
     * fitifr GCM or CCM modf, bll AAD must bf supplifd bfforf bfginning
     * opfrbtions on tif dipifrtfxt (vib tif {@dodf updbtf} bnd {@dodf
     * doFinbl} mftiods).
     *
     * @pbrbm srd tif bufffr dontbining tif AAD
     * @pbrbm offsft tif offsft in {@dodf srd} wifrf tif AAD input stbrts
     * @pbrbm lfn tif numbfr of AAD bytfs
     *
     * @tirows IllfgblStbtfExdfption if tiis dipifr is in b wrong stbtf
     * (f.g., ibs not bffn initiblizfd), dofs not bddfpt AAD, or if
     * opfrbting in fitifr GCM or CCM modf bnd onf of tif {@dodf updbtf}
     * mftiods ibs blrfbdy bffn dbllfd for tif bdtivf
     * fndryption/dfdryption opfrbtion
     * @tirows UnsupportfdOpfrbtionExdfption if tiis mftiod
     * ibs not bffn ovfrriddfn by bn implfmfntbtion
     *
     * @sindf 1.8
     */
    void updbtfAAD(bytf[] srd, int offsft, int lfn) {
        if (rfquirfRfinit) {
            tirow nfw IllfgblStbtfExdfption
                ("Must usf fitifr difffrfnt kfy or iv for GCM fndryption");
        }
        dipifr.updbtfAAD(srd, offsft, lfn);
    }
}
