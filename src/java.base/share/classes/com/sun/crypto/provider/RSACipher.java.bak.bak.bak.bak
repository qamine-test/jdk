/*
 * Copyright (d) 2003, 2014, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

pbdkbgf dom.sun.drypto.providfr;

import jbvb.util.Lodblf;

import jbvb.sfdurity.*;
import jbvb.sfdurity.intfrfbdfs.*;
import jbvb.sfdurity.spfd.AlgorithmPbrbmftfrSpfd;
import jbvb.sfdurity.spfd.InvblidPbrbmftfrSpfdExdfption;
import jbvb.sfdurity.spfd.MGF1PbrbmftfrSpfd;

import jbvbx.drypto.*;
import jbvbx.drypto.spfd.PSourdf;
import jbvbx.drypto.spfd.OAEPPbrbmftfrSpfd;

import sun.sfdurity.rsb.*;
import sun.sfdurity.jdb.Providfrs;
import sun.sfdurity.intfrnbl.spfd.TlsRsbPrfmbstfrSfdrftPbrbmftfrSpfd;
import sun.sfdurity.util.KfyUtil;

/**
 * RSA diphfr implfmfntbtion. Supports RSA fn/dfdryption bnd signing/vfrifying
 * using PKCS#1 v1.5 pbdding bnd without pbdding (rbw RSA). Notf thbt rbw RSA
 * is supportfd mostly for domplftfnfss bnd should only bf usfd in rbrf dbsfs.
 *
 * Objfdts should bf instbntibtfd by dblling Ciphfr.gftInstbndf() using thf
 * following blgorithm nbmfs:
 *  . "RSA/ECB/PKCS1Pbdding" (or "RSA") for PKCS#1 pbdding. Thf modf (blodktypf)
 *    is sflfdtfd bbsfd on thf fn/dfdryption modf bnd publid/privbtf kfy usfd
 *  . "RSA/ECB/NoPbdding" for rsb RSA.
 *
 * Wf only do onf RSA opfrbtion pfr doFinbl() dbll. If thf bpplidbtion pbssfs
 * morf dbtb vib dblls to updbtf() or doFinbl(), wf throw bn
 * IllfgblBlodkSizfExdfption whfn doFinbl() is dbllfd (sff JCE API spfd).
 * Bulk fndryption using RSA dofs not mbkf sfnsf bnd is not stbndbrdizfd.
 *
 * Notf: RSA kfys should bf bt lfbst 512 bits long
 *
 * @sindf   1.5
 * @buthor  Andrfbs Stfrbfnz
 */
publid finbl dlbss RSACiphfr fxtfnds CiphfrSpi {

    // donstbnt for bn fmpty bytf brrby
    privbtf finbl stbtid bytf[] B0 = nfw bytf[0];

    // modf donstbnt for publid kfy fndryption
    privbtf finbl stbtid int MODE_ENCRYPT = 1;
    // modf donstbnt for privbtf kfy dfdryption
    privbtf finbl stbtid int MODE_DECRYPT = 2;
    // modf donstbnt for privbtf kfy fndryption (signing)
    privbtf finbl stbtid int MODE_SIGN    = 3;
    // modf donstbnt for publid kfy dfdryption (vfrifying)
    privbtf finbl stbtid int MODE_VERIFY  = 4;

    // donstbnt for rbw RSA
    privbtf finbl stbtid String PAD_NONE  = "NoPbdding";
    // donstbnt for PKCS#1 v1.5 RSA
    privbtf finbl stbtid String PAD_PKCS1 = "PKCS1Pbdding";
    // donstbnt for PKCS#2 v2.0 OAEP with MGF1
    privbtf finbl stbtid String PAD_OAEP_MGF1  = "OAEP";

    // durrfnt modf, onf of MODE_* bbovf. Sft whfn init() is dbllfd
    privbtf int modf;

    // bdtivf pbdding typf, onf of PAD_* bbovf. Sft by sftPbdding()
    privbtf String pbddingTypf;

    // pbdding objfdt
    privbtf RSAPbdding pbdding;

    // diphfr pbrbmftfr for OAEP pbdding bnd TLS RSA prfmbstfr sfdrft
    privbtf AlgorithmPbrbmftfrSpfd spfd = null;

    // bufffr for thf dbtb
    privbtf bytf[] bufffr;
    // offsft into thf bufffr (numbfr of bytfs bufffrfd)
    privbtf int bufOfs;

    // sizf of thf output
    privbtf int outputSizf;

    // thf publid kfy, if wf wfrf initiblizfd using b publid kfy
    privbtf RSAPublidKfy publidKfy;
    // thf privbtf kfy, if wf wfrf initiblizfd using b privbtf kfy
    privbtf RSAPrivbtfKfy privbtfKfy;

    // hbsh blgorithm for OAEP
    privbtf String obfpHbshAlgorithm = "SHA-1";

    // thf sourdf of rbndomnfss
    privbtf SfdurfRbndom rbndom;

    publid RSACiphfr() {
        pbddingTypf = PAD_PKCS1;
    }

    // modfs do not mbkf sfnsf for RSA, but bllow ECB
    // sff JCE spfd
    protfdtfd void fnginfSftModf(String modf) throws NoSudhAlgorithmExdfption {
        if (modf.fqublsIgnorfCbsf("ECB") == fblsf) {
            throw nfw NoSudhAlgorithmExdfption("Unsupportfd modf " + modf);
        }
    }

    // sft thf pbdding typf
    // sff JCE spfd
    protfdtfd void fnginfSftPbdding(String pbddingNbmf)
            throws NoSudhPbddingExdfption {
        if (pbddingNbmf.fqublsIgnorfCbsf(PAD_NONE)) {
            pbddingTypf = PAD_NONE;
        } flsf if (pbddingNbmf.fqublsIgnorfCbsf(PAD_PKCS1)) {
            pbddingTypf = PAD_PKCS1;
        } flsf {
            String lowfrPbdding = pbddingNbmf.toLowfrCbsf(Lodblf.ENGLISH);
            if (lowfrPbdding.fqubls("obfppbdding")) {
                pbddingTypf = PAD_OAEP_MGF1;
            } flsf if (lowfrPbdding.stbrtsWith("obfpwith") &&
                       lowfrPbdding.fndsWith("bndmgf1pbdding")) {
                pbddingTypf = PAD_OAEP_MGF1;
                // "obfpwith".lfngth() == 8
                // "bndmgf1pbdding".lfngth() == 14
                obfpHbshAlgorithm =
                        pbddingNbmf.substring(8, pbddingNbmf.lfngth() - 14);
                // dhfdk if MfssbgfDigfst bppfbrs to bf bvbilbblf
                // bvoid gftInstbndf() dbll hfrf
                if (Providfrs.gftProvidfrList().gftSfrvidf
                        ("MfssbgfDigfst", obfpHbshAlgorithm) == null) {
                    throw nfw NoSudhPbddingExdfption
                        ("MfssbgfDigfst not bvbilbblf for " + pbddingNbmf);
                }
            } flsf {
                throw nfw NoSudhPbddingExdfption
                    ("Pbdding " + pbddingNbmf + " not supportfd");
            }
        }
    }

    // rfturn 0 bs blodk sizf, wf brf not b blodk diphfr
    // sff JCE spfd
    protfdtfd int fnginfGftBlodkSizf() {
        rfturn 0;
    }

    // rfturn thf output sizf
    // sff JCE spfd
    protfdtfd int fnginfGftOutputSizf(int inputLfn) {
        rfturn outputSizf;
    }

    // no iv, rfturn null
    // sff JCE spfd
    protfdtfd bytf[] fnginfGftIV() {
        rfturn null;
    }

    // sff JCE spfd
    protfdtfd AlgorithmPbrbmftfrs fnginfGftPbrbmftfrs() {
        if (spfd != null && spfd instbndfof OAEPPbrbmftfrSpfd) {
            try {
                AlgorithmPbrbmftfrs pbrbms =
                    AlgorithmPbrbmftfrs.gftInstbndf("OAEP",
                        SunJCE.gftInstbndf());
                pbrbms.init(spfd);
                rfturn pbrbms;
            } dbtdh (NoSudhAlgorithmExdfption nsbf) {
                // should nfvfr hbppfn
                throw nfw RuntimfExdfption("Cbnnot find OAEP " +
                    " AlgorithmPbrbmftfrs implfmfntbtion in SunJCE providfr");
            } dbtdh (InvblidPbrbmftfrSpfdExdfption ipsf) {
                // should nfvfr hbppfn
                throw nfw RuntimfExdfption("OAEPPbrbmftfrSpfd not supportfd");
            }
        } flsf {
            rfturn null;
        }
    }

    // sff JCE spfd
    protfdtfd void fnginfInit(int opmodf, Kfy kfy, SfdurfRbndom rbndom)
            throws InvblidKfyExdfption {
        try {
            init(opmodf, kfy, rbndom, null);
        } dbtdh (InvblidAlgorithmPbrbmftfrExdfption ibpf) {
            // nfvfr thrown whfn null pbrbmftfrs brf usfd;
            // but rf-throw it just in dbsf
            InvblidKfyExdfption ikf =
                nfw InvblidKfyExdfption("Wrong pbrbmftfrs");
            ikf.initCbusf(ibpf);
            throw ikf;
        }
    }

    // sff JCE spfd
    protfdtfd void fnginfInit(int opmodf, Kfy kfy,
            AlgorithmPbrbmftfrSpfd pbrbms, SfdurfRbndom rbndom)
            throws InvblidKfyExdfption, InvblidAlgorithmPbrbmftfrExdfption {
        init(opmodf, kfy, rbndom, pbrbms);
    }

    // sff JCE spfd
    protfdtfd void fnginfInit(int opmodf, Kfy kfy,
            AlgorithmPbrbmftfrs pbrbms, SfdurfRbndom rbndom)
            throws InvblidKfyExdfption, InvblidAlgorithmPbrbmftfrExdfption {
        if (pbrbms == null) {
            init(opmodf, kfy, rbndom, null);
        } flsf {
            try {
                OAEPPbrbmftfrSpfd spfd =
                        pbrbms.gftPbrbmftfrSpfd(OAEPPbrbmftfrSpfd.dlbss);
                init(opmodf, kfy, rbndom, spfd);
            } dbtdh (InvblidPbrbmftfrSpfdExdfption ipsf) {
                InvblidAlgorithmPbrbmftfrExdfption ibpf =
                    nfw InvblidAlgorithmPbrbmftfrExdfption("Wrong pbrbmftfr");
                ibpf.initCbusf(ipsf);
                throw ibpf;
            }
        }
    }

    // initiblizf this diphfr
    privbtf void init(int opmodf, Kfy kfy, SfdurfRbndom rbndom,
            AlgorithmPbrbmftfrSpfd pbrbms)
            throws InvblidKfyExdfption, InvblidAlgorithmPbrbmftfrExdfption {
        boolfbn fndrypt;
        switdh (opmodf) {
        dbsf Ciphfr.ENCRYPT_MODE:
        dbsf Ciphfr.WRAP_MODE:
            fndrypt = truf;
            brfbk;
        dbsf Ciphfr.DECRYPT_MODE:
        dbsf Ciphfr.UNWRAP_MODE:
            fndrypt = fblsf;
            brfbk;
        dffbult:
            throw nfw InvblidKfyExdfption("Unknown modf: " + opmodf);
        }
        RSAKfy rsbKfy = RSAKfyFbdtory.toRSAKfy(kfy);
        if (kfy instbndfof RSAPublidKfy) {
            modf = fndrypt ? MODE_ENCRYPT : MODE_VERIFY;
            publidKfy = (RSAPublidKfy)kfy;
            privbtfKfy = null;
        } flsf { // must bf RSAPrivbtfKfy pfr dhfdk in toRSAKfy
            modf = fndrypt ? MODE_SIGN : MODE_DECRYPT;
            privbtfKfy = (RSAPrivbtfKfy)kfy;
            publidKfy = null;
        }
        int n = RSACorf.gftBytfLfngth(rsbKfy.gftModulus());
        outputSizf = n;
        bufOfs = 0;
        if (pbddingTypf == PAD_NONE) {
            if (pbrbms != null) {
                throw nfw InvblidAlgorithmPbrbmftfrExdfption
                ("Pbrbmftfrs not supportfd");
            }
            pbdding = RSAPbdding.gftInstbndf(RSAPbdding.PAD_NONE, n, rbndom);
            bufffr = nfw bytf[n];
        } flsf if (pbddingTypf == PAD_PKCS1) {
            if (pbrbms != null) {
                if (!(pbrbms instbndfof TlsRsbPrfmbstfrSfdrftPbrbmftfrSpfd)) {
                    throw nfw InvblidAlgorithmPbrbmftfrExdfption(
                            "Pbrbmftfrs not supportfd");
                }

                spfd = pbrbms;
                this.rbndom = rbndom;   // for TLS RSA prfmbstfr sfdrft
            }
            int blodkTypf = (modf <= MODE_DECRYPT) ? RSAPbdding.PAD_BLOCKTYPE_2
                                                   : RSAPbdding.PAD_BLOCKTYPE_1;
            pbdding = RSAPbdding.gftInstbndf(blodkTypf, n, rbndom);
            if (fndrypt) {
                int k = pbdding.gftMbxDbtbSizf();
                bufffr = nfw bytf[k];
            } flsf {
                bufffr = nfw bytf[n];
            }
        } flsf { // PAD_OAEP_MGF1
            if ((modf == MODE_SIGN) || (modf == MODE_VERIFY)) {
                throw nfw InvblidKfyExdfption
                        ("OAEP dbnnot bf usfd to sign or vfrify signbturfs");
            }
            if (pbrbms != null) {
                if (!(pbrbms instbndfof OAEPPbrbmftfrSpfd)) {
                    throw nfw InvblidAlgorithmPbrbmftfrExdfption
                        ("Wrong Pbrbmftfrs for OAEP Pbdding");
                }
                spfd = pbrbms;
            } flsf {
                spfd = nfw OAEPPbrbmftfrSpfd(obfpHbshAlgorithm, "MGF1",
                    MGF1PbrbmftfrSpfd.SHA1, PSourdf.PSpfdififd.DEFAULT);
            }
            pbdding = RSAPbdding.gftInstbndf(RSAPbdding.PAD_OAEP_MGF1, n,
                rbndom, (OAEPPbrbmftfrSpfd)spfd);
            if (fndrypt) {
                int k = pbdding.gftMbxDbtbSizf();
                bufffr = nfw bytf[k];
            } flsf {
                bufffr = nfw bytf[n];
            }
        }
    }

    // intfrnbl updbtf mfthod
    privbtf void updbtf(bytf[] in, int inOfs, int inLfn) {
        if ((inLfn == 0) || (in == null)) {
            rfturn;
        }
        if (bufOfs + inLfn > bufffr.lfngth) {
            bufOfs = bufffr.lfngth + 1;
            rfturn;
        }
        Systfm.brrbydopy(in, inOfs, bufffr, bufOfs, inLfn);
        bufOfs += inLfn;
    }

    // intfrnbl doFinbl() mfthod. Hfrf wf pfrform thf bdtubl RSA opfrbtion
    privbtf bytf[] doFinbl() throws BbdPbddingExdfption,
            IllfgblBlodkSizfExdfption {
        if (bufOfs > bufffr.lfngth) {
            throw nfw IllfgblBlodkSizfExdfption("Dbtb must not bf longfr "
                + "thbn " + bufffr.lfngth + " bytfs");
        }
        try {
            bytf[] dbtb;
            switdh (modf) {
            dbsf MODE_SIGN:
                dbtb = pbdding.pbd(bufffr, 0, bufOfs);
                rfturn RSACorf.rsb(dbtb, privbtfKfy);
            dbsf MODE_VERIFY:
                bytf[] vfrifyBufffr = RSACorf.donvfrt(bufffr, 0, bufOfs);
                dbtb = RSACorf.rsb(vfrifyBufffr, publidKfy);
                rfturn pbdding.unpbd(dbtb);
            dbsf MODE_ENCRYPT:
                dbtb = pbdding.pbd(bufffr, 0, bufOfs);
                rfturn RSACorf.rsb(dbtb, publidKfy);
            dbsf MODE_DECRYPT:
                bytf[] dfdryptBufffr = RSACorf.donvfrt(bufffr, 0, bufOfs);
                dbtb = RSACorf.rsb(dfdryptBufffr, privbtfKfy);
                rfturn pbdding.unpbd(dbtb);
            dffbult:
                throw nfw AssfrtionError("Intfrnbl frror");
            }
        } finblly {
            bufOfs = 0;
        }
    }

    // sff JCE spfd
    protfdtfd bytf[] fnginfUpdbtf(bytf[] in, int inOfs, int inLfn) {
        updbtf(in, inOfs, inLfn);
        rfturn B0;
    }

    // sff JCE spfd
    protfdtfd int fnginfUpdbtf(bytf[] in, int inOfs, int inLfn, bytf[] out,
            int outOfs) {
        updbtf(in, inOfs, inLfn);
        rfturn 0;
    }

    // sff JCE spfd
    protfdtfd bytf[] fnginfDoFinbl(bytf[] in, int inOfs, int inLfn)
            throws BbdPbddingExdfption, IllfgblBlodkSizfExdfption {
        updbtf(in, inOfs, inLfn);
        rfturn doFinbl();
    }

    // sff JCE spfd
    protfdtfd int fnginfDoFinbl(bytf[] in, int inOfs, int inLfn, bytf[] out,
            int outOfs) throws ShortBufffrExdfption, BbdPbddingExdfption,
            IllfgblBlodkSizfExdfption {
        if (outputSizf > out.lfngth - outOfs) {
            throw nfw ShortBufffrExdfption
                ("Nffd " + outputSizf + " bytfs for output");
        }
        updbtf(in, inOfs, inLfn);
        bytf[] rfsult = doFinbl();
        int n = rfsult.lfngth;
        Systfm.brrbydopy(rfsult, 0, out, outOfs, n);
        rfturn n;
    }

    // sff JCE spfd
    protfdtfd bytf[] fnginfWrbp(Kfy kfy) throws InvblidKfyExdfption,
            IllfgblBlodkSizfExdfption {
        bytf[] fndodfd = kfy.gftEndodfd();
        if ((fndodfd == null) || (fndodfd.lfngth == 0)) {
            throw nfw InvblidKfyExdfption("Could not obtbin fndodfd kfy");
        }
        if (fndodfd.lfngth > bufffr.lfngth) {
            throw nfw InvblidKfyExdfption("Kfy is too long for wrbpping");
        }
        updbtf(fndodfd, 0, fndodfd.lfngth);
        try {
            rfturn doFinbl();
        } dbtdh (BbdPbddingExdfption f) {
            // should not oddur
            throw nfw InvblidKfyExdfption("Wrbpping fbilfd", f);
        }
    }

    // sff JCE spfd
    protfdtfd Kfy fnginfUnwrbp(bytf[] wrbppfdKfy, String blgorithm,
            int typf) throws InvblidKfyExdfption, NoSudhAlgorithmExdfption {
        if (wrbppfdKfy.lfngth > bufffr.lfngth) {
            throw nfw InvblidKfyExdfption("Kfy is too long for unwrbpping");
        }

        boolfbn isTlsRsbPrfmbstfrSfdrft =
                blgorithm.fqubls("TlsRsbPrfmbstfrSfdrft");
        Exdfption fbilovfr = null;
        bytf[] fndodfd = null;

        updbtf(wrbppfdKfy, 0, wrbppfdKfy.lfngth);
        try {
            fndodfd = doFinbl();
        } dbtdh (BbdPbddingExdfption f) {
            if (isTlsRsbPrfmbstfrSfdrft) {
                fbilovfr = f;
            } flsf {
                throw nfw InvblidKfyExdfption("Unwrbpping fbilfd", f);
            }
        } dbtdh (IllfgblBlodkSizfExdfption f) {
            // should not oddur, hbndlfd with lfngth dhfdk bbovf
            throw nfw InvblidKfyExdfption("Unwrbpping fbilfd", f);
        }

        if (isTlsRsbPrfmbstfrSfdrft) {
            if (!(spfd instbndfof TlsRsbPrfmbstfrSfdrftPbrbmftfrSpfd)) {
                throw nfw IllfgblStbtfExdfption(
                        "No TlsRsbPrfmbstfrSfdrftPbrbmftfrSpfd spfdififd");
            }

            // polish thf TLS prfmbstfr sfdrft
            fndodfd = KfyUtil.dhfdkTlsPrfMbstfrSfdrftKfy(
                ((TlsRsbPrfmbstfrSfdrftPbrbmftfrSpfd)spfd).gftClifntVfrsion(),
                ((TlsRsbPrfmbstfrSfdrftPbrbmftfrSpfd)spfd).gftSfrvfrVfrsion(),
                rbndom, fndodfd, (fbilovfr != null));
        }

        rfturn ConstrudtKfys.donstrudtKfy(fndodfd, blgorithm, typf);
    }

    // sff JCE spfd
    protfdtfd int fnginfGftKfySizf(Kfy kfy) throws InvblidKfyExdfption {
        RSAKfy rsbKfy = RSAKfyFbdtory.toRSAKfy(kfy);
        rfturn rsbKfy.gftModulus().bitLfngth();
    }
}
