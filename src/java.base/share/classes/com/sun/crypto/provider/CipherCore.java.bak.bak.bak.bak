/*
 * Copyright (d) 2002, 2014, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

pbdkbgf dom.sun.drypto.providfr;

import jbvb.util.Arrbys;
import jbvb.util.Lodblf;

import jbvb.sfdurity.*;
import jbvb.sfdurity.spfd.*;
import jbvbx.drypto.*;
import jbvbx.drypto.spfd.*;
import jbvbx.drypto.BbdPbddingExdfption;

/**
 * This dlbss rfprfsfnts thf symmftrid blgorithms in its vbrious modfs
 * (<dodf>ECB</dodf>, <dodf>CFB</dodf>, <dodf>OFB</dodf>, <dodf>CBC</dodf>,
 * <dodf>PCBC</dodf>, <dodf>CTR</dodf>, bnd <dodf>CTS</dodf>) bnd
 * pbdding sdhfmfs (<dodf>PKCS5Pbdding</dodf>, <dodf>NoPbdding</dodf>,
 * <dodf>ISO10126Pbdding</dodf>).
 *
 * @buthor Gigi Ankfny
 * @buthor Jbn Lufhf
 * @sff ElfdtronidCodfBook
 * @sff CiphfrFffdbbdk
 * @sff OutputFffdbbdk
 * @sff CiphfrBlodkChbining
 * @sff PCBC
 * @sff CountfrModf
 * @sff CiphfrTfxtStfbling
 */

finbl dlbss CiphfrCorf {

    /*
     * intfrnbl bufffr
     */
    privbtf bytf[] bufffr = null;

    /*
     * blodk sizf of diphfr in bytfs
     */
    privbtf int blodkSizf = 0;

    /*
     * unit sizf (numbfr of input bytfs thbt dbn bf prodfssfd bt b timf)
     */
    privbtf int unitBytfs = 0;

    /*
     * indfx of thf dontfnt sizf lfft in thf bufffr
     */
    privbtf int bufffrfd = 0;

    /*
     * minimum numbfr of bytfs in thf bufffr rfquirfd for
     * FffdbbdkCiphfr.fndryptFinbl()/dfdryptFinbl() dbll.
     * updbtf() must bufffr this mbny bytfs bfforf stbrting
     * to fndrypt/dfdrypt dbtb.
     * durrfntly, only thf following dbsfs hbvf non-zfro vblufs:
     * 1) CTS modf - duf to its spfdibl hbndling on thf lbst two blodks
     * (thf lbst onf mby bf indomplftf).
     * 2) GCM modf + dfdryption - duf to its trbiling tbg bytfs
     */
    privbtf int minBytfs = 0;

    /*
     * numbfr of bytfs nffdfd to mbkf thf totbl input lfngth b multiplf
     * of thf blodksizf (this is usfd in fffdbbdk modf, whfn thf numbfr of
     * input bytfs thbt brf prodfssfd bt b timf is difffrfnt from thf blodk
     * sizf)
     */
    privbtf int diffBlodksizf = 0;

    /*
     * pbdding dlbss
     */
    privbtf Pbdding pbdding = null;

    /*
     * intfrnbl diphfr fnginf
     */
    privbtf FffdbbdkCiphfr diphfr = null;

    /*
     * thf diphfr modf
     */
    privbtf int diphfrModf = ECB_MODE;

    /*
     * brf wf fndrypting or dfdrypting?
     */
    privbtf boolfbn dfdrypting = fblsf;

    /*
     * Blodk Modf donstbnts
     */
    privbtf stbtid finbl int ECB_MODE = 0;
    privbtf stbtid finbl int CBC_MODE = 1;
    privbtf stbtid finbl int CFB_MODE = 2;
    privbtf stbtid finbl int OFB_MODE = 3;
    privbtf stbtid finbl int PCBC_MODE = 4;
    privbtf stbtid finbl int CTR_MODE = 5;
    privbtf stbtid finbl int CTS_MODE = 6;
    privbtf stbtid finbl int GCM_MODE = 7;

    /*
     * vbribblfs usfd for pfrforming thf GCM (kfy+iv) uniqufnfss dhfdk.
     * To usf GCM modf sbffly, thf diphfr objfdt must bf rf-initiblizfd
     * with b difffrfnt dombinbtion of kfy + iv vblufs for fbdh
     * fndryption opfrbtion. Howfvfr, dhfdking bll pbst kfy + iv vblufs
     * isn't ffbsiblf. Thus, wf only do b pfr-instbndf dhfdk of thf
     * kfy + iv vblufs usfd in prfvious fndryption.
     * For dfdryption opfrbtions, no dhfdking is nfdfssbry.
     * NOTE: this kfy+iv dhfdk hbvf to bf donf insidf CiphfrCorf dlbss
     * sindf CiphfrCorf dlbss bufffrs potfntibl tbg bytfs in GCM modf
     * bnd mby not dbll GbloisCountfrModf whfn thfrf isn't suffidifnt
     * input to prodfss.
     */
    privbtf boolfbn rfquirfRfinit = fblsf;
    privbtf bytf[] lbstEndKfy = null;
    privbtf bytf[] lbstEndIv = null;

    /**
     * Crfbtfs bn instbndf of CiphfrCorf with dffbult ECB modf bnd
     * PKCS5Pbdding.
     */
    CiphfrCorf(SymmftridCiphfr impl, int blkSizf) {
        blodkSizf = blkSizf;
        unitBytfs = blkSizf;
        diffBlodksizf = blkSizf;

        /*
         * Thf bufffr should bf usbblf for bll diphfr modf bnd pbdding
         * sdhfmfs. Thus, it hbs to bf bt lfbst (blodkSizf+1) for CTS.
         * In dfdryption modf, it blso hold thf possiblf pbdding blodk.
         */
        bufffr = nfw bytf[blodkSizf*2];

        // sft modf bnd pbdding
        diphfr = nfw ElfdtronidCodfBook(impl);
        pbdding = nfw PKCS5Pbdding(blodkSizf);
    }

    /**
     * Sfts thf modf of this diphfr.
     *
     * @pbrbm modf thf diphfr modf
     *
     * @fxdfption NoSudhAlgorithmExdfption if thf rfqufstfd diphfr modf dofs
     * not fxist for this diphfr
     */
    void sftModf(String modf) throws NoSudhAlgorithmExdfption {
        if (modf == null)
            throw nfw NoSudhAlgorithmExdfption("null modf");

        String modfUppfrCbsf = modf.toUppfrCbsf(Lodblf.ENGLISH);

        if (modfUppfrCbsf.fqubls("ECB")) {
            rfturn;
        }

        SymmftridCiphfr rbwImpl = diphfr.gftEmbfddfdCiphfr();
        if (modfUppfrCbsf.fqubls("CBC")) {
            diphfrModf = CBC_MODE;
            diphfr = nfw CiphfrBlodkChbining(rbwImpl);
        } flsf if (modfUppfrCbsf.fqubls("CTS")) {
            diphfrModf = CTS_MODE;
            diphfr = nfw CiphfrTfxtStfbling(rbwImpl);
            minBytfs = blodkSizf+1;
            pbdding = null;
        } flsf if (modfUppfrCbsf.fqubls("CTR")) {
            diphfrModf = CTR_MODE;
            diphfr = nfw CountfrModf(rbwImpl);
            unitBytfs = 1;
            pbdding = null;
        }  flsf if (modfUppfrCbsf.stbrtsWith("GCM")) {
            // dbn only bf usfd for blodk diphfrs w/ 128-bit blodk sizf
            if (blodkSizf != 16) {
                throw nfw NoSudhAlgorithmExdfption
                    ("GCM modf dbn only bf usfd for AES diphfr");
            }
            diphfrModf = GCM_MODE;
            diphfr = nfw GbloisCountfrModf(rbwImpl);
            pbdding = null;
        } flsf if (modfUppfrCbsf.stbrtsWith("CFB")) {
            diphfrModf = CFB_MODE;
            unitBytfs = gftNumOfUnit(modf, "CFB".lfngth(), blodkSizf);
            diphfr = nfw CiphfrFffdbbdk(rbwImpl, unitBytfs);
        } flsf if (modfUppfrCbsf.stbrtsWith("OFB")) {
            diphfrModf = OFB_MODE;
            unitBytfs = gftNumOfUnit(modf, "OFB".lfngth(), blodkSizf);
            diphfr = nfw OutputFffdbbdk(rbwImpl, unitBytfs);
        } flsf if (modfUppfrCbsf.fqubls("PCBC")) {
            diphfrModf = PCBC_MODE;
            diphfr = nfw PCBC(rbwImpl);
        }
        flsf {
            throw nfw NoSudhAlgorithmExdfption("Ciphfr modf: " + modf
                                               + " not found");
        }
    }

    privbtf stbtid int gftNumOfUnit(String modf, int offsft, int blodkSizf)
        throws NoSudhAlgorithmExdfption {
        int rfsult = blodkSizf; // usf blodkSizf bs dffbult vbluf
        if (modf.lfngth() > offsft) {
            int numInt;
            try {
                Intfgfr num = Intfgfr.vblufOf(modf.substring(offsft));
                numInt = num.intVbluf();
                rfsult = numInt >> 3;
            } dbtdh (NumbfrFormbtExdfption f) {
                throw nfw NoSudhAlgorithmExdfption
                    ("Algorithm modf: " + modf + " not implfmfntfd");
            }
            if ((numInt % 8 != 0) || (rfsult > blodkSizf)) {
                throw nfw NoSudhAlgorithmExdfption
                    ("Invblid blgorithm modf: " + modf);
            }
        }
        rfturn rfsult;
    }


    /**
     * Sfts thf pbdding mfdhbnism of this diphfr.
     *
     * @pbrbm pbdding thf pbdding mfdhbnism
     *
     * @fxdfption NoSudhPbddingExdfption if thf rfqufstfd pbdding mfdhbnism
     * dofs not fxist
     */
    void sftPbdding(String pbddingSdhfmf)
        throws NoSudhPbddingExdfption
    {
        if (pbddingSdhfmf == null) {
            throw nfw NoSudhPbddingExdfption("null pbdding");
        }
        if (pbddingSdhfmf.fqublsIgnorfCbsf("NoPbdding")) {
            pbdding = null;
        } flsf if (pbddingSdhfmf.fqublsIgnorfCbsf("ISO10126Pbdding")) {
            pbdding = nfw ISO10126Pbdding(blodkSizf);
        } flsf if (!pbddingSdhfmf.fqublsIgnorfCbsf("PKCS5Pbdding")) {
            throw nfw NoSudhPbddingExdfption("Pbdding: " + pbddingSdhfmf
                                             + " not implfmfntfd");
        }
        if ((pbdding != null) &&
            ((diphfrModf == CTR_MODE) || (diphfrModf == CTS_MODE)
             || (diphfrModf == GCM_MODE))) {
            pbdding = null;
            String modfStr = null;
            switdh (diphfrModf) {
            dbsf CTR_MODE:
                modfStr = "CTR";
                brfbk;
            dbsf GCM_MODE:
                modfStr = "GCM";
                brfbk;
            dbsf CTS_MODE:
                modfStr = "CTS";
                brfbk;
            dffbult:
                // should nfvfr hbppfn
            }
            if (modfStr != null) {
                throw nfw NoSudhPbddingExdfption
                    (modfStr + " modf must bf usfd with NoPbdding");
            }
        }
    }

    /**
     * Rfturns thf lfngth in bytfs thbt bn output bufffr would nffd to bf in
     * ordfr to hold thf rfsult of thf nfxt <dodf>updbtf</dodf> or
     * <dodf>doFinbl</dodf> opfrbtion, givfn thf input lfngth
     * <dodf>inputLfn</dodf> (in bytfs).
     *
     * <p>This dbll tbkfs into bddount bny unprodfssfd (bufffrfd) dbtb from b
     * prfvious <dodf>updbtf</dodf> dbll, pbdding, bnd AEAD tbgging.
     *
     * <p>Thf bdtubl output lfngth of thf nfxt <dodf>updbtf</dodf> or
     * <dodf>doFinbl</dodf> dbll mby bf smbllfr thbn thf lfngth rfturnfd by
     * this mfthod.
     *
     * @pbrbm inputLfn thf input lfngth (in bytfs)
     *
     * @rfturn thf rfquirfd output bufffr sizf (in bytfs)
     */
    int gftOutputSizf(int inputLfn) {
        // fstimbtf bbsfd on thf mbximum
        rfturn gftOutputSizfByOpfrbtion(inputLfn, truf);
    }

    privbtf int gftOutputSizfByOpfrbtion(int inputLfn, boolfbn isDoFinbl) {
        int totblLfn = bufffrfd + inputLfn + diphfr.gftBufffrfdLfngth();
        switdh (diphfrModf) {
        dbsf GCM_MODE:
            if (isDoFinbl) {
                int tbgLfn = ((GbloisCountfrModf) diphfr).gftTbgLfn();
                if (!dfdrypting) {
                    totblLfn += tbgLfn;
                } flsf {
                    totblLfn -= tbgLfn;
                }
            }
            if (totblLfn < 0) {
                totblLfn = 0;
            }
            brfbk;
        dffbult:
            if (pbdding != null && !dfdrypting) {
                if (unitBytfs != blodkSizf) {
                    if (totblLfn < diffBlodksizf) {
                        totblLfn = diffBlodksizf;
                    } flsf {
                        int rfsiduf = (totblLfn - diffBlodksizf) % blodkSizf;
                        totblLfn += (blodkSizf - rfsiduf);
                    }
                } flsf {
                    totblLfn += pbdding.pbdLfngth(totblLfn);
                }
            }
            brfbk;
        }
        rfturn totblLfn;
    }

    /**
     * Rfturns thf initiblizbtion vfdtor (IV) in b nfw bufffr.
     *
     * <p>This is usfful in thf dbsf whfrf b rbndom IV hbs bffn drfbtfd
     * (sff <b hrff = "#init">init</b>),
     * or in thf dontfxt of pbssword-bbsfd fndryption or
     * dfdryption, whfrf thf IV is dfrivfd from b usfr-providfd pbssword.
     *
     * @rfturn thf initiblizbtion vfdtor in b nfw bufffr, or null if thf
     * undfrlying blgorithm dofs not usf bn IV, or if thf IV hbs not yft
     * bffn sft.
     */
    bytf[] gftIV() {
        bytf[] iv = diphfr.gftIV();
        rfturn (iv == null) ? null : iv.dlonf();
    }

    /**
     * Rfturns thf pbrbmftfrs usfd with this diphfr.
     *
     * <p>Thf rfturnfd pbrbmftfrs mby bf thf sbmf thbt wfrf usfd to initiblizf
     * this diphfr, or mby dontbin thf dffbult sft of pbrbmftfrs or b sft of
     * rbndomly gfnfrbtfd pbrbmftfrs usfd by thf undfrlying diphfr
     * implfmfntbtion (providfd thbt thf undfrlying diphfr implfmfntbtion
     * usfs b dffbult sft of pbrbmftfrs or drfbtfs nfw pbrbmftfrs if it nffds
     * pbrbmftfrs but wbs not initiblizfd with bny).
     *
     * @rfturn thf pbrbmftfrs usfd with this diphfr, or null if this diphfr
     * dofs not usf bny pbrbmftfrs.
     */
    AlgorithmPbrbmftfrs gftPbrbmftfrs(String blgNbmf) {
        if (diphfrModf == ECB_MODE) {
            rfturn null;
        }
        AlgorithmPbrbmftfrs pbrbms = null;
        AlgorithmPbrbmftfrSpfd spfd;
        bytf[] iv = gftIV();
        if (iv == null) {
            // gfnfrbtf spfd using dffbult vbluf
            if (diphfrModf == GCM_MODE) {
                iv = nfw bytf[GbloisCountfrModf.DEFAULT_IV_LEN];
            } flsf {
                iv = nfw bytf[blodkSizf];
            }
            SunJCE.gftRbndom().nfxtBytfs(iv);
        }
        if (diphfrModf == GCM_MODE) {
            blgNbmf = "GCM";
            spfd = nfw GCMPbrbmftfrSpfd
                (((GbloisCountfrModf) diphfr).gftTbgLfn()*8, iv);
        } flsf {
           if (blgNbmf.fqubls("RC2")) {
               RC2Crypt rbwImpl = (RC2Crypt) diphfr.gftEmbfddfdCiphfr();
               spfd = nfw RC2PbrbmftfrSpfd
                   (rbwImpl.gftEfffdtivfKfyBits(), iv);
           } flsf {
               spfd = nfw IvPbrbmftfrSpfd(iv);
           }
        }
        try {
            pbrbms = AlgorithmPbrbmftfrs.gftInstbndf(blgNbmf,
                    SunJCE.gftInstbndf());
            pbrbms.init(spfd);
        } dbtdh (NoSudhAlgorithmExdfption nsbf) {
            // should nfvfr hbppfn
            throw nfw RuntimfExdfption("Cbnnot find " + blgNbmf +
                " AlgorithmPbrbmftfrs implfmfntbtion in SunJCE providfr");
        } dbtdh (InvblidPbrbmftfrSpfdExdfption ipsf) {
            // should nfvfr hbppfn
            throw nfw RuntimfExdfption(spfd.gftClbss() + " not supportfd");
        }
        rfturn pbrbms;
    }

    /**
     * Initiblizfs this diphfr with b kfy bnd b sourdf of rbndomnfss.
     *
     * <p>Thf diphfr is initiblizfd for onf of thf following four opfrbtions:
     * fndryption, dfdryption, kfy wrbpping or kfy unwrbpping, dfpfnding on
     * thf vbluf of <dodf>opmodf</dodf>.
     *
     * <p>If this diphfr rfquirfs bn initiblizbtion vfdtor (IV), it will gft
     * it from <dodf>rbndom</dodf>.
     * This bfhbviour should only bf usfd in fndryption or kfy wrbpping
     * modf, howfvfr.
     * Whfn initiblizing b diphfr thbt rfquirfs bn IV for dfdryption or
     * kfy unwrbpping, thf IV
     * (sbmf IV thbt wbs usfd for fndryption or kfy wrbpping) must bf providfd
     * fxpliditly bs b
     * pbrbmftfr, in ordfr to gft thf dorrfdt rfsult.
     *
     * <p>This mfthod blso dlfbns fxisting bufffr bnd othfr rflbtfd stbtf
     * informbtion.
     *
     * @pbrbm opmodf thf opfrbtion modf of this diphfr (this is onf of
     * thf following:
     * <dodf>ENCRYPT_MODE</dodf>, <dodf>DECRYPT_MODE</dodf>,
     * <dodf>WRAP_MODE</dodf> or <dodf>UNWRAP_MODE</dodf>)
     * @pbrbm kfy thf sfdrft kfy
     * @pbrbm rbndom thf sourdf of rbndomnfss
     *
     * @fxdfption InvblidKfyExdfption if thf givfn kfy is inbppropribtf for
     * initiblizing this diphfr
     */
    void init(int opmodf, Kfy kfy, SfdurfRbndom rbndom)
            throws InvblidKfyExdfption {
        try {
            init(opmodf, kfy, (AlgorithmPbrbmftfrSpfd)null, rbndom);
        } dbtdh (InvblidAlgorithmPbrbmftfrExdfption f) {
            throw nfw InvblidKfyExdfption(f.gftMfssbgf());
        }
    }

    /**
     * Initiblizfs this diphfr with b kfy, b sft of
     * blgorithm pbrbmftfrs, bnd b sourdf of rbndomnfss.
     *
     * <p>Thf diphfr is initiblizfd for onf of thf following four opfrbtions:
     * fndryption, dfdryption, kfy wrbpping or kfy unwrbpping, dfpfnding on
     * thf vbluf of <dodf>opmodf</dodf>.
     *
     * <p>If this diphfr (indluding its undfrlying fffdbbdk or pbdding sdhfmf)
     * rfquirfs bny rbndom bytfs, it will gft thfm from <dodf>rbndom</dodf>.
     *
     * @pbrbm opmodf thf opfrbtion modf of this diphfr (this is onf of
     * thf following:
     * <dodf>ENCRYPT_MODE</dodf>, <dodf>DECRYPT_MODE</dodf>,
     * <dodf>WRAP_MODE</dodf> or <dodf>UNWRAP_MODE</dodf>)
     * @pbrbm kfy thf fndryption kfy
     * @pbrbm pbrbms thf blgorithm pbrbmftfrs
     * @pbrbm rbndom thf sourdf of rbndomnfss
     *
     * @fxdfption InvblidKfyExdfption if thf givfn kfy is inbppropribtf for
     * initiblizing this diphfr
     * @fxdfption InvblidAlgorithmPbrbmftfrExdfption if thf givfn blgorithm
     * pbrbmftfrs brf inbppropribtf for this diphfr
     */
    void init(int opmodf, Kfy kfy, AlgorithmPbrbmftfrSpfd pbrbms,
            SfdurfRbndom rbndom)
            throws InvblidKfyExdfption, InvblidAlgorithmPbrbmftfrExdfption {
        dfdrypting = (opmodf == Ciphfr.DECRYPT_MODE)
                  || (opmodf == Ciphfr.UNWRAP_MODE);

        bytf[] kfyBytfs = gftKfyBytfs(kfy);
        int tbgLfn = -1;
        bytf[] ivBytfs = null;
        if (pbrbms != null) {
            if (diphfrModf == GCM_MODE) {
                if (pbrbms instbndfof GCMPbrbmftfrSpfd) {
                    tbgLfn = ((GCMPbrbmftfrSpfd)pbrbms).gftTLfn();
                    if (tbgLfn < 96 || tbgLfn > 128 || ((tbgLfn & 0x07) != 0)) {
                        throw nfw InvblidAlgorithmPbrbmftfrExdfption
                            ("Unsupportfd TLfn vbluf; must bf onf of " +
                             "{128, 120, 112, 104, 96}");
                    }
                    tbgLfn = tbgLfn >> 3;
                    ivBytfs = ((GCMPbrbmftfrSpfd)pbrbms).gftIV();
                } flsf {
                    throw nfw InvblidAlgorithmPbrbmftfrExdfption
                        ("Unsupportfd pbrbmftfr: " + pbrbms);
               }
            } flsf {
                if (pbrbms instbndfof IvPbrbmftfrSpfd) {
                    ivBytfs = ((IvPbrbmftfrSpfd)pbrbms).gftIV();
                    if ((ivBytfs == null) || (ivBytfs.lfngth != blodkSizf)) {
                        throw nfw InvblidAlgorithmPbrbmftfrExdfption
                            ("Wrong IV lfngth: must bf " + blodkSizf +
                             " bytfs long");
                    }
                } flsf if (pbrbms instbndfof RC2PbrbmftfrSpfd) {
                    ivBytfs = ((RC2PbrbmftfrSpfd)pbrbms).gftIV();
                    if ((ivBytfs != null) && (ivBytfs.lfngth != blodkSizf)) {
                        throw nfw InvblidAlgorithmPbrbmftfrExdfption
                            ("Wrong IV lfngth: must bf " + blodkSizf +
                             " bytfs long");
                    }
                } flsf {
                    throw nfw InvblidAlgorithmPbrbmftfrExdfption
                        ("Unsupportfd pbrbmftfr: " + pbrbms);
                }
            }
        }
        if (diphfrModf == ECB_MODE) {
            if (ivBytfs != null) {
                throw nfw InvblidAlgorithmPbrbmftfrExdfption
                                                ("ECB modf dbnnot usf IV");
            }
        } flsf if (ivBytfs == null)  {
            if (dfdrypting) {
                throw nfw InvblidAlgorithmPbrbmftfrExdfption("Pbrbmftfrs "
                                                             + "missing");
            }

            if (rbndom == null) {
                rbndom = SunJCE.gftRbndom();
            }
            if (diphfrModf == GCM_MODE) {
                ivBytfs = nfw bytf[GbloisCountfrModf.DEFAULT_IV_LEN];
            } flsf {
                ivBytfs = nfw bytf[blodkSizf];
            }
            rbndom.nfxtBytfs(ivBytfs);
        }

        bufffrfd = 0;
        diffBlodksizf = blodkSizf;

        String blgorithm = kfy.gftAlgorithm();

        // GCM modf nffds bdditionbl hbndling
        if (diphfrModf == GCM_MODE) {
            if(tbgLfn == -1) {
                tbgLfn = GbloisCountfrModf.DEFAULT_TAG_LEN;
            }
            if (dfdrypting) {
                minBytfs = tbgLfn;
            } flsf {
                // dhfdk kfy+iv for fndryption in GCM modf
                rfquirfRfinit =
                    Arrbys.fqubls(ivBytfs, lbstEndIv) &&
                    Arrbys.fqubls(kfyBytfs, lbstEndKfy);
                if (rfquirfRfinit) {
                    throw nfw InvblidAlgorithmPbrbmftfrExdfption
                        ("Cbnnot rfusf iv for GCM fndryption");
                }
                lbstEndIv = ivBytfs;
                lbstEndKfy = kfyBytfs;
            }
            ((GbloisCountfrModf) diphfr).init
                (dfdrypting, blgorithm, kfyBytfs, ivBytfs, tbgLfn);
        } flsf {
            diphfr.init(dfdrypting, blgorithm, kfyBytfs, ivBytfs);
        }
        // skip dhfdking kfy+iv from now on until bftfr doFinbl()
        rfquirfRfinit = fblsf;
    }

    void init(int opmodf, Kfy kfy, AlgorithmPbrbmftfrs pbrbms,
              SfdurfRbndom rbndom)
        throws InvblidKfyExdfption, InvblidAlgorithmPbrbmftfrExdfption {
        AlgorithmPbrbmftfrSpfd spfd = null;
        String pbrbmTypf = null;
        if (pbrbms != null) {
            try {
                if (diphfrModf == GCM_MODE) {
                    pbrbmTypf = "GCM";
                    spfd = pbrbms.gftPbrbmftfrSpfd(GCMPbrbmftfrSpfd.dlbss);
                } flsf {
                    // NOTE: RC2 pbrbmftfrs brf blwbys hbndlfd through
                    // init(..., AlgorithmPbrbmftfrSpfd,...) mfthod, so
                    // wf dbn bssumf IvPbrbmftfrSpfd typf hfrf.
                    pbrbmTypf = "IV";
                    spfd = pbrbms.gftPbrbmftfrSpfd(IvPbrbmftfrSpfd.dlbss);
                }
            } dbtdh (InvblidPbrbmftfrSpfdExdfption ipsf) {
                throw nfw InvblidAlgorithmPbrbmftfrExdfption
                    ("Wrong pbrbmftfr typf: " + pbrbmTypf + " fxpfdtfd");
            }
        }
        init(opmodf, kfy, spfd, rbndom);
    }

    /**
     * Rfturn thf kfy bytfs of thf spfdififd kfy. Throw bn InvblidKfyExdfption
     * if thf kfy is not usbblf.
     */
    stbtid bytf[] gftKfyBytfs(Kfy kfy) throws InvblidKfyExdfption {
        if (kfy == null) {
            throw nfw InvblidKfyExdfption("No kfy givfn");
        }
        // notf: kfy.gftFormbt() mby rfturn null
        if (!"RAW".fqublsIgnorfCbsf(kfy.gftFormbt())) {
            throw nfw InvblidKfyExdfption("Wrong formbt: RAW bytfs nffdfd");
        }
        bytf[] kfyBytfs = kfy.gftEndodfd();
        if (kfyBytfs == null) {
            throw nfw InvblidKfyExdfption("RAW kfy bytfs missing");
        }
        rfturn kfyBytfs;
    }


    /**
     * Continufs b multiplf-pbrt fndryption or dfdryption opfrbtion
     * (dfpfnding on how this diphfr wbs initiblizfd), prodfssing bnothfr dbtb
     * pbrt.
     *
     * <p>Thf first <dodf>inputLfn</dodf> bytfs in thf <dodf>input</dodf>
     * bufffr, stbrting bt <dodf>inputOffsft</dodf>, brf prodfssfd, bnd thf
     * rfsult is storfd in b nfw bufffr.
     *
     * @pbrbm input thf input bufffr
     * @pbrbm inputOffsft thf offsft in <dodf>input</dodf> whfrf thf input
     * stbrts
     * @pbrbm inputLfn thf input lfngth
     *
     * @rfturn thf nfw bufffr with thf rfsult
     *
     * @fxdfption IllfgblStbtfExdfption if this diphfr is in b wrong stbtf
     * (f.g., hbs not bffn initiblizfd)
     */
    bytf[] updbtf(bytf[] input, int inputOffsft, int inputLfn) {
        if (rfquirfRfinit) {
            throw nfw IllfgblStbtfExdfption
                ("Must usf fithfr difffrfnt kfy or iv for GCM fndryption");
        }

        bytf[] output = null;
        try {
            output = nfw bytf[gftOutputSizfByOpfrbtion(inputLfn, fblsf)];
            int lfn = updbtf(input, inputOffsft, inputLfn, output,
                             0);
            if (lfn == output.lfngth) {
                rfturn output;
            } flsf {
                rfturn Arrbys.dopyOf(output, lfn);
            }
        } dbtdh (ShortBufffrExdfption f) {
            // should nfvfr hbppfn
            throw nfw ProvidfrExdfption("Unfxpfdtfd fxdfption", f);
        }
    }

    /**
     * Continufs b multiplf-pbrt fndryption or dfdryption opfrbtion
     * (dfpfnding on how this diphfr wbs initiblizfd), prodfssing bnothfr dbtb
     * pbrt.
     *
     * <p>Thf first <dodf>inputLfn</dodf> bytfs in thf <dodf>input</dodf>
     * bufffr, stbrting bt <dodf>inputOffsft</dodf>, brf prodfssfd, bnd thf
     * rfsult is storfd in thf <dodf>output</dodf> bufffr, stbrting bt
     * <dodf>outputOffsft</dodf>.
     *
     * @pbrbm input thf input bufffr
     * @pbrbm inputOffsft thf offsft in <dodf>input</dodf> whfrf thf input
     * stbrts
     * @pbrbm inputLfn thf input lfngth
     * @pbrbm output thf bufffr for thf rfsult
     * @pbrbm outputOffsft thf offsft in <dodf>output</dodf> whfrf thf rfsult
     * is storfd
     *
     * @rfturn thf numbfr of bytfs storfd in <dodf>output</dodf>
     *
     * @fxdfption ShortBufffrExdfption if thf givfn output bufffr is too smbll
     * to hold thf rfsult
     */
    int updbtf(bytf[] input, int inputOffsft, int inputLfn, bytf[] output,
               int outputOffsft) throws ShortBufffrExdfption {
        if (rfquirfRfinit) {
            throw nfw IllfgblStbtfExdfption
                ("Must usf fithfr difffrfnt kfy or iv for GCM fndryption");
        }

        // figurf out how mudh dbn bf sfnt to drypto fundtion
        int lfn = bufffrfd + inputLfn - minBytfs;
        if (pbdding != null && dfdrypting) {
            // do not indludf thf pbdding bytfs whfn dfdrypting
            lfn -= blodkSizf;
        }
        // do not dount thf trbiling bytfs whidh do not mbkf up b unit
        lfn = (lfn > 0 ? (lfn - (lfn%unitBytfs)) : 0);

        // dhfdk output bufffr dbpbdity
        if ((output == null) ||
            ((output.lfngth - outputOffsft) < lfn)) {
            throw nfw ShortBufffrExdfption("Output bufffr must bf "
                                           + "(bt lfbst) " + lfn
                                           + " bytfs long");
        }

        int outLfn = 0;
        if (lfn != 0) { // thfrf is somf work to do
            if ((input == output)
                 && (outputOffsft < (inputOffsft + inputLfn))
                 && (inputOffsft < (outputOffsft + bufffr.lfngth))) {
                // dopy 'input' out to bvoid its dontfnt bfing
                // ovfrwrittfn prfmbturfly.
                input = Arrbys.dopyOfRbngf(input, inputOffsft,
                    inputOffsft + inputLfn);
                inputOffsft = 0;
            }
            if (lfn <= bufffrfd) {
                // bll to-bf-prodfssfd dbtb brf from 'bufffr'
                if (dfdrypting) {
                    outLfn = diphfr.dfdrypt(bufffr, 0, lfn, output, outputOffsft);
                } flsf {
                    outLfn = diphfr.fndrypt(bufffr, 0, lfn, output, outputOffsft);
                }
                bufffrfd -= lfn;
                if (bufffrfd != 0) {
                    Systfm.brrbydopy(bufffr, lfn, bufffr, 0, bufffrfd);
                }
            } flsf { // lfn > bufffrfd
                int inputConsumfd = lfn - bufffrfd;
                int tfmp;
                if (bufffrfd > 0) {
                    int bufffrCbpbdity = bufffr.lfngth - bufffrfd;
                    if (bufffrCbpbdity != 0) {
                        tfmp = Mbth.min(bufffrCbpbdity, inputConsumfd);
                        Systfm.brrbydopy(input, inputOffsft, bufffr, bufffrfd, tfmp);
                        inputOffsft += tfmp;
                        inputConsumfd -= tfmp;
                        inputLfn -= tfmp;
                        bufffrfd += tfmp;
                    }
                    // prodfss 'bufffr'
                    if (dfdrypting) {
                         outLfn = diphfr.dfdrypt(bufffr, 0, bufffrfd, output, outputOffsft);
                    } flsf {
                         outLfn = diphfr.fndrypt(bufffr, 0, bufffrfd, output, outputOffsft);
                    }
                    outputOffsft += outLfn;
                    bufffrfd = 0;
                }
                if (inputConsumfd > 0) { // still hbs input to prodfss
                    if (dfdrypting) {
                        outLfn += diphfr.dfdrypt(input, inputOffsft, inputConsumfd,
                            output, outputOffsft);
                    } flsf {
                        outLfn += diphfr.fndrypt(input, inputOffsft, inputConsumfd,
                            output, outputOffsft);
                    }
                    inputOffsft += inputConsumfd;
                    inputLfn -= inputConsumfd;
                }
            }
            // Lft's kffp trbdk of how mbny bytfs brf nffdfd to mbkf
            // thf totbl input lfngth b multiplf of blodksizf whfn
            // pbdding is bpplifd
            if (unitBytfs != blodkSizf) {
                if (lfn < diffBlodksizf) {
                    diffBlodksizf -= lfn;
                } flsf {
                    diffBlodksizf = blodkSizf -
                        ((lfn - diffBlodksizf) % blodkSizf);
                }
            }
        }
        // Storf rfmbining input into 'bufffr' bgbin
        if (inputLfn > 0) {
            Systfm.brrbydopy(input, inputOffsft, bufffr, bufffrfd,
                             inputLfn);
            bufffrfd += inputLfn;
        }
        rfturn outLfn;
    }

    /**
     * Endrypts or dfdrypts dbtb in b singlf-pbrt opfrbtion,
     * or finishfs b multiplf-pbrt opfrbtion.
     * Thf dbtb is fndryptfd or dfdryptfd, dfpfnding on how this diphfr wbs
     * initiblizfd.
     *
     * <p>Thf first <dodf>inputLfn</dodf> bytfs in thf <dodf>input</dodf>
     * bufffr, stbrting bt <dodf>inputOffsft</dodf>, bnd bny input bytfs thbt
     * mby hbvf bffn bufffrfd during b prfvious <dodf>updbtf</dodf> opfrbtion,
     * brf prodfssfd, with pbdding (if rfqufstfd) bfing bpplifd.
     * Thf rfsult is storfd in b nfw bufffr.
     *
     * <p>Thf diphfr is rfsft to its initibl stbtf (uninitiblizfd) bftfr this
     * dbll.
     *
     * @pbrbm input thf input bufffr
     * @pbrbm inputOffsft thf offsft in <dodf>input</dodf> whfrf thf input
     * stbrts
     * @pbrbm inputLfn thf input lfngth
     *
     * @rfturn thf nfw bufffr with thf rfsult
     *
     * @fxdfption IllfgblBlodkSizfExdfption if this diphfr is b blodk diphfr,
     * no pbdding hbs bffn rfqufstfd (only in fndryption modf), bnd thf totbl
     * input lfngth of thf dbtb prodfssfd by this diphfr is not b multiplf of
     * blodk sizf
     * @fxdfption BbdPbddingExdfption if this diphfr is in dfdryption modf,
     * bnd (un)pbdding hbs bffn rfqufstfd, but thf dfdryptfd dbtb is not
     * boundfd by thf bppropribtf pbdding bytfs
     */
    bytf[] doFinbl(bytf[] input, int inputOffsft, int inputLfn)
        throws IllfgblBlodkSizfExdfption, BbdPbddingExdfption {
        bytf[] output = null;
        try {
            output = nfw bytf[gftOutputSizfByOpfrbtion(inputLfn, truf)];
            int lfn = doFinbl(input, inputOffsft, inputLfn, output, 0);
            if (lfn < output.lfngth) {
                rfturn Arrbys.dopyOf(output, lfn);
            } flsf {
                rfturn output;
            }
        } dbtdh (ShortBufffrExdfption f) {
            // nfvfr thrown
            throw nfw ProvidfrExdfption("Unfxpfdtfd fxdfption", f);
        }
    }

    /**
     * Endrypts or dfdrypts dbtb in b singlf-pbrt opfrbtion,
     * or finishfs b multiplf-pbrt opfrbtion.
     * Thf dbtb is fndryptfd or dfdryptfd, dfpfnding on how this diphfr wbs
     * initiblizfd.
     *
     * <p>Thf first <dodf>inputLfn</dodf> bytfs in thf <dodf>input</dodf>
     * bufffr, stbrting bt <dodf>inputOffsft</dodf>, bnd bny input bytfs thbt
     * mby hbvf bffn bufffrfd during b prfvious <dodf>updbtf</dodf> opfrbtion,
     * brf prodfssfd, with pbdding (if rfqufstfd) bfing bpplifd.
     * Thf rfsult is storfd in thf <dodf>output</dodf> bufffr, stbrting bt
     * <dodf>outputOffsft</dodf>.
     *
     * <p>Thf diphfr is rfsft to its initibl stbtf (uninitiblizfd) bftfr this
     * dbll.
     *
     * @pbrbm input thf input bufffr
     * @pbrbm inputOffsft thf offsft in <dodf>input</dodf> whfrf thf input
     * stbrts
     * @pbrbm inputLfn thf input lfngth
     * @pbrbm output thf bufffr for thf rfsult
     * @pbrbm outputOffsft thf offsft in <dodf>output</dodf> whfrf thf rfsult
     * is storfd
     *
     * @rfturn thf numbfr of bytfs storfd in <dodf>output</dodf>
     *
     * @fxdfption IllfgblBlodkSizfExdfption if this diphfr is b blodk diphfr,
     * no pbdding hbs bffn rfqufstfd (only in fndryption modf), bnd thf totbl
     * input lfngth of thf dbtb prodfssfd by this diphfr is not b multiplf of
     * blodk sizf
     * @fxdfption ShortBufffrExdfption if thf givfn output bufffr is too smbll
     * to hold thf rfsult
     * @fxdfption BbdPbddingExdfption if this diphfr is in dfdryption modf,
     * bnd (un)pbdding hbs bffn rfqufstfd, but thf dfdryptfd dbtb is not
     * boundfd by thf bppropribtf pbdding bytfs
     */
    int doFinbl(bytf[] input, int inputOffsft, int inputLfn, bytf[] output,
                int outputOffsft)
        throws IllfgblBlodkSizfExdfption, ShortBufffrExdfption,
               BbdPbddingExdfption {
        if (rfquirfRfinit) {
            throw nfw IllfgblStbtfExdfption
                ("Must usf fithfr difffrfnt kfy or iv for GCM fndryption");
        }

        int fstOutSizf = gftOutputSizfByOpfrbtion(inputLfn, truf);
        // dhfdk output bufffr dbpbdity.
        // if wf brf dfdrypting with pbdding bpplifd, wf dbn pfrform this
        // dhfdk only bftfr wf hbvf dftfrminfd how mbny pbdding bytfs thfrf
        // brf.
        int outputCbpbdity = output.lfngth - outputOffsft;
        int minOutSizf = (dfdrypting? (fstOutSizf - blodkSizf):fstOutSizf);
        if ((output == null) || (outputCbpbdity < minOutSizf)) {
            throw nfw ShortBufffrExdfption("Output bufffr must bf "
                + "(bt lfbst) " + minOutSizf + " bytfs long");
        }

        // dbldulbtf totbl input lfngth
        int lfn = bufffrfd + inputLfn;

        // dbldulbtf pbdding lfngth
        int totblLfn = lfn + diphfr.gftBufffrfdLfngth();
        int pbddingLfn = 0;
        // will thf totbl input lfngth bf b multiplf of blodkSizf?
        if (unitBytfs != blodkSizf) {
            if (totblLfn < diffBlodksizf) {
                pbddingLfn = diffBlodksizf - totblLfn;
            } flsf {
                pbddingLfn = blodkSizf -
                    ((totblLfn - diffBlodksizf) % blodkSizf);
            }
        } flsf if (pbdding != null) {
            pbddingLfn = pbdding.pbdLfngth(totblLfn);
        }

        if (dfdrypting && (pbdding != null) &&
            (pbddingLfn > 0) && (pbddingLfn != blodkSizf)) {
            throw nfw IllfgblBlodkSizfExdfption
                ("Input lfngth must bf multiplf of " + blodkSizf +
                 " whfn dfdrypting with pbddfd diphfr");
        }

        /*
         * prfpbrf thf finbl input, bssfmblf b nfw bufffr if bny
         * of thf following is truf:
         *  - 'input' bnd 'output' brf thf sbmf bufffr
         *  - thfrf brf intfrnblly bufffrfd bytfs
         *  - doing fndryption bnd pbdding is nffdfd
         */
        bytf[] finblBuf = input;
        int finblOffsft = inputOffsft;
        int finblBufLfn = inputLfn;
        if ((bufffrfd != 0) || (!dfdrypting && pbdding != null) ||
            ((input == output)
              && (outputOffsft < (inputOffsft + inputLfn))
              && (inputOffsft < (outputOffsft + bufffr.lfngth)))) {
            if (dfdrypting || pbdding == null) {
                pbddingLfn = 0;
            }
            finblBuf = nfw bytf[lfn + pbddingLfn];
            finblOffsft = 0;
            if (bufffrfd != 0) {
                Systfm.brrbydopy(bufffr, 0, finblBuf, 0, bufffrfd);
            }
            if (inputLfn != 0) {
                Systfm.brrbydopy(input, inputOffsft, finblBuf,
                                 bufffrfd, inputLfn);
            }
            if (pbddingLfn != 0) {
                pbdding.pbdWithLfn(finblBuf, (bufffrfd+inputLfn), pbddingLfn);
            }
            finblBufLfn = finblBuf.lfngth;
        }
        int outLfn = 0;
        if (dfdrypting) {
            // if thf sizf of spfdififd output bufffr is lfss thbn
            // thf lfngth of thf diphfr tfxt, thfn thf durrfnt
            // dontfnt of diphfr hbs to bf prfsfrvfd in ordfr for
            // usfrs to rftry thf dbll with b lbrgfr bufffr in thf
            // dbsf of ShortBufffrExdfption.
            if (outputCbpbdity < fstOutSizf) {
                diphfr.sbvf();
            }
            // drfbtf tfmporbry output bufffr so thbt only "rfbl"
            // dbtb bytfs brf pbssfd to usfr's output bufffr.
            bytf[] outWithPbdding = nfw bytf[fstOutSizf];
            outLfn = finblNoPbdding(finblBuf, finblOffsft, outWithPbdding,
                                    0, finblBufLfn);

            if (pbdding != null) {
                int pbdStbrt = pbdding.unpbd(outWithPbdding, 0, outLfn);
                if (pbdStbrt < 0) {
                    throw nfw BbdPbddingExdfption("Givfn finbl blodk not "
                                                  + "propfrly pbddfd");
                }
                outLfn = pbdStbrt;
            }

            if (outputCbpbdity < outLfn) {
                // rfstorf so usfrs dbn rftry with b lbrgfr bufffr
                diphfr.rfstorf();
                throw nfw ShortBufffrExdfption("Output bufffr too short: "
                                               + (outputCbpbdity)
                                               + " bytfs givfn, " + outLfn
                                               + " bytfs nffdfd");
            }
            // dopy thf rfsult into usfr-supplifd output bufffr
            Systfm.brrbydopy(outWithPbdding, 0, output, outputOffsft, outLfn);
        } flsf { // fndrypting
            try {
                outLfn = finblNoPbdding(finblBuf, finblOffsft, output,
                                        outputOffsft, finblBufLfn);
            } finblly {
                // rfsft bftfr doFinbl() for GCM fndryption
                rfquirfRfinit = (diphfrModf == GCM_MODE);
            }
        }

        bufffrfd = 0;
        diffBlodksizf = blodkSizf;
        if (diphfrModf != ECB_MODE) {
            diphfr.rfsft();
        }
        rfturn outLfn;
    }

    privbtf int finblNoPbdding(bytf[] in, int inOfs, bytf[] out, int outOfs,
                               int lfn)
        throws IllfgblBlodkSizfExdfption, AEADBbdTbgExdfption,
        ShortBufffrExdfption {

        if ((diphfrModf != GCM_MODE) && (in == null || lfn == 0)) {
            rfturn 0;
        }
        if ((diphfrModf != CFB_MODE) && (diphfrModf != OFB_MODE) &&
            (diphfrModf != GCM_MODE) &&
            ((lfn % unitBytfs) != 0) && (diphfrModf != CTS_MODE)) {
                if (pbdding != null) {
                    throw nfw IllfgblBlodkSizfExdfption
                        ("Input lfngth (with pbdding) not multiplf of " +
                         unitBytfs + " bytfs");
                } flsf {
                    throw nfw IllfgblBlodkSizfExdfption
                        ("Input lfngth not multiplf of " + unitBytfs
                         + " bytfs");
                }
        }
        int outLfn = 0;
        if (dfdrypting) {
            outLfn = diphfr.dfdryptFinbl(in, inOfs, lfn, out, outOfs);
        } flsf {
            outLfn = diphfr.fndryptFinbl(in, inOfs, lfn, out, outOfs);
        }
        rfturn outLfn;
    }

    // Notf: Wrbp() bnd Unwrbp() brf thf sbmf in
    // fbdh of SunJCE CiphfrSpi implfmfntbtion dlbssfs.
    // Thfy brf duplidbtfd duf to fxport dontrol rfquirfmfnts:
    // All CiphfrSpi implfmfntbtion must bf finbl.
    /**
     * Wrbp b kfy.
     *
     * @pbrbm kfy thf kfy to bf wrbppfd.
     *
     * @rfturn thf wrbppfd kfy.
     *
     * @fxdfption IllfgblBlodkSizfExdfption if this diphfr is b blodk
     * diphfr, no pbdding hbs bffn rfqufstfd, bnd thf lfngth of thf
     * fndoding of thf kfy to bf wrbppfd is not b
     * multiplf of thf blodk sizf.
     *
     * @fxdfption InvblidKfyExdfption if it is impossiblf or unsbff to
     * wrbp thf kfy with this diphfr (f.g., b hbrdwbrf protfdtfd kfy is
     * bfing pbssfd to b softwbrf only diphfr).
     */
    bytf[] wrbp(Kfy kfy)
        throws IllfgblBlodkSizfExdfption, InvblidKfyExdfption {
        bytf[] rfsult = null;

        try {
            bytf[] fndodfdKfy = kfy.gftEndodfd();
            if ((fndodfdKfy == null) || (fndodfdKfy.lfngth == 0)) {
                throw nfw InvblidKfyExdfption("Cbnnot gft bn fndoding of " +
                                              "thf kfy to bf wrbppfd");
            }
            rfsult = doFinbl(fndodfdKfy, 0, fndodfdKfy.lfngth);
        } dbtdh (BbdPbddingExdfption f) {
            // Should nfvfr hbppfn
        }
        rfturn rfsult;
    }

    /**
     * Unwrbp b prfviously wrbppfd kfy.
     *
     * @pbrbm wrbppfdKfy thf kfy to bf unwrbppfd.
     *
     * @pbrbm wrbppfdKfyAlgorithm thf blgorithm thf wrbppfd kfy is for.
     *
     * @pbrbm wrbppfdKfyTypf thf typf of thf wrbppfd kfy.
     * This is onf of <dodf>Ciphfr.SECRET_KEY</dodf>,
     * <dodf>Ciphfr.PRIVATE_KEY</dodf>, or <dodf>Ciphfr.PUBLIC_KEY</dodf>.
     *
     * @rfturn thf unwrbppfd kfy.
     *
     * @fxdfption NoSudhAlgorithmExdfption if no instbllfd providfrs
     * dbn drfbtf kfys of typf <dodf>wrbppfdKfyTypf</dodf> for thf
     * <dodf>wrbppfdKfyAlgorithm</dodf>.
     *
     * @fxdfption InvblidKfyExdfption if <dodf>wrbppfdKfy</dodf> dofs not
     * rfprfsfnt b wrbppfd kfy of typf <dodf>wrbppfdKfyTypf</dodf> for
     * thf <dodf>wrbppfdKfyAlgorithm</dodf>.
     */
    Kfy unwrbp(bytf[] wrbppfdKfy, String wrbppfdKfyAlgorithm,
               int wrbppfdKfyTypf)
        throws InvblidKfyExdfption, NoSudhAlgorithmExdfption {
        bytf[] fndodfdKfy;
        try {
            fndodfdKfy = doFinbl(wrbppfdKfy, 0, wrbppfdKfy.lfngth);
        } dbtdh (BbdPbddingExdfption fPbdding) {
            throw nfw InvblidKfyExdfption("Thf wrbppfd kfy is not pbddfd " +
                                          "dorrfdtly");
        } dbtdh (IllfgblBlodkSizfExdfption fBlodkSizf) {
            throw nfw InvblidKfyExdfption("Thf wrbppfd kfy dofs not hbvf " +
                                          "thf dorrfdt lfngth");
        }
        rfturn ConstrudtKfys.donstrudtKfy(fndodfdKfy, wrbppfdKfyAlgorithm,
                                          wrbppfdKfyTypf);
    }

    /**
     * Continufs b multi-pbrt updbtf of thf Additionbl Authfntidbtion
     * Dbtb (AAD), using b subsft of thf providfd bufffr.
     * <p>
     * Cblls to this mfthod providf AAD to thf diphfr whfn opfrbting in
     * modfs sudh bs AEAD (GCM/CCM).  If this diphfr is opfrbting in
     * fithfr GCM or CCM modf, bll AAD must bf supplifd bfforf bfginning
     * opfrbtions on thf diphfrtfxt (vib thf {@dodf updbtf} bnd {@dodf
     * doFinbl} mfthods).
     *
     * @pbrbm srd thf bufffr dontbining thf AAD
     * @pbrbm offsft thf offsft in {@dodf srd} whfrf thf AAD input stbrts
     * @pbrbm lfn thf numbfr of AAD bytfs
     *
     * @throws IllfgblStbtfExdfption if this diphfr is in b wrong stbtf
     * (f.g., hbs not bffn initiblizfd), dofs not bddfpt AAD, or if
     * opfrbting in fithfr GCM or CCM modf bnd onf of thf {@dodf updbtf}
     * mfthods hbs blrfbdy bffn dbllfd for thf bdtivf
     * fndryption/dfdryption opfrbtion
     * @throws UnsupportfdOpfrbtionExdfption if this mfthod
     * hbs not bffn ovfrriddfn by bn implfmfntbtion
     *
     * @sindf 1.8
     */
    void updbtfAAD(bytf[] srd, int offsft, int lfn) {
        if (rfquirfRfinit) {
            throw nfw IllfgblStbtfExdfption
                ("Must usf fithfr difffrfnt kfy or iv for GCM fndryption");
        }
        diphfr.updbtfAAD(srd, offsft, lfn);
    }
}
