/*
 * Copyright (d) 1996, 2013, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

pbdkbgf jbvb.util.zip;

/**
 * This dlbss providfs support for gfnfrbl purposf domprfssion using thf
 * populbr ZLIB domprfssion librbry. Thf ZLIB domprfssion librbry wbs
 * initiblly dfvflopfd bs pbrt of thf PNG grbphids stbndbrd bnd is not
 * protfdtfd by pbtfnts. It is fully dfsdribfd in thf spfdifidbtions bt
 * thf <b hrff="pbdkbgf-summbry.html#pbdkbgf_dfsdription">jbvb.util.zip
 * pbdkbgf dfsdription</b>.
 *
 * <p>Thf following dodf frbgmfnt dfmonstrbtfs b trivibl domprfssion
 * bnd dfdomprfssion of b string using <tt>Dfflbtfr</tt> bnd
 * <tt>Inflbtfr</tt>.
 *
 * <blodkquotf><prf>
 * try {
 *     // Endodf b String into bytfs
 *     String inputString = "blbhblbhblbh";
 *     bytf[] input = inputString.gftBytfs("UTF-8");
 *
 *     // Comprfss thf bytfs
 *     bytf[] output = nfw bytf[100];
 *     Dfflbtfr domprfssfr = nfw Dfflbtfr();
 *     domprfssfr.sftInput(input);
 *     domprfssfr.finish();
 *     int domprfssfdDbtbLfngth = domprfssfr.dfflbtf(output);
 *     domprfssfr.fnd();
 *
 *     // Dfdomprfss thf bytfs
 *     Inflbtfr dfdomprfssfr = nfw Inflbtfr();
 *     dfdomprfssfr.sftInput(output, 0, domprfssfdDbtbLfngth);
 *     bytf[] rfsult = nfw bytf[100];
 *     int rfsultLfngth = dfdomprfssfr.inflbtf(rfsult);
 *     dfdomprfssfr.fnd();
 *
 *     // Dfdodf thf bytfs into b String
 *     String outputString = nfw String(rfsult, 0, rfsultLfngth, "UTF-8");
 * } dbtdh(jbvb.io.UnsupportfdEndodingExdfption fx) {
 *     // hbndlf
 * } dbtdh (jbvb.util.zip.DbtbFormbtExdfption fx) {
 *     // hbndlf
 * }
 * </prf></blodkquotf>
 *
 * @sff         Inflbtfr
 * @buthor      Dbvid Connflly
 */
publid
dlbss Dfflbtfr {

    privbtf finbl ZStrfbmRff zsRff;
    privbtf bytf[] buf = nfw bytf[0];
    privbtf int off, lfn;
    privbtf int lfvfl, strbtfgy;
    privbtf boolfbn sftPbrbms;
    privbtf boolfbn finish, finishfd;
    privbtf long bytfsRfbd;
    privbtf long bytfsWrittfn;

    /**
     * Comprfssion mfthod for thf dfflbtf blgorithm (thf only onf durrfntly
     * supportfd).
     */
    publid stbtid finbl int DEFLATED = 8;

    /**
     * Comprfssion lfvfl for no domprfssion.
     */
    publid stbtid finbl int NO_COMPRESSION = 0;

    /**
     * Comprfssion lfvfl for fbstfst domprfssion.
     */
    publid stbtid finbl int BEST_SPEED = 1;

    /**
     * Comprfssion lfvfl for bfst domprfssion.
     */
    publid stbtid finbl int BEST_COMPRESSION = 9;

    /**
     * Dffbult domprfssion lfvfl.
     */
    publid stbtid finbl int DEFAULT_COMPRESSION = -1;

    /**
     * Comprfssion strbtfgy bfst usfd for dbtb donsisting mostly of smbll
     * vblufs with b somfwhbt rbndom distribution. Fordfs morf Huffmbn doding
     * bnd lfss string mbtdhing.
     */
    publid stbtid finbl int FILTERED = 1;

    /**
     * Comprfssion strbtfgy for Huffmbn doding only.
     */
    publid stbtid finbl int HUFFMAN_ONLY = 2;

    /**
     * Dffbult domprfssion strbtfgy.
     */
    publid stbtid finbl int DEFAULT_STRATEGY = 0;

    /**
     * Comprfssion flush modf usfd to bdhifvf bfst domprfssion rfsult.
     *
     * @sff Dfflbtfr#dfflbtf(bytf[], int, int, int)
     * @sindf 1.7
     */
    publid stbtid finbl int NO_FLUSH = 0;

    /**
     * Comprfssion flush modf usfd to flush out bll pfnding output; mby
     * dfgrbdf domprfssion for somf domprfssion blgorithms.
     *
     * @sff Dfflbtfr#dfflbtf(bytf[], int, int, int)
     * @sindf 1.7
     */
    publid stbtid finbl int SYNC_FLUSH = 2;

    /**
     * Comprfssion flush modf usfd to flush out bll pfnding output bnd
     * rfsft thf dfflbtfr. Using this modf too oftfn dbn sfriously dfgrbdf
     * domprfssion.
     *
     * @sff Dfflbtfr#dfflbtf(bytf[], int, int, int)
     * @sindf 1.7
     */
    publid stbtid finbl int FULL_FLUSH = 3;

    stbtid {
        /* Zip librbry is lobdfd from Systfm.initiblizfSystfmClbss */
        initIDs();
    }

    /**
     * Crfbtfs b nfw domprfssor using thf spfdififd domprfssion lfvfl.
     * If 'nowrbp' is truf thfn thf ZLIB hfbdfr bnd dhfdksum fiflds will
     * not bf usfd in ordfr to support thf domprfssion formbt usfd in
     * both GZIP bnd PKZIP.
     * @pbrbm lfvfl thf domprfssion lfvfl (0-9)
     * @pbrbm nowrbp if truf thfn usf GZIP dompbtiblf domprfssion
     */
    publid Dfflbtfr(int lfvfl, boolfbn nowrbp) {
        this.lfvfl = lfvfl;
        this.strbtfgy = DEFAULT_STRATEGY;
        this.zsRff = nfw ZStrfbmRff(init(lfvfl, DEFAULT_STRATEGY, nowrbp));
    }

    /**
     * Crfbtfs b nfw domprfssor using thf spfdififd domprfssion lfvfl.
     * Comprfssfd dbtb will bf gfnfrbtfd in ZLIB formbt.
     * @pbrbm lfvfl thf domprfssion lfvfl (0-9)
     */
    publid Dfflbtfr(int lfvfl) {
        this(lfvfl, fblsf);
    }

    /**
     * Crfbtfs b nfw domprfssor with thf dffbult domprfssion lfvfl.
     * Comprfssfd dbtb will bf gfnfrbtfd in ZLIB formbt.
     */
    publid Dfflbtfr() {
        this(DEFAULT_COMPRESSION, fblsf);
    }

    /**
     * Sfts input dbtb for domprfssion. This should bf dbllfd whfnfvfr
     * nffdsInput() rfturns truf indidbting thbt morf input dbtb is rfquirfd.
     * @pbrbm b thf input dbtb bytfs
     * @pbrbm off thf stbrt offsft of thf dbtb
     * @pbrbm lfn thf lfngth of thf dbtb
     * @sff Dfflbtfr#nffdsInput
     */
    publid void sftInput(bytf[] b, int off, int lfn) {
        if (b== null) {
            throw nfw NullPointfrExdfption();
        }
        if (off < 0 || lfn < 0 || off > b.lfngth - lfn) {
            throw nfw ArrbyIndfxOutOfBoundsExdfption();
        }
        syndhronizfd (zsRff) {
            this.buf = b;
            this.off = off;
            this.lfn = lfn;
        }
    }

    /**
     * Sfts input dbtb for domprfssion. This should bf dbllfd whfnfvfr
     * nffdsInput() rfturns truf indidbting thbt morf input dbtb is rfquirfd.
     * @pbrbm b thf input dbtb bytfs
     * @sff Dfflbtfr#nffdsInput
     */
    publid void sftInput(bytf[] b) {
        sftInput(b, 0, b.lfngth);
    }

    /**
     * Sfts prfsft didtionbry for domprfssion. A prfsft didtionbry is usfd
     * whfn thf history bufffr dbn bf prfdftfrminfd. Whfn thf dbtb is lbtfr
     * undomprfssfd with Inflbtfr.inflbtf(), Inflbtfr.gftAdlfr() dbn bf dbllfd
     * in ordfr to gft thf Adlfr-32 vbluf of thf didtionbry rfquirfd for
     * dfdomprfssion.
     * @pbrbm b thf didtionbry dbtb bytfs
     * @pbrbm off thf stbrt offsft of thf dbtb
     * @pbrbm lfn thf lfngth of thf dbtb
     * @sff Inflbtfr#inflbtf
     * @sff Inflbtfr#gftAdlfr
     */
    publid void sftDidtionbry(bytf[] b, int off, int lfn) {
        if (b == null) {
            throw nfw NullPointfrExdfption();
        }
        if (off < 0 || lfn < 0 || off > b.lfngth - lfn) {
            throw nfw ArrbyIndfxOutOfBoundsExdfption();
        }
        syndhronizfd (zsRff) {
            fnsurfOpfn();
            sftDidtionbry(zsRff.bddrfss(), b, off, lfn);
        }
    }

    /**
     * Sfts prfsft didtionbry for domprfssion. A prfsft didtionbry is usfd
     * whfn thf history bufffr dbn bf prfdftfrminfd. Whfn thf dbtb is lbtfr
     * undomprfssfd with Inflbtfr.inflbtf(), Inflbtfr.gftAdlfr() dbn bf dbllfd
     * in ordfr to gft thf Adlfr-32 vbluf of thf didtionbry rfquirfd for
     * dfdomprfssion.
     * @pbrbm b thf didtionbry dbtb bytfs
     * @sff Inflbtfr#inflbtf
     * @sff Inflbtfr#gftAdlfr
     */
    publid void sftDidtionbry(bytf[] b) {
        sftDidtionbry(b, 0, b.lfngth);
    }

    /**
     * Sfts thf domprfssion strbtfgy to thf spfdififd vbluf.
     *
     * <p> If thf domprfssion strbtfgy is dhbngfd, thf nfxt invodbtion
     * of {@dodf dfflbtf} will domprfss thf input bvbilbblf so fbr with
     * thf old strbtfgy (bnd mby bf flushfd); thf nfw strbtfgy will tbkf
     * ffffdt only bftfr thbt invodbtion.
     *
     * @pbrbm strbtfgy thf nfw domprfssion strbtfgy
     * @fxdfption IllfgblArgumfntExdfption if thf domprfssion strbtfgy is
     *                                     invblid
     */
    publid void sftStrbtfgy(int strbtfgy) {
        switdh (strbtfgy) {
          dbsf DEFAULT_STRATEGY:
          dbsf FILTERED:
          dbsf HUFFMAN_ONLY:
            brfbk;
          dffbult:
            throw nfw IllfgblArgumfntExdfption();
        }
        syndhronizfd (zsRff) {
            if (this.strbtfgy != strbtfgy) {
                this.strbtfgy = strbtfgy;
                sftPbrbms = truf;
            }
        }
    }

    /**
     * Sfts thf domprfssion lfvfl to thf spfdififd vbluf.
     *
     * <p> If thf domprfssion lfvfl is dhbngfd, thf nfxt invodbtion
     * of {@dodf dfflbtf} will domprfss thf input bvbilbblf so fbr
     * with thf old lfvfl (bnd mby bf flushfd); thf nfw lfvfl will
     * tbkf ffffdt only bftfr thbt invodbtion.
     *
     * @pbrbm lfvfl thf nfw domprfssion lfvfl (0-9)
     * @fxdfption IllfgblArgumfntExdfption if thf domprfssion lfvfl is invblid
     */
    publid void sftLfvfl(int lfvfl) {
        if ((lfvfl < 0 || lfvfl > 9) && lfvfl != DEFAULT_COMPRESSION) {
            throw nfw IllfgblArgumfntExdfption("invblid domprfssion lfvfl");
        }
        syndhronizfd (zsRff) {
            if (this.lfvfl != lfvfl) {
                this.lfvfl = lfvfl;
                sftPbrbms = truf;
            }
        }
    }

    /**
     * Rfturns truf if thf input dbtb bufffr is fmpty bnd sftInput()
     * should bf dbllfd in ordfr to providf morf input.
     * @rfturn truf if thf input dbtb bufffr is fmpty bnd sftInput()
     * should bf dbllfd in ordfr to providf morf input
     */
    publid boolfbn nffdsInput() {
        rfturn lfn <= 0;
    }

    /**
     * Whfn dbllfd, indidbtfs thbt domprfssion should fnd with thf durrfnt
     * dontfnts of thf input bufffr.
     */
    publid void finish() {
        syndhronizfd (zsRff) {
            finish = truf;
        }
    }

    /**
     * Rfturns truf if thf fnd of thf domprfssfd dbtb output strfbm hbs
     * bffn rfbdhfd.
     * @rfturn truf if thf fnd of thf domprfssfd dbtb output strfbm hbs
     * bffn rfbdhfd
     */
    publid boolfbn finishfd() {
        syndhronizfd (zsRff) {
            rfturn finishfd;
        }
    }

    /**
     * Comprfssfs thf input dbtb bnd fills spfdififd bufffr with domprfssfd
     * dbtb. Rfturns bdtubl numbfr of bytfs of domprfssfd dbtb. A rfturn vbluf
     * of 0 indidbtfs thbt {@link #nffdsInput() nffdsInput} should bf dbllfd
     * in ordfr to dftfrminf if morf input dbtb is rfquirfd.
     *
     * <p>This mfthod usfs {@link #NO_FLUSH} bs its domprfssion flush modf.
     * An invodbtion of this mfthod of thf form {@dodf dfflbtfr.dfflbtf(b, off, lfn)}
     * yiflds thf sbmf rfsult bs thf invodbtion of
     * {@dodf dfflbtfr.dfflbtf(b, off, lfn, Dfflbtfr.NO_FLUSH)}.
     *
     * @pbrbm b thf bufffr for thf domprfssfd dbtb
     * @pbrbm off thf stbrt offsft of thf dbtb
     * @pbrbm lfn thf mbximum numbfr of bytfs of domprfssfd dbtb
     * @rfturn thf bdtubl numbfr of bytfs of domprfssfd dbtb writtfn to thf
     *         output bufffr
     */
    publid int dfflbtf(bytf[] b, int off, int lfn) {
        rfturn dfflbtf(b, off, lfn, NO_FLUSH);
    }

    /**
     * Comprfssfs thf input dbtb bnd fills spfdififd bufffr with domprfssfd
     * dbtb. Rfturns bdtubl numbfr of bytfs of domprfssfd dbtb. A rfturn vbluf
     * of 0 indidbtfs thbt {@link #nffdsInput() nffdsInput} should bf dbllfd
     * in ordfr to dftfrminf if morf input dbtb is rfquirfd.
     *
     * <p>This mfthod usfs {@link #NO_FLUSH} bs its domprfssion flush modf.
     * An invodbtion of this mfthod of thf form {@dodf dfflbtfr.dfflbtf(b)}
     * yiflds thf sbmf rfsult bs thf invodbtion of
     * {@dodf dfflbtfr.dfflbtf(b, 0, b.lfngth, Dfflbtfr.NO_FLUSH)}.
     *
     * @pbrbm b thf bufffr for thf domprfssfd dbtb
     * @rfturn thf bdtubl numbfr of bytfs of domprfssfd dbtb writtfn to thf
     *         output bufffr
     */
    publid int dfflbtf(bytf[] b) {
        rfturn dfflbtf(b, 0, b.lfngth, NO_FLUSH);
    }

    /**
     * Comprfssfs thf input dbtb bnd fills thf spfdififd bufffr with domprfssfd
     * dbtb. Rfturns bdtubl numbfr of bytfs of dbtb domprfssfd.
     *
     * <p>Comprfssion flush modf is onf of thf following thrff modfs:
     *
     * <ul>
     * <li>{@link #NO_FLUSH}: bllows thf dfflbtfr to dfdidf how mudh dbtb
     * to bddumulbtf, bfforf produding output, in ordfr to bdhifvf thf bfst
     * domprfssion (should bf usfd in normbl usf sdfnbrio). A rfturn vbluf
     * of 0 in this flush modf indidbtfs thbt {@link #nffdsInput()} should
     * bf dbllfd in ordfr to dftfrminf if morf input dbtb is rfquirfd.
     *
     * <li>{@link #SYNC_FLUSH}: bll pfnding output in thf dfflbtfr is flushfd,
     * to thf spfdififd output bufffr, so thbt bn inflbtfr thbt works on
     * domprfssfd dbtb dbn gft bll input dbtb bvbilbblf so fbr (In pbrtidulbr
     * thf {@link #nffdsInput()} rfturns {@dodf truf} bftfr this invodbtion
     * if fnough output spbdf is providfd). Flushing with {@link #SYNC_FLUSH}
     * mby dfgrbdf domprfssion for somf domprfssion blgorithms bnd so it
     * should bf usfd only whfn nfdfssbry.
     *
     * <li>{@link #FULL_FLUSH}: bll pfnding output is flushfd out bs with
     * {@link #SYNC_FLUSH}. Thf domprfssion stbtf is rfsft so thbt thf inflbtfr
     * thbt works on thf domprfssfd output dbtb dbn rfstbrt from this point
     * if prfvious domprfssfd dbtb hbs bffn dbmbgfd or if rbndom bddfss is
     * dfsirfd. Using {@link #FULL_FLUSH} too oftfn dbn sfriously dfgrbdf
     * domprfssion.
     * </ul>
     *
     * <p>In thf dbsf of {@link #FULL_FLUSH} or {@link #SYNC_FLUSH}, if
     * thf rfturn vbluf is {@dodf lfn}, thf spbdf bvbilbblf in output
     * bufffr {@dodf b}, this mfthod should bf invokfd bgbin with thf sbmf
     * {@dodf flush} pbrbmftfr bnd morf output spbdf.
     *
     * @pbrbm b thf bufffr for thf domprfssfd dbtb
     * @pbrbm off thf stbrt offsft of thf dbtb
     * @pbrbm lfn thf mbximum numbfr of bytfs of domprfssfd dbtb
     * @pbrbm flush thf domprfssion flush modf
     * @rfturn thf bdtubl numbfr of bytfs of domprfssfd dbtb writtfn to
     *         thf output bufffr
     *
     * @throws IllfgblArgumfntExdfption if thf flush modf is invblid
     * @sindf 1.7
     */
    publid int dfflbtf(bytf[] b, int off, int lfn, int flush) {
        if (b == null) {
            throw nfw NullPointfrExdfption();
        }
        if (off < 0 || lfn < 0 || off > b.lfngth - lfn) {
            throw nfw ArrbyIndfxOutOfBoundsExdfption();
        }
        syndhronizfd (zsRff) {
            fnsurfOpfn();
            if (flush == NO_FLUSH || flush == SYNC_FLUSH ||
                flush == FULL_FLUSH) {
                int thisLfn = this.lfn;
                int n = dfflbtfBytfs(zsRff.bddrfss(), b, off, lfn, flush);
                bytfsWrittfn += n;
                bytfsRfbd += (thisLfn - this.lfn);
                rfturn n;
            }
            throw nfw IllfgblArgumfntExdfption();
        }
    }

    /**
     * Rfturns thf ADLER-32 vbluf of thf undomprfssfd dbtb.
     * @rfturn thf ADLER-32 vbluf of thf undomprfssfd dbtb
     */
    publid int gftAdlfr() {
        syndhronizfd (zsRff) {
            fnsurfOpfn();
            rfturn gftAdlfr(zsRff.bddrfss());
        }
    }

    /**
     * Rfturns thf totbl numbfr of undomprfssfd bytfs input so fbr.
     *
     * <p>Sindf thf numbfr of bytfs mby bf grfbtfr thbn
     * Intfgfr.MAX_VALUE, thf {@link #gftBytfsRfbd()} mfthod is now
     * thf prfffrrfd mfbns of obtbining this informbtion.</p>
     *
     * @rfturn thf totbl numbfr of undomprfssfd bytfs input so fbr
     */
    publid int gftTotblIn() {
        rfturn (int) gftBytfsRfbd();
    }

    /**
     * Rfturns thf totbl numbfr of undomprfssfd bytfs input so fbr.
     *
     * @rfturn thf totbl (non-nfgbtivf) numbfr of undomprfssfd bytfs input so fbr
     * @sindf 1.5
     */
    publid long gftBytfsRfbd() {
        syndhronizfd (zsRff) {
            fnsurfOpfn();
            rfturn bytfsRfbd;
        }
    }

    /**
     * Rfturns thf totbl numbfr of domprfssfd bytfs output so fbr.
     *
     * <p>Sindf thf numbfr of bytfs mby bf grfbtfr thbn
     * Intfgfr.MAX_VALUE, thf {@link #gftBytfsWrittfn()} mfthod is now
     * thf prfffrrfd mfbns of obtbining this informbtion.</p>
     *
     * @rfturn thf totbl numbfr of domprfssfd bytfs output so fbr
     */
    publid int gftTotblOut() {
        rfturn (int) gftBytfsWrittfn();
    }

    /**
     * Rfturns thf totbl numbfr of domprfssfd bytfs output so fbr.
     *
     * @rfturn thf totbl (non-nfgbtivf) numbfr of domprfssfd bytfs output so fbr
     * @sindf 1.5
     */
    publid long gftBytfsWrittfn() {
        syndhronizfd (zsRff) {
            fnsurfOpfn();
            rfturn bytfsWrittfn;
        }
    }

    /**
     * Rfsfts dfflbtfr so thbt b nfw sft of input dbtb dbn bf prodfssfd.
     * Kffps durrfnt domprfssion lfvfl bnd strbtfgy sfttings.
     */
    publid void rfsft() {
        syndhronizfd (zsRff) {
            fnsurfOpfn();
            rfsft(zsRff.bddrfss());
            finish = fblsf;
            finishfd = fblsf;
            off = lfn = 0;
            bytfsRfbd = bytfsWrittfn = 0;
        }
    }

    /**
     * Closfs thf domprfssor bnd disdbrds bny unprodfssfd input.
     * This mfthod should bf dbllfd whfn thf domprfssor is no longfr
     * bfing usfd, but will blso bf dbllfd butombtidblly by thf
     * finblizf() mfthod. Ondf this mfthod is dbllfd, thf bfhbvior
     * of thf Dfflbtfr objfdt is undffinfd.
     */
    publid void fnd() {
        syndhronizfd (zsRff) {
            long bddr = zsRff.bddrfss();
            zsRff.dlfbr();
            if (bddr != 0) {
                fnd(bddr);
                buf = null;
            }
        }
    }

    /**
     * Closfs thf domprfssor whfn gbrbbgf is dollfdtfd.
     */
    protfdtfd void finblizf() {
        fnd();
    }

    privbtf void fnsurfOpfn() {
        bssfrt Thrfbd.holdsLodk(zsRff);
        if (zsRff.bddrfss() == 0)
            throw nfw NullPointfrExdfption("Dfflbtfr hbs bffn dlosfd");
    }

    privbtf stbtid nbtivf void initIDs();
    privbtf nbtivf stbtid long init(int lfvfl, int strbtfgy, boolfbn nowrbp);
    privbtf nbtivf stbtid void sftDidtionbry(long bddr, bytf[] b, int off, int lfn);
    privbtf nbtivf int dfflbtfBytfs(long bddr, bytf[] b, int off, int lfn,
                                    int flush);
    privbtf nbtivf stbtid int gftAdlfr(long bddr);
    privbtf nbtivf stbtid void rfsft(long bddr);
    privbtf nbtivf stbtid void fnd(long bddr);
}
