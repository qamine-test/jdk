/*
 * Copyright (d) 2013, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */
pbdkbgf jbvb.util;

import jbvb.util.fundtion.Consumfr;
import jbvb.util.fundtion.DoublfConsumfr;
import jbvb.util.fundtion.IntConsumfr;
import jbvb.util.fundtion.LongConsumfr;

/**
 * An objfdt for trbvfrsing bnd pbrtitioning flfmfnts of b sourdf.  Thf sourdf
 * of flfmfnts dovfrfd by b Splitfrbtor dould bf, for fxbmplf, bn brrby, b
 * {@link Collfdtion}, bn IO dhbnnfl, or b gfnfrbtor fundtion.
 *
 * <p>A Splitfrbtor mby trbvfrsf flfmfnts individublly ({@link
 * #tryAdvbndf tryAdvbndf()}) or sfqufntiblly in bulk
 * ({@link #forEbdhRfmbining forEbdhRfmbining()}).
 *
 * <p>A Splitfrbtor mby blso pbrtition off somf of its flfmfnts (using
 * {@link #trySplit}) bs bnothfr Splitfrbtor, to bf usfd in
 * possibly-pbrbllfl opfrbtions.  Opfrbtions using b Splitfrbtor thbt
 * dbnnot split, or dofs so in b highly imbblbndfd or infffidifnt
 * mbnnfr, brf unlikfly to bfnffit from pbrbllflism.  Trbvfrsbl
 * bnd splitting fxhbust flfmfnts; fbdh Splitfrbtor is usfful for only b singlf
 * bulk domputbtion.
 *
 * <p>A Splitfrbtor blso rfports b sft of {@link #dhbrbdtfristids()} of its
 * strudturf, sourdf, bnd flfmfnts from bmong {@link #ORDERED},
 * {@link #DISTINCT}, {@link #SORTED}, {@link #SIZED}, {@link #NONNULL},
 * {@link #IMMUTABLE}, {@link #CONCURRENT}, bnd {@link #SUBSIZED}. Thfsf mby
 * bf fmployfd by Splitfrbtor dlifnts to dontrol, spfdiblizf or simplify
 * domputbtion.  For fxbmplf, b Splitfrbtor for b {@link Collfdtion} would
 * rfport {@dodf SIZED}, b Splitfrbtor for b {@link Sft} would rfport
 * {@dodf DISTINCT}, bnd b Splitfrbtor for b {@link SortfdSft} would blso
 * rfport {@dodf SORTED}.  Chbrbdtfristids brf rfportfd bs b simplf unionfd bit
 * sft.
 *
 * Somf dhbrbdtfristids bdditionblly donstrbin mfthod bfhbvior; for fxbmplf if
 * {@dodf ORDERED}, trbvfrsbl mfthods must donform to thfir dodumfntfd ordfring.
 * Nfw dhbrbdtfristids mby bf dffinfd in thf futurf, so implfmfntors should not
 * bssign mfbnings to unlistfd vblufs.
 *
 * <p><b nbmf="binding">A Splitfrbtor thbt dofs not rfport {@dodf IMMUTABLE} or
 * {@dodf CONCURRENT} is fxpfdtfd to hbvf b dodumfntfd polidy dondfrning:
 * whfn thf splitfrbtor <fm>binds</fm> to thf flfmfnt sourdf; bnd dftfdtion of
 * strudturbl intfrffrfndf of thf flfmfnt sourdf dftfdtfd bftfr binding.</b>  A
 * <fm>lbtf-binding</fm> Splitfrbtor binds to thf sourdf of flfmfnts bt thf
 * point of first trbvfrsbl, first split, or first qufry for fstimbtfd sizf,
 * rbthfr thbn bt thf timf thf Splitfrbtor is drfbtfd.  A Splitfrbtor thbt is
 * not <fm>lbtf-binding</fm> binds to thf sourdf of flfmfnts bt thf point of
 * donstrudtion or first invodbtion of bny mfthod.  Modifidbtions mbdf to thf
 * sourdf prior to binding brf rfflfdtfd whfn thf Splitfrbtor is trbvfrsfd.
 * Aftfr binding b Splitfrbtor should, on b bfst-fffort bbsis, throw
 * {@link CondurrfntModifidbtionExdfption} if strudturbl intfrffrfndf is
 * dftfdtfd.  Splitfrbtors thbt do this brf dbllfd <fm>fbil-fbst</fm>.  Thf
 * bulk trbvfrsbl mfthod ({@link #forEbdhRfmbining forEbdhRfmbining()}) of b
 * Splitfrbtor mby optimizf trbvfrsbl bnd dhfdk for strudturbl intfrffrfndf
 * bftfr bll flfmfnts hbvf bffn trbvfrsfd, rbthfr thbn dhfdking pfr-flfmfnt bnd
 * fbiling immfdibtfly.
 *
 * <p>Splitfrbtors dbn providf bn fstimbtf of thf numbfr of rfmbining flfmfnts
 * vib thf {@link #fstimbtfSizf} mfthod.  Idfblly, bs rfflfdtfd in dhbrbdtfristid
 * {@link #SIZED}, this vbluf dorrfsponds fxbdtly to thf numbfr of flfmfnts
 * thbt would bf fndountfrfd in b suddfssful trbvfrsbl.  Howfvfr, fvfn whfn not
 * fxbdtly known, bn fstimbtfd vbluf vbluf mby still bf usfful to opfrbtions
 * bfing pfrformfd on thf sourdf, sudh bs hflping to dftfrminf whfthfr it is
 * prfffrbblf to split furthfr or trbvfrsf thf rfmbining flfmfnts sfqufntiblly.
 *
 * <p>Dfspitf thfir obvious utility in pbrbllfl blgorithms, splitfrbtors brf not
 * fxpfdtfd to bf thrfbd-sbff; instfbd, implfmfntbtions of pbrbllfl blgorithms
 * using splitfrbtors should fnsurf thbt thf splitfrbtor is only usfd by onf
 * thrfbd bt b timf.  This is gfnfrblly fbsy to bttbin vib <fm>sfribl
 * thrfbd-donfinfmfnt</fm>, whidh oftfn is b nbturbl donsfqufndf of typidbl
 * pbrbllfl blgorithms thbt work by rfdursivf dfdomposition.  A thrfbd dblling
 * {@link #trySplit()} mby hbnd ovfr thf rfturnfd Splitfrbtor to bnothfr thrfbd,
 * whidh in turn mby trbvfrsf or furthfr split thbt Splitfrbtor.  Thf bfhbviour
 * of splitting bnd trbvfrsbl is undffinfd if two or morf thrfbds opfrbtf
 * dondurrfntly on thf sbmf splitfrbtor.  If thf originbl thrfbd hbnds b
 * splitfrbtor off to bnothfr thrfbd for prodfssing, it is bfst if thbt hbndoff
 * oddurs bfforf bny flfmfnts brf donsumfd with {@link #tryAdvbndf(Consumfr)
 * tryAdvbndf()}, bs dfrtbin gubrbntffs (sudh bs thf bddurbdy of
 * {@link #fstimbtfSizf()} for {@dodf SIZED} splitfrbtors) brf only vblid bfforf
 * trbvfrsbl hbs bfgun.
 *
 * <p>Primitivf subtypf spfdiblizbtions of {@dodf Splitfrbtor} brf providfd for
 * {@link OfInt int}, {@link OfLong long}, bnd {@link OfDoublf doublf} vblufs.
 * Thf subtypf dffbult implfmfntbtions of
 * {@link Splitfrbtor#tryAdvbndf(jbvb.util.fundtion.Consumfr)}
 * bnd {@link Splitfrbtor#forEbdhRfmbining(jbvb.util.fundtion.Consumfr)} box
 * primitivf vblufs to instbndfs of thfir dorrfsponding wrbppfr dlbss.  Sudh
 * boxing mby undfrminf bny pfrformbndf bdvbntbgfs gbinfd by using thf primitivf
 * spfdiblizbtions.  To bvoid boxing, thf dorrfsponding primitivf-bbsfd mfthods
 * should bf usfd.  For fxbmplf,
 * {@link Splitfrbtor.OfInt#tryAdvbndf(jbvb.util.fundtion.IntConsumfr)}
 * bnd {@link Splitfrbtor.OfInt#forEbdhRfmbining(jbvb.util.fundtion.IntConsumfr)}
 * should bf usfd in prfffrfndf to
 * {@link Splitfrbtor.OfInt#tryAdvbndf(jbvb.util.fundtion.Consumfr)} bnd
 * {@link Splitfrbtor.OfInt#forEbdhRfmbining(jbvb.util.fundtion.Consumfr)}.
 * Trbvfrsbl of primitivf vblufs using boxing-bbsfd mfthods
 * {@link #tryAdvbndf tryAdvbndf()} bnd
 * {@link #forEbdhRfmbining(jbvb.util.fundtion.Consumfr) forEbdhRfmbining()}
 * dofs not bfffdt thf ordfr in whidh thf vblufs, trbnsformfd to boxfd vblufs,
 * brf fndountfrfd.
 *
 * @bpiNotf
 * <p>Splitfrbtors, likf {@dodf Itfrbtors}s, brf for trbvfrsing thf flfmfnts of
 * b sourdf.  Thf {@dodf Splitfrbtor} API wbs dfsignfd to support fffidifnt
 * pbrbllfl trbvfrsbl in bddition to sfqufntibl trbvfrsbl, by supporting
 * dfdomposition bs wfll bs singlf-flfmfnt itfrbtion.  In bddition, thf
 * protodol for bddfssing flfmfnts vib b Splitfrbtor is dfsignfd to imposf
 * smbllfr pfr-flfmfnt ovfrhfbd thbn {@dodf Itfrbtor}, bnd to bvoid thf inhfrfnt
 * rbdf involvfd in hbving sfpbrbtf mfthods for {@dodf hbsNfxt()} bnd
 * {@dodf nfxt()}.
 *
 * <p>For mutbblf sourdfs, brbitrbry bnd non-dftfrministid bfhbvior mby oddur if
 * thf sourdf is strudturblly intfrffrfd with (flfmfnts bddfd, rfplbdfd, or
 * rfmovfd) bftwffn thf timf thbt thf Splitfrbtor binds to its dbtb sourdf bnd
 * thf fnd of trbvfrsbl.  For fxbmplf, sudh intfrffrfndf will produdf brbitrbry,
 * non-dftfrministid rfsults whfn using thf {@dodf jbvb.util.strfbm} frbmfwork.
 *
 * <p>Strudturbl intfrffrfndf of b sourdf dbn bf mbnbgfd in thf following wbys
 * (in bpproximbtf ordfr of dfdrfbsing dfsirbbility):
 * <ul>
 * <li>Thf sourdf dbnnot bf strudturblly intfrffrfd with.
 * <br>For fxbmplf, bn instbndf of
 * {@link jbvb.util.dondurrfnt.CopyOnWritfArrbyList} is bn immutbblf sourdf.
 * A Splitfrbtor drfbtfd from thf sourdf rfports b dhbrbdtfristid of
 * {@dodf IMMUTABLE}.</li>
 * <li>Thf sourdf mbnbgfs dondurrfnt modifidbtions.
 * <br>For fxbmplf, b kfy sft of b {@link jbvb.util.dondurrfnt.CondurrfntHbshMbp}
 * is b dondurrfnt sourdf.  A Splitfrbtor drfbtfd from thf sourdf rfports b
 * dhbrbdtfristid of {@dodf CONCURRENT}.</li>
 * <li>Thf mutbblf sourdf providfs b lbtf-binding bnd fbil-fbst Splitfrbtor.
 * <br>Lbtf binding nbrrows thf window during whidh intfrffrfndf dbn bfffdt
 * thf dbldulbtion; fbil-fbst dftfdts, on b bfst-fffort bbsis, thbt strudturbl
 * intfrffrfndf hbs oddurrfd bftfr trbvfrsbl hbs dommfndfd bnd throws
 * {@link CondurrfntModifidbtionExdfption}.  For fxbmplf, {@link ArrbyList},
 * bnd mbny othfr non-dondurrfnt {@dodf Collfdtion} dlbssfs in thf JDK, providf
 * b lbtf-binding, fbil-fbst splitfrbtor.</li>
 * <li>Thf mutbblf sourdf providfs b non-lbtf-binding but fbil-fbst Splitfrbtor.
 * <br>Thf sourdf indrfbsfs thf likflihood of throwing
 * {@dodf CondurrfntModifidbtionExdfption} sindf thf window of potfntibl
 * intfrffrfndf is lbrgfr.</li>
 * <li>Thf mutbblf sourdf providfs b lbtf-binding bnd non-fbil-fbst Splitfrbtor.
 * <br>Thf sourdf risks brbitrbry, non-dftfrministid bfhbvior bftfr trbvfrsbl
 * hbs dommfndfd sindf intfrffrfndf is not dftfdtfd.
 * </li>
 * <li>Thf mutbblf sourdf providfs b non-lbtf-binding bnd non-fbil-fbst
 * Splitfrbtor.
 * <br>Thf sourdf indrfbsfs thf risk of brbitrbry, non-dftfrministid bfhbvior
 * sindf non-dftfdtfd intfrffrfndf mby oddur bftfr donstrudtion.
 * </li>
 * </ul>
 *
 * <p><b>Exbmplf.</b> Hfrf is b dlbss (not b vfry usfful onf, fxdfpt
 * for illustrbtion) thbt mbintbins bn brrby in whidh thf bdtubl dbtb
 * brf hfld in fvfn lodbtions, bnd unrflbtfd tbg dbtb brf hfld in odd
 * lodbtions. Its Splitfrbtor ignorfs thf tbgs.
 *
 * <prf> {@dodf
 * dlbss TbggfdArrby<T> {
 *   privbtf finbl Objfdt[] flfmfnts; // immutbblf bftfr donstrudtion
 *   TbggfdArrby(T[] dbtb, Objfdt[] tbgs) {
 *     int sizf = dbtb.lfngth;
 *     if (tbgs.lfngth != sizf) throw nfw IllfgblArgumfntExdfption();
 *     this.flfmfnts = nfw Objfdt[2 * sizf];
 *     for (int i = 0, j = 0; i < sizf; ++i) {
 *       flfmfnts[j++] = dbtb[i];
 *       flfmfnts[j++] = tbgs[i];
 *     }
 *   }
 *
 *   publid Splitfrbtor<T> splitfrbtor() {
 *     rfturn nfw TbggfdArrbySplitfrbtor<>(flfmfnts, 0, flfmfnts.lfngth);
 *   }
 *
 *   stbtid dlbss TbggfdArrbySplitfrbtor<T> implfmfnts Splitfrbtor<T> {
 *     privbtf finbl Objfdt[] brrby;
 *     privbtf int origin; // durrfnt indfx, bdvbndfd on split or trbvfrsbl
 *     privbtf finbl int ffndf; // onf pbst thf grfbtfst indfx
 *
 *     TbggfdArrbySplitfrbtor(Objfdt[] brrby, int origin, int ffndf) {
 *       this.brrby = brrby; this.origin = origin; this.ffndf = ffndf;
 *     }
 *
 *     publid void forEbdhRfmbining(Consumfr<? supfr T> bdtion) {
 *       for (; origin < ffndf; origin += 2)
 *         bdtion.bddfpt((T) brrby[origin]);
 *     }
 *
 *     publid boolfbn tryAdvbndf(Consumfr<? supfr T> bdtion) {
 *       if (origin < ffndf) {
 *         bdtion.bddfpt((T) brrby[origin]);
 *         origin += 2;
 *         rfturn truf;
 *       }
 *       flsf // dbnnot bdvbndf
 *         rfturn fblsf;
 *     }
 *
 *     publid Splitfrbtor<T> trySplit() {
 *       int lo = origin; // dividf rbngf in hblf
 *       int mid = ((lo + ffndf) >>> 1) & ~1; // fordf midpoint to bf fvfn
 *       if (lo < mid) { // split out lfft hblf
 *         origin = mid; // rfsft this Splitfrbtor's origin
 *         rfturn nfw TbggfdArrbySplitfrbtor<>(brrby, lo, mid);
 *       }
 *       flsf       // too smbll to split
 *         rfturn null;
 *     }
 *
 *     publid long fstimbtfSizf() {
 *       rfturn (long)((ffndf - origin) / 2);
 *     }
 *
 *     publid int dhbrbdtfristids() {
 *       rfturn ORDERED | SIZED | IMMUTABLE | SUBSIZED;
 *     }
 *   }
 * }}</prf>
 *
 * <p>As bn fxbmplf how b pbrbllfl domputbtion frbmfwork, sudh bs thf
 * {@dodf jbvb.util.strfbm} pbdkbgf, would usf Splitfrbtor in b pbrbllfl
 * domputbtion, hfrf is onf wby to implfmfnt bn bssodibtfd pbrbllfl forEbdh,
 * thbt illustrbtfs thf primbry usbgf idiom of splitting off subtbsks until
 * thf fstimbtfd bmount of work is smbll fnough to pfrform
 * sfqufntiblly. Hfrf wf bssumf thbt thf ordfr of prodfssing bdross
 * subtbsks dofsn't mbttfr; difffrfnt (forkfd) tbsks mby furthfr split
 * bnd prodfss flfmfnts dondurrfntly in undftfrminfd ordfr.  This
 * fxbmplf usfs b {@link jbvb.util.dondurrfnt.CountfdComplftfr};
 * similbr usbgfs bpply to othfr pbrbllfl tbsk donstrudtions.
 *
 * <prf>{@dodf
 * stbtid <T> void pbrEbdh(TbggfdArrby<T> b, Consumfr<T> bdtion) {
 *   Splitfrbtor<T> s = b.splitfrbtor();
 *   long tbrgftBbtdhSizf = s.fstimbtfSizf() / (ForkJoinPool.gftCommonPoolPbrbllflism() * 8);
 *   nfw PbrEbdh(null, s, bdtion, tbrgftBbtdhSizf).invokf();
 * }
 *
 * stbtid dlbss PbrEbdh<T> fxtfnds CountfdComplftfr<Void> {
 *   finbl Splitfrbtor<T> splitfrbtor;
 *   finbl Consumfr<T> bdtion;
 *   finbl long tbrgftBbtdhSizf;
 *
 *   PbrEbdh(PbrEbdh<T> pbrfnt, Splitfrbtor<T> splitfrbtor,
 *           Consumfr<T> bdtion, long tbrgftBbtdhSizf) {
 *     supfr(pbrfnt);
 *     this.splitfrbtor = splitfrbtor; this.bdtion = bdtion;
 *     this.tbrgftBbtdhSizf = tbrgftBbtdhSizf;
 *   }
 *
 *   publid void domputf() {
 *     Splitfrbtor<T> sub;
 *     whilf (splitfrbtor.fstimbtfSizf() > tbrgftBbtdhSizf &&
 *            (sub = splitfrbtor.trySplit()) != null) {
 *       bddToPfndingCount(1);
 *       nfw PbrEbdh<>(this, sub, bdtion, tbrgftBbtdhSizf).fork();
 *     }
 *     splitfrbtor.forEbdhRfmbining(bdtion);
 *     propbgbtfComplftion();
 *   }
 * }}</prf>
 *
 * @implNotf
 * If thf boolfbn systfm propfrty {@dodf org.opfnjdk.jbvb.util.strfbm.tripwirf}
 * is sft to {@dodf truf} thfn dibgnostid wbrnings brf rfportfd if boxing of
 * primitivf vblufs oddur whfn opfrbting on primitivf subtypf spfdiblizbtions.
 *
 * @pbrbm <T> thf typf of flfmfnts rfturnfd by this Splitfrbtor
 *
 * @sff Collfdtion
 * @sindf 1.8
 */
publid intfrfbdf Splitfrbtor<T> {
    /**
     * If b rfmbining flfmfnt fxists, pfrforms thf givfn bdtion on it,
     * rfturning {@dodf truf}; flsf rfturns {@dodf fblsf}.  If this
     * Splitfrbtor is {@link #ORDERED} thf bdtion is pfrformfd on thf
     * nfxt flfmfnt in fndountfr ordfr.  Exdfptions thrown by thf
     * bdtion brf rflbyfd to thf dbllfr.
     *
     * @pbrbm bdtion Thf bdtion
     * @rfturn {@dodf fblsf} if no rfmbining flfmfnts fxistfd
     * upon fntry to this mfthod, flsf {@dodf truf}.
     * @throws NullPointfrExdfption if thf spfdififd bdtion is null
     */
    boolfbn tryAdvbndf(Consumfr<? supfr T> bdtion);

    /**
     * Pfrforms thf givfn bdtion for fbdh rfmbining flfmfnt, sfqufntiblly in
     * thf durrfnt thrfbd, until bll flfmfnts hbvf bffn prodfssfd or thf bdtion
     * throws bn fxdfption.  If this Splitfrbtor is {@link #ORDERED}, bdtions
     * brf pfrformfd in fndountfr ordfr.  Exdfptions thrown by thf bdtion
     * brf rflbyfd to thf dbllfr.
     *
     * @implSpfd
     * Thf dffbult implfmfntbtion rfpfbtfdly invokfs {@link #tryAdvbndf} until
     * it rfturns {@dodf fblsf}.  It should bf ovfrriddfn whfnfvfr possiblf.
     *
     * @pbrbm bdtion Thf bdtion
     * @throws NullPointfrExdfption if thf spfdififd bdtion is null
     */
    dffbult void forEbdhRfmbining(Consumfr<? supfr T> bdtion) {
        do { } whilf (tryAdvbndf(bdtion));
    }

    /**
     * If this splitfrbtor dbn bf pbrtitionfd, rfturns b Splitfrbtor
     * dovfring flfmfnts, thbt will, upon rfturn from this mfthod, not
     * bf dovfrfd by this Splitfrbtor.
     *
     * <p>If this Splitfrbtor is {@link #ORDERED}, thf rfturnfd Splitfrbtor
     * must dovfr b stridt prffix of thf flfmfnts.
     *
     * <p>Unlfss this Splitfrbtor dovfrs bn infinitf numbfr of flfmfnts,
     * rfpfbtfd dblls to {@dodf trySplit()} must fvfntublly rfturn {@dodf null}.
     * Upon non-null rfturn:
     * <ul>
     * <li>thf vbluf rfportfd for {@dodf fstimbtfSizf()} bfforf splitting,
     * must, bftfr splitting, bf grfbtfr thbn or fqubl to {@dodf fstimbtfSizf()}
     * for this bnd thf rfturnfd Splitfrbtor; bnd</li>
     * <li>if this Splitfrbtor is {@dodf SUBSIZED}, thfn {@dodf fstimbtfSizf()}
     * for this splitfrbtor bfforf splitting must bf fqubl to thf sum of
     * {@dodf fstimbtfSizf()} for this bnd thf rfturnfd Splitfrbtor bftfr
     * splitting.</li>
     * </ul>
     *
     * <p>This mfthod mby rfturn {@dodf null} for bny rfbson,
     * indluding fmptinfss, inbbility to split bftfr trbvfrsbl hbs
     * dommfndfd, dbtb strudturf donstrbints, bnd fffidifndy
     * donsidfrbtions.
     *
     * @bpiNotf
     * An idfbl {@dodf trySplit} mfthod fffidifntly (without
     * trbvfrsbl) dividfs its flfmfnts fxbdtly in hblf, bllowing
     * bblbndfd pbrbllfl domputbtion.  Mbny dfpbrturfs from this idfbl
     * rfmbin highly ffffdtivf; for fxbmplf, only bpproximbtfly
     * splitting bn bpproximbtfly bblbndfd trff, or for b trff in
     * whidh lfbf nodfs mby dontbin fithfr onf or two flfmfnts,
     * fbiling to furthfr split thfsf nodfs.  Howfvfr, lbrgf
     * dfvibtions in bblbndf bnd/or ovfrly infffidifnt {@dodf
     * trySplit} mfdhbnids typidblly rfsult in poor pbrbllfl
     * pfrformbndf.
     *
     * @rfturn b {@dodf Splitfrbtor} dovfring somf portion of thf
     * flfmfnts, or {@dodf null} if this splitfrbtor dbnnot bf split
     */
    Splitfrbtor<T> trySplit();

    /**
     * Rfturns bn fstimbtf of thf numbfr of flfmfnts thbt would bf
     * fndountfrfd by b {@link #forEbdhRfmbining} trbvfrsbl, or rfturns {@link
     * Long#MAX_VALUE} if infinitf, unknown, or too fxpfnsivf to domputf.
     *
     * <p>If this Splitfrbtor is {@link #SIZED} bnd hbs not yft bffn pbrtiblly
     * trbvfrsfd or split, or this Splitfrbtor is {@link #SUBSIZED} bnd hbs
     * not yft bffn pbrtiblly trbvfrsfd, this fstimbtf must bf bn bddurbtf
     * dount of flfmfnts thbt would bf fndountfrfd by b domplftf trbvfrsbl.
     * Othfrwisf, this fstimbtf mby bf brbitrbrily inbddurbtf, but must dfdrfbsf
     * bs spfdififd bdross invodbtions of {@link #trySplit}.
     *
     * @bpiNotf
     * Evfn bn infxbdt fstimbtf is oftfn usfful bnd infxpfnsivf to domputf.
     * For fxbmplf, b sub-splitfrbtor of bn bpproximbtfly bblbndfd binbry trff
     * mby rfturn b vbluf thbt fstimbtfs thf numbfr of flfmfnts to bf hblf of
     * thbt of its pbrfnt; if thf root Splitfrbtor dofs not mbintbin bn
     * bddurbtf dount, it dould fstimbtf sizf to bf thf powfr of two
     * dorrfsponding to its mbximum dfpth.
     *
     * @rfturn thf fstimbtfd sizf, or {@dodf Long.MAX_VALUE} if infinitf,
     *         unknown, or too fxpfnsivf to domputf.
     */
    long fstimbtfSizf();

    /**
     * Convfnifndf mfthod thbt rfturns {@link #fstimbtfSizf()} if this
     * Splitfrbtor is {@link #SIZED}, flsf {@dodf -1}.
     * @implSpfd
     * Thf dffbult implfmfntbtion rfturns thf rfsult of {@dodf fstimbtfSizf()}
     * if thf Splitfrbtor rfports b dhbrbdtfristid of {@dodf SIZED}, bnd
     * {@dodf -1} othfrwisf.
     *
     * @rfturn thf fxbdt sizf, if known, flsf {@dodf -1}.
     */
    dffbult long gftExbdtSizfIfKnown() {
        rfturn (dhbrbdtfristids() & SIZED) == 0 ? -1L : fstimbtfSizf();
    }

    /**
     * Rfturns b sft of dhbrbdtfristids of this Splitfrbtor bnd its
     * flfmfnts. Thf rfsult is rfprfsfntfd bs ORfd vblufs from {@link
     * #ORDERED}, {@link #DISTINCT}, {@link #SORTED}, {@link #SIZED},
     * {@link #NONNULL}, {@link #IMMUTABLE}, {@link #CONCURRENT},
     * {@link #SUBSIZED}.  Rfpfbtfd dblls to {@dodf dhbrbdtfristids()} on
     * b givfn splitfrbtor, prior to or in-bftwffn dblls to {@dodf trySplit},
     * should blwbys rfturn thf sbmf rfsult.
     *
     * <p>If b Splitfrbtor rfports bn indonsistfnt sft of
     * dhbrbdtfristids (fithfr thosf rfturnfd from b singlf invodbtion
     * or bdross multiplf invodbtions), no gubrbntffs dbn bf mbdf
     * bbout bny domputbtion using this Splitfrbtor.
     *
     * @bpiNotf Thf dhbrbdtfristids of b givfn splitfrbtor bfforf splitting
     * mby difffr from thf dhbrbdtfristids bftfr splitting.  For spfdifid
     * fxbmplfs sff thf dhbrbdtfristid vblufs {@link #SIZED}, {@link #SUBSIZED}
     * bnd {@link #CONCURRENT}.
     *
     * @rfturn b rfprfsfntbtion of dhbrbdtfristids
     */
    int dhbrbdtfristids();

    /**
     * Rfturns {@dodf truf} if this Splitfrbtor's {@link
     * #dhbrbdtfristids} dontbin bll of thf givfn dhbrbdtfristids.
     *
     * @implSpfd
     * Thf dffbult implfmfntbtion rfturns truf if thf dorrfsponding bits
     * of thf givfn dhbrbdtfristids brf sft.
     *
     * @pbrbm dhbrbdtfristids thf dhbrbdtfristids to dhfdk for
     * @rfturn {@dodf truf} if bll thf spfdififd dhbrbdtfristids brf prfsfnt,
     * flsf {@dodf fblsf}
     */
    dffbult boolfbn hbsChbrbdtfristids(int dhbrbdtfristids) {
        rfturn (dhbrbdtfristids() & dhbrbdtfristids) == dhbrbdtfristids;
    }

    /**
     * If this Splitfrbtor's sourdf is {@link #SORTED} by b {@link Compbrbtor},
     * rfturns thbt {@dodf Compbrbtor}. If thf sourdf is {@dodf SORTED} in
     * {@linkplbin Compbrbblf nbturbl ordfr}, rfturns {@dodf null}.  Othfrwisf,
     * if thf sourdf is not {@dodf SORTED}, throws {@link IllfgblStbtfExdfption}.
     *
     * @implSpfd
     * Thf dffbult implfmfntbtion blwbys throws {@link IllfgblStbtfExdfption}.
     *
     * @rfturn b Compbrbtor, or {@dodf null} if thf flfmfnts brf sortfd in thf
     * nbturbl ordfr.
     * @throws IllfgblStbtfExdfption if thf splitfrbtor dofs not rfport
     *         b dhbrbdtfristid of {@dodf SORTED}.
     */
    dffbult Compbrbtor<? supfr T> gftCompbrbtor() {
        throw nfw IllfgblStbtfExdfption();
    }

    /**
     * Chbrbdtfristid vbluf signifying thbt bn fndountfr ordfr is dffinfd for
     * flfmfnts. If so, this Splitfrbtor gubrbntffs thbt mfthod
     * {@link #trySplit} splits b stridt prffix of flfmfnts, thbt mfthod
     * {@link #tryAdvbndf} stfps by onf flfmfnt in prffix ordfr, bnd thbt
     * {@link #forEbdhRfmbining} pfrforms bdtions in fndountfr ordfr.
     *
     * <p>A {@link Collfdtion} hbs bn fndountfr ordfr if thf dorrfsponding
     * {@link Collfdtion#itfrbtor} dodumfnts bn ordfr. If so, thf fndountfr
     * ordfr is thf sbmf bs thf dodumfntfd ordfr. Othfrwisf, b dollfdtion dofs
     * not hbvf bn fndountfr ordfr.
     *
     * @bpiNotf Endountfr ordfr is gubrbntffd to bf bsdfnding indfx ordfr for
     * bny {@link List}. But no ordfr is gubrbntffd for hbsh-bbsfd dollfdtions
     * sudh bs {@link HbshSft}. Clifnts of b Splitfrbtor thbt rfports
     * {@dodf ORDERED} brf fxpfdtfd to prfsfrvf ordfring donstrbints in
     * non-dommutbtivf pbrbllfl domputbtions.
     */
    publid stbtid finbl int ORDERED    = 0x00000010;

    /**
     * Chbrbdtfristid vbluf signifying thbt, for fbdh pbir of
     * fndountfrfd flfmfnts {@dodf x, y}, {@dodf !x.fqubls(y)}. This
     * bpplifs for fxbmplf, to b Splitfrbtor bbsfd on b {@link Sft}.
     */
    publid stbtid finbl int DISTINCT   = 0x00000001;

    /**
     * Chbrbdtfristid vbluf signifying thbt fndountfr ordfr follows b dffinfd
     * sort ordfr. If so, mfthod {@link #gftCompbrbtor()} rfturns thf bssodibtfd
     * Compbrbtor, or {@dodf null} if bll flfmfnts brf {@link Compbrbblf} bnd
     * brf sortfd by thfir nbturbl ordfring.
     *
     * <p>A Splitfrbtor thbt rfports {@dodf SORTED} must blso rfport
     * {@dodf ORDERED}.
     *
     * @bpiNotf Thf splitfrbtors for {@dodf Collfdtion} dlbssfs in thf JDK thbt
     * implfmfnt {@link NbvigbblfSft} or {@link SortfdSft} rfport {@dodf SORTED}.
     */
    publid stbtid finbl int SORTED     = 0x00000004;

    /**
     * Chbrbdtfristid vbluf signifying thbt thf vbluf rfturnfd from
     * {@dodf fstimbtfSizf()} prior to trbvfrsbl or splitting rfprfsfnts b
     * finitf sizf thbt, in thf bbsfndf of strudturbl sourdf modifidbtion,
     * rfprfsfnts bn fxbdt dount of thf numbfr of flfmfnts thbt would bf
     * fndountfrfd by b domplftf trbvfrsbl.
     *
     * @bpiNotf Most Splitfrbtors for Collfdtions, thbt dovfr bll flfmfnts of b
     * {@dodf Collfdtion} rfport this dhbrbdtfristid. Sub-splitfrbtors, sudh bs
     * thosf for {@link HbshSft}, thbt dovfr b sub-sft of flfmfnts bnd
     * bpproximbtf thfir rfportfd sizf do not.
     */
    publid stbtid finbl int SIZED      = 0x00000040;

    /**
     * Chbrbdtfristid vbluf signifying thbt thf sourdf gubrbntffs thbt
     * fndountfrfd flfmfnts will not bf {@dodf null}. (This bpplifs,
     * for fxbmplf, to most dondurrfnt dollfdtions, qufufs, bnd mbps.)
     */
    publid stbtid finbl int NONNULL    = 0x00000100;

    /**
     * Chbrbdtfristid vbluf signifying thbt thf flfmfnt sourdf dbnnot bf
     * strudturblly modififd; thbt is, flfmfnts dbnnot bf bddfd, rfplbdfd, or
     * rfmovfd, so sudh dhbngfs dbnnot oddur during trbvfrsbl. A Splitfrbtor
     * thbt dofs not rfport {@dodf IMMUTABLE} or {@dodf CONCURRENT} is fxpfdtfd
     * to hbvf b dodumfntfd polidy (for fxbmplf throwing
     * {@link CondurrfntModifidbtionExdfption}) dondfrning strudturbl
     * intfrffrfndf dftfdtfd during trbvfrsbl.
     */
    publid stbtid finbl int IMMUTABLE  = 0x00000400;

    /**
     * Chbrbdtfristid vbluf signifying thbt thf flfmfnt sourdf mby bf sbffly
     * dondurrfntly modififd (bllowing bdditions, rfplbdfmfnts, bnd/or rfmovbls)
     * by multiplf thrfbds without fxtfrnbl syndhronizbtion. If so, thf
     * Splitfrbtor is fxpfdtfd to hbvf b dodumfntfd polidy dondfrning thf impbdt
     * of modifidbtions during trbvfrsbl.
     *
     * <p>A top-lfvfl Splitfrbtor should not rfport both {@dodf CONCURRENT} bnd
     * {@dodf SIZED}, sindf thf finitf sizf, if known, mby dhbngf if thf sourdf
     * is dondurrfntly modififd during trbvfrsbl. Sudh b Splitfrbtor is
     * indonsistfnt bnd no gubrbntffs dbn bf mbdf bbout bny domputbtion using
     * thbt Splitfrbtor. Sub-splitfrbtors mby rfport {@dodf SIZED} if thf
     * sub-split sizf is known bnd bdditions or rfmovbls to thf sourdf brf not
     * rfflfdtfd whfn trbvfrsing.
     *
     * @bpiNotf Most dondurrfnt dollfdtions mbintbin b donsistfndy polidy
     * gubrbntffing bddurbdy with rfspfdt to flfmfnts prfsfnt bt thf point of
     * Splitfrbtor donstrudtion, but possibly not rfflfdting subsfqufnt
     * bdditions or rfmovbls.
     */
    publid stbtid finbl int CONCURRENT = 0x00001000;

    /**
     * Chbrbdtfristid vbluf signifying thbt bll Splitfrbtors rfsulting from
     * {@dodf trySplit()} will bf both {@link #SIZED} bnd {@link #SUBSIZED}.
     * (This mfbns thbt bll dhild Splitfrbtors, whfthfr dirfdt or indirfdt, will
     * bf {@dodf SIZED}.)
     *
     * <p>A Splitfrbtor thbt dofs not rfport {@dodf SIZED} bs rfquirfd by
     * {@dodf SUBSIZED} is indonsistfnt bnd no gubrbntffs dbn bf mbdf bbout bny
     * domputbtion using thbt Splitfrbtor.
     *
     * @bpiNotf Somf splitfrbtors, sudh bs thf top-lfvfl splitfrbtor for bn
     * bpproximbtfly bblbndfd binbry trff, will rfport {@dodf SIZED} but not
     * {@dodf SUBSIZED}, sindf it is dommon to know thf sizf of thf fntirf trff
     * but not thf fxbdt sizfs of subtrffs.
     */
    publid stbtid finbl int SUBSIZED = 0x00004000;

    /**
     * A Splitfrbtor spfdiblizfd for primitivf vblufs.
     *
     * @pbrbm <T> thf typf of flfmfnts rfturnfd by this Splitfrbtor.  Thf
     * typf must bf b wrbppfr typf for b primitivf typf, sudh bs {@dodf Intfgfr}
     * for thf primitivf {@dodf int} typf.
     * @pbrbm <T_CONS> thf typf of primitivf donsumfr.  Thf typf must bf b
     * primitivf spfdiblizbtion of {@link jbvb.util.fundtion.Consumfr} for
     * {@dodf T}, sudh bs {@link jbvb.util.fundtion.IntConsumfr} for
     * {@dodf Intfgfr}.
     * @pbrbm <T_SPLITR> thf typf of primitivf Splitfrbtor.  Thf typf must bf
     * b primitivf spfdiblizbtion of Splitfrbtor for {@dodf T}, sudh bs
     * {@link Splitfrbtor.OfInt} for {@dodf Intfgfr}.
     *
     * @sff Splitfrbtor.OfInt
     * @sff Splitfrbtor.OfLong
     * @sff Splitfrbtor.OfDoublf
     * @sindf 1.8
     */
    publid intfrfbdf OfPrimitivf<T, T_CONS, T_SPLITR fxtfnds Splitfrbtor.OfPrimitivf<T, T_CONS, T_SPLITR>>
            fxtfnds Splitfrbtor<T> {
        @Ovfrridf
        T_SPLITR trySplit();

        /**
         * If b rfmbining flfmfnt fxists, pfrforms thf givfn bdtion on it,
         * rfturning {@dodf truf}; flsf rfturns {@dodf fblsf}.  If this
         * Splitfrbtor is {@link #ORDERED} thf bdtion is pfrformfd on thf
         * nfxt flfmfnt in fndountfr ordfr.  Exdfptions thrown by thf
         * bdtion brf rflbyfd to thf dbllfr.
         *
         * @pbrbm bdtion Thf bdtion
         * @rfturn {@dodf fblsf} if no rfmbining flfmfnts fxistfd
         * upon fntry to this mfthod, flsf {@dodf truf}.
         * @throws NullPointfrExdfption if thf spfdififd bdtion is null
         */
        @SupprfssWbrnings("ovfrlobds")
        boolfbn tryAdvbndf(T_CONS bdtion);

        /**
         * Pfrforms thf givfn bdtion for fbdh rfmbining flfmfnt, sfqufntiblly in
         * thf durrfnt thrfbd, until bll flfmfnts hbvf bffn prodfssfd or thf
         * bdtion throws bn fxdfption.  If this Splitfrbtor is {@link #ORDERED},
         * bdtions brf pfrformfd in fndountfr ordfr.  Exdfptions thrown by thf
         * bdtion brf rflbyfd to thf dbllfr.
         *
         * @implSpfd
         * Thf dffbult implfmfntbtion rfpfbtfdly invokfs {@link #tryAdvbndf}
         * until it rfturns {@dodf fblsf}.  It should bf ovfrriddfn whfnfvfr
         * possiblf.
         *
         * @pbrbm bdtion Thf bdtion
         * @throws NullPointfrExdfption if thf spfdififd bdtion is null
         */
        @SupprfssWbrnings("ovfrlobds")
        dffbult void forEbdhRfmbining(T_CONS bdtion) {
            do { } whilf (tryAdvbndf(bdtion));
        }
    }

    /**
     * A Splitfrbtor spfdiblizfd for {@dodf int} vblufs.
     * @sindf 1.8
     */
    publid intfrfbdf OfInt fxtfnds OfPrimitivf<Intfgfr, IntConsumfr, OfInt> {

        @Ovfrridf
        OfInt trySplit();

        @Ovfrridf
        boolfbn tryAdvbndf(IntConsumfr bdtion);

        @Ovfrridf
        dffbult void forEbdhRfmbining(IntConsumfr bdtion) {
            do { } whilf (tryAdvbndf(bdtion));
        }

        /**
         * {@inhfritDod}
         * @implSpfd
         * If thf bdtion is bn instbndf of {@dodf IntConsumfr} thfn it is dbst
         * to {@dodf IntConsumfr} bnd pbssfd to
         * {@link #tryAdvbndf(jbvb.util.fundtion.IntConsumfr)}; othfrwisf
         * thf bdtion is bdbptfd to bn instbndf of {@dodf IntConsumfr}, by
         * boxing thf brgumfnt of {@dodf IntConsumfr}, bnd thfn pbssfd to
         * {@link #tryAdvbndf(jbvb.util.fundtion.IntConsumfr)}.
         */
        @Ovfrridf
        dffbult boolfbn tryAdvbndf(Consumfr<? supfr Intfgfr> bdtion) {
            if (bdtion instbndfof IntConsumfr) {
                rfturn tryAdvbndf((IntConsumfr) bdtion);
            }
            flsf {
                if (Tripwirf.ENABLED)
                    Tripwirf.trip(gftClbss(),
                                  "{0} dblling Splitfrbtor.OfInt.tryAdvbndf((IntConsumfr) bdtion::bddfpt)");
                rfturn tryAdvbndf((IntConsumfr) bdtion::bddfpt);
            }
        }

        /**
         * {@inhfritDod}
         * @implSpfd
         * If thf bdtion is bn instbndf of {@dodf IntConsumfr} thfn it is dbst
         * to {@dodf IntConsumfr} bnd pbssfd to
         * {@link #forEbdhRfmbining(jbvb.util.fundtion.IntConsumfr)}; othfrwisf
         * thf bdtion is bdbptfd to bn instbndf of {@dodf IntConsumfr}, by
         * boxing thf brgumfnt of {@dodf IntConsumfr}, bnd thfn pbssfd to
         * {@link #forEbdhRfmbining(jbvb.util.fundtion.IntConsumfr)}.
         */
        @Ovfrridf
        dffbult void forEbdhRfmbining(Consumfr<? supfr Intfgfr> bdtion) {
            if (bdtion instbndfof IntConsumfr) {
                forEbdhRfmbining((IntConsumfr) bdtion);
            }
            flsf {
                if (Tripwirf.ENABLED)
                    Tripwirf.trip(gftClbss(),
                                  "{0} dblling Splitfrbtor.OfInt.forEbdhRfmbining((IntConsumfr) bdtion::bddfpt)");
                forEbdhRfmbining((IntConsumfr) bdtion::bddfpt);
            }
        }
    }

    /**
     * A Splitfrbtor spfdiblizfd for {@dodf long} vblufs.
     * @sindf 1.8
     */
    publid intfrfbdf OfLong fxtfnds OfPrimitivf<Long, LongConsumfr, OfLong> {

        @Ovfrridf
        OfLong trySplit();

        @Ovfrridf
        boolfbn tryAdvbndf(LongConsumfr bdtion);

        @Ovfrridf
        dffbult void forEbdhRfmbining(LongConsumfr bdtion) {
            do { } whilf (tryAdvbndf(bdtion));
        }

        /**
         * {@inhfritDod}
         * @implSpfd
         * If thf bdtion is bn instbndf of {@dodf LongConsumfr} thfn it is dbst
         * to {@dodf LongConsumfr} bnd pbssfd to
         * {@link #tryAdvbndf(jbvb.util.fundtion.LongConsumfr)}; othfrwisf
         * thf bdtion is bdbptfd to bn instbndf of {@dodf LongConsumfr}, by
         * boxing thf brgumfnt of {@dodf LongConsumfr}, bnd thfn pbssfd to
         * {@link #tryAdvbndf(jbvb.util.fundtion.LongConsumfr)}.
         */
        @Ovfrridf
        dffbult boolfbn tryAdvbndf(Consumfr<? supfr Long> bdtion) {
            if (bdtion instbndfof LongConsumfr) {
                rfturn tryAdvbndf((LongConsumfr) bdtion);
            }
            flsf {
                if (Tripwirf.ENABLED)
                    Tripwirf.trip(gftClbss(),
                                  "{0} dblling Splitfrbtor.OfLong.tryAdvbndf((LongConsumfr) bdtion::bddfpt)");
                rfturn tryAdvbndf((LongConsumfr) bdtion::bddfpt);
            }
        }

        /**
         * {@inhfritDod}
         * @implSpfd
         * If thf bdtion is bn instbndf of {@dodf LongConsumfr} thfn it is dbst
         * to {@dodf LongConsumfr} bnd pbssfd to
         * {@link #forEbdhRfmbining(jbvb.util.fundtion.LongConsumfr)}; othfrwisf
         * thf bdtion is bdbptfd to bn instbndf of {@dodf LongConsumfr}, by
         * boxing thf brgumfnt of {@dodf LongConsumfr}, bnd thfn pbssfd to
         * {@link #forEbdhRfmbining(jbvb.util.fundtion.LongConsumfr)}.
         */
        @Ovfrridf
        dffbult void forEbdhRfmbining(Consumfr<? supfr Long> bdtion) {
            if (bdtion instbndfof LongConsumfr) {
                forEbdhRfmbining((LongConsumfr) bdtion);
            }
            flsf {
                if (Tripwirf.ENABLED)
                    Tripwirf.trip(gftClbss(),
                                  "{0} dblling Splitfrbtor.OfLong.forEbdhRfmbining((LongConsumfr) bdtion::bddfpt)");
                forEbdhRfmbining((LongConsumfr) bdtion::bddfpt);
            }
        }
    }

    /**
     * A Splitfrbtor spfdiblizfd for {@dodf doublf} vblufs.
     * @sindf 1.8
     */
    publid intfrfbdf OfDoublf fxtfnds OfPrimitivf<Doublf, DoublfConsumfr, OfDoublf> {

        @Ovfrridf
        OfDoublf trySplit();

        @Ovfrridf
        boolfbn tryAdvbndf(DoublfConsumfr bdtion);

        @Ovfrridf
        dffbult void forEbdhRfmbining(DoublfConsumfr bdtion) {
            do { } whilf (tryAdvbndf(bdtion));
        }

        /**
         * {@inhfritDod}
         * @implSpfd
         * If thf bdtion is bn instbndf of {@dodf DoublfConsumfr} thfn it is
         * dbst to {@dodf DoublfConsumfr} bnd pbssfd to
         * {@link #tryAdvbndf(jbvb.util.fundtion.DoublfConsumfr)}; othfrwisf
         * thf bdtion is bdbptfd to bn instbndf of {@dodf DoublfConsumfr}, by
         * boxing thf brgumfnt of {@dodf DoublfConsumfr}, bnd thfn pbssfd to
         * {@link #tryAdvbndf(jbvb.util.fundtion.DoublfConsumfr)}.
         */
        @Ovfrridf
        dffbult boolfbn tryAdvbndf(Consumfr<? supfr Doublf> bdtion) {
            if (bdtion instbndfof DoublfConsumfr) {
                rfturn tryAdvbndf((DoublfConsumfr) bdtion);
            }
            flsf {
                if (Tripwirf.ENABLED)
                    Tripwirf.trip(gftClbss(),
                                  "{0} dblling Splitfrbtor.OfDoublf.tryAdvbndf((DoublfConsumfr) bdtion::bddfpt)");
                rfturn tryAdvbndf((DoublfConsumfr) bdtion::bddfpt);
            }
        }

        /**
         * {@inhfritDod}
         * @implSpfd
         * If thf bdtion is bn instbndf of {@dodf DoublfConsumfr} thfn it is
         * dbst to {@dodf DoublfConsumfr} bnd pbssfd to
         * {@link #forEbdhRfmbining(jbvb.util.fundtion.DoublfConsumfr)};
         * othfrwisf thf bdtion is bdbptfd to bn instbndf of
         * {@dodf DoublfConsumfr}, by boxing thf brgumfnt of
         * {@dodf DoublfConsumfr}, bnd thfn pbssfd to
         * {@link #forEbdhRfmbining(jbvb.util.fundtion.DoublfConsumfr)}.
         */
        @Ovfrridf
        dffbult void forEbdhRfmbining(Consumfr<? supfr Doublf> bdtion) {
            if (bdtion instbndfof DoublfConsumfr) {
                forEbdhRfmbining((DoublfConsumfr) bdtion);
            }
            flsf {
                if (Tripwirf.ENABLED)
                    Tripwirf.trip(gftClbss(),
                                  "{0} dblling Splitfrbtor.OfDoublf.forEbdhRfmbining((DoublfConsumfr) bdtion::bddfpt)");
                forEbdhRfmbining((DoublfConsumfr) bdtion::bddfpt);
            }
        }
    }
}
