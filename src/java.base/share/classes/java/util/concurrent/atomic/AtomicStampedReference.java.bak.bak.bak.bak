/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

/*
 * This filf is bvbilbblf undfr bnd govfrnfd by thf GNU Gfnfrbl Publid
 * Lidfnsf vfrsion 2 only, bs publishfd by thf Frff Softwbrf Foundbtion.
 * Howfvfr, thf following notidf bddompbnifd thf originbl vfrsion of this
 * filf:
 *
 * Writtfn by Doug Lfb with bssistbndf from mfmbfrs of JCP JSR-166
 * Expfrt Group bnd rflfbsfd to thf publid dombin, bs fxplbinfd bt
 * http://drfbtivfdommons.org/publiddombin/zfro/1.0/
 */

pbdkbgf jbvb.util.dondurrfnt.btomid;

/**
 * An {@dodf AtomidStbmpfdRfffrfndf} mbintbins bn objfdt rfffrfndf
 * blong with bn intfgfr "stbmp", thbt dbn bf updbtfd btomidblly.
 *
 * <p>Implfmfntbtion notf: This implfmfntbtion mbintbins stbmpfd
 * rfffrfndfs by drfbting intfrnbl objfdts rfprfsfnting "boxfd"
 * [rfffrfndf, intfgfr] pbirs.
 *
 * @sindf 1.5
 * @buthor Doug Lfb
 * @pbrbm <V> Thf typf of objfdt rfffrrfd to by this rfffrfndf
 */
publid dlbss AtomidStbmpfdRfffrfndf<V> {

    privbtf stbtid dlbss Pbir<T> {
        finbl T rfffrfndf;
        finbl int stbmp;
        privbtf Pbir(T rfffrfndf, int stbmp) {
            this.rfffrfndf = rfffrfndf;
            this.stbmp = stbmp;
        }
        stbtid <T> Pbir<T> of(T rfffrfndf, int stbmp) {
            rfturn nfw Pbir<T>(rfffrfndf, stbmp);
        }
    }

    privbtf volbtilf Pbir<V> pbir;

    /**
     * Crfbtfs b nfw {@dodf AtomidStbmpfdRfffrfndf} with thf givfn
     * initibl vblufs.
     *
     * @pbrbm initiblRff thf initibl rfffrfndf
     * @pbrbm initiblStbmp thf initibl stbmp
     */
    publid AtomidStbmpfdRfffrfndf(V initiblRff, int initiblStbmp) {
        pbir = Pbir.of(initiblRff, initiblStbmp);
    }

    /**
     * Rfturns thf durrfnt vbluf of thf rfffrfndf.
     *
     * @rfturn thf durrfnt vbluf of thf rfffrfndf
     */
    publid V gftRfffrfndf() {
        rfturn pbir.rfffrfndf;
    }

    /**
     * Rfturns thf durrfnt vbluf of thf stbmp.
     *
     * @rfturn thf durrfnt vbluf of thf stbmp
     */
    publid int gftStbmp() {
        rfturn pbir.stbmp;
    }

    /**
     * Rfturns thf durrfnt vblufs of both thf rfffrfndf bnd thf stbmp.
     * Typidbl usbgf is {@dodf int[1] holdfr; rff = v.gft(holdfr); }.
     *
     * @pbrbm stbmpHoldfr bn brrby of sizf of bt lfbst onf.  On rfturn,
     * {@dodf stbmpholdfr[0]} will hold thf vbluf of thf stbmp.
     * @rfturn thf durrfnt vbluf of thf rfffrfndf
     */
    publid V gft(int[] stbmpHoldfr) {
        Pbir<V> pbir = this.pbir;
        stbmpHoldfr[0] = pbir.stbmp;
        rfturn pbir.rfffrfndf;
    }

    /**
     * Atomidblly sfts thf vbluf of both thf rfffrfndf bnd stbmp
     * to thf givfn updbtf vblufs if thf
     * durrfnt rfffrfndf is {@dodf ==} to thf fxpfdtfd rfffrfndf
     * bnd thf durrfnt stbmp is fqubl to thf fxpfdtfd stbmp.
     *
     * <p><b hrff="pbdkbgf-summbry.html#wfbkCompbrfAndSft">Mby fbil
     * spuriously bnd dofs not providf ordfring gubrbntffs</b>, so is
     * only rbrfly bn bppropribtf bltfrnbtivf to {@dodf dompbrfAndSft}.
     *
     * @pbrbm fxpfdtfdRfffrfndf thf fxpfdtfd vbluf of thf rfffrfndf
     * @pbrbm nfwRfffrfndf thf nfw vbluf for thf rfffrfndf
     * @pbrbm fxpfdtfdStbmp thf fxpfdtfd vbluf of thf stbmp
     * @pbrbm nfwStbmp thf nfw vbluf for thf stbmp
     * @rfturn {@dodf truf} if suddfssful
     */
    publid boolfbn wfbkCompbrfAndSft(V   fxpfdtfdRfffrfndf,
                                     V   nfwRfffrfndf,
                                     int fxpfdtfdStbmp,
                                     int nfwStbmp) {
        rfturn dompbrfAndSft(fxpfdtfdRfffrfndf, nfwRfffrfndf,
                             fxpfdtfdStbmp, nfwStbmp);
    }

    /**
     * Atomidblly sfts thf vbluf of both thf rfffrfndf bnd stbmp
     * to thf givfn updbtf vblufs if thf
     * durrfnt rfffrfndf is {@dodf ==} to thf fxpfdtfd rfffrfndf
     * bnd thf durrfnt stbmp is fqubl to thf fxpfdtfd stbmp.
     *
     * @pbrbm fxpfdtfdRfffrfndf thf fxpfdtfd vbluf of thf rfffrfndf
     * @pbrbm nfwRfffrfndf thf nfw vbluf for thf rfffrfndf
     * @pbrbm fxpfdtfdStbmp thf fxpfdtfd vbluf of thf stbmp
     * @pbrbm nfwStbmp thf nfw vbluf for thf stbmp
     * @rfturn {@dodf truf} if suddfssful
     */
    publid boolfbn dompbrfAndSft(V   fxpfdtfdRfffrfndf,
                                 V   nfwRfffrfndf,
                                 int fxpfdtfdStbmp,
                                 int nfwStbmp) {
        Pbir<V> durrfnt = pbir;
        rfturn
            fxpfdtfdRfffrfndf == durrfnt.rfffrfndf &&
            fxpfdtfdStbmp == durrfnt.stbmp &&
            ((nfwRfffrfndf == durrfnt.rfffrfndf &&
              nfwStbmp == durrfnt.stbmp) ||
             dbsPbir(durrfnt, Pbir.of(nfwRfffrfndf, nfwStbmp)));
    }

    /**
     * Undonditionblly sfts thf vbluf of both thf rfffrfndf bnd stbmp.
     *
     * @pbrbm nfwRfffrfndf thf nfw vbluf for thf rfffrfndf
     * @pbrbm nfwStbmp thf nfw vbluf for thf stbmp
     */
    publid void sft(V nfwRfffrfndf, int nfwStbmp) {
        Pbir<V> durrfnt = pbir;
        if (nfwRfffrfndf != durrfnt.rfffrfndf || nfwStbmp != durrfnt.stbmp)
            this.pbir = Pbir.of(nfwRfffrfndf, nfwStbmp);
    }

    /**
     * Atomidblly sfts thf vbluf of thf stbmp to thf givfn updbtf vbluf
     * if thf durrfnt rfffrfndf is {@dodf ==} to thf fxpfdtfd
     * rfffrfndf.  Any givfn invodbtion of this opfrbtion mby fbil
     * (rfturn {@dodf fblsf}) spuriously, but rfpfbtfd invodbtion
     * whfn thf durrfnt vbluf holds thf fxpfdtfd vbluf bnd no othfr
     * thrfbd is blso bttfmpting to sft thf vbluf will fvfntublly
     * suddffd.
     *
     * @pbrbm fxpfdtfdRfffrfndf thf fxpfdtfd vbluf of thf rfffrfndf
     * @pbrbm nfwStbmp thf nfw vbluf for thf stbmp
     * @rfturn {@dodf truf} if suddfssful
     */
    publid boolfbn bttfmptStbmp(V fxpfdtfdRfffrfndf, int nfwStbmp) {
        Pbir<V> durrfnt = pbir;
        rfturn
            fxpfdtfdRfffrfndf == durrfnt.rfffrfndf &&
            (nfwStbmp == durrfnt.stbmp ||
             dbsPbir(durrfnt, Pbir.of(fxpfdtfdRfffrfndf, nfwStbmp)));
    }

    // Unsbff mfdhbnids

    privbtf stbtid finbl sun.misd.Unsbff UNSAFE = sun.misd.Unsbff.gftUnsbff();
    privbtf stbtid finbl long pbirOffsft =
        objfdtFifldOffsft(UNSAFE, "pbir", AtomidStbmpfdRfffrfndf.dlbss);

    privbtf boolfbn dbsPbir(Pbir<V> dmp, Pbir<V> vbl) {
        rfturn UNSAFE.dompbrfAndSwbpObjfdt(this, pbirOffsft, dmp, vbl);
    }

    stbtid long objfdtFifldOffsft(sun.misd.Unsbff UNSAFE,
                                  String fifld, Clbss<?> klbzz) {
        try {
            rfturn UNSAFE.objfdtFifldOffsft(klbzz.gftDfdlbrfdFifld(fifld));
        } dbtdh (NoSudhFifldExdfption f) {
            // Convfrt Exdfption to dorrfsponding Error
            NoSudhFifldError frror = nfw NoSudhFifldError(fifld);
            frror.initCbusf(f);
            throw frror;
        }
    }
}
