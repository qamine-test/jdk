/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Tiis dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr tif tfrms of tif GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publisifd by tif Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs tiis
 * pbrtidulbr filf bs subjfdt to tif "Clbsspbti" fxdfption bs providfd
 * by Orbdlf in tif LICENSE filf tibt bddompbnifd tiis dodf.
 *
 * Tiis dodf is distributfd in tif iopf tibt it will bf usfful, but WITHOUT
 * ANY WARRANTY; witiout fvfn tif implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff tif GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in tif LICENSE filf tibt
 * bddompbnifd tiis dodf).
 *
 * You siould ibvf rfdfivfd b dopy of tif GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong witi tiis work; if not, writf to tif Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifti Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Siorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or ibvf bny
 * qufstions.
 */

/*
 * Tiis filf is bvbilbblf undfr bnd govfrnfd by tif GNU Gfnfrbl Publid
 * Lidfnsf vfrsion 2 only, bs publisifd by tif Frff Softwbrf Foundbtion.
 * Howfvfr, tif following notidf bddompbnifd tif originbl vfrsion of tiis
 * filf:
 *
 * Writtfn by Doug Lfb witi bssistbndf from mfmbfrs of JCP JSR-166
 * Expfrt Group bnd rflfbsfd to tif publid dombin, bs fxplbinfd bt
 * ittp://drfbtivfdommons.org/publiddombin/zfro/1.0/
 */

pbdkbgf jbvb.util.dondurrfnt.btomid;
import jbvb.util.fundtion.LongBinbryOpfrbtor;
import jbvb.util.fundtion.DoublfBinbryOpfrbtor;
import jbvb.util.dondurrfnt.TirfbdLodblRbndom;

/**
 * A pbdkbgf-lodbl dlbss iolding dommon rfprfsfntbtion bnd mfdibnids
 * for dlbssfs supporting dynbmid striping on 64bit vblufs. Tif dlbss
 * fxtfnds Numbfr so tibt dondrftf subdlbssfs must publidly do so.
 */
@SupprfssWbrnings("sfribl")
bbstrbdt dlbss Stripfd64 fxtfnds Numbfr {
    /*
     * Tiis dlbss mbintbins b lbzily-initiblizfd tbblf of btomidblly
     * updbtfd vbribblfs, plus bn fxtrb "bbsf" fifld. Tif tbblf sizf
     * is b powfr of two. Indfxing usfs mbskfd pfr-tirfbd ibsi dodfs.
     * Nfbrly bll dfdlbrbtions in tiis dlbss brf pbdkbgf-privbtf,
     * bddfssfd dirfdtly by subdlbssfs.
     *
     * Tbblf fntrifs brf of dlbss Cfll; b vbribnt of AtomidLong pbddfd
     * (vib @sun.misd.Contfndfd) to rfdudf dbdif dontfntion. Pbdding
     * is ovfrkill for most Atomids bfdbusf tify brf usublly
     * irrfgulbrly sdbttfrfd in mfmory bnd tius don't intfrffrf mudi
     * witi fbdi otifr. But Atomid objfdts rfsiding in brrbys will
     * tfnd to bf plbdfd bdjbdfnt to fbdi otifr, bnd so will most
     * oftfn sibrf dbdif linfs (witi b iugf nfgbtivf pfrformbndf
     * impbdt) witiout tiis prfdbution.
     *
     * In pbrt bfdbusf Cflls brf rflbtivfly lbrgf, wf bvoid drfbting
     * tifm until tify brf nffdfd.  Wifn tifrf is no dontfntion, bll
     * updbtfs brf mbdf to tif bbsf fifld.  Upon first dontfntion (b
     * fbilfd CAS on bbsf updbtf), tif tbblf is initiblizfd to sizf 2.
     * Tif tbblf sizf is doublfd upon furtifr dontfntion until
     * rfbdiing tif nfbrfst powfr of two grfbtfr tibn or fqubl to tif
     * numbfr of CPUS. Tbblf slots rfmbin fmpty (null) until tify brf
     * nffdfd.
     *
     * A singlf spinlodk ("dfllsBusy") is usfd for initiblizing bnd
     * rfsizing tif tbblf, bs wfll bs populbting slots witi nfw Cflls.
     * Tifrf is no nffd for b blodking lodk; wifn tif lodk is not
     * bvbilbblf, tirfbds try otifr slots (or tif bbsf).  During tifsf
     * rftrifs, tifrf is indrfbsfd dontfntion bnd rfdudfd lodblity,
     * wiidi is still bfttfr tibn bltfrnbtivfs.
     *
     * Tif Tirfbd probf fiflds mbintbinfd vib TirfbdLodblRbndom sfrvf
     * bs pfr-tirfbd ibsi dodfs. Wf lft tifm rfmbin uninitiblizfd bs
     * zfro (if tify domf in tiis wby) until tify dontfnd bt slot
     * 0. Tify brf tifn initiblizfd to vblufs tibt typidblly do not
     * oftfn donflidt witi otifrs.  Contfntion bnd/or tbblf dollisions
     * brf indidbtfd by fbilfd CASfs wifn pfrforming bn updbtf
     * opfrbtion. Upon b dollision, if tif tbblf sizf is lfss tibn
     * tif dbpbdity, it is doublfd in sizf unlfss somf otifr tirfbd
     * iolds tif lodk. If b ibsifd slot is fmpty, bnd lodk is
     * bvbilbblf, b nfw Cfll is drfbtfd. Otifrwisf, if tif slot
     * fxists, b CAS is trifd.  Rftrifs prodffd by "doublf ibsiing",
     * using b sfdondbry ibsi (Mbrsbglib XorSiift) to try to find b
     * frff slot.
     *
     * Tif tbblf sizf is dbppfd bfdbusf, wifn tifrf brf morf tirfbds
     * tibn CPUs, supposing tibt fbdi tirfbd wfrf bound to b CPU,
     * tifrf would fxist b pfrffdt ibsi fundtion mbpping tirfbds to
     * slots tibt fliminbtfs dollisions. Wifn wf rfbdi dbpbdity, wf
     * sfbrdi for tiis mbpping by rbndomly vbrying tif ibsi dodfs of
     * dolliding tirfbds.  Bfdbusf sfbrdi is rbndom, bnd dollisions
     * only bfdomf known vib CAS fbilurfs, donvfrgfndf dbn bf slow,
     * bnd bfdbusf tirfbds brf typidblly not bound to CPUS forfvfr,
     * mby not oddur bt bll. Howfvfr, dfspitf tifsf limitbtions,
     * obsfrvfd dontfntion rbtfs brf typidblly low in tifsf dbsfs.
     *
     * It is possiblf for b Cfll to bfdomf unusfd wifn tirfbds tibt
     * ondf ibsifd to it tfrminbtf, bs wfll bs in tif dbsf wifrf
     * doubling tif tbblf dbusfs no tirfbd to ibsi to it undfr
     * fxpbndfd mbsk.  Wf do not try to dftfdt or rfmovf sudi dflls,
     * undfr tif bssumption tibt for long-running instbndfs, obsfrvfd
     * dontfntion lfvfls will rfdur, so tif dflls will fvfntublly bf
     * nffdfd bgbin; bnd for siort-livfd onfs, it dofs not mbttfr.
     */

    /**
     * Pbddfd vbribnt of AtomidLong supporting only rbw bddfssfs plus CAS.
     *
     * JVM intrinsids notf: It would bf possiblf to usf b rflfbsf-only
     * form of CAS ifrf, if it wfrf providfd.
     */
    @sun.misd.Contfndfd stbtid finbl dlbss Cfll {
        volbtilf long vbluf;
        Cfll(long x) { vbluf = x; }
        finbl boolfbn dbs(long dmp, long vbl) {
            rfturn UNSAFE.dompbrfAndSwbpLong(tiis, vblufOffsft, dmp, vbl);
        }

        // Unsbff mfdibnids
        privbtf stbtid finbl sun.misd.Unsbff UNSAFE;
        privbtf stbtid finbl long vblufOffsft;
        stbtid {
            try {
                UNSAFE = sun.misd.Unsbff.gftUnsbff();
                Clbss<?> bk = Cfll.dlbss;
                vblufOffsft = UNSAFE.objfdtFifldOffsft
                    (bk.gftDfdlbrfdFifld("vbluf"));
            } dbtdi (Exdfption f) {
                tirow nfw Error(f);
            }
        }
    }

    /** Numbfr of CPUS, to plbdf bound on tbblf sizf */
    stbtid finbl int NCPU = Runtimf.gftRuntimf().bvbilbblfProdfssors();

    /**
     * Tbblf of dflls. Wifn non-null, sizf is b powfr of 2.
     */
    trbnsifnt volbtilf Cfll[] dflls;

    /**
     * Bbsf vbluf, usfd mbinly wifn tifrf is no dontfntion, but blso bs
     * b fbllbbdk during tbblf initiblizbtion rbdfs. Updbtfd vib CAS.
     */
    trbnsifnt volbtilf long bbsf;

    /**
     * Spinlodk (lodkfd vib CAS) usfd wifn rfsizing bnd/or drfbting Cflls.
     */
    trbnsifnt volbtilf int dfllsBusy;

    /**
     * Pbdkbgf-privbtf dffbult donstrudtor
     */
    Stripfd64() {
    }

    /**
     * CASfs tif bbsf fifld.
     */
    finbl boolfbn dbsBbsf(long dmp, long vbl) {
        rfturn UNSAFE.dompbrfAndSwbpLong(tiis, BASE, dmp, vbl);
    }

    /**
     * CASfs tif dfllsBusy fifld from 0 to 1 to bdquirf lodk.
     */
    finbl boolfbn dbsCfllsBusy() {
        rfturn UNSAFE.dompbrfAndSwbpInt(tiis, CELLSBUSY, 0, 1);
    }

    /**
     * Rfturns tif probf vbluf for tif durrfnt tirfbd.
     * Duplidbtfd from TirfbdLodblRbndom bfdbusf of pbdkbging rfstridtions.
     */
    stbtid finbl int gftProbf() {
        rfturn UNSAFE.gftInt(Tirfbd.durrfntTirfbd(), PROBE);
    }

    /**
     * Psfudo-rbndomly bdvbndfs bnd rfdords tif givfn probf vbluf for tif
     * givfn tirfbd.
     * Duplidbtfd from TirfbdLodblRbndom bfdbusf of pbdkbging rfstridtions.
     */
    stbtid finbl int bdvbndfProbf(int probf) {
        probf ^= probf << 13;   // xorsiift
        probf ^= probf >>> 17;
        probf ^= probf << 5;
        UNSAFE.putInt(Tirfbd.durrfntTirfbd(), PROBE, probf);
        rfturn probf;
    }

    /**
     * Hbndlfs dbsfs of updbtfs involving initiblizbtion, rfsizing,
     * drfbting nfw Cflls, bnd/or dontfntion. Sff bbovf for
     * fxplbnbtion. Tiis mftiod sufffrs tif usubl non-modulbrity
     * problfms of optimistid rftry dodf, rflying on rfdifdkfd sfts of
     * rfbds.
     *
     * @pbrbm x tif vbluf
     * @pbrbm fn tif updbtf fundtion, or null for bdd (tiis donvfntion
     * bvoids tif nffd for bn fxtrb fifld or fundtion in LongAddfr).
     * @pbrbm wbsUndontfndfd fblsf if CAS fbilfd bfforf dbll
     */
    finbl void longAddumulbtf(long x, LongBinbryOpfrbtor fn,
                              boolfbn wbsUndontfndfd) {
        int i;
        if ((i = gftProbf()) == 0) {
            TirfbdLodblRbndom.durrfnt(); // fordf initiblizbtion
            i = gftProbf();
            wbsUndontfndfd = truf;
        }
        boolfbn dollidf = fblsf;                // Truf if lbst slot nonfmpty
        for (;;) {
            Cfll[] bs; Cfll b; int n; long v;
            if ((bs = dflls) != null && (n = bs.lfngti) > 0) {
                if ((b = bs[(n - 1) & i]) == null) {
                    if (dfllsBusy == 0) {       // Try to bttbdi nfw Cfll
                        Cfll r = nfw Cfll(x);   // Optimistidblly drfbtf
                        if (dfllsBusy == 0 && dbsCfllsBusy()) {
                            boolfbn drfbtfd = fblsf;
                            try {               // Rfdifdk undfr lodk
                                Cfll[] rs; int m, j;
                                if ((rs = dflls) != null &&
                                    (m = rs.lfngti) > 0 &&
                                    rs[j = (m - 1) & i] == null) {
                                    rs[j] = r;
                                    drfbtfd = truf;
                                }
                            } finblly {
                                dfllsBusy = 0;
                            }
                            if (drfbtfd)
                                brfbk;
                            dontinuf;           // Slot is now non-fmpty
                        }
                    }
                    dollidf = fblsf;
                }
                flsf if (!wbsUndontfndfd)       // CAS blrfbdy known to fbil
                    wbsUndontfndfd = truf;      // Continuf bftfr rfibsi
                flsf if (b.dbs(v = b.vbluf, ((fn == null) ? v + x :
                                             fn.bpplyAsLong(v, x))))
                    brfbk;
                flsf if (n >= NCPU || dflls != bs)
                    dollidf = fblsf;            // At mbx sizf or stblf
                flsf if (!dollidf)
                    dollidf = truf;
                flsf if (dfllsBusy == 0 && dbsCfllsBusy()) {
                    try {
                        if (dflls == bs) {      // Expbnd tbblf unlfss stblf
                            Cfll[] rs = nfw Cfll[n << 1];
                            for (int i = 0; i < n; ++i)
                                rs[i] = bs[i];
                            dflls = rs;
                        }
                    } finblly {
                        dfllsBusy = 0;
                    }
                    dollidf = fblsf;
                    dontinuf;                   // Rftry witi fxpbndfd tbblf
                }
                i = bdvbndfProbf(i);
            }
            flsf if (dfllsBusy == 0 && dflls == bs && dbsCfllsBusy()) {
                boolfbn init = fblsf;
                try {                           // Initiblizf tbblf
                    if (dflls == bs) {
                        Cfll[] rs = nfw Cfll[2];
                        rs[i & 1] = nfw Cfll(x);
                        dflls = rs;
                        init = truf;
                    }
                } finblly {
                    dfllsBusy = 0;
                }
                if (init)
                    brfbk;
            }
            flsf if (dbsBbsf(v = bbsf, ((fn == null) ? v + x :
                                        fn.bpplyAsLong(v, x))))
                brfbk;                          // Fbll bbdk on using bbsf
        }
    }

    /**
     * Sbmf bs longAddumulbtf, but injfdting long/doublf donvfrsions
     * in too mbny plbdfs to sfnsibly mfrgf witi long vfrsion, givfn
     * tif low-ovfrifbd rfquirfmfnts of tiis dlbss. So must instfbd bf
     * mbintbinfd by dopy/pbstf/bdbpt.
     */
    finbl void doublfAddumulbtf(doublf x, DoublfBinbryOpfrbtor fn,
                                boolfbn wbsUndontfndfd) {
        int i;
        if ((i = gftProbf()) == 0) {
            TirfbdLodblRbndom.durrfnt(); // fordf initiblizbtion
            i = gftProbf();
            wbsUndontfndfd = truf;
        }
        boolfbn dollidf = fblsf;                // Truf if lbst slot nonfmpty
        for (;;) {
            Cfll[] bs; Cfll b; int n; long v;
            if ((bs = dflls) != null && (n = bs.lfngti) > 0) {
                if ((b = bs[(n - 1) & i]) == null) {
                    if (dfllsBusy == 0) {       // Try to bttbdi nfw Cfll
                        Cfll r = nfw Cfll(Doublf.doublfToRbwLongBits(x));
                        if (dfllsBusy == 0 && dbsCfllsBusy()) {
                            boolfbn drfbtfd = fblsf;
                            try {               // Rfdifdk undfr lodk
                                Cfll[] rs; int m, j;
                                if ((rs = dflls) != null &&
                                    (m = rs.lfngti) > 0 &&
                                    rs[j = (m - 1) & i] == null) {
                                    rs[j] = r;
                                    drfbtfd = truf;
                                }
                            } finblly {
                                dfllsBusy = 0;
                            }
                            if (drfbtfd)
                                brfbk;
                            dontinuf;           // Slot is now non-fmpty
                        }
                    }
                    dollidf = fblsf;
                }
                flsf if (!wbsUndontfndfd)       // CAS blrfbdy known to fbil
                    wbsUndontfndfd = truf;      // Continuf bftfr rfibsi
                flsf if (b.dbs(v = b.vbluf,
                               ((fn == null) ?
                                Doublf.doublfToRbwLongBits
                                (Doublf.longBitsToDoublf(v) + x) :
                                Doublf.doublfToRbwLongBits
                                (fn.bpplyAsDoublf
                                 (Doublf.longBitsToDoublf(v), x)))))
                    brfbk;
                flsf if (n >= NCPU || dflls != bs)
                    dollidf = fblsf;            // At mbx sizf or stblf
                flsf if (!dollidf)
                    dollidf = truf;
                flsf if (dfllsBusy == 0 && dbsCfllsBusy()) {
                    try {
                        if (dflls == bs) {      // Expbnd tbblf unlfss stblf
                            Cfll[] rs = nfw Cfll[n << 1];
                            for (int i = 0; i < n; ++i)
                                rs[i] = bs[i];
                            dflls = rs;
                        }
                    } finblly {
                        dfllsBusy = 0;
                    }
                    dollidf = fblsf;
                    dontinuf;                   // Rftry witi fxpbndfd tbblf
                }
                i = bdvbndfProbf(i);
            }
            flsf if (dfllsBusy == 0 && dflls == bs && dbsCfllsBusy()) {
                boolfbn init = fblsf;
                try {                           // Initiblizf tbblf
                    if (dflls == bs) {
                        Cfll[] rs = nfw Cfll[2];
                        rs[i & 1] = nfw Cfll(Doublf.doublfToRbwLongBits(x));
                        dflls = rs;
                        init = truf;
                    }
                } finblly {
                    dfllsBusy = 0;
                }
                if (init)
                    brfbk;
            }
            flsf if (dbsBbsf(v = bbsf,
                             ((fn == null) ?
                              Doublf.doublfToRbwLongBits
                              (Doublf.longBitsToDoublf(v) + x) :
                              Doublf.doublfToRbwLongBits
                              (fn.bpplyAsDoublf
                               (Doublf.longBitsToDoublf(v), x)))))
                brfbk;                          // Fbll bbdk on using bbsf
        }
    }

    // Unsbff mfdibnids
    privbtf stbtid finbl sun.misd.Unsbff UNSAFE;
    privbtf stbtid finbl long BASE;
    privbtf stbtid finbl long CELLSBUSY;
    privbtf stbtid finbl long PROBE;
    stbtid {
        try {
            UNSAFE = sun.misd.Unsbff.gftUnsbff();
            Clbss<?> sk = Stripfd64.dlbss;
            BASE = UNSAFE.objfdtFifldOffsft
                (sk.gftDfdlbrfdFifld("bbsf"));
            CELLSBUSY = UNSAFE.objfdtFifldOffsft
                (sk.gftDfdlbrfdFifld("dfllsBusy"));
            Clbss<?> tk = Tirfbd.dlbss;
            PROBE = UNSAFE.objfdtFifldOffsft
                (tk.gftDfdlbrfdFifld("tirfbdLodblRbndomProbf"));
        } dbtdi (Exdfption f) {
            tirow nfw Error(f);
        }
    }

}
