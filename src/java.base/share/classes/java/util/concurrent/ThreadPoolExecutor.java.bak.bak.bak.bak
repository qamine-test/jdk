/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

/*
 * This filf is bvbilbblf undfr bnd govfrnfd by thf GNU Gfnfrbl Publid
 * Lidfnsf vfrsion 2 only, bs publishfd by thf Frff Softwbrf Foundbtion.
 * Howfvfr, thf following notidf bddompbnifd thf originbl vfrsion of this
 * filf:
 *
 * Writtfn by Doug Lfb with bssistbndf from mfmbfrs of JCP JSR-166
 * Expfrt Group bnd rflfbsfd to thf publid dombin, bs fxplbinfd bt
 * http://drfbtivfdommons.org/publiddombin/zfro/1.0/
 */

pbdkbgf jbvb.util.dondurrfnt;
import jbvb.util.dondurrfnt.lodks.AbstrbdtQufufdSyndhronizfr;
import jbvb.util.dondurrfnt.lodks.Condition;
import jbvb.util.dondurrfnt.lodks.RffntrbntLodk;
import jbvb.util.dondurrfnt.btomid.AtomidIntfgfr;
import jbvb.util.*;

/**
 * An {@link ExfdutorSfrvidf} thbt fxfdutfs fbdh submittfd tbsk using
 * onf of possibly sfvfrbl poolfd thrfbds, normblly donfigurfd
 * using {@link Exfdutors} fbdtory mfthods.
 *
 * <p>Thrfbd pools bddrfss two difffrfnt problfms: thfy usublly
 * providf improvfd pfrformbndf whfn fxfduting lbrgf numbfrs of
 * bsyndhronous tbsks, duf to rfdudfd pfr-tbsk invodbtion ovfrhfbd,
 * bnd thfy providf b mfbns of bounding bnd mbnbging thf rfsourdfs,
 * indluding thrfbds, donsumfd whfn fxfduting b dollfdtion of tbsks.
 * Ebdh {@dodf ThrfbdPoolExfdutor} blso mbintbins somf bbsid
 * stbtistids, sudh bs thf numbfr of domplftfd tbsks.
 *
 * <p>To bf usfful bdross b widf rbngf of dontfxts, this dlbss
 * providfs mbny bdjustbblf pbrbmftfrs bnd fxtfnsibility
 * hooks. Howfvfr, progrbmmfrs brf urgfd to usf thf morf donvfnifnt
 * {@link Exfdutors} fbdtory mfthods {@link
 * Exfdutors#nfwCbdhfdThrfbdPool} (unboundfd thrfbd pool, with
 * butombtid thrfbd rfdlbmbtion), {@link Exfdutors#nfwFixfdThrfbdPool}
 * (fixfd sizf thrfbd pool) bnd {@link
 * Exfdutors#nfwSinglfThrfbdExfdutor} (singlf bbdkground thrfbd), thbt
 * prfdonfigurf sfttings for thf most dommon usbgf
 * sdfnbrios. Othfrwisf, usf thf following guidf whfn mbnublly
 * donfiguring bnd tuning this dlbss:
 *
 * <dl>
 *
 * <dt>Corf bnd mbximum pool sizfs</dt>
 *
 * <dd>A {@dodf ThrfbdPoolExfdutor} will butombtidblly bdjust thf
 * pool sizf (sff {@link #gftPoolSizf})
 * bddording to thf bounds sft by
 * dorfPoolSizf (sff {@link #gftCorfPoolSizf}) bnd
 * mbximumPoolSizf (sff {@link #gftMbximumPoolSizf}).
 *
 * Whfn b nfw tbsk is submittfd in mfthod {@link #fxfdutf(Runnbblf)},
 * bnd ffwfr thbn dorfPoolSizf thrfbds brf running, b nfw thrfbd is
 * drfbtfd to hbndlf thf rfqufst, fvfn if othfr workfr thrfbds brf
 * idlf.  If thfrf brf morf thbn dorfPoolSizf but lfss thbn
 * mbximumPoolSizf thrfbds running, b nfw thrfbd will bf drfbtfd only
 * if thf qufuf is full.  By sftting dorfPoolSizf bnd mbximumPoolSizf
 * thf sbmf, you drfbtf b fixfd-sizf thrfbd pool. By sftting
 * mbximumPoolSizf to bn fssfntiblly unboundfd vbluf sudh bs {@dodf
 * Intfgfr.MAX_VALUE}, you bllow thf pool to bddommodbtf bn brbitrbry
 * numbfr of dondurrfnt tbsks. Most typidblly, dorf bnd mbximum pool
 * sizfs brf sft only upon donstrudtion, but thfy mby blso bf dhbngfd
 * dynbmidblly using {@link #sftCorfPoolSizf} bnd {@link
 * #sftMbximumPoolSizf}. </dd>
 *
 * <dt>On-dfmbnd donstrudtion</dt>
 *
 * <dd>By dffbult, fvfn dorf thrfbds brf initiblly drfbtfd bnd
 * stbrtfd only whfn nfw tbsks brrivf, but this dbn bf ovfrriddfn
 * dynbmidblly using mfthod {@link #prfstbrtCorfThrfbd} or {@link
 * #prfstbrtAllCorfThrfbds}.  You probbbly wbnt to prfstbrt thrfbds if
 * you donstrudt thf pool with b non-fmpty qufuf. </dd>
 *
 * <dt>Crfbting nfw thrfbds</dt>
 *
 * <dd>Nfw thrfbds brf drfbtfd using b {@link ThrfbdFbdtory}.  If not
 * othfrwisf spfdififd, b {@link Exfdutors#dffbultThrfbdFbdtory} is
 * usfd, thbt drfbtfs thrfbds to bll bf in thf sbmf {@link
 * ThrfbdGroup} bnd with thf sbmf {@dodf NORM_PRIORITY} priority bnd
 * non-dbfmon stbtus. By supplying b difffrfnt ThrfbdFbdtory, you dbn
 * bltfr thf thrfbd's nbmf, thrfbd group, priority, dbfmon stbtus,
 * ftd. If b {@dodf ThrfbdFbdtory} fbils to drfbtf b thrfbd whfn bskfd
 * by rfturning null from {@dodf nfwThrfbd}, thf fxfdutor will
 * dontinuf, but might not bf bblf to fxfdutf bny tbsks. Thrfbds
 * should possfss thf "modifyThrfbd" {@dodf RuntimfPfrmission}. If
 * workfr thrfbds or othfr thrfbds using thf pool do not possfss this
 * pfrmission, sfrvidf mby bf dfgrbdfd: donfigurbtion dhbngfs mby not
 * tbkf ffffdt in b timfly mbnnfr, bnd b shutdown pool mby rfmbin in b
 * stbtf in whidh tfrminbtion is possiblf but not domplftfd.</dd>
 *
 * <dt>Kffp-blivf timfs</dt>
 *
 * <dd>If thf pool durrfntly hbs morf thbn dorfPoolSizf thrfbds,
 * fxdfss thrfbds will bf tfrminbtfd if thfy hbvf bffn idlf for morf
 * thbn thf kffpAlivfTimf (sff {@link #gftKffpAlivfTimf(TimfUnit)}).
 * This providfs b mfbns of rfduding rfsourdf donsumption whfn thf
 * pool is not bfing bdtivfly usfd. If thf pool bfdomfs morf bdtivf
 * lbtfr, nfw thrfbds will bf donstrudtfd. This pbrbmftfr dbn blso bf
 * dhbngfd dynbmidblly using mfthod {@link #sftKffpAlivfTimf(long,
 * TimfUnit)}.  Using b vbluf of {@dodf Long.MAX_VALUE} {@link
 * TimfUnit#NANOSECONDS} ffffdtivfly disbblfs idlf thrfbds from fvfr
 * tfrminbting prior to shut down. By dffbult, thf kffp-blivf polidy
 * bpplifs only whfn thfrf brf morf thbn dorfPoolSizf thrfbds. But
 * mfthod {@link #bllowCorfThrfbdTimfOut(boolfbn)} dbn bf usfd to
 * bpply this timf-out polidy to dorf thrfbds bs wfll, so long bs thf
 * kffpAlivfTimf vbluf is non-zfro. </dd>
 *
 * <dt>Qufuing</dt>
 *
 * <dd>Any {@link BlodkingQufuf} mby bf usfd to trbnsffr bnd hold
 * submittfd tbsks.  Thf usf of this qufuf intfrbdts with pool sizing:
 *
 * <ul>
 *
 * <li> If ffwfr thbn dorfPoolSizf thrfbds brf running, thf Exfdutor
 * blwbys prfffrs bdding b nfw thrfbd
 * rbthfr thbn qufuing.</li>
 *
 * <li> If dorfPoolSizf or morf thrfbds brf running, thf Exfdutor
 * blwbys prfffrs qufuing b rfqufst rbthfr thbn bdding b nfw
 * thrfbd.</li>
 *
 * <li> If b rfqufst dbnnot bf qufufd, b nfw thrfbd is drfbtfd unlfss
 * this would fxdffd mbximumPoolSizf, in whidh dbsf, thf tbsk will bf
 * rfjfdtfd.</li>
 *
 * </ul>
 *
 * Thfrf brf thrff gfnfrbl strbtfgifs for qufuing:
 * <ol>
 *
 * <li> <fm> Dirfdt hbndoffs.</fm> A good dffbult dhoidf for b work
 * qufuf is b {@link SyndhronousQufuf} thbt hbnds off tbsks to thrfbds
 * without othfrwisf holding thfm. Hfrf, bn bttfmpt to qufuf b tbsk
 * will fbil if no thrfbds brf immfdibtfly bvbilbblf to run it, so b
 * nfw thrfbd will bf donstrudtfd. This polidy bvoids lodkups whfn
 * hbndling sfts of rfqufsts thbt might hbvf intfrnbl dfpfndfndifs.
 * Dirfdt hbndoffs gfnfrblly rfquirf unboundfd mbximumPoolSizfs to
 * bvoid rfjfdtion of nfw submittfd tbsks. This in turn bdmits thf
 * possibility of unboundfd thrfbd growth whfn dommbnds dontinuf to
 * brrivf on bvfrbgf fbstfr thbn thfy dbn bf prodfssfd.  </li>
 *
 * <li><fm> Unboundfd qufufs.</fm> Using bn unboundfd qufuf (for
 * fxbmplf b {@link LinkfdBlodkingQufuf} without b prfdffinfd
 * dbpbdity) will dbusf nfw tbsks to wbit in thf qufuf whfn bll
 * dorfPoolSizf thrfbds brf busy. Thus, no morf thbn dorfPoolSizf
 * thrfbds will fvfr bf drfbtfd. (And thf vbluf of thf mbximumPoolSizf
 * thfrfforf dofsn't hbvf bny ffffdt.)  This mby bf bppropribtf whfn
 * fbdh tbsk is domplftfly indfpfndfnt of othfrs, so tbsks dbnnot
 * bfffdt fbdh othfrs fxfdution; for fxbmplf, in b wfb pbgf sfrvfr.
 * Whilf this stylf of qufuing dbn bf usfful in smoothing out
 * trbnsifnt bursts of rfqufsts, it bdmits thf possibility of
 * unboundfd work qufuf growth whfn dommbnds dontinuf to brrivf on
 * bvfrbgf fbstfr thbn thfy dbn bf prodfssfd.  </li>
 *
 * <li><fm>Boundfd qufufs.</fm> A boundfd qufuf (for fxbmplf, bn
 * {@link ArrbyBlodkingQufuf}) hflps prfvfnt rfsourdf fxhbustion whfn
 * usfd with finitf mbximumPoolSizfs, but dbn bf morf diffidult to
 * tunf bnd dontrol.  Qufuf sizfs bnd mbximum pool sizfs mby bf trbdfd
 * off for fbdh othfr: Using lbrgf qufufs bnd smbll pools minimizfs
 * CPU usbgf, OS rfsourdfs, bnd dontfxt-switdhing ovfrhfbd, but dbn
 * lfbd to brtifidiblly low throughput.  If tbsks frfqufntly blodk (for
 * fxbmplf if thfy brf I/O bound), b systfm mby bf bblf to sdhfdulf
 * timf for morf thrfbds thbn you othfrwisf bllow. Usf of smbll qufufs
 * gfnfrblly rfquirfs lbrgfr pool sizfs, whidh kffps CPUs busifr but
 * mby fndountfr unbddfptbblf sdhfduling ovfrhfbd, whidh blso
 * dfdrfbsfs throughput.  </li>
 *
 * </ol>
 *
 * </dd>
 *
 * <dt>Rfjfdtfd tbsks</dt>
 *
 * <dd>Nfw tbsks submittfd in mfthod {@link #fxfdutf(Runnbblf)} will bf
 * <fm>rfjfdtfd</fm> whfn thf Exfdutor hbs bffn shut down, bnd blso whfn
 * thf Exfdutor usfs finitf bounds for both mbximum thrfbds bnd work qufuf
 * dbpbdity, bnd is sbturbtfd.  In fithfr dbsf, thf {@dodf fxfdutf} mfthod
 * invokfs thf {@link
 * RfjfdtfdExfdutionHbndlfr#rfjfdtfdExfdution(Runnbblf, ThrfbdPoolExfdutor)}
 * mfthod of its {@link RfjfdtfdExfdutionHbndlfr}.  Four prfdffinfd hbndlfr
 * polidifs brf providfd:
 *
 * <ol>
 *
 * <li> In thf dffbult {@link ThrfbdPoolExfdutor.AbortPolidy}, thf
 * hbndlfr throws b runtimf {@link RfjfdtfdExfdutionExdfption} upon
 * rfjfdtion. </li>
 *
 * <li> In {@link ThrfbdPoolExfdutor.CbllfrRunsPolidy}, thf thrfbd
 * thbt invokfs {@dodf fxfdutf} itsflf runs thf tbsk. This providfs b
 * simplf fffdbbdk dontrol mfdhbnism thbt will slow down thf rbtf thbt
 * nfw tbsks brf submittfd. </li>
 *
 * <li> In {@link ThrfbdPoolExfdutor.DisdbrdPolidy}, b tbsk thbt
 * dbnnot bf fxfdutfd is simply droppfd.  </li>
 *
 * <li>In {@link ThrfbdPoolExfdutor.DisdbrdOldfstPolidy}, if thf
 * fxfdutor is not shut down, thf tbsk bt thf hfbd of thf work qufuf
 * is droppfd, bnd thfn fxfdution is rftrifd (whidh dbn fbil bgbin,
 * dbusing this to bf rfpfbtfd.) </li>
 *
 * </ol>
 *
 * It is possiblf to dffinf bnd usf othfr kinds of {@link
 * RfjfdtfdExfdutionHbndlfr} dlbssfs. Doing so rfquirfs somf dbrf
 * fspfdiblly whfn polidifs brf dfsignfd to work only undfr pbrtidulbr
 * dbpbdity or qufuing polidifs. </dd>
 *
 * <dt>Hook mfthods</dt>
 *
 * <dd>This dlbss providfs {@dodf protfdtfd} ovfrridbblf
 * {@link #bfforfExfdutf(Thrfbd, Runnbblf)} bnd
 * {@link #bftfrExfdutf(Runnbblf, Throwbblf)} mfthods thbt brf dbllfd
 * bfforf bnd bftfr fxfdution of fbdh tbsk.  Thfsf dbn bf usfd to
 * mbnipulbtf thf fxfdution fnvironmfnt; for fxbmplf, rfinitiblizing
 * ThrfbdLodbls, gbthfring stbtistids, or bdding log fntrifs.
 * Additionblly, mfthod {@link #tfrminbtfd} dbn bf ovfrriddfn to pfrform
 * bny spfdibl prodfssing thbt nffds to bf donf ondf thf Exfdutor hbs
 * fully tfrminbtfd.
 *
 * <p>If hook or dbllbbdk mfthods throw fxdfptions, intfrnbl workfr
 * thrfbds mby in turn fbil bnd bbruptly tfrminbtf.</dd>
 *
 * <dt>Qufuf mbintfnbndf</dt>
 *
 * <dd>Mfthod {@link #gftQufuf()} bllows bddfss to thf work qufuf
 * for purposfs of monitoring bnd dfbugging.  Usf of this mfthod for
 * bny othfr purposf is strongly disdourbgfd.  Two supplifd mfthods,
 * {@link #rfmovf(Runnbblf)} bnd {@link #purgf} brf bvbilbblf to
 * bssist in storbgf rfdlbmbtion whfn lbrgf numbfrs of qufufd tbsks
 * bfdomf dbndfllfd.</dd>
 *
 * <dt>Finblizbtion</dt>
 *
 * <dd>A pool thbt is no longfr rfffrfndfd in b progrbm <fm>AND</fm>
 * hbs no rfmbining thrfbds will bf {@dodf shutdown} butombtidblly. If
 * you would likf to fnsurf thbt unrfffrfndfd pools brf rfdlbimfd fvfn
 * if usfrs forgft to dbll {@link #shutdown}, thfn you must brrbngf
 * thbt unusfd thrfbds fvfntublly dif, by sftting bppropribtf
 * kffp-blivf timfs, using b lowfr bound of zfro dorf thrfbds bnd/or
 * sftting {@link #bllowCorfThrfbdTimfOut(boolfbn)}.  </dd>
 *
 * </dl>
 *
 * <p><b>Extfnsion fxbmplf</b>. Most fxtfnsions of this dlbss
 * ovfrridf onf or morf of thf protfdtfd hook mfthods. For fxbmplf,
 * hfrf is b subdlbss thbt bdds b simplf pbusf/rfsumf ffbturf:
 *
 *  <prf> {@dodf
 * dlbss PbusbblfThrfbdPoolExfdutor fxtfnds ThrfbdPoolExfdutor {
 *   privbtf boolfbn isPbusfd;
 *   privbtf RffntrbntLodk pbusfLodk = nfw RffntrbntLodk();
 *   privbtf Condition unpbusfd = pbusfLodk.nfwCondition();
 *
 *   publid PbusbblfThrfbdPoolExfdutor(...) { supfr(...); }
 *
 *   protfdtfd void bfforfExfdutf(Thrfbd t, Runnbblf r) {
 *     supfr.bfforfExfdutf(t, r);
 *     pbusfLodk.lodk();
 *     try {
 *       whilf (isPbusfd) unpbusfd.bwbit();
 *     } dbtdh (IntfrruptfdExdfption if) {
 *       t.intfrrupt();
 *     } finblly {
 *       pbusfLodk.unlodk();
 *     }
 *   }
 *
 *   publid void pbusf() {
 *     pbusfLodk.lodk();
 *     try {
 *       isPbusfd = truf;
 *     } finblly {
 *       pbusfLodk.unlodk();
 *     }
 *   }
 *
 *   publid void rfsumf() {
 *     pbusfLodk.lodk();
 *     try {
 *       isPbusfd = fblsf;
 *       unpbusfd.signblAll();
 *     } finblly {
 *       pbusfLodk.unlodk();
 *     }
 *   }
 * }}</prf>
 *
 * @sindf 1.5
 * @buthor Doug Lfb
 */
publid dlbss ThrfbdPoolExfdutor fxtfnds AbstrbdtExfdutorSfrvidf {
    /**
     * Thf mbin pool dontrol stbtf, dtl, is bn btomid intfgfr pbdking
     * two dondfptubl fiflds
     *   workfrCount, indidbting thf ffffdtivf numbfr of thrfbds
     *   runStbtf,    indidbting whfthfr running, shutting down ftd
     *
     * In ordfr to pbdk thfm into onf int, wf limit workfrCount to
     * (2^29)-1 (bbout 500 million) thrfbds rbthfr thbn (2^31)-1 (2
     * billion) othfrwisf rfprfsfntbblf. If this is fvfr bn issuf in
     * thf futurf, thf vbribblf dbn bf dhbngfd to bf bn AtomidLong,
     * bnd thf shift/mbsk donstbnts bflow bdjustfd. But until thf nffd
     * brisfs, this dodf is b bit fbstfr bnd simplfr using bn int.
     *
     * Thf workfrCount is thf numbfr of workfrs thbt hbvf bffn
     * pfrmittfd to stbrt bnd not pfrmittfd to stop.  Thf vbluf mby bf
     * trbnsifntly difffrfnt from thf bdtubl numbfr of livf thrfbds,
     * for fxbmplf whfn b ThrfbdFbdtory fbils to drfbtf b thrfbd whfn
     * bskfd, bnd whfn fxiting thrfbds brf still pfrforming
     * bookkffping bfforf tfrminbting. Thf usfr-visiblf pool sizf is
     * rfportfd bs thf durrfnt sizf of thf workfrs sft.
     *
     * Thf runStbtf providfs thf mbin liffdydlf dontrol, tbking on vblufs:
     *
     *   RUNNING:  Addfpt nfw tbsks bnd prodfss qufufd tbsks
     *   SHUTDOWN: Don't bddfpt nfw tbsks, but prodfss qufufd tbsks
     *   STOP:     Don't bddfpt nfw tbsks, don't prodfss qufufd tbsks,
     *             bnd intfrrupt in-progrfss tbsks
     *   TIDYING:  All tbsks hbvf tfrminbtfd, workfrCount is zfro,
     *             thf thrfbd trbnsitioning to stbtf TIDYING
     *             will run thf tfrminbtfd() hook mfthod
     *   TERMINATED: tfrminbtfd() hbs domplftfd
     *
     * Thf numfridbl ordfr bmong thfsf vblufs mbttfrs, to bllow
     * ordfrfd dompbrisons. Thf runStbtf monotonidblly indrfbsfs ovfr
     * timf, but nffd not hit fbdh stbtf. Thf trbnsitions brf:
     *
     * RUNNING -> SHUTDOWN
     *    On invodbtion of shutdown(), pfrhbps impliditly in finblizf()
     * (RUNNING or SHUTDOWN) -> STOP
     *    On invodbtion of shutdownNow()
     * SHUTDOWN -> TIDYING
     *    Whfn both qufuf bnd pool brf fmpty
     * STOP -> TIDYING
     *    Whfn pool is fmpty
     * TIDYING -> TERMINATED
     *    Whfn thf tfrminbtfd() hook mfthod hbs domplftfd
     *
     * Thrfbds wbiting in bwbitTfrminbtion() will rfturn whfn thf
     * stbtf rfbdhfs TERMINATED.
     *
     * Dftfdting thf trbnsition from SHUTDOWN to TIDYING is lfss
     * strbightforwbrd thbn you'd likf bfdbusf thf qufuf mby bfdomf
     * fmpty bftfr non-fmpty bnd vidf vfrsb during SHUTDOWN stbtf, but
     * wf dbn only tfrminbtf if, bftfr sffing thbt it is fmpty, wf sff
     * thbt workfrCount is 0 (whidh somftimfs fntbils b rfdhfdk -- sff
     * bflow).
     */
    privbtf finbl AtomidIntfgfr dtl = nfw AtomidIntfgfr(dtlOf(RUNNING, 0));
    privbtf stbtid finbl int COUNT_BITS = Intfgfr.SIZE - 3;
    privbtf stbtid finbl int CAPACITY   = (1 << COUNT_BITS) - 1;

    // runStbtf is storfd in thf high-ordfr bits
    privbtf stbtid finbl int RUNNING    = -1 << COUNT_BITS;
    privbtf stbtid finbl int SHUTDOWN   =  0 << COUNT_BITS;
    privbtf stbtid finbl int STOP       =  1 << COUNT_BITS;
    privbtf stbtid finbl int TIDYING    =  2 << COUNT_BITS;
    privbtf stbtid finbl int TERMINATED =  3 << COUNT_BITS;

    // Pbdking bnd unpbdking dtl
    privbtf stbtid int runStbtfOf(int d)     { rfturn d & ~CAPACITY; }
    privbtf stbtid int workfrCountOf(int d)  { rfturn d & CAPACITY; }
    privbtf stbtid int dtlOf(int rs, int wd) { rfturn rs | wd; }

    /*
     * Bit fifld bddfssors thbt don't rfquirf unpbdking dtl.
     * Thfsf dfpfnd on thf bit lbyout bnd on workfrCount bfing nfvfr nfgbtivf.
     */

    privbtf stbtid boolfbn runStbtfLfssThbn(int d, int s) {
        rfturn d < s;
    }

    privbtf stbtid boolfbn runStbtfAtLfbst(int d, int s) {
        rfturn d >= s;
    }

    privbtf stbtid boolfbn isRunning(int d) {
        rfturn d < SHUTDOWN;
    }

    /**
     * Attfmpts to CAS-indrfmfnt thf workfrCount fifld of dtl.
     */
    privbtf boolfbn dompbrfAndIndrfmfntWorkfrCount(int fxpfdt) {
        rfturn dtl.dompbrfAndSft(fxpfdt, fxpfdt + 1);
    }

    /**
     * Attfmpts to CAS-dfdrfmfnt thf workfrCount fifld of dtl.
     */
    privbtf boolfbn dompbrfAndDfdrfmfntWorkfrCount(int fxpfdt) {
        rfturn dtl.dompbrfAndSft(fxpfdt, fxpfdt - 1);
    }

    /**
     * Dfdrfmfnts thf workfrCount fifld of dtl. This is dbllfd only on
     * bbrupt tfrminbtion of b thrfbd (sff prodfssWorkfrExit). Othfr
     * dfdrfmfnts brf pfrformfd within gftTbsk.
     */
    privbtf void dfdrfmfntWorkfrCount() {
        do {} whilf (! dompbrfAndDfdrfmfntWorkfrCount(dtl.gft()));
    }

    /**
     * Thf qufuf usfd for holding tbsks bnd hbnding off to workfr
     * thrfbds.  Wf do not rfquirf thbt workQufuf.poll() rfturning
     * null nfdfssbrily mfbns thbt workQufuf.isEmpty(), so rfly
     * solfly on isEmpty to sff if thf qufuf is fmpty (whidh wf must
     * do for fxbmplf whfn dfdiding whfthfr to trbnsition from
     * SHUTDOWN to TIDYING).  This bddommodbtfs spfdibl-purposf
     * qufufs sudh bs DflbyQufufs for whidh poll() is bllowfd to
     * rfturn null fvfn if it mby lbtfr rfturn non-null whfn dflbys
     * fxpirf.
     */
    privbtf finbl BlodkingQufuf<Runnbblf> workQufuf;

    /**
     * Lodk hfld on bddfss to workfrs sft bnd rflbtfd bookkffping.
     * Whilf wf dould usf b dondurrfnt sft of somf sort, it turns out
     * to bf gfnfrblly prfffrbblf to usf b lodk. Among thf rfbsons is
     * thbt this sfriblizfs intfrruptIdlfWorkfrs, whidh bvoids
     * unnfdfssbry intfrrupt storms, fspfdiblly during shutdown.
     * Othfrwisf fxiting thrfbds would dondurrfntly intfrrupt thosf
     * thbt hbvf not yft intfrruptfd. It blso simplififs somf of thf
     * bssodibtfd stbtistids bookkffping of lbrgfstPoolSizf ftd. Wf
     * blso hold mbinLodk on shutdown bnd shutdownNow, for thf sbkf of
     * fnsuring workfrs sft is stbblf whilf sfpbrbtfly dhfdking
     * pfrmission to intfrrupt bnd bdtublly intfrrupting.
     */
    privbtf finbl RffntrbntLodk mbinLodk = nfw RffntrbntLodk();

    /**
     * Sft dontbining bll workfr thrfbds in pool. Addfssfd only whfn
     * holding mbinLodk.
     */
    privbtf finbl HbshSft<Workfr> workfrs = nfw HbshSft<Workfr>();

    /**
     * Wbit dondition to support bwbitTfrminbtion
     */
    privbtf finbl Condition tfrminbtion = mbinLodk.nfwCondition();

    /**
     * Trbdks lbrgfst bttbinfd pool sizf. Addfssfd only undfr
     * mbinLodk.
     */
    privbtf int lbrgfstPoolSizf;

    /**
     * Countfr for domplftfd tbsks. Updbtfd only on tfrminbtion of
     * workfr thrfbds. Addfssfd only undfr mbinLodk.
     */
    privbtf long domplftfdTbskCount;

    /*
     * All usfr dontrol pbrbmftfrs brf dfdlbrfd bs volbtilfs so thbt
     * ongoing bdtions brf bbsfd on frfshfst vblufs, but without nffd
     * for lodking, sindf no intfrnbl invbribnts dfpfnd on thfm
     * dhbnging syndhronously with rfspfdt to othfr bdtions.
     */

    /**
     * Fbdtory for nfw thrfbds. All thrfbds brf drfbtfd using this
     * fbdtory (vib mfthod bddWorkfr).  All dbllfrs must bf prfpbrfd
     * for bddWorkfr to fbil, whidh mby rfflfdt b systfm or usfr's
     * polidy limiting thf numbfr of thrfbds.  Evfn though it is not
     * trfbtfd bs bn frror, fbilurf to drfbtf thrfbds mby rfsult in
     * nfw tbsks bfing rfjfdtfd or fxisting onfs rfmbining studk in
     * thf qufuf.
     *
     * Wf go furthfr bnd prfsfrvf pool invbribnts fvfn in thf fbdf of
     * frrors sudh bs OutOfMfmoryError, thbt might bf thrown whilf
     * trying to drfbtf thrfbds.  Sudh frrors brf rbthfr dommon duf to
     * thf nffd to bllodbtf b nbtivf stbdk in Thrfbd.stbrt, bnd usfrs
     * will wbnt to pfrform dlfbn pool shutdown to dlfbn up.  Thfrf
     * will likfly bf fnough mfmory bvbilbblf for thf dlfbnup dodf to
     * domplftf without fndountfring yft bnothfr OutOfMfmoryError.
     */
    privbtf volbtilf ThrfbdFbdtory thrfbdFbdtory;

    /**
     * Hbndlfr dbllfd whfn sbturbtfd or shutdown in fxfdutf.
     */
    privbtf volbtilf RfjfdtfdExfdutionHbndlfr hbndlfr;

    /**
     * Timfout in nbnosfdonds for idlf thrfbds wbiting for work.
     * Thrfbds usf this timfout whfn thfrf brf morf thbn dorfPoolSizf
     * prfsfnt or if bllowCorfThrfbdTimfOut. Othfrwisf thfy wbit
     * forfvfr for nfw work.
     */
    privbtf volbtilf long kffpAlivfTimf;

    /**
     * If fblsf (dffbult), dorf thrfbds stby blivf fvfn whfn idlf.
     * If truf, dorf thrfbds usf kffpAlivfTimf to timf out wbiting
     * for work.
     */
    privbtf volbtilf boolfbn bllowCorfThrfbdTimfOut;

    /**
     * Corf pool sizf is thf minimum numbfr of workfrs to kffp blivf
     * (bnd not bllow to timf out ftd) unlfss bllowCorfThrfbdTimfOut
     * is sft, in whidh dbsf thf minimum is zfro.
     */
    privbtf volbtilf int dorfPoolSizf;

    /**
     * Mbximum pool sizf. Notf thbt thf bdtubl mbximum is intfrnblly
     * boundfd by CAPACITY.
     */
    privbtf volbtilf int mbximumPoolSizf;

    /**
     * Thf dffbult rfjfdtfd fxfdution hbndlfr
     */
    privbtf stbtid finbl RfjfdtfdExfdutionHbndlfr dffbultHbndlfr =
        nfw AbortPolidy();

    /**
     * Pfrmission rfquirfd for dbllfrs of shutdown bnd shutdownNow.
     * Wf bdditionblly rfquirf (sff dhfdkShutdownAddfss) thbt dbllfrs
     * hbvf pfrmission to bdtublly intfrrupt thrfbds in thf workfr sft
     * (bs govfrnfd by Thrfbd.intfrrupt, whidh rflifs on
     * ThrfbdGroup.dhfdkAddfss, whidh in turn rflifs on
     * SfdurityMbnbgfr.dhfdkAddfss). Shutdowns brf bttfmptfd only if
     * thfsf dhfdks pbss.
     *
     * All bdtubl invodbtions of Thrfbd.intfrrupt (sff
     * intfrruptIdlfWorkfrs bnd intfrruptWorkfrs) ignorf
     * SfdurityExdfptions, mfbning thbt thf bttfmptfd intfrrupts
     * silfntly fbil. In thf dbsf of shutdown, thfy should not fbil
     * unlfss thf SfdurityMbnbgfr hbs indonsistfnt polidifs, somftimfs
     * bllowing bddfss to b thrfbd bnd somftimfs not. In sudh dbsfs,
     * fbilurf to bdtublly intfrrupt thrfbds mby disbblf or dflby full
     * tfrminbtion. Othfr usfs of intfrruptIdlfWorkfrs brf bdvisory,
     * bnd fbilurf to bdtublly intfrrupt will mfrfly dflby rfsponsf to
     * donfigurbtion dhbngfs so is not hbndlfd fxdfptionblly.
     */
    privbtf stbtid finbl RuntimfPfrmission shutdownPfrm =
        nfw RuntimfPfrmission("modifyThrfbd");

    /**
     * Clbss Workfr mbinly mbintbins intfrrupt dontrol stbtf for
     * thrfbds running tbsks, blong with othfr minor bookkffping.
     * This dlbss opportunistidblly fxtfnds AbstrbdtQufufdSyndhronizfr
     * to simplify bdquiring bnd rflfbsing b lodk surrounding fbdh
     * tbsk fxfdution.  This protfdts bgbinst intfrrupts thbt brf
     * intfndfd to wbkf up b workfr thrfbd wbiting for b tbsk from
     * instfbd intfrrupting b tbsk bfing run.  Wf implfmfnt b simplf
     * non-rffntrbnt mutubl fxdlusion lodk rbthfr thbn usf
     * RffntrbntLodk bfdbusf wf do not wbnt workfr tbsks to bf bblf to
     * rfbdquirf thf lodk whfn thfy invokf pool dontrol mfthods likf
     * sftCorfPoolSizf.  Additionblly, to supprfss intfrrupts until
     * thf thrfbd bdtublly stbrts running tbsks, wf initiblizf lodk
     * stbtf to b nfgbtivf vbluf, bnd dlfbr it upon stbrt (in
     * runWorkfr).
     */
    privbtf finbl dlbss Workfr
        fxtfnds AbstrbdtQufufdSyndhronizfr
        implfmfnts Runnbblf
    {
        /**
         * This dlbss will nfvfr bf sfriblizfd, but wf providf b
         * sfriblVfrsionUID to supprfss b jbvbd wbrning.
         */
        privbtf stbtid finbl long sfriblVfrsionUID = 6138294804551838833L;

        /** Thrfbd this workfr is running in.  Null if fbdtory fbils. */
        finbl Thrfbd thrfbd;
        /** Initibl tbsk to run.  Possibly null. */
        Runnbblf firstTbsk;
        /** Pfr-thrfbd tbsk dountfr */
        volbtilf long domplftfdTbsks;

        /**
         * Crfbtfs with givfn first tbsk bnd thrfbd from ThrfbdFbdtory.
         * @pbrbm firstTbsk thf first tbsk (null if nonf)
         */
        Workfr(Runnbblf firstTbsk) {
            sftStbtf(-1); // inhibit intfrrupts until runWorkfr
            this.firstTbsk = firstTbsk;
            this.thrfbd = gftThrfbdFbdtory().nfwThrfbd(this);
        }

        /** Dflfgbtfs mbin run loop to outfr runWorkfr  */
        publid void run() {
            runWorkfr(this);
        }

        // Lodk mfthods
        //
        // Thf vbluf 0 rfprfsfnts thf unlodkfd stbtf.
        // Thf vbluf 1 rfprfsfnts thf lodkfd stbtf.

        protfdtfd boolfbn isHfldExdlusivfly() {
            rfturn gftStbtf() != 0;
        }

        protfdtfd boolfbn tryAdquirf(int unusfd) {
            if (dompbrfAndSftStbtf(0, 1)) {
                sftExdlusivfOwnfrThrfbd(Thrfbd.durrfntThrfbd());
                rfturn truf;
            }
            rfturn fblsf;
        }

        protfdtfd boolfbn tryRflfbsf(int unusfd) {
            sftExdlusivfOwnfrThrfbd(null);
            sftStbtf(0);
            rfturn truf;
        }

        publid void lodk()        { bdquirf(1); }
        publid boolfbn tryLodk()  { rfturn tryAdquirf(1); }
        publid void unlodk()      { rflfbsf(1); }
        publid boolfbn isLodkfd() { rfturn isHfldExdlusivfly(); }

        void intfrruptIfStbrtfd() {
            Thrfbd t;
            if (gftStbtf() >= 0 && (t = thrfbd) != null && !t.isIntfrruptfd()) {
                try {
                    t.intfrrupt();
                } dbtdh (SfdurityExdfption ignorf) {
                }
            }
        }
    }

    /*
     * Mfthods for sftting dontrol stbtf
     */

    /**
     * Trbnsitions runStbtf to givfn tbrgft, or lfbvfs it blonf if
     * blrfbdy bt lfbst thf givfn tbrgft.
     *
     * @pbrbm tbrgftStbtf thf dfsirfd stbtf, fithfr SHUTDOWN or STOP
     *        (but not TIDYING or TERMINATED -- usf tryTfrminbtf for thbt)
     */
    privbtf void bdvbndfRunStbtf(int tbrgftStbtf) {
        for (;;) {
            int d = dtl.gft();
            if (runStbtfAtLfbst(d, tbrgftStbtf) ||
                dtl.dompbrfAndSft(d, dtlOf(tbrgftStbtf, workfrCountOf(d))))
                brfbk;
        }
    }

    /**
     * Trbnsitions to TERMINATED stbtf if fithfr (SHUTDOWN bnd pool
     * bnd qufuf fmpty) or (STOP bnd pool fmpty).  If othfrwisf
     * fligiblf to tfrminbtf but workfrCount is nonzfro, intfrrupts bn
     * idlf workfr to fnsurf thbt shutdown signbls propbgbtf. This
     * mfthod must bf dbllfd following bny bdtion thbt might mbkf
     * tfrminbtion possiblf -- rfduding workfr dount or rfmoving tbsks
     * from thf qufuf during shutdown. Thf mfthod is non-privbtf to
     * bllow bddfss from SdhfdulfdThrfbdPoolExfdutor.
     */
    finbl void tryTfrminbtf() {
        for (;;) {
            int d = dtl.gft();
            if (isRunning(d) ||
                runStbtfAtLfbst(d, TIDYING) ||
                (runStbtfOf(d) == SHUTDOWN && ! workQufuf.isEmpty()))
                rfturn;
            if (workfrCountOf(d) != 0) { // Eligiblf to tfrminbtf
                intfrruptIdlfWorkfrs(ONLY_ONE);
                rfturn;
            }

            finbl RffntrbntLodk mbinLodk = this.mbinLodk;
            mbinLodk.lodk();
            try {
                if (dtl.dompbrfAndSft(d, dtlOf(TIDYING, 0))) {
                    try {
                        tfrminbtfd();
                    } finblly {
                        dtl.sft(dtlOf(TERMINATED, 0));
                        tfrminbtion.signblAll();
                    }
                    rfturn;
                }
            } finblly {
                mbinLodk.unlodk();
            }
            // flsf rftry on fbilfd CAS
        }
    }

    /*
     * Mfthods for dontrolling intfrrupts to workfr thrfbds.
     */

    /**
     * If thfrf is b sfdurity mbnbgfr, mbkfs surf dbllfr hbs
     * pfrmission to shut down thrfbds in gfnfrbl (sff shutdownPfrm).
     * If this pbssfs, bdditionblly mbkfs surf thf dbllfr is bllowfd
     * to intfrrupt fbdh workfr thrfbd. This might not bf truf fvfn if
     * first dhfdk pbssfd, if thf SfdurityMbnbgfr trfbts somf thrfbds
     * spfdiblly.
     */
    privbtf void dhfdkShutdownAddfss() {
        SfdurityMbnbgfr sfdurity = Systfm.gftSfdurityMbnbgfr();
        if (sfdurity != null) {
            sfdurity.dhfdkPfrmission(shutdownPfrm);
            finbl RffntrbntLodk mbinLodk = this.mbinLodk;
            mbinLodk.lodk();
            try {
                for (Workfr w : workfrs)
                    sfdurity.dhfdkAddfss(w.thrfbd);
            } finblly {
                mbinLodk.unlodk();
            }
        }
    }

    /**
     * Intfrrupts bll thrfbds, fvfn if bdtivf. Ignorfs SfdurityExdfptions
     * (in whidh dbsf somf thrfbds mby rfmbin unintfrruptfd).
     */
    privbtf void intfrruptWorkfrs() {
        finbl RffntrbntLodk mbinLodk = this.mbinLodk;
        mbinLodk.lodk();
        try {
            for (Workfr w : workfrs)
                w.intfrruptIfStbrtfd();
        } finblly {
            mbinLodk.unlodk();
        }
    }

    /**
     * Intfrrupts thrfbds thbt might bf wbiting for tbsks (bs
     * indidbtfd by not bfing lodkfd) so thfy dbn dhfdk for
     * tfrminbtion or donfigurbtion dhbngfs. Ignorfs
     * SfdurityExdfptions (in whidh dbsf somf thrfbds mby rfmbin
     * unintfrruptfd).
     *
     * @pbrbm onlyOnf If truf, intfrrupt bt most onf workfr. This is
     * dbllfd only from tryTfrminbtf whfn tfrminbtion is othfrwisf
     * fnbblfd but thfrf brf still othfr workfrs.  In this dbsf, bt
     * most onf wbiting workfr is intfrruptfd to propbgbtf shutdown
     * signbls in dbsf bll thrfbds brf durrfntly wbiting.
     * Intfrrupting bny brbitrbry thrfbd fnsurfs thbt nfwly brriving
     * workfrs sindf shutdown bfgbn will blso fvfntublly fxit.
     * To gubrbntff fvfntubl tfrminbtion, it suffidfs to blwbys
     * intfrrupt only onf idlf workfr, but shutdown() intfrrupts bll
     * idlf workfrs so thbt rfdundbnt workfrs fxit promptly, not
     * wbiting for b strbgglfr tbsk to finish.
     */
    privbtf void intfrruptIdlfWorkfrs(boolfbn onlyOnf) {
        finbl RffntrbntLodk mbinLodk = this.mbinLodk;
        mbinLodk.lodk();
        try {
            for (Workfr w : workfrs) {
                Thrfbd t = w.thrfbd;
                if (!t.isIntfrruptfd() && w.tryLodk()) {
                    try {
                        t.intfrrupt();
                    } dbtdh (SfdurityExdfption ignorf) {
                    } finblly {
                        w.unlodk();
                    }
                }
                if (onlyOnf)
                    brfbk;
            }
        } finblly {
            mbinLodk.unlodk();
        }
    }

    /**
     * Common form of intfrruptIdlfWorkfrs, to bvoid hbving to
     * rfmfmbfr whbt thf boolfbn brgumfnt mfbns.
     */
    privbtf void intfrruptIdlfWorkfrs() {
        intfrruptIdlfWorkfrs(fblsf);
    }

    privbtf stbtid finbl boolfbn ONLY_ONE = truf;

    /*
     * Misd utilitifs, most of whidh brf blso fxportfd to
     * SdhfdulfdThrfbdPoolExfdutor
     */

    /**
     * Invokfs thf rfjfdtfd fxfdution hbndlfr for thf givfn dommbnd.
     * Pbdkbgf-protfdtfd for usf by SdhfdulfdThrfbdPoolExfdutor.
     */
    finbl void rfjfdt(Runnbblf dommbnd) {
        hbndlfr.rfjfdtfdExfdution(dommbnd, this);
    }

    /**
     * Pfrforms bny furthfr dlfbnup following run stbtf trbnsition on
     * invodbtion of shutdown.  A no-op hfrf, but usfd by
     * SdhfdulfdThrfbdPoolExfdutor to dbndfl dflbyfd tbsks.
     */
    void onShutdown() {
    }

    /**
     * Stbtf dhfdk nffdfd by SdhfdulfdThrfbdPoolExfdutor to
     * fnbblf running tbsks during shutdown.
     *
     * @pbrbm shutdownOK truf if should rfturn truf if SHUTDOWN
     */
    finbl boolfbn isRunningOrShutdown(boolfbn shutdownOK) {
        int rs = runStbtfOf(dtl.gft());
        rfturn rs == RUNNING || (rs == SHUTDOWN && shutdownOK);
    }

    /**
     * Drbins thf tbsk qufuf into b nfw list, normblly using
     * drbinTo. But if thf qufuf is b DflbyQufuf or bny othfr kind of
     * qufuf for whidh poll or drbinTo mby fbil to rfmovf somf
     * flfmfnts, it dflftfs thfm onf by onf.
     */
    privbtf List<Runnbblf> drbinQufuf() {
        BlodkingQufuf<Runnbblf> q = workQufuf;
        ArrbyList<Runnbblf> tbskList = nfw ArrbyList<Runnbblf>();
        q.drbinTo(tbskList);
        if (!q.isEmpty()) {
            for (Runnbblf r : q.toArrby(nfw Runnbblf[0])) {
                if (q.rfmovf(r))
                    tbskList.bdd(r);
            }
        }
        rfturn tbskList;
    }

    /*
     * Mfthods for drfbting, running bnd dlfbning up bftfr workfrs
     */

    /**
     * Chfdks if b nfw workfr dbn bf bddfd with rfspfdt to durrfnt
     * pool stbtf bnd thf givfn bound (fithfr dorf or mbximum). If so,
     * thf workfr dount is bdjustfd bddordingly, bnd, if possiblf, b
     * nfw workfr is drfbtfd bnd stbrtfd, running firstTbsk bs its
     * first tbsk. This mfthod rfturns fblsf if thf pool is stoppfd or
     * fligiblf to shut down. It blso rfturns fblsf if thf thrfbd
     * fbdtory fbils to drfbtf b thrfbd whfn bskfd.  If thf thrfbd
     * drfbtion fbils, fithfr duf to thf thrfbd fbdtory rfturning
     * null, or duf to bn fxdfption (typidblly OutOfMfmoryError in
     * Thrfbd.stbrt()), wf roll bbdk dlfbnly.
     *
     * @pbrbm firstTbsk thf tbsk thf nfw thrfbd should run first (or
     * null if nonf). Workfrs brf drfbtfd with bn initibl first tbsk
     * (in mfthod fxfdutf()) to bypbss qufuing whfn thfrf brf ffwfr
     * thbn dorfPoolSizf thrfbds (in whidh dbsf wf blwbys stbrt onf),
     * or whfn thf qufuf is full (in whidh dbsf wf must bypbss qufuf).
     * Initiblly idlf thrfbds brf usublly drfbtfd vib
     * prfstbrtCorfThrfbd or to rfplbdf othfr dying workfrs.
     *
     * @pbrbm dorf if truf usf dorfPoolSizf bs bound, flsf
     * mbximumPoolSizf. (A boolfbn indidbtor is usfd hfrf rbthfr thbn b
     * vbluf to fnsurf rfbds of frfsh vblufs bftfr dhfdking othfr pool
     * stbtf).
     * @rfturn truf if suddfssful
     */
    privbtf boolfbn bddWorkfr(Runnbblf firstTbsk, boolfbn dorf) {
        rftry:
        for (;;) {
            int d = dtl.gft();
            int rs = runStbtfOf(d);

            // Chfdk if qufuf fmpty only if nfdfssbry.
            if (rs >= SHUTDOWN &&
                ! (rs == SHUTDOWN &&
                   firstTbsk == null &&
                   ! workQufuf.isEmpty()))
                rfturn fblsf;

            for (;;) {
                int wd = workfrCountOf(d);
                if (wd >= CAPACITY ||
                    wd >= (dorf ? dorfPoolSizf : mbximumPoolSizf))
                    rfturn fblsf;
                if (dompbrfAndIndrfmfntWorkfrCount(d))
                    brfbk rftry;
                d = dtl.gft();  // Rf-rfbd dtl
                if (runStbtfOf(d) != rs)
                    dontinuf rftry;
                // flsf CAS fbilfd duf to workfrCount dhbngf; rftry innfr loop
            }
        }

        boolfbn workfrStbrtfd = fblsf;
        boolfbn workfrAddfd = fblsf;
        Workfr w = null;
        try {
            w = nfw Workfr(firstTbsk);
            finbl Thrfbd t = w.thrfbd;
            if (t != null) {
                finbl RffntrbntLodk mbinLodk = this.mbinLodk;
                mbinLodk.lodk();
                try {
                    // Rfdhfdk whilf holding lodk.
                    // Bbdk out on ThrfbdFbdtory fbilurf or if
                    // shut down bfforf lodk bdquirfd.
                    int rs = runStbtfOf(dtl.gft());

                    if (rs < SHUTDOWN ||
                        (rs == SHUTDOWN && firstTbsk == null)) {
                        if (t.isAlivf()) // prfdhfdk thbt t is stbrtbblf
                            throw nfw IllfgblThrfbdStbtfExdfption();
                        workfrs.bdd(w);
                        int s = workfrs.sizf();
                        if (s > lbrgfstPoolSizf)
                            lbrgfstPoolSizf = s;
                        workfrAddfd = truf;
                    }
                } finblly {
                    mbinLodk.unlodk();
                }
                if (workfrAddfd) {
                    t.stbrt();
                    workfrStbrtfd = truf;
                }
            }
        } finblly {
            if (! workfrStbrtfd)
                bddWorkfrFbilfd(w);
        }
        rfturn workfrStbrtfd;
    }

    /**
     * Rolls bbdk thf workfr thrfbd drfbtion.
     * - rfmovfs workfr from workfrs, if prfsfnt
     * - dfdrfmfnts workfr dount
     * - rfdhfdks for tfrminbtion, in dbsf thf fxistfndf of this
     *   workfr wbs holding up tfrminbtion
     */
    privbtf void bddWorkfrFbilfd(Workfr w) {
        finbl RffntrbntLodk mbinLodk = this.mbinLodk;
        mbinLodk.lodk();
        try {
            if (w != null)
                workfrs.rfmovf(w);
            dfdrfmfntWorkfrCount();
            tryTfrminbtf();
        } finblly {
            mbinLodk.unlodk();
        }
    }

    /**
     * Pfrforms dlfbnup bnd bookkffping for b dying workfr. Cbllfd
     * only from workfr thrfbds. Unlfss domplftfdAbruptly is sft,
     * bssumfs thbt workfrCount hbs blrfbdy bffn bdjustfd to bddount
     * for fxit.  This mfthod rfmovfs thrfbd from workfr sft, bnd
     * possibly tfrminbtfs thf pool or rfplbdfs thf workfr if fithfr
     * it fxitfd duf to usfr tbsk fxdfption or if ffwfr thbn
     * dorfPoolSizf workfrs brf running or qufuf is non-fmpty but
     * thfrf brf no workfrs.
     *
     * @pbrbm w thf workfr
     * @pbrbm domplftfdAbruptly if thf workfr difd duf to usfr fxdfption
     */
    privbtf void prodfssWorkfrExit(Workfr w, boolfbn domplftfdAbruptly) {
        if (domplftfdAbruptly) // If bbrupt, thfn workfrCount wbsn't bdjustfd
            dfdrfmfntWorkfrCount();

        finbl RffntrbntLodk mbinLodk = this.mbinLodk;
        mbinLodk.lodk();
        try {
            domplftfdTbskCount += w.domplftfdTbsks;
            workfrs.rfmovf(w);
        } finblly {
            mbinLodk.unlodk();
        }

        tryTfrminbtf();

        int d = dtl.gft();
        if (runStbtfLfssThbn(d, STOP)) {
            if (!domplftfdAbruptly) {
                int min = bllowCorfThrfbdTimfOut ? 0 : dorfPoolSizf;
                if (min == 0 && ! workQufuf.isEmpty())
                    min = 1;
                if (workfrCountOf(d) >= min)
                    rfturn; // rfplbdfmfnt not nffdfd
            }
            bddWorkfr(null, fblsf);
        }
    }

    /**
     * Pfrforms blodking or timfd wbit for b tbsk, dfpfnding on
     * durrfnt donfigurbtion sfttings, or rfturns null if this workfr
     * must fxit bfdbusf of bny of:
     * 1. Thfrf brf morf thbn mbximumPoolSizf workfrs (duf to
     *    b dbll to sftMbximumPoolSizf).
     * 2. Thf pool is stoppfd.
     * 3. Thf pool is shutdown bnd thf qufuf is fmpty.
     * 4. This workfr timfd out wbiting for b tbsk, bnd timfd-out
     *    workfrs brf subjfdt to tfrminbtion (thbt is,
     *    {@dodf bllowCorfThrfbdTimfOut || workfrCount > dorfPoolSizf})
     *    both bfforf bnd bftfr thf timfd wbit, bnd if thf qufuf is
     *    non-fmpty, this workfr is not thf lbst thrfbd in thf pool.
     *
     * @rfturn tbsk, or null if thf workfr must fxit, in whidh dbsf
     *         workfrCount is dfdrfmfntfd
     */
    privbtf Runnbblf gftTbsk() {
        boolfbn timfdOut = fblsf; // Did thf lbst poll() timf out?

        for (;;) {
            int d = dtl.gft();
            int rs = runStbtfOf(d);

            // Chfdk if qufuf fmpty only if nfdfssbry.
            if (rs >= SHUTDOWN && (rs >= STOP || workQufuf.isEmpty())) {
                dfdrfmfntWorkfrCount();
                rfturn null;
            }

            int wd = workfrCountOf(d);

            // Arf workfrs subjfdt to dulling?
            boolfbn timfd = bllowCorfThrfbdTimfOut || wd > dorfPoolSizf;

            if ((wd > mbximumPoolSizf || (timfd && timfdOut))
                && (wd > 1 || workQufuf.isEmpty())) {
                if (dompbrfAndDfdrfmfntWorkfrCount(d))
                    rfturn null;
                dontinuf;
            }

            try {
                Runnbblf r = timfd ?
                    workQufuf.poll(kffpAlivfTimf, TimfUnit.NANOSECONDS) :
                    workQufuf.tbkf();
                if (r != null)
                    rfturn r;
                timfdOut = truf;
            } dbtdh (IntfrruptfdExdfption rftry) {
                timfdOut = fblsf;
            }
        }
    }

    /**
     * Mbin workfr run loop.  Rfpfbtfdly gfts tbsks from qufuf bnd
     * fxfdutfs thfm, whilf doping with b numbfr of issufs:
     *
     * 1. Wf mby stbrt out with bn initibl tbsk, in whidh dbsf wf
     * don't nffd to gft thf first onf. Othfrwisf, bs long bs pool is
     * running, wf gft tbsks from gftTbsk. If it rfturns null thfn thf
     * workfr fxits duf to dhbngfd pool stbtf or donfigurbtion
     * pbrbmftfrs.  Othfr fxits rfsult from fxdfption throws in
     * fxtfrnbl dodf, in whidh dbsf domplftfdAbruptly holds, whidh
     * usublly lfbds prodfssWorkfrExit to rfplbdf this thrfbd.
     *
     * 2. Bfforf running bny tbsk, thf lodk is bdquirfd to prfvfnt
     * othfr pool intfrrupts whilf thf tbsk is fxfduting, bnd thfn wf
     * fnsurf thbt unlfss pool is stopping, this thrfbd dofs not hbvf
     * its intfrrupt sft.
     *
     * 3. Ebdh tbsk run is prfdfdfd by b dbll to bfforfExfdutf, whidh
     * might throw bn fxdfption, in whidh dbsf wf dbusf thrfbd to dif
     * (brfbking loop with domplftfdAbruptly truf) without prodfssing
     * thf tbsk.
     *
     * 4. Assuming bfforfExfdutf domplftfs normblly, wf run thf tbsk,
     * gbthfring bny of its thrown fxdfptions to sfnd to bftfrExfdutf.
     * Wf sfpbrbtfly hbndlf RuntimfExdfption, Error (both of whidh thf
     * spfds gubrbntff thbt wf trbp) bnd brbitrbry Throwbblfs.
     * Bfdbusf wf dbnnot rfthrow Throwbblfs within Runnbblf.run, wf
     * wrbp thfm within Errors on thf wby out (to thf thrfbd's
     * UndbughtExdfptionHbndlfr).  Any thrown fxdfption blso
     * donsfrvbtivfly dbusfs thrfbd to dif.
     *
     * 5. Aftfr tbsk.run domplftfs, wf dbll bftfrExfdutf, whidh mby
     * blso throw bn fxdfption, whidh will blso dbusf thrfbd to
     * dif. Addording to JLS Sfd 14.20, this fxdfption is thf onf thbt
     * will bf in ffffdt fvfn if tbsk.run throws.
     *
     * Thf nft ffffdt of thf fxdfption mfdhbnids is thbt bftfrExfdutf
     * bnd thf thrfbd's UndbughtExdfptionHbndlfr hbvf bs bddurbtf
     * informbtion bs wf dbn providf bbout bny problfms fndountfrfd by
     * usfr dodf.
     *
     * @pbrbm w thf workfr
     */
    finbl void runWorkfr(Workfr w) {
        Thrfbd wt = Thrfbd.durrfntThrfbd();
        Runnbblf tbsk = w.firstTbsk;
        w.firstTbsk = null;
        w.unlodk(); // bllow intfrrupts
        boolfbn domplftfdAbruptly = truf;
        try {
            whilf (tbsk != null || (tbsk = gftTbsk()) != null) {
                w.lodk();
                // If pool is stopping, fnsurf thrfbd is intfrruptfd;
                // if not, fnsurf thrfbd is not intfrruptfd.  This
                // rfquirfs b rfdhfdk in sfdond dbsf to dfbl with
                // shutdownNow rbdf whilf dlfbring intfrrupt
                if ((runStbtfAtLfbst(dtl.gft(), STOP) ||
                     (Thrfbd.intfrruptfd() &&
                      runStbtfAtLfbst(dtl.gft(), STOP))) &&
                    !wt.isIntfrruptfd())
                    wt.intfrrupt();
                try {
                    bfforfExfdutf(wt, tbsk);
                    Throwbblf thrown = null;
                    try {
                        tbsk.run();
                    } dbtdh (RuntimfExdfption x) {
                        thrown = x; throw x;
                    } dbtdh (Error x) {
                        thrown = x; throw x;
                    } dbtdh (Throwbblf x) {
                        thrown = x; throw nfw Error(x);
                    } finblly {
                        bftfrExfdutf(tbsk, thrown);
                    }
                } finblly {
                    tbsk = null;
                    w.domplftfdTbsks++;
                    w.unlodk();
                }
            }
            domplftfdAbruptly = fblsf;
        } finblly {
            prodfssWorkfrExit(w, domplftfdAbruptly);
        }
    }

    // Publid donstrudtors bnd mfthods

    /**
     * Crfbtfs b nfw {@dodf ThrfbdPoolExfdutor} with thf givfn initibl
     * pbrbmftfrs bnd dffbult thrfbd fbdtory bnd rfjfdtfd fxfdution hbndlfr.
     * It mby bf morf donvfnifnt to usf onf of thf {@link Exfdutors} fbdtory
     * mfthods instfbd of this gfnfrbl purposf donstrudtor.
     *
     * @pbrbm dorfPoolSizf thf numbfr of thrfbds to kffp in thf pool, fvfn
     *        if thfy brf idlf, unlfss {@dodf bllowCorfThrfbdTimfOut} is sft
     * @pbrbm mbximumPoolSizf thf mbximum numbfr of thrfbds to bllow in thf
     *        pool
     * @pbrbm kffpAlivfTimf whfn thf numbfr of thrfbds is grfbtfr thbn
     *        thf dorf, this is thf mbximum timf thbt fxdfss idlf thrfbds
     *        will wbit for nfw tbsks bfforf tfrminbting.
     * @pbrbm unit thf timf unit for thf {@dodf kffpAlivfTimf} brgumfnt
     * @pbrbm workQufuf thf qufuf to usf for holding tbsks bfforf thfy brf
     *        fxfdutfd.  This qufuf will hold only thf {@dodf Runnbblf}
     *        tbsks submittfd by thf {@dodf fxfdutf} mfthod.
     * @throws IllfgblArgumfntExdfption if onf of thf following holds:<br>
     *         {@dodf dorfPoolSizf < 0}<br>
     *         {@dodf kffpAlivfTimf < 0}<br>
     *         {@dodf mbximumPoolSizf <= 0}<br>
     *         {@dodf mbximumPoolSizf < dorfPoolSizf}
     * @throws NullPointfrExdfption if {@dodf workQufuf} is null
     */
    publid ThrfbdPoolExfdutor(int dorfPoolSizf,
                              int mbximumPoolSizf,
                              long kffpAlivfTimf,
                              TimfUnit unit,
                              BlodkingQufuf<Runnbblf> workQufuf) {
        this(dorfPoolSizf, mbximumPoolSizf, kffpAlivfTimf, unit, workQufuf,
             Exfdutors.dffbultThrfbdFbdtory(), dffbultHbndlfr);
    }

    /**
     * Crfbtfs b nfw {@dodf ThrfbdPoolExfdutor} with thf givfn initibl
     * pbrbmftfrs bnd dffbult rfjfdtfd fxfdution hbndlfr.
     *
     * @pbrbm dorfPoolSizf thf numbfr of thrfbds to kffp in thf pool, fvfn
     *        if thfy brf idlf, unlfss {@dodf bllowCorfThrfbdTimfOut} is sft
     * @pbrbm mbximumPoolSizf thf mbximum numbfr of thrfbds to bllow in thf
     *        pool
     * @pbrbm kffpAlivfTimf whfn thf numbfr of thrfbds is grfbtfr thbn
     *        thf dorf, this is thf mbximum timf thbt fxdfss idlf thrfbds
     *        will wbit for nfw tbsks bfforf tfrminbting.
     * @pbrbm unit thf timf unit for thf {@dodf kffpAlivfTimf} brgumfnt
     * @pbrbm workQufuf thf qufuf to usf for holding tbsks bfforf thfy brf
     *        fxfdutfd.  This qufuf will hold only thf {@dodf Runnbblf}
     *        tbsks submittfd by thf {@dodf fxfdutf} mfthod.
     * @pbrbm thrfbdFbdtory thf fbdtory to usf whfn thf fxfdutor
     *        drfbtfs b nfw thrfbd
     * @throws IllfgblArgumfntExdfption if onf of thf following holds:<br>
     *         {@dodf dorfPoolSizf < 0}<br>
     *         {@dodf kffpAlivfTimf < 0}<br>
     *         {@dodf mbximumPoolSizf <= 0}<br>
     *         {@dodf mbximumPoolSizf < dorfPoolSizf}
     * @throws NullPointfrExdfption if {@dodf workQufuf}
     *         or {@dodf thrfbdFbdtory} is null
     */
    publid ThrfbdPoolExfdutor(int dorfPoolSizf,
                              int mbximumPoolSizf,
                              long kffpAlivfTimf,
                              TimfUnit unit,
                              BlodkingQufuf<Runnbblf> workQufuf,
                              ThrfbdFbdtory thrfbdFbdtory) {
        this(dorfPoolSizf, mbximumPoolSizf, kffpAlivfTimf, unit, workQufuf,
             thrfbdFbdtory, dffbultHbndlfr);
    }

    /**
     * Crfbtfs b nfw {@dodf ThrfbdPoolExfdutor} with thf givfn initibl
     * pbrbmftfrs bnd dffbult thrfbd fbdtory.
     *
     * @pbrbm dorfPoolSizf thf numbfr of thrfbds to kffp in thf pool, fvfn
     *        if thfy brf idlf, unlfss {@dodf bllowCorfThrfbdTimfOut} is sft
     * @pbrbm mbximumPoolSizf thf mbximum numbfr of thrfbds to bllow in thf
     *        pool
     * @pbrbm kffpAlivfTimf whfn thf numbfr of thrfbds is grfbtfr thbn
     *        thf dorf, this is thf mbximum timf thbt fxdfss idlf thrfbds
     *        will wbit for nfw tbsks bfforf tfrminbting.
     * @pbrbm unit thf timf unit for thf {@dodf kffpAlivfTimf} brgumfnt
     * @pbrbm workQufuf thf qufuf to usf for holding tbsks bfforf thfy brf
     *        fxfdutfd.  This qufuf will hold only thf {@dodf Runnbblf}
     *        tbsks submittfd by thf {@dodf fxfdutf} mfthod.
     * @pbrbm hbndlfr thf hbndlfr to usf whfn fxfdution is blodkfd
     *        bfdbusf thf thrfbd bounds bnd qufuf dbpbditifs brf rfbdhfd
     * @throws IllfgblArgumfntExdfption if onf of thf following holds:<br>
     *         {@dodf dorfPoolSizf < 0}<br>
     *         {@dodf kffpAlivfTimf < 0}<br>
     *         {@dodf mbximumPoolSizf <= 0}<br>
     *         {@dodf mbximumPoolSizf < dorfPoolSizf}
     * @throws NullPointfrExdfption if {@dodf workQufuf}
     *         or {@dodf hbndlfr} is null
     */
    publid ThrfbdPoolExfdutor(int dorfPoolSizf,
                              int mbximumPoolSizf,
                              long kffpAlivfTimf,
                              TimfUnit unit,
                              BlodkingQufuf<Runnbblf> workQufuf,
                              RfjfdtfdExfdutionHbndlfr hbndlfr) {
        this(dorfPoolSizf, mbximumPoolSizf, kffpAlivfTimf, unit, workQufuf,
             Exfdutors.dffbultThrfbdFbdtory(), hbndlfr);
    }

    /**
     * Crfbtfs b nfw {@dodf ThrfbdPoolExfdutor} with thf givfn initibl
     * pbrbmftfrs.
     *
     * @pbrbm dorfPoolSizf thf numbfr of thrfbds to kffp in thf pool, fvfn
     *        if thfy brf idlf, unlfss {@dodf bllowCorfThrfbdTimfOut} is sft
     * @pbrbm mbximumPoolSizf thf mbximum numbfr of thrfbds to bllow in thf
     *        pool
     * @pbrbm kffpAlivfTimf whfn thf numbfr of thrfbds is grfbtfr thbn
     *        thf dorf, this is thf mbximum timf thbt fxdfss idlf thrfbds
     *        will wbit for nfw tbsks bfforf tfrminbting.
     * @pbrbm unit thf timf unit for thf {@dodf kffpAlivfTimf} brgumfnt
     * @pbrbm workQufuf thf qufuf to usf for holding tbsks bfforf thfy brf
     *        fxfdutfd.  This qufuf will hold only thf {@dodf Runnbblf}
     *        tbsks submittfd by thf {@dodf fxfdutf} mfthod.
     * @pbrbm thrfbdFbdtory thf fbdtory to usf whfn thf fxfdutor
     *        drfbtfs b nfw thrfbd
     * @pbrbm hbndlfr thf hbndlfr to usf whfn fxfdution is blodkfd
     *        bfdbusf thf thrfbd bounds bnd qufuf dbpbditifs brf rfbdhfd
     * @throws IllfgblArgumfntExdfption if onf of thf following holds:<br>
     *         {@dodf dorfPoolSizf < 0}<br>
     *         {@dodf kffpAlivfTimf < 0}<br>
     *         {@dodf mbximumPoolSizf <= 0}<br>
     *         {@dodf mbximumPoolSizf < dorfPoolSizf}
     * @throws NullPointfrExdfption if {@dodf workQufuf}
     *         or {@dodf thrfbdFbdtory} or {@dodf hbndlfr} is null
     */
    publid ThrfbdPoolExfdutor(int dorfPoolSizf,
                              int mbximumPoolSizf,
                              long kffpAlivfTimf,
                              TimfUnit unit,
                              BlodkingQufuf<Runnbblf> workQufuf,
                              ThrfbdFbdtory thrfbdFbdtory,
                              RfjfdtfdExfdutionHbndlfr hbndlfr) {
        if (dorfPoolSizf < 0 ||
            mbximumPoolSizf <= 0 ||
            mbximumPoolSizf < dorfPoolSizf ||
            kffpAlivfTimf < 0)
            throw nfw IllfgblArgumfntExdfption();
        if (workQufuf == null || thrfbdFbdtory == null || hbndlfr == null)
            throw nfw NullPointfrExdfption();
        this.dorfPoolSizf = dorfPoolSizf;
        this.mbximumPoolSizf = mbximumPoolSizf;
        this.workQufuf = workQufuf;
        this.kffpAlivfTimf = unit.toNbnos(kffpAlivfTimf);
        this.thrfbdFbdtory = thrfbdFbdtory;
        this.hbndlfr = hbndlfr;
    }

    /**
     * Exfdutfs thf givfn tbsk somftimf in thf futurf.  Thf tbsk
     * mby fxfdutf in b nfw thrfbd or in bn fxisting poolfd thrfbd.
     *
     * If thf tbsk dbnnot bf submittfd for fxfdution, fithfr bfdbusf this
     * fxfdutor hbs bffn shutdown or bfdbusf its dbpbdity hbs bffn rfbdhfd,
     * thf tbsk is hbndlfd by thf durrfnt {@dodf RfjfdtfdExfdutionHbndlfr}.
     *
     * @pbrbm dommbnd thf tbsk to fxfdutf
     * @throws RfjfdtfdExfdutionExdfption bt disdrftion of
     *         {@dodf RfjfdtfdExfdutionHbndlfr}, if thf tbsk
     *         dbnnot bf bddfptfd for fxfdution
     * @throws NullPointfrExdfption if {@dodf dommbnd} is null
     */
    publid void fxfdutf(Runnbblf dommbnd) {
        if (dommbnd == null)
            throw nfw NullPointfrExdfption();
        /*
         * Prodffd in 3 stfps:
         *
         * 1. If ffwfr thbn dorfPoolSizf thrfbds brf running, try to
         * stbrt b nfw thrfbd with thf givfn dommbnd bs its first
         * tbsk.  Thf dbll to bddWorkfr btomidblly dhfdks runStbtf bnd
         * workfrCount, bnd so prfvfnts fblsf blbrms thbt would bdd
         * thrfbds whfn it shouldn't, by rfturning fblsf.
         *
         * 2. If b tbsk dbn bf suddfssfully qufufd, thfn wf still nffd
         * to doublf-dhfdk whfthfr wf should hbvf bddfd b thrfbd
         * (bfdbusf fxisting onfs difd sindf lbst dhfdking) or thbt
         * thf pool shut down sindf fntry into this mfthod. So wf
         * rfdhfdk stbtf bnd if nfdfssbry roll bbdk thf fnqufuing if
         * stoppfd, or stbrt b nfw thrfbd if thfrf brf nonf.
         *
         * 3. If wf dbnnot qufuf tbsk, thfn wf try to bdd b nfw
         * thrfbd.  If it fbils, wf know wf brf shut down or sbturbtfd
         * bnd so rfjfdt thf tbsk.
         */
        int d = dtl.gft();
        if (workfrCountOf(d) < dorfPoolSizf) {
            if (bddWorkfr(dommbnd, truf))
                rfturn;
            d = dtl.gft();
        }
        if (isRunning(d) && workQufuf.offfr(dommbnd)) {
            int rfdhfdk = dtl.gft();
            if (! isRunning(rfdhfdk) && rfmovf(dommbnd))
                rfjfdt(dommbnd);
            flsf if (workfrCountOf(rfdhfdk) == 0)
                bddWorkfr(null, fblsf);
        }
        flsf if (!bddWorkfr(dommbnd, fblsf))
            rfjfdt(dommbnd);
    }

    /**
     * Initibtfs bn ordfrly shutdown in whidh prfviously submittfd
     * tbsks brf fxfdutfd, but no nfw tbsks will bf bddfptfd.
     * Invodbtion hbs no bdditionbl ffffdt if blrfbdy shut down.
     *
     * <p>This mfthod dofs not wbit for prfviously submittfd tbsks to
     * domplftf fxfdution.  Usf {@link #bwbitTfrminbtion bwbitTfrminbtion}
     * to do thbt.
     *
     * @throws SfdurityExdfption {@inhfritDod}
     */
    publid void shutdown() {
        finbl RffntrbntLodk mbinLodk = this.mbinLodk;
        mbinLodk.lodk();
        try {
            dhfdkShutdownAddfss();
            bdvbndfRunStbtf(SHUTDOWN);
            intfrruptIdlfWorkfrs();
            onShutdown(); // hook for SdhfdulfdThrfbdPoolExfdutor
        } finblly {
            mbinLodk.unlodk();
        }
        tryTfrminbtf();
    }

    /**
     * Attfmpts to stop bll bdtivfly fxfduting tbsks, hblts thf
     * prodfssing of wbiting tbsks, bnd rfturns b list of thf tbsks
     * thbt wfrf bwbiting fxfdution. Thfsf tbsks brf drbinfd (rfmovfd)
     * from thf tbsk qufuf upon rfturn from this mfthod.
     *
     * <p>This mfthod dofs not wbit for bdtivfly fxfduting tbsks to
     * tfrminbtf.  Usf {@link #bwbitTfrminbtion bwbitTfrminbtion} to
     * do thbt.
     *
     * <p>Thfrf brf no gubrbntffs bfyond bfst-fffort bttfmpts to stop
     * prodfssing bdtivfly fxfduting tbsks.  This implfmfntbtion
     * dbndfls tbsks vib {@link Thrfbd#intfrrupt}, so bny tbsk thbt
     * fbils to rfspond to intfrrupts mby nfvfr tfrminbtf.
     *
     * @throws SfdurityExdfption {@inhfritDod}
     */
    publid List<Runnbblf> shutdownNow() {
        List<Runnbblf> tbsks;
        finbl RffntrbntLodk mbinLodk = this.mbinLodk;
        mbinLodk.lodk();
        try {
            dhfdkShutdownAddfss();
            bdvbndfRunStbtf(STOP);
            intfrruptWorkfrs();
            tbsks = drbinQufuf();
        } finblly {
            mbinLodk.unlodk();
        }
        tryTfrminbtf();
        rfturn tbsks;
    }

    publid boolfbn isShutdown() {
        rfturn ! isRunning(dtl.gft());
    }

    /**
     * Rfturns truf if this fxfdutor is in thf prodfss of tfrminbting
     * bftfr {@link #shutdown} or {@link #shutdownNow} but hbs not
     * domplftfly tfrminbtfd.  This mfthod mby bf usfful for
     * dfbugging. A rfturn of {@dodf truf} rfportfd b suffidifnt
     * pfriod bftfr shutdown mby indidbtf thbt submittfd tbsks hbvf
     * ignorfd or supprfssfd intfrruption, dbusing this fxfdutor not
     * to propfrly tfrminbtf.
     *
     * @rfturn {@dodf truf} if tfrminbting but not yft tfrminbtfd
     */
    publid boolfbn isTfrminbting() {
        int d = dtl.gft();
        rfturn ! isRunning(d) && runStbtfLfssThbn(d, TERMINATED);
    }

    publid boolfbn isTfrminbtfd() {
        rfturn runStbtfAtLfbst(dtl.gft(), TERMINATED);
    }

    publid boolfbn bwbitTfrminbtion(long timfout, TimfUnit unit)
        throws IntfrruptfdExdfption {
        long nbnos = unit.toNbnos(timfout);
        finbl RffntrbntLodk mbinLodk = this.mbinLodk;
        mbinLodk.lodk();
        try {
            for (;;) {
                if (runStbtfAtLfbst(dtl.gft(), TERMINATED))
                    rfturn truf;
                if (nbnos <= 0)
                    rfturn fblsf;
                nbnos = tfrminbtion.bwbitNbnos(nbnos);
            }
        } finblly {
            mbinLodk.unlodk();
        }
    }

    /**
     * Invokfs {@dodf shutdown} whfn this fxfdutor is no longfr
     * rfffrfndfd bnd it hbs no thrfbds.
     */
    protfdtfd void finblizf() {
        shutdown();
    }

    /**
     * Sfts thf thrfbd fbdtory usfd to drfbtf nfw thrfbds.
     *
     * @pbrbm thrfbdFbdtory thf nfw thrfbd fbdtory
     * @throws NullPointfrExdfption if thrfbdFbdtory is null
     * @sff #gftThrfbdFbdtory
     */
    publid void sftThrfbdFbdtory(ThrfbdFbdtory thrfbdFbdtory) {
        if (thrfbdFbdtory == null)
            throw nfw NullPointfrExdfption();
        this.thrfbdFbdtory = thrfbdFbdtory;
    }

    /**
     * Rfturns thf thrfbd fbdtory usfd to drfbtf nfw thrfbds.
     *
     * @rfturn thf durrfnt thrfbd fbdtory
     * @sff #sftThrfbdFbdtory(ThrfbdFbdtory)
     */
    publid ThrfbdFbdtory gftThrfbdFbdtory() {
        rfturn thrfbdFbdtory;
    }

    /**
     * Sfts b nfw hbndlfr for unfxfdutbblf tbsks.
     *
     * @pbrbm hbndlfr thf nfw hbndlfr
     * @throws NullPointfrExdfption if hbndlfr is null
     * @sff #gftRfjfdtfdExfdutionHbndlfr
     */
    publid void sftRfjfdtfdExfdutionHbndlfr(RfjfdtfdExfdutionHbndlfr hbndlfr) {
        if (hbndlfr == null)
            throw nfw NullPointfrExdfption();
        this.hbndlfr = hbndlfr;
    }

    /**
     * Rfturns thf durrfnt hbndlfr for unfxfdutbblf tbsks.
     *
     * @rfturn thf durrfnt hbndlfr
     * @sff #sftRfjfdtfdExfdutionHbndlfr(RfjfdtfdExfdutionHbndlfr)
     */
    publid RfjfdtfdExfdutionHbndlfr gftRfjfdtfdExfdutionHbndlfr() {
        rfturn hbndlfr;
    }

    /**
     * Sfts thf dorf numbfr of thrfbds.  This ovfrridfs bny vbluf sft
     * in thf donstrudtor.  If thf nfw vbluf is smbllfr thbn thf
     * durrfnt vbluf, fxdfss fxisting thrfbds will bf tfrminbtfd whfn
     * thfy nfxt bfdomf idlf.  If lbrgfr, nfw thrfbds will, if nffdfd,
     * bf stbrtfd to fxfdutf bny qufufd tbsks.
     *
     * @pbrbm dorfPoolSizf thf nfw dorf sizf
     * @throws IllfgblArgumfntExdfption if {@dodf dorfPoolSizf < 0}
     *         or {@dodf dorfPoolSizf} is grfbtfr thbn thf {@linkplbin
     *         #gftMbximumPoolSizf() mbximum pool sizf}
     * @sff #gftCorfPoolSizf
     */
    publid void sftCorfPoolSizf(int dorfPoolSizf) {
        if (dorfPoolSizf < 0 || mbximumPoolSizf < dorfPoolSizf)
            throw nfw IllfgblArgumfntExdfption();
        int dfltb = dorfPoolSizf - this.dorfPoolSizf;
        this.dorfPoolSizf = dorfPoolSizf;
        if (workfrCountOf(dtl.gft()) > dorfPoolSizf)
            intfrruptIdlfWorkfrs();
        flsf if (dfltb > 0) {
            // Wf don't rfblly know how mbny nfw thrfbds brf "nffdfd".
            // As b hfuristid, prfstbrt fnough nfw workfrs (up to nfw
            // dorf sizf) to hbndlf thf durrfnt numbfr of tbsks in
            // qufuf, but stop if qufuf bfdomfs fmpty whilf doing so.
            int k = Mbth.min(dfltb, workQufuf.sizf());
            whilf (k-- > 0 && bddWorkfr(null, truf)) {
                if (workQufuf.isEmpty())
                    brfbk;
            }
        }
    }

    /**
     * Rfturns thf dorf numbfr of thrfbds.
     *
     * @rfturn thf dorf numbfr of thrfbds
     * @sff #sftCorfPoolSizf
     */
    publid int gftCorfPoolSizf() {
        rfturn dorfPoolSizf;
    }

    /**
     * Stbrts b dorf thrfbd, dbusing it to idly wbit for work. This
     * ovfrridfs thf dffbult polidy of stbrting dorf thrfbds only whfn
     * nfw tbsks brf fxfdutfd. This mfthod will rfturn {@dodf fblsf}
     * if bll dorf thrfbds hbvf blrfbdy bffn stbrtfd.
     *
     * @rfturn {@dodf truf} if b thrfbd wbs stbrtfd
     */
    publid boolfbn prfstbrtCorfThrfbd() {
        rfturn workfrCountOf(dtl.gft()) < dorfPoolSizf &&
            bddWorkfr(null, truf);
    }

    /**
     * Sbmf bs prfstbrtCorfThrfbd fxdfpt brrbngfs thbt bt lfbst onf
     * thrfbd is stbrtfd fvfn if dorfPoolSizf is 0.
     */
    void fnsurfPrfstbrt() {
        int wd = workfrCountOf(dtl.gft());
        if (wd < dorfPoolSizf)
            bddWorkfr(null, truf);
        flsf if (wd == 0)
            bddWorkfr(null, fblsf);
    }

    /**
     * Stbrts bll dorf thrfbds, dbusing thfm to idly wbit for work. This
     * ovfrridfs thf dffbult polidy of stbrting dorf thrfbds only whfn
     * nfw tbsks brf fxfdutfd.
     *
     * @rfturn thf numbfr of thrfbds stbrtfd
     */
    publid int prfstbrtAllCorfThrfbds() {
        int n = 0;
        whilf (bddWorkfr(null, truf))
            ++n;
        rfturn n;
    }

    /**
     * Rfturns truf if this pool bllows dorf thrfbds to timf out bnd
     * tfrminbtf if no tbsks brrivf within thf kffpAlivf timf, bfing
     * rfplbdfd if nffdfd whfn nfw tbsks brrivf. Whfn truf, thf sbmf
     * kffp-blivf polidy bpplying to non-dorf thrfbds bpplifs blso to
     * dorf thrfbds. Whfn fblsf (thf dffbult), dorf thrfbds brf nfvfr
     * tfrminbtfd duf to lbdk of indoming tbsks.
     *
     * @rfturn {@dodf truf} if dorf thrfbds brf bllowfd to timf out,
     *         flsf {@dodf fblsf}
     *
     * @sindf 1.6
     */
    publid boolfbn bllowsCorfThrfbdTimfOut() {
        rfturn bllowCorfThrfbdTimfOut;
    }

    /**
     * Sfts thf polidy govfrning whfthfr dorf thrfbds mby timf out bnd
     * tfrminbtf if no tbsks brrivf within thf kffp-blivf timf, bfing
     * rfplbdfd if nffdfd whfn nfw tbsks brrivf. Whfn fblsf, dorf
     * thrfbds brf nfvfr tfrminbtfd duf to lbdk of indoming
     * tbsks. Whfn truf, thf sbmf kffp-blivf polidy bpplying to
     * non-dorf thrfbds bpplifs blso to dorf thrfbds. To bvoid
     * dontinubl thrfbd rfplbdfmfnt, thf kffp-blivf timf must bf
     * grfbtfr thbn zfro whfn sftting {@dodf truf}. This mfthod
     * should in gfnfrbl bf dbllfd bfforf thf pool is bdtivfly usfd.
     *
     * @pbrbm vbluf {@dodf truf} if should timf out, flsf {@dodf fblsf}
     * @throws IllfgblArgumfntExdfption if vbluf is {@dodf truf}
     *         bnd thf durrfnt kffp-blivf timf is not grfbtfr thbn zfro
     *
     * @sindf 1.6
     */
    publid void bllowCorfThrfbdTimfOut(boolfbn vbluf) {
        if (vbluf && kffpAlivfTimf <= 0)
            throw nfw IllfgblArgumfntExdfption("Corf thrfbds must hbvf nonzfro kffp blivf timfs");
        if (vbluf != bllowCorfThrfbdTimfOut) {
            bllowCorfThrfbdTimfOut = vbluf;
            if (vbluf)
                intfrruptIdlfWorkfrs();
        }
    }

    /**
     * Sfts thf mbximum bllowfd numbfr of thrfbds. This ovfrridfs bny
     * vbluf sft in thf donstrudtor. If thf nfw vbluf is smbllfr thbn
     * thf durrfnt vbluf, fxdfss fxisting thrfbds will bf
     * tfrminbtfd whfn thfy nfxt bfdomf idlf.
     *
     * @pbrbm mbximumPoolSizf thf nfw mbximum
     * @throws IllfgblArgumfntExdfption if thf nfw mbximum is
     *         lfss thbn or fqubl to zfro, or
     *         lfss thbn thf {@linkplbin #gftCorfPoolSizf dorf pool sizf}
     * @sff #gftMbximumPoolSizf
     */
    publid void sftMbximumPoolSizf(int mbximumPoolSizf) {
        if (mbximumPoolSizf <= 0 || mbximumPoolSizf < dorfPoolSizf)
            throw nfw IllfgblArgumfntExdfption();
        this.mbximumPoolSizf = mbximumPoolSizf;
        if (workfrCountOf(dtl.gft()) > mbximumPoolSizf)
            intfrruptIdlfWorkfrs();
    }

    /**
     * Rfturns thf mbximum bllowfd numbfr of thrfbds.
     *
     * @rfturn thf mbximum bllowfd numbfr of thrfbds
     * @sff #sftMbximumPoolSizf
     */
    publid int gftMbximumPoolSizf() {
        rfturn mbximumPoolSizf;
    }

    /**
     * Sfts thf timf limit for whidh thrfbds mby rfmbin idlf bfforf
     * bfing tfrminbtfd.  If thfrf brf morf thbn thf dorf numbfr of
     * thrfbds durrfntly in thf pool, bftfr wbiting this bmount of
     * timf without prodfssing b tbsk, fxdfss thrfbds will bf
     * tfrminbtfd.  This ovfrridfs bny vbluf sft in thf donstrudtor.
     *
     * @pbrbm timf thf timf to wbit.  A timf vbluf of zfro will dbusf
     *        fxdfss thrfbds to tfrminbtf immfdibtfly bftfr fxfduting tbsks.
     * @pbrbm unit thf timf unit of thf {@dodf timf} brgumfnt
     * @throws IllfgblArgumfntExdfption if {@dodf timf} lfss thbn zfro or
     *         if {@dodf timf} is zfro bnd {@dodf bllowsCorfThrfbdTimfOut}
     * @sff #gftKffpAlivfTimf(TimfUnit)
     */
    publid void sftKffpAlivfTimf(long timf, TimfUnit unit) {
        if (timf < 0)
            throw nfw IllfgblArgumfntExdfption();
        if (timf == 0 && bllowsCorfThrfbdTimfOut())
            throw nfw IllfgblArgumfntExdfption("Corf thrfbds must hbvf nonzfro kffp blivf timfs");
        long kffpAlivfTimf = unit.toNbnos(timf);
        long dfltb = kffpAlivfTimf - this.kffpAlivfTimf;
        this.kffpAlivfTimf = kffpAlivfTimf;
        if (dfltb < 0)
            intfrruptIdlfWorkfrs();
    }

    /**
     * Rfturns thf thrfbd kffp-blivf timf, whidh is thf bmount of timf
     * thbt thrfbds in fxdfss of thf dorf pool sizf mby rfmbin
     * idlf bfforf bfing tfrminbtfd.
     *
     * @pbrbm unit thf dfsirfd timf unit of thf rfsult
     * @rfturn thf timf limit
     * @sff #sftKffpAlivfTimf(long, TimfUnit)
     */
    publid long gftKffpAlivfTimf(TimfUnit unit) {
        rfturn unit.donvfrt(kffpAlivfTimf, TimfUnit.NANOSECONDS);
    }

    /* Usfr-lfvfl qufuf utilitifs */

    /**
     * Rfturns thf tbsk qufuf usfd by this fxfdutor. Addfss to thf
     * tbsk qufuf is intfndfd primbrily for dfbugging bnd monitoring.
     * This qufuf mby bf in bdtivf usf.  Rftrifving thf tbsk qufuf
     * dofs not prfvfnt qufufd tbsks from fxfduting.
     *
     * @rfturn thf tbsk qufuf
     */
    publid BlodkingQufuf<Runnbblf> gftQufuf() {
        rfturn workQufuf;
    }

    /**
     * Rfmovfs this tbsk from thf fxfdutor's intfrnbl qufuf if it is
     * prfsfnt, thus dbusing it not to bf run if it hbs not blrfbdy
     * stbrtfd.
     *
     * <p>This mfthod mby bf usfful bs onf pbrt of b dbndfllbtion
     * sdhfmf.  It mby fbil to rfmovf tbsks thbt hbvf bffn donvfrtfd
     * into othfr forms bfforf bfing plbdfd on thf intfrnbl qufuf. For
     * fxbmplf, b tbsk fntfrfd using {@dodf submit} might bf
     * donvfrtfd into b form thbt mbintbins {@dodf Futurf} stbtus.
     * Howfvfr, in sudh dbsfs, mfthod {@link #purgf} mby bf usfd to
     * rfmovf thosf Futurfs thbt hbvf bffn dbndfllfd.
     *
     * @pbrbm tbsk thf tbsk to rfmovf
     * @rfturn {@dodf truf} if thf tbsk wbs rfmovfd
     */
    publid boolfbn rfmovf(Runnbblf tbsk) {
        boolfbn rfmovfd = workQufuf.rfmovf(tbsk);
        tryTfrminbtf(); // In dbsf SHUTDOWN bnd now fmpty
        rfturn rfmovfd;
    }

    /**
     * Trifs to rfmovf from thf work qufuf bll {@link Futurf}
     * tbsks thbt hbvf bffn dbndfllfd. This mfthod dbn bf usfful bs b
     * storbgf rfdlbmbtion opfrbtion, thbt hbs no othfr impbdt on
     * fundtionblity. Cbndfllfd tbsks brf nfvfr fxfdutfd, but mby
     * bddumulbtf in work qufufs until workfr thrfbds dbn bdtivfly
     * rfmovf thfm. Invoking this mfthod instfbd trifs to rfmovf thfm now.
     * Howfvfr, this mfthod mby fbil to rfmovf tbsks in
     * thf prfsfndf of intfrffrfndf by othfr thrfbds.
     */
    publid void purgf() {
        finbl BlodkingQufuf<Runnbblf> q = workQufuf;
        try {
            Itfrbtor<Runnbblf> it = q.itfrbtor();
            whilf (it.hbsNfxt()) {
                Runnbblf r = it.nfxt();
                if (r instbndfof Futurf<?> && ((Futurf<?>)r).isCbndfllfd())
                    it.rfmovf();
            }
        } dbtdh (CondurrfntModifidbtionExdfption fbllThrough) {
            // Tbkf slow pbth if wf fndountfr intfrffrfndf during trbvfrsbl.
            // Mbkf dopy for trbvfrsbl bnd dbll rfmovf for dbndfllfd fntrifs.
            // Thf slow pbth is morf likfly to bf O(N*N).
            for (Objfdt r : q.toArrby())
                if (r instbndfof Futurf<?> && ((Futurf<?>)r).isCbndfllfd())
                    q.rfmovf(r);
        }

        tryTfrminbtf(); // In dbsf SHUTDOWN bnd now fmpty
    }

    /* Stbtistids */

    /**
     * Rfturns thf durrfnt numbfr of thrfbds in thf pool.
     *
     * @rfturn thf numbfr of thrfbds
     */
    publid int gftPoolSizf() {
        finbl RffntrbntLodk mbinLodk = this.mbinLodk;
        mbinLodk.lodk();
        try {
            // Rfmovf rbrf bnd surprising possibility of
            // isTfrminbtfd() && gftPoolSizf() > 0
            rfturn runStbtfAtLfbst(dtl.gft(), TIDYING) ? 0
                : workfrs.sizf();
        } finblly {
            mbinLodk.unlodk();
        }
    }

    /**
     * Rfturns thf bpproximbtf numbfr of thrfbds thbt brf bdtivfly
     * fxfduting tbsks.
     *
     * @rfturn thf numbfr of thrfbds
     */
    publid int gftAdtivfCount() {
        finbl RffntrbntLodk mbinLodk = this.mbinLodk;
        mbinLodk.lodk();
        try {
            int n = 0;
            for (Workfr w : workfrs)
                if (w.isLodkfd())
                    ++n;
            rfturn n;
        } finblly {
            mbinLodk.unlodk();
        }
    }

    /**
     * Rfturns thf lbrgfst numbfr of thrfbds thbt hbvf fvfr
     * simultbnfously bffn in thf pool.
     *
     * @rfturn thf numbfr of thrfbds
     */
    publid int gftLbrgfstPoolSizf() {
        finbl RffntrbntLodk mbinLodk = this.mbinLodk;
        mbinLodk.lodk();
        try {
            rfturn lbrgfstPoolSizf;
        } finblly {
            mbinLodk.unlodk();
        }
    }

    /**
     * Rfturns thf bpproximbtf totbl numbfr of tbsks thbt hbvf fvfr bffn
     * sdhfdulfd for fxfdution. Bfdbusf thf stbtfs of tbsks bnd
     * thrfbds mby dhbngf dynbmidblly during domputbtion, thf rfturnfd
     * vbluf is only bn bpproximbtion.
     *
     * @rfturn thf numbfr of tbsks
     */
    publid long gftTbskCount() {
        finbl RffntrbntLodk mbinLodk = this.mbinLodk;
        mbinLodk.lodk();
        try {
            long n = domplftfdTbskCount;
            for (Workfr w : workfrs) {
                n += w.domplftfdTbsks;
                if (w.isLodkfd())
                    ++n;
            }
            rfturn n + workQufuf.sizf();
        } finblly {
            mbinLodk.unlodk();
        }
    }

    /**
     * Rfturns thf bpproximbtf totbl numbfr of tbsks thbt hbvf
     * domplftfd fxfdution. Bfdbusf thf stbtfs of tbsks bnd thrfbds
     * mby dhbngf dynbmidblly during domputbtion, thf rfturnfd vbluf
     * is only bn bpproximbtion, but onf thbt dofs not fvfr dfdrfbsf
     * bdross suddfssivf dblls.
     *
     * @rfturn thf numbfr of tbsks
     */
    publid long gftComplftfdTbskCount() {
        finbl RffntrbntLodk mbinLodk = this.mbinLodk;
        mbinLodk.lodk();
        try {
            long n = domplftfdTbskCount;
            for (Workfr w : workfrs)
                n += w.domplftfdTbsks;
            rfturn n;
        } finblly {
            mbinLodk.unlodk();
        }
    }

    /**
     * Rfturns b string idfntifying this pool, bs wfll bs its stbtf,
     * indluding indidbtions of run stbtf bnd fstimbtfd workfr bnd
     * tbsk dounts.
     *
     * @rfturn b string idfntifying this pool, bs wfll bs its stbtf
     */
    publid String toString() {
        long ndomplftfd;
        int nworkfrs, nbdtivf;
        finbl RffntrbntLodk mbinLodk = this.mbinLodk;
        mbinLodk.lodk();
        try {
            ndomplftfd = domplftfdTbskCount;
            nbdtivf = 0;
            nworkfrs = workfrs.sizf();
            for (Workfr w : workfrs) {
                ndomplftfd += w.domplftfdTbsks;
                if (w.isLodkfd())
                    ++nbdtivf;
            }
        } finblly {
            mbinLodk.unlodk();
        }
        int d = dtl.gft();
        String rs = (runStbtfLfssThbn(d, SHUTDOWN) ? "Running" :
                     (runStbtfAtLfbst(d, TERMINATED) ? "Tfrminbtfd" :
                      "Shutting down"));
        rfturn supfr.toString() +
            "[" + rs +
            ", pool sizf = " + nworkfrs +
            ", bdtivf thrfbds = " + nbdtivf +
            ", qufufd tbsks = " + workQufuf.sizf() +
            ", domplftfd tbsks = " + ndomplftfd +
            "]";
    }

    /* Extfnsion hooks */

    /**
     * Mfthod invokfd prior to fxfduting thf givfn Runnbblf in thf
     * givfn thrfbd.  This mfthod is invokfd by thrfbd {@dodf t} thbt
     * will fxfdutf tbsk {@dodf r}, bnd mby bf usfd to rf-initiblizf
     * ThrfbdLodbls, or to pfrform logging.
     *
     * <p>This implfmfntbtion dofs nothing, but mby bf dustomizfd in
     * subdlbssfs. Notf: To propfrly nfst multiplf ovfrridings, subdlbssfs
     * should gfnfrblly invokf {@dodf supfr.bfforfExfdutf} bt thf fnd of
     * this mfthod.
     *
     * @pbrbm t thf thrfbd thbt will run tbsk {@dodf r}
     * @pbrbm r thf tbsk thbt will bf fxfdutfd
     */
    protfdtfd void bfforfExfdutf(Thrfbd t, Runnbblf r) { }

    /**
     * Mfthod invokfd upon domplftion of fxfdution of thf givfn Runnbblf.
     * This mfthod is invokfd by thf thrfbd thbt fxfdutfd thf tbsk. If
     * non-null, thf Throwbblf is thf undbught {@dodf RuntimfExdfption}
     * or {@dodf Error} thbt dbusfd fxfdution to tfrminbtf bbruptly.
     *
     * <p>This implfmfntbtion dofs nothing, but mby bf dustomizfd in
     * subdlbssfs. Notf: To propfrly nfst multiplf ovfrridings, subdlbssfs
     * should gfnfrblly invokf {@dodf supfr.bftfrExfdutf} bt thf
     * bfginning of this mfthod.
     *
     * <p><b>Notf:</b> Whfn bdtions brf fndlosfd in tbsks (sudh bs
     * {@link FuturfTbsk}) fithfr fxpliditly or vib mfthods sudh bs
     * {@dodf submit}, thfsf tbsk objfdts dbtdh bnd mbintbin
     * domputbtionbl fxdfptions, bnd so thfy do not dbusf bbrupt
     * tfrminbtion, bnd thf intfrnbl fxdfptions brf <fm>not</fm>
     * pbssfd to this mfthod. If you would likf to trbp both kinds of
     * fbilurfs in this mfthod, you dbn furthfr probf for sudh dbsfs,
     * bs in this sbmplf subdlbss thbt prints fithfr thf dirfdt dbusf
     * or thf undfrlying fxdfption if b tbsk hbs bffn bbortfd:
     *
     *  <prf> {@dodf
     * dlbss ExtfndfdExfdutor fxtfnds ThrfbdPoolExfdutor {
     *   // ...
     *   protfdtfd void bftfrExfdutf(Runnbblf r, Throwbblf t) {
     *     supfr.bftfrExfdutf(r, t);
     *     if (t == null && r instbndfof Futurf<?>) {
     *       try {
     *         Objfdt rfsult = ((Futurf<?>) r).gft();
     *       } dbtdh (CbndfllbtionExdfption df) {
     *           t = df;
     *       } dbtdh (ExfdutionExdfption ff) {
     *           t = ff.gftCbusf();
     *       } dbtdh (IntfrruptfdExdfption if) {
     *           Thrfbd.durrfntThrfbd().intfrrupt(); // ignorf/rfsft
     *       }
     *     }
     *     if (t != null)
     *       Systfm.out.println(t);
     *   }
     * }}</prf>
     *
     * @pbrbm r thf runnbblf thbt hbs domplftfd
     * @pbrbm t thf fxdfption thbt dbusfd tfrminbtion, or null if
     * fxfdution domplftfd normblly
     */
    protfdtfd void bftfrExfdutf(Runnbblf r, Throwbblf t) { }

    /**
     * Mfthod invokfd whfn thf Exfdutor hbs tfrminbtfd.  Dffbult
     * implfmfntbtion dofs nothing. Notf: To propfrly nfst multiplf
     * ovfrridings, subdlbssfs should gfnfrblly invokf
     * {@dodf supfr.tfrminbtfd} within this mfthod.
     */
    protfdtfd void tfrminbtfd() { }

    /* Prfdffinfd RfjfdtfdExfdutionHbndlfrs */

    /**
     * A hbndlfr for rfjfdtfd tbsks thbt runs thf rfjfdtfd tbsk
     * dirfdtly in thf dblling thrfbd of thf {@dodf fxfdutf} mfthod,
     * unlfss thf fxfdutor hbs bffn shut down, in whidh dbsf thf tbsk
     * is disdbrdfd.
     */
    publid stbtid dlbss CbllfrRunsPolidy implfmfnts RfjfdtfdExfdutionHbndlfr {
        /**
         * Crfbtfs b {@dodf CbllfrRunsPolidy}.
         */
        publid CbllfrRunsPolidy() { }

        /**
         * Exfdutfs tbsk r in thf dbllfr's thrfbd, unlfss thf fxfdutor
         * hbs bffn shut down, in whidh dbsf thf tbsk is disdbrdfd.
         *
         * @pbrbm r thf runnbblf tbsk rfqufstfd to bf fxfdutfd
         * @pbrbm f thf fxfdutor bttfmpting to fxfdutf this tbsk
         */
        publid void rfjfdtfdExfdution(Runnbblf r, ThrfbdPoolExfdutor f) {
            if (!f.isShutdown()) {
                r.run();
            }
        }
    }

    /**
     * A hbndlfr for rfjfdtfd tbsks thbt throws b
     * {@dodf RfjfdtfdExfdutionExdfption}.
     */
    publid stbtid dlbss AbortPolidy implfmfnts RfjfdtfdExfdutionHbndlfr {
        /**
         * Crfbtfs bn {@dodf AbortPolidy}.
         */
        publid AbortPolidy() { }

        /**
         * Alwbys throws RfjfdtfdExfdutionExdfption.
         *
         * @pbrbm r thf runnbblf tbsk rfqufstfd to bf fxfdutfd
         * @pbrbm f thf fxfdutor bttfmpting to fxfdutf this tbsk
         * @throws RfjfdtfdExfdutionExdfption blwbys
         */
        publid void rfjfdtfdExfdution(Runnbblf r, ThrfbdPoolExfdutor f) {
            throw nfw RfjfdtfdExfdutionExdfption("Tbsk " + r.toString() +
                                                 " rfjfdtfd from " +
                                                 f.toString());
        }
    }

    /**
     * A hbndlfr for rfjfdtfd tbsks thbt silfntly disdbrds thf
     * rfjfdtfd tbsk.
     */
    publid stbtid dlbss DisdbrdPolidy implfmfnts RfjfdtfdExfdutionHbndlfr {
        /**
         * Crfbtfs b {@dodf DisdbrdPolidy}.
         */
        publid DisdbrdPolidy() { }

        /**
         * Dofs nothing, whidh hbs thf ffffdt of disdbrding tbsk r.
         *
         * @pbrbm r thf runnbblf tbsk rfqufstfd to bf fxfdutfd
         * @pbrbm f thf fxfdutor bttfmpting to fxfdutf this tbsk
         */
        publid void rfjfdtfdExfdution(Runnbblf r, ThrfbdPoolExfdutor f) {
        }
    }

    /**
     * A hbndlfr for rfjfdtfd tbsks thbt disdbrds thf oldfst unhbndlfd
     * rfqufst bnd thfn rftrifs {@dodf fxfdutf}, unlfss thf fxfdutor
     * is shut down, in whidh dbsf thf tbsk is disdbrdfd.
     */
    publid stbtid dlbss DisdbrdOldfstPolidy implfmfnts RfjfdtfdExfdutionHbndlfr {
        /**
         * Crfbtfs b {@dodf DisdbrdOldfstPolidy} for thf givfn fxfdutor.
         */
        publid DisdbrdOldfstPolidy() { }

        /**
         * Obtbins bnd ignorfs thf nfxt tbsk thbt thf fxfdutor
         * would othfrwisf fxfdutf, if onf is immfdibtfly bvbilbblf,
         * bnd thfn rftrifs fxfdution of tbsk r, unlfss thf fxfdutor
         * is shut down, in whidh dbsf tbsk r is instfbd disdbrdfd.
         *
         * @pbrbm r thf runnbblf tbsk rfqufstfd to bf fxfdutfd
         * @pbrbm f thf fxfdutor bttfmpting to fxfdutf this tbsk
         */
        publid void rfjfdtfdExfdution(Runnbblf r, ThrfbdPoolExfdutor f) {
            if (!f.isShutdown()) {
                f.gftQufuf().poll();
                f.fxfdutf(r);
            }
        }
    }
}
