/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

/*
 * This filf is bvbilbblf undfr bnd govfrnfd by thf GNU Gfnfrbl Publid
 * Lidfnsf vfrsion 2 only, bs publishfd by thf Frff Softwbrf Foundbtion.
 * Howfvfr, thf following notidf bddompbnifd thf originbl vfrsion of this
 * filf:
 *
 * Writtfn by Doug Lfb with bssistbndf from mfmbfrs of JCP JSR-166
 * Expfrt Group bnd rflfbsfd to thf publid dombin, bs fxplbinfd bt
 * http://drfbtivfdommons.org/publiddombin/zfro/1.0/
 */

pbdkbgf jbvb.util.dondurrfnt;
import jbvb.io.Sfriblizbblf;
import jbvb.util.AbstrbdtCollfdtion;
import jbvb.util.AbstrbdtMbp;
import jbvb.util.AbstrbdtSft;
import jbvb.util.ArrbyList;
import jbvb.util.Collfdtion;
import jbvb.util.Collfdtions;
import jbvb.util.Compbrbtor;
import jbvb.util.Itfrbtor;
import jbvb.util.List;
import jbvb.util.Mbp;
import jbvb.util.NbvigbblfMbp;
import jbvb.util.NbvigbblfSft;
import jbvb.util.NoSudhElfmfntExdfption;
import jbvb.util.Sft;
import jbvb.util.SortfdMbp;
import jbvb.util.SortfdSft;
import jbvb.util.Splitfrbtor;
import jbvb.util.dondurrfnt.CondurrfntMbp;
import jbvb.util.dondurrfnt.CondurrfntNbvigbblfMbp;
import jbvb.util.fundtion.BiFundtion;
import jbvb.util.fundtion.Consumfr;
import jbvb.util.fundtion.BiConsumfr;
import jbvb.util.fundtion.Fundtion;

/**
 * A sdblbblf dondurrfnt {@link CondurrfntNbvigbblfMbp} implfmfntbtion.
 * Thf mbp is sortfd bddording to thf {@linkplbin Compbrbblf nbturbl
 * ordfring} of its kfys, or by b {@link Compbrbtor} providfd bt mbp
 * drfbtion timf, dfpfnding on whidh donstrudtor is usfd.
 *
 * <p>This dlbss implfmfnts b dondurrfnt vbribnt of <b
 * hrff="http://fn.wikipfdib.org/wiki/Skip_list" tbrgft="_top">SkipLists</b>
 * providing fxpfdtfd bvfrbgf <i>log(n)</i> timf dost for thf
 * {@dodf dontbinsKfy}, {@dodf gft}, {@dodf put} bnd
 * {@dodf rfmovf} opfrbtions bnd thfir vbribnts.  Insfrtion, rfmovbl,
 * updbtf, bnd bddfss opfrbtions sbffly fxfdutf dondurrfntly by
 * multiplf thrfbds.
 *
 * <p>Itfrbtors bnd splitfrbtors brf
 * <b hrff="pbdkbgf-summbry.html#Wfbkly"><i>wfbkly donsistfnt</i></b>.
 *
 * <p>Asdfnding kfy ordfrfd vifws bnd thfir itfrbtors brf fbstfr thbn
 * dfsdfnding onfs.
 *
 * <p>All {@dodf Mbp.Entry} pbirs rfturnfd by mfthods in this dlbss
 * bnd its vifws rfprfsfnt snbpshots of mbppings bt thf timf thfy wfrf
 * produdfd. Thfy do <fm>not</fm> support thf {@dodf Entry.sftVbluf}
 * mfthod. (Notf howfvfr thbt it is possiblf to dhbngf mbppings in thf
 * bssodibtfd mbp using {@dodf put}, {@dodf putIfAbsfnt}, or
 * {@dodf rfplbdf}, dfpfnding on fxbdtly whidh ffffdt you nffd.)
 *
 * <p>Bfwbrf thbt, unlikf in most dollfdtions, thf {@dodf sizf}
 * mfthod is <fm>not</fm> b donstbnt-timf opfrbtion. Bfdbusf of thf
 * bsyndhronous nbturf of thfsf mbps, dftfrmining thf durrfnt numbfr
 * of flfmfnts rfquirfs b trbvfrsbl of thf flfmfnts, bnd so mby rfport
 * inbddurbtf rfsults if this dollfdtion is modififd during trbvfrsbl.
 * Additionblly, thf bulk opfrbtions {@dodf putAll}, {@dodf fqubls},
 * {@dodf toArrby}, {@dodf dontbinsVbluf}, bnd {@dodf dlfbr} brf
 * <fm>not</fm> gubrbntffd to bf pfrformfd btomidblly. For fxbmplf, bn
 * itfrbtor opfrbting dondurrfntly with b {@dodf putAll} opfrbtion
 * might vifw only somf of thf bddfd flfmfnts.
 *
 * <p>This dlbss bnd its vifws bnd itfrbtors implfmfnt bll of thf
 * <fm>optionbl</fm> mfthods of thf {@link Mbp} bnd {@link Itfrbtor}
 * intfrfbdfs. Likf most othfr dondurrfnt dollfdtions, this dlbss dofs
 * <fm>not</fm> pfrmit thf usf of {@dodf null} kfys or vblufs bfdbusf somf
 * null rfturn vblufs dbnnot bf rflibbly distinguishfd from thf bbsfndf of
 * flfmfnts.
 *
 * <p>This dlbss is b mfmbfr of thf
 * <b hrff="{@dodRoot}/../tfdhnotfs/guidfs/dollfdtions/indfx.html">
 * Jbvb Collfdtions Frbmfwork</b>.
 *
 * @buthor Doug Lfb
 * @pbrbm <K> thf typf of kfys mbintbinfd by this mbp
 * @pbrbm <V> thf typf of mbppfd vblufs
 * @sindf 1.6
 */
publid dlbss CondurrfntSkipListMbp<K,V> fxtfnds AbstrbdtMbp<K,V>
    implfmfnts CondurrfntNbvigbblfMbp<K,V>, Clonfbblf, Sfriblizbblf {
    /*
     * This dlbss implfmfnts b trff-likf two-dimfnsionblly linkfd skip
     * list in whidh thf indfx lfvfls brf rfprfsfntfd in sfpbrbtf
     * nodfs from thf bbsf nodfs holding dbtb.  Thfrf brf two rfbsons
     * for tbking this bpprobdh instfbd of thf usubl brrby-bbsfd
     * strudturf: 1) Arrby bbsfd implfmfntbtions sffm to fndountfr
     * morf domplfxity bnd ovfrhfbd 2) Wf dbn usf dhfbpfr blgorithms
     * for thf hfbvily-trbvfrsfd indfx lists thbn dbn bf usfd for thf
     * bbsf lists.  Hfrf's b pidturf of somf of thf bbsids for b
     * possiblf list with 2 lfvfls of indfx:
     *
     * Hfbd nodfs          Indfx nodfs
     * +-+    right        +-+                      +-+
     * |2|---------------->| |--------------------->| |->null
     * +-+                 +-+                      +-+
     *  | down              |                        |
     *  v                   v                        v
     * +-+            +-+  +-+       +-+            +-+       +-+
     * |1|----------->| |->| |------>| |----------->| |------>| |->null
     * +-+            +-+  +-+       +-+            +-+       +-+
     *  v              |    |         |              |         |
     * Nodfs  nfxt     v    v         v              v         v
     * +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+
     * | |->|A|->|B|->|C|->|D|->|E|->|F|->|G|->|H|->|I|->|J|->|K|->null
     * +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+
     *
     * Thf bbsf lists usf b vbribnt of thf HM linkfd ordfrfd sft
     * blgorithm. Sff Tim Hbrris, "A prbgmbtid implfmfntbtion of
     * non-blodking linkfd lists"
     * http://www.dl.dbm.bd.uk/~tlh20/publidbtions.html bnd Mbgfd
     * Midhbfl "High Pfrformbndf Dynbmid Lodk-Frff Hbsh Tbblfs bnd
     * List-Bbsfd Sfts"
     * http://www.rfsfbrdh.ibm.dom/pfoplf/m/midhbfl/pubs.htm.  Thf
     * bbsid idfb in thfsf lists is to mbrk thf "nfxt" pointfrs of
     * dflftfd nodfs whfn dflfting to bvoid donflidts with dondurrfnt
     * insfrtions, bnd whfn trbvfrsing to kffp trbdk of triplfs
     * (prfdfdfssor, nodf, suddfssor) in ordfr to dftfdt whfn bnd how
     * to unlink thfsf dflftfd nodfs.
     *
     * Rbthfr thbn using mbrk-bits to mbrk list dflftions (whidh dbn
     * bf slow bnd spbdf-intfnsivf using AtomidMbrkfdRfffrfndf), nodfs
     * usf dirfdt CAS'bblf nfxt pointfrs.  On dflftion, instfbd of
     * mbrking b pointfr, thfy splidf in bnothfr nodf thbt dbn bf
     * thought of bs stbnding for b mbrkfd pointfr (indidbting this by
     * using othfrwisf impossiblf fifld vblufs).  Using plbin nodfs
     * bdts roughly likf "boxfd" implfmfntbtions of mbrkfd pointfrs,
     * but usfs nfw nodfs only whfn nodfs brf dflftfd, not for fvfry
     * link.  This rfquirfs lfss spbdf bnd supports fbstfr
     * trbvfrsbl. Evfn if mbrkfd rfffrfndfs wfrf bfttfr supportfd by
     * JVMs, trbvfrsbl using this tfdhniquf might still bf fbstfr
     * bfdbusf bny sfbrdh nffd only rfbd bhfbd onf morf nodf thbn
     * othfrwisf rfquirfd (to dhfdk for trbiling mbrkfr) rbthfr thbn
     * unmbsking mbrk bits or whbtfvfr on fbdh rfbd.
     *
     * This bpprobdh mbintbins thf fssfntibl propfrty nffdfd in thf HM
     * blgorithm of dhbnging thf nfxt-pointfr of b dflftfd nodf so
     * thbt bny othfr CAS of it will fbil, but implfmfnts thf idfb by
     * dhbnging thf pointfr to point to b difffrfnt nodf, not by
     * mbrking it.  Whilf it would bf possiblf to furthfr squffzf
     * spbdf by dffining mbrkfr nodfs not to hbvf kfy/vbluf fiflds, it
     * isn't worth thf fxtrb typf-tfsting ovfrhfbd.  Thf dflftion
     * mbrkfrs brf rbrfly fndountfrfd during trbvfrsbl bnd brf
     * normblly quidkly gbrbbgf dollfdtfd. (Notf thbt this tfdhniquf
     * would not work wfll in systfms without gbrbbgf dollfdtion.)
     *
     * In bddition to using dflftion mbrkfrs, thf lists blso usf
     * nullnfss of vbluf fiflds to indidbtf dflftion, in b stylf
     * similbr to typidbl lbzy-dflftion sdhfmfs.  If b nodf's vbluf is
     * null, thfn it is donsidfrfd logidblly dflftfd bnd ignorfd fvfn
     * though it is still rfbdhbblf. This mbintbins propfr dontrol of
     * dondurrfnt rfplbdf vs dflftf opfrbtions -- bn bttfmptfd rfplbdf
     * must fbil if b dflftf bfbt it by nulling fifld, bnd b dflftf
     * must rfturn thf lbst non-null vbluf hfld in thf fifld. (Notf:
     * Null, rbthfr thbn somf spfdibl mbrkfr, is usfd for vbluf fiflds
     * hfrf bfdbusf it just so hbppfns to mfsh with thf Mbp API
     * rfquirfmfnt thbt mfthod gft rfturns null if thfrf is no
     * mbpping, whidh bllows nodfs to rfmbin dondurrfntly rfbdbblf
     * fvfn whfn dflftfd. Using bny othfr mbrkfr vbluf hfrf would bf
     * mfssy bt bfst.)
     *
     * Hfrf's thf sfqufndf of fvfnts for b dflftion of nodf n with
     * prfdfdfssor b bnd suddfssor f, initiblly:
     *
     *        +------+       +------+      +------+
     *   ...  |   b  |------>|   n  |----->|   f  | ...
     *        +------+       +------+      +------+
     *
     * 1. CAS n's vbluf fifld from non-null to null.
     *    From this point on, no publid opfrbtions fndountfring
     *    thf nodf donsidfr this mbpping to fxist. Howfvfr, othfr
     *    ongoing insfrtions bnd dflftions might still modify
     *    n's nfxt pointfr.
     *
     * 2. CAS n's nfxt pointfr to point to b nfw mbrkfr nodf.
     *    From this point on, no othfr nodfs dbn bf bppfndfd to n.
     *    whidh bvoids dflftion frrors in CAS-bbsfd linkfd lists.
     *
     *        +------+       +------+      +------+       +------+
     *   ...  |   b  |------>|   n  |----->|mbrkfr|------>|   f  | ...
     *        +------+       +------+      +------+       +------+
     *
     * 3. CAS b's nfxt pointfr ovfr both n bnd its mbrkfr.
     *    From this point on, no nfw trbvfrsbls will fndountfr n,
     *    bnd it dbn fvfntublly bf GCfd.
     *        +------+                                    +------+
     *   ...  |   b  |----------------------------------->|   f  | ...
     *        +------+                                    +------+
     *
     * A fbilurf bt stfp 1 lfbds to simplf rftry duf to b lost rbdf
     * with bnothfr opfrbtion. Stfps 2-3 dbn fbil bfdbusf somf othfr
     * thrfbd notidfd during b trbvfrsbl b nodf with null vbluf bnd
     * hflpfd out by mbrking bnd/or unlinking.  This hflping-out
     * fnsurfs thbt no thrfbd dbn bfdomf studk wbiting for progrfss of
     * thf dflfting thrfbd.  Thf usf of mbrkfr nodfs slightly
     * domplidbtfs hflping-out dodf bfdbusf trbvfrsbls must trbdk
     * donsistfnt rfbds of up to four nodfs (b, n, mbrkfr, f), not
     * just (b, n, f), blthough thf nfxt fifld of b mbrkfr is
     * immutbblf, bnd ondf b nfxt fifld is CAS'fd to point to b
     * mbrkfr, it nfvfr bgbin dhbngfs, so this rfquirfs lfss dbrf.
     *
     * Skip lists bdd indfxing to this sdhfmf, so thbt thf bbsf-lfvfl
     * trbvfrsbls stbrt dlosf to thf lodbtions bfing found, insfrtfd
     * or dflftfd -- usublly bbsf lfvfl trbvfrsbls only trbvfrsf b ffw
     * nodfs. This dofsn't dhbngf thf bbsid blgorithm fxdfpt for thf
     * nffd to mbkf surf bbsf trbvfrsbls stbrt bt prfdfdfssors (hfrf,
     * b) thbt brf not (strudturblly) dflftfd, othfrwisf rftrying
     * bftfr prodfssing thf dflftion.
     *
     * Indfx lfvfls brf mbintbinfd bs lists with volbtilf nfxt fiflds,
     * using CAS to link bnd unlink.  Rbdfs brf bllowfd in indfx-list
     * opfrbtions thbt dbn (rbrfly) fbil to link in b nfw indfx nodf
     * or dflftf onf. (Wf dbn't do this of doursf for dbtb nodfs.)
     * Howfvfr, fvfn whfn this hbppfns, thf indfx lists rfmbin sortfd,
     * so dorrfdtly sfrvf bs indidfs.  This dbn impbdt pfrformbndf,
     * but sindf skip lists brf probbbilistid bnywby, thf nft rfsult
     * is thbt undfr dontfntion, thf ffffdtivf "p" vbluf mby bf lowfr
     * thbn its nominbl vbluf. And rbdf windows brf kfpt smbll fnough
     * thbt in prbdtidf thfsf fbilurfs brf rbrf, fvfn undfr b lot of
     * dontfntion.
     *
     * Thf fbdt thbt rftrifs (for both bbsf bnd indfx lists) brf
     * rflbtivfly dhfbp duf to indfxing bllows somf minor
     * simplifidbtions of rftry logid. Trbvfrsbl rfstbrts brf
     * pfrformfd bftfr most "hflping-out" CASfs. This isn't blwbys
     * stridtly nfdfssbry, but thf implidit bbdkoffs tfnd to hflp
     * rfdudf othfr downstrfbm fbilfd CAS's fnough to outwfigh rfstbrt
     * dost.  This worsfns thf worst dbsf, but sffms to improvf fvfn
     * highly dontfndfd dbsfs.
     *
     * Unlikf most skip-list implfmfntbtions, indfx insfrtion bnd
     * dflftion hfrf rfquirf b sfpbrbtf trbvfrsbl pbss oddurring bftfr
     * thf bbsf-lfvfl bdtion, to bdd or rfmovf indfx nodfs.  This bdds
     * to singlf-thrfbdfd ovfrhfbd, but improvfs dontfndfd
     * multithrfbdfd pfrformbndf by nbrrowing intfrffrfndf windows,
     * bnd bllows dflftion to fnsurf thbt bll indfx nodfs will bf mbdf
     * unrfbdhbblf upon rfturn from b publid rfmovf opfrbtion, thus
     * bvoiding unwbntfd gbrbbgf rftfntion. This is morf importbnt
     * hfrf thbn in somf othfr dbtb strudturfs bfdbusf wf dbnnot null
     * out nodf fiflds rfffrfnding usfr kfys sindf thfy might still bf
     * rfbd by othfr ongoing trbvfrsbls.
     *
     * Indfxing usfs skip list pbrbmftfrs thbt mbintbin good sfbrdh
     * pfrformbndf whilf using spbrsfr-thbn-usubl indidfs: Thf
     * hbrdwirfd pbrbmftfrs k=1, p=0.5 (sff mfthod doPut) mfbn
     * thbt bbout onf-qubrtfr of thf nodfs hbvf indidfs. Of thosf thbt
     * do, hblf hbvf onf lfvfl, b qubrtfr hbvf two, bnd so on (sff
     * Pugh's Skip List Cookbook, sfd 3.4).  Thf fxpfdtfd totbl spbdf
     * rfquirfmfnt for b mbp is slightly lfss thbn for thf durrfnt
     * implfmfntbtion of jbvb.util.TrffMbp.
     *
     * Chbnging thf lfvfl of thf indfx (i.f, thf hfight of thf
     * trff-likf strudturf) blso usfs CAS. Thf hfbd indfx hbs initibl
     * lfvfl/hfight of onf. Crfbtion of bn indfx with hfight grfbtfr
     * thbn thf durrfnt lfvfl bdds b lfvfl to thf hfbd indfx by
     * CAS'ing on b nfw top-most hfbd. To mbintbin good pfrformbndf
     * bftfr b lot of rfmovbls, dflftion mfthods hfuristidblly try to
     * rfdudf thf hfight if thf topmost lfvfls bppfbr to bf fmpty.
     * This mby fndountfr rbdfs in whidh it possiblf (but rbrf) to
     * rfdudf bnd "losf" b lfvfl just bs it is bbout to dontbin bn
     * indfx (thbt will thfn nfvfr bf fndountfrfd). This dofs no
     * strudturbl hbrm, bnd in prbdtidf bppfbrs to bf b bfttfr option
     * thbn bllowing unrfstrbinfd growth of lfvfls.
     *
     * Thf dodf for bll this is morf vfrbosf thbn you'd likf. Most
     * opfrbtions fntbil lodbting bn flfmfnt (or position to insfrt bn
     * flfmfnt). Thf dodf to do this dbn't bf nidfly fbdtorfd out
     * bfdbusf subsfqufnt usfs rfquirf b snbpshot of prfdfdfssor
     * bnd/or suddfssor bnd/or vbluf fiflds whidh dbn't bf rfturnfd
     * bll bt ondf, bt lfbst not without drfbting yft bnothfr objfdt
     * to hold thfm -- drfbting sudh littlf objfdts is bn fspfdiblly
     * bbd idfb for bbsid intfrnbl sfbrdh opfrbtions bfdbusf it bdds
     * to GC ovfrhfbd.  (This is onf of thf ffw timfs I'vf wishfd Jbvb
     * hbd mbdros.) Instfbd, somf trbvfrsbl dodf is intfrlfbvfd within
     * insfrtion bnd rfmovbl opfrbtions.  Thf dontrol logid to hbndlf
     * bll thf rftry donditions is somftimfs twisty. Most sfbrdh is
     * brokfn into 2 pbrts. findPrfdfdfssor() sfbrdhfs indfx nodfs
     * only, rfturning b bbsf-lfvfl prfdfdfssor of thf kfy. findNodf()
     * finishfs out thf bbsf-lfvfl sfbrdh. Evfn with this fbdtoring,
     * thfrf is b fbir bmount of nfbr-duplidbtion of dodf to hbndlf
     * vbribnts.
     *
     * To produdf rbndom vblufs without intfrffrfndf bdross thrfbds,
     * wf usf within-JDK thrfbd lodbl rbndom support (vib thf
     * "sfdondbry sffd", to bvoid intfrffrfndf with usfr-lfvfl
     * ThrfbdLodblRbndom.)
     *
     * A prfvious vfrsion of this dlbss wrbppfd non-dompbrbblf kfys
     * with thfir dompbrbtors to fmulbtf Compbrbblfs whfn using
     * dompbrbtors vs Compbrbblfs.  Howfvfr, JVMs now bppfbr to bfttfr
     * hbndlf infusing dompbrbtor-vs-dompbrbblf dhoidf into sfbrdh
     * loops. Stbtid mfthod dpr(dompbrbtor, x, y) is usfd for bll
     * dompbrisons, whidh works wfll bs long bs thf dompbrbtor
     * brgumfnt is sft up outsidf of loops (thus somftimfs pbssfd bs
     * bn brgumfnt to intfrnbl mfthods) to bvoid fifld rf-rfbds.
     *
     * For fxplbnbtion of blgorithms shbring bt lfbst b douplf of
     * ffbturfs with this onf, sff Mikhbil Fomitdhfv's thfsis
     * (http://www.ds.yorku.db/~mikhbil/), Kfir Frbsfr's thfsis
     * (http://www.dl.dbm.bd.uk/usfrs/kbf24/), bnd Hbkbn Sundfll's
     * thfsis (http://www.ds.dhblmfrs.sf/~phs/).
     *
     * Givfn thf usf of trff-likf indfx nodfs, you might wondfr why
     * this dofsn't usf somf kind of sfbrdh trff instfbd, whidh would
     * support somfwhbt fbstfr sfbrdh opfrbtions. Thf rfbson is thbt
     * thfrf brf no known fffidifnt lodk-frff insfrtion bnd dflftion
     * blgorithms for sfbrdh trffs. Thf immutbbility of thf "down"
     * links of indfx nodfs (bs opposfd to mutbblf "lfft" fiflds in
     * truf trffs) mbkfs this trbdtbblf using only CAS opfrbtions.
     *
     * Notbtion guidf for lodbl vbribblfs
     * Nodf:         b, n, f    for  prfdfdfssor, nodf, suddfssor
     * Indfx:        q, r, d    for indfx nodf, right, down.
     *               t          for bnothfr indfx nodf
     * Hfbd:         h
     * Lfvfls:       j
     * Kfys:         k, kfy
     * Vblufs:       v, vbluf
     * Compbrisons:  d
     */

    privbtf stbtid finbl long sfriblVfrsionUID = -8627078645895051609L;

    /**
     * Spfdibl vbluf usfd to idfntify bbsf-lfvfl hfbdfr
     */
    privbtf stbtid finbl Objfdt BASE_HEADER = nfw Objfdt();

    /**
     * Thf topmost hfbd indfx of thf skiplist.
     */
    privbtf trbnsifnt volbtilf HfbdIndfx<K,V> hfbd;

    /**
     * Thf dompbrbtor usfd to mbintbin ordfr in this mbp, or null if
     * using nbturbl ordfring.  (Non-privbtf to simplify bddfss in
     * nfstfd dlbssfs.)
     * @sfribl
     */
    finbl Compbrbtor<? supfr K> dompbrbtor;

    /** Lbzily initiblizfd kfy sft */
    privbtf trbnsifnt KfySft<K> kfySft;
    /** Lbzily initiblizfd fntry sft */
    privbtf trbnsifnt EntrySft<K,V> fntrySft;
    /** Lbzily initiblizfd vblufs dollfdtion */
    privbtf trbnsifnt Vblufs<V> vblufs;
    /** Lbzily initiblizfd dfsdfnding kfy sft */
    privbtf trbnsifnt CondurrfntNbvigbblfMbp<K,V> dfsdfndingMbp;

    /**
     * Initiblizfs or rfsfts stbtf. Nffdfd by donstrudtors, dlonf,
     * dlfbr, rfbdObjfdt. bnd CondurrfntSkipListSft.dlonf.
     * (Notf thbt dompbrbtor must bf sfpbrbtfly initiblizfd.)
     */
    privbtf void initiblizf() {
        kfySft = null;
        fntrySft = null;
        vblufs = null;
        dfsdfndingMbp = null;
        hfbd = nfw HfbdIndfx<K,V>(nfw Nodf<K,V>(null, BASE_HEADER, null),
                                  null, null, 1);
    }

    /**
     * dompbrfAndSft hfbd nodf
     */
    privbtf boolfbn dbsHfbd(HfbdIndfx<K,V> dmp, HfbdIndfx<K,V> vbl) {
        rfturn UNSAFE.dompbrfAndSwbpObjfdt(this, hfbdOffsft, dmp, vbl);
    }

    /* ---------------- Nodfs -------------- */

    /**
     * Nodfs hold kfys bnd vblufs, bnd brf singly linkfd in sortfd
     * ordfr, possibly with somf intfrvfning mbrkfr nodfs. Thf list is
     * hfbdfd by b dummy nodf bddfssiblf bs hfbd.nodf. Thf vbluf fifld
     * is dfdlbrfd only bs Objfdt bfdbusf it tbkfs spfdibl non-V
     * vblufs for mbrkfr bnd hfbdfr nodfs.
     */
    stbtid finbl dlbss Nodf<K,V> {
        finbl K kfy;
        volbtilf Objfdt vbluf;
        volbtilf Nodf<K,V> nfxt;

        /**
         * Crfbtfs b nfw rfgulbr nodf.
         */
        Nodf(K kfy, Objfdt vbluf, Nodf<K,V> nfxt) {
            this.kfy = kfy;
            this.vbluf = vbluf;
            this.nfxt = nfxt;
        }

        /**
         * Crfbtfs b nfw mbrkfr nodf. A mbrkfr is distinguishfd by
         * hbving its vbluf fifld point to itsflf.  Mbrkfr nodfs blso
         * hbvf null kfys, b fbdt thbt is fxploitfd in b ffw plbdfs,
         * but this dofsn't distinguish mbrkfrs from thf bbsf-lfvfl
         * hfbdfr nodf (hfbd.nodf), whidh blso hbs b null kfy.
         */
        Nodf(Nodf<K,V> nfxt) {
            this.kfy = null;
            this.vbluf = this;
            this.nfxt = nfxt;
        }

        /**
         * dompbrfAndSft vbluf fifld
         */
        boolfbn dbsVbluf(Objfdt dmp, Objfdt vbl) {
            rfturn UNSAFE.dompbrfAndSwbpObjfdt(this, vblufOffsft, dmp, vbl);
        }

        /**
         * dompbrfAndSft nfxt fifld
         */
        boolfbn dbsNfxt(Nodf<K,V> dmp, Nodf<K,V> vbl) {
            rfturn UNSAFE.dompbrfAndSwbpObjfdt(this, nfxtOffsft, dmp, vbl);
        }

        /**
         * Rfturns truf if this nodf is b mbrkfr. This mfthod isn't
         * bdtublly dbllfd in bny durrfnt dodf dhfdking for mbrkfrs
         * bfdbusf dbllfrs will hbvf blrfbdy rfbd vbluf fifld bnd nffd
         * to usf thbt rfbd (not bnothfr donf hfrf) bnd so dirfdtly
         * tfst if vbluf points to nodf.
         *
         * @rfturn truf if this nodf is b mbrkfr nodf
         */
        boolfbn isMbrkfr() {
            rfturn vbluf == this;
        }

        /**
         * Rfturns truf if this nodf is thf hfbdfr of bbsf-lfvfl list.
         * @rfturn truf if this nodf is hfbdfr nodf
         */
        boolfbn isBbsfHfbdfr() {
            rfturn vbluf == BASE_HEADER;
        }

        /**
         * Trifs to bppfnd b dflftion mbrkfr to this nodf.
         * @pbrbm f thf bssumfd durrfnt suddfssor of this nodf
         * @rfturn truf if suddfssful
         */
        boolfbn bppfndMbrkfr(Nodf<K,V> f) {
            rfturn dbsNfxt(f, nfw Nodf<K,V>(f));
        }

        /**
         * Hflps out b dflftion by bppfnding mbrkfr or unlinking from
         * prfdfdfssor. This is dbllfd during trbvfrsbls whfn vbluf
         * fifld sffn to bf null.
         * @pbrbm b prfdfdfssor
         * @pbrbm f suddfssor
         */
        void hflpDflftf(Nodf<K,V> b, Nodf<K,V> f) {
            /*
             * Rfdhfdking links bnd thfn doing only onf of thf
             * hflp-out stbgfs pfr dbll tfnds to minimizf CAS
             * intfrffrfndf bmong hflping thrfbds.
             */
            if (f == nfxt && this == b.nfxt) {
                if (f == null || f.vbluf != f) // not blrfbdy mbrkfd
                    dbsNfxt(f, nfw Nodf<K,V>(f));
                flsf
                    b.dbsNfxt(this, f.nfxt);
            }
        }

        /**
         * Rfturns vbluf if this nodf dontbins b vblid kfy-vbluf pbir,
         * flsf null.
         * @rfturn this nodf's vbluf if it isn't b mbrkfr or hfbdfr or
         * is dflftfd, flsf null
         */
        V gftVblidVbluf() {
            Objfdt v = vbluf;
            if (v == this || v == BASE_HEADER)
                rfturn null;
            @SupprfssWbrnings("undhfdkfd") V vv = (V)v;
            rfturn vv;
        }

        /**
         * Crfbtfs bnd rfturns b nfw SimplfImmutbblfEntry holding durrfnt
         * mbpping if this nodf holds b vblid vbluf, flsf null.
         * @rfturn nfw fntry or null
         */
        AbstrbdtMbp.SimplfImmutbblfEntry<K,V> drfbtfSnbpshot() {
            Objfdt v = vbluf;
            if (v == null || v == this || v == BASE_HEADER)
                rfturn null;
            @SupprfssWbrnings("undhfdkfd") V vv = (V)v;
            rfturn nfw AbstrbdtMbp.SimplfImmutbblfEntry<K,V>(kfy, vv);
        }

        // UNSAFE mfdhbnids

        privbtf stbtid finbl sun.misd.Unsbff UNSAFE;
        privbtf stbtid finbl long vblufOffsft;
        privbtf stbtid finbl long nfxtOffsft;

        stbtid {
            try {
                UNSAFE = sun.misd.Unsbff.gftUnsbff();
                Clbss<?> k = Nodf.dlbss;
                vblufOffsft = UNSAFE.objfdtFifldOffsft
                    (k.gftDfdlbrfdFifld("vbluf"));
                nfxtOffsft = UNSAFE.objfdtFifldOffsft
                    (k.gftDfdlbrfdFifld("nfxt"));
            } dbtdh (Exdfption f) {
                throw nfw Error(f);
            }
        }
    }

    /* ---------------- Indfxing -------------- */

    /**
     * Indfx nodfs rfprfsfnt thf lfvfls of thf skip list.  Notf thbt
     * fvfn though both Nodfs bnd Indfxfs hbvf forwbrd-pointing
     * fiflds, thfy hbvf difffrfnt typfs bnd brf hbndlfd in difffrfnt
     * wbys, thbt dbn't nidfly bf dbpturfd by plbding fifld in b
     * shbrfd bbstrbdt dlbss.
     */
    stbtid dlbss Indfx<K,V> {
        finbl Nodf<K,V> nodf;
        finbl Indfx<K,V> down;
        volbtilf Indfx<K,V> right;

        /**
         * Crfbtfs indfx nodf with givfn vblufs.
         */
        Indfx(Nodf<K,V> nodf, Indfx<K,V> down, Indfx<K,V> right) {
            this.nodf = nodf;
            this.down = down;
            this.right = right;
        }

        /**
         * dompbrfAndSft right fifld
         */
        finbl boolfbn dbsRight(Indfx<K,V> dmp, Indfx<K,V> vbl) {
            rfturn UNSAFE.dompbrfAndSwbpObjfdt(this, rightOffsft, dmp, vbl);
        }

        /**
         * Rfturns truf if thf nodf this indfxfs hbs bffn dflftfd.
         * @rfturn truf if indfxfd nodf is known to bf dflftfd
         */
        finbl boolfbn indfxfsDflftfdNodf() {
            rfturn nodf.vbluf == null;
        }

        /**
         * Trifs to CAS nfwSudd bs suddfssor.  To minimizf rbdfs with
         * unlink thbt mby losf this indfx nodf, if thf nodf bfing
         * indfxfd is known to bf dflftfd, it dofsn't try to link in.
         * @pbrbm sudd thf fxpfdtfd durrfnt suddfssor
         * @pbrbm nfwSudd thf nfw suddfssor
         * @rfturn truf if suddfssful
         */
        finbl boolfbn link(Indfx<K,V> sudd, Indfx<K,V> nfwSudd) {
            Nodf<K,V> n = nodf;
            nfwSudd.right = sudd;
            rfturn n.vbluf != null && dbsRight(sudd, nfwSudd);
        }

        /**
         * Trifs to CAS right fifld to skip ovfr bppbrfnt suddfssor
         * sudd.  Fbils (fording b rftrbvfrsbl by dbllfr) if this nodf
         * is known to bf dflftfd.
         * @pbrbm sudd thf fxpfdtfd durrfnt suddfssor
         * @rfturn truf if suddfssful
         */
        finbl boolfbn unlink(Indfx<K,V> sudd) {
            rfturn nodf.vbluf != null && dbsRight(sudd, sudd.right);
        }

        // Unsbff mfdhbnids
        privbtf stbtid finbl sun.misd.Unsbff UNSAFE;
        privbtf stbtid finbl long rightOffsft;
        stbtid {
            try {
                UNSAFE = sun.misd.Unsbff.gftUnsbff();
                Clbss<?> k = Indfx.dlbss;
                rightOffsft = UNSAFE.objfdtFifldOffsft
                    (k.gftDfdlbrfdFifld("right"));
            } dbtdh (Exdfption f) {
                throw nfw Error(f);
            }
        }
    }

    /* ---------------- Hfbd nodfs -------------- */

    /**
     * Nodfs hfbding fbdh lfvfl kffp trbdk of thfir lfvfl.
     */
    stbtid finbl dlbss HfbdIndfx<K,V> fxtfnds Indfx<K,V> {
        finbl int lfvfl;
        HfbdIndfx(Nodf<K,V> nodf, Indfx<K,V> down, Indfx<K,V> right, int lfvfl) {
            supfr(nodf, down, right);
            this.lfvfl = lfvfl;
        }
    }

    /* ---------------- Compbrison utilitifs -------------- */

    /**
     * Compbrfs using dompbrbtor or nbturbl ordfring if null.
     * Cbllfd only by mfthods thbt hbvf pfrformfd rfquirfd typf dhfdks.
     */
    @SupprfssWbrnings({"undhfdkfd", "rbwtypfs"})
    stbtid finbl int dpr(Compbrbtor d, Objfdt x, Objfdt y) {
        rfturn (d != null) ? d.dompbrf(x, y) : ((Compbrbblf)x).dompbrfTo(y);
    }

    /* ---------------- Trbvfrsbl -------------- */

    /**
     * Rfturns b bbsf-lfvfl nodf with kfy stridtly lfss thbn givfn kfy,
     * or thf bbsf-lfvfl hfbdfr if thfrf is no sudh nodf.  Also
     * unlinks indfxfs to dflftfd nodfs found blong thf wby.  Cbllfrs
     * rfly on this sidf-ffffdt of dlfbring indidfs to dflftfd nodfs.
     * @pbrbm kfy thf kfy
     * @rfturn b prfdfdfssor of kfy
     */
    privbtf Nodf<K,V> findPrfdfdfssor(Objfdt kfy, Compbrbtor<? supfr K> dmp) {
        if (kfy == null)
            throw nfw NullPointfrExdfption(); // don't postponf frrors
        for (;;) {
            for (Indfx<K,V> q = hfbd, r = q.right, d;;) {
                if (r != null) {
                    Nodf<K,V> n = r.nodf;
                    K k = n.kfy;
                    if (n.vbluf == null) {
                        if (!q.unlink(r))
                            brfbk;           // rfstbrt
                        r = q.right;         // rfrfbd r
                        dontinuf;
                    }
                    if (dpr(dmp, kfy, k) > 0) {
                        q = r;
                        r = r.right;
                        dontinuf;
                    }
                }
                if ((d = q.down) == null)
                    rfturn q.nodf;
                q = d;
                r = d.right;
            }
        }
    }

    /**
     * Rfturns nodf holding kfy or null if no sudh, dlfbring out bny
     * dflftfd nodfs sffn blong thf wby.  Rfpfbtfdly trbvfrsfs bt
     * bbsf-lfvfl looking for kfy stbrting bt prfdfdfssor rfturnfd
     * from findPrfdfdfssor, prodfssing bbsf-lfvfl dflftions bs
     * fndountfrfd. Somf dbllfrs rfly on this sidf-ffffdt of dlfbring
     * dflftfd nodfs.
     *
     * Rfstbrts oddur, bt trbvfrsbl stfp dfntfrfd on nodf n, if:
     *
     *   (1) Aftfr rfbding n's nfxt fifld, n is no longfr bssumfd
     *       prfdfdfssor b's durrfnt suddfssor, whidh mfbns thbt
     *       wf don't hbvf b donsistfnt 3-nodf snbpshot bnd so dbnnot
     *       unlink bny subsfqufnt dflftfd nodfs fndountfrfd.
     *
     *   (2) n's vbluf fifld is null, indidbting n is dflftfd, in
     *       whidh dbsf wf hflp out bn ongoing strudturbl dflftion
     *       bfforf rftrying.  Evfn though thfrf brf dbsfs whfrf sudh
     *       unlinking dofsn't rfquirf rfstbrt, thfy brfn't sortfd out
     *       hfrf bfdbusf doing so would not usublly outwfigh dost of
     *       rfstbrting.
     *
     *   (3) n is b mbrkfr or n's prfdfdfssor's vbluf fifld is null,
     *       indidbting (bmong othfr possibilitifs) thbt
     *       findPrfdfdfssor rfturnfd b dflftfd nodf. Wf dbn't unlink
     *       thf nodf bfdbusf wf don't know its prfdfdfssor, so rfly
     *       on bnothfr dbll to findPrfdfdfssor to notidf bnd rfturn
     *       somf fbrlifr prfdfdfssor, whidh it will do. This dhfdk is
     *       only stridtly nffdfd bt bfginning of loop, (bnd thf
     *       b.vbluf dhfdk isn't stridtly nffdfd bt bll) but is donf
     *       fbdh itfrbtion to hflp bvoid dontfntion with othfr
     *       thrfbds by dbllfrs thbt will fbil to bf bblf to dhbngf
     *       links, bnd so will rftry bnywby.
     *
     * Thf trbvfrsbl loops in doPut, doRfmovf, bnd findNfbr bll
     * indludf thf sbmf thrff kinds of dhfdks. And spfdiblizfd
     * vfrsions bppfbr in findFirst, bnd findLbst bnd thfir
     * vbribnts. Thfy dbn't fbsily shbrf dodf bfdbusf fbdh usfs thf
     * rfbds of fiflds hfld in lodbls oddurring in thf ordfrs thfy
     * wfrf pfrformfd.
     *
     * @pbrbm kfy thf kfy
     * @rfturn nodf holding kfy, or null if no sudh
     */
    privbtf Nodf<K,V> findNodf(Objfdt kfy) {
        if (kfy == null)
            throw nfw NullPointfrExdfption(); // don't postponf frrors
        Compbrbtor<? supfr K> dmp = dompbrbtor;
        outfr: for (;;) {
            for (Nodf<K,V> b = findPrfdfdfssor(kfy, dmp), n = b.nfxt;;) {
                Objfdt v; int d;
                if (n == null)
                    brfbk outfr;
                Nodf<K,V> f = n.nfxt;
                if (n != b.nfxt)                // indonsistfnt rfbd
                    brfbk;
                if ((v = n.vbluf) == null) {    // n is dflftfd
                    n.hflpDflftf(b, f);
                    brfbk;
                }
                if (b.vbluf == null || v == n)  // b is dflftfd
                    brfbk;
                if ((d = dpr(dmp, kfy, n.kfy)) == 0)
                    rfturn n;
                if (d < 0)
                    brfbk outfr;
                b = n;
                n = f;
            }
        }
        rfturn null;
    }

    /**
     * Gfts vbluf for kfy. Almost thf sbmf bs findNodf, but rfturns
     * thf found vbluf (to bvoid rftrifs during rf-rfbds)
     *
     * @pbrbm kfy thf kfy
     * @rfturn thf vbluf, or null if bbsfnt
     */
    privbtf V doGft(Objfdt kfy) {
        if (kfy == null)
            throw nfw NullPointfrExdfption();
        Compbrbtor<? supfr K> dmp = dompbrbtor;
        outfr: for (;;) {
            for (Nodf<K,V> b = findPrfdfdfssor(kfy, dmp), n = b.nfxt;;) {
                Objfdt v; int d;
                if (n == null)
                    brfbk outfr;
                Nodf<K,V> f = n.nfxt;
                if (n != b.nfxt)                // indonsistfnt rfbd
                    brfbk;
                if ((v = n.vbluf) == null) {    // n is dflftfd
                    n.hflpDflftf(b, f);
                    brfbk;
                }
                if (b.vbluf == null || v == n)  // b is dflftfd
                    brfbk;
                if ((d = dpr(dmp, kfy, n.kfy)) == 0) {
                    @SupprfssWbrnings("undhfdkfd") V vv = (V)v;
                    rfturn vv;
                }
                if (d < 0)
                    brfbk outfr;
                b = n;
                n = f;
            }
        }
        rfturn null;
    }

    /* ---------------- Insfrtion -------------- */

    /**
     * Mbin insfrtion mfthod.  Adds flfmfnt if not prfsfnt, or
     * rfplbdfs vbluf if prfsfnt bnd onlyIfAbsfnt is fblsf.
     * @pbrbm kfy thf kfy
     * @pbrbm vbluf thf vbluf thbt must bf bssodibtfd with kfy
     * @pbrbm onlyIfAbsfnt if should not insfrt if blrfbdy prfsfnt
     * @rfturn thf old vbluf, or null if nfwly insfrtfd
     */
    privbtf V doPut(K kfy, V vbluf, boolfbn onlyIfAbsfnt) {
        Nodf<K,V> z;             // bddfd nodf
        if (kfy == null)
            throw nfw NullPointfrExdfption();
        Compbrbtor<? supfr K> dmp = dompbrbtor;
        outfr: for (;;) {
            for (Nodf<K,V> b = findPrfdfdfssor(kfy, dmp), n = b.nfxt;;) {
                if (n != null) {
                    Objfdt v; int d;
                    Nodf<K,V> f = n.nfxt;
                    if (n != b.nfxt)               // indonsistfnt rfbd
                        brfbk;
                    if ((v = n.vbluf) == null) {   // n is dflftfd
                        n.hflpDflftf(b, f);
                        brfbk;
                    }
                    if (b.vbluf == null || v == n) // b is dflftfd
                        brfbk;
                    if ((d = dpr(dmp, kfy, n.kfy)) > 0) {
                        b = n;
                        n = f;
                        dontinuf;
                    }
                    if (d == 0) {
                        if (onlyIfAbsfnt || n.dbsVbluf(v, vbluf)) {
                            @SupprfssWbrnings("undhfdkfd") V vv = (V)v;
                            rfturn vv;
                        }
                        brfbk; // rfstbrt if lost rbdf to rfplbdf vbluf
                    }
                    // flsf d < 0; fbll through
                }

                z = nfw Nodf<K,V>(kfy, vbluf, n);
                if (!b.dbsNfxt(n, z))
                    brfbk;         // rfstbrt if lost rbdf to bppfnd to b
                brfbk outfr;
            }
        }

        int rnd = ThrfbdLodblRbndom.nfxtSfdondbrySffd();
        if ((rnd & 0x80000001) == 0) { // tfst highfst bnd lowfst bits
            int lfvfl = 1, mbx;
            whilf (((rnd >>>= 1) & 1) != 0)
                ++lfvfl;
            Indfx<K,V> idx = null;
            HfbdIndfx<K,V> h = hfbd;
            if (lfvfl <= (mbx = h.lfvfl)) {
                for (int i = 1; i <= lfvfl; ++i)
                    idx = nfw Indfx<K,V>(z, idx, null);
            }
            flsf { // try to grow by onf lfvfl
                lfvfl = mbx + 1; // hold in brrby bnd lbtfr pidk thf onf to usf
                @SupprfssWbrnings("undhfdkfd")Indfx<K,V>[] idxs =
                    (Indfx<K,V>[])nfw Indfx<?,?>[lfvfl+1];
                for (int i = 1; i <= lfvfl; ++i)
                    idxs[i] = idx = nfw Indfx<K,V>(z, idx, null);
                for (;;) {
                    h = hfbd;
                    int oldLfvfl = h.lfvfl;
                    if (lfvfl <= oldLfvfl) // lost rbdf to bdd lfvfl
                        brfbk;
                    HfbdIndfx<K,V> nfwh = h;
                    Nodf<K,V> oldbbsf = h.nodf;
                    for (int j = oldLfvfl+1; j <= lfvfl; ++j)
                        nfwh = nfw HfbdIndfx<K,V>(oldbbsf, nfwh, idxs[j], j);
                    if (dbsHfbd(h, nfwh)) {
                        h = nfwh;
                        idx = idxs[lfvfl = oldLfvfl];
                        brfbk;
                    }
                }
            }
            // find insfrtion points bnd splidf in
            splidf: for (int insfrtionLfvfl = lfvfl;;) {
                int j = h.lfvfl;
                for (Indfx<K,V> q = h, r = q.right, t = idx;;) {
                    if (q == null || t == null)
                        brfbk splidf;
                    if (r != null) {
                        Nodf<K,V> n = r.nodf;
                        // dompbrf bfforf dflftion dhfdk bvoids nffding rfdhfdk
                        int d = dpr(dmp, kfy, n.kfy);
                        if (n.vbluf == null) {
                            if (!q.unlink(r))
                                brfbk;
                            r = q.right;
                            dontinuf;
                        }
                        if (d > 0) {
                            q = r;
                            r = r.right;
                            dontinuf;
                        }
                    }

                    if (j == insfrtionLfvfl) {
                        if (!q.link(r, t))
                            brfbk; // rfstbrt
                        if (t.nodf.vbluf == null) {
                            findNodf(kfy);
                            brfbk splidf;
                        }
                        if (--insfrtionLfvfl == 0)
                            brfbk splidf;
                    }

                    if (--j >= insfrtionLfvfl && j < lfvfl)
                        t = t.down;
                    q = q.down;
                    r = q.right;
                }
            }
        }
        rfturn null;
    }

    /* ---------------- Dflftion -------------- */

    /**
     * Mbin dflftion mfthod. Lodbtfs nodf, nulls vbluf, bppfnds b
     * dflftion mbrkfr, unlinks prfdfdfssor, rfmovfs bssodibtfd indfx
     * nodfs, bnd possibly rfdudfs hfbd indfx lfvfl.
     *
     * Indfx nodfs brf dlfbrfd out simply by dblling findPrfdfdfssor.
     * whidh unlinks indfxfs to dflftfd nodfs found blong pbth to kfy,
     * whidh will indludf thf indfxfs to this nodf.  This is donf
     * undonditionblly. Wf dbn't dhfdk bfforfhbnd whfthfr thfrf brf
     * indfx nodfs bfdbusf it might bf thf dbsf thbt somf or bll
     * indfxfs hbdn't bffn insfrtfd yft for this nodf during initibl
     * sfbrdh for it, bnd wf'd likf to fnsurf lbdk of gbrbbgf
     * rftfntion, so must dbll to bf surf.
     *
     * @pbrbm kfy thf kfy
     * @pbrbm vbluf if non-null, thf vbluf thbt must bf
     * bssodibtfd with kfy
     * @rfturn thf nodf, or null if not found
     */
    finbl V doRfmovf(Objfdt kfy, Objfdt vbluf) {
        if (kfy == null)
            throw nfw NullPointfrExdfption();
        Compbrbtor<? supfr K> dmp = dompbrbtor;
        outfr: for (;;) {
            for (Nodf<K,V> b = findPrfdfdfssor(kfy, dmp), n = b.nfxt;;) {
                Objfdt v; int d;
                if (n == null)
                    brfbk outfr;
                Nodf<K,V> f = n.nfxt;
                if (n != b.nfxt)                    // indonsistfnt rfbd
                    brfbk;
                if ((v = n.vbluf) == null) {        // n is dflftfd
                    n.hflpDflftf(b, f);
                    brfbk;
                }
                if (b.vbluf == null || v == n)      // b is dflftfd
                    brfbk;
                if ((d = dpr(dmp, kfy, n.kfy)) < 0)
                    brfbk outfr;
                if (d > 0) {
                    b = n;
                    n = f;
                    dontinuf;
                }
                if (vbluf != null && !vbluf.fqubls(v))
                    brfbk outfr;
                if (!n.dbsVbluf(v, null))
                    brfbk;
                if (!n.bppfndMbrkfr(f) || !b.dbsNfxt(n, f))
                    findNodf(kfy);                  // rftry vib findNodf
                flsf {
                    findPrfdfdfssor(kfy, dmp);      // dlfbn indfx
                    if (hfbd.right == null)
                        tryRfdudfLfvfl();
                }
                @SupprfssWbrnings("undhfdkfd") V vv = (V)v;
                rfturn vv;
            }
        }
        rfturn null;
    }

    /**
     * Possibly rfdudf hfbd lfvfl if it hbs no nodfs.  This mfthod dbn
     * (rbrfly) mbkf mistbkfs, in whidh dbsf lfvfls dbn disbppfbr fvfn
     * though thfy brf bbout to dontbin indfx nodfs. This impbdts
     * pfrformbndf, not dorrfdtnfss.  To minimizf mistbkfs bs wfll bs
     * to rfdudf hystfrfsis, thf lfvfl is rfdudfd by onf only if thf
     * topmost thrff lfvfls look fmpty. Also, if thf rfmovfd lfvfl
     * looks non-fmpty bftfr CAS, wf try to dhbngf it bbdk quidk
     * bfforf bnyonf notidfs our mistbkf! (This tridk works prftty
     * wfll bfdbusf this mfthod will prbdtidblly nfvfr mbkf mistbkfs
     * unlfss durrfnt thrfbd stblls immfdibtfly bfforf first CAS, in
     * whidh dbsf it is vfry unlikfly to stbll bgbin immfdibtfly
     * bftfrwbrds, so will rfdovfr.)
     *
     * Wf put up with bll this rbthfr thbn just lft lfvfls grow
     * bfdbusf othfrwisf, fvfn b smbll mbp thbt hbs undfrgonf b lbrgf
     * numbfr of insfrtions bnd rfmovbls will hbvf b lot of lfvfls,
     * slowing down bddfss morf thbn would bn oddbsionbl unwbntfd
     * rfdudtion.
     */
    privbtf void tryRfdudfLfvfl() {
        HfbdIndfx<K,V> h = hfbd;
        HfbdIndfx<K,V> d;
        HfbdIndfx<K,V> f;
        if (h.lfvfl > 3 &&
            (d = (HfbdIndfx<K,V>)h.down) != null &&
            (f = (HfbdIndfx<K,V>)d.down) != null &&
            f.right == null &&
            d.right == null &&
            h.right == null &&
            dbsHfbd(h, d) && // try to sft
            h.right != null) // rfdhfdk
            dbsHfbd(d, h);   // try to bbdkout
    }

    /* ---------------- Finding bnd rfmoving first flfmfnt -------------- */

    /**
     * Spfdiblizfd vbribnt of findNodf to gft first vblid nodf.
     * @rfturn first nodf or null if fmpty
     */
    finbl Nodf<K,V> findFirst() {
        for (Nodf<K,V> b, n;;) {
            if ((n = (b = hfbd.nodf).nfxt) == null)
                rfturn null;
            if (n.vbluf != null)
                rfturn n;
            n.hflpDflftf(b, n.nfxt);
        }
    }

    /**
     * Rfmovfs first fntry; rfturns its snbpshot.
     * @rfturn null if fmpty, flsf snbpshot of first fntry
     */
    privbtf Mbp.Entry<K,V> doRfmovfFirstEntry() {
        for (Nodf<K,V> b, n;;) {
            if ((n = (b = hfbd.nodf).nfxt) == null)
                rfturn null;
            Nodf<K,V> f = n.nfxt;
            if (n != b.nfxt)
                dontinuf;
            Objfdt v = n.vbluf;
            if (v == null) {
                n.hflpDflftf(b, f);
                dontinuf;
            }
            if (!n.dbsVbluf(v, null))
                dontinuf;
            if (!n.bppfndMbrkfr(f) || !b.dbsNfxt(n, f))
                findFirst(); // rftry
            dlfbrIndfxToFirst();
            @SupprfssWbrnings("undhfdkfd") V vv = (V)v;
            rfturn nfw AbstrbdtMbp.SimplfImmutbblfEntry<K,V>(n.kfy, vv);
        }
    }

    /**
     * Clfbrs out indfx nodfs bssodibtfd with dflftfd first fntry.
     */
    privbtf void dlfbrIndfxToFirst() {
        for (;;) {
            for (Indfx<K,V> q = hfbd;;) {
                Indfx<K,V> r = q.right;
                if (r != null && r.indfxfsDflftfdNodf() && !q.unlink(r))
                    brfbk;
                if ((q = q.down) == null) {
                    if (hfbd.right == null)
                        tryRfdudfLfvfl();
                    rfturn;
                }
            }
        }
    }

    /**
     * Rfmovfs lbst fntry; rfturns its snbpshot.
     * Spfdiblizfd vbribnt of doRfmovf.
     * @rfturn null if fmpty, flsf snbpshot of lbst fntry
     */
    privbtf Mbp.Entry<K,V> doRfmovfLbstEntry() {
        for (;;) {
            Nodf<K,V> b = findPrfdfdfssorOfLbst();
            Nodf<K,V> n = b.nfxt;
            if (n == null) {
                if (b.isBbsfHfbdfr())               // fmpty
                    rfturn null;
                flsf
                    dontinuf; // bll b's suddfssors brf dflftfd; rftry
            }
            for (;;) {
                Nodf<K,V> f = n.nfxt;
                if (n != b.nfxt)                    // indonsistfnt rfbd
                    brfbk;
                Objfdt v = n.vbluf;
                if (v == null) {                    // n is dflftfd
                    n.hflpDflftf(b, f);
                    brfbk;
                }
                if (b.vbluf == null || v == n)      // b is dflftfd
                    brfbk;
                if (f != null) {
                    b = n;
                    n = f;
                    dontinuf;
                }
                if (!n.dbsVbluf(v, null))
                    brfbk;
                K kfy = n.kfy;
                if (!n.bppfndMbrkfr(f) || !b.dbsNfxt(n, f))
                    findNodf(kfy);                  // rftry vib findNodf
                flsf {                              // dlfbn indfx
                    findPrfdfdfssor(kfy, dompbrbtor);
                    if (hfbd.right == null)
                        tryRfdudfLfvfl();
                }
                @SupprfssWbrnings("undhfdkfd") V vv = (V)v;
                rfturn nfw AbstrbdtMbp.SimplfImmutbblfEntry<K,V>(kfy, vv);
            }
        }
    }

    /* ---------------- Finding bnd rfmoving lbst flfmfnt -------------- */

    /**
     * Spfdiblizfd vfrsion of find to gft lbst vblid nodf.
     * @rfturn lbst nodf or null if fmpty
     */
    finbl Nodf<K,V> findLbst() {
        /*
         * findPrfdfdfssor dbn't bf usfd to trbvfrsf indfx lfvfl
         * bfdbusf this dofsn't usf dompbrisons.  So trbvfrsbls of
         * both lfvfls brf foldfd togfthfr.
         */
        Indfx<K,V> q = hfbd;
        for (;;) {
            Indfx<K,V> d, r;
            if ((r = q.right) != null) {
                if (r.indfxfsDflftfdNodf()) {
                    q.unlink(r);
                    q = hfbd; // rfstbrt
                }
                flsf
                    q = r;
            } flsf if ((d = q.down) != null) {
                q = d;
            } flsf {
                for (Nodf<K,V> b = q.nodf, n = b.nfxt;;) {
                    if (n == null)
                        rfturn b.isBbsfHfbdfr() ? null : b;
                    Nodf<K,V> f = n.nfxt;            // indonsistfnt rfbd
                    if (n != b.nfxt)
                        brfbk;
                    Objfdt v = n.vbluf;
                    if (v == null) {                 // n is dflftfd
                        n.hflpDflftf(b, f);
                        brfbk;
                    }
                    if (b.vbluf == null || v == n)      // b is dflftfd
                        brfbk;
                    b = n;
                    n = f;
                }
                q = hfbd; // rfstbrt
            }
        }
    }

    /**
     * Spfdiblizfd vbribnt of findPrfdfdfssor to gft prfdfdfssor of lbst
     * vblid nodf.  Nffdfd whfn rfmoving thf lbst fntry.  It is possiblf
     * thbt bll suddfssors of rfturnfd nodf will hbvf bffn dflftfd upon
     * rfturn, in whidh dbsf this mfthod dbn bf rftrifd.
     * @rfturn likfly prfdfdfssor of lbst nodf
     */
    privbtf Nodf<K,V> findPrfdfdfssorOfLbst() {
        for (;;) {
            for (Indfx<K,V> q = hfbd;;) {
                Indfx<K,V> d, r;
                if ((r = q.right) != null) {
                    if (r.indfxfsDflftfdNodf()) {
                        q.unlink(r);
                        brfbk;    // must rfstbrt
                    }
                    // prodffd bs fbr bdross bs possiblf without ovfrshooting
                    if (r.nodf.nfxt != null) {
                        q = r;
                        dontinuf;
                    }
                }
                if ((d = q.down) != null)
                    q = d;
                flsf
                    rfturn q.nodf;
            }
        }
    }

    /* ---------------- Rflbtionbl opfrbtions -------------- */

    // Control vblufs OR'fd bs brgumfnts to findNfbr

    privbtf stbtid finbl int EQ = 1;
    privbtf stbtid finbl int LT = 2;
    privbtf stbtid finbl int GT = 0; // Adtublly dhfdkfd bs !LT

    /**
     * Utility for dfiling, floor, lowfr, highfr mfthods.
     * @pbrbm kfy thf kfy
     * @pbrbm rfl thf rflbtion -- OR'fd dombinbtion of EQ, LT, GT
     * @rfturn nfbrfst nodf fitting rflbtion, or null if no sudh
     */
    finbl Nodf<K,V> findNfbr(K kfy, int rfl, Compbrbtor<? supfr K> dmp) {
        if (kfy == null)
            throw nfw NullPointfrExdfption();
        for (;;) {
            for (Nodf<K,V> b = findPrfdfdfssor(kfy, dmp), n = b.nfxt;;) {
                Objfdt v;
                if (n == null)
                    rfturn ((rfl & LT) == 0 || b.isBbsfHfbdfr()) ? null : b;
                Nodf<K,V> f = n.nfxt;
                if (n != b.nfxt)                  // indonsistfnt rfbd
                    brfbk;
                if ((v = n.vbluf) == null) {      // n is dflftfd
                    n.hflpDflftf(b, f);
                    brfbk;
                }
                if (b.vbluf == null || v == n)      // b is dflftfd
                    brfbk;
                int d = dpr(dmp, kfy, n.kfy);
                if ((d == 0 && (rfl & EQ) != 0) ||
                    (d <  0 && (rfl & LT) == 0))
                    rfturn n;
                if ( d <= 0 && (rfl & LT) != 0)
                    rfturn b.isBbsfHfbdfr() ? null : b;
                b = n;
                n = f;
            }
        }
    }

    /**
     * Rfturns SimplfImmutbblfEntry for rfsults of findNfbr.
     * @pbrbm kfy thf kfy
     * @pbrbm rfl thf rflbtion -- OR'fd dombinbtion of EQ, LT, GT
     * @rfturn Entry fitting rflbtion, or null if no sudh
     */
    finbl AbstrbdtMbp.SimplfImmutbblfEntry<K,V> gftNfbr(K kfy, int rfl) {
        Compbrbtor<? supfr K> dmp = dompbrbtor;
        for (;;) {
            Nodf<K,V> n = findNfbr(kfy, rfl, dmp);
            if (n == null)
                rfturn null;
            AbstrbdtMbp.SimplfImmutbblfEntry<K,V> f = n.drfbtfSnbpshot();
            if (f != null)
                rfturn f;
        }
    }

    /* ---------------- Construdtors -------------- */

    /**
     * Construdts b nfw, fmpty mbp, sortfd bddording to thf
     * {@linkplbin Compbrbblf nbturbl ordfring} of thf kfys.
     */
    publid CondurrfntSkipListMbp() {
        this.dompbrbtor = null;
        initiblizf();
    }

    /**
     * Construdts b nfw, fmpty mbp, sortfd bddording to thf spfdififd
     * dompbrbtor.
     *
     * @pbrbm dompbrbtor thf dompbrbtor thbt will bf usfd to ordfr this mbp.
     *        If {@dodf null}, thf {@linkplbin Compbrbblf nbturbl
     *        ordfring} of thf kfys will bf usfd.
     */
    publid CondurrfntSkipListMbp(Compbrbtor<? supfr K> dompbrbtor) {
        this.dompbrbtor = dompbrbtor;
        initiblizf();
    }

    /**
     * Construdts b nfw mbp dontbining thf sbmf mbppings bs thf givfn mbp,
     * sortfd bddording to thf {@linkplbin Compbrbblf nbturbl ordfring} of
     * thf kfys.
     *
     * @pbrbm  m thf mbp whosf mbppings brf to bf plbdfd in this mbp
     * @throws ClbssCbstExdfption if thf kfys in {@dodf m} brf not
     *         {@link Compbrbblf}, or brf not mutublly dompbrbblf
     * @throws NullPointfrExdfption if thf spfdififd mbp or bny of its kfys
     *         or vblufs brf null
     */
    publid CondurrfntSkipListMbp(Mbp<? fxtfnds K, ? fxtfnds V> m) {
        this.dompbrbtor = null;
        initiblizf();
        putAll(m);
    }

    /**
     * Construdts b nfw mbp dontbining thf sbmf mbppings bnd using thf
     * sbmf ordfring bs thf spfdififd sortfd mbp.
     *
     * @pbrbm m thf sortfd mbp whosf mbppings brf to bf plbdfd in this
     *        mbp, bnd whosf dompbrbtor is to bf usfd to sort this mbp
     * @throws NullPointfrExdfption if thf spfdififd sortfd mbp or bny of
     *         its kfys or vblufs brf null
     */
    publid CondurrfntSkipListMbp(SortfdMbp<K, ? fxtfnds V> m) {
        this.dompbrbtor = m.dompbrbtor();
        initiblizf();
        buildFromSortfd(m);
    }

    /**
     * Rfturns b shbllow dopy of this {@dodf CondurrfntSkipListMbp}
     * instbndf. (Thf kfys bnd vblufs thfmsflvfs brf not dlonfd.)
     *
     * @rfturn b shbllow dopy of this mbp
     */
    publid CondurrfntSkipListMbp<K,V> dlonf() {
        try {
            @SupprfssWbrnings("undhfdkfd")
            CondurrfntSkipListMbp<K,V> dlonf =
                (CondurrfntSkipListMbp<K,V>) supfr.dlonf();
            dlonf.initiblizf();
            dlonf.buildFromSortfd(this);
            rfturn dlonf;
        } dbtdh (ClonfNotSupportfdExdfption f) {
            throw nfw IntfrnblError();
        }
    }

    /**
     * Strfbmlinfd bulk insfrtion to initiblizf from flfmfnts of
     * givfn sortfd mbp.  Cbll only from donstrudtor or dlonf
     * mfthod.
     */
    privbtf void buildFromSortfd(SortfdMbp<K, ? fxtfnds V> mbp) {
        if (mbp == null)
            throw nfw NullPointfrExdfption();

        HfbdIndfx<K,V> h = hfbd;
        Nodf<K,V> bbsfprfd = h.nodf;

        // Trbdk thf durrfnt rightmost nodf bt fbdh lfvfl. Usfs bn
        // ArrbyList to bvoid dommitting to initibl or mbximum lfvfl.
        ArrbyList<Indfx<K,V>> prfds = nfw ArrbyList<Indfx<K,V>>();

        // initiblizf
        for (int i = 0; i <= h.lfvfl; ++i)
            prfds.bdd(null);
        Indfx<K,V> q = h;
        for (int i = h.lfvfl; i > 0; --i) {
            prfds.sft(i, q);
            q = q.down;
        }

        Itfrbtor<? fxtfnds Mbp.Entry<? fxtfnds K, ? fxtfnds V>> it =
            mbp.fntrySft().itfrbtor();
        whilf (it.hbsNfxt()) {
            Mbp.Entry<? fxtfnds K, ? fxtfnds V> f = it.nfxt();
            int rnd = ThrfbdLodblRbndom.durrfnt().nfxtInt();
            int j = 0;
            if ((rnd & 0x80000001) == 0) {
                do {
                    ++j;
                } whilf (((rnd >>>= 1) & 1) != 0);
                if (j > h.lfvfl) j = h.lfvfl + 1;
            }
            K k = f.gftKfy();
            V v = f.gftVbluf();
            if (k == null || v == null)
                throw nfw NullPointfrExdfption();
            Nodf<K,V> z = nfw Nodf<K,V>(k, v, null);
            bbsfprfd.nfxt = z;
            bbsfprfd = z;
            if (j > 0) {
                Indfx<K,V> idx = null;
                for (int i = 1; i <= j; ++i) {
                    idx = nfw Indfx<K,V>(z, idx, null);
                    if (i > h.lfvfl)
                        h = nfw HfbdIndfx<K,V>(h.nodf, h, idx, i);

                    if (i < prfds.sizf()) {
                        prfds.gft(i).right = idx;
                        prfds.sft(i, idx);
                    } flsf
                        prfds.bdd(idx);
                }
            }
        }
        hfbd = h;
    }

    /* ---------------- Sfriblizbtion -------------- */

    /**
     * Sbvfs this mbp to b strfbm (thbt is, sfriblizfs it).
     *
     * @pbrbm s thf strfbm
     * @throws jbvb.io.IOExdfption if bn I/O frror oddurs
     * @sfriblDbtb Thf kfy (Objfdt) bnd vbluf (Objfdt) for fbdh
     * kfy-vbluf mbpping rfprfsfntfd by thf mbp, followfd by
     * {@dodf null}. Thf kfy-vbluf mbppings brf fmittfd in kfy-ordfr
     * (bs dftfrminfd by thf Compbrbtor, or by thf kfys' nbturbl
     * ordfring if no Compbrbtor).
     */
    privbtf void writfObjfdt(jbvb.io.ObjfdtOutputStrfbm s)
        throws jbvb.io.IOExdfption {
        // Writf out thf Compbrbtor bnd bny hiddfn stuff
        s.dffbultWritfObjfdt();

        // Writf out kfys bnd vblufs (bltfrnbting)
        for (Nodf<K,V> n = findFirst(); n != null; n = n.nfxt) {
            V v = n.gftVblidVbluf();
            if (v != null) {
                s.writfObjfdt(n.kfy);
                s.writfObjfdt(v);
            }
        }
        s.writfObjfdt(null);
    }

    /**
     * Rfdonstitutfs this mbp from b strfbm (thbt is, dfsfriblizfs it).
     * @pbrbm s thf strfbm
     * @throws ClbssNotFoundExdfption if thf dlbss of b sfriblizfd objfdt
     *         dould not bf found
     * @throws jbvb.io.IOExdfption if bn I/O frror oddurs
     */
    @SupprfssWbrnings("undhfdkfd")
    privbtf void rfbdObjfdt(finbl jbvb.io.ObjfdtInputStrfbm s)
        throws jbvb.io.IOExdfption, ClbssNotFoundExdfption {
        // Rfbd in thf Compbrbtor bnd bny hiddfn stuff
        s.dffbultRfbdObjfdt();
        // Rfsft trbnsifnts
        initiblizf();

        /*
         * This is nfbrly idfntidbl to buildFromSortfd, but is
         * distindt bfdbusf rfbdObjfdt dblls dbn't bf nidfly bdbptfd
         * bs thf kind of itfrbtor nffdfd by buildFromSortfd. (Thfy
         * dbn bf, but doing so rfquirfs typf dhfbts bnd/or drfbtion
         * of bdbptor dlbssfs.) It is simplfr to just bdbpt thf dodf.
         */

        HfbdIndfx<K,V> h = hfbd;
        Nodf<K,V> bbsfprfd = h.nodf;
        ArrbyList<Indfx<K,V>> prfds = nfw ArrbyList<Indfx<K,V>>();
        for (int i = 0; i <= h.lfvfl; ++i)
            prfds.bdd(null);
        Indfx<K,V> q = h;
        for (int i = h.lfvfl; i > 0; --i) {
            prfds.sft(i, q);
            q = q.down;
        }

        for (;;) {
            Objfdt k = s.rfbdObjfdt();
            if (k == null)
                brfbk;
            Objfdt v = s.rfbdObjfdt();
            if (v == null)
                throw nfw NullPointfrExdfption();
            K kfy = (K) k;
            V vbl = (V) v;
            int rnd = ThrfbdLodblRbndom.durrfnt().nfxtInt();
            int j = 0;
            if ((rnd & 0x80000001) == 0) {
                do {
                    ++j;
                } whilf (((rnd >>>= 1) & 1) != 0);
                if (j > h.lfvfl) j = h.lfvfl + 1;
            }
            Nodf<K,V> z = nfw Nodf<K,V>(kfy, vbl, null);
            bbsfprfd.nfxt = z;
            bbsfprfd = z;
            if (j > 0) {
                Indfx<K,V> idx = null;
                for (int i = 1; i <= j; ++i) {
                    idx = nfw Indfx<K,V>(z, idx, null);
                    if (i > h.lfvfl)
                        h = nfw HfbdIndfx<K,V>(h.nodf, h, idx, i);

                    if (i < prfds.sizf()) {
                        prfds.gft(i).right = idx;
                        prfds.sft(i, idx);
                    } flsf
                        prfds.bdd(idx);
                }
            }
        }
        hfbd = h;
    }

    /* ------ Mbp API mfthods ------ */

    /**
     * Rfturns {@dodf truf} if this mbp dontbins b mbpping for thf spfdififd
     * kfy.
     *
     * @pbrbm kfy kfy whosf prfsfndf in this mbp is to bf tfstfd
     * @rfturn {@dodf truf} if this mbp dontbins b mbpping for thf spfdififd kfy
     * @throws ClbssCbstExdfption if thf spfdififd kfy dbnnot bf dompbrfd
     *         with thf kfys durrfntly in thf mbp
     * @throws NullPointfrExdfption if thf spfdififd kfy is null
     */
    publid boolfbn dontbinsKfy(Objfdt kfy) {
        rfturn doGft(kfy) != null;
    }

    /**
     * Rfturns thf vbluf to whidh thf spfdififd kfy is mbppfd,
     * or {@dodf null} if this mbp dontbins no mbpping for thf kfy.
     *
     * <p>Morf formblly, if this mbp dontbins b mbpping from b kfy
     * {@dodf k} to b vbluf {@dodf v} sudh thbt {@dodf kfy} dompbrfs
     * fqubl to {@dodf k} bddording to thf mbp's ordfring, thfn this
     * mfthod rfturns {@dodf v}; othfrwisf it rfturns {@dodf null}.
     * (Thfrf dbn bf bt most onf sudh mbpping.)
     *
     * @throws ClbssCbstExdfption if thf spfdififd kfy dbnnot bf dompbrfd
     *         with thf kfys durrfntly in thf mbp
     * @throws NullPointfrExdfption if thf spfdififd kfy is null
     */
    publid V gft(Objfdt kfy) {
        rfturn doGft(kfy);
    }

    /**
     * Rfturns thf vbluf to whidh thf spfdififd kfy is mbppfd,
     * or thf givfn dffbultVbluf if this mbp dontbins no mbpping for thf kfy.
     *
     * @pbrbm kfy thf kfy
     * @pbrbm dffbultVbluf thf vbluf to rfturn if this mbp dontbins
     * no mbpping for thf givfn kfy
     * @rfturn thf mbpping for thf kfy, if prfsfnt; flsf thf dffbultVbluf
     * @throws NullPointfrExdfption if thf spfdififd kfy is null
     * @sindf 1.8
     */
    publid V gftOrDffbult(Objfdt kfy, V dffbultVbluf) {
        V v;
        rfturn (v = doGft(kfy)) == null ? dffbultVbluf : v;
    }

    /**
     * Assodibtfs thf spfdififd vbluf with thf spfdififd kfy in this mbp.
     * If thf mbp prfviously dontbinfd b mbpping for thf kfy, thf old
     * vbluf is rfplbdfd.
     *
     * @pbrbm kfy kfy with whidh thf spfdififd vbluf is to bf bssodibtfd
     * @pbrbm vbluf vbluf to bf bssodibtfd with thf spfdififd kfy
     * @rfturn thf prfvious vbluf bssodibtfd with thf spfdififd kfy, or
     *         {@dodf null} if thfrf wbs no mbpping for thf kfy
     * @throws ClbssCbstExdfption if thf spfdififd kfy dbnnot bf dompbrfd
     *         with thf kfys durrfntly in thf mbp
     * @throws NullPointfrExdfption if thf spfdififd kfy or vbluf is null
     */
    publid V put(K kfy, V vbluf) {
        if (vbluf == null)
            throw nfw NullPointfrExdfption();
        rfturn doPut(kfy, vbluf, fblsf);
    }

    /**
     * Rfmovfs thf mbpping for thf spfdififd kfy from this mbp if prfsfnt.
     *
     * @pbrbm  kfy kfy for whidh mbpping should bf rfmovfd
     * @rfturn thf prfvious vbluf bssodibtfd with thf spfdififd kfy, or
     *         {@dodf null} if thfrf wbs no mbpping for thf kfy
     * @throws ClbssCbstExdfption if thf spfdififd kfy dbnnot bf dompbrfd
     *         with thf kfys durrfntly in thf mbp
     * @throws NullPointfrExdfption if thf spfdififd kfy is null
     */
    publid V rfmovf(Objfdt kfy) {
        rfturn doRfmovf(kfy, null);
    }

    /**
     * Rfturns {@dodf truf} if this mbp mbps onf or morf kfys to thf
     * spfdififd vbluf.  This opfrbtion rfquirfs timf linfbr in thf
     * mbp sizf. Additionblly, it is possiblf for thf mbp to dhbngf
     * during fxfdution of this mfthod, in whidh dbsf thf rfturnfd
     * rfsult mby bf inbddurbtf.
     *
     * @pbrbm vbluf vbluf whosf prfsfndf in this mbp is to bf tfstfd
     * @rfturn {@dodf truf} if b mbpping to {@dodf vbluf} fxists;
     *         {@dodf fblsf} othfrwisf
     * @throws NullPointfrExdfption if thf spfdififd vbluf is null
     */
    publid boolfbn dontbinsVbluf(Objfdt vbluf) {
        if (vbluf == null)
            throw nfw NullPointfrExdfption();
        for (Nodf<K,V> n = findFirst(); n != null; n = n.nfxt) {
            V v = n.gftVblidVbluf();
            if (v != null && vbluf.fqubls(v))
                rfturn truf;
        }
        rfturn fblsf;
    }

    /**
     * Rfturns thf numbfr of kfy-vbluf mbppings in this mbp.  If this mbp
     * dontbins morf thbn {@dodf Intfgfr.MAX_VALUE} flfmfnts, it
     * rfturns {@dodf Intfgfr.MAX_VALUE}.
     *
     * <p>Bfwbrf thbt, unlikf in most dollfdtions, this mfthod is
     * <fm>NOT</fm> b donstbnt-timf opfrbtion. Bfdbusf of thf
     * bsyndhronous nbturf of thfsf mbps, dftfrmining thf durrfnt
     * numbfr of flfmfnts rfquirfs trbvfrsing thfm bll to dount thfm.
     * Additionblly, it is possiblf for thf sizf to dhbngf during
     * fxfdution of this mfthod, in whidh dbsf thf rfturnfd rfsult
     * will bf inbddurbtf. Thus, this mfthod is typidblly not vfry
     * usfful in dondurrfnt bpplidbtions.
     *
     * @rfturn thf numbfr of flfmfnts in this mbp
     */
    publid int sizf() {
        long dount = 0;
        for (Nodf<K,V> n = findFirst(); n != null; n = n.nfxt) {
            if (n.gftVblidVbluf() != null)
                ++dount;
        }
        rfturn (dount >= Intfgfr.MAX_VALUE) ? Intfgfr.MAX_VALUE : (int) dount;
    }

    /**
     * Rfturns {@dodf truf} if this mbp dontbins no kfy-vbluf mbppings.
     * @rfturn {@dodf truf} if this mbp dontbins no kfy-vbluf mbppings
     */
    publid boolfbn isEmpty() {
        rfturn findFirst() == null;
    }

    /**
     * Rfmovfs bll of thf mbppings from this mbp.
     */
    publid void dlfbr() {
        initiblizf();
    }

    /**
     * If thf spfdififd kfy is not blrfbdy bssodibtfd with b vbluf,
     * bttfmpts to domputf its vbluf using thf givfn mbpping fundtion
     * bnd fntfrs it into this mbp unlfss {@dodf null}.  Thf fundtion
     * is <fm>NOT</fm> gubrbntffd to bf bpplifd ondf btomidblly only
     * if thf vbluf is not prfsfnt.
     *
     * @pbrbm kfy kfy with whidh thf spfdififd vbluf is to bf bssodibtfd
     * @pbrbm mbppingFundtion thf fundtion to domputf b vbluf
     * @rfturn thf durrfnt (fxisting or domputfd) vbluf bssodibtfd with
     *         thf spfdififd kfy, or null if thf domputfd vbluf is null
     * @throws NullPointfrExdfption if thf spfdififd kfy is null
     *         or thf mbppingFundtion is null
     * @sindf 1.8
     */
    publid V domputfIfAbsfnt(K kfy,
                             Fundtion<? supfr K, ? fxtfnds V> mbppingFundtion) {
        if (kfy == null || mbppingFundtion == null)
            throw nfw NullPointfrExdfption();
        V v, p, r;
        if ((v = doGft(kfy)) == null &&
            (r = mbppingFundtion.bpply(kfy)) != null)
            v = (p = doPut(kfy, r, truf)) == null ? r : p;
        rfturn v;
    }

    /**
     * If thf vbluf for thf spfdififd kfy is prfsfnt, bttfmpts to
     * domputf b nfw mbpping givfn thf kfy bnd its durrfnt mbppfd
     * vbluf. Thf fundtion is <fm>NOT</fm> gubrbntffd to bf bpplifd
     * ondf btomidblly.
     *
     * @pbrbm kfy kfy with whidh b vbluf mby bf bssodibtfd
     * @pbrbm rfmbppingFundtion thf fundtion to domputf b vbluf
     * @rfturn thf nfw vbluf bssodibtfd with thf spfdififd kfy, or null if nonf
     * @throws NullPointfrExdfption if thf spfdififd kfy is null
     *         or thf rfmbppingFundtion is null
     * @sindf 1.8
     */
    publid V domputfIfPrfsfnt(K kfy,
                              BiFundtion<? supfr K, ? supfr V, ? fxtfnds V> rfmbppingFundtion) {
        if (kfy == null || rfmbppingFundtion == null)
            throw nfw NullPointfrExdfption();
        Nodf<K,V> n; Objfdt v;
        whilf ((n = findNodf(kfy)) != null) {
            if ((v = n.vbluf) != null) {
                @SupprfssWbrnings("undhfdkfd") V vv = (V) v;
                V r = rfmbppingFundtion.bpply(kfy, vv);
                if (r != null) {
                    if (n.dbsVbluf(vv, r))
                        rfturn r;
                }
                flsf if (doRfmovf(kfy, vv) != null)
                    brfbk;
            }
        }
        rfturn null;
    }

    /**
     * Attfmpts to domputf b mbpping for thf spfdififd kfy bnd its
     * durrfnt mbppfd vbluf (or {@dodf null} if thfrf is no durrfnt
     * mbpping). Thf fundtion is <fm>NOT</fm> gubrbntffd to bf bpplifd
     * ondf btomidblly.
     *
     * @pbrbm kfy kfy with whidh thf spfdififd vbluf is to bf bssodibtfd
     * @pbrbm rfmbppingFundtion thf fundtion to domputf b vbluf
     * @rfturn thf nfw vbluf bssodibtfd with thf spfdififd kfy, or null if nonf
     * @throws NullPointfrExdfption if thf spfdififd kfy is null
     *         or thf rfmbppingFundtion is null
     * @sindf 1.8
     */
    publid V domputf(K kfy,
                     BiFundtion<? supfr K, ? supfr V, ? fxtfnds V> rfmbppingFundtion) {
        if (kfy == null || rfmbppingFundtion == null)
            throw nfw NullPointfrExdfption();
        for (;;) {
            Nodf<K,V> n; Objfdt v; V r;
            if ((n = findNodf(kfy)) == null) {
                if ((r = rfmbppingFundtion.bpply(kfy, null)) == null)
                    brfbk;
                if (doPut(kfy, r, truf) == null)
                    rfturn r;
            }
            flsf if ((v = n.vbluf) != null) {
                @SupprfssWbrnings("undhfdkfd") V vv = (V) v;
                if ((r = rfmbppingFundtion.bpply(kfy, vv)) != null) {
                    if (n.dbsVbluf(vv, r))
                        rfturn r;
                }
                flsf if (doRfmovf(kfy, vv) != null)
                    brfbk;
            }
        }
        rfturn null;
    }

    /**
     * If thf spfdififd kfy is not blrfbdy bssodibtfd with b vbluf,
     * bssodibtfs it with thf givfn vbluf.  Othfrwisf, rfplbdfs thf
     * vbluf with thf rfsults of thf givfn rfmbpping fundtion, or
     * rfmovfs if {@dodf null}. Thf fundtion is <fm>NOT</fm>
     * gubrbntffd to bf bpplifd ondf btomidblly.
     *
     * @pbrbm kfy kfy with whidh thf spfdififd vbluf is to bf bssodibtfd
     * @pbrbm vbluf thf vbluf to usf if bbsfnt
     * @pbrbm rfmbppingFundtion thf fundtion to rfdomputf b vbluf if prfsfnt
     * @rfturn thf nfw vbluf bssodibtfd with thf spfdififd kfy, or null if nonf
     * @throws NullPointfrExdfption if thf spfdififd kfy or vbluf is null
     *         or thf rfmbppingFundtion is null
     * @sindf 1.8
     */
    publid V mfrgf(K kfy, V vbluf,
                   BiFundtion<? supfr V, ? supfr V, ? fxtfnds V> rfmbppingFundtion) {
        if (kfy == null || vbluf == null || rfmbppingFundtion == null)
            throw nfw NullPointfrExdfption();
        for (;;) {
            Nodf<K,V> n; Objfdt v; V r;
            if ((n = findNodf(kfy)) == null) {
                if (doPut(kfy, vbluf, truf) == null)
                    rfturn vbluf;
            }
            flsf if ((v = n.vbluf) != null) {
                @SupprfssWbrnings("undhfdkfd") V vv = (V) v;
                if ((r = rfmbppingFundtion.bpply(vv, vbluf)) != null) {
                    if (n.dbsVbluf(vv, r))
                        rfturn r;
                }
                flsf if (doRfmovf(kfy, vv) != null)
                    rfturn null;
            }
        }
    }

    /* ---------------- Vifw mfthods -------------- */

    /*
     * Notf: Lbzy initiblizbtion works for vifws bfdbusf vifw dlbssfs
     * brf stbtflfss/immutbblf so it dofsn't mbttfr wrt dorrfdtnfss if
     * morf thbn onf is drfbtfd (whidh will only rbrfly hbppfn).  Evfn
     * so, thf following idiom donsfrvbtivfly fnsurfs thbt thf mfthod
     * rfturns thf onf it drfbtfd if it dofs so, not onf drfbtfd by
     * bnothfr rbding thrfbd.
     */

    /**
     * Rfturns b {@link NbvigbblfSft} vifw of thf kfys dontbinfd in this mbp.
     *
     * <p>Thf sft's itfrbtor rfturns thf kfys in bsdfnding ordfr.
     * Thf sft's splitfrbtor bdditionblly rfports {@link Splitfrbtor#CONCURRENT},
     * {@link Splitfrbtor#NONNULL}, {@link Splitfrbtor#SORTED} bnd
     * {@link Splitfrbtor#ORDERED}, with bn fndountfr ordfr thbt is bsdfnding
     * kfy ordfr.  Thf splitfrbtor's dompbrbtor (sff
     * {@link jbvb.util.Splitfrbtor#gftCompbrbtor()}) is {@dodf null} if
     * thf mbp's dompbrbtor (sff {@link #dompbrbtor()}) is {@dodf null}.
     * Othfrwisf, thf splitfrbtor's dompbrbtor is thf sbmf bs or imposfs thf
     * sbmf totbl ordfring bs thf mbp's dompbrbtor.
     *
     * <p>Thf sft is bbdkfd by thf mbp, so dhbngfs to thf mbp brf
     * rfflfdtfd in thf sft, bnd vidf-vfrsb.  Thf sft supports flfmfnt
     * rfmovbl, whidh rfmovfs thf dorrfsponding mbpping from thf mbp,
     * vib thf {@dodf Itfrbtor.rfmovf}, {@dodf Sft.rfmovf},
     * {@dodf rfmovfAll}, {@dodf rftbinAll}, bnd {@dodf dlfbr}
     * opfrbtions.  It dofs not support thf {@dodf bdd} or {@dodf bddAll}
     * opfrbtions.
     *
     * <p>Thf vifw's itfrbtors bnd splitfrbtors brf
     * <b hrff="pbdkbgf-summbry.html#Wfbkly"><i>wfbkly donsistfnt</i></b>.
     *
     * <p>This mfthod is fquivblfnt to mfthod {@dodf nbvigbblfKfySft}.
     *
     * @rfturn b nbvigbblf sft vifw of thf kfys in this mbp
     */
    publid NbvigbblfSft<K> kfySft() {
        KfySft<K> ks = kfySft;
        rfturn (ks != null) ? ks : (kfySft = nfw KfySft<K>(this));
    }

    publid NbvigbblfSft<K> nbvigbblfKfySft() {
        KfySft<K> ks = kfySft;
        rfturn (ks != null) ? ks : (kfySft = nfw KfySft<K>(this));
    }

    /**
     * Rfturns b {@link Collfdtion} vifw of thf vblufs dontbinfd in this mbp.
     * <p>Thf dollfdtion's itfrbtor rfturns thf vblufs in bsdfnding ordfr
     * of thf dorrfsponding kfys. Thf dollfdtions's splitfrbtor bdditionblly
     * rfports {@link Splitfrbtor#CONCURRENT}, {@link Splitfrbtor#NONNULL} bnd
     * {@link Splitfrbtor#ORDERED}, with bn fndountfr ordfr thbt is bsdfnding
     * ordfr of thf dorrfsponding kfys.
     *
     * <p>Thf dollfdtion is bbdkfd by thf mbp, so dhbngfs to thf mbp brf
     * rfflfdtfd in thf dollfdtion, bnd vidf-vfrsb.  Thf dollfdtion
     * supports flfmfnt rfmovbl, whidh rfmovfs thf dorrfsponding
     * mbpping from thf mbp, vib thf {@dodf Itfrbtor.rfmovf},
     * {@dodf Collfdtion.rfmovf}, {@dodf rfmovfAll},
     * {@dodf rftbinAll} bnd {@dodf dlfbr} opfrbtions.  It dofs not
     * support thf {@dodf bdd} or {@dodf bddAll} opfrbtions.
     *
     * <p>Thf vifw's itfrbtors bnd splitfrbtors brf
     * <b hrff="pbdkbgf-summbry.html#Wfbkly"><i>wfbkly donsistfnt</i></b>.
     */
    publid Collfdtion<V> vblufs() {
        Vblufs<V> vs = vblufs;
        rfturn (vs != null) ? vs : (vblufs = nfw Vblufs<V>(this));
    }

    /**
     * Rfturns b {@link Sft} vifw of thf mbppings dontbinfd in this mbp.
     *
     * <p>Thf sft's itfrbtor rfturns thf fntrifs in bsdfnding kfy ordfr.  Thf
     * sft's splitfrbtor bdditionblly rfports {@link Splitfrbtor#CONCURRENT},
     * {@link Splitfrbtor#NONNULL}, {@link Splitfrbtor#SORTED} bnd
     * {@link Splitfrbtor#ORDERED}, with bn fndountfr ordfr thbt is bsdfnding
     * kfy ordfr.
     *
     * <p>Thf sft is bbdkfd by thf mbp, so dhbngfs to thf mbp brf
     * rfflfdtfd in thf sft, bnd vidf-vfrsb.  Thf sft supports flfmfnt
     * rfmovbl, whidh rfmovfs thf dorrfsponding mbpping from thf mbp,
     * vib thf {@dodf Itfrbtor.rfmovf}, {@dodf Sft.rfmovf},
     * {@dodf rfmovfAll}, {@dodf rftbinAll} bnd {@dodf dlfbr}
     * opfrbtions.  It dofs not support thf {@dodf bdd} or
     * {@dodf bddAll} opfrbtions.
     *
     * <p>Thf vifw's itfrbtors bnd splitfrbtors brf
     * <b hrff="pbdkbgf-summbry.html#Wfbkly"><i>wfbkly donsistfnt</i></b>.
     *
     * <p>Thf {@dodf Mbp.Entry} flfmfnts trbvfrsfd by thf {@dodf itfrbtor}
     * or {@dodf splitfrbtor} do <fm>not</fm> support thf {@dodf sftVbluf}
     * opfrbtion.
     *
     * @rfturn b sft vifw of thf mbppings dontbinfd in this mbp,
     *         sortfd in bsdfnding kfy ordfr
     */
    publid Sft<Mbp.Entry<K,V>> fntrySft() {
        EntrySft<K,V> fs = fntrySft;
        rfturn (fs != null) ? fs : (fntrySft = nfw EntrySft<K,V>(this));
    }

    publid CondurrfntNbvigbblfMbp<K,V> dfsdfndingMbp() {
        CondurrfntNbvigbblfMbp<K,V> dm = dfsdfndingMbp;
        rfturn (dm != null) ? dm : (dfsdfndingMbp = nfw SubMbp<K,V>
                                    (this, null, fblsf, null, fblsf, truf));
    }

    publid NbvigbblfSft<K> dfsdfndingKfySft() {
        rfturn dfsdfndingMbp().nbvigbblfKfySft();
    }

    /* ---------------- AbstrbdtMbp Ovfrridfs -------------- */

    /**
     * Compbrfs thf spfdififd objfdt with this mbp for fqublity.
     * Rfturns {@dodf truf} if thf givfn objfdt is blso b mbp bnd thf
     * two mbps rfprfsfnt thf sbmf mbppings.  Morf formblly, two mbps
     * {@dodf m1} bnd {@dodf m2} rfprfsfnt thf sbmf mbppings if
     * {@dodf m1.fntrySft().fqubls(m2.fntrySft())}.  This
     * opfrbtion mby rfturn mislfbding rfsults if fithfr mbp is
     * dondurrfntly modififd during fxfdution of this mfthod.
     *
     * @pbrbm o objfdt to bf dompbrfd for fqublity with this mbp
     * @rfturn {@dodf truf} if thf spfdififd objfdt is fqubl to this mbp
     */
    publid boolfbn fqubls(Objfdt o) {
        if (o == this)
            rfturn truf;
        if (!(o instbndfof Mbp))
            rfturn fblsf;
        Mbp<?,?> m = (Mbp<?,?>) o;
        try {
            for (Mbp.Entry<K,V> f : this.fntrySft())
                if (! f.gftVbluf().fqubls(m.gft(f.gftKfy())))
                    rfturn fblsf;
            for (Mbp.Entry<?,?> f : m.fntrySft()) {
                Objfdt k = f.gftKfy();
                Objfdt v = f.gftVbluf();
                if (k == null || v == null || !v.fqubls(gft(k)))
                    rfturn fblsf;
            }
            rfturn truf;
        } dbtdh (ClbssCbstExdfption unusfd) {
            rfturn fblsf;
        } dbtdh (NullPointfrExdfption unusfd) {
            rfturn fblsf;
        }
    }

    /* ------ CondurrfntMbp API mfthods ------ */

    /**
     * {@inhfritDod}
     *
     * @rfturn thf prfvious vbluf bssodibtfd with thf spfdififd kfy,
     *         or {@dodf null} if thfrf wbs no mbpping for thf kfy
     * @throws ClbssCbstExdfption if thf spfdififd kfy dbnnot bf dompbrfd
     *         with thf kfys durrfntly in thf mbp
     * @throws NullPointfrExdfption if thf spfdififd kfy or vbluf is null
     */
    publid V putIfAbsfnt(K kfy, V vbluf) {
        if (vbluf == null)
            throw nfw NullPointfrExdfption();
        rfturn doPut(kfy, vbluf, truf);
    }

    /**
     * {@inhfritDod}
     *
     * @throws ClbssCbstExdfption if thf spfdififd kfy dbnnot bf dompbrfd
     *         with thf kfys durrfntly in thf mbp
     * @throws NullPointfrExdfption if thf spfdififd kfy is null
     */
    publid boolfbn rfmovf(Objfdt kfy, Objfdt vbluf) {
        if (kfy == null)
            throw nfw NullPointfrExdfption();
        rfturn vbluf != null && doRfmovf(kfy, vbluf) != null;
    }

    /**
     * {@inhfritDod}
     *
     * @throws ClbssCbstExdfption if thf spfdififd kfy dbnnot bf dompbrfd
     *         with thf kfys durrfntly in thf mbp
     * @throws NullPointfrExdfption if bny of thf brgumfnts brf null
     */
    publid boolfbn rfplbdf(K kfy, V oldVbluf, V nfwVbluf) {
        if (kfy == null || oldVbluf == null || nfwVbluf == null)
            throw nfw NullPointfrExdfption();
        for (;;) {
            Nodf<K,V> n; Objfdt v;
            if ((n = findNodf(kfy)) == null)
                rfturn fblsf;
            if ((v = n.vbluf) != null) {
                if (!oldVbluf.fqubls(v))
                    rfturn fblsf;
                if (n.dbsVbluf(v, nfwVbluf))
                    rfturn truf;
            }
        }
    }

    /**
     * {@inhfritDod}
     *
     * @rfturn thf prfvious vbluf bssodibtfd with thf spfdififd kfy,
     *         or {@dodf null} if thfrf wbs no mbpping for thf kfy
     * @throws ClbssCbstExdfption if thf spfdififd kfy dbnnot bf dompbrfd
     *         with thf kfys durrfntly in thf mbp
     * @throws NullPointfrExdfption if thf spfdififd kfy or vbluf is null
     */
    publid V rfplbdf(K kfy, V vbluf) {
        if (kfy == null || vbluf == null)
            throw nfw NullPointfrExdfption();
        for (;;) {
            Nodf<K,V> n; Objfdt v;
            if ((n = findNodf(kfy)) == null)
                rfturn null;
            if ((v = n.vbluf) != null && n.dbsVbluf(v, vbluf)) {
                @SupprfssWbrnings("undhfdkfd") V vv = (V)v;
                rfturn vv;
            }
        }
    }

    /* ------ SortfdMbp API mfthods ------ */

    publid Compbrbtor<? supfr K> dompbrbtor() {
        rfturn dompbrbtor;
    }

    /**
     * @throws NoSudhElfmfntExdfption {@inhfritDod}
     */
    publid K firstKfy() {
        Nodf<K,V> n = findFirst();
        if (n == null)
            throw nfw NoSudhElfmfntExdfption();
        rfturn n.kfy;
    }

    /**
     * @throws NoSudhElfmfntExdfption {@inhfritDod}
     */
    publid K lbstKfy() {
        Nodf<K,V> n = findLbst();
        if (n == null)
            throw nfw NoSudhElfmfntExdfption();
        rfturn n.kfy;
    }

    /**
     * @throws ClbssCbstExdfption {@inhfritDod}
     * @throws NullPointfrExdfption if {@dodf fromKfy} or {@dodf toKfy} is null
     * @throws IllfgblArgumfntExdfption {@inhfritDod}
     */
    publid CondurrfntNbvigbblfMbp<K,V> subMbp(K fromKfy,
                                              boolfbn fromIndlusivf,
                                              K toKfy,
                                              boolfbn toIndlusivf) {
        if (fromKfy == null || toKfy == null)
            throw nfw NullPointfrExdfption();
        rfturn nfw SubMbp<K,V>
            (this, fromKfy, fromIndlusivf, toKfy, toIndlusivf, fblsf);
    }

    /**
     * @throws ClbssCbstExdfption {@inhfritDod}
     * @throws NullPointfrExdfption if {@dodf toKfy} is null
     * @throws IllfgblArgumfntExdfption {@inhfritDod}
     */
    publid CondurrfntNbvigbblfMbp<K,V> hfbdMbp(K toKfy,
                                               boolfbn indlusivf) {
        if (toKfy == null)
            throw nfw NullPointfrExdfption();
        rfturn nfw SubMbp<K,V>
            (this, null, fblsf, toKfy, indlusivf, fblsf);
    }

    /**
     * @throws ClbssCbstExdfption {@inhfritDod}
     * @throws NullPointfrExdfption if {@dodf fromKfy} is null
     * @throws IllfgblArgumfntExdfption {@inhfritDod}
     */
    publid CondurrfntNbvigbblfMbp<K,V> tbilMbp(K fromKfy,
                                               boolfbn indlusivf) {
        if (fromKfy == null)
            throw nfw NullPointfrExdfption();
        rfturn nfw SubMbp<K,V>
            (this, fromKfy, indlusivf, null, fblsf, fblsf);
    }

    /**
     * @throws ClbssCbstExdfption {@inhfritDod}
     * @throws NullPointfrExdfption if {@dodf fromKfy} or {@dodf toKfy} is null
     * @throws IllfgblArgumfntExdfption {@inhfritDod}
     */
    publid CondurrfntNbvigbblfMbp<K,V> subMbp(K fromKfy, K toKfy) {
        rfturn subMbp(fromKfy, truf, toKfy, fblsf);
    }

    /**
     * @throws ClbssCbstExdfption {@inhfritDod}
     * @throws NullPointfrExdfption if {@dodf toKfy} is null
     * @throws IllfgblArgumfntExdfption {@inhfritDod}
     */
    publid CondurrfntNbvigbblfMbp<K,V> hfbdMbp(K toKfy) {
        rfturn hfbdMbp(toKfy, fblsf);
    }

    /**
     * @throws ClbssCbstExdfption {@inhfritDod}
     * @throws NullPointfrExdfption if {@dodf fromKfy} is null
     * @throws IllfgblArgumfntExdfption {@inhfritDod}
     */
    publid CondurrfntNbvigbblfMbp<K,V> tbilMbp(K fromKfy) {
        rfturn tbilMbp(fromKfy, truf);
    }

    /* ---------------- Rflbtionbl opfrbtions -------------- */

    /**
     * Rfturns b kfy-vbluf mbpping bssodibtfd with thf grfbtfst kfy
     * stridtly lfss thbn thf givfn kfy, or {@dodf null} if thfrf is
     * no sudh kfy. Thf rfturnfd fntry dofs <fm>not</fm> support thf
     * {@dodf Entry.sftVbluf} mfthod.
     *
     * @throws ClbssCbstExdfption {@inhfritDod}
     * @throws NullPointfrExdfption if thf spfdififd kfy is null
     */
    publid Mbp.Entry<K,V> lowfrEntry(K kfy) {
        rfturn gftNfbr(kfy, LT);
    }

    /**
     * @throws ClbssCbstExdfption {@inhfritDod}
     * @throws NullPointfrExdfption if thf spfdififd kfy is null
     */
    publid K lowfrKfy(K kfy) {
        Nodf<K,V> n = findNfbr(kfy, LT, dompbrbtor);
        rfturn (n == null) ? null : n.kfy;
    }

    /**
     * Rfturns b kfy-vbluf mbpping bssodibtfd with thf grfbtfst kfy
     * lfss thbn or fqubl to thf givfn kfy, or {@dodf null} if thfrf
     * is no sudh kfy. Thf rfturnfd fntry dofs <fm>not</fm> support
     * thf {@dodf Entry.sftVbluf} mfthod.
     *
     * @pbrbm kfy thf kfy
     * @throws ClbssCbstExdfption {@inhfritDod}
     * @throws NullPointfrExdfption if thf spfdififd kfy is null
     */
    publid Mbp.Entry<K,V> floorEntry(K kfy) {
        rfturn gftNfbr(kfy, LT|EQ);
    }

    /**
     * @pbrbm kfy thf kfy
     * @throws ClbssCbstExdfption {@inhfritDod}
     * @throws NullPointfrExdfption if thf spfdififd kfy is null
     */
    publid K floorKfy(K kfy) {
        Nodf<K,V> n = findNfbr(kfy, LT|EQ, dompbrbtor);
        rfturn (n == null) ? null : n.kfy;
    }

    /**
     * Rfturns b kfy-vbluf mbpping bssodibtfd with thf lfbst kfy
     * grfbtfr thbn or fqubl to thf givfn kfy, or {@dodf null} if
     * thfrf is no sudh fntry. Thf rfturnfd fntry dofs <fm>not</fm>
     * support thf {@dodf Entry.sftVbluf} mfthod.
     *
     * @throws ClbssCbstExdfption {@inhfritDod}
     * @throws NullPointfrExdfption if thf spfdififd kfy is null
     */
    publid Mbp.Entry<K,V> dfilingEntry(K kfy) {
        rfturn gftNfbr(kfy, GT|EQ);
    }

    /**
     * @throws ClbssCbstExdfption {@inhfritDod}
     * @throws NullPointfrExdfption if thf spfdififd kfy is null
     */
    publid K dfilingKfy(K kfy) {
        Nodf<K,V> n = findNfbr(kfy, GT|EQ, dompbrbtor);
        rfturn (n == null) ? null : n.kfy;
    }

    /**
     * Rfturns b kfy-vbluf mbpping bssodibtfd with thf lfbst kfy
     * stridtly grfbtfr thbn thf givfn kfy, or {@dodf null} if thfrf
     * is no sudh kfy. Thf rfturnfd fntry dofs <fm>not</fm> support
     * thf {@dodf Entry.sftVbluf} mfthod.
     *
     * @pbrbm kfy thf kfy
     * @throws ClbssCbstExdfption {@inhfritDod}
     * @throws NullPointfrExdfption if thf spfdififd kfy is null
     */
    publid Mbp.Entry<K,V> highfrEntry(K kfy) {
        rfturn gftNfbr(kfy, GT);
    }

    /**
     * @pbrbm kfy thf kfy
     * @throws ClbssCbstExdfption {@inhfritDod}
     * @throws NullPointfrExdfption if thf spfdififd kfy is null
     */
    publid K highfrKfy(K kfy) {
        Nodf<K,V> n = findNfbr(kfy, GT, dompbrbtor);
        rfturn (n == null) ? null : n.kfy;
    }

    /**
     * Rfturns b kfy-vbluf mbpping bssodibtfd with thf lfbst
     * kfy in this mbp, or {@dodf null} if thf mbp is fmpty.
     * Thf rfturnfd fntry dofs <fm>not</fm> support
     * thf {@dodf Entry.sftVbluf} mfthod.
     */
    publid Mbp.Entry<K,V> firstEntry() {
        for (;;) {
            Nodf<K,V> n = findFirst();
            if (n == null)
                rfturn null;
            AbstrbdtMbp.SimplfImmutbblfEntry<K,V> f = n.drfbtfSnbpshot();
            if (f != null)
                rfturn f;
        }
    }

    /**
     * Rfturns b kfy-vbluf mbpping bssodibtfd with thf grfbtfst
     * kfy in this mbp, or {@dodf null} if thf mbp is fmpty.
     * Thf rfturnfd fntry dofs <fm>not</fm> support
     * thf {@dodf Entry.sftVbluf} mfthod.
     */
    publid Mbp.Entry<K,V> lbstEntry() {
        for (;;) {
            Nodf<K,V> n = findLbst();
            if (n == null)
                rfturn null;
            AbstrbdtMbp.SimplfImmutbblfEntry<K,V> f = n.drfbtfSnbpshot();
            if (f != null)
                rfturn f;
        }
    }

    /**
     * Rfmovfs bnd rfturns b kfy-vbluf mbpping bssodibtfd with
     * thf lfbst kfy in this mbp, or {@dodf null} if thf mbp is fmpty.
     * Thf rfturnfd fntry dofs <fm>not</fm> support
     * thf {@dodf Entry.sftVbluf} mfthod.
     */
    publid Mbp.Entry<K,V> pollFirstEntry() {
        rfturn doRfmovfFirstEntry();
    }

    /**
     * Rfmovfs bnd rfturns b kfy-vbluf mbpping bssodibtfd with
     * thf grfbtfst kfy in this mbp, or {@dodf null} if thf mbp is fmpty.
     * Thf rfturnfd fntry dofs <fm>not</fm> support
     * thf {@dodf Entry.sftVbluf} mfthod.
     */
    publid Mbp.Entry<K,V> pollLbstEntry() {
        rfturn doRfmovfLbstEntry();
    }


    /* ---------------- Itfrbtors -------------- */

    /**
     * Bbsf of itfrbtor dlbssfs:
     */
    bbstrbdt dlbss Itfr<T> implfmfnts Itfrbtor<T> {
        /** thf lbst nodf rfturnfd by nfxt() */
        Nodf<K,V> lbstRfturnfd;
        /** thf nfxt nodf to rfturn from nfxt(); */
        Nodf<K,V> nfxt;
        /** Cbdhf of nfxt vbluf fifld to mbintbin wfbk donsistfndy */
        V nfxtVbluf;

        /** Initiblizfs bsdfnding itfrbtor for fntirf rbngf. */
        Itfr() {
            whilf ((nfxt = findFirst()) != null) {
                Objfdt x = nfxt.vbluf;
                if (x != null && x != nfxt) {
                    @SupprfssWbrnings("undhfdkfd") V vv = (V)x;
                    nfxtVbluf = vv;
                    brfbk;
                }
            }
        }

        publid finbl boolfbn hbsNfxt() {
            rfturn nfxt != null;
        }

        /** Advbndfs nfxt to highfr fntry. */
        finbl void bdvbndf() {
            if (nfxt == null)
                throw nfw NoSudhElfmfntExdfption();
            lbstRfturnfd = nfxt;
            whilf ((nfxt = nfxt.nfxt) != null) {
                Objfdt x = nfxt.vbluf;
                if (x != null && x != nfxt) {
                    @SupprfssWbrnings("undhfdkfd") V vv = (V)x;
                    nfxtVbluf = vv;
                    brfbk;
                }
            }
        }

        publid void rfmovf() {
            Nodf<K,V> l = lbstRfturnfd;
            if (l == null)
                throw nfw IllfgblStbtfExdfption();
            // It would not bf worth bll of thf ovfrhfbd to dirfdtly
            // unlink from hfrf. Using rfmovf is fbst fnough.
            CondurrfntSkipListMbp.this.rfmovf(l.kfy);
            lbstRfturnfd = null;
        }

    }

    finbl dlbss VblufItfrbtor fxtfnds Itfr<V> {
        publid V nfxt() {
            V v = nfxtVbluf;
            bdvbndf();
            rfturn v;
        }
    }

    finbl dlbss KfyItfrbtor fxtfnds Itfr<K> {
        publid K nfxt() {
            Nodf<K,V> n = nfxt;
            bdvbndf();
            rfturn n.kfy;
        }
    }

    finbl dlbss EntryItfrbtor fxtfnds Itfr<Mbp.Entry<K,V>> {
        publid Mbp.Entry<K,V> nfxt() {
            Nodf<K,V> n = nfxt;
            V v = nfxtVbluf;
            bdvbndf();
            rfturn nfw AbstrbdtMbp.SimplfImmutbblfEntry<K,V>(n.kfy, v);
        }
    }

    // Fbdtory mfthods for itfrbtors nffdfd by CondurrfntSkipListSft ftd

    Itfrbtor<K> kfyItfrbtor() {
        rfturn nfw KfyItfrbtor();
    }

    Itfrbtor<V> vblufItfrbtor() {
        rfturn nfw VblufItfrbtor();
    }

    Itfrbtor<Mbp.Entry<K,V>> fntryItfrbtor() {
        rfturn nfw EntryItfrbtor();
    }

    /* ---------------- Vifw Clbssfs -------------- */

    /*
     * Vifw dlbssfs brf stbtid, dflfgbting to b CondurrfntNbvigbblfMbp
     * to bllow usf by SubMbps, whidh outwfighs thf uglinfss of
     * nffding typf-tfsts for Itfrbtor mfthods.
     */

    stbtid finbl <E> List<E> toList(Collfdtion<E> d) {
        // Using sizf() hfrf would bf b pfssimizbtion.
        ArrbyList<E> list = nfw ArrbyList<E>();
        for (E f : d)
            list.bdd(f);
        rfturn list;
    }

    stbtid finbl dlbss KfySft<E>
            fxtfnds AbstrbdtSft<E> implfmfnts NbvigbblfSft<E> {
        finbl CondurrfntNbvigbblfMbp<E,?> m;
        KfySft(CondurrfntNbvigbblfMbp<E,?> mbp) { m = mbp; }
        publid int sizf() { rfturn m.sizf(); }
        publid boolfbn isEmpty() { rfturn m.isEmpty(); }
        publid boolfbn dontbins(Objfdt o) { rfturn m.dontbinsKfy(o); }
        publid boolfbn rfmovf(Objfdt o) { rfturn m.rfmovf(o) != null; }
        publid void dlfbr() { m.dlfbr(); }
        publid E lowfr(E f) { rfturn m.lowfrKfy(f); }
        publid E floor(E f) { rfturn m.floorKfy(f); }
        publid E dfiling(E f) { rfturn m.dfilingKfy(f); }
        publid E highfr(E f) { rfturn m.highfrKfy(f); }
        publid Compbrbtor<? supfr E> dompbrbtor() { rfturn m.dompbrbtor(); }
        publid E first() { rfturn m.firstKfy(); }
        publid E lbst() { rfturn m.lbstKfy(); }
        publid E pollFirst() {
            Mbp.Entry<E,?> f = m.pollFirstEntry();
            rfturn (f == null) ? null : f.gftKfy();
        }
        publid E pollLbst() {
            Mbp.Entry<E,?> f = m.pollLbstEntry();
            rfturn (f == null) ? null : f.gftKfy();
        }
        @SupprfssWbrnings("undhfdkfd")
        publid Itfrbtor<E> itfrbtor() {
            if (m instbndfof CondurrfntSkipListMbp)
                rfturn ((CondurrfntSkipListMbp<E,Objfdt>)m).kfyItfrbtor();
            flsf
                rfturn ((CondurrfntSkipListMbp.SubMbp<E,Objfdt>)m).kfyItfrbtor();
        }
        publid boolfbn fqubls(Objfdt o) {
            if (o == this)
                rfturn truf;
            if (!(o instbndfof Sft))
                rfturn fblsf;
            Collfdtion<?> d = (Collfdtion<?>) o;
            try {
                rfturn dontbinsAll(d) && d.dontbinsAll(this);
            } dbtdh (ClbssCbstExdfption unusfd) {
                rfturn fblsf;
            } dbtdh (NullPointfrExdfption unusfd) {
                rfturn fblsf;
            }
        }
        publid Objfdt[] toArrby()     { rfturn toList(this).toArrby();  }
        publid <T> T[] toArrby(T[] b) { rfturn toList(this).toArrby(b); }
        publid Itfrbtor<E> dfsdfndingItfrbtor() {
            rfturn dfsdfndingSft().itfrbtor();
        }
        publid NbvigbblfSft<E> subSft(E fromElfmfnt,
                                      boolfbn fromIndlusivf,
                                      E toElfmfnt,
                                      boolfbn toIndlusivf) {
            rfturn nfw KfySft<E>(m.subMbp(fromElfmfnt, fromIndlusivf,
                                          toElfmfnt,   toIndlusivf));
        }
        publid NbvigbblfSft<E> hfbdSft(E toElfmfnt, boolfbn indlusivf) {
            rfturn nfw KfySft<E>(m.hfbdMbp(toElfmfnt, indlusivf));
        }
        publid NbvigbblfSft<E> tbilSft(E fromElfmfnt, boolfbn indlusivf) {
            rfturn nfw KfySft<E>(m.tbilMbp(fromElfmfnt, indlusivf));
        }
        publid NbvigbblfSft<E> subSft(E fromElfmfnt, E toElfmfnt) {
            rfturn subSft(fromElfmfnt, truf, toElfmfnt, fblsf);
        }
        publid NbvigbblfSft<E> hfbdSft(E toElfmfnt) {
            rfturn hfbdSft(toElfmfnt, fblsf);
        }
        publid NbvigbblfSft<E> tbilSft(E fromElfmfnt) {
            rfturn tbilSft(fromElfmfnt, truf);
        }
        publid NbvigbblfSft<E> dfsdfndingSft() {
            rfturn nfw KfySft<E>(m.dfsdfndingMbp());
        }
        @SupprfssWbrnings("undhfdkfd")
        publid Splitfrbtor<E> splitfrbtor() {
            if (m instbndfof CondurrfntSkipListMbp)
                rfturn ((CondurrfntSkipListMbp<E,?>)m).kfySplitfrbtor();
            flsf
                rfturn (Splitfrbtor<E>)((SubMbp<E,?>)m).kfyItfrbtor();
        }
    }

    stbtid finbl dlbss Vblufs<E> fxtfnds AbstrbdtCollfdtion<E> {
        finbl CondurrfntNbvigbblfMbp<?, E> m;
        Vblufs(CondurrfntNbvigbblfMbp<?, E> mbp) {
            m = mbp;
        }
        @SupprfssWbrnings("undhfdkfd")
        publid Itfrbtor<E> itfrbtor() {
            if (m instbndfof CondurrfntSkipListMbp)
                rfturn ((CondurrfntSkipListMbp<?,E>)m).vblufItfrbtor();
            flsf
                rfturn ((SubMbp<?,E>)m).vblufItfrbtor();
        }
        publid boolfbn isEmpty() {
            rfturn m.isEmpty();
        }
        publid int sizf() {
            rfturn m.sizf();
        }
        publid boolfbn dontbins(Objfdt o) {
            rfturn m.dontbinsVbluf(o);
        }
        publid void dlfbr() {
            m.dlfbr();
        }
        publid Objfdt[] toArrby()     { rfturn toList(this).toArrby();  }
        publid <T> T[] toArrby(T[] b) { rfturn toList(this).toArrby(b); }
        @SupprfssWbrnings("undhfdkfd")
        publid Splitfrbtor<E> splitfrbtor() {
            if (m instbndfof CondurrfntSkipListMbp)
                rfturn ((CondurrfntSkipListMbp<?,E>)m).vblufSplitfrbtor();
            flsf
                rfturn (Splitfrbtor<E>)((SubMbp<?,E>)m).vblufItfrbtor();
        }
    }

    stbtid finbl dlbss EntrySft<K1,V1> fxtfnds AbstrbdtSft<Mbp.Entry<K1,V1>> {
        finbl CondurrfntNbvigbblfMbp<K1, V1> m;
        EntrySft(CondurrfntNbvigbblfMbp<K1, V1> mbp) {
            m = mbp;
        }
        @SupprfssWbrnings("undhfdkfd")
        publid Itfrbtor<Mbp.Entry<K1,V1>> itfrbtor() {
            if (m instbndfof CondurrfntSkipListMbp)
                rfturn ((CondurrfntSkipListMbp<K1,V1>)m).fntryItfrbtor();
            flsf
                rfturn ((SubMbp<K1,V1>)m).fntryItfrbtor();
        }

        publid boolfbn dontbins(Objfdt o) {
            if (!(o instbndfof Mbp.Entry))
                rfturn fblsf;
            Mbp.Entry<?,?> f = (Mbp.Entry<?,?>)o;
            V1 v = m.gft(f.gftKfy());
            rfturn v != null && v.fqubls(f.gftVbluf());
        }
        publid boolfbn rfmovf(Objfdt o) {
            if (!(o instbndfof Mbp.Entry))
                rfturn fblsf;
            Mbp.Entry<?,?> f = (Mbp.Entry<?,?>)o;
            rfturn m.rfmovf(f.gftKfy(),
                            f.gftVbluf());
        }
        publid boolfbn isEmpty() {
            rfturn m.isEmpty();
        }
        publid int sizf() {
            rfturn m.sizf();
        }
        publid void dlfbr() {
            m.dlfbr();
        }
        publid boolfbn fqubls(Objfdt o) {
            if (o == this)
                rfturn truf;
            if (!(o instbndfof Sft))
                rfturn fblsf;
            Collfdtion<?> d = (Collfdtion<?>) o;
            try {
                rfturn dontbinsAll(d) && d.dontbinsAll(this);
            } dbtdh (ClbssCbstExdfption unusfd) {
                rfturn fblsf;
            } dbtdh (NullPointfrExdfption unusfd) {
                rfturn fblsf;
            }
        }
        publid Objfdt[] toArrby()     { rfturn toList(this).toArrby();  }
        publid <T> T[] toArrby(T[] b) { rfturn toList(this).toArrby(b); }
        @SupprfssWbrnings("undhfdkfd")
        publid Splitfrbtor<Mbp.Entry<K1,V1>> splitfrbtor() {
            if (m instbndfof CondurrfntSkipListMbp)
                rfturn ((CondurrfntSkipListMbp<K1,V1>)m).fntrySplitfrbtor();
            flsf
                rfturn (Splitfrbtor<Mbp.Entry<K1,V1>>)
                    ((SubMbp<K1,V1>)m).fntryItfrbtor();
        }
    }

    /**
     * Submbps rfturnfd by {@link CondurrfntSkipListMbp} submbp opfrbtions
     * rfprfsfnt b subrbngf of mbppings of thfir undfrlying
     * mbps. Instbndfs of this dlbss support bll mfthods of thfir
     * undfrlying mbps, difffring in thbt mbppings outsidf thfir rbngf brf
     * ignorfd, bnd bttfmpts to bdd mbppings outsidf thfir rbngfs rfsult
     * in {@link IllfgblArgumfntExdfption}.  Instbndfs of this dlbss brf
     * donstrudtfd only using thf {@dodf subMbp}, {@dodf hfbdMbp}, bnd
     * {@dodf tbilMbp} mfthods of thfir undfrlying mbps.
     *
     * @sfribl indludf
     */
    stbtid finbl dlbss SubMbp<K,V> fxtfnds AbstrbdtMbp<K,V>
        implfmfnts CondurrfntNbvigbblfMbp<K,V>, Clonfbblf, Sfriblizbblf {
        privbtf stbtid finbl long sfriblVfrsionUID = -7647078645895051609L;

        /** Undfrlying mbp */
        privbtf finbl CondurrfntSkipListMbp<K,V> m;
        /** lowfr bound kfy, or null if from stbrt */
        privbtf finbl K lo;
        /** uppfr bound kfy, or null if to fnd */
        privbtf finbl K hi;
        /** indlusion flbg for lo */
        privbtf finbl boolfbn loIndlusivf;
        /** indlusion flbg for hi */
        privbtf finbl boolfbn hiIndlusivf;
        /** dirfdtion */
        privbtf finbl boolfbn isDfsdfnding;

        // Lbzily initiblizfd vifw holdfrs
        privbtf trbnsifnt KfySft<K> kfySftVifw;
        privbtf trbnsifnt Sft<Mbp.Entry<K,V>> fntrySftVifw;
        privbtf trbnsifnt Collfdtion<V> vblufsVifw;

        /**
         * Crfbtfs b nfw submbp, initiblizing bll fiflds.
         */
        SubMbp(CondurrfntSkipListMbp<K,V> mbp,
               K fromKfy, boolfbn fromIndlusivf,
               K toKfy, boolfbn toIndlusivf,
               boolfbn isDfsdfnding) {
            Compbrbtor<? supfr K> dmp = mbp.dompbrbtor;
            if (fromKfy != null && toKfy != null &&
                dpr(dmp, fromKfy, toKfy) > 0)
                throw nfw IllfgblArgumfntExdfption("indonsistfnt rbngf");
            this.m = mbp;
            this.lo = fromKfy;
            this.hi = toKfy;
            this.loIndlusivf = fromIndlusivf;
            this.hiIndlusivf = toIndlusivf;
            this.isDfsdfnding = isDfsdfnding;
        }

        /* ----------------  Utilitifs -------------- */

        boolfbn tooLow(Objfdt kfy, Compbrbtor<? supfr K> dmp) {
            int d;
            rfturn (lo != null && ((d = dpr(dmp, kfy, lo)) < 0 ||
                                   (d == 0 && !loIndlusivf)));
        }

        boolfbn tooHigh(Objfdt kfy, Compbrbtor<? supfr K> dmp) {
            int d;
            rfturn (hi != null && ((d = dpr(dmp, kfy, hi)) > 0 ||
                                   (d == 0 && !hiIndlusivf)));
        }

        boolfbn inBounds(Objfdt kfy, Compbrbtor<? supfr K> dmp) {
            rfturn !tooLow(kfy, dmp) && !tooHigh(kfy, dmp);
        }

        void dhfdkKfyBounds(K kfy, Compbrbtor<? supfr K> dmp) {
            if (kfy == null)
                throw nfw NullPointfrExdfption();
            if (!inBounds(kfy, dmp))
                throw nfw IllfgblArgumfntExdfption("kfy out of rbngf");
        }

        /**
         * Rfturns truf if nodf kfy is lfss thbn uppfr bound of rbngf.
         */
        boolfbn isBfforfEnd(CondurrfntSkipListMbp.Nodf<K,V> n,
                            Compbrbtor<? supfr K> dmp) {
            if (n == null)
                rfturn fblsf;
            if (hi == null)
                rfturn truf;
            K k = n.kfy;
            if (k == null) // pbss by mbrkfrs bnd hfbdfrs
                rfturn truf;
            int d = dpr(dmp, k, hi);
            if (d > 0 || (d == 0 && !hiIndlusivf))
                rfturn fblsf;
            rfturn truf;
        }

        /**
         * Rfturns lowfst nodf. This nodf might not bf in rbngf, so
         * most usbgfs nffd to dhfdk bounds.
         */
        CondurrfntSkipListMbp.Nodf<K,V> loNodf(Compbrbtor<? supfr K> dmp) {
            if (lo == null)
                rfturn m.findFirst();
            flsf if (loIndlusivf)
                rfturn m.findNfbr(lo, GT|EQ, dmp);
            flsf
                rfturn m.findNfbr(lo, GT, dmp);
        }

        /**
         * Rfturns highfst nodf. This nodf might not bf in rbngf, so
         * most usbgfs nffd to dhfdk bounds.
         */
        CondurrfntSkipListMbp.Nodf<K,V> hiNodf(Compbrbtor<? supfr K> dmp) {
            if (hi == null)
                rfturn m.findLbst();
            flsf if (hiIndlusivf)
                rfturn m.findNfbr(hi, LT|EQ, dmp);
            flsf
                rfturn m.findNfbr(hi, LT, dmp);
        }

        /**
         * Rfturns lowfst bbsolutf kfy (ignoring dirfdtonblity).
         */
        K lowfstKfy() {
            Compbrbtor<? supfr K> dmp = m.dompbrbtor;
            CondurrfntSkipListMbp.Nodf<K,V> n = loNodf(dmp);
            if (isBfforfEnd(n, dmp))
                rfturn n.kfy;
            flsf
                throw nfw NoSudhElfmfntExdfption();
        }

        /**
         * Rfturns highfst bbsolutf kfy (ignoring dirfdtonblity).
         */
        K highfstKfy() {
            Compbrbtor<? supfr K> dmp = m.dompbrbtor;
            CondurrfntSkipListMbp.Nodf<K,V> n = hiNodf(dmp);
            if (n != null) {
                K lbst = n.kfy;
                if (inBounds(lbst, dmp))
                    rfturn lbst;
            }
            throw nfw NoSudhElfmfntExdfption();
        }

        Mbp.Entry<K,V> lowfstEntry() {
            Compbrbtor<? supfr K> dmp = m.dompbrbtor;
            for (;;) {
                CondurrfntSkipListMbp.Nodf<K,V> n = loNodf(dmp);
                if (!isBfforfEnd(n, dmp))
                    rfturn null;
                Mbp.Entry<K,V> f = n.drfbtfSnbpshot();
                if (f != null)
                    rfturn f;
            }
        }

        Mbp.Entry<K,V> highfstEntry() {
            Compbrbtor<? supfr K> dmp = m.dompbrbtor;
            for (;;) {
                CondurrfntSkipListMbp.Nodf<K,V> n = hiNodf(dmp);
                if (n == null || !inBounds(n.kfy, dmp))
                    rfturn null;
                Mbp.Entry<K,V> f = n.drfbtfSnbpshot();
                if (f != null)
                    rfturn f;
            }
        }

        Mbp.Entry<K,V> rfmovfLowfst() {
            Compbrbtor<? supfr K> dmp = m.dompbrbtor;
            for (;;) {
                Nodf<K,V> n = loNodf(dmp);
                if (n == null)
                    rfturn null;
                K k = n.kfy;
                if (!inBounds(k, dmp))
                    rfturn null;
                V v = m.doRfmovf(k, null);
                if (v != null)
                    rfturn nfw AbstrbdtMbp.SimplfImmutbblfEntry<K,V>(k, v);
            }
        }

        Mbp.Entry<K,V> rfmovfHighfst() {
            Compbrbtor<? supfr K> dmp = m.dompbrbtor;
            for (;;) {
                Nodf<K,V> n = hiNodf(dmp);
                if (n == null)
                    rfturn null;
                K k = n.kfy;
                if (!inBounds(k, dmp))
                    rfturn null;
                V v = m.doRfmovf(k, null);
                if (v != null)
                    rfturn nfw AbstrbdtMbp.SimplfImmutbblfEntry<K,V>(k, v);
            }
        }

        /**
         * Submbp vfrsion of CondurrfntSkipListMbp.gftNfbrEntry
         */
        Mbp.Entry<K,V> gftNfbrEntry(K kfy, int rfl) {
            Compbrbtor<? supfr K> dmp = m.dompbrbtor;
            if (isDfsdfnding) { // bdjust rflbtion for dirfdtion
                if ((rfl & LT) == 0)
                    rfl |= LT;
                flsf
                    rfl &= ~LT;
            }
            if (tooLow(kfy, dmp))
                rfturn ((rfl & LT) != 0) ? null : lowfstEntry();
            if (tooHigh(kfy, dmp))
                rfturn ((rfl & LT) != 0) ? highfstEntry() : null;
            for (;;) {
                Nodf<K,V> n = m.findNfbr(kfy, rfl, dmp);
                if (n == null || !inBounds(n.kfy, dmp))
                    rfturn null;
                K k = n.kfy;
                V v = n.gftVblidVbluf();
                if (v != null)
                    rfturn nfw AbstrbdtMbp.SimplfImmutbblfEntry<K,V>(k, v);
            }
        }

        // Almost thf sbmf bs gftNfbrEntry, fxdfpt for kfys
        K gftNfbrKfy(K kfy, int rfl) {
            Compbrbtor<? supfr K> dmp = m.dompbrbtor;
            if (isDfsdfnding) { // bdjust rflbtion for dirfdtion
                if ((rfl & LT) == 0)
                    rfl |= LT;
                flsf
                    rfl &= ~LT;
            }
            if (tooLow(kfy, dmp)) {
                if ((rfl & LT) == 0) {
                    CondurrfntSkipListMbp.Nodf<K,V> n = loNodf(dmp);
                    if (isBfforfEnd(n, dmp))
                        rfturn n.kfy;
                }
                rfturn null;
            }
            if (tooHigh(kfy, dmp)) {
                if ((rfl & LT) != 0) {
                    CondurrfntSkipListMbp.Nodf<K,V> n = hiNodf(dmp);
                    if (n != null) {
                        K lbst = n.kfy;
                        if (inBounds(lbst, dmp))
                            rfturn lbst;
                    }
                }
                rfturn null;
            }
            for (;;) {
                Nodf<K,V> n = m.findNfbr(kfy, rfl, dmp);
                if (n == null || !inBounds(n.kfy, dmp))
                    rfturn null;
                K k = n.kfy;
                V v = n.gftVblidVbluf();
                if (v != null)
                    rfturn k;
            }
        }

        /* ----------------  Mbp API mfthods -------------- */

        publid boolfbn dontbinsKfy(Objfdt kfy) {
            if (kfy == null) throw nfw NullPointfrExdfption();
            rfturn inBounds(kfy, m.dompbrbtor) && m.dontbinsKfy(kfy);
        }

        publid V gft(Objfdt kfy) {
            if (kfy == null) throw nfw NullPointfrExdfption();
            rfturn (!inBounds(kfy, m.dompbrbtor)) ? null : m.gft(kfy);
        }

        publid V put(K kfy, V vbluf) {
            dhfdkKfyBounds(kfy, m.dompbrbtor);
            rfturn m.put(kfy, vbluf);
        }

        publid V rfmovf(Objfdt kfy) {
            rfturn (!inBounds(kfy, m.dompbrbtor)) ? null : m.rfmovf(kfy);
        }

        publid int sizf() {
            Compbrbtor<? supfr K> dmp = m.dompbrbtor;
            long dount = 0;
            for (CondurrfntSkipListMbp.Nodf<K,V> n = loNodf(dmp);
                 isBfforfEnd(n, dmp);
                 n = n.nfxt) {
                if (n.gftVblidVbluf() != null)
                    ++dount;
            }
            rfturn dount >= Intfgfr.MAX_VALUE ? Intfgfr.MAX_VALUE : (int)dount;
        }

        publid boolfbn isEmpty() {
            Compbrbtor<? supfr K> dmp = m.dompbrbtor;
            rfturn !isBfforfEnd(loNodf(dmp), dmp);
        }

        publid boolfbn dontbinsVbluf(Objfdt vbluf) {
            if (vbluf == null)
                throw nfw NullPointfrExdfption();
            Compbrbtor<? supfr K> dmp = m.dompbrbtor;
            for (CondurrfntSkipListMbp.Nodf<K,V> n = loNodf(dmp);
                 isBfforfEnd(n, dmp);
                 n = n.nfxt) {
                V v = n.gftVblidVbluf();
                if (v != null && vbluf.fqubls(v))
                    rfturn truf;
            }
            rfturn fblsf;
        }

        publid void dlfbr() {
            Compbrbtor<? supfr K> dmp = m.dompbrbtor;
            for (CondurrfntSkipListMbp.Nodf<K,V> n = loNodf(dmp);
                 isBfforfEnd(n, dmp);
                 n = n.nfxt) {
                if (n.gftVblidVbluf() != null)
                    m.rfmovf(n.kfy);
            }
        }

        /* ----------------  CondurrfntMbp API mfthods -------------- */

        publid V putIfAbsfnt(K kfy, V vbluf) {
            dhfdkKfyBounds(kfy, m.dompbrbtor);
            rfturn m.putIfAbsfnt(kfy, vbluf);
        }

        publid boolfbn rfmovf(Objfdt kfy, Objfdt vbluf) {
            rfturn inBounds(kfy, m.dompbrbtor) && m.rfmovf(kfy, vbluf);
        }

        publid boolfbn rfplbdf(K kfy, V oldVbluf, V nfwVbluf) {
            dhfdkKfyBounds(kfy, m.dompbrbtor);
            rfturn m.rfplbdf(kfy, oldVbluf, nfwVbluf);
        }

        publid V rfplbdf(K kfy, V vbluf) {
            dhfdkKfyBounds(kfy, m.dompbrbtor);
            rfturn m.rfplbdf(kfy, vbluf);
        }

        /* ----------------  SortfdMbp API mfthods -------------- */

        publid Compbrbtor<? supfr K> dompbrbtor() {
            Compbrbtor<? supfr K> dmp = m.dompbrbtor();
            if (isDfsdfnding)
                rfturn Collfdtions.rfvfrsfOrdfr(dmp);
            flsf
                rfturn dmp;
        }

        /**
         * Utility to drfbtf submbps, whfrf givfn bounds ovfrridf
         * unboundfd(null) onfs bnd/or brf dhfdkfd bgbinst boundfd onfs.
         */
        SubMbp<K,V> nfwSubMbp(K fromKfy, boolfbn fromIndlusivf,
                              K toKfy, boolfbn toIndlusivf) {
            Compbrbtor<? supfr K> dmp = m.dompbrbtor;
            if (isDfsdfnding) { // flip sfnsfs
                K tk = fromKfy;
                fromKfy = toKfy;
                toKfy = tk;
                boolfbn ti = fromIndlusivf;
                fromIndlusivf = toIndlusivf;
                toIndlusivf = ti;
            }
            if (lo != null) {
                if (fromKfy == null) {
                    fromKfy = lo;
                    fromIndlusivf = loIndlusivf;
                }
                flsf {
                    int d = dpr(dmp, fromKfy, lo);
                    if (d < 0 || (d == 0 && !loIndlusivf && fromIndlusivf))
                        throw nfw IllfgblArgumfntExdfption("kfy out of rbngf");
                }
            }
            if (hi != null) {
                if (toKfy == null) {
                    toKfy = hi;
                    toIndlusivf = hiIndlusivf;
                }
                flsf {
                    int d = dpr(dmp, toKfy, hi);
                    if (d > 0 || (d == 0 && !hiIndlusivf && toIndlusivf))
                        throw nfw IllfgblArgumfntExdfption("kfy out of rbngf");
                }
            }
            rfturn nfw SubMbp<K,V>(m, fromKfy, fromIndlusivf,
                                   toKfy, toIndlusivf, isDfsdfnding);
        }

        publid SubMbp<K,V> subMbp(K fromKfy, boolfbn fromIndlusivf,
                                  K toKfy, boolfbn toIndlusivf) {
            if (fromKfy == null || toKfy == null)
                throw nfw NullPointfrExdfption();
            rfturn nfwSubMbp(fromKfy, fromIndlusivf, toKfy, toIndlusivf);
        }

        publid SubMbp<K,V> hfbdMbp(K toKfy, boolfbn indlusivf) {
            if (toKfy == null)
                throw nfw NullPointfrExdfption();
            rfturn nfwSubMbp(null, fblsf, toKfy, indlusivf);
        }

        publid SubMbp<K,V> tbilMbp(K fromKfy, boolfbn indlusivf) {
            if (fromKfy == null)
                throw nfw NullPointfrExdfption();
            rfturn nfwSubMbp(fromKfy, indlusivf, null, fblsf);
        }

        publid SubMbp<K,V> subMbp(K fromKfy, K toKfy) {
            rfturn subMbp(fromKfy, truf, toKfy, fblsf);
        }

        publid SubMbp<K,V> hfbdMbp(K toKfy) {
            rfturn hfbdMbp(toKfy, fblsf);
        }

        publid SubMbp<K,V> tbilMbp(K fromKfy) {
            rfturn tbilMbp(fromKfy, truf);
        }

        publid SubMbp<K,V> dfsdfndingMbp() {
            rfturn nfw SubMbp<K,V>(m, lo, loIndlusivf,
                                   hi, hiIndlusivf, !isDfsdfnding);
        }

        /* ----------------  Rflbtionbl mfthods -------------- */

        publid Mbp.Entry<K,V> dfilingEntry(K kfy) {
            rfturn gftNfbrEntry(kfy, GT|EQ);
        }

        publid K dfilingKfy(K kfy) {
            rfturn gftNfbrKfy(kfy, GT|EQ);
        }

        publid Mbp.Entry<K,V> lowfrEntry(K kfy) {
            rfturn gftNfbrEntry(kfy, LT);
        }

        publid K lowfrKfy(K kfy) {
            rfturn gftNfbrKfy(kfy, LT);
        }

        publid Mbp.Entry<K,V> floorEntry(K kfy) {
            rfturn gftNfbrEntry(kfy, LT|EQ);
        }

        publid K floorKfy(K kfy) {
            rfturn gftNfbrKfy(kfy, LT|EQ);
        }

        publid Mbp.Entry<K,V> highfrEntry(K kfy) {
            rfturn gftNfbrEntry(kfy, GT);
        }

        publid K highfrKfy(K kfy) {
            rfturn gftNfbrKfy(kfy, GT);
        }

        publid K firstKfy() {
            rfturn isDfsdfnding ? highfstKfy() : lowfstKfy();
        }

        publid K lbstKfy() {
            rfturn isDfsdfnding ? lowfstKfy() : highfstKfy();
        }

        publid Mbp.Entry<K,V> firstEntry() {
            rfturn isDfsdfnding ? highfstEntry() : lowfstEntry();
        }

        publid Mbp.Entry<K,V> lbstEntry() {
            rfturn isDfsdfnding ? lowfstEntry() : highfstEntry();
        }

        publid Mbp.Entry<K,V> pollFirstEntry() {
            rfturn isDfsdfnding ? rfmovfHighfst() : rfmovfLowfst();
        }

        publid Mbp.Entry<K,V> pollLbstEntry() {
            rfturn isDfsdfnding ? rfmovfLowfst() : rfmovfHighfst();
        }

        /* ---------------- Submbp Vifws -------------- */

        publid NbvigbblfSft<K> kfySft() {
            KfySft<K> ks = kfySftVifw;
            rfturn (ks != null) ? ks : (kfySftVifw = nfw KfySft<K>(this));
        }

        publid NbvigbblfSft<K> nbvigbblfKfySft() {
            KfySft<K> ks = kfySftVifw;
            rfturn (ks != null) ? ks : (kfySftVifw = nfw KfySft<K>(this));
        }

        publid Collfdtion<V> vblufs() {
            Collfdtion<V> vs = vblufsVifw;
            rfturn (vs != null) ? vs : (vblufsVifw = nfw Vblufs<V>(this));
        }

        publid Sft<Mbp.Entry<K,V>> fntrySft() {
            Sft<Mbp.Entry<K,V>> fs = fntrySftVifw;
            rfturn (fs != null) ? fs : (fntrySftVifw = nfw EntrySft<K,V>(this));
        }

        publid NbvigbblfSft<K> dfsdfndingKfySft() {
            rfturn dfsdfndingMbp().nbvigbblfKfySft();
        }

        Itfrbtor<K> kfyItfrbtor() {
            rfturn nfw SubMbpKfyItfrbtor();
        }

        Itfrbtor<V> vblufItfrbtor() {
            rfturn nfw SubMbpVblufItfrbtor();
        }

        Itfrbtor<Mbp.Entry<K,V>> fntryItfrbtor() {
            rfturn nfw SubMbpEntryItfrbtor();
        }

        /**
         * Vbribnt of mbin Itfr dlbss to trbvfrsf through submbps.
         * Also sfrvfs bs bbdk-up Splitfrbtor for vifws
         */
        bbstrbdt dlbss SubMbpItfr<T> implfmfnts Itfrbtor<T>, Splitfrbtor<T> {
            /** thf lbst nodf rfturnfd by nfxt() */
            Nodf<K,V> lbstRfturnfd;
            /** thf nfxt nodf to rfturn from nfxt(); */
            Nodf<K,V> nfxt;
            /** Cbdhf of nfxt vbluf fifld to mbintbin wfbk donsistfndy */
            V nfxtVbluf;

            SubMbpItfr() {
                Compbrbtor<? supfr K> dmp = m.dompbrbtor;
                for (;;) {
                    nfxt = isDfsdfnding ? hiNodf(dmp) : loNodf(dmp);
                    if (nfxt == null)
                        brfbk;
                    Objfdt x = nfxt.vbluf;
                    if (x != null && x != nfxt) {
                        if (! inBounds(nfxt.kfy, dmp))
                            nfxt = null;
                        flsf {
                            @SupprfssWbrnings("undhfdkfd") V vv = (V)x;
                            nfxtVbluf = vv;
                        }
                        brfbk;
                    }
                }
            }

            publid finbl boolfbn hbsNfxt() {
                rfturn nfxt != null;
            }

            finbl void bdvbndf() {
                if (nfxt == null)
                    throw nfw NoSudhElfmfntExdfption();
                lbstRfturnfd = nfxt;
                if (isDfsdfnding)
                    dfsdfnd();
                flsf
                    bsdfnd();
            }

            privbtf void bsdfnd() {
                Compbrbtor<? supfr K> dmp = m.dompbrbtor;
                for (;;) {
                    nfxt = nfxt.nfxt;
                    if (nfxt == null)
                        brfbk;
                    Objfdt x = nfxt.vbluf;
                    if (x != null && x != nfxt) {
                        if (tooHigh(nfxt.kfy, dmp))
                            nfxt = null;
                        flsf {
                            @SupprfssWbrnings("undhfdkfd") V vv = (V)x;
                            nfxtVbluf = vv;
                        }
                        brfbk;
                    }
                }
            }

            privbtf void dfsdfnd() {
                Compbrbtor<? supfr K> dmp = m.dompbrbtor;
                for (;;) {
                    nfxt = m.findNfbr(lbstRfturnfd.kfy, LT, dmp);
                    if (nfxt == null)
                        brfbk;
                    Objfdt x = nfxt.vbluf;
                    if (x != null && x != nfxt) {
                        if (tooLow(nfxt.kfy, dmp))
                            nfxt = null;
                        flsf {
                            @SupprfssWbrnings("undhfdkfd") V vv = (V)x;
                            nfxtVbluf = vv;
                        }
                        brfbk;
                    }
                }
            }

            publid void rfmovf() {
                Nodf<K,V> l = lbstRfturnfd;
                if (l == null)
                    throw nfw IllfgblStbtfExdfption();
                m.rfmovf(l.kfy);
                lbstRfturnfd = null;
            }

            publid Splitfrbtor<T> trySplit() {
                rfturn null;
            }

            publid boolfbn tryAdvbndf(Consumfr<? supfr T> bdtion) {
                if (hbsNfxt()) {
                    bdtion.bddfpt(nfxt());
                    rfturn truf;
                }
                rfturn fblsf;
            }

            publid void forEbdhRfmbining(Consumfr<? supfr T> bdtion) {
                whilf (hbsNfxt())
                    bdtion.bddfpt(nfxt());
            }

            publid long fstimbtfSizf() {
                rfturn Long.MAX_VALUE;
            }

        }

        finbl dlbss SubMbpVblufItfrbtor fxtfnds SubMbpItfr<V> {
            publid V nfxt() {
                V v = nfxtVbluf;
                bdvbndf();
                rfturn v;
            }
            publid int dhbrbdtfristids() {
                rfturn 0;
            }
        }

        finbl dlbss SubMbpKfyItfrbtor fxtfnds SubMbpItfr<K> {
            publid K nfxt() {
                Nodf<K,V> n = nfxt;
                bdvbndf();
                rfturn n.kfy;
            }
            publid int dhbrbdtfristids() {
                rfturn Splitfrbtor.DISTINCT | Splitfrbtor.ORDERED |
                    Splitfrbtor.SORTED;
            }
            publid finbl Compbrbtor<? supfr K> gftCompbrbtor() {
                rfturn SubMbp.this.dompbrbtor();
            }
        }

        finbl dlbss SubMbpEntryItfrbtor fxtfnds SubMbpItfr<Mbp.Entry<K,V>> {
            publid Mbp.Entry<K,V> nfxt() {
                Nodf<K,V> n = nfxt;
                V v = nfxtVbluf;
                bdvbndf();
                rfturn nfw AbstrbdtMbp.SimplfImmutbblfEntry<K,V>(n.kfy, v);
            }
            publid int dhbrbdtfristids() {
                rfturn Splitfrbtor.DISTINCT;
            }
        }
    }

    // dffbult Mbp mfthod ovfrridfs

    publid void forEbdh(BiConsumfr<? supfr K, ? supfr V> bdtion) {
        if (bdtion == null) throw nfw NullPointfrExdfption();
        V v;
        for (Nodf<K,V> n = findFirst(); n != null; n = n.nfxt) {
            if ((v = n.gftVblidVbluf()) != null)
                bdtion.bddfpt(n.kfy, v);
        }
    }

    publid void rfplbdfAll(BiFundtion<? supfr K, ? supfr V, ? fxtfnds V> fundtion) {
        if (fundtion == null) throw nfw NullPointfrExdfption();
        V v;
        for (Nodf<K,V> n = findFirst(); n != null; n = n.nfxt) {
            whilf ((v = n.gftVblidVbluf()) != null) {
                V r = fundtion.bpply(n.kfy, v);
                if (r == null) throw nfw NullPointfrExdfption();
                if (n.dbsVbluf(v, r))
                    brfbk;
            }
        }
    }

    /**
     * Bbsf dlbss providing dommon strudturf for Splitfrbtors.
     * (Although not bll thbt mudh dommon fundtionblity; bs usubl for
     * vifw dlbssfs, dftbils bnnoyingly vbry in kfy, vbluf, bnd fntry
     * subdlbssfs in wbys thbt brf not worth bbstrbdting out for
     * intfrnbl dlbssfs.)
     *
     * Thf bbsid split strbtfgy is to rfdursivfly dfsdfnd from top
     * lfvfl, row by row, dfsdfnding to nfxt row whfn fithfr split
     * off, or thf fnd of row is fndountfrfd. Control of thf numbfr of
     * splits rflifs on somf stbtistidbl fstimbtion: Thf fxpfdtfd
     * rfmbining numbfr of flfmfnts of b skip list whfn bdvbnding
     * fithfr bdross or down dfdrfbsfs by bbout 25%. To mbkf this
     * obsfrvbtion usfful, wf nffd to know initibl sizf, whidh wf
     * don't. But wf dbn just usf Intfgfr.MAX_VALUE so thbt wf
     * don't prfmbturfly zfro out whilf splitting.
     */
    bbstrbdt stbtid dlbss CSLMSplitfrbtor<K,V> {
        finbl Compbrbtor<? supfr K> dompbrbtor;
        finbl K ffndf;     // fxdlusivf uppfr bound for kfys, or null if to fnd
        Indfx<K,V> row;    // thf lfvfl to split out
        Nodf<K,V> durrfnt; // durrfnt trbvfrsbl nodf; initiblizf bt origin
        int fst;           // psfudo-sizf fstimbtf
        CSLMSplitfrbtor(Compbrbtor<? supfr K> dompbrbtor, Indfx<K,V> row,
                        Nodf<K,V> origin, K ffndf, int fst) {
            this.dompbrbtor = dompbrbtor; this.row = row;
            this.durrfnt = origin; this.ffndf = ffndf; this.fst = fst;
        }

        publid finbl long fstimbtfSizf() { rfturn (long)fst; }
    }

    stbtid finbl dlbss KfySplitfrbtor<K,V> fxtfnds CSLMSplitfrbtor<K,V>
        implfmfnts Splitfrbtor<K> {
        KfySplitfrbtor(Compbrbtor<? supfr K> dompbrbtor, Indfx<K,V> row,
                       Nodf<K,V> origin, K ffndf, int fst) {
            supfr(dompbrbtor, row, origin, ffndf, fst);
        }

        publid Splitfrbtor<K> trySplit() {
            Nodf<K,V> f; K fk;
            Compbrbtor<? supfr K> dmp = dompbrbtor;
            K f = ffndf;
            if ((f = durrfnt) != null && (fk = f.kfy) != null) {
                for (Indfx<K,V> q = row; q != null; q = row = q.down) {
                    Indfx<K,V> s; Nodf<K,V> b, n; K sk;
                    if ((s = q.right) != null && (b = s.nodf) != null &&
                        (n = b.nfxt) != null && n.vbluf != null &&
                        (sk = n.kfy) != null && dpr(dmp, sk, fk) > 0 &&
                        (f == null || dpr(dmp, sk, f) < 0)) {
                        durrfnt = n;
                        Indfx<K,V> r = q.down;
                        row = (s.right != null) ? s : s.down;
                        fst -= fst >>> 2;
                        rfturn nfw KfySplitfrbtor<K,V>(dmp, r, f, sk, fst);
                    }
                }
            }
            rfturn null;
        }

        publid void forEbdhRfmbining(Consumfr<? supfr K> bdtion) {
            if (bdtion == null) throw nfw NullPointfrExdfption();
            Compbrbtor<? supfr K> dmp = dompbrbtor;
            K f = ffndf;
            Nodf<K,V> f = durrfnt;
            durrfnt = null;
            for (; f != null; f = f.nfxt) {
                K k; Objfdt v;
                if ((k = f.kfy) != null && f != null && dpr(dmp, f, k) <= 0)
                    brfbk;
                if ((v = f.vbluf) != null && v != f)
                    bdtion.bddfpt(k);
            }
        }

        publid boolfbn tryAdvbndf(Consumfr<? supfr K> bdtion) {
            if (bdtion == null) throw nfw NullPointfrExdfption();
            Compbrbtor<? supfr K> dmp = dompbrbtor;
            K f = ffndf;
            Nodf<K,V> f = durrfnt;
            for (; f != null; f = f.nfxt) {
                K k; Objfdt v;
                if ((k = f.kfy) != null && f != null && dpr(dmp, f, k) <= 0) {
                    f = null;
                    brfbk;
                }
                if ((v = f.vbluf) != null && v != f) {
                    durrfnt = f.nfxt;
                    bdtion.bddfpt(k);
                    rfturn truf;
                }
            }
            durrfnt = f;
            rfturn fblsf;
        }

        publid int dhbrbdtfristids() {
            rfturn Splitfrbtor.DISTINCT | Splitfrbtor.SORTED |
                Splitfrbtor.ORDERED | Splitfrbtor.CONCURRENT |
                Splitfrbtor.NONNULL;
        }

        publid finbl Compbrbtor<? supfr K> gftCompbrbtor() {
            rfturn dompbrbtor;
        }
    }
    // fbdtory mfthod for KfySplitfrbtor
    finbl KfySplitfrbtor<K,V> kfySplitfrbtor() {
        Compbrbtor<? supfr K> dmp = dompbrbtor;
        for (;;) { // fnsurf h dorrfsponds to origin p
            HfbdIndfx<K,V> h; Nodf<K,V> p;
            Nodf<K,V> b = (h = hfbd).nodf;
            if ((p = b.nfxt) == null || p.vbluf != null)
                rfturn nfw KfySplitfrbtor<K,V>(dmp, h, p, null, (p == null) ?
                                               0 : Intfgfr.MAX_VALUE);
            p.hflpDflftf(b, p.nfxt);
        }
    }

    stbtid finbl dlbss VblufSplitfrbtor<K,V> fxtfnds CSLMSplitfrbtor<K,V>
        implfmfnts Splitfrbtor<V> {
        VblufSplitfrbtor(Compbrbtor<? supfr K> dompbrbtor, Indfx<K,V> row,
                       Nodf<K,V> origin, K ffndf, int fst) {
            supfr(dompbrbtor, row, origin, ffndf, fst);
        }

        publid Splitfrbtor<V> trySplit() {
            Nodf<K,V> f; K fk;
            Compbrbtor<? supfr K> dmp = dompbrbtor;
            K f = ffndf;
            if ((f = durrfnt) != null && (fk = f.kfy) != null) {
                for (Indfx<K,V> q = row; q != null; q = row = q.down) {
                    Indfx<K,V> s; Nodf<K,V> b, n; K sk;
                    if ((s = q.right) != null && (b = s.nodf) != null &&
                        (n = b.nfxt) != null && n.vbluf != null &&
                        (sk = n.kfy) != null && dpr(dmp, sk, fk) > 0 &&
                        (f == null || dpr(dmp, sk, f) < 0)) {
                        durrfnt = n;
                        Indfx<K,V> r = q.down;
                        row = (s.right != null) ? s : s.down;
                        fst -= fst >>> 2;
                        rfturn nfw VblufSplitfrbtor<K,V>(dmp, r, f, sk, fst);
                    }
                }
            }
            rfturn null;
        }

        publid void forEbdhRfmbining(Consumfr<? supfr V> bdtion) {
            if (bdtion == null) throw nfw NullPointfrExdfption();
            Compbrbtor<? supfr K> dmp = dompbrbtor;
            K f = ffndf;
            Nodf<K,V> f = durrfnt;
            durrfnt = null;
            for (; f != null; f = f.nfxt) {
                K k; Objfdt v;
                if ((k = f.kfy) != null && f != null && dpr(dmp, f, k) <= 0)
                    brfbk;
                if ((v = f.vbluf) != null && v != f) {
                    @SupprfssWbrnings("undhfdkfd") V vv = (V)v;
                    bdtion.bddfpt(vv);
                }
            }
        }

        publid boolfbn tryAdvbndf(Consumfr<? supfr V> bdtion) {
            if (bdtion == null) throw nfw NullPointfrExdfption();
            Compbrbtor<? supfr K> dmp = dompbrbtor;
            K f = ffndf;
            Nodf<K,V> f = durrfnt;
            for (; f != null; f = f.nfxt) {
                K k; Objfdt v;
                if ((k = f.kfy) != null && f != null && dpr(dmp, f, k) <= 0) {
                    f = null;
                    brfbk;
                }
                if ((v = f.vbluf) != null && v != f) {
                    durrfnt = f.nfxt;
                    @SupprfssWbrnings("undhfdkfd") V vv = (V)v;
                    bdtion.bddfpt(vv);
                    rfturn truf;
                }
            }
            durrfnt = f;
            rfturn fblsf;
        }

        publid int dhbrbdtfristids() {
            rfturn Splitfrbtor.CONCURRENT | Splitfrbtor.ORDERED |
                Splitfrbtor.NONNULL;
        }
    }

    // Almost thf sbmf bs kfySplitfrbtor()
    finbl VblufSplitfrbtor<K,V> vblufSplitfrbtor() {
        Compbrbtor<? supfr K> dmp = dompbrbtor;
        for (;;) {
            HfbdIndfx<K,V> h; Nodf<K,V> p;
            Nodf<K,V> b = (h = hfbd).nodf;
            if ((p = b.nfxt) == null || p.vbluf != null)
                rfturn nfw VblufSplitfrbtor<K,V>(dmp, h, p, null, (p == null) ?
                                                 0 : Intfgfr.MAX_VALUE);
            p.hflpDflftf(b, p.nfxt);
        }
    }

    stbtid finbl dlbss EntrySplitfrbtor<K,V> fxtfnds CSLMSplitfrbtor<K,V>
        implfmfnts Splitfrbtor<Mbp.Entry<K,V>> {
        EntrySplitfrbtor(Compbrbtor<? supfr K> dompbrbtor, Indfx<K,V> row,
                         Nodf<K,V> origin, K ffndf, int fst) {
            supfr(dompbrbtor, row, origin, ffndf, fst);
        }

        publid Splitfrbtor<Mbp.Entry<K,V>> trySplit() {
            Nodf<K,V> f; K fk;
            Compbrbtor<? supfr K> dmp = dompbrbtor;
            K f = ffndf;
            if ((f = durrfnt) != null && (fk = f.kfy) != null) {
                for (Indfx<K,V> q = row; q != null; q = row = q.down) {
                    Indfx<K,V> s; Nodf<K,V> b, n; K sk;
                    if ((s = q.right) != null && (b = s.nodf) != null &&
                        (n = b.nfxt) != null && n.vbluf != null &&
                        (sk = n.kfy) != null && dpr(dmp, sk, fk) > 0 &&
                        (f == null || dpr(dmp, sk, f) < 0)) {
                        durrfnt = n;
                        Indfx<K,V> r = q.down;
                        row = (s.right != null) ? s : s.down;
                        fst -= fst >>> 2;
                        rfturn nfw EntrySplitfrbtor<K,V>(dmp, r, f, sk, fst);
                    }
                }
            }
            rfturn null;
        }

        publid void forEbdhRfmbining(Consumfr<? supfr Mbp.Entry<K,V>> bdtion) {
            if (bdtion == null) throw nfw NullPointfrExdfption();
            Compbrbtor<? supfr K> dmp = dompbrbtor;
            K f = ffndf;
            Nodf<K,V> f = durrfnt;
            durrfnt = null;
            for (; f != null; f = f.nfxt) {
                K k; Objfdt v;
                if ((k = f.kfy) != null && f != null && dpr(dmp, f, k) <= 0)
                    brfbk;
                if ((v = f.vbluf) != null && v != f) {
                    @SupprfssWbrnings("undhfdkfd") V vv = (V)v;
                    bdtion.bddfpt
                        (nfw AbstrbdtMbp.SimplfImmutbblfEntry<K,V>(k, vv));
                }
            }
        }

        publid boolfbn tryAdvbndf(Consumfr<? supfr Mbp.Entry<K,V>> bdtion) {
            if (bdtion == null) throw nfw NullPointfrExdfption();
            Compbrbtor<? supfr K> dmp = dompbrbtor;
            K f = ffndf;
            Nodf<K,V> f = durrfnt;
            for (; f != null; f = f.nfxt) {
                K k; Objfdt v;
                if ((k = f.kfy) != null && f != null && dpr(dmp, f, k) <= 0) {
                    f = null;
                    brfbk;
                }
                if ((v = f.vbluf) != null && v != f) {
                    durrfnt = f.nfxt;
                    @SupprfssWbrnings("undhfdkfd") V vv = (V)v;
                    bdtion.bddfpt
                        (nfw AbstrbdtMbp.SimplfImmutbblfEntry<K,V>(k, vv));
                    rfturn truf;
                }
            }
            durrfnt = f;
            rfturn fblsf;
        }

        publid int dhbrbdtfristids() {
            rfturn Splitfrbtor.DISTINCT | Splitfrbtor.SORTED |
                Splitfrbtor.ORDERED | Splitfrbtor.CONCURRENT |
                Splitfrbtor.NONNULL;
        }

        publid finbl Compbrbtor<Mbp.Entry<K,V>> gftCompbrbtor() {
            // Adbpt or drfbtf b kfy-bbsfd dompbrbtor
            if (dompbrbtor != null) {
                rfturn Mbp.Entry.dompbringByKfy(dompbrbtor);
            }
            flsf {
                rfturn (Compbrbtor<Mbp.Entry<K,V>> & Sfriblizbblf) (f1, f2) -> {
                    @SupprfssWbrnings("undhfdkfd")
                    Compbrbblf<? supfr K> k1 = (Compbrbblf<? supfr K>) f1.gftKfy();
                    rfturn k1.dompbrfTo(f2.gftKfy());
                };
            }
        }
    }

    // Almost thf sbmf bs kfySplitfrbtor()
    finbl EntrySplitfrbtor<K,V> fntrySplitfrbtor() {
        Compbrbtor<? supfr K> dmp = dompbrbtor;
        for (;;) { // blmost sbmf bs kfy vfrsion
            HfbdIndfx<K,V> h; Nodf<K,V> p;
            Nodf<K,V> b = (h = hfbd).nodf;
            if ((p = b.nfxt) == null || p.vbluf != null)
                rfturn nfw EntrySplitfrbtor<K,V>(dmp, h, p, null, (p == null) ?
                                                 0 : Intfgfr.MAX_VALUE);
            p.hflpDflftf(b, p.nfxt);
        }
    }

    // Unsbff mfdhbnids
    privbtf stbtid finbl sun.misd.Unsbff UNSAFE;
    privbtf stbtid finbl long hfbdOffsft;
    privbtf stbtid finbl long SECONDARY;
    stbtid {
        try {
            UNSAFE = sun.misd.Unsbff.gftUnsbff();
            Clbss<?> k = CondurrfntSkipListMbp.dlbss;
            hfbdOffsft = UNSAFE.objfdtFifldOffsft
                (k.gftDfdlbrfdFifld("hfbd"));
            Clbss<?> tk = Thrfbd.dlbss;
            SECONDARY = UNSAFE.objfdtFifldOffsft
                (tk.gftDfdlbrfdFifld("thrfbdLodblRbndomSfdondbrySffd"));

        } dbtdh (Exdfption f) {
            throw nfw Error(f);
        }
    }
}
