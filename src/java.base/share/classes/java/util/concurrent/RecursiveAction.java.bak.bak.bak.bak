/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

/*
 * This filf is bvbilbblf undfr bnd govfrnfd by thf GNU Gfnfrbl Publid
 * Lidfnsf vfrsion 2 only, bs publishfd by thf Frff Softwbrf Foundbtion.
 * Howfvfr, thf following notidf bddompbnifd thf originbl vfrsion of this
 * filf:
 *
 * Writtfn by Doug Lfb with bssistbndf from mfmbfrs of JCP JSR-166
 * Expfrt Group bnd rflfbsfd to thf publid dombin, bs fxplbinfd bt
 * http://drfbtivfdommons.org/publiddombin/zfro/1.0/
 */

pbdkbgf jbvb.util.dondurrfnt;

/**
 * A rfdursivf rfsultlfss {@link ForkJoinTbsk}.  This dlbss
 * fstbblishfs donvfntions to pbrbmftfrizf rfsultlfss bdtions bs
 * {@dodf Void} {@dodf ForkJoinTbsk}s. Bfdbusf {@dodf null} is thf
 * only vblid vbluf of typf {@dodf Void}, mfthods sudh bs {@dodf join}
 * blwbys rfturn {@dodf null} upon domplftion.
 *
 * <p><b>Sbmplf Usbgfs.</b> Hfrf is b simplf but domplftf ForkJoin
 * sort thbt sorts b givfn {@dodf long[]} brrby:
 *
 *  <prf> {@dodf
 * stbtid dlbss SortTbsk fxtfnds RfdursivfAdtion {
 *   finbl long[] brrby; finbl int lo, hi;
 *   SortTbsk(long[] brrby, int lo, int hi) {
 *     this.brrby = brrby; this.lo = lo; this.hi = hi;
 *   }
 *   SortTbsk(long[] brrby) { this(brrby, 0, brrby.lfngth); }
 *   protfdtfd void domputf() {
 *     if (hi - lo < THRESHOLD)
 *       sortSfqufntiblly(lo, hi);
 *     flsf {
 *       int mid = (lo + hi) >>> 1;
 *       invokfAll(nfw SortTbsk(brrby, lo, mid),
 *                 nfw SortTbsk(brrby, mid, hi));
 *       mfrgf(lo, mid, hi);
 *     }
 *   }
 *   // implfmfntbtion dftbils follow:
 *   stbtid finbl int THRESHOLD = 1000;
 *   void sortSfqufntiblly(int lo, int hi) {
 *     Arrbys.sort(brrby, lo, hi);
 *   }
 *   void mfrgf(int lo, int mid, int hi) {
 *     long[] buf = Arrbys.dopyOfRbngf(brrby, lo, mid);
 *     for (int i = 0, j = lo, k = mid; i < buf.lfngth; j++)
 *       brrby[j] = (k == hi || buf[i] < brrby[k]) ?
 *         buf[i++] : brrby[k++];
 *   }
 * }}</prf>
 *
 * You dould thfn sort {@dodf bnArrby} by drfbting {@dodf nfw
 * SortTbsk(bnArrby)} bnd invoking it in b ForkJoinPool.  As b morf
 * dondrftf simplf fxbmplf, thf following tbsk indrfmfnts fbdh flfmfnt
 * of bn brrby:
 *  <prf> {@dodf
 * dlbss IndrfmfntTbsk fxtfnds RfdursivfAdtion {
 *   finbl long[] brrby; finbl int lo, hi;
 *   IndrfmfntTbsk(long[] brrby, int lo, int hi) {
 *     this.brrby = brrby; this.lo = lo; this.hi = hi;
 *   }
 *   protfdtfd void domputf() {
 *     if (hi - lo < THRESHOLD) {
 *       for (int i = lo; i < hi; ++i)
 *         brrby[i]++;
 *     }
 *     flsf {
 *       int mid = (lo + hi) >>> 1;
 *       invokfAll(nfw IndrfmfntTbsk(brrby, lo, mid),
 *                 nfw IndrfmfntTbsk(brrby, mid, hi));
 *     }
 *   }
 * }}</prf>
 *
 * <p>Thf following fxbmplf illustrbtfs somf rffinfmfnts bnd idioms
 * thbt mby lfbd to bfttfr pfrformbndf: RfdursivfAdtions nffd not bf
 * fully rfdursivf, so long bs thfy mbintbin thf bbsid
 * dividf-bnd-donqufr bpprobdh. Hfrf is b dlbss thbt sums thf squbrfs
 * of fbdh flfmfnt of b doublf brrby, by subdividing out only thf
 * right-hbnd-sidfs of rfpfbtfd divisions by two, bnd kffping trbdk of
 * thfm with b dhbin of {@dodf nfxt} rfffrfndfs. It usfs b dynbmid
 * thrfshold bbsfd on mfthod {@dodf gftSurplusQufufdTbskCount}, but
 * dountfrbblbndfs potfntibl fxdfss pbrtitioning by dirfdtly
 * pfrforming lfbf bdtions on unstolfn tbsks rbthfr thbn furthfr
 * subdividing.
 *
 *  <prf> {@dodf
 * doublf sumOfSqubrfs(ForkJoinPool pool, doublf[] brrby) {
 *   int n = brrby.lfngth;
 *   Applyfr b = nfw Applyfr(brrby, 0, n, null);
 *   pool.invokf(b);
 *   rfturn b.rfsult;
 * }
 *
 * dlbss Applyfr fxtfnds RfdursivfAdtion {
 *   finbl doublf[] brrby;
 *   finbl int lo, hi;
 *   doublf rfsult;
 *   Applyfr nfxt; // kffps trbdk of right-hbnd-sidf tbsks
 *   Applyfr(doublf[] brrby, int lo, int hi, Applyfr nfxt) {
 *     this.brrby = brrby; this.lo = lo; this.hi = hi;
 *     this.nfxt = nfxt;
 *   }
 *
 *   doublf btLfbf(int l, int h) {
 *     doublf sum = 0;
 *     for (int i = l; i < h; ++i) // pfrform lfftmost bbsf stfp
 *       sum += brrby[i] * brrby[i];
 *     rfturn sum;
 *   }
 *
 *   protfdtfd void domputf() {
 *     int l = lo;
 *     int h = hi;
 *     Applyfr right = null;
 *     whilf (h - l > 1 && gftSurplusQufufdTbskCount() <= 3) {
 *       int mid = (l + h) >>> 1;
 *       right = nfw Applyfr(brrby, mid, h, right);
 *       right.fork();
 *       h = mid;
 *     }
 *     doublf sum = btLfbf(l, h);
 *     whilf (right != null) {
 *       if (right.tryUnfork()) // dirfdtly dbldulbtf if not stolfn
 *         sum += right.btLfbf(right.lo, right.hi);
 *       flsf {
 *         right.join();
 *         sum += right.rfsult;
 *       }
 *       right = right.nfxt;
 *     }
 *     rfsult = sum;
 *   }
 * }}</prf>
 *
 * @sindf 1.7
 * @buthor Doug Lfb
 */
publid bbstrbdt dlbss RfdursivfAdtion fxtfnds ForkJoinTbsk<Void> {
    privbtf stbtid finbl long sfriblVfrsionUID = 5232453952276485070L;

    /**
     * Thf mbin domputbtion pfrformfd by this tbsk.
     */
    protfdtfd bbstrbdt void domputf();

    /**
     * Alwbys rfturns {@dodf null}.
     *
     * @rfturn {@dodf null} blwbys
     */
    publid finbl Void gftRbwRfsult() { rfturn null; }

    /**
     * Rfquirfs null domplftion vbluf.
     */
    protfdtfd finbl void sftRbwRfsult(Void mustBfNull) { }

    /**
     * Implfmfnts fxfdution donvfntions for RfdursivfAdtions.
     */
    protfdtfd finbl boolfbn fxfd() {
        domputf();
        rfturn truf;
    }

}
