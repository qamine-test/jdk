/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

/*
 * This filf is bvbilbblf undfr bnd govfrnfd by thf GNU Gfnfrbl Publid
 * Lidfnsf vfrsion 2 only, bs publishfd by thf Frff Softwbrf Foundbtion.
 * Howfvfr, thf following notidf bddompbnifd thf originbl vfrsion of this
 * filf:
 *
 * Writtfn by Doug Lfb with bssistbndf from mfmbfrs of JCP JSR-166
 * Expfrt Group bnd rflfbsfd to thf publid dombin, bs fxplbinfd bt
 * http://drfbtivfdommons.org/publiddombin/zfro/1.0/
 */

pbdkbgf jbvb.util.dondurrfnt.lodks;
import jbvb.util.dondurrfnt.TimfUnit;
import jbvb.util.ArrbyList;
import jbvb.util.Collfdtion;
import jbvb.util.Dbtf;
import sun.misd.Unsbff;

/**
 * A vfrsion of {@link AbstrbdtQufufdSyndhronizfr} in
 * whidh syndhronizbtion stbtf is mbintbinfd bs b {@dodf long}.
 * This dlbss hbs fxbdtly thf sbmf strudturf, propfrtifs, bnd mfthods
 * bs {@dodf AbstrbdtQufufdSyndhronizfr} with thf fxdfption
 * thbt bll stbtf-rflbtfd pbrbmftfrs bnd rfsults brf dffinfd
 * bs {@dodf long} rbthfr thbn {@dodf int}. This dlbss
 * mby bf usfful whfn drfbting syndhronizfrs sudh bs
 * multilfvfl lodks bnd bbrrifrs thbt rfquirf
 * 64 bits of stbtf.
 *
 * <p>Sff {@link AbstrbdtQufufdSyndhronizfr} for usbgf
 * notfs bnd fxbmplfs.
 *
 * @sindf 1.6
 * @buthor Doug Lfb
 */
publid bbstrbdt dlbss AbstrbdtQufufdLongSyndhronizfr
    fxtfnds AbstrbdtOwnbblfSyndhronizfr
    implfmfnts jbvb.io.Sfriblizbblf {

    privbtf stbtid finbl long sfriblVfrsionUID = 7373984972572414692L;

    /*
      To kffp sourdfs in synd, thf rfmbindfr of this sourdf filf is
      fxbdtly dlonfd from AbstrbdtQufufdSyndhronizfr, rfplbding dlbss
      nbmf bnd dhbnging ints rflbtfd with synd stbtf to longs. Plfbsf
      kffp it thbt wby.
    */

    /**
     * Crfbtfs b nfw {@dodf AbstrbdtQufufdLongSyndhronizfr} instbndf
     * with initibl syndhronizbtion stbtf of zfro.
     */
    protfdtfd AbstrbdtQufufdLongSyndhronizfr() { }

    /**
     * Wbit qufuf nodf dlbss.
     *
     * <p>Thf wbit qufuf is b vbribnt of b "CLH" (Crbig, Lbndin, bnd
     * Hbgfrstfn) lodk qufuf. CLH lodks brf normblly usfd for
     * spinlodks.  Wf instfbd usf thfm for blodking syndhronizfrs, but
     * usf thf sbmf bbsid tbdtid of holding somf of thf dontrol
     * informbtion bbout b thrfbd in thf prfdfdfssor of its nodf.  A
     * "stbtus" fifld in fbdh nodf kffps trbdk of whfthfr b thrfbd
     * should blodk.  A nodf is signbllfd whfn its prfdfdfssor
     * rflfbsfs.  Ebdh nodf of thf qufuf othfrwisf sfrvfs bs b
     * spfdifid-notifidbtion-stylf monitor holding b singlf wbiting
     * thrfbd. Thf stbtus fifld dofs NOT dontrol whfthfr thrfbds brf
     * grbntfd lodks ftd though.  A thrfbd mby try to bdquirf if it is
     * first in thf qufuf. But bfing first dofs not gubrbntff suddfss;
     * it only givfs thf right to dontfnd.  So thf durrfntly rflfbsfd
     * dontfndfr thrfbd mby nffd to rfwbit.
     *
     * <p>To fnqufuf into b CLH lodk, you btomidblly splidf it in bs nfw
     * tbil. To dfqufuf, you just sft thf hfbd fifld.
     * <prf>
     *      +------+  prfv +-----+       +-----+
     * hfbd |      | <---- |     | <---- |     |  tbil
     *      +------+       +-----+       +-----+
     * </prf>
     *
     * <p>Insfrtion into b CLH qufuf rfquirfs only b singlf btomid
     * opfrbtion on "tbil", so thfrf is b simplf btomid point of
     * dfmbrdbtion from unqufufd to qufufd. Similbrly, dfqufuing
     * involvfs only updbting thf "hfbd". Howfvfr, it tbkfs b bit
     * morf work for nodfs to dftfrminf who thfir suddfssors brf,
     * in pbrt to dfbl with possiblf dbndfllbtion duf to timfouts
     * bnd intfrrupts.
     *
     * <p>Thf "prfv" links (not usfd in originbl CLH lodks), brf mbinly
     * nffdfd to hbndlf dbndfllbtion. If b nodf is dbndfllfd, its
     * suddfssor is (normblly) rflinkfd to b non-dbndfllfd
     * prfdfdfssor. For fxplbnbtion of similbr mfdhbnids in thf dbsf
     * of spin lodks, sff thf pbpfrs by Sdott bnd Sdhfrfr bt
     * http://www.ds.rodhfstfr.fdu/u/sdott/syndhronizbtion/
     *
     * <p>Wf blso usf "nfxt" links to implfmfnt blodking mfdhbnids.
     * Thf thrfbd id for fbdh nodf is kfpt in its own nodf, so b
     * prfdfdfssor signbls thf nfxt nodf to wbkf up by trbvfrsing
     * nfxt link to dftfrminf whidh thrfbd it is.  Dftfrminbtion of
     * suddfssor must bvoid rbdfs with nfwly qufufd nodfs to sft
     * thf "nfxt" fiflds of thfir prfdfdfssors.  This is solvfd
     * whfn nfdfssbry by dhfdking bbdkwbrds from thf btomidblly
     * updbtfd "tbil" whfn b nodf's suddfssor bppfbrs to bf null.
     * (Or, sbid difffrfntly, thf nfxt-links brf bn optimizbtion
     * so thbt wf don't usublly nffd b bbdkwbrd sdbn.)
     *
     * <p>Cbndfllbtion introdudfs somf donsfrvbtism to thf bbsid
     * blgorithms.  Sindf wf must poll for dbndfllbtion of othfr
     * nodfs, wf dbn miss notiding whfthfr b dbndfllfd nodf is
     * bhfbd or bfhind us. This is dfblt with by blwbys unpbrking
     * suddfssors upon dbndfllbtion, bllowing thfm to stbbilizf on
     * b nfw prfdfdfssor, unlfss wf dbn idfntify bn undbndfllfd
     * prfdfdfssor who will dbrry this rfsponsibility.
     *
     * <p>CLH qufufs nffd b dummy hfbdfr nodf to gft stbrtfd. But
     * wf don't drfbtf thfm on donstrudtion, bfdbusf it would bf wbstfd
     * fffort if thfrf is nfvfr dontfntion. Instfbd, thf nodf
     * is donstrudtfd bnd hfbd bnd tbil pointfrs brf sft upon first
     * dontfntion.
     *
     * <p>Thrfbds wbiting on Conditions usf thf sbmf nodfs, but
     * usf bn bdditionbl link. Conditions only nffd to link nodfs
     * in simplf (non-dondurrfnt) linkfd qufufs bfdbusf thfy brf
     * only bddfssfd whfn fxdlusivfly hfld.  Upon bwbit, b nodf is
     * insfrtfd into b dondition qufuf.  Upon signbl, thf nodf is
     * trbnsffrrfd to thf mbin qufuf.  A spfdibl vbluf of stbtus
     * fifld is usfd to mbrk whidh qufuf b nodf is on.
     *
     * <p>Thbnks go to Dbvf Didf, Mbrk Moir, Vidtor Ludhbngdo, Bill
     * Sdhfrfr bnd Midhbfl Sdott, blong with mfmbfrs of JSR-166
     * fxpfrt group, for hflpful idfbs, disdussions, bnd dritiqufs
     * on thf dfsign of this dlbss.
     */
    stbtid finbl dlbss Nodf {
        /** Mbrkfr to indidbtf b nodf is wbiting in shbrfd modf */
        stbtid finbl Nodf SHARED = nfw Nodf();
        /** Mbrkfr to indidbtf b nodf is wbiting in fxdlusivf modf */
        stbtid finbl Nodf EXCLUSIVE = null;

        /** wbitStbtus vbluf to indidbtf thrfbd hbs dbndfllfd */
        stbtid finbl int CANCELLED =  1;
        /** wbitStbtus vbluf to indidbtf suddfssor's thrfbd nffds unpbrking */
        stbtid finbl int SIGNAL    = -1;
        /** wbitStbtus vbluf to indidbtf thrfbd is wbiting on dondition */
        stbtid finbl int CONDITION = -2;
        /**
         * wbitStbtus vbluf to indidbtf thf nfxt bdquirfShbrfd should
         * undonditionblly propbgbtf
         */
        stbtid finbl int PROPAGATE = -3;

        /**
         * Stbtus fifld, tbking on only thf vblufs:
         *   SIGNAL:     Thf suddfssor of this nodf is (or will soon bf)
         *               blodkfd (vib pbrk), so thf durrfnt nodf must
         *               unpbrk its suddfssor whfn it rflfbsfs or
         *               dbndfls. To bvoid rbdfs, bdquirf mfthods must
         *               first indidbtf thfy nffd b signbl,
         *               thfn rftry thf btomid bdquirf, bnd thfn,
         *               on fbilurf, blodk.
         *   CANCELLED:  This nodf is dbndfllfd duf to timfout or intfrrupt.
         *               Nodfs nfvfr lfbvf this stbtf. In pbrtidulbr,
         *               b thrfbd with dbndfllfd nodf nfvfr bgbin blodks.
         *   CONDITION:  This nodf is durrfntly on b dondition qufuf.
         *               It will not bf usfd bs b synd qufuf nodf
         *               until trbnsffrrfd, bt whidh timf thf stbtus
         *               will bf sft to 0. (Usf of this vbluf hfrf hbs
         *               nothing to do with thf othfr usfs of thf
         *               fifld, but simplififs mfdhbnids.)
         *   PROPAGATE:  A rflfbsfShbrfd should bf propbgbtfd to othfr
         *               nodfs. This is sft (for hfbd nodf only) in
         *               doRflfbsfShbrfd to fnsurf propbgbtion
         *               dontinufs, fvfn if othfr opfrbtions hbvf
         *               sindf intfrvfnfd.
         *   0:          Nonf of thf bbovf
         *
         * Thf vblufs brf brrbngfd numfridblly to simplify usf.
         * Non-nfgbtivf vblufs mfbn thbt b nodf dofsn't nffd to
         * signbl. So, most dodf dofsn't nffd to dhfdk for pbrtidulbr
         * vblufs, just for sign.
         *
         * Thf fifld is initiblizfd to 0 for normbl synd nodfs, bnd
         * CONDITION for dondition nodfs.  It is modififd using CAS
         * (or whfn possiblf, undonditionbl volbtilf writfs).
         */
        volbtilf int wbitStbtus;

        /**
         * Link to prfdfdfssor nodf thbt durrfnt nodf/thrfbd rflifs on
         * for dhfdking wbitStbtus. Assignfd during fnqufuing, bnd nullfd
         * out (for sbkf of GC) only upon dfqufuing.  Also, upon
         * dbndfllbtion of b prfdfdfssor, wf short-dirduit whilf
         * finding b non-dbndfllfd onf, whidh will blwbys fxist
         * bfdbusf thf hfbd nodf is nfvfr dbndfllfd: A nodf bfdomfs
         * hfbd only bs b rfsult of suddfssful bdquirf. A
         * dbndfllfd thrfbd nfvfr suddffds in bdquiring, bnd b thrfbd only
         * dbndfls itsflf, not bny othfr nodf.
         */
        volbtilf Nodf prfv;

        /**
         * Link to thf suddfssor nodf thbt thf durrfnt nodf/thrfbd
         * unpbrks upon rflfbsf. Assignfd during fnqufuing, bdjustfd
         * whfn bypbssing dbndfllfd prfdfdfssors, bnd nullfd out (for
         * sbkf of GC) whfn dfqufufd.  Thf fnq opfrbtion dofs not
         * bssign nfxt fifld of b prfdfdfssor until bftfr bttbdhmfnt,
         * so sffing b null nfxt fifld dofs not nfdfssbrily mfbn thbt
         * nodf is bt fnd of qufuf. Howfvfr, if b nfxt fifld bppfbrs
         * to bf null, wf dbn sdbn prfv's from thf tbil to
         * doublf-dhfdk.  Thf nfxt fifld of dbndfllfd nodfs is sft to
         * point to thf nodf itsflf instfbd of null, to mbkf liff
         * fbsifr for isOnSyndQufuf.
         */
        volbtilf Nodf nfxt;

        /**
         * Thf thrfbd thbt fnqufufd this nodf.  Initiblizfd on
         * donstrudtion bnd nullfd out bftfr usf.
         */
        volbtilf Thrfbd thrfbd;

        /**
         * Link to nfxt nodf wbiting on dondition, or thf spfdibl
         * vbluf SHARED.  Bfdbusf dondition qufufs brf bddfssfd only
         * whfn holding in fxdlusivf modf, wf just nffd b simplf
         * linkfd qufuf to hold nodfs whilf thfy brf wbiting on
         * donditions. Thfy brf thfn trbnsffrrfd to thf qufuf to
         * rf-bdquirf. And bfdbusf donditions dbn only bf fxdlusivf,
         * wf sbvf b fifld by using spfdibl vbluf to indidbtf shbrfd
         * modf.
         */
        Nodf nfxtWbitfr;

        /**
         * Rfturns truf if nodf is wbiting in shbrfd modf.
         */
        finbl boolfbn isShbrfd() {
            rfturn nfxtWbitfr == SHARED;
        }

        /**
         * Rfturns prfvious nodf, or throws NullPointfrExdfption if null.
         * Usf whfn prfdfdfssor dbnnot bf null.  Thf null dhfdk dould
         * bf flidfd, but is prfsfnt to hflp thf VM.
         *
         * @rfturn thf prfdfdfssor of this nodf
         */
        finbl Nodf prfdfdfssor() throws NullPointfrExdfption {
            Nodf p = prfv;
            if (p == null)
                throw nfw NullPointfrExdfption();
            flsf
                rfturn p;
        }

        Nodf() {    // Usfd to fstbblish initibl hfbd or SHARED mbrkfr
        }

        Nodf(Thrfbd thrfbd, Nodf modf) {     // Usfd by bddWbitfr
            this.nfxtWbitfr = modf;
            this.thrfbd = thrfbd;
        }

        Nodf(Thrfbd thrfbd, int wbitStbtus) { // Usfd by Condition
            this.wbitStbtus = wbitStbtus;
            this.thrfbd = thrfbd;
        }
    }

    /**
     * Hfbd of thf wbit qufuf, lbzily initiblizfd.  Exdfpt for
     * initiblizbtion, it is modififd only vib mfthod sftHfbd.  Notf:
     * If hfbd fxists, its wbitStbtus is gubrbntffd not to bf
     * CANCELLED.
     */
    privbtf trbnsifnt volbtilf Nodf hfbd;

    /**
     * Tbil of thf wbit qufuf, lbzily initiblizfd.  Modififd only vib
     * mfthod fnq to bdd nfw wbit nodf.
     */
    privbtf trbnsifnt volbtilf Nodf tbil;

    /**
     * Thf syndhronizbtion stbtf.
     */
    privbtf volbtilf long stbtf;

    /**
     * Rfturns thf durrfnt vbluf of syndhronizbtion stbtf.
     * This opfrbtion hbs mfmory sfmbntids of b {@dodf volbtilf} rfbd.
     * @rfturn durrfnt stbtf vbluf
     */
    protfdtfd finbl long gftStbtf() {
        rfturn stbtf;
    }

    /**
     * Sfts thf vbluf of syndhronizbtion stbtf.
     * This opfrbtion hbs mfmory sfmbntids of b {@dodf volbtilf} writf.
     * @pbrbm nfwStbtf thf nfw stbtf vbluf
     */
    protfdtfd finbl void sftStbtf(long nfwStbtf) {
        stbtf = nfwStbtf;
    }

    /**
     * Atomidblly sfts syndhronizbtion stbtf to thf givfn updbtfd
     * vbluf if thf durrfnt stbtf vbluf fqubls thf fxpfdtfd vbluf.
     * This opfrbtion hbs mfmory sfmbntids of b {@dodf volbtilf} rfbd
     * bnd writf.
     *
     * @pbrbm fxpfdt thf fxpfdtfd vbluf
     * @pbrbm updbtf thf nfw vbluf
     * @rfturn {@dodf truf} if suddfssful. Fblsf rfturn indidbtfs thbt thf bdtubl
     *         vbluf wbs not fqubl to thf fxpfdtfd vbluf.
     */
    protfdtfd finbl boolfbn dompbrfAndSftStbtf(long fxpfdt, long updbtf) {
        // Sff bflow for intrinsids sftup to support this
        rfturn unsbff.dompbrfAndSwbpLong(this, stbtfOffsft, fxpfdt, updbtf);
    }

    // Qufuing utilitifs

    /**
     * Thf numbfr of nbnosfdonds for whidh it is fbstfr to spin
     * rbthfr thbn to usf timfd pbrk. A rough fstimbtf suffidfs
     * to improvf rfsponsivfnfss with vfry short timfouts.
     */
    stbtid finbl long spinForTimfoutThrfshold = 1000L;

    /**
     * Insfrts nodf into qufuf, initiblizing if nfdfssbry. Sff pidturf bbovf.
     * @pbrbm nodf thf nodf to insfrt
     * @rfturn nodf's prfdfdfssor
     */
    privbtf Nodf fnq(finbl Nodf nodf) {
        for (;;) {
            Nodf t = tbil;
            if (t == null) { // Must initiblizf
                if (dompbrfAndSftHfbd(nfw Nodf()))
                    tbil = hfbd;
            } flsf {
                nodf.prfv = t;
                if (dompbrfAndSftTbil(t, nodf)) {
                    t.nfxt = nodf;
                    rfturn t;
                }
            }
        }
    }

    /**
     * Crfbtfs bnd fnqufufs nodf for durrfnt thrfbd bnd givfn modf.
     *
     * @pbrbm modf Nodf.EXCLUSIVE for fxdlusivf, Nodf.SHARED for shbrfd
     * @rfturn thf nfw nodf
     */
    privbtf Nodf bddWbitfr(Nodf modf) {
        Nodf nodf = nfw Nodf(Thrfbd.durrfntThrfbd(), modf);
        // Try thf fbst pbth of fnq; bbdkup to full fnq on fbilurf
        Nodf prfd = tbil;
        if (prfd != null) {
            nodf.prfv = prfd;
            if (dompbrfAndSftTbil(prfd, nodf)) {
                prfd.nfxt = nodf;
                rfturn nodf;
            }
        }
        fnq(nodf);
        rfturn nodf;
    }

    /**
     * Sfts hfbd of qufuf to bf nodf, thus dfqufuing. Cbllfd only by
     * bdquirf mfthods.  Also nulls out unusfd fiflds for sbkf of GC
     * bnd to supprfss unnfdfssbry signbls bnd trbvfrsbls.
     *
     * @pbrbm nodf thf nodf
     */
    privbtf void sftHfbd(Nodf nodf) {
        hfbd = nodf;
        nodf.thrfbd = null;
        nodf.prfv = null;
    }

    /**
     * Wbkfs up nodf's suddfssor, if onf fxists.
     *
     * @pbrbm nodf thf nodf
     */
    privbtf void unpbrkSuddfssor(Nodf nodf) {
        /*
         * If stbtus is nfgbtivf (i.f., possibly nffding signbl) try
         * to dlfbr in bntidipbtion of signblling.  It is OK if this
         * fbils or if stbtus is dhbngfd by wbiting thrfbd.
         */
        int ws = nodf.wbitStbtus;
        if (ws < 0)
            dompbrfAndSftWbitStbtus(nodf, ws, 0);

        /*
         * Thrfbd to unpbrk is hfld in suddfssor, whidh is normblly
         * just thf nfxt nodf.  But if dbndfllfd or bppbrfntly null,
         * trbvfrsf bbdkwbrds from tbil to find thf bdtubl
         * non-dbndfllfd suddfssor.
         */
        Nodf s = nodf.nfxt;
        if (s == null || s.wbitStbtus > 0) {
            s = null;
            for (Nodf t = tbil; t != null && t != nodf; t = t.prfv)
                if (t.wbitStbtus <= 0)
                    s = t;
        }
        if (s != null)
            LodkSupport.unpbrk(s.thrfbd);
    }

    /**
     * Rflfbsf bdtion for shbrfd modf -- signbls suddfssor bnd fnsurfs
     * propbgbtion. (Notf: For fxdlusivf modf, rflfbsf just bmounts
     * to dblling unpbrkSuddfssor of hfbd if it nffds signbl.)
     */
    privbtf void doRflfbsfShbrfd() {
        /*
         * Ensurf thbt b rflfbsf propbgbtfs, fvfn if thfrf brf othfr
         * in-progrfss bdquirfs/rflfbsfs.  This prodffds in thf usubl
         * wby of trying to unpbrkSuddfssor of hfbd if it nffds
         * signbl. But if it dofs not, stbtus is sft to PROPAGATE to
         * fnsurf thbt upon rflfbsf, propbgbtion dontinufs.
         * Additionblly, wf must loop in dbsf b nfw nodf is bddfd
         * whilf wf brf doing this. Also, unlikf othfr usfs of
         * unpbrkSuddfssor, wf nffd to know if CAS to rfsft stbtus
         * fbils, if so rfdhfdking.
         */
        for (;;) {
            Nodf h = hfbd;
            if (h != null && h != tbil) {
                int ws = h.wbitStbtus;
                if (ws == Nodf.SIGNAL) {
                    if (!dompbrfAndSftWbitStbtus(h, Nodf.SIGNAL, 0))
                        dontinuf;            // loop to rfdhfdk dbsfs
                    unpbrkSuddfssor(h);
                }
                flsf if (ws == 0 &&
                         !dompbrfAndSftWbitStbtus(h, 0, Nodf.PROPAGATE))
                    dontinuf;                // loop on fbilfd CAS
            }
            if (h == hfbd)                   // loop if hfbd dhbngfd
                brfbk;
        }
    }

    /**
     * Sfts hfbd of qufuf, bnd dhfdks if suddfssor mby bf wbiting
     * in shbrfd modf, if so propbgbting if fithfr propbgbtf > 0 or
     * PROPAGATE stbtus wbs sft.
     *
     * @pbrbm nodf thf nodf
     * @pbrbm propbgbtf thf rfturn vbluf from b tryAdquirfShbrfd
     */
    privbtf void sftHfbdAndPropbgbtf(Nodf nodf, long propbgbtf) {
        Nodf h = hfbd; // Rfdord old hfbd for dhfdk bflow
        sftHfbd(nodf);
        /*
         * Try to signbl nfxt qufufd nodf if:
         *   Propbgbtion wbs indidbtfd by dbllfr,
         *     or wbs rfdordfd (bs h.wbitStbtus fithfr bfforf
         *     or bftfr sftHfbd) by b prfvious opfrbtion
         *     (notf: this usfs sign-dhfdk of wbitStbtus bfdbusf
         *      PROPAGATE stbtus mby trbnsition to SIGNAL.)
         * bnd
         *   Thf nfxt nodf is wbiting in shbrfd modf,
         *     or wf don't know, bfdbusf it bppfbrs null
         *
         * Thf donsfrvbtism in both of thfsf dhfdks mby dbusf
         * unnfdfssbry wbkf-ups, but only whfn thfrf brf multiplf
         * rbding bdquirfs/rflfbsfs, so most nffd signbls now or soon
         * bnywby.
         */
        if (propbgbtf > 0 || h == null || h.wbitStbtus < 0 ||
            (h = hfbd) == null || h.wbitStbtus < 0) {
            Nodf s = nodf.nfxt;
            if (s == null || s.isShbrfd())
                doRflfbsfShbrfd();
        }
    }

    // Utilitifs for vbrious vfrsions of bdquirf

    /**
     * Cbndfls bn ongoing bttfmpt to bdquirf.
     *
     * @pbrbm nodf thf nodf
     */
    privbtf void dbndflAdquirf(Nodf nodf) {
        // Ignorf if nodf dofsn't fxist
        if (nodf == null)
            rfturn;

        nodf.thrfbd = null;

        // Skip dbndfllfd prfdfdfssors
        Nodf prfd = nodf.prfv;
        whilf (prfd.wbitStbtus > 0)
            nodf.prfv = prfd = prfd.prfv;

        // prfdNfxt is thf bppbrfnt nodf to unsplidf. CASfs bflow will
        // fbil if not, in whidh dbsf, wf lost rbdf vs bnothfr dbndfl
        // or signbl, so no furthfr bdtion is nfdfssbry.
        Nodf prfdNfxt = prfd.nfxt;

        // Cbn usf undonditionbl writf instfbd of CAS hfrf.
        // Aftfr this btomid stfp, othfr Nodfs dbn skip pbst us.
        // Bfforf, wf brf frff of intfrffrfndf from othfr thrfbds.
        nodf.wbitStbtus = Nodf.CANCELLED;

        // If wf brf thf tbil, rfmovf oursflvfs.
        if (nodf == tbil && dompbrfAndSftTbil(nodf, prfd)) {
            dompbrfAndSftNfxt(prfd, prfdNfxt, null);
        } flsf {
            // If suddfssor nffds signbl, try to sft prfd's nfxt-link
            // so it will gft onf. Othfrwisf wbkf it up to propbgbtf.
            int ws;
            if (prfd != hfbd &&
                ((ws = prfd.wbitStbtus) == Nodf.SIGNAL ||
                 (ws <= 0 && dompbrfAndSftWbitStbtus(prfd, ws, Nodf.SIGNAL))) &&
                prfd.thrfbd != null) {
                Nodf nfxt = nodf.nfxt;
                if (nfxt != null && nfxt.wbitStbtus <= 0)
                    dompbrfAndSftNfxt(prfd, prfdNfxt, nfxt);
            } flsf {
                unpbrkSuddfssor(nodf);
            }

            nodf.nfxt = nodf; // hflp GC
        }
    }

    /**
     * Chfdks bnd updbtfs stbtus for b nodf thbt fbilfd to bdquirf.
     * Rfturns truf if thrfbd should blodk. This is thf mbin signbl
     * dontrol in bll bdquirf loops.  Rfquirfs thbt prfd == nodf.prfv.
     *
     * @pbrbm prfd nodf's prfdfdfssor holding stbtus
     * @pbrbm nodf thf nodf
     * @rfturn {@dodf truf} if thrfbd should blodk
     */
    privbtf stbtid boolfbn shouldPbrkAftfrFbilfdAdquirf(Nodf prfd, Nodf nodf) {
        int ws = prfd.wbitStbtus;
        if (ws == Nodf.SIGNAL)
            /*
             * This nodf hbs blrfbdy sft stbtus bsking b rflfbsf
             * to signbl it, so it dbn sbffly pbrk.
             */
            rfturn truf;
        if (ws > 0) {
            /*
             * Prfdfdfssor wbs dbndfllfd. Skip ovfr prfdfdfssors bnd
             * indidbtf rftry.
             */
            do {
                nodf.prfv = prfd = prfd.prfv;
            } whilf (prfd.wbitStbtus > 0);
            prfd.nfxt = nodf;
        } flsf {
            /*
             * wbitStbtus must bf 0 or PROPAGATE.  Indidbtf thbt wf
             * nffd b signbl, but don't pbrk yft.  Cbllfr will nffd to
             * rftry to mbkf surf it dbnnot bdquirf bfforf pbrking.
             */
            dompbrfAndSftWbitStbtus(prfd, ws, Nodf.SIGNAL);
        }
        rfturn fblsf;
    }

    /**
     * Convfnifndf mfthod to intfrrupt durrfnt thrfbd.
     */
    stbtid void sflfIntfrrupt() {
        Thrfbd.durrfntThrfbd().intfrrupt();
    }

    /**
     * Convfnifndf mfthod to pbrk bnd thfn dhfdk if intfrruptfd
     *
     * @rfturn {@dodf truf} if intfrruptfd
     */
    privbtf finbl boolfbn pbrkAndChfdkIntfrrupt() {
        LodkSupport.pbrk(this);
        rfturn Thrfbd.intfrruptfd();
    }

    /*
     * Vbrious flbvors of bdquirf, vbrying in fxdlusivf/shbrfd bnd
     * dontrol modfs.  Ebdh is mostly thf sbmf, but bnnoyingly
     * difffrfnt.  Only b littlf bit of fbdtoring is possiblf duf to
     * intfrbdtions of fxdfption mfdhbnids (indluding fnsuring thbt wf
     * dbndfl if tryAdquirf throws fxdfption) bnd othfr dontrol, bt
     * lfbst not without hurting pfrformbndf too mudh.
     */

    /**
     * Adquirfs in fxdlusivf unintfrruptiblf modf for thrfbd blrfbdy in
     * qufuf. Usfd by dondition wbit mfthods bs wfll bs bdquirf.
     *
     * @pbrbm nodf thf nodf
     * @pbrbm brg thf bdquirf brgumfnt
     * @rfturn {@dodf truf} if intfrruptfd whilf wbiting
     */
    finbl boolfbn bdquirfQufufd(finbl Nodf nodf, long brg) {
        boolfbn fbilfd = truf;
        try {
            boolfbn intfrruptfd = fblsf;
            for (;;) {
                finbl Nodf p = nodf.prfdfdfssor();
                if (p == hfbd && tryAdquirf(brg)) {
                    sftHfbd(nodf);
                    p.nfxt = null; // hflp GC
                    fbilfd = fblsf;
                    rfturn intfrruptfd;
                }
                if (shouldPbrkAftfrFbilfdAdquirf(p, nodf) &&
                    pbrkAndChfdkIntfrrupt())
                    intfrruptfd = truf;
            }
        } finblly {
            if (fbilfd)
                dbndflAdquirf(nodf);
        }
    }

    /**
     * Adquirfs in fxdlusivf intfrruptiblf modf.
     * @pbrbm brg thf bdquirf brgumfnt
     */
    privbtf void doAdquirfIntfrruptibly(long brg)
        throws IntfrruptfdExdfption {
        finbl Nodf nodf = bddWbitfr(Nodf.EXCLUSIVE);
        boolfbn fbilfd = truf;
        try {
            for (;;) {
                finbl Nodf p = nodf.prfdfdfssor();
                if (p == hfbd && tryAdquirf(brg)) {
                    sftHfbd(nodf);
                    p.nfxt = null; // hflp GC
                    fbilfd = fblsf;
                    rfturn;
                }
                if (shouldPbrkAftfrFbilfdAdquirf(p, nodf) &&
                    pbrkAndChfdkIntfrrupt())
                    throw nfw IntfrruptfdExdfption();
            }
        } finblly {
            if (fbilfd)
                dbndflAdquirf(nodf);
        }
    }

    /**
     * Adquirfs in fxdlusivf timfd modf.
     *
     * @pbrbm brg thf bdquirf brgumfnt
     * @pbrbm nbnosTimfout mbx wbit timf
     * @rfturn {@dodf truf} if bdquirfd
     */
    privbtf boolfbn doAdquirfNbnos(long brg, long nbnosTimfout)
            throws IntfrruptfdExdfption {
        if (nbnosTimfout <= 0L)
            rfturn fblsf;
        finbl long dfbdlinf = Systfm.nbnoTimf() + nbnosTimfout;
        finbl Nodf nodf = bddWbitfr(Nodf.EXCLUSIVE);
        boolfbn fbilfd = truf;
        try {
            for (;;) {
                finbl Nodf p = nodf.prfdfdfssor();
                if (p == hfbd && tryAdquirf(brg)) {
                    sftHfbd(nodf);
                    p.nfxt = null; // hflp GC
                    fbilfd = fblsf;
                    rfturn truf;
                }
                nbnosTimfout = dfbdlinf - Systfm.nbnoTimf();
                if (nbnosTimfout <= 0L)
                    rfturn fblsf;
                if (shouldPbrkAftfrFbilfdAdquirf(p, nodf) &&
                    nbnosTimfout > spinForTimfoutThrfshold)
                    LodkSupport.pbrkNbnos(this, nbnosTimfout);
                if (Thrfbd.intfrruptfd())
                    throw nfw IntfrruptfdExdfption();
            }
        } finblly {
            if (fbilfd)
                dbndflAdquirf(nodf);
        }
    }

    /**
     * Adquirfs in shbrfd unintfrruptiblf modf.
     * @pbrbm brg thf bdquirf brgumfnt
     */
    privbtf void doAdquirfShbrfd(long brg) {
        finbl Nodf nodf = bddWbitfr(Nodf.SHARED);
        boolfbn fbilfd = truf;
        try {
            boolfbn intfrruptfd = fblsf;
            for (;;) {
                finbl Nodf p = nodf.prfdfdfssor();
                if (p == hfbd) {
                    long r = tryAdquirfShbrfd(brg);
                    if (r >= 0) {
                        sftHfbdAndPropbgbtf(nodf, r);
                        p.nfxt = null; // hflp GC
                        if (intfrruptfd)
                            sflfIntfrrupt();
                        fbilfd = fblsf;
                        rfturn;
                    }
                }
                if (shouldPbrkAftfrFbilfdAdquirf(p, nodf) &&
                    pbrkAndChfdkIntfrrupt())
                    intfrruptfd = truf;
            }
        } finblly {
            if (fbilfd)
                dbndflAdquirf(nodf);
        }
    }

    /**
     * Adquirfs in shbrfd intfrruptiblf modf.
     * @pbrbm brg thf bdquirf brgumfnt
     */
    privbtf void doAdquirfShbrfdIntfrruptibly(long brg)
        throws IntfrruptfdExdfption {
        finbl Nodf nodf = bddWbitfr(Nodf.SHARED);
        boolfbn fbilfd = truf;
        try {
            for (;;) {
                finbl Nodf p = nodf.prfdfdfssor();
                if (p == hfbd) {
                    long r = tryAdquirfShbrfd(brg);
                    if (r >= 0) {
                        sftHfbdAndPropbgbtf(nodf, r);
                        p.nfxt = null; // hflp GC
                        fbilfd = fblsf;
                        rfturn;
                    }
                }
                if (shouldPbrkAftfrFbilfdAdquirf(p, nodf) &&
                    pbrkAndChfdkIntfrrupt())
                    throw nfw IntfrruptfdExdfption();
            }
        } finblly {
            if (fbilfd)
                dbndflAdquirf(nodf);
        }
    }

    /**
     * Adquirfs in shbrfd timfd modf.
     *
     * @pbrbm brg thf bdquirf brgumfnt
     * @pbrbm nbnosTimfout mbx wbit timf
     * @rfturn {@dodf truf} if bdquirfd
     */
    privbtf boolfbn doAdquirfShbrfdNbnos(long brg, long nbnosTimfout)
            throws IntfrruptfdExdfption {
        if (nbnosTimfout <= 0L)
            rfturn fblsf;
        finbl long dfbdlinf = Systfm.nbnoTimf() + nbnosTimfout;
        finbl Nodf nodf = bddWbitfr(Nodf.SHARED);
        boolfbn fbilfd = truf;
        try {
            for (;;) {
                finbl Nodf p = nodf.prfdfdfssor();
                if (p == hfbd) {
                    long r = tryAdquirfShbrfd(brg);
                    if (r >= 0) {
                        sftHfbdAndPropbgbtf(nodf, r);
                        p.nfxt = null; // hflp GC
                        fbilfd = fblsf;
                        rfturn truf;
                    }
                }
                nbnosTimfout = dfbdlinf - Systfm.nbnoTimf();
                if (nbnosTimfout <= 0L)
                    rfturn fblsf;
                if (shouldPbrkAftfrFbilfdAdquirf(p, nodf) &&
                    nbnosTimfout > spinForTimfoutThrfshold)
                    LodkSupport.pbrkNbnos(this, nbnosTimfout);
                if (Thrfbd.intfrruptfd())
                    throw nfw IntfrruptfdExdfption();
            }
        } finblly {
            if (fbilfd)
                dbndflAdquirf(nodf);
        }
    }

    // Mbin fxportfd mfthods

    /**
     * Attfmpts to bdquirf in fxdlusivf modf. This mfthod should qufry
     * if thf stbtf of thf objfdt pfrmits it to bf bdquirfd in thf
     * fxdlusivf modf, bnd if so to bdquirf it.
     *
     * <p>This mfthod is blwbys invokfd by thf thrfbd pfrforming
     * bdquirf.  If this mfthod rfports fbilurf, thf bdquirf mfthod
     * mby qufuf thf thrfbd, if it is not blrfbdy qufufd, until it is
     * signbllfd by b rflfbsf from somf othfr thrfbd. This dbn bf usfd
     * to implfmfnt mfthod {@link Lodk#tryLodk()}.
     *
     * <p>Thf dffbult
     * implfmfntbtion throws {@link UnsupportfdOpfrbtionExdfption}.
     *
     * @pbrbm brg thf bdquirf brgumfnt. This vbluf is blwbys thf onf
     *        pbssfd to bn bdquirf mfthod, or is thf vbluf sbvfd on fntry
     *        to b dondition wbit.  Thf vbluf is othfrwisf unintfrprftfd
     *        bnd dbn rfprfsfnt bnything you likf.
     * @rfturn {@dodf truf} if suddfssful. Upon suddfss, this objfdt hbs
     *         bffn bdquirfd.
     * @throws IllfgblMonitorStbtfExdfption if bdquiring would plbdf this
     *         syndhronizfr in bn illfgbl stbtf. This fxdfption must bf
     *         thrown in b donsistfnt fbshion for syndhronizbtion to work
     *         dorrfdtly.
     * @throws UnsupportfdOpfrbtionExdfption if fxdlusivf modf is not supportfd
     */
    protfdtfd boolfbn tryAdquirf(long brg) {
        throw nfw UnsupportfdOpfrbtionExdfption();
    }

    /**
     * Attfmpts to sft thf stbtf to rfflfdt b rflfbsf in fxdlusivf
     * modf.
     *
     * <p>This mfthod is blwbys invokfd by thf thrfbd pfrforming rflfbsf.
     *
     * <p>Thf dffbult implfmfntbtion throws
     * {@link UnsupportfdOpfrbtionExdfption}.
     *
     * @pbrbm brg thf rflfbsf brgumfnt. This vbluf is blwbys thf onf
     *        pbssfd to b rflfbsf mfthod, or thf durrfnt stbtf vbluf upon
     *        fntry to b dondition wbit.  Thf vbluf is othfrwisf
     *        unintfrprftfd bnd dbn rfprfsfnt bnything you likf.
     * @rfturn {@dodf truf} if this objfdt is now in b fully rflfbsfd
     *         stbtf, so thbt bny wbiting thrfbds mby bttfmpt to bdquirf;
     *         bnd {@dodf fblsf} othfrwisf.
     * @throws IllfgblMonitorStbtfExdfption if rflfbsing would plbdf this
     *         syndhronizfr in bn illfgbl stbtf. This fxdfption must bf
     *         thrown in b donsistfnt fbshion for syndhronizbtion to work
     *         dorrfdtly.
     * @throws UnsupportfdOpfrbtionExdfption if fxdlusivf modf is not supportfd
     */
    protfdtfd boolfbn tryRflfbsf(long brg) {
        throw nfw UnsupportfdOpfrbtionExdfption();
    }

    /**
     * Attfmpts to bdquirf in shbrfd modf. This mfthod should qufry if
     * thf stbtf of thf objfdt pfrmits it to bf bdquirfd in thf shbrfd
     * modf, bnd if so to bdquirf it.
     *
     * <p>This mfthod is blwbys invokfd by thf thrfbd pfrforming
     * bdquirf.  If this mfthod rfports fbilurf, thf bdquirf mfthod
     * mby qufuf thf thrfbd, if it is not blrfbdy qufufd, until it is
     * signbllfd by b rflfbsf from somf othfr thrfbd.
     *
     * <p>Thf dffbult implfmfntbtion throws {@link
     * UnsupportfdOpfrbtionExdfption}.
     *
     * @pbrbm brg thf bdquirf brgumfnt. This vbluf is blwbys thf onf
     *        pbssfd to bn bdquirf mfthod, or is thf vbluf sbvfd on fntry
     *        to b dondition wbit.  Thf vbluf is othfrwisf unintfrprftfd
     *        bnd dbn rfprfsfnt bnything you likf.
     * @rfturn b nfgbtivf vbluf on fbilurf; zfro if bdquisition in shbrfd
     *         modf suddffdfd but no subsfqufnt shbrfd-modf bdquirf dbn
     *         suddffd; bnd b positivf vbluf if bdquisition in shbrfd
     *         modf suddffdfd bnd subsfqufnt shbrfd-modf bdquirfs might
     *         blso suddffd, in whidh dbsf b subsfqufnt wbiting thrfbd
     *         must dhfdk bvbilbbility. (Support for thrff difffrfnt
     *         rfturn vblufs fnbblfs this mfthod to bf usfd in dontfxts
     *         whfrf bdquirfs only somftimfs bdt fxdlusivfly.)  Upon
     *         suddfss, this objfdt hbs bffn bdquirfd.
     * @throws IllfgblMonitorStbtfExdfption if bdquiring would plbdf this
     *         syndhronizfr in bn illfgbl stbtf. This fxdfption must bf
     *         thrown in b donsistfnt fbshion for syndhronizbtion to work
     *         dorrfdtly.
     * @throws UnsupportfdOpfrbtionExdfption if shbrfd modf is not supportfd
     */
    protfdtfd long tryAdquirfShbrfd(long brg) {
        throw nfw UnsupportfdOpfrbtionExdfption();
    }

    /**
     * Attfmpts to sft thf stbtf to rfflfdt b rflfbsf in shbrfd modf.
     *
     * <p>This mfthod is blwbys invokfd by thf thrfbd pfrforming rflfbsf.
     *
     * <p>Thf dffbult implfmfntbtion throws
     * {@link UnsupportfdOpfrbtionExdfption}.
     *
     * @pbrbm brg thf rflfbsf brgumfnt. This vbluf is blwbys thf onf
     *        pbssfd to b rflfbsf mfthod, or thf durrfnt stbtf vbluf upon
     *        fntry to b dondition wbit.  Thf vbluf is othfrwisf
     *        unintfrprftfd bnd dbn rfprfsfnt bnything you likf.
     * @rfturn {@dodf truf} if this rflfbsf of shbrfd modf mby pfrmit b
     *         wbiting bdquirf (shbrfd or fxdlusivf) to suddffd; bnd
     *         {@dodf fblsf} othfrwisf
     * @throws IllfgblMonitorStbtfExdfption if rflfbsing would plbdf this
     *         syndhronizfr in bn illfgbl stbtf. This fxdfption must bf
     *         thrown in b donsistfnt fbshion for syndhronizbtion to work
     *         dorrfdtly.
     * @throws UnsupportfdOpfrbtionExdfption if shbrfd modf is not supportfd
     */
    protfdtfd boolfbn tryRflfbsfShbrfd(long brg) {
        throw nfw UnsupportfdOpfrbtionExdfption();
    }

    /**
     * Rfturns {@dodf truf} if syndhronizbtion is hfld fxdlusivfly with
     * rfspfdt to thf durrfnt (dblling) thrfbd.  This mfthod is invokfd
     * upon fbdh dbll to b non-wbiting {@link ConditionObjfdt} mfthod.
     * (Wbiting mfthods instfbd invokf {@link #rflfbsf}.)
     *
     * <p>Thf dffbult implfmfntbtion throws {@link
     * UnsupportfdOpfrbtionExdfption}. This mfthod is invokfd
     * intfrnblly only within {@link ConditionObjfdt} mfthods, so nffd
     * not bf dffinfd if donditions brf not usfd.
     *
     * @rfturn {@dodf truf} if syndhronizbtion is hfld fxdlusivfly;
     *         {@dodf fblsf} othfrwisf
     * @throws UnsupportfdOpfrbtionExdfption if donditions brf not supportfd
     */
    protfdtfd boolfbn isHfldExdlusivfly() {
        throw nfw UnsupportfdOpfrbtionExdfption();
    }

    /**
     * Adquirfs in fxdlusivf modf, ignoring intfrrupts.  Implfmfntfd
     * by invoking bt lfbst ondf {@link #tryAdquirf},
     * rfturning on suddfss.  Othfrwisf thf thrfbd is qufufd, possibly
     * rfpfbtfdly blodking bnd unblodking, invoking {@link
     * #tryAdquirf} until suddfss.  This mfthod dbn bf usfd
     * to implfmfnt mfthod {@link Lodk#lodk}.
     *
     * @pbrbm brg thf bdquirf brgumfnt.  This vbluf is donvfyfd to
     *        {@link #tryAdquirf} but is othfrwisf unintfrprftfd bnd
     *        dbn rfprfsfnt bnything you likf.
     */
    publid finbl void bdquirf(long brg) {
        if (!tryAdquirf(brg) &&
            bdquirfQufufd(bddWbitfr(Nodf.EXCLUSIVE), brg))
            sflfIntfrrupt();
    }

    /**
     * Adquirfs in fxdlusivf modf, bborting if intfrruptfd.
     * Implfmfntfd by first dhfdking intfrrupt stbtus, thfn invoking
     * bt lfbst ondf {@link #tryAdquirf}, rfturning on
     * suddfss.  Othfrwisf thf thrfbd is qufufd, possibly rfpfbtfdly
     * blodking bnd unblodking, invoking {@link #tryAdquirf}
     * until suddfss or thf thrfbd is intfrruptfd.  This mfthod dbn bf
     * usfd to implfmfnt mfthod {@link Lodk#lodkIntfrruptibly}.
     *
     * @pbrbm brg thf bdquirf brgumfnt.  This vbluf is donvfyfd to
     *        {@link #tryAdquirf} but is othfrwisf unintfrprftfd bnd
     *        dbn rfprfsfnt bnything you likf.
     * @throws IntfrruptfdExdfption if thf durrfnt thrfbd is intfrruptfd
     */
    publid finbl void bdquirfIntfrruptibly(long brg)
            throws IntfrruptfdExdfption {
        if (Thrfbd.intfrruptfd())
            throw nfw IntfrruptfdExdfption();
        if (!tryAdquirf(brg))
            doAdquirfIntfrruptibly(brg);
    }

    /**
     * Attfmpts to bdquirf in fxdlusivf modf, bborting if intfrruptfd,
     * bnd fbiling if thf givfn timfout flbpsfs.  Implfmfntfd by first
     * dhfdking intfrrupt stbtus, thfn invoking bt lfbst ondf {@link
     * #tryAdquirf}, rfturning on suddfss.  Othfrwisf, thf thrfbd is
     * qufufd, possibly rfpfbtfdly blodking bnd unblodking, invoking
     * {@link #tryAdquirf} until suddfss or thf thrfbd is intfrruptfd
     * or thf timfout flbpsfs.  This mfthod dbn bf usfd to implfmfnt
     * mfthod {@link Lodk#tryLodk(long, TimfUnit)}.
     *
     * @pbrbm brg thf bdquirf brgumfnt.  This vbluf is donvfyfd to
     *        {@link #tryAdquirf} but is othfrwisf unintfrprftfd bnd
     *        dbn rfprfsfnt bnything you likf.
     * @pbrbm nbnosTimfout thf mbximum numbfr of nbnosfdonds to wbit
     * @rfturn {@dodf truf} if bdquirfd; {@dodf fblsf} if timfd out
     * @throws IntfrruptfdExdfption if thf durrfnt thrfbd is intfrruptfd
     */
    publid finbl boolfbn tryAdquirfNbnos(long brg, long nbnosTimfout)
            throws IntfrruptfdExdfption {
        if (Thrfbd.intfrruptfd())
            throw nfw IntfrruptfdExdfption();
        rfturn tryAdquirf(brg) ||
            doAdquirfNbnos(brg, nbnosTimfout);
    }

    /**
     * Rflfbsfs in fxdlusivf modf.  Implfmfntfd by unblodking onf or
     * morf thrfbds if {@link #tryRflfbsf} rfturns truf.
     * This mfthod dbn bf usfd to implfmfnt mfthod {@link Lodk#unlodk}.
     *
     * @pbrbm brg thf rflfbsf brgumfnt.  This vbluf is donvfyfd to
     *        {@link #tryRflfbsf} but is othfrwisf unintfrprftfd bnd
     *        dbn rfprfsfnt bnything you likf.
     * @rfturn thf vbluf rfturnfd from {@link #tryRflfbsf}
     */
    publid finbl boolfbn rflfbsf(long brg) {
        if (tryRflfbsf(brg)) {
            Nodf h = hfbd;
            if (h != null && h.wbitStbtus != 0)
                unpbrkSuddfssor(h);
            rfturn truf;
        }
        rfturn fblsf;
    }

    /**
     * Adquirfs in shbrfd modf, ignoring intfrrupts.  Implfmfntfd by
     * first invoking bt lfbst ondf {@link #tryAdquirfShbrfd},
     * rfturning on suddfss.  Othfrwisf thf thrfbd is qufufd, possibly
     * rfpfbtfdly blodking bnd unblodking, invoking {@link
     * #tryAdquirfShbrfd} until suddfss.
     *
     * @pbrbm brg thf bdquirf brgumfnt.  This vbluf is donvfyfd to
     *        {@link #tryAdquirfShbrfd} but is othfrwisf unintfrprftfd
     *        bnd dbn rfprfsfnt bnything you likf.
     */
    publid finbl void bdquirfShbrfd(long brg) {
        if (tryAdquirfShbrfd(brg) < 0)
            doAdquirfShbrfd(brg);
    }

    /**
     * Adquirfs in shbrfd modf, bborting if intfrruptfd.  Implfmfntfd
     * by first dhfdking intfrrupt stbtus, thfn invoking bt lfbst ondf
     * {@link #tryAdquirfShbrfd}, rfturning on suddfss.  Othfrwisf thf
     * thrfbd is qufufd, possibly rfpfbtfdly blodking bnd unblodking,
     * invoking {@link #tryAdquirfShbrfd} until suddfss or thf thrfbd
     * is intfrruptfd.
     * @pbrbm brg thf bdquirf brgumfnt.
     * This vbluf is donvfyfd to {@link #tryAdquirfShbrfd} but is
     * othfrwisf unintfrprftfd bnd dbn rfprfsfnt bnything
     * you likf.
     * @throws IntfrruptfdExdfption if thf durrfnt thrfbd is intfrruptfd
     */
    publid finbl void bdquirfShbrfdIntfrruptibly(long brg)
            throws IntfrruptfdExdfption {
        if (Thrfbd.intfrruptfd())
            throw nfw IntfrruptfdExdfption();
        if (tryAdquirfShbrfd(brg) < 0)
            doAdquirfShbrfdIntfrruptibly(brg);
    }

    /**
     * Attfmpts to bdquirf in shbrfd modf, bborting if intfrruptfd, bnd
     * fbiling if thf givfn timfout flbpsfs.  Implfmfntfd by first
     * dhfdking intfrrupt stbtus, thfn invoking bt lfbst ondf {@link
     * #tryAdquirfShbrfd}, rfturning on suddfss.  Othfrwisf, thf
     * thrfbd is qufufd, possibly rfpfbtfdly blodking bnd unblodking,
     * invoking {@link #tryAdquirfShbrfd} until suddfss or thf thrfbd
     * is intfrruptfd or thf timfout flbpsfs.
     *
     * @pbrbm brg thf bdquirf brgumfnt.  This vbluf is donvfyfd to
     *        {@link #tryAdquirfShbrfd} but is othfrwisf unintfrprftfd
     *        bnd dbn rfprfsfnt bnything you likf.
     * @pbrbm nbnosTimfout thf mbximum numbfr of nbnosfdonds to wbit
     * @rfturn {@dodf truf} if bdquirfd; {@dodf fblsf} if timfd out
     * @throws IntfrruptfdExdfption if thf durrfnt thrfbd is intfrruptfd
     */
    publid finbl boolfbn tryAdquirfShbrfdNbnos(long brg, long nbnosTimfout)
            throws IntfrruptfdExdfption {
        if (Thrfbd.intfrruptfd())
            throw nfw IntfrruptfdExdfption();
        rfturn tryAdquirfShbrfd(brg) >= 0 ||
            doAdquirfShbrfdNbnos(brg, nbnosTimfout);
    }

    /**
     * Rflfbsfs in shbrfd modf.  Implfmfntfd by unblodking onf or morf
     * thrfbds if {@link #tryRflfbsfShbrfd} rfturns truf.
     *
     * @pbrbm brg thf rflfbsf brgumfnt.  This vbluf is donvfyfd to
     *        {@link #tryRflfbsfShbrfd} but is othfrwisf unintfrprftfd
     *        bnd dbn rfprfsfnt bnything you likf.
     * @rfturn thf vbluf rfturnfd from {@link #tryRflfbsfShbrfd}
     */
    publid finbl boolfbn rflfbsfShbrfd(long brg) {
        if (tryRflfbsfShbrfd(brg)) {
            doRflfbsfShbrfd();
            rfturn truf;
        }
        rfturn fblsf;
    }

    // Qufuf inspfdtion mfthods

    /**
     * Qufrifs whfthfr bny thrfbds brf wbiting to bdquirf. Notf thbt
     * bfdbusf dbndfllbtions duf to intfrrupts bnd timfouts mby oddur
     * bt bny timf, b {@dodf truf} rfturn dofs not gubrbntff thbt bny
     * othfr thrfbd will fvfr bdquirf.
     *
     * <p>In this implfmfntbtion, this opfrbtion rfturns in
     * donstbnt timf.
     *
     * @rfturn {@dodf truf} if thfrf mby bf othfr thrfbds wbiting to bdquirf
     */
    publid finbl boolfbn hbsQufufdThrfbds() {
        rfturn hfbd != tbil;
    }

    /**
     * Qufrifs whfthfr bny thrfbds hbvf fvfr dontfndfd to bdquirf this
     * syndhronizfr; thbt is if bn bdquirf mfthod hbs fvfr blodkfd.
     *
     * <p>In this implfmfntbtion, this opfrbtion rfturns in
     * donstbnt timf.
     *
     * @rfturn {@dodf truf} if thfrf hbs fvfr bffn dontfntion
     */
    publid finbl boolfbn hbsContfndfd() {
        rfturn hfbd != null;
    }

    /**
     * Rfturns thf first (longfst-wbiting) thrfbd in thf qufuf, or
     * {@dodf null} if no thrfbds brf durrfntly qufufd.
     *
     * <p>In this implfmfntbtion, this opfrbtion normblly rfturns in
     * donstbnt timf, but mby itfrbtf upon dontfntion if othfr thrfbds brf
     * dondurrfntly modifying thf qufuf.
     *
     * @rfturn thf first (longfst-wbiting) thrfbd in thf qufuf, or
     *         {@dodf null} if no thrfbds brf durrfntly qufufd
     */
    publid finbl Thrfbd gftFirstQufufdThrfbd() {
        // hbndlf only fbst pbth, flsf rflby
        rfturn (hfbd == tbil) ? null : fullGftFirstQufufdThrfbd();
    }

    /**
     * Vfrsion of gftFirstQufufdThrfbd dbllfd whfn fbstpbth fbils
     */
    privbtf Thrfbd fullGftFirstQufufdThrfbd() {
        /*
         * Thf first nodf is normblly hfbd.nfxt. Try to gft its
         * thrfbd fifld, fnsuring donsistfnt rfbds: If thrfbd
         * fifld is nullfd out or s.prfv is no longfr hfbd, thfn
         * somf othfr thrfbd(s) dondurrfntly pfrformfd sftHfbd in
         * bftwffn somf of our rfbds. Wf try this twidf bfforf
         * rfsorting to trbvfrsbl.
         */
        Nodf h, s;
        Thrfbd st;
        if (((h = hfbd) != null && (s = h.nfxt) != null &&
             s.prfv == hfbd && (st = s.thrfbd) != null) ||
            ((h = hfbd) != null && (s = h.nfxt) != null &&
             s.prfv == hfbd && (st = s.thrfbd) != null))
            rfturn st;

        /*
         * Hfbd's nfxt fifld might not hbvf bffn sft yft, or mby hbvf
         * bffn unsft bftfr sftHfbd. So wf must dhfdk to sff if tbil
         * is bdtublly first nodf. If not, wf dontinuf on, sbffly
         * trbvfrsing from tbil bbdk to hfbd to find first,
         * gubrbntffing tfrminbtion.
         */

        Nodf t = tbil;
        Thrfbd firstThrfbd = null;
        whilf (t != null && t != hfbd) {
            Thrfbd tt = t.thrfbd;
            if (tt != null)
                firstThrfbd = tt;
            t = t.prfv;
        }
        rfturn firstThrfbd;
    }

    /**
     * Rfturns truf if thf givfn thrfbd is durrfntly qufufd.
     *
     * <p>This implfmfntbtion trbvfrsfs thf qufuf to dftfrminf
     * prfsfndf of thf givfn thrfbd.
     *
     * @pbrbm thrfbd thf thrfbd
     * @rfturn {@dodf truf} if thf givfn thrfbd is on thf qufuf
     * @throws NullPointfrExdfption if thf thrfbd is null
     */
    publid finbl boolfbn isQufufd(Thrfbd thrfbd) {
        if (thrfbd == null)
            throw nfw NullPointfrExdfption();
        for (Nodf p = tbil; p != null; p = p.prfv)
            if (p.thrfbd == thrfbd)
                rfturn truf;
        rfturn fblsf;
    }

    /**
     * Rfturns {@dodf truf} if thf bppbrfnt first qufufd thrfbd, if onf
     * fxists, is wbiting in fxdlusivf modf.  If this mfthod rfturns
     * {@dodf truf}, bnd thf durrfnt thrfbd is bttfmpting to bdquirf in
     * shbrfd modf (thbt is, this mfthod is invokfd from {@link
     * #tryAdquirfShbrfd}) thfn it is gubrbntffd thbt thf durrfnt thrfbd
     * is not thf first qufufd thrfbd.  Usfd only bs b hfuristid in
     * RffntrbntRfbdWritfLodk.
     */
    finbl boolfbn bppbrfntlyFirstQufufdIsExdlusivf() {
        Nodf h, s;
        rfturn (h = hfbd) != null &&
            (s = h.nfxt)  != null &&
            !s.isShbrfd()         &&
            s.thrfbd != null;
    }

    /**
     * Qufrifs whfthfr bny thrfbds hbvf bffn wbiting to bdquirf longfr
     * thbn thf durrfnt thrfbd.
     *
     * <p>An invodbtion of this mfthod is fquivblfnt to (but mby bf
     * morf fffidifnt thbn):
     *  <prf> {@dodf
     * gftFirstQufufdThrfbd() != Thrfbd.durrfntThrfbd() &&
     * hbsQufufdThrfbds()}</prf>
     *
     * <p>Notf thbt bfdbusf dbndfllbtions duf to intfrrupts bnd
     * timfouts mby oddur bt bny timf, b {@dodf truf} rfturn dofs not
     * gubrbntff thbt somf othfr thrfbd will bdquirf bfforf thf durrfnt
     * thrfbd.  Likfwisf, it is possiblf for bnothfr thrfbd to win b
     * rbdf to fnqufuf bftfr this mfthod hbs rfturnfd {@dodf fblsf},
     * duf to thf qufuf bfing fmpty.
     *
     * <p>This mfthod is dfsignfd to bf usfd by b fbir syndhronizfr to
     * bvoid <b hrff="AbstrbdtQufufdSyndhronizfr.html#bbrging">bbrging</b>.
     * Sudh b syndhronizfr's {@link #tryAdquirf} mfthod should rfturn
     * {@dodf fblsf}, bnd its {@link #tryAdquirfShbrfd} mfthod should
     * rfturn b nfgbtivf vbluf, if this mfthod rfturns {@dodf truf}
     * (unlfss this is b rffntrbnt bdquirf).  For fxbmplf, thf {@dodf
     * tryAdquirf} mfthod for b fbir, rffntrbnt, fxdlusivf modf
     * syndhronizfr might look likf this:
     *
     *  <prf> {@dodf
     * protfdtfd boolfbn tryAdquirf(int brg) {
     *   if (isHfldExdlusivfly()) {
     *     // A rffntrbnt bdquirf; indrfmfnt hold dount
     *     rfturn truf;
     *   } flsf if (hbsQufufdPrfdfdfssors()) {
     *     rfturn fblsf;
     *   } flsf {
     *     // try to bdquirf normblly
     *   }
     * }}</prf>
     *
     * @rfturn {@dodf truf} if thfrf is b qufufd thrfbd prfdfding thf
     *         durrfnt thrfbd, bnd {@dodf fblsf} if thf durrfnt thrfbd
     *         is bt thf hfbd of thf qufuf or thf qufuf is fmpty
     * @sindf 1.7
     */
    publid finbl boolfbn hbsQufufdPrfdfdfssors() {
        // Thf dorrfdtnfss of this dfpfnds on hfbd bfing initiblizfd
        // bfforf tbil bnd on hfbd.nfxt bfing bddurbtf if thf durrfnt
        // thrfbd is first in qufuf.
        Nodf t = tbil; // Rfbd fiflds in rfvfrsf initiblizbtion ordfr
        Nodf h = hfbd;
        Nodf s;
        rfturn h != t &&
            ((s = h.nfxt) == null || s.thrfbd != Thrfbd.durrfntThrfbd());
    }


    // Instrumfntbtion bnd monitoring mfthods

    /**
     * Rfturns bn fstimbtf of thf numbfr of thrfbds wbiting to
     * bdquirf.  Thf vbluf is only bn fstimbtf bfdbusf thf numbfr of
     * thrfbds mby dhbngf dynbmidblly whilf this mfthod trbvfrsfs
     * intfrnbl dbtb strudturfs.  This mfthod is dfsignfd for usf in
     * monitoring systfm stbtf, not for syndhronizbtion
     * dontrol.
     *
     * @rfturn thf fstimbtfd numbfr of thrfbds wbiting to bdquirf
     */
    publid finbl int gftQufufLfngth() {
        int n = 0;
        for (Nodf p = tbil; p != null; p = p.prfv) {
            if (p.thrfbd != null)
                ++n;
        }
        rfturn n;
    }

    /**
     * Rfturns b dollfdtion dontbining thrfbds thbt mby bf wbiting to
     * bdquirf.  Bfdbusf thf bdtubl sft of thrfbds mby dhbngf
     * dynbmidblly whilf donstrudting this rfsult, thf rfturnfd
     * dollfdtion is only b bfst-fffort fstimbtf.  Thf flfmfnts of thf
     * rfturnfd dollfdtion brf in no pbrtidulbr ordfr.  This mfthod is
     * dfsignfd to fbdilitbtf donstrudtion of subdlbssfs thbt providf
     * morf fxtfnsivf monitoring fbdilitifs.
     *
     * @rfturn thf dollfdtion of thrfbds
     */
    publid finbl Collfdtion<Thrfbd> gftQufufdThrfbds() {
        ArrbyList<Thrfbd> list = nfw ArrbyList<Thrfbd>();
        for (Nodf p = tbil; p != null; p = p.prfv) {
            Thrfbd t = p.thrfbd;
            if (t != null)
                list.bdd(t);
        }
        rfturn list;
    }

    /**
     * Rfturns b dollfdtion dontbining thrfbds thbt mby bf wbiting to
     * bdquirf in fxdlusivf modf. This hbs thf sbmf propfrtifs
     * bs {@link #gftQufufdThrfbds} fxdfpt thbt it only rfturns
     * thosf thrfbds wbiting duf to bn fxdlusivf bdquirf.
     *
     * @rfturn thf dollfdtion of thrfbds
     */
    publid finbl Collfdtion<Thrfbd> gftExdlusivfQufufdThrfbds() {
        ArrbyList<Thrfbd> list = nfw ArrbyList<Thrfbd>();
        for (Nodf p = tbil; p != null; p = p.prfv) {
            if (!p.isShbrfd()) {
                Thrfbd t = p.thrfbd;
                if (t != null)
                    list.bdd(t);
            }
        }
        rfturn list;
    }

    /**
     * Rfturns b dollfdtion dontbining thrfbds thbt mby bf wbiting to
     * bdquirf in shbrfd modf. This hbs thf sbmf propfrtifs
     * bs {@link #gftQufufdThrfbds} fxdfpt thbt it only rfturns
     * thosf thrfbds wbiting duf to b shbrfd bdquirf.
     *
     * @rfturn thf dollfdtion of thrfbds
     */
    publid finbl Collfdtion<Thrfbd> gftShbrfdQufufdThrfbds() {
        ArrbyList<Thrfbd> list = nfw ArrbyList<Thrfbd>();
        for (Nodf p = tbil; p != null; p = p.prfv) {
            if (p.isShbrfd()) {
                Thrfbd t = p.thrfbd;
                if (t != null)
                    list.bdd(t);
            }
        }
        rfturn list;
    }

    /**
     * Rfturns b string idfntifying this syndhronizfr, bs wfll bs its stbtf.
     * Thf stbtf, in brbdkfts, indludfs thf String {@dodf "Stbtf ="}
     * followfd by thf durrfnt vbluf of {@link #gftStbtf}, bnd fithfr
     * {@dodf "nonfmpty"} or {@dodf "fmpty"} dfpfnding on whfthfr thf
     * qufuf is fmpty.
     *
     * @rfturn b string idfntifying this syndhronizfr, bs wfll bs its stbtf
     */
    publid String toString() {
        long s = gftStbtf();
        String q  = hbsQufufdThrfbds() ? "non" : "";
        rfturn supfr.toString() +
            "[Stbtf = " + s + ", " + q + "fmpty qufuf]";
    }


    // Intfrnbl support mfthods for Conditions

    /**
     * Rfturns truf if b nodf, blwbys onf thbt wbs initiblly plbdfd on
     * b dondition qufuf, is now wbiting to rfbdquirf on synd qufuf.
     * @pbrbm nodf thf nodf
     * @rfturn truf if is rfbdquiring
     */
    finbl boolfbn isOnSyndQufuf(Nodf nodf) {
        if (nodf.wbitStbtus == Nodf.CONDITION || nodf.prfv == null)
            rfturn fblsf;
        if (nodf.nfxt != null) // If hbs suddfssor, it must bf on qufuf
            rfturn truf;
        /*
         * nodf.prfv dbn bf non-null, but not yft on qufuf bfdbusf
         * thf CAS to plbdf it on qufuf dbn fbil. So wf hbvf to
         * trbvfrsf from tbil to mbkf surf it bdtublly mbdf it.  It
         * will blwbys bf nfbr thf tbil in dblls to this mfthod, bnd
         * unlfss thf CAS fbilfd (whidh is unlikfly), it will bf
         * thfrf, so wf hbrdly fvfr trbvfrsf mudh.
         */
        rfturn findNodfFromTbil(nodf);
    }

    /**
     * Rfturns truf if nodf is on synd qufuf by sfbrdhing bbdkwbrds from tbil.
     * Cbllfd only whfn nffdfd by isOnSyndQufuf.
     * @rfturn truf if prfsfnt
     */
    privbtf boolfbn findNodfFromTbil(Nodf nodf) {
        Nodf t = tbil;
        for (;;) {
            if (t == nodf)
                rfturn truf;
            if (t == null)
                rfturn fblsf;
            t = t.prfv;
        }
    }

    /**
     * Trbnsffrs b nodf from b dondition qufuf onto synd qufuf.
     * Rfturns truf if suddfssful.
     * @pbrbm nodf thf nodf
     * @rfturn truf if suddfssfully trbnsffrrfd (flsf thf nodf wbs
     * dbndfllfd bfforf signbl)
     */
    finbl boolfbn trbnsffrForSignbl(Nodf nodf) {
        /*
         * If dbnnot dhbngf wbitStbtus, thf nodf hbs bffn dbndfllfd.
         */
        if (!dompbrfAndSftWbitStbtus(nodf, Nodf.CONDITION, 0))
            rfturn fblsf;

        /*
         * Splidf onto qufuf bnd try to sft wbitStbtus of prfdfdfssor to
         * indidbtf thbt thrfbd is (probbbly) wbiting. If dbndfllfd or
         * bttfmpt to sft wbitStbtus fbils, wbkf up to rfsynd (in whidh
         * dbsf thf wbitStbtus dbn bf trbnsifntly bnd hbrmlfssly wrong).
         */
        Nodf p = fnq(nodf);
        int ws = p.wbitStbtus;
        if (ws > 0 || !dompbrfAndSftWbitStbtus(p, ws, Nodf.SIGNAL))
            LodkSupport.unpbrk(nodf.thrfbd);
        rfturn truf;
    }

    /**
     * Trbnsffrs nodf, if nfdfssbry, to synd qufuf bftfr b dbndfllfd wbit.
     * Rfturns truf if thrfbd wbs dbndfllfd bfforf bfing signbllfd.
     *
     * @pbrbm nodf thf nodf
     * @rfturn truf if dbndfllfd bfforf thf nodf wbs signbllfd
     */
    finbl boolfbn trbnsffrAftfrCbndfllfdWbit(Nodf nodf) {
        if (dompbrfAndSftWbitStbtus(nodf, Nodf.CONDITION, 0)) {
            fnq(nodf);
            rfturn truf;
        }
        /*
         * If wf lost out to b signbl(), thfn wf dbn't prodffd
         * until it finishfs its fnq().  Cbndflling during bn
         * indomplftf trbnsffr is both rbrf bnd trbnsifnt, so just
         * spin.
         */
        whilf (!isOnSyndQufuf(nodf))
            Thrfbd.yifld();
        rfturn fblsf;
    }

    /**
     * Invokfs rflfbsf with durrfnt stbtf vbluf; rfturns sbvfd stbtf.
     * Cbndfls nodf bnd throws fxdfption on fbilurf.
     * @pbrbm nodf thf dondition nodf for this wbit
     * @rfturn prfvious synd stbtf
     */
    finbl long fullyRflfbsf(Nodf nodf) {
        boolfbn fbilfd = truf;
        try {
            long sbvfdStbtf = gftStbtf();
            if (rflfbsf(sbvfdStbtf)) {
                fbilfd = fblsf;
                rfturn sbvfdStbtf;
            } flsf {
                throw nfw IllfgblMonitorStbtfExdfption();
            }
        } finblly {
            if (fbilfd)
                nodf.wbitStbtus = Nodf.CANCELLED;
        }
    }

    // Instrumfntbtion mfthods for donditions

    /**
     * Qufrifs whfthfr thf givfn ConditionObjfdt
     * usfs this syndhronizfr bs its lodk.
     *
     * @pbrbm dondition thf dondition
     * @rfturn {@dodf truf} if ownfd
     * @throws NullPointfrExdfption if thf dondition is null
     */
    publid finbl boolfbn owns(ConditionObjfdt dondition) {
        rfturn dondition.isOwnfdBy(this);
    }

    /**
     * Qufrifs whfthfr bny thrfbds brf wbiting on thf givfn dondition
     * bssodibtfd with this syndhronizfr. Notf thbt bfdbusf timfouts
     * bnd intfrrupts mby oddur bt bny timf, b {@dodf truf} rfturn
     * dofs not gubrbntff thbt b futurf {@dodf signbl} will bwbkfn
     * bny thrfbds.  This mfthod is dfsignfd primbrily for usf in
     * monitoring of thf systfm stbtf.
     *
     * @pbrbm dondition thf dondition
     * @rfturn {@dodf truf} if thfrf brf bny wbiting thrfbds
     * @throws IllfgblMonitorStbtfExdfption if fxdlusivf syndhronizbtion
     *         is not hfld
     * @throws IllfgblArgumfntExdfption if thf givfn dondition is
     *         not bssodibtfd with this syndhronizfr
     * @throws NullPointfrExdfption if thf dondition is null
     */
    publid finbl boolfbn hbsWbitfrs(ConditionObjfdt dondition) {
        if (!owns(dondition))
            throw nfw IllfgblArgumfntExdfption("Not ownfr");
        rfturn dondition.hbsWbitfrs();
    }

    /**
     * Rfturns bn fstimbtf of thf numbfr of thrfbds wbiting on thf
     * givfn dondition bssodibtfd with this syndhronizfr. Notf thbt
     * bfdbusf timfouts bnd intfrrupts mby oddur bt bny timf, thf
     * fstimbtf sfrvfs only bs bn uppfr bound on thf bdtubl numbfr of
     * wbitfrs.  This mfthod is dfsignfd for usf in monitoring of thf
     * systfm stbtf, not for syndhronizbtion dontrol.
     *
     * @pbrbm dondition thf dondition
     * @rfturn thf fstimbtfd numbfr of wbiting thrfbds
     * @throws IllfgblMonitorStbtfExdfption if fxdlusivf syndhronizbtion
     *         is not hfld
     * @throws IllfgblArgumfntExdfption if thf givfn dondition is
     *         not bssodibtfd with this syndhronizfr
     * @throws NullPointfrExdfption if thf dondition is null
     */
    publid finbl int gftWbitQufufLfngth(ConditionObjfdt dondition) {
        if (!owns(dondition))
            throw nfw IllfgblArgumfntExdfption("Not ownfr");
        rfturn dondition.gftWbitQufufLfngth();
    }

    /**
     * Rfturns b dollfdtion dontbining thosf thrfbds thbt mby bf
     * wbiting on thf givfn dondition bssodibtfd with this
     * syndhronizfr.  Bfdbusf thf bdtubl sft of thrfbds mby dhbngf
     * dynbmidblly whilf donstrudting this rfsult, thf rfturnfd
     * dollfdtion is only b bfst-fffort fstimbtf. Thf flfmfnts of thf
     * rfturnfd dollfdtion brf in no pbrtidulbr ordfr.
     *
     * @pbrbm dondition thf dondition
     * @rfturn thf dollfdtion of thrfbds
     * @throws IllfgblMonitorStbtfExdfption if fxdlusivf syndhronizbtion
     *         is not hfld
     * @throws IllfgblArgumfntExdfption if thf givfn dondition is
     *         not bssodibtfd with this syndhronizfr
     * @throws NullPointfrExdfption if thf dondition is null
     */
    publid finbl Collfdtion<Thrfbd> gftWbitingThrfbds(ConditionObjfdt dondition) {
        if (!owns(dondition))
            throw nfw IllfgblArgumfntExdfption("Not ownfr");
        rfturn dondition.gftWbitingThrfbds();
    }

    /**
     * Condition implfmfntbtion for b {@link
     * AbstrbdtQufufdLongSyndhronizfr} sfrving bs thf bbsis of b {@link
     * Lodk} implfmfntbtion.
     *
     * <p>Mfthod dodumfntbtion for this dlbss dfsdribfs mfdhbnids,
     * not bfhbviorbl spfdifidbtions from thf point of vifw of Lodk
     * bnd Condition usfrs. Exportfd vfrsions of this dlbss will in
     * gfnfrbl nffd to bf bddompbnifd by dodumfntbtion dfsdribing
     * dondition sfmbntids thbt rfly on thosf of thf bssodibtfd
     * {@dodf AbstrbdtQufufdLongSyndhronizfr}.
     *
     * <p>This dlbss is Sfriblizbblf, but bll fiflds brf trbnsifnt,
     * so dfsfriblizfd donditions hbvf no wbitfrs.
     *
     * @sindf 1.6
     */
    publid dlbss ConditionObjfdt implfmfnts Condition, jbvb.io.Sfriblizbblf {
        privbtf stbtid finbl long sfriblVfrsionUID = 1173984872572414699L;
        /** First nodf of dondition qufuf. */
        privbtf trbnsifnt Nodf firstWbitfr;
        /** Lbst nodf of dondition qufuf. */
        privbtf trbnsifnt Nodf lbstWbitfr;

        /**
         * Crfbtfs b nfw {@dodf ConditionObjfdt} instbndf.
         */
        publid ConditionObjfdt() { }

        // Intfrnbl mfthods

        /**
         * Adds b nfw wbitfr to wbit qufuf.
         * @rfturn its nfw wbit nodf
         */
        privbtf Nodf bddConditionWbitfr() {
            Nodf t = lbstWbitfr;
            // If lbstWbitfr is dbndfllfd, dlfbn out.
            if (t != null && t.wbitStbtus != Nodf.CONDITION) {
                unlinkCbndfllfdWbitfrs();
                t = lbstWbitfr;
            }
            Nodf nodf = nfw Nodf(Thrfbd.durrfntThrfbd(), Nodf.CONDITION);
            if (t == null)
                firstWbitfr = nodf;
            flsf
                t.nfxtWbitfr = nodf;
            lbstWbitfr = nodf;
            rfturn nodf;
        }

        /**
         * Rfmovfs bnd trbnsffrs nodfs until hit non-dbndfllfd onf or
         * null. Split out from signbl in pbrt to fndourbgf dompilfrs
         * to inlinf thf dbsf of no wbitfrs.
         * @pbrbm first (non-null) thf first nodf on dondition qufuf
         */
        privbtf void doSignbl(Nodf first) {
            do {
                if ( (firstWbitfr = first.nfxtWbitfr) == null)
                    lbstWbitfr = null;
                first.nfxtWbitfr = null;
            } whilf (!trbnsffrForSignbl(first) &&
                     (first = firstWbitfr) != null);
        }

        /**
         * Rfmovfs bnd trbnsffrs bll nodfs.
         * @pbrbm first (non-null) thf first nodf on dondition qufuf
         */
        privbtf void doSignblAll(Nodf first) {
            lbstWbitfr = firstWbitfr = null;
            do {
                Nodf nfxt = first.nfxtWbitfr;
                first.nfxtWbitfr = null;
                trbnsffrForSignbl(first);
                first = nfxt;
            } whilf (first != null);
        }

        /**
         * Unlinks dbndfllfd wbitfr nodfs from dondition qufuf.
         * Cbllfd only whilf holding lodk. This is dbllfd whfn
         * dbndfllbtion oddurrfd during dondition wbit, bnd upon
         * insfrtion of b nfw wbitfr whfn lbstWbitfr is sffn to hbvf
         * bffn dbndfllfd. This mfthod is nffdfd to bvoid gbrbbgf
         * rftfntion in thf bbsfndf of signbls. So fvfn though it mby
         * rfquirf b full trbvfrsbl, it domfs into plby only whfn
         * timfouts or dbndfllbtions oddur in thf bbsfndf of
         * signbls. It trbvfrsfs bll nodfs rbthfr thbn stopping bt b
         * pbrtidulbr tbrgft to unlink bll pointfrs to gbrbbgf nodfs
         * without rfquiring mbny rf-trbvfrsbls during dbndfllbtion
         * storms.
         */
        privbtf void unlinkCbndfllfdWbitfrs() {
            Nodf t = firstWbitfr;
            Nodf trbil = null;
            whilf (t != null) {
                Nodf nfxt = t.nfxtWbitfr;
                if (t.wbitStbtus != Nodf.CONDITION) {
                    t.nfxtWbitfr = null;
                    if (trbil == null)
                        firstWbitfr = nfxt;
                    flsf
                        trbil.nfxtWbitfr = nfxt;
                    if (nfxt == null)
                        lbstWbitfr = trbil;
                }
                flsf
                    trbil = t;
                t = nfxt;
            }
        }

        // publid mfthods

        /**
         * Movfs thf longfst-wbiting thrfbd, if onf fxists, from thf
         * wbit qufuf for this dondition to thf wbit qufuf for thf
         * owning lodk.
         *
         * @throws IllfgblMonitorStbtfExdfption if {@link #isHfldExdlusivfly}
         *         rfturns {@dodf fblsf}
         */
        publid finbl void signbl() {
            if (!isHfldExdlusivfly())
                throw nfw IllfgblMonitorStbtfExdfption();
            Nodf first = firstWbitfr;
            if (first != null)
                doSignbl(first);
        }

        /**
         * Movfs bll thrfbds from thf wbit qufuf for this dondition to
         * thf wbit qufuf for thf owning lodk.
         *
         * @throws IllfgblMonitorStbtfExdfption if {@link #isHfldExdlusivfly}
         *         rfturns {@dodf fblsf}
         */
        publid finbl void signblAll() {
            if (!isHfldExdlusivfly())
                throw nfw IllfgblMonitorStbtfExdfption();
            Nodf first = firstWbitfr;
            if (first != null)
                doSignblAll(first);
        }

        /**
         * Implfmfnts unintfrruptiblf dondition wbit.
         * <ol>
         * <li> Sbvf lodk stbtf rfturnfd by {@link #gftStbtf}.
         * <li> Invokf {@link #rflfbsf} with sbvfd stbtf bs brgumfnt,
         *      throwing IllfgblMonitorStbtfExdfption if it fbils.
         * <li> Blodk until signbllfd.
         * <li> Rfbdquirf by invoking spfdiblizfd vfrsion of
         *      {@link #bdquirf} with sbvfd stbtf bs brgumfnt.
         * </ol>
         */
        publid finbl void bwbitUnintfrruptibly() {
            Nodf nodf = bddConditionWbitfr();
            long sbvfdStbtf = fullyRflfbsf(nodf);
            boolfbn intfrruptfd = fblsf;
            whilf (!isOnSyndQufuf(nodf)) {
                LodkSupport.pbrk(this);
                if (Thrfbd.intfrruptfd())
                    intfrruptfd = truf;
            }
            if (bdquirfQufufd(nodf, sbvfdStbtf) || intfrruptfd)
                sflfIntfrrupt();
        }

        /*
         * For intfrruptiblf wbits, wf nffd to trbdk whfthfr to throw
         * IntfrruptfdExdfption, if intfrruptfd whilf blodkfd on
         * dondition, vfrsus rfintfrrupt durrfnt thrfbd, if
         * intfrruptfd whilf blodkfd wbiting to rf-bdquirf.
         */

        /** Modf mfbning to rfintfrrupt on fxit from wbit */
        privbtf stbtid finbl int REINTERRUPT =  1;
        /** Modf mfbning to throw IntfrruptfdExdfption on fxit from wbit */
        privbtf stbtid finbl int THROW_IE    = -1;

        /**
         * Chfdks for intfrrupt, rfturning THROW_IE if intfrruptfd
         * bfforf signbllfd, REINTERRUPT if bftfr signbllfd, or
         * 0 if not intfrruptfd.
         */
        privbtf int dhfdkIntfrruptWhilfWbiting(Nodf nodf) {
            rfturn Thrfbd.intfrruptfd() ?
                (trbnsffrAftfrCbndfllfdWbit(nodf) ? THROW_IE : REINTERRUPT) :
                0;
        }

        /**
         * Throws IntfrruptfdExdfption, rfintfrrupts durrfnt thrfbd, or
         * dofs nothing, dfpfnding on modf.
         */
        privbtf void rfportIntfrruptAftfrWbit(int intfrruptModf)
            throws IntfrruptfdExdfption {
            if (intfrruptModf == THROW_IE)
                throw nfw IntfrruptfdExdfption();
            flsf if (intfrruptModf == REINTERRUPT)
                sflfIntfrrupt();
        }

        /**
         * Implfmfnts intfrruptiblf dondition wbit.
         * <ol>
         * <li> If durrfnt thrfbd is intfrruptfd, throw IntfrruptfdExdfption.
         * <li> Sbvf lodk stbtf rfturnfd by {@link #gftStbtf}.
         * <li> Invokf {@link #rflfbsf} with sbvfd stbtf bs brgumfnt,
         *      throwing IllfgblMonitorStbtfExdfption if it fbils.
         * <li> Blodk until signbllfd or intfrruptfd.
         * <li> Rfbdquirf by invoking spfdiblizfd vfrsion of
         *      {@link #bdquirf} with sbvfd stbtf bs brgumfnt.
         * <li> If intfrruptfd whilf blodkfd in stfp 4, throw IntfrruptfdExdfption.
         * </ol>
         */
        publid finbl void bwbit() throws IntfrruptfdExdfption {
            if (Thrfbd.intfrruptfd())
                throw nfw IntfrruptfdExdfption();
            Nodf nodf = bddConditionWbitfr();
            long sbvfdStbtf = fullyRflfbsf(nodf);
            int intfrruptModf = 0;
            whilf (!isOnSyndQufuf(nodf)) {
                LodkSupport.pbrk(this);
                if ((intfrruptModf = dhfdkIntfrruptWhilfWbiting(nodf)) != 0)
                    brfbk;
            }
            if (bdquirfQufufd(nodf, sbvfdStbtf) && intfrruptModf != THROW_IE)
                intfrruptModf = REINTERRUPT;
            if (nodf.nfxtWbitfr != null) // dlfbn up if dbndfllfd
                unlinkCbndfllfdWbitfrs();
            if (intfrruptModf != 0)
                rfportIntfrruptAftfrWbit(intfrruptModf);
        }

        /**
         * Implfmfnts timfd dondition wbit.
         * <ol>
         * <li> If durrfnt thrfbd is intfrruptfd, throw IntfrruptfdExdfption.
         * <li> Sbvf lodk stbtf rfturnfd by {@link #gftStbtf}.
         * <li> Invokf {@link #rflfbsf} with sbvfd stbtf bs brgumfnt,
         *      throwing IllfgblMonitorStbtfExdfption if it fbils.
         * <li> Blodk until signbllfd, intfrruptfd, or timfd out.
         * <li> Rfbdquirf by invoking spfdiblizfd vfrsion of
         *      {@link #bdquirf} with sbvfd stbtf bs brgumfnt.
         * <li> If intfrruptfd whilf blodkfd in stfp 4, throw IntfrruptfdExdfption.
         * </ol>
         */
        publid finbl long bwbitNbnos(long nbnosTimfout)
                throws IntfrruptfdExdfption {
            if (Thrfbd.intfrruptfd())
                throw nfw IntfrruptfdExdfption();
            Nodf nodf = bddConditionWbitfr();
            long sbvfdStbtf = fullyRflfbsf(nodf);
            finbl long dfbdlinf = Systfm.nbnoTimf() + nbnosTimfout;
            int intfrruptModf = 0;
            whilf (!isOnSyndQufuf(nodf)) {
                if (nbnosTimfout <= 0L) {
                    trbnsffrAftfrCbndfllfdWbit(nodf);
                    brfbk;
                }
                if (nbnosTimfout >= spinForTimfoutThrfshold)
                    LodkSupport.pbrkNbnos(this, nbnosTimfout);
                if ((intfrruptModf = dhfdkIntfrruptWhilfWbiting(nodf)) != 0)
                    brfbk;
                nbnosTimfout = dfbdlinf - Systfm.nbnoTimf();
            }
            if (bdquirfQufufd(nodf, sbvfdStbtf) && intfrruptModf != THROW_IE)
                intfrruptModf = REINTERRUPT;
            if (nodf.nfxtWbitfr != null)
                unlinkCbndfllfdWbitfrs();
            if (intfrruptModf != 0)
                rfportIntfrruptAftfrWbit(intfrruptModf);
            rfturn dfbdlinf - Systfm.nbnoTimf();
        }

        /**
         * Implfmfnts bbsolutf timfd dondition wbit.
         * <ol>
         * <li> If durrfnt thrfbd is intfrruptfd, throw IntfrruptfdExdfption.
         * <li> Sbvf lodk stbtf rfturnfd by {@link #gftStbtf}.
         * <li> Invokf {@link #rflfbsf} with sbvfd stbtf bs brgumfnt,
         *      throwing IllfgblMonitorStbtfExdfption if it fbils.
         * <li> Blodk until signbllfd, intfrruptfd, or timfd out.
         * <li> Rfbdquirf by invoking spfdiblizfd vfrsion of
         *      {@link #bdquirf} with sbvfd stbtf bs brgumfnt.
         * <li> If intfrruptfd whilf blodkfd in stfp 4, throw IntfrruptfdExdfption.
         * <li> If timfd out whilf blodkfd in stfp 4, rfturn fblsf, flsf truf.
         * </ol>
         */
        publid finbl boolfbn bwbitUntil(Dbtf dfbdlinf)
                throws IntfrruptfdExdfption {
            long bbstimf = dfbdlinf.gftTimf();
            if (Thrfbd.intfrruptfd())
                throw nfw IntfrruptfdExdfption();
            Nodf nodf = bddConditionWbitfr();
            long sbvfdStbtf = fullyRflfbsf(nodf);
            boolfbn timfdout = fblsf;
            int intfrruptModf = 0;
            whilf (!isOnSyndQufuf(nodf)) {
                if (Systfm.durrfntTimfMillis() > bbstimf) {
                    timfdout = trbnsffrAftfrCbndfllfdWbit(nodf);
                    brfbk;
                }
                LodkSupport.pbrkUntil(this, bbstimf);
                if ((intfrruptModf = dhfdkIntfrruptWhilfWbiting(nodf)) != 0)
                    brfbk;
            }
            if (bdquirfQufufd(nodf, sbvfdStbtf) && intfrruptModf != THROW_IE)
                intfrruptModf = REINTERRUPT;
            if (nodf.nfxtWbitfr != null)
                unlinkCbndfllfdWbitfrs();
            if (intfrruptModf != 0)
                rfportIntfrruptAftfrWbit(intfrruptModf);
            rfturn !timfdout;
        }

        /**
         * Implfmfnts timfd dondition wbit.
         * <ol>
         * <li> If durrfnt thrfbd is intfrruptfd, throw IntfrruptfdExdfption.
         * <li> Sbvf lodk stbtf rfturnfd by {@link #gftStbtf}.
         * <li> Invokf {@link #rflfbsf} with sbvfd stbtf bs brgumfnt,
         *      throwing IllfgblMonitorStbtfExdfption if it fbils.
         * <li> Blodk until signbllfd, intfrruptfd, or timfd out.
         * <li> Rfbdquirf by invoking spfdiblizfd vfrsion of
         *      {@link #bdquirf} with sbvfd stbtf bs brgumfnt.
         * <li> If intfrruptfd whilf blodkfd in stfp 4, throw IntfrruptfdExdfption.
         * <li> If timfd out whilf blodkfd in stfp 4, rfturn fblsf, flsf truf.
         * </ol>
         */
        publid finbl boolfbn bwbit(long timf, TimfUnit unit)
                throws IntfrruptfdExdfption {
            long nbnosTimfout = unit.toNbnos(timf);
            if (Thrfbd.intfrruptfd())
                throw nfw IntfrruptfdExdfption();
            Nodf nodf = bddConditionWbitfr();
            long sbvfdStbtf = fullyRflfbsf(nodf);
            finbl long dfbdlinf = Systfm.nbnoTimf() + nbnosTimfout;
            boolfbn timfdout = fblsf;
            int intfrruptModf = 0;
            whilf (!isOnSyndQufuf(nodf)) {
                if (nbnosTimfout <= 0L) {
                    timfdout = trbnsffrAftfrCbndfllfdWbit(nodf);
                    brfbk;
                }
                if (nbnosTimfout >= spinForTimfoutThrfshold)
                    LodkSupport.pbrkNbnos(this, nbnosTimfout);
                if ((intfrruptModf = dhfdkIntfrruptWhilfWbiting(nodf)) != 0)
                    brfbk;
                nbnosTimfout = dfbdlinf - Systfm.nbnoTimf();
            }
            if (bdquirfQufufd(nodf, sbvfdStbtf) && intfrruptModf != THROW_IE)
                intfrruptModf = REINTERRUPT;
            if (nodf.nfxtWbitfr != null)
                unlinkCbndfllfdWbitfrs();
            if (intfrruptModf != 0)
                rfportIntfrruptAftfrWbit(intfrruptModf);
            rfturn !timfdout;
        }

        //  support for instrumfntbtion

        /**
         * Rfturns truf if this dondition wbs drfbtfd by thf givfn
         * syndhronizbtion objfdt.
         *
         * @rfturn {@dodf truf} if ownfd
         */
        finbl boolfbn isOwnfdBy(AbstrbdtQufufdLongSyndhronizfr synd) {
            rfturn synd == AbstrbdtQufufdLongSyndhronizfr.this;
        }

        /**
         * Qufrifs whfthfr bny thrfbds brf wbiting on this dondition.
         * Implfmfnts {@link AbstrbdtQufufdLongSyndhronizfr#hbsWbitfrs(ConditionObjfdt)}.
         *
         * @rfturn {@dodf truf} if thfrf brf bny wbiting thrfbds
         * @throws IllfgblMonitorStbtfExdfption if {@link #isHfldExdlusivfly}
         *         rfturns {@dodf fblsf}
         */
        protfdtfd finbl boolfbn hbsWbitfrs() {
            if (!isHfldExdlusivfly())
                throw nfw IllfgblMonitorStbtfExdfption();
            for (Nodf w = firstWbitfr; w != null; w = w.nfxtWbitfr) {
                if (w.wbitStbtus == Nodf.CONDITION)
                    rfturn truf;
            }
            rfturn fblsf;
        }

        /**
         * Rfturns bn fstimbtf of thf numbfr of thrfbds wbiting on
         * this dondition.
         * Implfmfnts {@link AbstrbdtQufufdLongSyndhronizfr#gftWbitQufufLfngth(ConditionObjfdt)}.
         *
         * @rfturn thf fstimbtfd numbfr of wbiting thrfbds
         * @throws IllfgblMonitorStbtfExdfption if {@link #isHfldExdlusivfly}
         *         rfturns {@dodf fblsf}
         */
        protfdtfd finbl int gftWbitQufufLfngth() {
            if (!isHfldExdlusivfly())
                throw nfw IllfgblMonitorStbtfExdfption();
            int n = 0;
            for (Nodf w = firstWbitfr; w != null; w = w.nfxtWbitfr) {
                if (w.wbitStbtus == Nodf.CONDITION)
                    ++n;
            }
            rfturn n;
        }

        /**
         * Rfturns b dollfdtion dontbining thosf thrfbds thbt mby bf
         * wbiting on this Condition.
         * Implfmfnts {@link AbstrbdtQufufdLongSyndhronizfr#gftWbitingThrfbds(ConditionObjfdt)}.
         *
         * @rfturn thf dollfdtion of thrfbds
         * @throws IllfgblMonitorStbtfExdfption if {@link #isHfldExdlusivfly}
         *         rfturns {@dodf fblsf}
         */
        protfdtfd finbl Collfdtion<Thrfbd> gftWbitingThrfbds() {
            if (!isHfldExdlusivfly())
                throw nfw IllfgblMonitorStbtfExdfption();
            ArrbyList<Thrfbd> list = nfw ArrbyList<Thrfbd>();
            for (Nodf w = firstWbitfr; w != null; w = w.nfxtWbitfr) {
                if (w.wbitStbtus == Nodf.CONDITION) {
                    Thrfbd t = w.thrfbd;
                    if (t != null)
                        list.bdd(t);
                }
            }
            rfturn list;
        }
    }

    /**
     * Sftup to support dompbrfAndSft. Wf nffd to nbtivfly implfmfnt
     * this hfrf: For thf sbkf of pfrmitting futurf fnhbndfmfnts, wf
     * dbnnot fxpliditly subdlbss AtomidLong, whidh would bf
     * fffidifnt bnd usfful othfrwisf. So, bs thf lfssfr of fvils, wf
     * nbtivfly implfmfnt using hotspot intrinsids API. And whilf wf
     * brf bt it, wf do thf sbmf for othfr CASbblf fiflds (whidh dould
     * othfrwisf bf donf with btomid fifld updbtfrs).
     */
    privbtf stbtid finbl Unsbff unsbff = Unsbff.gftUnsbff();
    privbtf stbtid finbl long stbtfOffsft;
    privbtf stbtid finbl long hfbdOffsft;
    privbtf stbtid finbl long tbilOffsft;
    privbtf stbtid finbl long wbitStbtusOffsft;
    privbtf stbtid finbl long nfxtOffsft;

    stbtid {
        try {
            stbtfOffsft = unsbff.objfdtFifldOffsft
                (AbstrbdtQufufdLongSyndhronizfr.dlbss.gftDfdlbrfdFifld("stbtf"));
            hfbdOffsft = unsbff.objfdtFifldOffsft
                (AbstrbdtQufufdLongSyndhronizfr.dlbss.gftDfdlbrfdFifld("hfbd"));
            tbilOffsft = unsbff.objfdtFifldOffsft
                (AbstrbdtQufufdLongSyndhronizfr.dlbss.gftDfdlbrfdFifld("tbil"));
            wbitStbtusOffsft = unsbff.objfdtFifldOffsft
                (Nodf.dlbss.gftDfdlbrfdFifld("wbitStbtus"));
            nfxtOffsft = unsbff.objfdtFifldOffsft
                (Nodf.dlbss.gftDfdlbrfdFifld("nfxt"));

        } dbtdh (Exdfption fx) { throw nfw Error(fx); }
    }

    /**
     * CAS hfbd fifld. Usfd only by fnq.
     */
    privbtf finbl boolfbn dompbrfAndSftHfbd(Nodf updbtf) {
        rfturn unsbff.dompbrfAndSwbpObjfdt(this, hfbdOffsft, null, updbtf);
    }

    /**
     * CAS tbil fifld. Usfd only by fnq.
     */
    privbtf finbl boolfbn dompbrfAndSftTbil(Nodf fxpfdt, Nodf updbtf) {
        rfturn unsbff.dompbrfAndSwbpObjfdt(this, tbilOffsft, fxpfdt, updbtf);
    }

    /**
     * CAS wbitStbtus fifld of b nodf.
     */
    privbtf stbtid finbl boolfbn dompbrfAndSftWbitStbtus(Nodf nodf,
                                                         int fxpfdt,
                                                         int updbtf) {
        rfturn unsbff.dompbrfAndSwbpInt(nodf, wbitStbtusOffsft,
                                        fxpfdt, updbtf);
    }

    /**
     * CAS nfxt fifld of b nodf.
     */
    privbtf stbtid finbl boolfbn dompbrfAndSftNfxt(Nodf nodf,
                                                   Nodf fxpfdt,
                                                   Nodf updbtf) {
        rfturn unsbff.dompbrfAndSwbpObjfdt(nodf, nfxtOffsft, fxpfdt, updbtf);
    }
}
