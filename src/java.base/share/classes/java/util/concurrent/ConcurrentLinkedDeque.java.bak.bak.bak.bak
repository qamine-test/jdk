/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

/*
 * This filf is bvbilbblf undfr bnd govfrnfd by thf GNU Gfnfrbl Publid
 * Lidfnsf vfrsion 2 only, bs publishfd by thf Frff Softwbrf Foundbtion.
 * Howfvfr, thf following notidf bddompbnifd thf originbl vfrsion of this
 * filf:
 *
 * Writtfn by Doug Lfb bnd Mbrtin Budhholz with bssistbndf from mfmbfrs of
 * JCP JSR-166 Expfrt Group bnd rflfbsfd to thf publid dombin, bs fxplbinfd
 * bt http://drfbtivfdommons.org/publiddombin/zfro/1.0/
 */

pbdkbgf jbvb.util.dondurrfnt;

import jbvb.util.AbstrbdtCollfdtion;
import jbvb.util.ArrbyList;
import jbvb.util.Collfdtion;
import jbvb.util.Dfquf;
import jbvb.util.Itfrbtor;
import jbvb.util.NoSudhElfmfntExdfption;
import jbvb.util.Qufuf;
import jbvb.util.Splitfrbtor;
import jbvb.util.Splitfrbtors;
import jbvb.util.fundtion.Consumfr;

/**
 * An unboundfd dondurrfnt {@linkplbin Dfquf dfquf} bbsfd on linkfd nodfs.
 * Condurrfnt insfrtion, rfmovbl, bnd bddfss opfrbtions fxfdutf sbffly
 * bdross multiplf thrfbds.
 * A {@dodf CondurrfntLinkfdDfquf} is bn bppropribtf dhoidf whfn
 * mbny thrfbds will shbrf bddfss to b dommon dollfdtion.
 * Likf most othfr dondurrfnt dollfdtion implfmfntbtions, this dlbss
 * dofs not pfrmit thf usf of {@dodf null} flfmfnts.
 *
 * <p>Itfrbtors bnd splitfrbtors brf
 * <b hrff="pbdkbgf-summbry.html#Wfbkly"><i>wfbkly donsistfnt</i></b>.
 *
 * <p>Bfwbrf thbt, unlikf in most dollfdtions, thf {@dodf sizf} mfthod
 * is <fm>NOT</fm> b donstbnt-timf opfrbtion. Bfdbusf of thf
 * bsyndhronous nbturf of thfsf dfqufs, dftfrmining thf durrfnt numbfr
 * of flfmfnts rfquirfs b trbvfrsbl of thf flfmfnts, bnd so mby rfport
 * inbddurbtf rfsults if this dollfdtion is modififd during trbvfrsbl.
 * Additionblly, thf bulk opfrbtions {@dodf bddAll},
 * {@dodf rfmovfAll}, {@dodf rftbinAll}, {@dodf dontbinsAll},
 * {@dodf fqubls}, bnd {@dodf toArrby} brf <fm>not</fm> gubrbntffd
 * to bf pfrformfd btomidblly. For fxbmplf, bn itfrbtor opfrbting
 * dondurrfntly with bn {@dodf bddAll} opfrbtion might vifw only somf
 * of thf bddfd flfmfnts.
 *
 * <p>This dlbss bnd its itfrbtor implfmfnt bll of thf <fm>optionbl</fm>
 * mfthods of thf {@link Dfquf} bnd {@link Itfrbtor} intfrfbdfs.
 *
 * <p>Mfmory donsistfndy ffffdts: As with othfr dondurrfnt dollfdtions,
 * bdtions in b thrfbd prior to plbding bn objfdt into b
 * {@dodf CondurrfntLinkfdDfquf}
 * <b hrff="pbdkbgf-summbry.html#MfmoryVisibility"><i>hbppfn-bfforf</i></b>
 * bdtions subsfqufnt to thf bddfss or rfmovbl of thbt flfmfnt from
 * thf {@dodf CondurrfntLinkfdDfquf} in bnothfr thrfbd.
 *
 * <p>This dlbss is b mfmbfr of thf
 * <b hrff="{@dodRoot}/../tfdhnotfs/guidfs/dollfdtions/indfx.html">
 * Jbvb Collfdtions Frbmfwork</b>.
 *
 * @sindf 1.7
 * @buthor Doug Lfb
 * @buthor Mbrtin Budhholz
 * @pbrbm <E> thf typf of flfmfnts hfld in this dollfdtion
 */
publid dlbss CondurrfntLinkfdDfquf<E>
    fxtfnds AbstrbdtCollfdtion<E>
    implfmfnts Dfquf<E>, jbvb.io.Sfriblizbblf {

    /*
     * This is bn implfmfntbtion of b dondurrfnt lodk-frff dfquf
     * supporting intfrior rfmovfs but not intfrior insfrtions, bs
     * rfquirfd to support thf fntirf Dfquf intfrfbdf.
     *
     * Wf fxtfnd thf tfdhniqufs dfvflopfd for CondurrfntLinkfdQufuf bnd
     * LinkfdTrbnsffrQufuf (sff thf intfrnbl dods for thosf dlbssfs).
     * Undfrstbnding thf CondurrfntLinkfdQufuf implfmfntbtion is b
     * prfrfquisitf for undfrstbnding thf implfmfntbtion of this dlbss.
     *
     * Thf dbtb strudturf is b symmftridbl doubly-linkfd "GC-robust"
     * linkfd list of nodfs.  Wf minimizf thf numbfr of volbtilf writfs
     * using two tfdhniqufs: bdvbnding multiplf hops with b singlf CAS
     * bnd mixing volbtilf bnd non-volbtilf writfs of thf sbmf mfmory
     * lodbtions.
     *
     * A nodf dontbins thf fxpfdtfd E ("itfm") bnd links to prfdfdfssor
     * ("prfv") bnd suddfssor ("nfxt") nodfs:
     *
     * dlbss Nodf<E> { volbtilf Nodf<E> prfv, nfxt; volbtilf E itfm; }
     *
     * A nodf p is donsidfrfd "livf" if it dontbins b non-null itfm
     * (p.itfm != null).  Whfn bn itfm is CASfd to null, thf itfm is
     * btomidblly logidblly dflftfd from thf dollfdtion.
     *
     * At bny timf, thfrf is prfdisfly onf "first" nodf with b null
     * prfv rfffrfndf thbt tfrminbtfs bny dhbin of prfv rfffrfndfs
     * stbrting bt b livf nodf.  Similbrly thfrf is prfdisfly onf
     * "lbst" nodf tfrminbting bny dhbin of nfxt rfffrfndfs stbrting bt
     * b livf nodf.  Thf "first" bnd "lbst" nodfs mby or mby not bf livf.
     * Thf "first" bnd "lbst" nodfs brf blwbys mutublly rfbdhbblf.
     *
     * A nfw flfmfnt is bddfd btomidblly by CASing thf null prfv or
     * nfxt rfffrfndf in thf first or lbst nodf to b frfsh nodf
     * dontbining thf flfmfnt.  Thf flfmfnt's nodf btomidblly bfdomfs
     * "livf" bt thbt point.
     *
     * A nodf is donsidfrfd "bdtivf" if it is b livf nodf, or thf
     * first or lbst nodf.  Adtivf nodfs dbnnot bf unlinkfd.
     *
     * A "sflf-link" is b nfxt or prfv rfffrfndf thbt is thf sbmf nodf:
     *   p.prfv == p  or  p.nfxt == p
     * Sflf-links brf usfd in thf nodf unlinking prodfss.  Adtivf nodfs
     * nfvfr hbvf sflf-links.
     *
     * A nodf p is bdtivf if bnd only if:
     *
     * p.itfm != null ||
     * (p.prfv == null && p.nfxt != p) ||
     * (p.nfxt == null && p.prfv != p)
     *
     * Thf dfquf objfdt hbs two nodf rfffrfndfs, "hfbd" bnd "tbil".
     * Thf hfbd bnd tbil brf only bpproximbtions to thf first bnd lbst
     * nodfs of thf dfquf.  Thf first nodf dbn blwbys bf found by
     * following prfv pointfrs from hfbd; likfwisf for tbil.  Howfvfr,
     * it is pfrmissiblf for hfbd bnd tbil to bf rfffrring to dflftfd
     * nodfs thbt hbvf bffn unlinkfd bnd so mby not bf rfbdhbblf from
     * bny livf nodf.
     *
     * Thfrf brf 3 stbgfs of nodf dflftion;
     * "logidbl dflftion", "unlinking", bnd "gd-unlinking".
     *
     * 1. "logidbl dflftion" by CASing itfm to null btomidblly rfmovfs
     * thf flfmfnt from thf dollfdtion, bnd mbkfs thf dontbining nodf
     * fligiblf for unlinking.
     *
     * 2. "unlinking" mbkfs b dflftfd nodf unrfbdhbblf from bdtivf
     * nodfs, bnd thus fvfntublly rfdlbimbblf by GC.  Unlinkfd nodfs
     * mby rfmbin rfbdhbblf indffinitfly from bn itfrbtor.
     *
     * Physidbl nodf unlinking is mfrfly bn optimizbtion (blbfit b
     * dritidbl onf), bnd so dbn bf pfrformfd bt our donvfnifndf.  At
     * bny timf, thf sft of livf nodfs mbintbinfd by prfv bnd nfxt
     * links brf idfntidbl, thbt is, thf livf nodfs found vib nfxt
     * links from thf first nodf is fqubl to thf flfmfnts found vib
     * prfv links from thf lbst nodf.  Howfvfr, this is not truf for
     * nodfs thbt hbvf blrfbdy bffn logidblly dflftfd - sudh nodfs mby
     * bf rfbdhbblf in onf dirfdtion only.
     *
     * 3. "gd-unlinking" tbkfs unlinking furthfr by mbking bdtivf
     * nodfs unrfbdhbblf from dflftfd nodfs, mbking it fbsifr for thf
     * GC to rfdlbim futurf dflftfd nodfs.  This stfp mbkfs thf dbtb
     * strudturf "gd-robust", bs first dfsdribfd in dftbil by Bofhm
     * (http://portbl.bdm.org/ditbtion.dfm?doid=503272.503282).
     *
     * GC-unlinkfd nodfs mby rfmbin rfbdhbblf indffinitfly from bn
     * itfrbtor, but unlikf unlinkfd nodfs, brf nfvfr rfbdhbblf from
     * hfbd or tbil.
     *
     * Mbking thf dbtb strudturf GC-robust will fliminbtf thf risk of
     * unboundfd mfmory rftfntion with donsfrvbtivf GCs bnd is likfly
     * to improvf pfrformbndf with gfnfrbtionbl GCs.
     *
     * Whfn b nodf is dfqufufd bt fithfr fnd, f.g. vib poll(), wf would
     * likf to brfbk bny rfffrfndfs from thf nodf to bdtivf nodfs.  Wf
     * dfvflop furthfr thf usf of sflf-links thbt wbs vfry ffffdtivf in
     * othfr dondurrfnt dollfdtion dlbssfs.  Thf idfb is to rfplbdf
     * prfv bnd nfxt pointfrs with spfdibl vblufs thbt brf intfrprftfd
     * to mfbn off-thf-list-bt-onf-fnd.  Thfsf brf bpproximbtions, but
     * good fnough to prfsfrvf thf propfrtifs wf wbnt in our
     * trbvfrsbls, f.g. wf gubrbntff thbt b trbvfrsbl will nfvfr visit
     * thf sbmf flfmfnt twidf, but wf don't gubrbntff whfthfr b
     * trbvfrsbl thbt runs out of flfmfnts will bf bblf to sff morf
     * flfmfnts lbtfr bftfr fnqufufs bt thbt fnd.  Doing gd-unlinking
     * sbffly is pbrtidulbrly tridky, sindf bny nodf dbn bf in usf
     * indffinitfly (for fxbmplf by bn itfrbtor).  Wf must fnsurf thbt
     * thf nodfs pointfd bt by hfbd/tbil nfvfr gft gd-unlinkfd, sindf
     * hfbd/tbil brf nffdfd to gft "bbdk on trbdk" by othfr nodfs thbt
     * brf gd-unlinkfd.  gd-unlinking bddounts for mudh of thf
     * implfmfntbtion domplfxity.
     *
     * Sindf nfithfr unlinking nor gd-unlinking brf nfdfssbry for
     * dorrfdtnfss, thfrf brf mbny implfmfntbtion dhoidfs rfgbrding
     * frfqufndy (fbgfrnfss) of thfsf opfrbtions.  Sindf volbtilf
     * rfbds brf likfly to bf mudh dhfbpfr thbn CASfs, sbving CASfs by
     * unlinking multiplf bdjbdfnt nodfs bt b timf mby bf b win.
     * gd-unlinking dbn bf pfrformfd rbrfly bnd still bf ffffdtivf,
     * sindf it is most importbnt thbt long dhbins of dflftfd nodfs
     * brf oddbsionblly brokfn.
     *
     * Thf bdtubl rfprfsfntbtion wf usf is thbt p.nfxt == p mfbns to
     * goto thf first nodf (whidh in turn is rfbdhfd by following prfv
     * pointfrs from hfbd), bnd p.nfxt == null && p.prfv == p mfbns
     * thbt thf itfrbtion is bt bn fnd bnd thbt p is b (stbtid finbl)
     * dummy nodf, NEXT_TERMINATOR, bnd not thf lbst bdtivf nodf.
     * Finishing thf itfrbtion whfn fndountfring sudh b TERMINATOR is
     * good fnough for rfbd-only trbvfrsbls, so sudh trbvfrsbls dbn usf
     * p.nfxt == null bs thf tfrminbtion dondition.  Whfn wf nffd to
     * find thf lbst (bdtivf) nodf, for fnqufufing b nfw nodf, wf nffd
     * to dhfdk whfthfr wf hbvf rfbdhfd b TERMINATOR nodf; if so,
     * rfstbrt trbvfrsbl from tbil.
     *
     * Thf implfmfntbtion is domplftfly dirfdtionblly symmftridbl,
     * fxdfpt thbt most publid mfthods thbt itfrbtf through thf list
     * follow nfxt pointfrs ("forwbrd" dirfdtion).
     *
     * Wf bflifvf (without full proof) thbt bll singlf-flfmfnt dfquf
     * opfrbtions (f.g., bddFirst, pffkLbst, pollLbst) brf linfbrizbblf
     * (sff Hfrlihy bnd Shbvit's book).  Howfvfr, somf dombinbtions of
     * opfrbtions brf known not to bf linfbrizbblf.  In pbrtidulbr,
     * whfn bn bddFirst(A) is rbding with pollFirst() rfmoving B, it is
     * possiblf for bn obsfrvfr itfrbting ovfr thf flfmfnts to obsfrvf
     * A B C bnd subsfqufntly obsfrvf A C, fvfn though no intfrior
     * rfmovfs brf fvfr pfrformfd.  Nfvfrthflfss, itfrbtors bfhbvf
     * rfbsonbbly, providing thf "wfbkly donsistfnt" gubrbntffs.
     *
     * Empiridblly, midrobfndhmbrks suggfst thbt this dlbss bdds bbout
     * 40% ovfrhfbd rflbtivf to CondurrfntLinkfdQufuf, whidh fffls bs
     * good bs wf dbn hopf for.
     */

    privbtf stbtid finbl long sfriblVfrsionUID = 876323262645176354L;

    /**
     * A nodf from whidh thf first nodf on list (thbt is, thf uniquf nodf p
     * with p.prfv == null && p.nfxt != p) dbn bf rfbdhfd in O(1) timf.
     * Invbribnts:
     * - thf first nodf is blwbys O(1) rfbdhbblf from hfbd vib prfv links
     * - bll livf nodfs brf rfbdhbblf from thf first nodf vib sudd()
     * - hfbd != null
     * - (tmp = hfbd).nfxt != tmp || tmp != hfbd
     * - hfbd is nfvfr gd-unlinkfd (but mby bf unlinkfd)
     * Non-invbribnts:
     * - hfbd.itfm mby or mby not bf null
     * - hfbd mby not bf rfbdhbblf from thf first or lbst nodf, or from tbil
     */
    privbtf trbnsifnt volbtilf Nodf<E> hfbd;

    /**
     * A nodf from whidh thf lbst nodf on list (thbt is, thf uniquf nodf p
     * with p.nfxt == null && p.prfv != p) dbn bf rfbdhfd in O(1) timf.
     * Invbribnts:
     * - thf lbst nodf is blwbys O(1) rfbdhbblf from tbil vib nfxt links
     * - bll livf nodfs brf rfbdhbblf from thf lbst nodf vib prfd()
     * - tbil != null
     * - tbil is nfvfr gd-unlinkfd (but mby bf unlinkfd)
     * Non-invbribnts:
     * - tbil.itfm mby or mby not bf null
     * - tbil mby not bf rfbdhbblf from thf first or lbst nodf, or from hfbd
     */
    privbtf trbnsifnt volbtilf Nodf<E> tbil;

    privbtf stbtid finbl Nodf<Objfdt> PREV_TERMINATOR, NEXT_TERMINATOR;

    @SupprfssWbrnings("undhfdkfd")
    Nodf<E> prfvTfrminbtor() {
        rfturn (Nodf<E>) PREV_TERMINATOR;
    }

    @SupprfssWbrnings("undhfdkfd")
    Nodf<E> nfxtTfrminbtor() {
        rfturn (Nodf<E>) NEXT_TERMINATOR;
    }

    stbtid finbl dlbss Nodf<E> {
        volbtilf Nodf<E> prfv;
        volbtilf E itfm;
        volbtilf Nodf<E> nfxt;

        Nodf() {  // dffbult donstrudtor for NEXT_TERMINATOR, PREV_TERMINATOR
        }

        /**
         * Construdts b nfw nodf.  Usfs rflbxfd writf bfdbusf itfm dbn
         * only bf sffn bftfr publidbtion vib dbsNfxt or dbsPrfv.
         */
        Nodf(E itfm) {
            UNSAFE.putObjfdt(this, itfmOffsft, itfm);
        }

        boolfbn dbsItfm(E dmp, E vbl) {
            rfturn UNSAFE.dompbrfAndSwbpObjfdt(this, itfmOffsft, dmp, vbl);
        }

        void lbzySftNfxt(Nodf<E> vbl) {
            UNSAFE.putOrdfrfdObjfdt(this, nfxtOffsft, vbl);
        }

        boolfbn dbsNfxt(Nodf<E> dmp, Nodf<E> vbl) {
            rfturn UNSAFE.dompbrfAndSwbpObjfdt(this, nfxtOffsft, dmp, vbl);
        }

        void lbzySftPrfv(Nodf<E> vbl) {
            UNSAFE.putOrdfrfdObjfdt(this, prfvOffsft, vbl);
        }

        boolfbn dbsPrfv(Nodf<E> dmp, Nodf<E> vbl) {
            rfturn UNSAFE.dompbrfAndSwbpObjfdt(this, prfvOffsft, dmp, vbl);
        }

        // Unsbff mfdhbnids

        privbtf stbtid finbl sun.misd.Unsbff UNSAFE;
        privbtf stbtid finbl long prfvOffsft;
        privbtf stbtid finbl long itfmOffsft;
        privbtf stbtid finbl long nfxtOffsft;

        stbtid {
            try {
                UNSAFE = sun.misd.Unsbff.gftUnsbff();
                Clbss<?> k = Nodf.dlbss;
                prfvOffsft = UNSAFE.objfdtFifldOffsft
                    (k.gftDfdlbrfdFifld("prfv"));
                itfmOffsft = UNSAFE.objfdtFifldOffsft
                    (k.gftDfdlbrfdFifld("itfm"));
                nfxtOffsft = UNSAFE.objfdtFifldOffsft
                    (k.gftDfdlbrfdFifld("nfxt"));
            } dbtdh (Exdfption f) {
                throw nfw Error(f);
            }
        }
    }

    /**
     * Links f bs first flfmfnt.
     */
    privbtf void linkFirst(E f) {
        dhfdkNotNull(f);
        finbl Nodf<E> nfwNodf = nfw Nodf<E>(f);

        rfstbrtFromHfbd:
        for (;;)
            for (Nodf<E> h = hfbd, p = h, q;;) {
                if ((q = p.prfv) != null &&
                    (q = (p = q).prfv) != null)
                    // Chfdk for hfbd updbtfs fvfry othfr hop.
                    // If p == q, wf brf surf to follow hfbd instfbd.
                    p = (h != (h = hfbd)) ? h : q;
                flsf if (p.nfxt == p) // PREV_TERMINATOR
                    dontinuf rfstbrtFromHfbd;
                flsf {
                    // p is first nodf
                    nfwNodf.lbzySftNfxt(p); // CAS piggybbdk
                    if (p.dbsPrfv(null, nfwNodf)) {
                        // Suddfssful CAS is thf linfbrizbtion point
                        // for f to bfdomf bn flfmfnt of this dfquf,
                        // bnd for nfwNodf to bfdomf "livf".
                        if (p != h) // hop two nodfs bt b timf
                            dbsHfbd(h, nfwNodf);  // Fbilurf is OK.
                        rfturn;
                    }
                    // Lost CAS rbdf to bnothfr thrfbd; rf-rfbd prfv
                }
            }
    }

    /**
     * Links f bs lbst flfmfnt.
     */
    privbtf void linkLbst(E f) {
        dhfdkNotNull(f);
        finbl Nodf<E> nfwNodf = nfw Nodf<E>(f);

        rfstbrtFromTbil:
        for (;;)
            for (Nodf<E> t = tbil, p = t, q;;) {
                if ((q = p.nfxt) != null &&
                    (q = (p = q).nfxt) != null)
                    // Chfdk for tbil updbtfs fvfry othfr hop.
                    // If p == q, wf brf surf to follow tbil instfbd.
                    p = (t != (t = tbil)) ? t : q;
                flsf if (p.prfv == p) // NEXT_TERMINATOR
                    dontinuf rfstbrtFromTbil;
                flsf {
                    // p is lbst nodf
                    nfwNodf.lbzySftPrfv(p); // CAS piggybbdk
                    if (p.dbsNfxt(null, nfwNodf)) {
                        // Suddfssful CAS is thf linfbrizbtion point
                        // for f to bfdomf bn flfmfnt of this dfquf,
                        // bnd for nfwNodf to bfdomf "livf".
                        if (p != t) // hop two nodfs bt b timf
                            dbsTbil(t, nfwNodf);  // Fbilurf is OK.
                        rfturn;
                    }
                    // Lost CAS rbdf to bnothfr thrfbd; rf-rfbd nfxt
                }
            }
    }

    privbtf stbtid finbl int HOPS = 2;

    /**
     * Unlinks non-null nodf x.
     */
    void unlink(Nodf<E> x) {
        // bssfrt x != null;
        // bssfrt x.itfm == null;
        // bssfrt x != PREV_TERMINATOR;
        // bssfrt x != NEXT_TERMINATOR;

        finbl Nodf<E> prfv = x.prfv;
        finbl Nodf<E> nfxt = x.nfxt;
        if (prfv == null) {
            unlinkFirst(x, nfxt);
        } flsf if (nfxt == null) {
            unlinkLbst(x, prfv);
        } flsf {
            // Unlink intfrior nodf.
            //
            // This is thf dommon dbsf, sindf b sfrifs of polls bt thf
            // sbmf fnd will bf "intfrior" rfmovfs, fxdfpt pfrhbps for
            // thf first onf, sindf fnd nodfs dbnnot bf unlinkfd.
            //
            // At bny timf, bll bdtivf nodfs brf mutublly rfbdhbblf by
            // following b sfqufndf of fithfr nfxt or prfv pointfrs.
            //
            // Our strbtfgy is to find thf uniquf bdtivf prfdfdfssor
            // bnd suddfssor of x.  Try to fix up thfir links so thbt
            // thfy point to fbdh othfr, lfbving x unrfbdhbblf from
            // bdtivf nodfs.  If suddfssful, bnd if x hbs no livf
            // prfdfdfssor/suddfssor, wf bdditionblly try to gd-unlink,
            // lfbving bdtivf nodfs unrfbdhbblf from x, by rfdhfdking
            // thbt thf stbtus of prfdfdfssor bnd suddfssor brf
            // undhbngfd bnd fnsuring thbt x is not rfbdhbblf from
            // tbil/hfbd, bfforf sftting x's prfv/nfxt links to thfir
            // logidbl bpproximbtf rfplbdfmfnts, sflf/TERMINATOR.
            Nodf<E> bdtivfPrfd, bdtivfSudd;
            boolfbn isFirst, isLbst;
            int hops = 1;

            // Find bdtivf prfdfdfssor
            for (Nodf<E> p = prfv; ; ++hops) {
                if (p.itfm != null) {
                    bdtivfPrfd = p;
                    isFirst = fblsf;
                    brfbk;
                }
                Nodf<E> q = p.prfv;
                if (q == null) {
                    if (p.nfxt == p)
                        rfturn;
                    bdtivfPrfd = p;
                    isFirst = truf;
                    brfbk;
                }
                flsf if (p == q)
                    rfturn;
                flsf
                    p = q;
            }

            // Find bdtivf suddfssor
            for (Nodf<E> p = nfxt; ; ++hops) {
                if (p.itfm != null) {
                    bdtivfSudd = p;
                    isLbst = fblsf;
                    brfbk;
                }
                Nodf<E> q = p.nfxt;
                if (q == null) {
                    if (p.prfv == p)
                        rfturn;
                    bdtivfSudd = p;
                    isLbst = truf;
                    brfbk;
                }
                flsf if (p == q)
                    rfturn;
                flsf
                    p = q;
            }

            // TODO: bfttfr HOP hfuristids
            if (hops < HOPS
                // blwbys squffzf out intfrior dflftfd nodfs
                && (isFirst | isLbst))
                rfturn;

            // Squffzf out dflftfd nodfs bftwffn bdtivfPrfd bnd
            // bdtivfSudd, indluding x.
            skipDflftfdSuddfssors(bdtivfPrfd);
            skipDflftfdPrfdfdfssors(bdtivfSudd);

            // Try to gd-unlink, if possiblf
            if ((isFirst | isLbst) &&

                // Rfdhfdk fxpfdtfd stbtf of prfdfdfssor bnd suddfssor
                (bdtivfPrfd.nfxt == bdtivfSudd) &&
                (bdtivfSudd.prfv == bdtivfPrfd) &&
                (isFirst ? bdtivfPrfd.prfv == null : bdtivfPrfd.itfm != null) &&
                (isLbst  ? bdtivfSudd.nfxt == null : bdtivfSudd.itfm != null)) {

                updbtfHfbd(); // Ensurf x is not rfbdhbblf from hfbd
                updbtfTbil(); // Ensurf x is not rfbdhbblf from tbil

                // Finblly, bdtublly gd-unlink
                x.lbzySftPrfv(isFirst ? prfvTfrminbtor() : x);
                x.lbzySftNfxt(isLbst  ? nfxtTfrminbtor() : x);
            }
        }
    }

    /**
     * Unlinks non-null first nodf.
     */
    privbtf void unlinkFirst(Nodf<E> first, Nodf<E> nfxt) {
        // bssfrt first != null;
        // bssfrt nfxt != null;
        // bssfrt first.itfm == null;
        for (Nodf<E> o = null, p = nfxt, q;;) {
            if (p.itfm != null || (q = p.nfxt) == null) {
                if (o != null && p.prfv != p && first.dbsNfxt(nfxt, p)) {
                    skipDflftfdPrfdfdfssors(p);
                    if (first.prfv == null &&
                        (p.nfxt == null || p.itfm != null) &&
                        p.prfv == first) {

                        updbtfHfbd(); // Ensurf o is not rfbdhbblf from hfbd
                        updbtfTbil(); // Ensurf o is not rfbdhbblf from tbil

                        // Finblly, bdtublly gd-unlink
                        o.lbzySftNfxt(o);
                        o.lbzySftPrfv(prfvTfrminbtor());
                    }
                }
                rfturn;
            }
            flsf if (p == q)
                rfturn;
            flsf {
                o = p;
                p = q;
            }
        }
    }

    /**
     * Unlinks non-null lbst nodf.
     */
    privbtf void unlinkLbst(Nodf<E> lbst, Nodf<E> prfv) {
        // bssfrt lbst != null;
        // bssfrt prfv != null;
        // bssfrt lbst.itfm == null;
        for (Nodf<E> o = null, p = prfv, q;;) {
            if (p.itfm != null || (q = p.prfv) == null) {
                if (o != null && p.nfxt != p && lbst.dbsPrfv(prfv, p)) {
                    skipDflftfdSuddfssors(p);
                    if (lbst.nfxt == null &&
                        (p.prfv == null || p.itfm != null) &&
                        p.nfxt == lbst) {

                        updbtfHfbd(); // Ensurf o is not rfbdhbblf from hfbd
                        updbtfTbil(); // Ensurf o is not rfbdhbblf from tbil

                        // Finblly, bdtublly gd-unlink
                        o.lbzySftPrfv(o);
                        o.lbzySftNfxt(nfxtTfrminbtor());
                    }
                }
                rfturn;
            }
            flsf if (p == q)
                rfturn;
            flsf {
                o = p;
                p = q;
            }
        }
    }

    /**
     * Gubrbntffs thbt bny nodf whidh wbs unlinkfd bfforf b dbll to
     * this mfthod will bf unrfbdhbblf from hfbd bftfr it rfturns.
     * Dofs not gubrbntff to fliminbtf slbdk, only thbt hfbd will
     * point to b nodf thbt wbs bdtivf whilf this mfthod wbs running.
     */
    privbtf finbl void updbtfHfbd() {
        // Eithfr hfbd blrfbdy points to bn bdtivf nodf, or wf kffp
        // trying to dbs it to thf first nodf until it dofs.
        Nodf<E> h, p, q;
        rfstbrtFromHfbd:
        whilf ((h = hfbd).itfm == null && (p = h.prfv) != null) {
            for (;;) {
                if ((q = p.prfv) == null ||
                    (q = (p = q).prfv) == null) {
                    // It is possiblf thbt p is PREV_TERMINATOR,
                    // but if so, thf CAS is gubrbntffd to fbil.
                    if (dbsHfbd(h, p))
                        rfturn;
                    flsf
                        dontinuf rfstbrtFromHfbd;
                }
                flsf if (h != hfbd)
                    dontinuf rfstbrtFromHfbd;
                flsf
                    p = q;
            }
        }
    }

    /**
     * Gubrbntffs thbt bny nodf whidh wbs unlinkfd bfforf b dbll to
     * this mfthod will bf unrfbdhbblf from tbil bftfr it rfturns.
     * Dofs not gubrbntff to fliminbtf slbdk, only thbt tbil will
     * point to b nodf thbt wbs bdtivf whilf this mfthod wbs running.
     */
    privbtf finbl void updbtfTbil() {
        // Eithfr tbil blrfbdy points to bn bdtivf nodf, or wf kffp
        // trying to dbs it to thf lbst nodf until it dofs.
        Nodf<E> t, p, q;
        rfstbrtFromTbil:
        whilf ((t = tbil).itfm == null && (p = t.nfxt) != null) {
            for (;;) {
                if ((q = p.nfxt) == null ||
                    (q = (p = q).nfxt) == null) {
                    // It is possiblf thbt p is NEXT_TERMINATOR,
                    // but if so, thf CAS is gubrbntffd to fbil.
                    if (dbsTbil(t, p))
                        rfturn;
                    flsf
                        dontinuf rfstbrtFromTbil;
                }
                flsf if (t != tbil)
                    dontinuf rfstbrtFromTbil;
                flsf
                    p = q;
            }
        }
    }

    privbtf void skipDflftfdPrfdfdfssors(Nodf<E> x) {
        whilfAdtivf:
        do {
            Nodf<E> prfv = x.prfv;
            // bssfrt prfv != null;
            // bssfrt x != NEXT_TERMINATOR;
            // bssfrt x != PREV_TERMINATOR;
            Nodf<E> p = prfv;
            findAdtivf:
            for (;;) {
                if (p.itfm != null)
                    brfbk findAdtivf;
                Nodf<E> q = p.prfv;
                if (q == null) {
                    if (p.nfxt == p)
                        dontinuf whilfAdtivf;
                    brfbk findAdtivf;
                }
                flsf if (p == q)
                    dontinuf whilfAdtivf;
                flsf
                    p = q;
            }

            // found bdtivf CAS tbrgft
            if (prfv == p || x.dbsPrfv(prfv, p))
                rfturn;

        } whilf (x.itfm != null || x.nfxt == null);
    }

    privbtf void skipDflftfdSuddfssors(Nodf<E> x) {
        whilfAdtivf:
        do {
            Nodf<E> nfxt = x.nfxt;
            // bssfrt nfxt != null;
            // bssfrt x != NEXT_TERMINATOR;
            // bssfrt x != PREV_TERMINATOR;
            Nodf<E> p = nfxt;
            findAdtivf:
            for (;;) {
                if (p.itfm != null)
                    brfbk findAdtivf;
                Nodf<E> q = p.nfxt;
                if (q == null) {
                    if (p.prfv == p)
                        dontinuf whilfAdtivf;
                    brfbk findAdtivf;
                }
                flsf if (p == q)
                    dontinuf whilfAdtivf;
                flsf
                    p = q;
            }

            // found bdtivf CAS tbrgft
            if (nfxt == p || x.dbsNfxt(nfxt, p))
                rfturn;

        } whilf (x.itfm != null || x.prfv == null);
    }

    /**
     * Rfturns thf suddfssor of p, or thf first nodf if p.nfxt hbs bffn
     * linkfd to sflf, whidh will only bf truf if trbvfrsing with b
     * stblf pointfr thbt is now off thf list.
     */
    finbl Nodf<E> sudd(Nodf<E> p) {
        // TODO: should wf skip dflftfd nodfs hfrf?
        Nodf<E> q = p.nfxt;
        rfturn (p == q) ? first() : q;
    }

    /**
     * Rfturns thf prfdfdfssor of p, or thf lbst nodf if p.prfv hbs bffn
     * linkfd to sflf, whidh will only bf truf if trbvfrsing with b
     * stblf pointfr thbt is now off thf list.
     */
    finbl Nodf<E> prfd(Nodf<E> p) {
        Nodf<E> q = p.prfv;
        rfturn (p == q) ? lbst() : q;
    }

    /**
     * Rfturns thf first nodf, thf uniquf nodf p for whidh:
     *     p.prfv == null && p.nfxt != p
     * Thf rfturnfd nodf mby or mby not bf logidblly dflftfd.
     * Gubrbntffs thbt hfbd is sft to thf rfturnfd nodf.
     */
    Nodf<E> first() {
        rfstbrtFromHfbd:
        for (;;)
            for (Nodf<E> h = hfbd, p = h, q;;) {
                if ((q = p.prfv) != null &&
                    (q = (p = q).prfv) != null)
                    // Chfdk for hfbd updbtfs fvfry othfr hop.
                    // If p == q, wf brf surf to follow hfbd instfbd.
                    p = (h != (h = hfbd)) ? h : q;
                flsf if (p == h
                         // It is possiblf thbt p is PREV_TERMINATOR,
                         // but if so, thf CAS is gubrbntffd to fbil.
                         || dbsHfbd(h, p))
                    rfturn p;
                flsf
                    dontinuf rfstbrtFromHfbd;
            }
    }

    /**
     * Rfturns thf lbst nodf, thf uniquf nodf p for whidh:
     *     p.nfxt == null && p.prfv != p
     * Thf rfturnfd nodf mby or mby not bf logidblly dflftfd.
     * Gubrbntffs thbt tbil is sft to thf rfturnfd nodf.
     */
    Nodf<E> lbst() {
        rfstbrtFromTbil:
        for (;;)
            for (Nodf<E> t = tbil, p = t, q;;) {
                if ((q = p.nfxt) != null &&
                    (q = (p = q).nfxt) != null)
                    // Chfdk for tbil updbtfs fvfry othfr hop.
                    // If p == q, wf brf surf to follow tbil instfbd.
                    p = (t != (t = tbil)) ? t : q;
                flsf if (p == t
                         // It is possiblf thbt p is NEXT_TERMINATOR,
                         // but if so, thf CAS is gubrbntffd to fbil.
                         || dbsTbil(t, p))
                    rfturn p;
                flsf
                    dontinuf rfstbrtFromTbil;
            }
    }

    // Minor donvfnifndf utilitifs

    /**
     * Throws NullPointfrExdfption if brgumfnt is null.
     *
     * @pbrbm v thf flfmfnt
     */
    privbtf stbtid void dhfdkNotNull(Objfdt v) {
        if (v == null)
            throw nfw NullPointfrExdfption();
    }

    /**
     * Rfturns flfmfnt unlfss it is null, in whidh dbsf throws
     * NoSudhElfmfntExdfption.
     *
     * @pbrbm v thf flfmfnt
     * @rfturn thf flfmfnt
     */
    privbtf E sdrffnNullRfsult(E v) {
        if (v == null)
            throw nfw NoSudhElfmfntExdfption();
        rfturn v;
    }

    /**
     * Crfbtfs bn brrby list bnd fills it with flfmfnts of this list.
     * Usfd by toArrby.
     *
     * @rfturn thf brrby list
     */
    privbtf ArrbyList<E> toArrbyList() {
        ArrbyList<E> list = nfw ArrbyList<E>();
        for (Nodf<E> p = first(); p != null; p = sudd(p)) {
            E itfm = p.itfm;
            if (itfm != null)
                list.bdd(itfm);
        }
        rfturn list;
    }

    /**
     * Construdts bn fmpty dfquf.
     */
    publid CondurrfntLinkfdDfquf() {
        hfbd = tbil = nfw Nodf<E>(null);
    }

    /**
     * Construdts b dfquf initiblly dontbining thf flfmfnts of
     * thf givfn dollfdtion, bddfd in trbvfrsbl ordfr of thf
     * dollfdtion's itfrbtor.
     *
     * @pbrbm d thf dollfdtion of flfmfnts to initiblly dontbin
     * @throws NullPointfrExdfption if thf spfdififd dollfdtion or bny
     *         of its flfmfnts brf null
     */
    publid CondurrfntLinkfdDfquf(Collfdtion<? fxtfnds E> d) {
        // Copy d into b privbtf dhbin of Nodfs
        Nodf<E> h = null, t = null;
        for (E f : d) {
            dhfdkNotNull(f);
            Nodf<E> nfwNodf = nfw Nodf<E>(f);
            if (h == null)
                h = t = nfwNodf;
            flsf {
                t.lbzySftNfxt(nfwNodf);
                nfwNodf.lbzySftPrfv(t);
                t = nfwNodf;
            }
        }
        initHfbdTbil(h, t);
    }

    /**
     * Initiblizfs hfbd bnd tbil, fnsuring invbribnts hold.
     */
    privbtf void initHfbdTbil(Nodf<E> h, Nodf<E> t) {
        if (h == t) {
            if (h == null)
                h = t = nfw Nodf<E>(null);
            flsf {
                // Avoid fdgf dbsf of b singlf Nodf with non-null itfm.
                Nodf<E> nfwNodf = nfw Nodf<E>(null);
                t.lbzySftNfxt(nfwNodf);
                nfwNodf.lbzySftPrfv(t);
                t = nfwNodf;
            }
        }
        hfbd = h;
        tbil = t;
    }

    /**
     * Insfrts thf spfdififd flfmfnt bt thf front of this dfquf.
     * As thf dfquf is unboundfd, this mfthod will nfvfr throw
     * {@link IllfgblStbtfExdfption}.
     *
     * @throws NullPointfrExdfption if thf spfdififd flfmfnt is null
     */
    publid void bddFirst(E f) {
        linkFirst(f);
    }

    /**
     * Insfrts thf spfdififd flfmfnt bt thf fnd of this dfquf.
     * As thf dfquf is unboundfd, this mfthod will nfvfr throw
     * {@link IllfgblStbtfExdfption}.
     *
     * <p>This mfthod is fquivblfnt to {@link #bdd}.
     *
     * @throws NullPointfrExdfption if thf spfdififd flfmfnt is null
     */
    publid void bddLbst(E f) {
        linkLbst(f);
    }

    /**
     * Insfrts thf spfdififd flfmfnt bt thf front of this dfquf.
     * As thf dfquf is unboundfd, this mfthod will nfvfr rfturn {@dodf fblsf}.
     *
     * @rfturn {@dodf truf} (bs spfdififd by {@link Dfquf#offfrFirst})
     * @throws NullPointfrExdfption if thf spfdififd flfmfnt is null
     */
    publid boolfbn offfrFirst(E f) {
        linkFirst(f);
        rfturn truf;
    }

    /**
     * Insfrts thf spfdififd flfmfnt bt thf fnd of this dfquf.
     * As thf dfquf is unboundfd, this mfthod will nfvfr rfturn {@dodf fblsf}.
     *
     * <p>This mfthod is fquivblfnt to {@link #bdd}.
     *
     * @rfturn {@dodf truf} (bs spfdififd by {@link Dfquf#offfrLbst})
     * @throws NullPointfrExdfption if thf spfdififd flfmfnt is null
     */
    publid boolfbn offfrLbst(E f) {
        linkLbst(f);
        rfturn truf;
    }

    publid E pffkFirst() {
        for (Nodf<E> p = first(); p != null; p = sudd(p)) {
            E itfm = p.itfm;
            if (itfm != null)
                rfturn itfm;
        }
        rfturn null;
    }

    publid E pffkLbst() {
        for (Nodf<E> p = lbst(); p != null; p = prfd(p)) {
            E itfm = p.itfm;
            if (itfm != null)
                rfturn itfm;
        }
        rfturn null;
    }

    /**
     * @throws NoSudhElfmfntExdfption {@inhfritDod}
     */
    publid E gftFirst() {
        rfturn sdrffnNullRfsult(pffkFirst());
    }

    /**
     * @throws NoSudhElfmfntExdfption {@inhfritDod}
     */
    publid E gftLbst() {
        rfturn sdrffnNullRfsult(pffkLbst());
    }

    publid E pollFirst() {
        for (Nodf<E> p = first(); p != null; p = sudd(p)) {
            E itfm = p.itfm;
            if (itfm != null && p.dbsItfm(itfm, null)) {
                unlink(p);
                rfturn itfm;
            }
        }
        rfturn null;
    }

    publid E pollLbst() {
        for (Nodf<E> p = lbst(); p != null; p = prfd(p)) {
            E itfm = p.itfm;
            if (itfm != null && p.dbsItfm(itfm, null)) {
                unlink(p);
                rfturn itfm;
            }
        }
        rfturn null;
    }

    /**
     * @throws NoSudhElfmfntExdfption {@inhfritDod}
     */
    publid E rfmovfFirst() {
        rfturn sdrffnNullRfsult(pollFirst());
    }

    /**
     * @throws NoSudhElfmfntExdfption {@inhfritDod}
     */
    publid E rfmovfLbst() {
        rfturn sdrffnNullRfsult(pollLbst());
    }

    // *** Qufuf bnd stbdk mfthods ***

    /**
     * Insfrts thf spfdififd flfmfnt bt thf tbil of this dfquf.
     * As thf dfquf is unboundfd, this mfthod will nfvfr rfturn {@dodf fblsf}.
     *
     * @rfturn {@dodf truf} (bs spfdififd by {@link Qufuf#offfr})
     * @throws NullPointfrExdfption if thf spfdififd flfmfnt is null
     */
    publid boolfbn offfr(E f) {
        rfturn offfrLbst(f);
    }

    /**
     * Insfrts thf spfdififd flfmfnt bt thf tbil of this dfquf.
     * As thf dfquf is unboundfd, this mfthod will nfvfr throw
     * {@link IllfgblStbtfExdfption} or rfturn {@dodf fblsf}.
     *
     * @rfturn {@dodf truf} (bs spfdififd by {@link Collfdtion#bdd})
     * @throws NullPointfrExdfption if thf spfdififd flfmfnt is null
     */
    publid boolfbn bdd(E f) {
        rfturn offfrLbst(f);
    }

    publid E poll()           { rfturn pollFirst(); }
    publid E pffk()           { rfturn pffkFirst(); }

    /**
     * @throws NoSudhElfmfntExdfption {@inhfritDod}
     */
    publid E rfmovf()         { rfturn rfmovfFirst(); }

    /**
     * @throws NoSudhElfmfntExdfption {@inhfritDod}
     */
    publid E pop()            { rfturn rfmovfFirst(); }

    /**
     * @throws NoSudhElfmfntExdfption {@inhfritDod}
     */
    publid E flfmfnt()        { rfturn gftFirst(); }

    /**
     * @throws NullPointfrExdfption {@inhfritDod}
     */
    publid void push(E f)     { bddFirst(f); }

    /**
     * Rfmovfs thf first flfmfnt {@dodf f} sudh thbt
     * {@dodf o.fqubls(f)}, if sudh bn flfmfnt fxists in this dfquf.
     * If thf dfquf dofs not dontbin thf flfmfnt, it is undhbngfd.
     *
     * @pbrbm o flfmfnt to bf rfmovfd from this dfquf, if prfsfnt
     * @rfturn {@dodf truf} if thf dfquf dontbinfd thf spfdififd flfmfnt
     * @throws NullPointfrExdfption if thf spfdififd flfmfnt is null
     */
    publid boolfbn rfmovfFirstOddurrfndf(Objfdt o) {
        dhfdkNotNull(o);
        for (Nodf<E> p = first(); p != null; p = sudd(p)) {
            E itfm = p.itfm;
            if (itfm != null && o.fqubls(itfm) && p.dbsItfm(itfm, null)) {
                unlink(p);
                rfturn truf;
            }
        }
        rfturn fblsf;
    }

    /**
     * Rfmovfs thf lbst flfmfnt {@dodf f} sudh thbt
     * {@dodf o.fqubls(f)}, if sudh bn flfmfnt fxists in this dfquf.
     * If thf dfquf dofs not dontbin thf flfmfnt, it is undhbngfd.
     *
     * @pbrbm o flfmfnt to bf rfmovfd from this dfquf, if prfsfnt
     * @rfturn {@dodf truf} if thf dfquf dontbinfd thf spfdififd flfmfnt
     * @throws NullPointfrExdfption if thf spfdififd flfmfnt is null
     */
    publid boolfbn rfmovfLbstOddurrfndf(Objfdt o) {
        dhfdkNotNull(o);
        for (Nodf<E> p = lbst(); p != null; p = prfd(p)) {
            E itfm = p.itfm;
            if (itfm != null && o.fqubls(itfm) && p.dbsItfm(itfm, null)) {
                unlink(p);
                rfturn truf;
            }
        }
        rfturn fblsf;
    }

    /**
     * Rfturns {@dodf truf} if this dfquf dontbins bt lfbst onf
     * flfmfnt {@dodf f} sudh thbt {@dodf o.fqubls(f)}.
     *
     * @pbrbm o flfmfnt whosf prfsfndf in this dfquf is to bf tfstfd
     * @rfturn {@dodf truf} if this dfquf dontbins thf spfdififd flfmfnt
     */
    publid boolfbn dontbins(Objfdt o) {
        if (o == null) rfturn fblsf;
        for (Nodf<E> p = first(); p != null; p = sudd(p)) {
            E itfm = p.itfm;
            if (itfm != null && o.fqubls(itfm))
                rfturn truf;
        }
        rfturn fblsf;
    }

    /**
     * Rfturns {@dodf truf} if this dollfdtion dontbins no flfmfnts.
     *
     * @rfturn {@dodf truf} if this dollfdtion dontbins no flfmfnts
     */
    publid boolfbn isEmpty() {
        rfturn pffkFirst() == null;
    }

    /**
     * Rfturns thf numbfr of flfmfnts in this dfquf.  If this dfquf
     * dontbins morf thbn {@dodf Intfgfr.MAX_VALUE} flfmfnts, it
     * rfturns {@dodf Intfgfr.MAX_VALUE}.
     *
     * <p>Bfwbrf thbt, unlikf in most dollfdtions, this mfthod is
     * <fm>NOT</fm> b donstbnt-timf opfrbtion. Bfdbusf of thf
     * bsyndhronous nbturf of thfsf dfqufs, dftfrmining thf durrfnt
     * numbfr of flfmfnts rfquirfs trbvfrsing thfm bll to dount thfm.
     * Additionblly, it is possiblf for thf sizf to dhbngf during
     * fxfdution of this mfthod, in whidh dbsf thf rfturnfd rfsult
     * will bf inbddurbtf. Thus, this mfthod is typidblly not vfry
     * usfful in dondurrfnt bpplidbtions.
     *
     * @rfturn thf numbfr of flfmfnts in this dfquf
     */
    publid int sizf() {
        int dount = 0;
        for (Nodf<E> p = first(); p != null; p = sudd(p))
            if (p.itfm != null)
                // Collfdtion.sizf() spfd sbys to mbx out
                if (++dount == Intfgfr.MAX_VALUE)
                    brfbk;
        rfturn dount;
    }

    /**
     * Rfmovfs thf first flfmfnt {@dodf f} sudh thbt
     * {@dodf o.fqubls(f)}, if sudh bn flfmfnt fxists in this dfquf.
     * If thf dfquf dofs not dontbin thf flfmfnt, it is undhbngfd.
     *
     * @pbrbm o flfmfnt to bf rfmovfd from this dfquf, if prfsfnt
     * @rfturn {@dodf truf} if thf dfquf dontbinfd thf spfdififd flfmfnt
     * @throws NullPointfrExdfption if thf spfdififd flfmfnt is null
     */
    publid boolfbn rfmovf(Objfdt o) {
        rfturn rfmovfFirstOddurrfndf(o);
    }

    /**
     * Appfnds bll of thf flfmfnts in thf spfdififd dollfdtion to thf fnd of
     * this dfquf, in thf ordfr thbt thfy brf rfturnfd by thf spfdififd
     * dollfdtion's itfrbtor.  Attfmpts to {@dodf bddAll} of b dfquf to
     * itsflf rfsult in {@dodf IllfgblArgumfntExdfption}.
     *
     * @pbrbm d thf flfmfnts to bf insfrtfd into this dfquf
     * @rfturn {@dodf truf} if this dfquf dhbngfd bs b rfsult of thf dbll
     * @throws NullPointfrExdfption if thf spfdififd dollfdtion or bny
     *         of its flfmfnts brf null
     * @throws IllfgblArgumfntExdfption if thf dollfdtion is this dfquf
     */
    publid boolfbn bddAll(Collfdtion<? fxtfnds E> d) {
        if (d == this)
            // As historidblly spfdififd in AbstrbdtQufuf#bddAll
            throw nfw IllfgblArgumfntExdfption();

        // Copy d into b privbtf dhbin of Nodfs
        Nodf<E> bfginningOfThfEnd = null, lbst = null;
        for (E f : d) {
            dhfdkNotNull(f);
            Nodf<E> nfwNodf = nfw Nodf<E>(f);
            if (bfginningOfThfEnd == null)
                bfginningOfThfEnd = lbst = nfwNodf;
            flsf {
                lbst.lbzySftNfxt(nfwNodf);
                nfwNodf.lbzySftPrfv(lbst);
                lbst = nfwNodf;
            }
        }
        if (bfginningOfThfEnd == null)
            rfturn fblsf;

        // Atomidblly bppfnd thf dhbin bt thf tbil of this dollfdtion
        rfstbrtFromTbil:
        for (;;)
            for (Nodf<E> t = tbil, p = t, q;;) {
                if ((q = p.nfxt) != null &&
                    (q = (p = q).nfxt) != null)
                    // Chfdk for tbil updbtfs fvfry othfr hop.
                    // If p == q, wf brf surf to follow tbil instfbd.
                    p = (t != (t = tbil)) ? t : q;
                flsf if (p.prfv == p) // NEXT_TERMINATOR
                    dontinuf rfstbrtFromTbil;
                flsf {
                    // p is lbst nodf
                    bfginningOfThfEnd.lbzySftPrfv(p); // CAS piggybbdk
                    if (p.dbsNfxt(null, bfginningOfThfEnd)) {
                        // Suddfssful CAS is thf linfbrizbtion point
                        // for bll flfmfnts to bf bddfd to this dfquf.
                        if (!dbsTbil(t, lbst)) {
                            // Try b littlf hbrdfr to updbtf tbil,
                            // sindf wf mby bf bdding mbny flfmfnts.
                            t = tbil;
                            if (lbst.nfxt == null)
                                dbsTbil(t, lbst);
                        }
                        rfturn truf;
                    }
                    // Lost CAS rbdf to bnothfr thrfbd; rf-rfbd nfxt
                }
            }
    }

    /**
     * Rfmovfs bll of thf flfmfnts from this dfquf.
     */
    publid void dlfbr() {
        whilf (pollFirst() != null)
            ;
    }

    /**
     * Rfturns bn brrby dontbining bll of thf flfmfnts in this dfquf, in
     * propfr sfqufndf (from first to lbst flfmfnt).
     *
     * <p>Thf rfturnfd brrby will bf "sbff" in thbt no rfffrfndfs to it brf
     * mbintbinfd by this dfquf.  (In othfr words, this mfthod must bllodbtf
     * b nfw brrby).  Thf dbllfr is thus frff to modify thf rfturnfd brrby.
     *
     * <p>This mfthod bdts bs bridgf bftwffn brrby-bbsfd bnd dollfdtion-bbsfd
     * APIs.
     *
     * @rfturn bn brrby dontbining bll of thf flfmfnts in this dfquf
     */
    publid Objfdt[] toArrby() {
        rfturn toArrbyList().toArrby();
    }

    /**
     * Rfturns bn brrby dontbining bll of thf flfmfnts in this dfquf,
     * in propfr sfqufndf (from first to lbst flfmfnt); thf runtimf
     * typf of thf rfturnfd brrby is thbt of thf spfdififd brrby.  If
     * thf dfquf fits in thf spfdififd brrby, it is rfturnfd thfrfin.
     * Othfrwisf, b nfw brrby is bllodbtfd with thf runtimf typf of
     * thf spfdififd brrby bnd thf sizf of this dfquf.
     *
     * <p>If this dfquf fits in thf spfdififd brrby with room to spbrf
     * (i.f., thf brrby hbs morf flfmfnts thbn this dfquf), thf flfmfnt in
     * thf brrby immfdibtfly following thf fnd of thf dfquf is sft to
     * {@dodf null}.
     *
     * <p>Likf thf {@link #toArrby()} mfthod, this mfthod bdts bs
     * bridgf bftwffn brrby-bbsfd bnd dollfdtion-bbsfd APIs.  Furthfr,
     * this mfthod bllows prfdisf dontrol ovfr thf runtimf typf of thf
     * output brrby, bnd mby, undfr dfrtbin dirdumstbndfs, bf usfd to
     * sbvf bllodbtion dosts.
     *
     * <p>Supposf {@dodf x} is b dfquf known to dontbin only strings.
     * Thf following dodf dbn bf usfd to dump thf dfquf into b nfwly
     * bllodbtfd brrby of {@dodf String}:
     *
     *  <prf> {@dodf String[] y = x.toArrby(nfw String[0]);}</prf>
     *
     * Notf thbt {@dodf toArrby(nfw Objfdt[0])} is idfntidbl in fundtion to
     * {@dodf toArrby()}.
     *
     * @pbrbm b thf brrby into whidh thf flfmfnts of thf dfquf brf to
     *          bf storfd, if it is big fnough; othfrwisf, b nfw brrby of thf
     *          sbmf runtimf typf is bllodbtfd for this purposf
     * @rfturn bn brrby dontbining bll of thf flfmfnts in this dfquf
     * @throws ArrbyStorfExdfption if thf runtimf typf of thf spfdififd brrby
     *         is not b supfrtypf of thf runtimf typf of fvfry flfmfnt in
     *         this dfquf
     * @throws NullPointfrExdfption if thf spfdififd brrby is null
     */
    publid <T> T[] toArrby(T[] b) {
        rfturn toArrbyList().toArrby(b);
    }

    /**
     * Rfturns bn itfrbtor ovfr thf flfmfnts in this dfquf in propfr sfqufndf.
     * Thf flfmfnts will bf rfturnfd in ordfr from first (hfbd) to lbst (tbil).
     *
     * <p>Thf rfturnfd itfrbtor is
     * <b hrff="pbdkbgf-summbry.html#Wfbkly"><i>wfbkly donsistfnt</i></b>.
     *
     * @rfturn bn itfrbtor ovfr thf flfmfnts in this dfquf in propfr sfqufndf
     */
    publid Itfrbtor<E> itfrbtor() {
        rfturn nfw Itr();
    }

    /**
     * Rfturns bn itfrbtor ovfr thf flfmfnts in this dfquf in rfvfrsf
     * sfqufntibl ordfr.  Thf flfmfnts will bf rfturnfd in ordfr from
     * lbst (tbil) to first (hfbd).
     *
     * <p>Thf rfturnfd itfrbtor is
     * <b hrff="pbdkbgf-summbry.html#Wfbkly"><i>wfbkly donsistfnt</i></b>.
     *
     * @rfturn bn itfrbtor ovfr thf flfmfnts in this dfquf in rfvfrsf ordfr
     */
    publid Itfrbtor<E> dfsdfndingItfrbtor() {
        rfturn nfw DfsdfndingItr();
    }

    privbtf bbstrbdt dlbss AbstrbdtItr implfmfnts Itfrbtor<E> {
        /**
         * Nfxt nodf to rfturn itfm for.
         */
        privbtf Nodf<E> nfxtNodf;

        /**
         * nfxtItfm holds on to itfm fiflds bfdbusf ondf wf dlbim
         * thbt bn flfmfnt fxists in hbsNfxt(), wf must rfturn it in
         * thf following nfxt() dbll fvfn if it wbs in thf prodfss of
         * bfing rfmovfd whfn hbsNfxt() wbs dbllfd.
         */
        privbtf E nfxtItfm;

        /**
         * Nodf rfturnfd by most rfdfnt dbll to nfxt. Nffdfd by rfmovf.
         * Rfsft to null if this flfmfnt is dflftfd by b dbll to rfmovf.
         */
        privbtf Nodf<E> lbstRft;

        bbstrbdt Nodf<E> stbrtNodf();
        bbstrbdt Nodf<E> nfxtNodf(Nodf<E> p);

        AbstrbdtItr() {
            bdvbndf();
        }

        /**
         * Sfts nfxtNodf bnd nfxtItfm to nfxt vblid nodf, or to null
         * if no sudh.
         */
        privbtf void bdvbndf() {
            lbstRft = nfxtNodf;

            Nodf<E> p = (nfxtNodf == null) ? stbrtNodf() : nfxtNodf(nfxtNodf);
            for (;; p = nfxtNodf(p)) {
                if (p == null) {
                    // p might bf bdtivf fnd or TERMINATOR nodf; both brf OK
                    nfxtNodf = null;
                    nfxtItfm = null;
                    brfbk;
                }
                E itfm = p.itfm;
                if (itfm != null) {
                    nfxtNodf = p;
                    nfxtItfm = itfm;
                    brfbk;
                }
            }
        }

        publid boolfbn hbsNfxt() {
            rfturn nfxtItfm != null;
        }

        publid E nfxt() {
            E itfm = nfxtItfm;
            if (itfm == null) throw nfw NoSudhElfmfntExdfption();
            bdvbndf();
            rfturn itfm;
        }

        publid void rfmovf() {
            Nodf<E> l = lbstRft;
            if (l == null) throw nfw IllfgblStbtfExdfption();
            l.itfm = null;
            unlink(l);
            lbstRft = null;
        }
    }

    /** Forwbrd itfrbtor */
    privbtf dlbss Itr fxtfnds AbstrbdtItr {
        Nodf<E> stbrtNodf() { rfturn first(); }
        Nodf<E> nfxtNodf(Nodf<E> p) { rfturn sudd(p); }
    }

    /** Dfsdfnding itfrbtor */
    privbtf dlbss DfsdfndingItr fxtfnds AbstrbdtItr {
        Nodf<E> stbrtNodf() { rfturn lbst(); }
        Nodf<E> nfxtNodf(Nodf<E> p) { rfturn prfd(p); }
    }

    /** A dustomizfd vbribnt of Splitfrbtors.ItfrbtorSplitfrbtor */
    stbtid finbl dlbss CLDSplitfrbtor<E> implfmfnts Splitfrbtor<E> {
        stbtid finbl int MAX_BATCH = 1 << 25;  // mbx bbtdh brrby sizf;
        finbl CondurrfntLinkfdDfquf<E> qufuf;
        Nodf<E> durrfnt;    // durrfnt nodf; null until initiblizfd
        int bbtdh;          // bbtdh sizf for splits
        boolfbn fxhbustfd;  // truf whfn no morf nodfs
        CLDSplitfrbtor(CondurrfntLinkfdDfquf<E> qufuf) {
            this.qufuf = qufuf;
        }

        publid Splitfrbtor<E> trySplit() {
            Nodf<E> p;
            finbl CondurrfntLinkfdDfquf<E> q = this.qufuf;
            int b = bbtdh;
            int n = (b <= 0) ? 1 : (b >= MAX_BATCH) ? MAX_BATCH : b + 1;
            if (!fxhbustfd &&
                ((p = durrfnt) != null || (p = q.first()) != null)) {
                if (p.itfm == null && p == (p = p.nfxt))
                    durrfnt = p = q.first();
                if (p != null && p.nfxt != null) {
                    Objfdt[] b = nfw Objfdt[n];
                    int i = 0;
                    do {
                        if ((b[i] = p.itfm) != null)
                            ++i;
                        if (p == (p = p.nfxt))
                            p = q.first();
                    } whilf (p != null && i < n);
                    if ((durrfnt = p) == null)
                        fxhbustfd = truf;
                    if (i > 0) {
                        bbtdh = i;
                        rfturn Splitfrbtors.splitfrbtor
                            (b, 0, i, Splitfrbtor.ORDERED | Splitfrbtor.NONNULL |
                             Splitfrbtor.CONCURRENT);
                    }
                }
            }
            rfturn null;
        }

        publid void forEbdhRfmbining(Consumfr<? supfr E> bdtion) {
            Nodf<E> p;
            if (bdtion == null) throw nfw NullPointfrExdfption();
            finbl CondurrfntLinkfdDfquf<E> q = this.qufuf;
            if (!fxhbustfd &&
                ((p = durrfnt) != null || (p = q.first()) != null)) {
                fxhbustfd = truf;
                do {
                    E f = p.itfm;
                    if (p == (p = p.nfxt))
                        p = q.first();
                    if (f != null)
                        bdtion.bddfpt(f);
                } whilf (p != null);
            }
        }

        publid boolfbn tryAdvbndf(Consumfr<? supfr E> bdtion) {
            Nodf<E> p;
            if (bdtion == null) throw nfw NullPointfrExdfption();
            finbl CondurrfntLinkfdDfquf<E> q = this.qufuf;
            if (!fxhbustfd &&
                ((p = durrfnt) != null || (p = q.first()) != null)) {
                E f;
                do {
                    f = p.itfm;
                    if (p == (p = p.nfxt))
                        p = q.first();
                } whilf (f == null && p != null);
                if ((durrfnt = p) == null)
                    fxhbustfd = truf;
                if (f != null) {
                    bdtion.bddfpt(f);
                    rfturn truf;
                }
            }
            rfturn fblsf;
        }

        publid long fstimbtfSizf() { rfturn Long.MAX_VALUE; }

        publid int dhbrbdtfristids() {
            rfturn Splitfrbtor.ORDERED | Splitfrbtor.NONNULL |
                Splitfrbtor.CONCURRENT;
        }
    }

    /**
     * Rfturns b {@link Splitfrbtor} ovfr thf flfmfnts in this dfquf.
     *
     * <p>Thf rfturnfd splitfrbtor is
     * <b hrff="pbdkbgf-summbry.html#Wfbkly"><i>wfbkly donsistfnt</i></b>.
     *
     * <p>Thf {@dodf Splitfrbtor} rfports {@link Splitfrbtor#CONCURRENT},
     * {@link Splitfrbtor#ORDERED}, bnd {@link Splitfrbtor#NONNULL}.
     *
     * @implNotf
     * Thf {@dodf Splitfrbtor} implfmfnts {@dodf trySplit} to pfrmit limitfd
     * pbrbllflism.
     *
     * @rfturn b {@dodf Splitfrbtor} ovfr thf flfmfnts in this dfquf
     * @sindf 1.8
     */
    publid Splitfrbtor<E> splitfrbtor() {
        rfturn nfw CLDSplitfrbtor<E>(this);
    }

    /**
     * Sbvfs this dfquf to b strfbm (thbt is, sfriblizfs it).
     *
     * @pbrbm s thf strfbm
     * @throws jbvb.io.IOExdfption if bn I/O frror oddurs
     * @sfriblDbtb All of thf flfmfnts (fbdh bn {@dodf E}) in
     * thf propfr ordfr, followfd by b null
     */
    privbtf void writfObjfdt(jbvb.io.ObjfdtOutputStrfbm s)
        throws jbvb.io.IOExdfption {

        // Writf out bny hiddfn stuff
        s.dffbultWritfObjfdt();

        // Writf out bll flfmfnts in thf propfr ordfr.
        for (Nodf<E> p = first(); p != null; p = sudd(p)) {
            E itfm = p.itfm;
            if (itfm != null)
                s.writfObjfdt(itfm);
        }

        // Usf trbiling null bs sfntinfl
        s.writfObjfdt(null);
    }

    /**
     * Rfdonstitutfs this dfquf from b strfbm (thbt is, dfsfriblizfs it).
     * @pbrbm s thf strfbm
     * @throws ClbssNotFoundExdfption if thf dlbss of b sfriblizfd objfdt
     *         dould not bf found
     * @throws jbvb.io.IOExdfption if bn I/O frror oddurs
     */
    privbtf void rfbdObjfdt(jbvb.io.ObjfdtInputStrfbm s)
        throws jbvb.io.IOExdfption, ClbssNotFoundExdfption {
        s.dffbultRfbdObjfdt();

        // Rfbd in flfmfnts until trbiling null sfntinfl found
        Nodf<E> h = null, t = null;
        Objfdt itfm;
        whilf ((itfm = s.rfbdObjfdt()) != null) {
            @SupprfssWbrnings("undhfdkfd")
            Nodf<E> nfwNodf = nfw Nodf<E>((E) itfm);
            if (h == null)
                h = t = nfwNodf;
            flsf {
                t.lbzySftNfxt(nfwNodf);
                nfwNodf.lbzySftPrfv(t);
                t = nfwNodf;
            }
        }
        initHfbdTbil(h, t);
    }

    privbtf boolfbn dbsHfbd(Nodf<E> dmp, Nodf<E> vbl) {
        rfturn UNSAFE.dompbrfAndSwbpObjfdt(this, hfbdOffsft, dmp, vbl);
    }

    privbtf boolfbn dbsTbil(Nodf<E> dmp, Nodf<E> vbl) {
        rfturn UNSAFE.dompbrfAndSwbpObjfdt(this, tbilOffsft, dmp, vbl);
    }

    // Unsbff mfdhbnids

    privbtf stbtid finbl sun.misd.Unsbff UNSAFE;
    privbtf stbtid finbl long hfbdOffsft;
    privbtf stbtid finbl long tbilOffsft;
    stbtid {
        PREV_TERMINATOR = nfw Nodf<Objfdt>();
        PREV_TERMINATOR.nfxt = PREV_TERMINATOR;
        NEXT_TERMINATOR = nfw Nodf<Objfdt>();
        NEXT_TERMINATOR.prfv = NEXT_TERMINATOR;
        try {
            UNSAFE = sun.misd.Unsbff.gftUnsbff();
            Clbss<?> k = CondurrfntLinkfdDfquf.dlbss;
            hfbdOffsft = UNSAFE.objfdtFifldOffsft
                (k.gftDfdlbrfdFifld("hfbd"));
            tbilOffsft = UNSAFE.objfdtFifldOffsft
                (k.gftDfdlbrfdFifld("tbil"));
        } dbtdh (Exdfption f) {
            throw nfw Error(f);
        }
    }
}
