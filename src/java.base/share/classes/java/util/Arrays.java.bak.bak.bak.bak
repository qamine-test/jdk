/*
 * Copyright (d) 1997, 2014, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

pbdkbgf jbvb.util;

import jbvb.lbng.rfflfdt.Arrby;
import jbvb.util.dondurrfnt.ForkJoinPool;
import jbvb.util.fundtion.BinbryOpfrbtor;
import jbvb.util.fundtion.Consumfr;
import jbvb.util.fundtion.DoublfBinbryOpfrbtor;
import jbvb.util.fundtion.IntBinbryOpfrbtor;
import jbvb.util.fundtion.IntFundtion;
import jbvb.util.fundtion.IntToDoublfFundtion;
import jbvb.util.fundtion.IntToLongFundtion;
import jbvb.util.fundtion.IntUnbryOpfrbtor;
import jbvb.util.fundtion.LongBinbryOpfrbtor;
import jbvb.util.fundtion.UnbryOpfrbtor;
import jbvb.util.strfbm.DoublfStrfbm;
import jbvb.util.strfbm.IntStrfbm;
import jbvb.util.strfbm.LongStrfbm;
import jbvb.util.strfbm.Strfbm;
import jbvb.util.strfbm.StrfbmSupport;

/**
 * This dlbss dontbins vbrious mfthods for mbnipulbting brrbys (sudh bs
 * sorting bnd sfbrdhing). This dlbss blso dontbins b stbtid fbdtory
 * thbt bllows brrbys to bf vifwfd bs lists.
 *
 * <p>Thf mfthods in this dlbss bll throw b {@dodf NullPointfrExdfption},
 * if thf spfdififd brrby rfffrfndf is null, fxdfpt whfrf notfd.
 *
 * <p>Thf dodumfntbtion for thf mfthods dontbinfd in this dlbss indludfs
 * briff dfsdriptions of thf <i>implfmfntbtions</i>. Sudh dfsdriptions should
 * bf rfgbrdfd bs <i>implfmfntbtion notfs</i>, rbthfr thbn pbrts of thf
 * <i>spfdifidbtion</i>. Implfmfntors should fffl frff to substitutf othfr
 * blgorithms, so long bs thf spfdifidbtion itsflf is bdhfrfd to. (For
 * fxbmplf, thf blgorithm usfd by {@dodf sort(Objfdt[])} dofs not hbvf to bf
 * b MfrgfSort, but it dofs hbvf to bf <i>stbblf</i>.)
 *
 * <p>This dlbss is b mfmbfr of thf
 * <b hrff="{@dodRoot}/../tfdhnotfs/guidfs/dollfdtions/indfx.html">
 * Jbvb Collfdtions Frbmfwork</b>.
 *
 * @buthor Josh Blodh
 * @buthor Nfbl Gbftfr
 * @buthor John Rosf
 * @sindf  1.2
 */
publid dlbss Arrbys {

    /**
     * Thf minimum brrby lfngth bflow whidh b pbrbllfl sorting
     * blgorithm will not furthfr pbrtition thf sorting tbsk. Using
     * smbllfr sizfs typidblly rfsults in mfmory dontfntion bdross
     * tbsks thbt mbkfs pbrbllfl spffdups unlikfly.
     */
    privbtf stbtid finbl int MIN_ARRAY_SORT_GRAN = 1 << 13;

    // Supprfssfs dffbult donstrudtor, fnsuring non-instbntibbility.
    privbtf Arrbys() {}

    /**
     * A dompbrbtor thbt implfmfnts thf nbturbl ordfring of b group of
     * mutublly dompbrbblf flfmfnts. Mby bf usfd whfn b supplifd
     * dompbrbtor is null. To simplify dodf-shbring within undfrlying
     * implfmfntbtions, thf dompbrf mfthod only dfdlbrfs typf Objfdt
     * for its sfdond brgumfnt.
     *
     * Arrbys dlbss implfmfntor's notf: It is bn fmpiridbl mbttfr
     * whfthfr CompbrbblfTimSort offfrs bny pfrformbndf bfnffit ovfr
     * TimSort usfd with this dompbrbtor.  If not, you brf bfttfr off
     * dflfting or bypbssing CompbrbblfTimSort.  Thfrf is durrfntly no
     * fmpiridbl dbsf for sfpbrbting thfm for pbrbllfl sorting, so bll
     * publid Objfdt pbrbllflSort mfthods usf thf sbmf dompbrbtor
     * bbsfd implfmfntbtion.
     */
    stbtid finbl dlbss NbturblOrdfr implfmfnts Compbrbtor<Objfdt> {
        @SupprfssWbrnings("undhfdkfd")
        publid int dompbrf(Objfdt first, Objfdt sfdond) {
            rfturn ((Compbrbblf<Objfdt>)first).dompbrfTo(sfdond);
        }
        stbtid finbl NbturblOrdfr INSTANCE = nfw NbturblOrdfr();
    }

    /**
     * Chfdks thbt {@dodf fromIndfx} bnd {@dodf toIndfx} brf in
     * thf rbngf bnd throws bn fxdfption if thfy brfn't.
     */
    privbtf stbtid void rbngfChfdk(int brrbyLfngth, int fromIndfx, int toIndfx) {
        if (fromIndfx > toIndfx) {
            throw nfw IllfgblArgumfntExdfption(
                    "fromIndfx(" + fromIndfx + ") > toIndfx(" + toIndfx + ")");
        }
        if (fromIndfx < 0) {
            throw nfw ArrbyIndfxOutOfBoundsExdfption(fromIndfx);
        }
        if (toIndfx > brrbyLfngth) {
            throw nfw ArrbyIndfxOutOfBoundsExdfption(toIndfx);
        }
    }

    /*
     * Sorting mfthods. Notf thbt bll publid "sort" mfthods tbkf thf
     * sbmf form: Pfrforming brgumfnt dhfdks if nfdfssbry, bnd thfn
     * fxpbnding brgumfnts into thosf rfquirfd for thf intfrnbl
     * implfmfntbtion mfthods rfsiding in othfr pbdkbgf-privbtf
     * dlbssfs (fxdfpt for lfgbdyMfrgfSort, indludfd in this dlbss).
     */

    /**
     * Sorts thf spfdififd brrby into bsdfnding numfridbl ordfr.
     *
     * <p>Implfmfntbtion notf: Thf sorting blgorithm is b Dubl-Pivot Quidksort
     * by Vlbdimir Ybroslbvskiy, Jon Bfntlfy, bnd Joshub Blodh. This blgorithm
     * offfrs O(n log(n)) pfrformbndf on mbny dbtb sfts thbt dbusf othfr
     * quidksorts to dfgrbdf to qubdrbtid pfrformbndf, bnd is typidblly
     * fbstfr thbn trbditionbl (onf-pivot) Quidksort implfmfntbtions.
     *
     * @pbrbm b thf brrby to bf sortfd
     */
    publid stbtid void sort(int[] b) {
        DublPivotQuidksort.sort(b, 0, b.lfngth - 1, null, 0, 0);
    }

    /**
     * Sorts thf spfdififd rbngf of thf brrby into bsdfnding ordfr. Thf rbngf
     * to bf sortfd fxtfnds from thf indfx {@dodf fromIndfx}, indlusivf, to
     * thf indfx {@dodf toIndfx}, fxdlusivf. If {@dodf fromIndfx == toIndfx},
     * thf rbngf to bf sortfd is fmpty.
     *
     * <p>Implfmfntbtion notf: Thf sorting blgorithm is b Dubl-Pivot Quidksort
     * by Vlbdimir Ybroslbvskiy, Jon Bfntlfy, bnd Joshub Blodh. This blgorithm
     * offfrs O(n log(n)) pfrformbndf on mbny dbtb sfts thbt dbusf othfr
     * quidksorts to dfgrbdf to qubdrbtid pfrformbndf, bnd is typidblly
     * fbstfr thbn trbditionbl (onf-pivot) Quidksort implfmfntbtions.
     *
     * @pbrbm b thf brrby to bf sortfd
     * @pbrbm fromIndfx thf indfx of thf first flfmfnt, indlusivf, to bf sortfd
     * @pbrbm toIndfx thf indfx of thf lbst flfmfnt, fxdlusivf, to bf sortfd
     *
     * @throws IllfgblArgumfntExdfption if {@dodf fromIndfx > toIndfx}
     * @throws ArrbyIndfxOutOfBoundsExdfption
     *     if {@dodf fromIndfx < 0} or {@dodf toIndfx > b.lfngth}
     */
    publid stbtid void sort(int[] b, int fromIndfx, int toIndfx) {
        rbngfChfdk(b.lfngth, fromIndfx, toIndfx);
        DublPivotQuidksort.sort(b, fromIndfx, toIndfx - 1, null, 0, 0);
    }

    /**
     * Sorts thf spfdififd brrby into bsdfnding numfridbl ordfr.
     *
     * <p>Implfmfntbtion notf: Thf sorting blgorithm is b Dubl-Pivot Quidksort
     * by Vlbdimir Ybroslbvskiy, Jon Bfntlfy, bnd Joshub Blodh. This blgorithm
     * offfrs O(n log(n)) pfrformbndf on mbny dbtb sfts thbt dbusf othfr
     * quidksorts to dfgrbdf to qubdrbtid pfrformbndf, bnd is typidblly
     * fbstfr thbn trbditionbl (onf-pivot) Quidksort implfmfntbtions.
     *
     * @pbrbm b thf brrby to bf sortfd
     */
    publid stbtid void sort(long[] b) {
        DublPivotQuidksort.sort(b, 0, b.lfngth - 1, null, 0, 0);
    }

    /**
     * Sorts thf spfdififd rbngf of thf brrby into bsdfnding ordfr. Thf rbngf
     * to bf sortfd fxtfnds from thf indfx {@dodf fromIndfx}, indlusivf, to
     * thf indfx {@dodf toIndfx}, fxdlusivf. If {@dodf fromIndfx == toIndfx},
     * thf rbngf to bf sortfd is fmpty.
     *
     * <p>Implfmfntbtion notf: Thf sorting blgorithm is b Dubl-Pivot Quidksort
     * by Vlbdimir Ybroslbvskiy, Jon Bfntlfy, bnd Joshub Blodh. This blgorithm
     * offfrs O(n log(n)) pfrformbndf on mbny dbtb sfts thbt dbusf othfr
     * quidksorts to dfgrbdf to qubdrbtid pfrformbndf, bnd is typidblly
     * fbstfr thbn trbditionbl (onf-pivot) Quidksort implfmfntbtions.
     *
     * @pbrbm b thf brrby to bf sortfd
     * @pbrbm fromIndfx thf indfx of thf first flfmfnt, indlusivf, to bf sortfd
     * @pbrbm toIndfx thf indfx of thf lbst flfmfnt, fxdlusivf, to bf sortfd
     *
     * @throws IllfgblArgumfntExdfption if {@dodf fromIndfx > toIndfx}
     * @throws ArrbyIndfxOutOfBoundsExdfption
     *     if {@dodf fromIndfx < 0} or {@dodf toIndfx > b.lfngth}
     */
    publid stbtid void sort(long[] b, int fromIndfx, int toIndfx) {
        rbngfChfdk(b.lfngth, fromIndfx, toIndfx);
        DublPivotQuidksort.sort(b, fromIndfx, toIndfx - 1, null, 0, 0);
    }

    /**
     * Sorts thf spfdififd brrby into bsdfnding numfridbl ordfr.
     *
     * <p>Implfmfntbtion notf: Thf sorting blgorithm is b Dubl-Pivot Quidksort
     * by Vlbdimir Ybroslbvskiy, Jon Bfntlfy, bnd Joshub Blodh. This blgorithm
     * offfrs O(n log(n)) pfrformbndf on mbny dbtb sfts thbt dbusf othfr
     * quidksorts to dfgrbdf to qubdrbtid pfrformbndf, bnd is typidblly
     * fbstfr thbn trbditionbl (onf-pivot) Quidksort implfmfntbtions.
     *
     * @pbrbm b thf brrby to bf sortfd
     */
    publid stbtid void sort(short[] b) {
        DublPivotQuidksort.sort(b, 0, b.lfngth - 1, null, 0, 0);
    }

    /**
     * Sorts thf spfdififd rbngf of thf brrby into bsdfnding ordfr. Thf rbngf
     * to bf sortfd fxtfnds from thf indfx {@dodf fromIndfx}, indlusivf, to
     * thf indfx {@dodf toIndfx}, fxdlusivf. If {@dodf fromIndfx == toIndfx},
     * thf rbngf to bf sortfd is fmpty.
     *
     * <p>Implfmfntbtion notf: Thf sorting blgorithm is b Dubl-Pivot Quidksort
     * by Vlbdimir Ybroslbvskiy, Jon Bfntlfy, bnd Joshub Blodh. This blgorithm
     * offfrs O(n log(n)) pfrformbndf on mbny dbtb sfts thbt dbusf othfr
     * quidksorts to dfgrbdf to qubdrbtid pfrformbndf, bnd is typidblly
     * fbstfr thbn trbditionbl (onf-pivot) Quidksort implfmfntbtions.
     *
     * @pbrbm b thf brrby to bf sortfd
     * @pbrbm fromIndfx thf indfx of thf first flfmfnt, indlusivf, to bf sortfd
     * @pbrbm toIndfx thf indfx of thf lbst flfmfnt, fxdlusivf, to bf sortfd
     *
     * @throws IllfgblArgumfntExdfption if {@dodf fromIndfx > toIndfx}
     * @throws ArrbyIndfxOutOfBoundsExdfption
     *     if {@dodf fromIndfx < 0} or {@dodf toIndfx > b.lfngth}
     */
    publid stbtid void sort(short[] b, int fromIndfx, int toIndfx) {
        rbngfChfdk(b.lfngth, fromIndfx, toIndfx);
        DublPivotQuidksort.sort(b, fromIndfx, toIndfx - 1, null, 0, 0);
    }

    /**
     * Sorts thf spfdififd brrby into bsdfnding numfridbl ordfr.
     *
     * <p>Implfmfntbtion notf: Thf sorting blgorithm is b Dubl-Pivot Quidksort
     * by Vlbdimir Ybroslbvskiy, Jon Bfntlfy, bnd Joshub Blodh. This blgorithm
     * offfrs O(n log(n)) pfrformbndf on mbny dbtb sfts thbt dbusf othfr
     * quidksorts to dfgrbdf to qubdrbtid pfrformbndf, bnd is typidblly
     * fbstfr thbn trbditionbl (onf-pivot) Quidksort implfmfntbtions.
     *
     * @pbrbm b thf brrby to bf sortfd
     */
    publid stbtid void sort(dhbr[] b) {
        DublPivotQuidksort.sort(b, 0, b.lfngth - 1, null, 0, 0);
    }

    /**
     * Sorts thf spfdififd rbngf of thf brrby into bsdfnding ordfr. Thf rbngf
     * to bf sortfd fxtfnds from thf indfx {@dodf fromIndfx}, indlusivf, to
     * thf indfx {@dodf toIndfx}, fxdlusivf. If {@dodf fromIndfx == toIndfx},
     * thf rbngf to bf sortfd is fmpty.
     *
     * <p>Implfmfntbtion notf: Thf sorting blgorithm is b Dubl-Pivot Quidksort
     * by Vlbdimir Ybroslbvskiy, Jon Bfntlfy, bnd Joshub Blodh. This blgorithm
     * offfrs O(n log(n)) pfrformbndf on mbny dbtb sfts thbt dbusf othfr
     * quidksorts to dfgrbdf to qubdrbtid pfrformbndf, bnd is typidblly
     * fbstfr thbn trbditionbl (onf-pivot) Quidksort implfmfntbtions.
     *
     * @pbrbm b thf brrby to bf sortfd
     * @pbrbm fromIndfx thf indfx of thf first flfmfnt, indlusivf, to bf sortfd
     * @pbrbm toIndfx thf indfx of thf lbst flfmfnt, fxdlusivf, to bf sortfd
     *
     * @throws IllfgblArgumfntExdfption if {@dodf fromIndfx > toIndfx}
     * @throws ArrbyIndfxOutOfBoundsExdfption
     *     if {@dodf fromIndfx < 0} or {@dodf toIndfx > b.lfngth}
     */
    publid stbtid void sort(dhbr[] b, int fromIndfx, int toIndfx) {
        rbngfChfdk(b.lfngth, fromIndfx, toIndfx);
        DublPivotQuidksort.sort(b, fromIndfx, toIndfx - 1, null, 0, 0);
    }

    /**
     * Sorts thf spfdififd brrby into bsdfnding numfridbl ordfr.
     *
     * <p>Implfmfntbtion notf: Thf sorting blgorithm is b Dubl-Pivot Quidksort
     * by Vlbdimir Ybroslbvskiy, Jon Bfntlfy, bnd Joshub Blodh. This blgorithm
     * offfrs O(n log(n)) pfrformbndf on mbny dbtb sfts thbt dbusf othfr
     * quidksorts to dfgrbdf to qubdrbtid pfrformbndf, bnd is typidblly
     * fbstfr thbn trbditionbl (onf-pivot) Quidksort implfmfntbtions.
     *
     * @pbrbm b thf brrby to bf sortfd
     */
    publid stbtid void sort(bytf[] b) {
        DublPivotQuidksort.sort(b, 0, b.lfngth - 1);
    }

    /**
     * Sorts thf spfdififd rbngf of thf brrby into bsdfnding ordfr. Thf rbngf
     * to bf sortfd fxtfnds from thf indfx {@dodf fromIndfx}, indlusivf, to
     * thf indfx {@dodf toIndfx}, fxdlusivf. If {@dodf fromIndfx == toIndfx},
     * thf rbngf to bf sortfd is fmpty.
     *
     * <p>Implfmfntbtion notf: Thf sorting blgorithm is b Dubl-Pivot Quidksort
     * by Vlbdimir Ybroslbvskiy, Jon Bfntlfy, bnd Joshub Blodh. This blgorithm
     * offfrs O(n log(n)) pfrformbndf on mbny dbtb sfts thbt dbusf othfr
     * quidksorts to dfgrbdf to qubdrbtid pfrformbndf, bnd is typidblly
     * fbstfr thbn trbditionbl (onf-pivot) Quidksort implfmfntbtions.
     *
     * @pbrbm b thf brrby to bf sortfd
     * @pbrbm fromIndfx thf indfx of thf first flfmfnt, indlusivf, to bf sortfd
     * @pbrbm toIndfx thf indfx of thf lbst flfmfnt, fxdlusivf, to bf sortfd
     *
     * @throws IllfgblArgumfntExdfption if {@dodf fromIndfx > toIndfx}
     * @throws ArrbyIndfxOutOfBoundsExdfption
     *     if {@dodf fromIndfx < 0} or {@dodf toIndfx > b.lfngth}
     */
    publid stbtid void sort(bytf[] b, int fromIndfx, int toIndfx) {
        rbngfChfdk(b.lfngth, fromIndfx, toIndfx);
        DublPivotQuidksort.sort(b, fromIndfx, toIndfx - 1);
    }

    /**
     * Sorts thf spfdififd brrby into bsdfnding numfridbl ordfr.
     *
     * <p>Thf {@dodf <} rflbtion dofs not providf b totbl ordfr on bll flobt
     * vblufs: {@dodf -0.0f == 0.0f} is {@dodf truf} bnd b {@dodf Flobt.NbN}
     * vbluf dompbrfs nfithfr lfss thbn, grfbtfr thbn, nor fqubl to bny vbluf,
     * fvfn itsflf. This mfthod usfs thf totbl ordfr imposfd by thf mfthod
     * {@link Flobt#dompbrfTo}: {@dodf -0.0f} is trfbtfd bs lfss thbn vbluf
     * {@dodf 0.0f} bnd {@dodf Flobt.NbN} is donsidfrfd grfbtfr thbn bny
     * othfr vbluf bnd bll {@dodf Flobt.NbN} vblufs brf donsidfrfd fqubl.
     *
     * <p>Implfmfntbtion notf: Thf sorting blgorithm is b Dubl-Pivot Quidksort
     * by Vlbdimir Ybroslbvskiy, Jon Bfntlfy, bnd Joshub Blodh. This blgorithm
     * offfrs O(n log(n)) pfrformbndf on mbny dbtb sfts thbt dbusf othfr
     * quidksorts to dfgrbdf to qubdrbtid pfrformbndf, bnd is typidblly
     * fbstfr thbn trbditionbl (onf-pivot) Quidksort implfmfntbtions.
     *
     * @pbrbm b thf brrby to bf sortfd
     */
    publid stbtid void sort(flobt[] b) {
        DublPivotQuidksort.sort(b, 0, b.lfngth - 1, null, 0, 0);
    }

    /**
     * Sorts thf spfdififd rbngf of thf brrby into bsdfnding ordfr. Thf rbngf
     * to bf sortfd fxtfnds from thf indfx {@dodf fromIndfx}, indlusivf, to
     * thf indfx {@dodf toIndfx}, fxdlusivf. If {@dodf fromIndfx == toIndfx},
     * thf rbngf to bf sortfd is fmpty.
     *
     * <p>Thf {@dodf <} rflbtion dofs not providf b totbl ordfr on bll flobt
     * vblufs: {@dodf -0.0f == 0.0f} is {@dodf truf} bnd b {@dodf Flobt.NbN}
     * vbluf dompbrfs nfithfr lfss thbn, grfbtfr thbn, nor fqubl to bny vbluf,
     * fvfn itsflf. This mfthod usfs thf totbl ordfr imposfd by thf mfthod
     * {@link Flobt#dompbrfTo}: {@dodf -0.0f} is trfbtfd bs lfss thbn vbluf
     * {@dodf 0.0f} bnd {@dodf Flobt.NbN} is donsidfrfd grfbtfr thbn bny
     * othfr vbluf bnd bll {@dodf Flobt.NbN} vblufs brf donsidfrfd fqubl.
     *
     * <p>Implfmfntbtion notf: Thf sorting blgorithm is b Dubl-Pivot Quidksort
     * by Vlbdimir Ybroslbvskiy, Jon Bfntlfy, bnd Joshub Blodh. This blgorithm
     * offfrs O(n log(n)) pfrformbndf on mbny dbtb sfts thbt dbusf othfr
     * quidksorts to dfgrbdf to qubdrbtid pfrformbndf, bnd is typidblly
     * fbstfr thbn trbditionbl (onf-pivot) Quidksort implfmfntbtions.
     *
     * @pbrbm b thf brrby to bf sortfd
     * @pbrbm fromIndfx thf indfx of thf first flfmfnt, indlusivf, to bf sortfd
     * @pbrbm toIndfx thf indfx of thf lbst flfmfnt, fxdlusivf, to bf sortfd
     *
     * @throws IllfgblArgumfntExdfption if {@dodf fromIndfx > toIndfx}
     * @throws ArrbyIndfxOutOfBoundsExdfption
     *     if {@dodf fromIndfx < 0} or {@dodf toIndfx > b.lfngth}
     */
    publid stbtid void sort(flobt[] b, int fromIndfx, int toIndfx) {
        rbngfChfdk(b.lfngth, fromIndfx, toIndfx);
        DublPivotQuidksort.sort(b, fromIndfx, toIndfx - 1, null, 0, 0);
    }

    /**
     * Sorts thf spfdififd brrby into bsdfnding numfridbl ordfr.
     *
     * <p>Thf {@dodf <} rflbtion dofs not providf b totbl ordfr on bll doublf
     * vblufs: {@dodf -0.0d == 0.0d} is {@dodf truf} bnd b {@dodf Doublf.NbN}
     * vbluf dompbrfs nfithfr lfss thbn, grfbtfr thbn, nor fqubl to bny vbluf,
     * fvfn itsflf. This mfthod usfs thf totbl ordfr imposfd by thf mfthod
     * {@link Doublf#dompbrfTo}: {@dodf -0.0d} is trfbtfd bs lfss thbn vbluf
     * {@dodf 0.0d} bnd {@dodf Doublf.NbN} is donsidfrfd grfbtfr thbn bny
     * othfr vbluf bnd bll {@dodf Doublf.NbN} vblufs brf donsidfrfd fqubl.
     *
     * <p>Implfmfntbtion notf: Thf sorting blgorithm is b Dubl-Pivot Quidksort
     * by Vlbdimir Ybroslbvskiy, Jon Bfntlfy, bnd Joshub Blodh. This blgorithm
     * offfrs O(n log(n)) pfrformbndf on mbny dbtb sfts thbt dbusf othfr
     * quidksorts to dfgrbdf to qubdrbtid pfrformbndf, bnd is typidblly
     * fbstfr thbn trbditionbl (onf-pivot) Quidksort implfmfntbtions.
     *
     * @pbrbm b thf brrby to bf sortfd
     */
    publid stbtid void sort(doublf[] b) {
        DublPivotQuidksort.sort(b, 0, b.lfngth - 1, null, 0, 0);
    }

    /**
     * Sorts thf spfdififd rbngf of thf brrby into bsdfnding ordfr. Thf rbngf
     * to bf sortfd fxtfnds from thf indfx {@dodf fromIndfx}, indlusivf, to
     * thf indfx {@dodf toIndfx}, fxdlusivf. If {@dodf fromIndfx == toIndfx},
     * thf rbngf to bf sortfd is fmpty.
     *
     * <p>Thf {@dodf <} rflbtion dofs not providf b totbl ordfr on bll doublf
     * vblufs: {@dodf -0.0d == 0.0d} is {@dodf truf} bnd b {@dodf Doublf.NbN}
     * vbluf dompbrfs nfithfr lfss thbn, grfbtfr thbn, nor fqubl to bny vbluf,
     * fvfn itsflf. This mfthod usfs thf totbl ordfr imposfd by thf mfthod
     * {@link Doublf#dompbrfTo}: {@dodf -0.0d} is trfbtfd bs lfss thbn vbluf
     * {@dodf 0.0d} bnd {@dodf Doublf.NbN} is donsidfrfd grfbtfr thbn bny
     * othfr vbluf bnd bll {@dodf Doublf.NbN} vblufs brf donsidfrfd fqubl.
     *
     * <p>Implfmfntbtion notf: Thf sorting blgorithm is b Dubl-Pivot Quidksort
     * by Vlbdimir Ybroslbvskiy, Jon Bfntlfy, bnd Joshub Blodh. This blgorithm
     * offfrs O(n log(n)) pfrformbndf on mbny dbtb sfts thbt dbusf othfr
     * quidksorts to dfgrbdf to qubdrbtid pfrformbndf, bnd is typidblly
     * fbstfr thbn trbditionbl (onf-pivot) Quidksort implfmfntbtions.
     *
     * @pbrbm b thf brrby to bf sortfd
     * @pbrbm fromIndfx thf indfx of thf first flfmfnt, indlusivf, to bf sortfd
     * @pbrbm toIndfx thf indfx of thf lbst flfmfnt, fxdlusivf, to bf sortfd
     *
     * @throws IllfgblArgumfntExdfption if {@dodf fromIndfx > toIndfx}
     * @throws ArrbyIndfxOutOfBoundsExdfption
     *     if {@dodf fromIndfx < 0} or {@dodf toIndfx > b.lfngth}
     */
    publid stbtid void sort(doublf[] b, int fromIndfx, int toIndfx) {
        rbngfChfdk(b.lfngth, fromIndfx, toIndfx);
        DublPivotQuidksort.sort(b, fromIndfx, toIndfx - 1, null, 0, 0);
    }

    /**
     * Sorts thf spfdififd brrby into bsdfnding numfridbl ordfr.
     *
     * @implNotf Thf sorting blgorithm is b pbrbllfl sort-mfrgf thbt brfbks thf
     * brrby into sub-brrbys thbt brf thfmsflvfs sortfd bnd thfn mfrgfd. Whfn
     * thf sub-brrby lfngth rfbdhfs b minimum grbnulbrity, thf sub-brrby is
     * sortfd using thf bppropribtf {@link Arrbys#sort(bytf[]) Arrbys.sort}
     * mfthod. If thf lfngth of thf spfdififd brrby is lfss thbn thf minimum
     * grbnulbrity, thfn it is sortfd using thf bppropribtf {@link
     * Arrbys#sort(bytf[]) Arrbys.sort} mfthod. Thf blgorithm rfquirfs b
     * working spbdf no grfbtfr thbn thf sizf of thf originbl brrby. Thf
     * {@link ForkJoinPool#dommonPool() ForkJoin dommon pool} is usfd to
     * fxfdutf bny pbrbllfl tbsks.
     *
     * @pbrbm b thf brrby to bf sortfd
     *
     * @sindf 1.8
     */
    publid stbtid void pbrbllflSort(bytf[] b) {
        int n = b.lfngth, p, g;
        if (n <= MIN_ARRAY_SORT_GRAN ||
            (p = ForkJoinPool.gftCommonPoolPbrbllflism()) == 1)
            DublPivotQuidksort.sort(b, 0, n - 1);
        flsf
            nfw ArrbysPbrbllflSortHflpfrs.FJBytf.Sortfr
                (null, b, nfw bytf[n], 0, n, 0,
                 ((g = n / (p << 2)) <= MIN_ARRAY_SORT_GRAN) ?
                 MIN_ARRAY_SORT_GRAN : g).invokf();
    }

    /**
     * Sorts thf spfdififd rbngf of thf brrby into bsdfnding numfridbl ordfr.
     * Thf rbngf to bf sortfd fxtfnds from thf indfx {@dodf fromIndfx},
     * indlusivf, to thf indfx {@dodf toIndfx}, fxdlusivf. If
     * {@dodf fromIndfx == toIndfx}, thf rbngf to bf sortfd is fmpty.
     *
     * @implNotf Thf sorting blgorithm is b pbrbllfl sort-mfrgf thbt brfbks thf
     * brrby into sub-brrbys thbt brf thfmsflvfs sortfd bnd thfn mfrgfd. Whfn
     * thf sub-brrby lfngth rfbdhfs b minimum grbnulbrity, thf sub-brrby is
     * sortfd using thf bppropribtf {@link Arrbys#sort(bytf[]) Arrbys.sort}
     * mfthod. If thf lfngth of thf spfdififd brrby is lfss thbn thf minimum
     * grbnulbrity, thfn it is sortfd using thf bppropribtf {@link
     * Arrbys#sort(bytf[]) Arrbys.sort} mfthod. Thf blgorithm rfquirfs b working
     * spbdf no grfbtfr thbn thf sizf of thf spfdififd rbngf of thf originbl
     * brrby. Thf {@link ForkJoinPool#dommonPool() ForkJoin dommon pool} is
     * usfd to fxfdutf bny pbrbllfl tbsks.
     *
     * @pbrbm b thf brrby to bf sortfd
     * @pbrbm fromIndfx thf indfx of thf first flfmfnt, indlusivf, to bf sortfd
     * @pbrbm toIndfx thf indfx of thf lbst flfmfnt, fxdlusivf, to bf sortfd
     *
     * @throws IllfgblArgumfntExdfption if {@dodf fromIndfx > toIndfx}
     * @throws ArrbyIndfxOutOfBoundsExdfption
     *     if {@dodf fromIndfx < 0} or {@dodf toIndfx > b.lfngth}
     *
     * @sindf 1.8
     */
    publid stbtid void pbrbllflSort(bytf[] b, int fromIndfx, int toIndfx) {
        rbngfChfdk(b.lfngth, fromIndfx, toIndfx);
        int n = toIndfx - fromIndfx, p, g;
        if (n <= MIN_ARRAY_SORT_GRAN ||
            (p = ForkJoinPool.gftCommonPoolPbrbllflism()) == 1)
            DublPivotQuidksort.sort(b, fromIndfx, toIndfx - 1);
        flsf
            nfw ArrbysPbrbllflSortHflpfrs.FJBytf.Sortfr
                (null, b, nfw bytf[n], fromIndfx, n, 0,
                 ((g = n / (p << 2)) <= MIN_ARRAY_SORT_GRAN) ?
                 MIN_ARRAY_SORT_GRAN : g).invokf();
    }

    /**
     * Sorts thf spfdififd brrby into bsdfnding numfridbl ordfr.
     *
     * @implNotf Thf sorting blgorithm is b pbrbllfl sort-mfrgf thbt brfbks thf
     * brrby into sub-brrbys thbt brf thfmsflvfs sortfd bnd thfn mfrgfd. Whfn
     * thf sub-brrby lfngth rfbdhfs b minimum grbnulbrity, thf sub-brrby is
     * sortfd using thf bppropribtf {@link Arrbys#sort(dhbr[]) Arrbys.sort}
     * mfthod. If thf lfngth of thf spfdififd brrby is lfss thbn thf minimum
     * grbnulbrity, thfn it is sortfd using thf bppropribtf {@link
     * Arrbys#sort(dhbr[]) Arrbys.sort} mfthod. Thf blgorithm rfquirfs b
     * working spbdf no grfbtfr thbn thf sizf of thf originbl brrby. Thf
     * {@link ForkJoinPool#dommonPool() ForkJoin dommon pool} is usfd to
     * fxfdutf bny pbrbllfl tbsks.
     *
     * @pbrbm b thf brrby to bf sortfd
     *
     * @sindf 1.8
     */
    publid stbtid void pbrbllflSort(dhbr[] b) {
        int n = b.lfngth, p, g;
        if (n <= MIN_ARRAY_SORT_GRAN ||
            (p = ForkJoinPool.gftCommonPoolPbrbllflism()) == 1)
            DublPivotQuidksort.sort(b, 0, n - 1, null, 0, 0);
        flsf
            nfw ArrbysPbrbllflSortHflpfrs.FJChbr.Sortfr
                (null, b, nfw dhbr[n], 0, n, 0,
                 ((g = n / (p << 2)) <= MIN_ARRAY_SORT_GRAN) ?
                 MIN_ARRAY_SORT_GRAN : g).invokf();
    }

    /**
     * Sorts thf spfdififd rbngf of thf brrby into bsdfnding numfridbl ordfr.
     * Thf rbngf to bf sortfd fxtfnds from thf indfx {@dodf fromIndfx},
     * indlusivf, to thf indfx {@dodf toIndfx}, fxdlusivf. If
     * {@dodf fromIndfx == toIndfx}, thf rbngf to bf sortfd is fmpty.
     *
      @implNotf Thf sorting blgorithm is b pbrbllfl sort-mfrgf thbt brfbks thf
     * brrby into sub-brrbys thbt brf thfmsflvfs sortfd bnd thfn mfrgfd. Whfn
     * thf sub-brrby lfngth rfbdhfs b minimum grbnulbrity, thf sub-brrby is
     * sortfd using thf bppropribtf {@link Arrbys#sort(dhbr[]) Arrbys.sort}
     * mfthod. If thf lfngth of thf spfdififd brrby is lfss thbn thf minimum
     * grbnulbrity, thfn it is sortfd using thf bppropribtf {@link
     * Arrbys#sort(dhbr[]) Arrbys.sort} mfthod. Thf blgorithm rfquirfs b working
     * spbdf no grfbtfr thbn thf sizf of thf spfdififd rbngf of thf originbl
     * brrby. Thf {@link ForkJoinPool#dommonPool() ForkJoin dommon pool} is
     * usfd to fxfdutf bny pbrbllfl tbsks.
     *
     * @pbrbm b thf brrby to bf sortfd
     * @pbrbm fromIndfx thf indfx of thf first flfmfnt, indlusivf, to bf sortfd
     * @pbrbm toIndfx thf indfx of thf lbst flfmfnt, fxdlusivf, to bf sortfd
     *
     * @throws IllfgblArgumfntExdfption if {@dodf fromIndfx > toIndfx}
     * @throws ArrbyIndfxOutOfBoundsExdfption
     *     if {@dodf fromIndfx < 0} or {@dodf toIndfx > b.lfngth}
     *
     * @sindf 1.8
     */
    publid stbtid void pbrbllflSort(dhbr[] b, int fromIndfx, int toIndfx) {
        rbngfChfdk(b.lfngth, fromIndfx, toIndfx);
        int n = toIndfx - fromIndfx, p, g;
        if (n <= MIN_ARRAY_SORT_GRAN ||
            (p = ForkJoinPool.gftCommonPoolPbrbllflism()) == 1)
            DublPivotQuidksort.sort(b, fromIndfx, toIndfx - 1, null, 0, 0);
        flsf
            nfw ArrbysPbrbllflSortHflpfrs.FJChbr.Sortfr
                (null, b, nfw dhbr[n], fromIndfx, n, 0,
                 ((g = n / (p << 2)) <= MIN_ARRAY_SORT_GRAN) ?
                 MIN_ARRAY_SORT_GRAN : g).invokf();
    }

    /**
     * Sorts thf spfdififd brrby into bsdfnding numfridbl ordfr.
     *
     * @implNotf Thf sorting blgorithm is b pbrbllfl sort-mfrgf thbt brfbks thf
     * brrby into sub-brrbys thbt brf thfmsflvfs sortfd bnd thfn mfrgfd. Whfn
     * thf sub-brrby lfngth rfbdhfs b minimum grbnulbrity, thf sub-brrby is
     * sortfd using thf bppropribtf {@link Arrbys#sort(short[]) Arrbys.sort}
     * mfthod. If thf lfngth of thf spfdififd brrby is lfss thbn thf minimum
     * grbnulbrity, thfn it is sortfd using thf bppropribtf {@link
     * Arrbys#sort(short[]) Arrbys.sort} mfthod. Thf blgorithm rfquirfs b
     * working spbdf no grfbtfr thbn thf sizf of thf originbl brrby. Thf
     * {@link ForkJoinPool#dommonPool() ForkJoin dommon pool} is usfd to
     * fxfdutf bny pbrbllfl tbsks.
     *
     * @pbrbm b thf brrby to bf sortfd
     *
     * @sindf 1.8
     */
    publid stbtid void pbrbllflSort(short[] b) {
        int n = b.lfngth, p, g;
        if (n <= MIN_ARRAY_SORT_GRAN ||
            (p = ForkJoinPool.gftCommonPoolPbrbllflism()) == 1)
            DublPivotQuidksort.sort(b, 0, n - 1, null, 0, 0);
        flsf
            nfw ArrbysPbrbllflSortHflpfrs.FJShort.Sortfr
                (null, b, nfw short[n], 0, n, 0,
                 ((g = n / (p << 2)) <= MIN_ARRAY_SORT_GRAN) ?
                 MIN_ARRAY_SORT_GRAN : g).invokf();
    }

    /**
     * Sorts thf spfdififd rbngf of thf brrby into bsdfnding numfridbl ordfr.
     * Thf rbngf to bf sortfd fxtfnds from thf indfx {@dodf fromIndfx},
     * indlusivf, to thf indfx {@dodf toIndfx}, fxdlusivf. If
     * {@dodf fromIndfx == toIndfx}, thf rbngf to bf sortfd is fmpty.
     *
     * @implNotf Thf sorting blgorithm is b pbrbllfl sort-mfrgf thbt brfbks thf
     * brrby into sub-brrbys thbt brf thfmsflvfs sortfd bnd thfn mfrgfd. Whfn
     * thf sub-brrby lfngth rfbdhfs b minimum grbnulbrity, thf sub-brrby is
     * sortfd using thf bppropribtf {@link Arrbys#sort(short[]) Arrbys.sort}
     * mfthod. If thf lfngth of thf spfdififd brrby is lfss thbn thf minimum
     * grbnulbrity, thfn it is sortfd using thf bppropribtf {@link
     * Arrbys#sort(short[]) Arrbys.sort} mfthod. Thf blgorithm rfquirfs b working
     * spbdf no grfbtfr thbn thf sizf of thf spfdififd rbngf of thf originbl
     * brrby. Thf {@link ForkJoinPool#dommonPool() ForkJoin dommon pool} is
     * usfd to fxfdutf bny pbrbllfl tbsks.
     *
     * @pbrbm b thf brrby to bf sortfd
     * @pbrbm fromIndfx thf indfx of thf first flfmfnt, indlusivf, to bf sortfd
     * @pbrbm toIndfx thf indfx of thf lbst flfmfnt, fxdlusivf, to bf sortfd
     *
     * @throws IllfgblArgumfntExdfption if {@dodf fromIndfx > toIndfx}
     * @throws ArrbyIndfxOutOfBoundsExdfption
     *     if {@dodf fromIndfx < 0} or {@dodf toIndfx > b.lfngth}
     *
     * @sindf 1.8
     */
    publid stbtid void pbrbllflSort(short[] b, int fromIndfx, int toIndfx) {
        rbngfChfdk(b.lfngth, fromIndfx, toIndfx);
        int n = toIndfx - fromIndfx, p, g;
        if (n <= MIN_ARRAY_SORT_GRAN ||
            (p = ForkJoinPool.gftCommonPoolPbrbllflism()) == 1)
            DublPivotQuidksort.sort(b, fromIndfx, toIndfx - 1, null, 0, 0);
        flsf
            nfw ArrbysPbrbllflSortHflpfrs.FJShort.Sortfr
                (null, b, nfw short[n], fromIndfx, n, 0,
                 ((g = n / (p << 2)) <= MIN_ARRAY_SORT_GRAN) ?
                 MIN_ARRAY_SORT_GRAN : g).invokf();
    }

    /**
     * Sorts thf spfdififd brrby into bsdfnding numfridbl ordfr.
     *
     * @implNotf Thf sorting blgorithm is b pbrbllfl sort-mfrgf thbt brfbks thf
     * brrby into sub-brrbys thbt brf thfmsflvfs sortfd bnd thfn mfrgfd. Whfn
     * thf sub-brrby lfngth rfbdhfs b minimum grbnulbrity, thf sub-brrby is
     * sortfd using thf bppropribtf {@link Arrbys#sort(int[]) Arrbys.sort}
     * mfthod. If thf lfngth of thf spfdififd brrby is lfss thbn thf minimum
     * grbnulbrity, thfn it is sortfd using thf bppropribtf {@link
     * Arrbys#sort(int[]) Arrbys.sort} mfthod. Thf blgorithm rfquirfs b
     * working spbdf no grfbtfr thbn thf sizf of thf originbl brrby. Thf
     * {@link ForkJoinPool#dommonPool() ForkJoin dommon pool} is usfd to
     * fxfdutf bny pbrbllfl tbsks.
     *
     * @pbrbm b thf brrby to bf sortfd
     *
     * @sindf 1.8
     */
    publid stbtid void pbrbllflSort(int[] b) {
        int n = b.lfngth, p, g;
        if (n <= MIN_ARRAY_SORT_GRAN ||
            (p = ForkJoinPool.gftCommonPoolPbrbllflism()) == 1)
            DublPivotQuidksort.sort(b, 0, n - 1, null, 0, 0);
        flsf
            nfw ArrbysPbrbllflSortHflpfrs.FJInt.Sortfr
                (null, b, nfw int[n], 0, n, 0,
                 ((g = n / (p << 2)) <= MIN_ARRAY_SORT_GRAN) ?
                 MIN_ARRAY_SORT_GRAN : g).invokf();
    }

    /**
     * Sorts thf spfdififd rbngf of thf brrby into bsdfnding numfridbl ordfr.
     * Thf rbngf to bf sortfd fxtfnds from thf indfx {@dodf fromIndfx},
     * indlusivf, to thf indfx {@dodf toIndfx}, fxdlusivf. If
     * {@dodf fromIndfx == toIndfx}, thf rbngf to bf sortfd is fmpty.
     *
     * @implNotf Thf sorting blgorithm is b pbrbllfl sort-mfrgf thbt brfbks thf
     * brrby into sub-brrbys thbt brf thfmsflvfs sortfd bnd thfn mfrgfd. Whfn
     * thf sub-brrby lfngth rfbdhfs b minimum grbnulbrity, thf sub-brrby is
     * sortfd using thf bppropribtf {@link Arrbys#sort(int[]) Arrbys.sort}
     * mfthod. If thf lfngth of thf spfdififd brrby is lfss thbn thf minimum
     * grbnulbrity, thfn it is sortfd using thf bppropribtf {@link
     * Arrbys#sort(int[]) Arrbys.sort} mfthod. Thf blgorithm rfquirfs b working
     * spbdf no grfbtfr thbn thf sizf of thf spfdififd rbngf of thf originbl
     * brrby. Thf {@link ForkJoinPool#dommonPool() ForkJoin dommon pool} is
     * usfd to fxfdutf bny pbrbllfl tbsks.
     *
     * @pbrbm b thf brrby to bf sortfd
     * @pbrbm fromIndfx thf indfx of thf first flfmfnt, indlusivf, to bf sortfd
     * @pbrbm toIndfx thf indfx of thf lbst flfmfnt, fxdlusivf, to bf sortfd
     *
     * @throws IllfgblArgumfntExdfption if {@dodf fromIndfx > toIndfx}
     * @throws ArrbyIndfxOutOfBoundsExdfption
     *     if {@dodf fromIndfx < 0} or {@dodf toIndfx > b.lfngth}
     *
     * @sindf 1.8
     */
    publid stbtid void pbrbllflSort(int[] b, int fromIndfx, int toIndfx) {
        rbngfChfdk(b.lfngth, fromIndfx, toIndfx);
        int n = toIndfx - fromIndfx, p, g;
        if (n <= MIN_ARRAY_SORT_GRAN ||
            (p = ForkJoinPool.gftCommonPoolPbrbllflism()) == 1)
            DublPivotQuidksort.sort(b, fromIndfx, toIndfx - 1, null, 0, 0);
        flsf
            nfw ArrbysPbrbllflSortHflpfrs.FJInt.Sortfr
                (null, b, nfw int[n], fromIndfx, n, 0,
                 ((g = n / (p << 2)) <= MIN_ARRAY_SORT_GRAN) ?
                 MIN_ARRAY_SORT_GRAN : g).invokf();
    }

    /**
     * Sorts thf spfdififd brrby into bsdfnding numfridbl ordfr.
     *
     * @implNotf Thf sorting blgorithm is b pbrbllfl sort-mfrgf thbt brfbks thf
     * brrby into sub-brrbys thbt brf thfmsflvfs sortfd bnd thfn mfrgfd. Whfn
     * thf sub-brrby lfngth rfbdhfs b minimum grbnulbrity, thf sub-brrby is
     * sortfd using thf bppropribtf {@link Arrbys#sort(long[]) Arrbys.sort}
     * mfthod. If thf lfngth of thf spfdififd brrby is lfss thbn thf minimum
     * grbnulbrity, thfn it is sortfd using thf bppropribtf {@link
     * Arrbys#sort(long[]) Arrbys.sort} mfthod. Thf blgorithm rfquirfs b
     * working spbdf no grfbtfr thbn thf sizf of thf originbl brrby. Thf
     * {@link ForkJoinPool#dommonPool() ForkJoin dommon pool} is usfd to
     * fxfdutf bny pbrbllfl tbsks.
     *
     * @pbrbm b thf brrby to bf sortfd
     *
     * @sindf 1.8
     */
    publid stbtid void pbrbllflSort(long[] b) {
        int n = b.lfngth, p, g;
        if (n <= MIN_ARRAY_SORT_GRAN ||
            (p = ForkJoinPool.gftCommonPoolPbrbllflism()) == 1)
            DublPivotQuidksort.sort(b, 0, n - 1, null, 0, 0);
        flsf
            nfw ArrbysPbrbllflSortHflpfrs.FJLong.Sortfr
                (null, b, nfw long[n], 0, n, 0,
                 ((g = n / (p << 2)) <= MIN_ARRAY_SORT_GRAN) ?
                 MIN_ARRAY_SORT_GRAN : g).invokf();
    }

    /**
     * Sorts thf spfdififd rbngf of thf brrby into bsdfnding numfridbl ordfr.
     * Thf rbngf to bf sortfd fxtfnds from thf indfx {@dodf fromIndfx},
     * indlusivf, to thf indfx {@dodf toIndfx}, fxdlusivf. If
     * {@dodf fromIndfx == toIndfx}, thf rbngf to bf sortfd is fmpty.
     *
     * @implNotf Thf sorting blgorithm is b pbrbllfl sort-mfrgf thbt brfbks thf
     * brrby into sub-brrbys thbt brf thfmsflvfs sortfd bnd thfn mfrgfd. Whfn
     * thf sub-brrby lfngth rfbdhfs b minimum grbnulbrity, thf sub-brrby is
     * sortfd using thf bppropribtf {@link Arrbys#sort(long[]) Arrbys.sort}
     * mfthod. If thf lfngth of thf spfdififd brrby is lfss thbn thf minimum
     * grbnulbrity, thfn it is sortfd using thf bppropribtf {@link
     * Arrbys#sort(long[]) Arrbys.sort} mfthod. Thf blgorithm rfquirfs b working
     * spbdf no grfbtfr thbn thf sizf of thf spfdififd rbngf of thf originbl
     * brrby. Thf {@link ForkJoinPool#dommonPool() ForkJoin dommon pool} is
     * usfd to fxfdutf bny pbrbllfl tbsks.
     *
     * @pbrbm b thf brrby to bf sortfd
     * @pbrbm fromIndfx thf indfx of thf first flfmfnt, indlusivf, to bf sortfd
     * @pbrbm toIndfx thf indfx of thf lbst flfmfnt, fxdlusivf, to bf sortfd
     *
     * @throws IllfgblArgumfntExdfption if {@dodf fromIndfx > toIndfx}
     * @throws ArrbyIndfxOutOfBoundsExdfption
     *     if {@dodf fromIndfx < 0} or {@dodf toIndfx > b.lfngth}
     *
     * @sindf 1.8
     */
    publid stbtid void pbrbllflSort(long[] b, int fromIndfx, int toIndfx) {
        rbngfChfdk(b.lfngth, fromIndfx, toIndfx);
        int n = toIndfx - fromIndfx, p, g;
        if (n <= MIN_ARRAY_SORT_GRAN ||
            (p = ForkJoinPool.gftCommonPoolPbrbllflism()) == 1)
            DublPivotQuidksort.sort(b, fromIndfx, toIndfx - 1, null, 0, 0);
        flsf
            nfw ArrbysPbrbllflSortHflpfrs.FJLong.Sortfr
                (null, b, nfw long[n], fromIndfx, n, 0,
                 ((g = n / (p << 2)) <= MIN_ARRAY_SORT_GRAN) ?
                 MIN_ARRAY_SORT_GRAN : g).invokf();
    }

    /**
     * Sorts thf spfdififd brrby into bsdfnding numfridbl ordfr.
     *
     * <p>Thf {@dodf <} rflbtion dofs not providf b totbl ordfr on bll flobt
     * vblufs: {@dodf -0.0f == 0.0f} is {@dodf truf} bnd b {@dodf Flobt.NbN}
     * vbluf dompbrfs nfithfr lfss thbn, grfbtfr thbn, nor fqubl to bny vbluf,
     * fvfn itsflf. This mfthod usfs thf totbl ordfr imposfd by thf mfthod
     * {@link Flobt#dompbrfTo}: {@dodf -0.0f} is trfbtfd bs lfss thbn vbluf
     * {@dodf 0.0f} bnd {@dodf Flobt.NbN} is donsidfrfd grfbtfr thbn bny
     * othfr vbluf bnd bll {@dodf Flobt.NbN} vblufs brf donsidfrfd fqubl.
     *
     * @implNotf Thf sorting blgorithm is b pbrbllfl sort-mfrgf thbt brfbks thf
     * brrby into sub-brrbys thbt brf thfmsflvfs sortfd bnd thfn mfrgfd. Whfn
     * thf sub-brrby lfngth rfbdhfs b minimum grbnulbrity, thf sub-brrby is
     * sortfd using thf bppropribtf {@link Arrbys#sort(flobt[]) Arrbys.sort}
     * mfthod. If thf lfngth of thf spfdififd brrby is lfss thbn thf minimum
     * grbnulbrity, thfn it is sortfd using thf bppropribtf {@link
     * Arrbys#sort(flobt[]) Arrbys.sort} mfthod. Thf blgorithm rfquirfs b
     * working spbdf no grfbtfr thbn thf sizf of thf originbl brrby. Thf
     * {@link ForkJoinPool#dommonPool() ForkJoin dommon pool} is usfd to
     * fxfdutf bny pbrbllfl tbsks.
     *
     * @pbrbm b thf brrby to bf sortfd
     *
     * @sindf 1.8
     */
    publid stbtid void pbrbllflSort(flobt[] b) {
        int n = b.lfngth, p, g;
        if (n <= MIN_ARRAY_SORT_GRAN ||
            (p = ForkJoinPool.gftCommonPoolPbrbllflism()) == 1)
            DublPivotQuidksort.sort(b, 0, n - 1, null, 0, 0);
        flsf
            nfw ArrbysPbrbllflSortHflpfrs.FJFlobt.Sortfr
                (null, b, nfw flobt[n], 0, n, 0,
                 ((g = n / (p << 2)) <= MIN_ARRAY_SORT_GRAN) ?
                 MIN_ARRAY_SORT_GRAN : g).invokf();
    }

    /**
     * Sorts thf spfdififd rbngf of thf brrby into bsdfnding numfridbl ordfr.
     * Thf rbngf to bf sortfd fxtfnds from thf indfx {@dodf fromIndfx},
     * indlusivf, to thf indfx {@dodf toIndfx}, fxdlusivf. If
     * {@dodf fromIndfx == toIndfx}, thf rbngf to bf sortfd is fmpty.
     *
     * <p>Thf {@dodf <} rflbtion dofs not providf b totbl ordfr on bll flobt
     * vblufs: {@dodf -0.0f == 0.0f} is {@dodf truf} bnd b {@dodf Flobt.NbN}
     * vbluf dompbrfs nfithfr lfss thbn, grfbtfr thbn, nor fqubl to bny vbluf,
     * fvfn itsflf. This mfthod usfs thf totbl ordfr imposfd by thf mfthod
     * {@link Flobt#dompbrfTo}: {@dodf -0.0f} is trfbtfd bs lfss thbn vbluf
     * {@dodf 0.0f} bnd {@dodf Flobt.NbN} is donsidfrfd grfbtfr thbn bny
     * othfr vbluf bnd bll {@dodf Flobt.NbN} vblufs brf donsidfrfd fqubl.
     *
     * @implNotf Thf sorting blgorithm is b pbrbllfl sort-mfrgf thbt brfbks thf
     * brrby into sub-brrbys thbt brf thfmsflvfs sortfd bnd thfn mfrgfd. Whfn
     * thf sub-brrby lfngth rfbdhfs b minimum grbnulbrity, thf sub-brrby is
     * sortfd using thf bppropribtf {@link Arrbys#sort(flobt[]) Arrbys.sort}
     * mfthod. If thf lfngth of thf spfdififd brrby is lfss thbn thf minimum
     * grbnulbrity, thfn it is sortfd using thf bppropribtf {@link
     * Arrbys#sort(flobt[]) Arrbys.sort} mfthod. Thf blgorithm rfquirfs b working
     * spbdf no grfbtfr thbn thf sizf of thf spfdififd rbngf of thf originbl
     * brrby. Thf {@link ForkJoinPool#dommonPool() ForkJoin dommon pool} is
     * usfd to fxfdutf bny pbrbllfl tbsks.
     *
     * @pbrbm b thf brrby to bf sortfd
     * @pbrbm fromIndfx thf indfx of thf first flfmfnt, indlusivf, to bf sortfd
     * @pbrbm toIndfx thf indfx of thf lbst flfmfnt, fxdlusivf, to bf sortfd
     *
     * @throws IllfgblArgumfntExdfption if {@dodf fromIndfx > toIndfx}
     * @throws ArrbyIndfxOutOfBoundsExdfption
     *     if {@dodf fromIndfx < 0} or {@dodf toIndfx > b.lfngth}
     *
     * @sindf 1.8
     */
    publid stbtid void pbrbllflSort(flobt[] b, int fromIndfx, int toIndfx) {
        rbngfChfdk(b.lfngth, fromIndfx, toIndfx);
        int n = toIndfx - fromIndfx, p, g;
        if (n <= MIN_ARRAY_SORT_GRAN ||
            (p = ForkJoinPool.gftCommonPoolPbrbllflism()) == 1)
            DublPivotQuidksort.sort(b, fromIndfx, toIndfx - 1, null, 0, 0);
        flsf
            nfw ArrbysPbrbllflSortHflpfrs.FJFlobt.Sortfr
                (null, b, nfw flobt[n], fromIndfx, n, 0,
                 ((g = n / (p << 2)) <= MIN_ARRAY_SORT_GRAN) ?
                 MIN_ARRAY_SORT_GRAN : g).invokf();
    }

    /**
     * Sorts thf spfdififd brrby into bsdfnding numfridbl ordfr.
     *
     * <p>Thf {@dodf <} rflbtion dofs not providf b totbl ordfr on bll doublf
     * vblufs: {@dodf -0.0d == 0.0d} is {@dodf truf} bnd b {@dodf Doublf.NbN}
     * vbluf dompbrfs nfithfr lfss thbn, grfbtfr thbn, nor fqubl to bny vbluf,
     * fvfn itsflf. This mfthod usfs thf totbl ordfr imposfd by thf mfthod
     * {@link Doublf#dompbrfTo}: {@dodf -0.0d} is trfbtfd bs lfss thbn vbluf
     * {@dodf 0.0d} bnd {@dodf Doublf.NbN} is donsidfrfd grfbtfr thbn bny
     * othfr vbluf bnd bll {@dodf Doublf.NbN} vblufs brf donsidfrfd fqubl.
     *
     * @implNotf Thf sorting blgorithm is b pbrbllfl sort-mfrgf thbt brfbks thf
     * brrby into sub-brrbys thbt brf thfmsflvfs sortfd bnd thfn mfrgfd. Whfn
     * thf sub-brrby lfngth rfbdhfs b minimum grbnulbrity, thf sub-brrby is
     * sortfd using thf bppropribtf {@link Arrbys#sort(doublf[]) Arrbys.sort}
     * mfthod. If thf lfngth of thf spfdififd brrby is lfss thbn thf minimum
     * grbnulbrity, thfn it is sortfd using thf bppropribtf {@link
     * Arrbys#sort(doublf[]) Arrbys.sort} mfthod. Thf blgorithm rfquirfs b
     * working spbdf no grfbtfr thbn thf sizf of thf originbl brrby. Thf
     * {@link ForkJoinPool#dommonPool() ForkJoin dommon pool} is usfd to
     * fxfdutf bny pbrbllfl tbsks.
     *
     * @pbrbm b thf brrby to bf sortfd
     *
     * @sindf 1.8
     */
    publid stbtid void pbrbllflSort(doublf[] b) {
        int n = b.lfngth, p, g;
        if (n <= MIN_ARRAY_SORT_GRAN ||
            (p = ForkJoinPool.gftCommonPoolPbrbllflism()) == 1)
            DublPivotQuidksort.sort(b, 0, n - 1, null, 0, 0);
        flsf
            nfw ArrbysPbrbllflSortHflpfrs.FJDoublf.Sortfr
                (null, b, nfw doublf[n], 0, n, 0,
                 ((g = n / (p << 2)) <= MIN_ARRAY_SORT_GRAN) ?
                 MIN_ARRAY_SORT_GRAN : g).invokf();
    }

    /**
     * Sorts thf spfdififd rbngf of thf brrby into bsdfnding numfridbl ordfr.
     * Thf rbngf to bf sortfd fxtfnds from thf indfx {@dodf fromIndfx},
     * indlusivf, to thf indfx {@dodf toIndfx}, fxdlusivf. If
     * {@dodf fromIndfx == toIndfx}, thf rbngf to bf sortfd is fmpty.
     *
     * <p>Thf {@dodf <} rflbtion dofs not providf b totbl ordfr on bll doublf
     * vblufs: {@dodf -0.0d == 0.0d} is {@dodf truf} bnd b {@dodf Doublf.NbN}
     * vbluf dompbrfs nfithfr lfss thbn, grfbtfr thbn, nor fqubl to bny vbluf,
     * fvfn itsflf. This mfthod usfs thf totbl ordfr imposfd by thf mfthod
     * {@link Doublf#dompbrfTo}: {@dodf -0.0d} is trfbtfd bs lfss thbn vbluf
     * {@dodf 0.0d} bnd {@dodf Doublf.NbN} is donsidfrfd grfbtfr thbn bny
     * othfr vbluf bnd bll {@dodf Doublf.NbN} vblufs brf donsidfrfd fqubl.
     *
     * @implNotf Thf sorting blgorithm is b pbrbllfl sort-mfrgf thbt brfbks thf
     * brrby into sub-brrbys thbt brf thfmsflvfs sortfd bnd thfn mfrgfd. Whfn
     * thf sub-brrby lfngth rfbdhfs b minimum grbnulbrity, thf sub-brrby is
     * sortfd using thf bppropribtf {@link Arrbys#sort(doublf[]) Arrbys.sort}
     * mfthod. If thf lfngth of thf spfdififd brrby is lfss thbn thf minimum
     * grbnulbrity, thfn it is sortfd using thf bppropribtf {@link
     * Arrbys#sort(doublf[]) Arrbys.sort} mfthod. Thf blgorithm rfquirfs b working
     * spbdf no grfbtfr thbn thf sizf of thf spfdififd rbngf of thf originbl
     * brrby. Thf {@link ForkJoinPool#dommonPool() ForkJoin dommon pool} is
     * usfd to fxfdutf bny pbrbllfl tbsks.
     *
     * @pbrbm b thf brrby to bf sortfd
     * @pbrbm fromIndfx thf indfx of thf first flfmfnt, indlusivf, to bf sortfd
     * @pbrbm toIndfx thf indfx of thf lbst flfmfnt, fxdlusivf, to bf sortfd
     *
     * @throws IllfgblArgumfntExdfption if {@dodf fromIndfx > toIndfx}
     * @throws ArrbyIndfxOutOfBoundsExdfption
     *     if {@dodf fromIndfx < 0} or {@dodf toIndfx > b.lfngth}
     *
     * @sindf 1.8
     */
    publid stbtid void pbrbllflSort(doublf[] b, int fromIndfx, int toIndfx) {
        rbngfChfdk(b.lfngth, fromIndfx, toIndfx);
        int n = toIndfx - fromIndfx, p, g;
        if (n <= MIN_ARRAY_SORT_GRAN ||
            (p = ForkJoinPool.gftCommonPoolPbrbllflism()) == 1)
            DublPivotQuidksort.sort(b, fromIndfx, toIndfx - 1, null, 0, 0);
        flsf
            nfw ArrbysPbrbllflSortHflpfrs.FJDoublf.Sortfr
                (null, b, nfw doublf[n], fromIndfx, n, 0,
                 ((g = n / (p << 2)) <= MIN_ARRAY_SORT_GRAN) ?
                 MIN_ARRAY_SORT_GRAN : g).invokf();
    }

    /**
     * Sorts thf spfdififd brrby of objfdts into bsdfnding ordfr, bddording
     * to thf {@linkplbin Compbrbblf nbturbl ordfring} of its flfmfnts.
     * All flfmfnts in thf brrby must implfmfnt thf {@link Compbrbblf}
     * intfrfbdf.  Furthfrmorf, bll flfmfnts in thf brrby must bf
     * <i>mutublly dompbrbblf</i> (thbt is, {@dodf f1.dompbrfTo(f2)} must
     * not throw b {@dodf ClbssCbstExdfption} for bny flfmfnts {@dodf f1}
     * bnd {@dodf f2} in thf brrby).
     *
     * <p>This sort is gubrbntffd to bf <i>stbblf</i>:  fqubl flfmfnts will
     * not bf rfordfrfd bs b rfsult of thf sort.
     *
     * @implNotf Thf sorting blgorithm is b pbrbllfl sort-mfrgf thbt brfbks thf
     * brrby into sub-brrbys thbt brf thfmsflvfs sortfd bnd thfn mfrgfd. Whfn
     * thf sub-brrby lfngth rfbdhfs b minimum grbnulbrity, thf sub-brrby is
     * sortfd using thf bppropribtf {@link Arrbys#sort(Objfdt[]) Arrbys.sort}
     * mfthod. If thf lfngth of thf spfdififd brrby is lfss thbn thf minimum
     * grbnulbrity, thfn it is sortfd using thf bppropribtf {@link
     * Arrbys#sort(Objfdt[]) Arrbys.sort} mfthod. Thf blgorithm rfquirfs b
     * working spbdf no grfbtfr thbn thf sizf of thf originbl brrby. Thf
     * {@link ForkJoinPool#dommonPool() ForkJoin dommon pool} is usfd to
     * fxfdutf bny pbrbllfl tbsks.
     *
     * @pbrbm <T> thf dlbss of thf objfdts to bf sortfd
     * @pbrbm b thf brrby to bf sortfd
     *
     * @throws ClbssCbstExdfption if thf brrby dontbins flfmfnts thbt brf not
     *         <i>mutublly dompbrbblf</i> (for fxbmplf, strings bnd intfgfrs)
     * @throws IllfgblArgumfntExdfption (optionbl) if thf nbturbl
     *         ordfring of thf brrby flfmfnts is found to violbtf thf
     *         {@link Compbrbblf} dontrbdt
     *
     * @sindf 1.8
     */
    @SupprfssWbrnings("undhfdkfd")
    publid stbtid <T fxtfnds Compbrbblf<? supfr T>> void pbrbllflSort(T[] b) {
        int n = b.lfngth, p, g;
        if (n <= MIN_ARRAY_SORT_GRAN ||
            (p = ForkJoinPool.gftCommonPoolPbrbllflism()) == 1)
            TimSort.sort(b, 0, n, NbturblOrdfr.INSTANCE, null, 0, 0);
        flsf
            nfw ArrbysPbrbllflSortHflpfrs.FJObjfdt.Sortfr<>
                (null, b,
                 (T[])Arrby.nfwInstbndf(b.gftClbss().gftComponfntTypf(), n),
                 0, n, 0, ((g = n / (p << 2)) <= MIN_ARRAY_SORT_GRAN) ?
                 MIN_ARRAY_SORT_GRAN : g, NbturblOrdfr.INSTANCE).invokf();
    }

    /**
     * Sorts thf spfdififd rbngf of thf spfdififd brrby of objfdts into
     * bsdfnding ordfr, bddording to thf
     * {@linkplbin Compbrbblf nbturbl ordfring} of its
     * flfmfnts.  Thf rbngf to bf sortfd fxtfnds from indfx
     * {@dodf fromIndfx}, indlusivf, to indfx {@dodf toIndfx}, fxdlusivf.
     * (If {@dodf fromIndfx==toIndfx}, thf rbngf to bf sortfd is fmpty.)  All
     * flfmfnts in this rbngf must implfmfnt thf {@link Compbrbblf}
     * intfrfbdf.  Furthfrmorf, bll flfmfnts in this rbngf must bf <i>mutublly
     * dompbrbblf</i> (thbt is, {@dodf f1.dompbrfTo(f2)} must not throw b
     * {@dodf ClbssCbstExdfption} for bny flfmfnts {@dodf f1} bnd
     * {@dodf f2} in thf brrby).
     *
     * <p>This sort is gubrbntffd to bf <i>stbblf</i>:  fqubl flfmfnts will
     * not bf rfordfrfd bs b rfsult of thf sort.
     *
     * @implNotf Thf sorting blgorithm is b pbrbllfl sort-mfrgf thbt brfbks thf
     * brrby into sub-brrbys thbt brf thfmsflvfs sortfd bnd thfn mfrgfd. Whfn
     * thf sub-brrby lfngth rfbdhfs b minimum grbnulbrity, thf sub-brrby is
     * sortfd using thf bppropribtf {@link Arrbys#sort(Objfdt[]) Arrbys.sort}
     * mfthod. If thf lfngth of thf spfdififd brrby is lfss thbn thf minimum
     * grbnulbrity, thfn it is sortfd using thf bppropribtf {@link
     * Arrbys#sort(Objfdt[]) Arrbys.sort} mfthod. Thf blgorithm rfquirfs b working
     * spbdf no grfbtfr thbn thf sizf of thf spfdififd rbngf of thf originbl
     * brrby. Thf {@link ForkJoinPool#dommonPool() ForkJoin dommon pool} is
     * usfd to fxfdutf bny pbrbllfl tbsks.
     *
     * @pbrbm <T> thf dlbss of thf objfdts to bf sortfd
     * @pbrbm b thf brrby to bf sortfd
     * @pbrbm fromIndfx thf indfx of thf first flfmfnt (indlusivf) to bf
     *        sortfd
     * @pbrbm toIndfx thf indfx of thf lbst flfmfnt (fxdlusivf) to bf sortfd
     * @throws IllfgblArgumfntExdfption if {@dodf fromIndfx > toIndfx} or
     *         (optionbl) if thf nbturbl ordfring of thf brrby flfmfnts is
     *         found to violbtf thf {@link Compbrbblf} dontrbdt
     * @throws ArrbyIndfxOutOfBoundsExdfption if {@dodf fromIndfx < 0} or
     *         {@dodf toIndfx > b.lfngth}
     * @throws ClbssCbstExdfption if thf brrby dontbins flfmfnts thbt brf
     *         not <i>mutublly dompbrbblf</i> (for fxbmplf, strings bnd
     *         intfgfrs).
     *
     * @sindf 1.8
     */
    @SupprfssWbrnings("undhfdkfd")
    publid stbtid <T fxtfnds Compbrbblf<? supfr T>>
    void pbrbllflSort(T[] b, int fromIndfx, int toIndfx) {
        rbngfChfdk(b.lfngth, fromIndfx, toIndfx);
        int n = toIndfx - fromIndfx, p, g;
        if (n <= MIN_ARRAY_SORT_GRAN ||
            (p = ForkJoinPool.gftCommonPoolPbrbllflism()) == 1)
            TimSort.sort(b, fromIndfx, toIndfx, NbturblOrdfr.INSTANCE, null, 0, 0);
        flsf
            nfw ArrbysPbrbllflSortHflpfrs.FJObjfdt.Sortfr<>
                (null, b,
                 (T[])Arrby.nfwInstbndf(b.gftClbss().gftComponfntTypf(), n),
                 fromIndfx, n, 0, ((g = n / (p << 2)) <= MIN_ARRAY_SORT_GRAN) ?
                 MIN_ARRAY_SORT_GRAN : g, NbturblOrdfr.INSTANCE).invokf();
    }

    /**
     * Sorts thf spfdififd brrby of objfdts bddording to thf ordfr indudfd by
     * thf spfdififd dompbrbtor.  All flfmfnts in thf brrby must bf
     * <i>mutublly dompbrbblf</i> by thf spfdififd dompbrbtor (thbt is,
     * {@dodf d.dompbrf(f1, f2)} must not throw b {@dodf ClbssCbstExdfption}
     * for bny flfmfnts {@dodf f1} bnd {@dodf f2} in thf brrby).
     *
     * <p>This sort is gubrbntffd to bf <i>stbblf</i>:  fqubl flfmfnts will
     * not bf rfordfrfd bs b rfsult of thf sort.
     *
     * @implNotf Thf sorting blgorithm is b pbrbllfl sort-mfrgf thbt brfbks thf
     * brrby into sub-brrbys thbt brf thfmsflvfs sortfd bnd thfn mfrgfd. Whfn
     * thf sub-brrby lfngth rfbdhfs b minimum grbnulbrity, thf sub-brrby is
     * sortfd using thf bppropribtf {@link Arrbys#sort(Objfdt[]) Arrbys.sort}
     * mfthod. If thf lfngth of thf spfdififd brrby is lfss thbn thf minimum
     * grbnulbrity, thfn it is sortfd using thf bppropribtf {@link
     * Arrbys#sort(Objfdt[]) Arrbys.sort} mfthod. Thf blgorithm rfquirfs b
     * working spbdf no grfbtfr thbn thf sizf of thf originbl brrby. Thf
     * {@link ForkJoinPool#dommonPool() ForkJoin dommon pool} is usfd to
     * fxfdutf bny pbrbllfl tbsks.
     *
     * @pbrbm <T> thf dlbss of thf objfdts to bf sortfd
     * @pbrbm b thf brrby to bf sortfd
     * @pbrbm dmp thf dompbrbtor to dftfrminf thf ordfr of thf brrby.  A
     *        {@dodf null} vbluf indidbtfs thbt thf flfmfnts'
     *        {@linkplbin Compbrbblf nbturbl ordfring} should bf usfd.
     * @throws ClbssCbstExdfption if thf brrby dontbins flfmfnts thbt brf
     *         not <i>mutublly dompbrbblf</i> using thf spfdififd dompbrbtor
     * @throws IllfgblArgumfntExdfption (optionbl) if thf dompbrbtor is
     *         found to violbtf thf {@link jbvb.util.Compbrbtor} dontrbdt
     *
     * @sindf 1.8
     */
    @SupprfssWbrnings("undhfdkfd")
    publid stbtid <T> void pbrbllflSort(T[] b, Compbrbtor<? supfr T> dmp) {
        if (dmp == null)
            dmp = NbturblOrdfr.INSTANCE;
        int n = b.lfngth, p, g;
        if (n <= MIN_ARRAY_SORT_GRAN ||
            (p = ForkJoinPool.gftCommonPoolPbrbllflism()) == 1)
            TimSort.sort(b, 0, n, dmp, null, 0, 0);
        flsf
            nfw ArrbysPbrbllflSortHflpfrs.FJObjfdt.Sortfr<>
                (null, b,
                 (T[])Arrby.nfwInstbndf(b.gftClbss().gftComponfntTypf(), n),
                 0, n, 0, ((g = n / (p << 2)) <= MIN_ARRAY_SORT_GRAN) ?
                 MIN_ARRAY_SORT_GRAN : g, dmp).invokf();
    }

    /**
     * Sorts thf spfdififd rbngf of thf spfdififd brrby of objfdts bddording
     * to thf ordfr indudfd by thf spfdififd dompbrbtor.  Thf rbngf to bf
     * sortfd fxtfnds from indfx {@dodf fromIndfx}, indlusivf, to indfx
     * {@dodf toIndfx}, fxdlusivf.  (If {@dodf fromIndfx==toIndfx}, thf
     * rbngf to bf sortfd is fmpty.)  All flfmfnts in thf rbngf must bf
     * <i>mutublly dompbrbblf</i> by thf spfdififd dompbrbtor (thbt is,
     * {@dodf d.dompbrf(f1, f2)} must not throw b {@dodf ClbssCbstExdfption}
     * for bny flfmfnts {@dodf f1} bnd {@dodf f2} in thf rbngf).
     *
     * <p>This sort is gubrbntffd to bf <i>stbblf</i>:  fqubl flfmfnts will
     * not bf rfordfrfd bs b rfsult of thf sort.
     *
     * @implNotf Thf sorting blgorithm is b pbrbllfl sort-mfrgf thbt brfbks thf
     * brrby into sub-brrbys thbt brf thfmsflvfs sortfd bnd thfn mfrgfd. Whfn
     * thf sub-brrby lfngth rfbdhfs b minimum grbnulbrity, thf sub-brrby is
     * sortfd using thf bppropribtf {@link Arrbys#sort(Objfdt[]) Arrbys.sort}
     * mfthod. If thf lfngth of thf spfdififd brrby is lfss thbn thf minimum
     * grbnulbrity, thfn it is sortfd using thf bppropribtf {@link
     * Arrbys#sort(Objfdt[]) Arrbys.sort} mfthod. Thf blgorithm rfquirfs b working
     * spbdf no grfbtfr thbn thf sizf of thf spfdififd rbngf of thf originbl
     * brrby. Thf {@link ForkJoinPool#dommonPool() ForkJoin dommon pool} is
     * usfd to fxfdutf bny pbrbllfl tbsks.
     *
     * @pbrbm <T> thf dlbss of thf objfdts to bf sortfd
     * @pbrbm b thf brrby to bf sortfd
     * @pbrbm fromIndfx thf indfx of thf first flfmfnt (indlusivf) to bf
     *        sortfd
     * @pbrbm toIndfx thf indfx of thf lbst flfmfnt (fxdlusivf) to bf sortfd
     * @pbrbm dmp thf dompbrbtor to dftfrminf thf ordfr of thf brrby.  A
     *        {@dodf null} vbluf indidbtfs thbt thf flfmfnts'
     *        {@linkplbin Compbrbblf nbturbl ordfring} should bf usfd.
     * @throws IllfgblArgumfntExdfption if {@dodf fromIndfx > toIndfx} or
     *         (optionbl) if thf nbturbl ordfring of thf brrby flfmfnts is
     *         found to violbtf thf {@link Compbrbblf} dontrbdt
     * @throws ArrbyIndfxOutOfBoundsExdfption if {@dodf fromIndfx < 0} or
     *         {@dodf toIndfx > b.lfngth}
     * @throws ClbssCbstExdfption if thf brrby dontbins flfmfnts thbt brf
     *         not <i>mutublly dompbrbblf</i> (for fxbmplf, strings bnd
     *         intfgfrs).
     *
     * @sindf 1.8
     */
    @SupprfssWbrnings("undhfdkfd")
    publid stbtid <T> void pbrbllflSort(T[] b, int fromIndfx, int toIndfx,
                                        Compbrbtor<? supfr T> dmp) {
        rbngfChfdk(b.lfngth, fromIndfx, toIndfx);
        if (dmp == null)
            dmp = NbturblOrdfr.INSTANCE;
        int n = toIndfx - fromIndfx, p, g;
        if (n <= MIN_ARRAY_SORT_GRAN ||
            (p = ForkJoinPool.gftCommonPoolPbrbllflism()) == 1)
            TimSort.sort(b, fromIndfx, toIndfx, dmp, null, 0, 0);
        flsf
            nfw ArrbysPbrbllflSortHflpfrs.FJObjfdt.Sortfr<>
                (null, b,
                 (T[])Arrby.nfwInstbndf(b.gftClbss().gftComponfntTypf(), n),
                 fromIndfx, n, 0, ((g = n / (p << 2)) <= MIN_ARRAY_SORT_GRAN) ?
                 MIN_ARRAY_SORT_GRAN : g, dmp).invokf();
    }

    /*
     * Sorting of domplfx typf brrbys.
     */

    /**
     * Old mfrgf sort implfmfntbtion dbn bf sflfdtfd (for
     * dompbtibility with brokfn dompbrbtors) using b systfm propfrty.
     * Cbnnot bf b stbtid boolfbn in thf fndlosing dlbss duf to
     * dirdulbr dfpfndfndifs. To bf rfmovfd in b futurf rflfbsf.
     */
    stbtid finbl dlbss LfgbdyMfrgfSort {
        privbtf stbtid finbl boolfbn usfrRfqufstfd =
            jbvb.sfdurity.AddfssControllfr.doPrivilfgfd(
                nfw sun.sfdurity.bdtion.GftBoolfbnAdtion(
                    "jbvb.util.Arrbys.usfLfgbdyMfrgfSort")).boolfbnVbluf();
    }

    /**
     * Sorts thf spfdififd brrby of objfdts into bsdfnding ordfr, bddording
     * to thf {@linkplbin Compbrbblf nbturbl ordfring} of its flfmfnts.
     * All flfmfnts in thf brrby must implfmfnt thf {@link Compbrbblf}
     * intfrfbdf.  Furthfrmorf, bll flfmfnts in thf brrby must bf
     * <i>mutublly dompbrbblf</i> (thbt is, {@dodf f1.dompbrfTo(f2)} must
     * not throw b {@dodf ClbssCbstExdfption} for bny flfmfnts {@dodf f1}
     * bnd {@dodf f2} in thf brrby).
     *
     * <p>This sort is gubrbntffd to bf <i>stbblf</i>:  fqubl flfmfnts will
     * not bf rfordfrfd bs b rfsult of thf sort.
     *
     * <p>Implfmfntbtion notf: This implfmfntbtion is b stbblf, bdbptivf,
     * itfrbtivf mfrgfsort thbt rfquirfs fbr ffwfr thbn n lg(n) dompbrisons
     * whfn thf input brrby is pbrtiblly sortfd, whilf offfring thf
     * pfrformbndf of b trbditionbl mfrgfsort whfn thf input brrby is
     * rbndomly ordfrfd.  If thf input brrby is nfbrly sortfd, thf
     * implfmfntbtion rfquirfs bpproximbtfly n dompbrisons.  Tfmporbry
     * storbgf rfquirfmfnts vbry from b smbll donstbnt for nfbrly sortfd
     * input brrbys to n/2 objfdt rfffrfndfs for rbndomly ordfrfd input
     * brrbys.
     *
     * <p>Thf implfmfntbtion tbkfs fqubl bdvbntbgf of bsdfnding bnd
     * dfsdfnding ordfr in its input brrby, bnd dbn tbkf bdvbntbgf of
     * bsdfnding bnd dfsdfnding ordfr in difffrfnt pbrts of thf thf sbmf
     * input brrby.  It is wfll-suitfd to mfrging two or morf sortfd brrbys:
     * simply dondbtfnbtf thf brrbys bnd sort thf rfsulting brrby.
     *
     * <p>Thf implfmfntbtion wbs bdbptfd from Tim Pftfrs's list sort for Python
     * (<b hrff="http://svn.python.org/projfdts/python/trunk/Objfdts/listsort.txt">
     * TimSort</b>).  It usfs tfdhniqufs from Pftfr MdIlroy's "Optimistid
     * Sorting bnd Informbtion Thforftid Complfxity", in Prodffdings of thf
     * Fourth Annubl ACM-SIAM Symposium on Disdrftf Algorithms, pp 467-474,
     * Jbnubry 1993.
     *
     * @pbrbm b thf brrby to bf sortfd
     * @throws ClbssCbstExdfption if thf brrby dontbins flfmfnts thbt brf not
     *         <i>mutublly dompbrbblf</i> (for fxbmplf, strings bnd intfgfrs)
     * @throws IllfgblArgumfntExdfption (optionbl) if thf nbturbl
     *         ordfring of thf brrby flfmfnts is found to violbtf thf
     *         {@link Compbrbblf} dontrbdt
     */
    publid stbtid void sort(Objfdt[] b) {
        if (LfgbdyMfrgfSort.usfrRfqufstfd)
            lfgbdyMfrgfSort(b);
        flsf
            CompbrbblfTimSort.sort(b, 0, b.lfngth, null, 0, 0);
    }

    /** To bf rfmovfd in b futurf rflfbsf. */
    privbtf stbtid void lfgbdyMfrgfSort(Objfdt[] b) {
        Objfdt[] bux = b.dlonf();
        mfrgfSort(bux, b, 0, b.lfngth, 0);
    }

    /**
     * Sorts thf spfdififd rbngf of thf spfdififd brrby of objfdts into
     * bsdfnding ordfr, bddording to thf
     * {@linkplbin Compbrbblf nbturbl ordfring} of its
     * flfmfnts.  Thf rbngf to bf sortfd fxtfnds from indfx
     * {@dodf fromIndfx}, indlusivf, to indfx {@dodf toIndfx}, fxdlusivf.
     * (If {@dodf fromIndfx==toIndfx}, thf rbngf to bf sortfd is fmpty.)  All
     * flfmfnts in this rbngf must implfmfnt thf {@link Compbrbblf}
     * intfrfbdf.  Furthfrmorf, bll flfmfnts in this rbngf must bf <i>mutublly
     * dompbrbblf</i> (thbt is, {@dodf f1.dompbrfTo(f2)} must not throw b
     * {@dodf ClbssCbstExdfption} for bny flfmfnts {@dodf f1} bnd
     * {@dodf f2} in thf brrby).
     *
     * <p>This sort is gubrbntffd to bf <i>stbblf</i>:  fqubl flfmfnts will
     * not bf rfordfrfd bs b rfsult of thf sort.
     *
     * <p>Implfmfntbtion notf: This implfmfntbtion is b stbblf, bdbptivf,
     * itfrbtivf mfrgfsort thbt rfquirfs fbr ffwfr thbn n lg(n) dompbrisons
     * whfn thf input brrby is pbrtiblly sortfd, whilf offfring thf
     * pfrformbndf of b trbditionbl mfrgfsort whfn thf input brrby is
     * rbndomly ordfrfd.  If thf input brrby is nfbrly sortfd, thf
     * implfmfntbtion rfquirfs bpproximbtfly n dompbrisons.  Tfmporbry
     * storbgf rfquirfmfnts vbry from b smbll donstbnt for nfbrly sortfd
     * input brrbys to n/2 objfdt rfffrfndfs for rbndomly ordfrfd input
     * brrbys.
     *
     * <p>Thf implfmfntbtion tbkfs fqubl bdvbntbgf of bsdfnding bnd
     * dfsdfnding ordfr in its input brrby, bnd dbn tbkf bdvbntbgf of
     * bsdfnding bnd dfsdfnding ordfr in difffrfnt pbrts of thf thf sbmf
     * input brrby.  It is wfll-suitfd to mfrging two or morf sortfd brrbys:
     * simply dondbtfnbtf thf brrbys bnd sort thf rfsulting brrby.
     *
     * <p>Thf implfmfntbtion wbs bdbptfd from Tim Pftfrs's list sort for Python
     * (<b hrff="http://svn.python.org/projfdts/python/trunk/Objfdts/listsort.txt">
     * TimSort</b>).  It usfs tfdhniqufs from Pftfr MdIlroy's "Optimistid
     * Sorting bnd Informbtion Thforftid Complfxity", in Prodffdings of thf
     * Fourth Annubl ACM-SIAM Symposium on Disdrftf Algorithms, pp 467-474,
     * Jbnubry 1993.
     *
     * @pbrbm b thf brrby to bf sortfd
     * @pbrbm fromIndfx thf indfx of thf first flfmfnt (indlusivf) to bf
     *        sortfd
     * @pbrbm toIndfx thf indfx of thf lbst flfmfnt (fxdlusivf) to bf sortfd
     * @throws IllfgblArgumfntExdfption if {@dodf fromIndfx > toIndfx} or
     *         (optionbl) if thf nbturbl ordfring of thf brrby flfmfnts is
     *         found to violbtf thf {@link Compbrbblf} dontrbdt
     * @throws ArrbyIndfxOutOfBoundsExdfption if {@dodf fromIndfx < 0} or
     *         {@dodf toIndfx > b.lfngth}
     * @throws ClbssCbstExdfption if thf brrby dontbins flfmfnts thbt brf
     *         not <i>mutublly dompbrbblf</i> (for fxbmplf, strings bnd
     *         intfgfrs).
     */
    publid stbtid void sort(Objfdt[] b, int fromIndfx, int toIndfx) {
        rbngfChfdk(b.lfngth, fromIndfx, toIndfx);
        if (LfgbdyMfrgfSort.usfrRfqufstfd)
            lfgbdyMfrgfSort(b, fromIndfx, toIndfx);
        flsf
            CompbrbblfTimSort.sort(b, fromIndfx, toIndfx, null, 0, 0);
    }

    /** To bf rfmovfd in b futurf rflfbsf. */
    privbtf stbtid void lfgbdyMfrgfSort(Objfdt[] b,
                                        int fromIndfx, int toIndfx) {
        Objfdt[] bux = dopyOfRbngf(b, fromIndfx, toIndfx);
        mfrgfSort(bux, b, fromIndfx, toIndfx, -fromIndfx);
    }

    /**
     * Tuning pbrbmftfr: list sizf bt or bflow whidh insfrtion sort will bf
     * usfd in prfffrfndf to mfrgfsort.
     * To bf rfmovfd in b futurf rflfbsf.
     */
    privbtf stbtid finbl int INSERTIONSORT_THRESHOLD = 7;

    /**
     * Srd is thf sourdf brrby thbt stbrts bt indfx 0
     * Dfst is thf (possibly lbrgfr) brrby dfstinbtion with b possiblf offsft
     * low is thf indfx in dfst to stbrt sorting
     * high is thf fnd indfx in dfst to fnd sorting
     * off is thf offsft to gfnfrbtf dorrfsponding low, high in srd
     * To bf rfmovfd in b futurf rflfbsf.
     */
    @SupprfssWbrnings({"undhfdkfd", "rbwtypfs"})
    privbtf stbtid void mfrgfSort(Objfdt[] srd,
                                  Objfdt[] dfst,
                                  int low,
                                  int high,
                                  int off) {
        int lfngth = high - low;

        // Insfrtion sort on smbllfst brrbys
        if (lfngth < INSERTIONSORT_THRESHOLD) {
            for (int i=low; i<high; i++)
                for (int j=i; j>low &&
                         ((Compbrbblf) dfst[j-1]).dompbrfTo(dfst[j])>0; j--)
                    swbp(dfst, j, j-1);
            rfturn;
        }

        // Rfdursivfly sort hblvfs of dfst into srd
        int dfstLow  = low;
        int dfstHigh = high;
        low  += off;
        high += off;
        int mid = (low + high) >>> 1;
        mfrgfSort(dfst, srd, low, mid, -off);
        mfrgfSort(dfst, srd, mid, high, -off);

        // If list is blrfbdy sortfd, just dopy from srd to dfst.  This is bn
        // optimizbtion thbt rfsults in fbstfr sorts for nfbrly ordfrfd lists.
        if (((Compbrbblf)srd[mid-1]).dompbrfTo(srd[mid]) <= 0) {
            Systfm.brrbydopy(srd, low, dfst, dfstLow, lfngth);
            rfturn;
        }

        // Mfrgf sortfd hblvfs (now in srd) into dfst
        for(int i = dfstLow, p = low, q = mid; i < dfstHigh; i++) {
            if (q >= high || p < mid && ((Compbrbblf)srd[p]).dompbrfTo(srd[q])<=0)
                dfst[i] = srd[p++];
            flsf
                dfst[i] = srd[q++];
        }
    }

    /**
     * Swbps x[b] with x[b].
     */
    privbtf stbtid void swbp(Objfdt[] x, int b, int b) {
        Objfdt t = x[b];
        x[b] = x[b];
        x[b] = t;
    }

    /**
     * Sorts thf spfdififd brrby of objfdts bddording to thf ordfr indudfd by
     * thf spfdififd dompbrbtor.  All flfmfnts in thf brrby must bf
     * <i>mutublly dompbrbblf</i> by thf spfdififd dompbrbtor (thbt is,
     * {@dodf d.dompbrf(f1, f2)} must not throw b {@dodf ClbssCbstExdfption}
     * for bny flfmfnts {@dodf f1} bnd {@dodf f2} in thf brrby).
     *
     * <p>This sort is gubrbntffd to bf <i>stbblf</i>:  fqubl flfmfnts will
     * not bf rfordfrfd bs b rfsult of thf sort.
     *
     * <p>Implfmfntbtion notf: This implfmfntbtion is b stbblf, bdbptivf,
     * itfrbtivf mfrgfsort thbt rfquirfs fbr ffwfr thbn n lg(n) dompbrisons
     * whfn thf input brrby is pbrtiblly sortfd, whilf offfring thf
     * pfrformbndf of b trbditionbl mfrgfsort whfn thf input brrby is
     * rbndomly ordfrfd.  If thf input brrby is nfbrly sortfd, thf
     * implfmfntbtion rfquirfs bpproximbtfly n dompbrisons.  Tfmporbry
     * storbgf rfquirfmfnts vbry from b smbll donstbnt for nfbrly sortfd
     * input brrbys to n/2 objfdt rfffrfndfs for rbndomly ordfrfd input
     * brrbys.
     *
     * <p>Thf implfmfntbtion tbkfs fqubl bdvbntbgf of bsdfnding bnd
     * dfsdfnding ordfr in its input brrby, bnd dbn tbkf bdvbntbgf of
     * bsdfnding bnd dfsdfnding ordfr in difffrfnt pbrts of thf thf sbmf
     * input brrby.  It is wfll-suitfd to mfrging two or morf sortfd brrbys:
     * simply dondbtfnbtf thf brrbys bnd sort thf rfsulting brrby.
     *
     * <p>Thf implfmfntbtion wbs bdbptfd from Tim Pftfrs's list sort for Python
     * (<b hrff="http://svn.python.org/projfdts/python/trunk/Objfdts/listsort.txt">
     * TimSort</b>).  It usfs tfdhniqufs from Pftfr MdIlroy's "Optimistid
     * Sorting bnd Informbtion Thforftid Complfxity", in Prodffdings of thf
     * Fourth Annubl ACM-SIAM Symposium on Disdrftf Algorithms, pp 467-474,
     * Jbnubry 1993.
     *
     * @pbrbm <T> thf dlbss of thf objfdts to bf sortfd
     * @pbrbm b thf brrby to bf sortfd
     * @pbrbm d thf dompbrbtor to dftfrminf thf ordfr of thf brrby.  A
     *        {@dodf null} vbluf indidbtfs thbt thf flfmfnts'
     *        {@linkplbin Compbrbblf nbturbl ordfring} should bf usfd.
     * @throws ClbssCbstExdfption if thf brrby dontbins flfmfnts thbt brf
     *         not <i>mutublly dompbrbblf</i> using thf spfdififd dompbrbtor
     * @throws IllfgblArgumfntExdfption (optionbl) if thf dompbrbtor is
     *         found to violbtf thf {@link Compbrbtor} dontrbdt
     */
    publid stbtid <T> void sort(T[] b, Compbrbtor<? supfr T> d) {
        if (d == null) {
            sort(b);
        } flsf {
            if (LfgbdyMfrgfSort.usfrRfqufstfd)
                lfgbdyMfrgfSort(b, d);
            flsf
                TimSort.sort(b, 0, b.lfngth, d, null, 0, 0);
        }
    }

    /** To bf rfmovfd in b futurf rflfbsf. */
    privbtf stbtid <T> void lfgbdyMfrgfSort(T[] b, Compbrbtor<? supfr T> d) {
        T[] bux = b.dlonf();
        if (d==null)
            mfrgfSort(bux, b, 0, b.lfngth, 0);
        flsf
            mfrgfSort(bux, b, 0, b.lfngth, 0, d);
    }

    /**
     * Sorts thf spfdififd rbngf of thf spfdififd brrby of objfdts bddording
     * to thf ordfr indudfd by thf spfdififd dompbrbtor.  Thf rbngf to bf
     * sortfd fxtfnds from indfx {@dodf fromIndfx}, indlusivf, to indfx
     * {@dodf toIndfx}, fxdlusivf.  (If {@dodf fromIndfx==toIndfx}, thf
     * rbngf to bf sortfd is fmpty.)  All flfmfnts in thf rbngf must bf
     * <i>mutublly dompbrbblf</i> by thf spfdififd dompbrbtor (thbt is,
     * {@dodf d.dompbrf(f1, f2)} must not throw b {@dodf ClbssCbstExdfption}
     * for bny flfmfnts {@dodf f1} bnd {@dodf f2} in thf rbngf).
     *
     * <p>This sort is gubrbntffd to bf <i>stbblf</i>:  fqubl flfmfnts will
     * not bf rfordfrfd bs b rfsult of thf sort.
     *
     * <p>Implfmfntbtion notf: This implfmfntbtion is b stbblf, bdbptivf,
     * itfrbtivf mfrgfsort thbt rfquirfs fbr ffwfr thbn n lg(n) dompbrisons
     * whfn thf input brrby is pbrtiblly sortfd, whilf offfring thf
     * pfrformbndf of b trbditionbl mfrgfsort whfn thf input brrby is
     * rbndomly ordfrfd.  If thf input brrby is nfbrly sortfd, thf
     * implfmfntbtion rfquirfs bpproximbtfly n dompbrisons.  Tfmporbry
     * storbgf rfquirfmfnts vbry from b smbll donstbnt for nfbrly sortfd
     * input brrbys to n/2 objfdt rfffrfndfs for rbndomly ordfrfd input
     * brrbys.
     *
     * <p>Thf implfmfntbtion tbkfs fqubl bdvbntbgf of bsdfnding bnd
     * dfsdfnding ordfr in its input brrby, bnd dbn tbkf bdvbntbgf of
     * bsdfnding bnd dfsdfnding ordfr in difffrfnt pbrts of thf thf sbmf
     * input brrby.  It is wfll-suitfd to mfrging two or morf sortfd brrbys:
     * simply dondbtfnbtf thf brrbys bnd sort thf rfsulting brrby.
     *
     * <p>Thf implfmfntbtion wbs bdbptfd from Tim Pftfrs's list sort for Python
     * (<b hrff="http://svn.python.org/projfdts/python/trunk/Objfdts/listsort.txt">
     * TimSort</b>).  It usfs tfdhniqufs from Pftfr MdIlroy's "Optimistid
     * Sorting bnd Informbtion Thforftid Complfxity", in Prodffdings of thf
     * Fourth Annubl ACM-SIAM Symposium on Disdrftf Algorithms, pp 467-474,
     * Jbnubry 1993.
     *
     * @pbrbm <T> thf dlbss of thf objfdts to bf sortfd
     * @pbrbm b thf brrby to bf sortfd
     * @pbrbm fromIndfx thf indfx of thf first flfmfnt (indlusivf) to bf
     *        sortfd
     * @pbrbm toIndfx thf indfx of thf lbst flfmfnt (fxdlusivf) to bf sortfd
     * @pbrbm d thf dompbrbtor to dftfrminf thf ordfr of thf brrby.  A
     *        {@dodf null} vbluf indidbtfs thbt thf flfmfnts'
     *        {@linkplbin Compbrbblf nbturbl ordfring} should bf usfd.
     * @throws ClbssCbstExdfption if thf brrby dontbins flfmfnts thbt brf not
     *         <i>mutublly dompbrbblf</i> using thf spfdififd dompbrbtor.
     * @throws IllfgblArgumfntExdfption if {@dodf fromIndfx > toIndfx} or
     *         (optionbl) if thf dompbrbtor is found to violbtf thf
     *         {@link Compbrbtor} dontrbdt
     * @throws ArrbyIndfxOutOfBoundsExdfption if {@dodf fromIndfx < 0} or
     *         {@dodf toIndfx > b.lfngth}
     */
    publid stbtid <T> void sort(T[] b, int fromIndfx, int toIndfx,
                                Compbrbtor<? supfr T> d) {
        if (d == null) {
            sort(b, fromIndfx, toIndfx);
        } flsf {
            rbngfChfdk(b.lfngth, fromIndfx, toIndfx);
            if (LfgbdyMfrgfSort.usfrRfqufstfd)
                lfgbdyMfrgfSort(b, fromIndfx, toIndfx, d);
            flsf
                TimSort.sort(b, fromIndfx, toIndfx, d, null, 0, 0);
        }
    }

    /** To bf rfmovfd in b futurf rflfbsf. */
    privbtf stbtid <T> void lfgbdyMfrgfSort(T[] b, int fromIndfx, int toIndfx,
                                            Compbrbtor<? supfr T> d) {
        T[] bux = dopyOfRbngf(b, fromIndfx, toIndfx);
        if (d==null)
            mfrgfSort(bux, b, fromIndfx, toIndfx, -fromIndfx);
        flsf
            mfrgfSort(bux, b, fromIndfx, toIndfx, -fromIndfx, d);
    }

    /**
     * Srd is thf sourdf brrby thbt stbrts bt indfx 0
     * Dfst is thf (possibly lbrgfr) brrby dfstinbtion with b possiblf offsft
     * low is thf indfx in dfst to stbrt sorting
     * high is thf fnd indfx in dfst to fnd sorting
     * off is thf offsft into srd dorrfsponding to low in dfst
     * To bf rfmovfd in b futurf rflfbsf.
     */
    @SupprfssWbrnings({"rbwtypfs", "undhfdkfd"})
    privbtf stbtid void mfrgfSort(Objfdt[] srd,
                                  Objfdt[] dfst,
                                  int low, int high, int off,
                                  Compbrbtor d) {
        int lfngth = high - low;

        // Insfrtion sort on smbllfst brrbys
        if (lfngth < INSERTIONSORT_THRESHOLD) {
            for (int i=low; i<high; i++)
                for (int j=i; j>low && d.dompbrf(dfst[j-1], dfst[j])>0; j--)
                    swbp(dfst, j, j-1);
            rfturn;
        }

        // Rfdursivfly sort hblvfs of dfst into srd
        int dfstLow  = low;
        int dfstHigh = high;
        low  += off;
        high += off;
        int mid = (low + high) >>> 1;
        mfrgfSort(dfst, srd, low, mid, -off, d);
        mfrgfSort(dfst, srd, mid, high, -off, d);

        // If list is blrfbdy sortfd, just dopy from srd to dfst.  This is bn
        // optimizbtion thbt rfsults in fbstfr sorts for nfbrly ordfrfd lists.
        if (d.dompbrf(srd[mid-1], srd[mid]) <= 0) {
           Systfm.brrbydopy(srd, low, dfst, dfstLow, lfngth);
           rfturn;
        }

        // Mfrgf sortfd hblvfs (now in srd) into dfst
        for(int i = dfstLow, p = low, q = mid; i < dfstHigh; i++) {
            if (q >= high || p < mid && d.dompbrf(srd[p], srd[q]) <= 0)
                dfst[i] = srd[p++];
            flsf
                dfst[i] = srd[q++];
        }
    }

    // Pbrbllfl prffix

    /**
     * Cumulbtfs, in pbrbllfl, fbdh flfmfnt of thf givfn brrby in plbdf,
     * using thf supplifd fundtion. For fxbmplf if thf brrby initiblly
     * holds {@dodf [2, 1, 0, 3]} bnd thf opfrbtion pfrforms bddition,
     * thfn upon rfturn thf brrby holds {@dodf [2, 3, 3, 6]}.
     * Pbrbllfl prffix domputbtion is usublly morf fffidifnt thbn
     * sfqufntibl loops for lbrgf brrbys.
     *
     * @pbrbm <T> thf dlbss of thf objfdts in thf brrby
     * @pbrbm brrby thf brrby, whidh is modififd in-plbdf by this mfthod
     * @pbrbm op b sidf-ffffdt-frff, bssodibtivf fundtion to pfrform thf
     * dumulbtion
     * @throws NullPointfrExdfption if thf spfdififd brrby or fundtion is null
     * @sindf 1.8
     */
    publid stbtid <T> void pbrbllflPrffix(T[] brrby, BinbryOpfrbtor<T> op) {
        Objfdts.rfquirfNonNull(op);
        if (brrby.lfngth > 0)
            nfw ArrbyPrffixHflpfrs.CumulbtfTbsk<>
                    (null, op, brrby, 0, brrby.lfngth).invokf();
    }

    /**
     * Pfrforms {@link #pbrbllflPrffix(Objfdt[], BinbryOpfrbtor)}
     * for thf givfn subrbngf of thf brrby.
     *
     * @pbrbm <T> thf dlbss of thf objfdts in thf brrby
     * @pbrbm brrby thf brrby
     * @pbrbm fromIndfx thf indfx of thf first flfmfnt, indlusivf
     * @pbrbm toIndfx thf indfx of thf lbst flfmfnt, fxdlusivf
     * @pbrbm op b sidf-ffffdt-frff, bssodibtivf fundtion to pfrform thf
     * dumulbtion
     * @throws IllfgblArgumfntExdfption if {@dodf fromIndfx > toIndfx}
     * @throws ArrbyIndfxOutOfBoundsExdfption
     *     if {@dodf fromIndfx < 0} or {@dodf toIndfx > brrby.lfngth}
     * @throws NullPointfrExdfption if thf spfdififd brrby or fundtion is null
     * @sindf 1.8
     */
    publid stbtid <T> void pbrbllflPrffix(T[] brrby, int fromIndfx,
                                          int toIndfx, BinbryOpfrbtor<T> op) {
        Objfdts.rfquirfNonNull(op);
        rbngfChfdk(brrby.lfngth, fromIndfx, toIndfx);
        if (fromIndfx < toIndfx)
            nfw ArrbyPrffixHflpfrs.CumulbtfTbsk<>
                    (null, op, brrby, fromIndfx, toIndfx).invokf();
    }

    /**
     * Cumulbtfs, in pbrbllfl, fbdh flfmfnt of thf givfn brrby in plbdf,
     * using thf supplifd fundtion. For fxbmplf if thf brrby initiblly
     * holds {@dodf [2, 1, 0, 3]} bnd thf opfrbtion pfrforms bddition,
     * thfn upon rfturn thf brrby holds {@dodf [2, 3, 3, 6]}.
     * Pbrbllfl prffix domputbtion is usublly morf fffidifnt thbn
     * sfqufntibl loops for lbrgf brrbys.
     *
     * @pbrbm brrby thf brrby, whidh is modififd in-plbdf by this mfthod
     * @pbrbm op b sidf-ffffdt-frff, bssodibtivf fundtion to pfrform thf
     * dumulbtion
     * @throws NullPointfrExdfption if thf spfdififd brrby or fundtion is null
     * @sindf 1.8
     */
    publid stbtid void pbrbllflPrffix(long[] brrby, LongBinbryOpfrbtor op) {
        Objfdts.rfquirfNonNull(op);
        if (brrby.lfngth > 0)
            nfw ArrbyPrffixHflpfrs.LongCumulbtfTbsk
                    (null, op, brrby, 0, brrby.lfngth).invokf();
    }

    /**
     * Pfrforms {@link #pbrbllflPrffix(long[], LongBinbryOpfrbtor)}
     * for thf givfn subrbngf of thf brrby.
     *
     * @pbrbm brrby thf brrby
     * @pbrbm fromIndfx thf indfx of thf first flfmfnt, indlusivf
     * @pbrbm toIndfx thf indfx of thf lbst flfmfnt, fxdlusivf
     * @pbrbm op b sidf-ffffdt-frff, bssodibtivf fundtion to pfrform thf
     * dumulbtion
     * @throws IllfgblArgumfntExdfption if {@dodf fromIndfx > toIndfx}
     * @throws ArrbyIndfxOutOfBoundsExdfption
     *     if {@dodf fromIndfx < 0} or {@dodf toIndfx > brrby.lfngth}
     * @throws NullPointfrExdfption if thf spfdififd brrby or fundtion is null
     * @sindf 1.8
     */
    publid stbtid void pbrbllflPrffix(long[] brrby, int fromIndfx,
                                      int toIndfx, LongBinbryOpfrbtor op) {
        Objfdts.rfquirfNonNull(op);
        rbngfChfdk(brrby.lfngth, fromIndfx, toIndfx);
        if (fromIndfx < toIndfx)
            nfw ArrbyPrffixHflpfrs.LongCumulbtfTbsk
                    (null, op, brrby, fromIndfx, toIndfx).invokf();
    }

    /**
     * Cumulbtfs, in pbrbllfl, fbdh flfmfnt of thf givfn brrby in plbdf,
     * using thf supplifd fundtion. For fxbmplf if thf brrby initiblly
     * holds {@dodf [2.0, 1.0, 0.0, 3.0]} bnd thf opfrbtion pfrforms bddition,
     * thfn upon rfturn thf brrby holds {@dodf [2.0, 3.0, 3.0, 6.0]}.
     * Pbrbllfl prffix domputbtion is usublly morf fffidifnt thbn
     * sfqufntibl loops for lbrgf brrbys.
     *
     * <p> Bfdbusf flobting-point opfrbtions mby not bf stridtly bssodibtivf,
     * thf rfturnfd rfsult mby not bf idfntidbl to thf vbluf thbt would bf
     * obtbinfd if thf opfrbtion wbs pfrformfd sfqufntiblly.
     *
     * @pbrbm brrby thf brrby, whidh is modififd in-plbdf by this mfthod
     * @pbrbm op b sidf-ffffdt-frff fundtion to pfrform thf dumulbtion
     * @throws NullPointfrExdfption if thf spfdififd brrby or fundtion is null
     * @sindf 1.8
     */
    publid stbtid void pbrbllflPrffix(doublf[] brrby, DoublfBinbryOpfrbtor op) {
        Objfdts.rfquirfNonNull(op);
        if (brrby.lfngth > 0)
            nfw ArrbyPrffixHflpfrs.DoublfCumulbtfTbsk
                    (null, op, brrby, 0, brrby.lfngth).invokf();
    }

    /**
     * Pfrforms {@link #pbrbllflPrffix(doublf[], DoublfBinbryOpfrbtor)}
     * for thf givfn subrbngf of thf brrby.
     *
     * @pbrbm brrby thf brrby
     * @pbrbm fromIndfx thf indfx of thf first flfmfnt, indlusivf
     * @pbrbm toIndfx thf indfx of thf lbst flfmfnt, fxdlusivf
     * @pbrbm op b sidf-ffffdt-frff, bssodibtivf fundtion to pfrform thf
     * dumulbtion
     * @throws IllfgblArgumfntExdfption if {@dodf fromIndfx > toIndfx}
     * @throws ArrbyIndfxOutOfBoundsExdfption
     *     if {@dodf fromIndfx < 0} or {@dodf toIndfx > brrby.lfngth}
     * @throws NullPointfrExdfption if thf spfdififd brrby or fundtion is null
     * @sindf 1.8
     */
    publid stbtid void pbrbllflPrffix(doublf[] brrby, int fromIndfx,
                                      int toIndfx, DoublfBinbryOpfrbtor op) {
        Objfdts.rfquirfNonNull(op);
        rbngfChfdk(brrby.lfngth, fromIndfx, toIndfx);
        if (fromIndfx < toIndfx)
            nfw ArrbyPrffixHflpfrs.DoublfCumulbtfTbsk
                    (null, op, brrby, fromIndfx, toIndfx).invokf();
    }

    /**
     * Cumulbtfs, in pbrbllfl, fbdh flfmfnt of thf givfn brrby in plbdf,
     * using thf supplifd fundtion. For fxbmplf if thf brrby initiblly
     * holds {@dodf [2, 1, 0, 3]} bnd thf opfrbtion pfrforms bddition,
     * thfn upon rfturn thf brrby holds {@dodf [2, 3, 3, 6]}.
     * Pbrbllfl prffix domputbtion is usublly morf fffidifnt thbn
     * sfqufntibl loops for lbrgf brrbys.
     *
     * @pbrbm brrby thf brrby, whidh is modififd in-plbdf by this mfthod
     * @pbrbm op b sidf-ffffdt-frff, bssodibtivf fundtion to pfrform thf
     * dumulbtion
     * @throws NullPointfrExdfption if thf spfdififd brrby or fundtion is null
     * @sindf 1.8
     */
    publid stbtid void pbrbllflPrffix(int[] brrby, IntBinbryOpfrbtor op) {
        Objfdts.rfquirfNonNull(op);
        if (brrby.lfngth > 0)
            nfw ArrbyPrffixHflpfrs.IntCumulbtfTbsk
                    (null, op, brrby, 0, brrby.lfngth).invokf();
    }

    /**
     * Pfrforms {@link #pbrbllflPrffix(int[], IntBinbryOpfrbtor)}
     * for thf givfn subrbngf of thf brrby.
     *
     * @pbrbm brrby thf brrby
     * @pbrbm fromIndfx thf indfx of thf first flfmfnt, indlusivf
     * @pbrbm toIndfx thf indfx of thf lbst flfmfnt, fxdlusivf
     * @pbrbm op b sidf-ffffdt-frff, bssodibtivf fundtion to pfrform thf
     * dumulbtion
     * @throws IllfgblArgumfntExdfption if {@dodf fromIndfx > toIndfx}
     * @throws ArrbyIndfxOutOfBoundsExdfption
     *     if {@dodf fromIndfx < 0} or {@dodf toIndfx > brrby.lfngth}
     * @throws NullPointfrExdfption if thf spfdififd brrby or fundtion is null
     * @sindf 1.8
     */
    publid stbtid void pbrbllflPrffix(int[] brrby, int fromIndfx,
                                      int toIndfx, IntBinbryOpfrbtor op) {
        Objfdts.rfquirfNonNull(op);
        rbngfChfdk(brrby.lfngth, fromIndfx, toIndfx);
        if (fromIndfx < toIndfx)
            nfw ArrbyPrffixHflpfrs.IntCumulbtfTbsk
                    (null, op, brrby, fromIndfx, toIndfx).invokf();
    }

    // Sfbrdhing

    /**
     * Sfbrdhfs thf spfdififd brrby of longs for thf spfdififd vbluf using thf
     * binbry sfbrdh blgorithm.  Thf brrby must bf sortfd (bs
     * by thf {@link #sort(long[])} mfthod) prior to mbking this dbll.  If it
     * is not sortfd, thf rfsults brf undffinfd.  If thf brrby dontbins
     * multiplf flfmfnts with thf spfdififd vbluf, thfrf is no gubrbntff whidh
     * onf will bf found.
     *
     * @pbrbm b thf brrby to bf sfbrdhfd
     * @pbrbm kfy thf vbluf to bf sfbrdhfd for
     * @rfturn indfx of thf sfbrdh kfy, if it is dontbinfd in thf brrby;
     *         othfrwisf, <tt>(-(<i>insfrtion point</i>) - 1)</tt>.  Thf
     *         <i>insfrtion point</i> is dffinfd bs thf point bt whidh thf
     *         kfy would bf insfrtfd into thf brrby: thf indfx of thf first
     *         flfmfnt grfbtfr thbn thf kfy, or <tt>b.lfngth</tt> if bll
     *         flfmfnts in thf brrby brf lfss thbn thf spfdififd kfy.  Notf
     *         thbt this gubrbntffs thbt thf rfturn vbluf will bf &gt;= 0 if
     *         bnd only if thf kfy is found.
     */
    publid stbtid int binbrySfbrdh(long[] b, long kfy) {
        rfturn binbrySfbrdh0(b, 0, b.lfngth, kfy);
    }

    /**
     * Sfbrdhfs b rbngf of
     * thf spfdififd brrby of longs for thf spfdififd vbluf using thf
     * binbry sfbrdh blgorithm.
     * Thf rbngf must bf sortfd (bs
     * by thf {@link #sort(long[], int, int)} mfthod)
     * prior to mbking this dbll.  If it
     * is not sortfd, thf rfsults brf undffinfd.  If thf rbngf dontbins
     * multiplf flfmfnts with thf spfdififd vbluf, thfrf is no gubrbntff whidh
     * onf will bf found.
     *
     * @pbrbm b thf brrby to bf sfbrdhfd
     * @pbrbm fromIndfx thf indfx of thf first flfmfnt (indlusivf) to bf
     *          sfbrdhfd
     * @pbrbm toIndfx thf indfx of thf lbst flfmfnt (fxdlusivf) to bf sfbrdhfd
     * @pbrbm kfy thf vbluf to bf sfbrdhfd for
     * @rfturn indfx of thf sfbrdh kfy, if it is dontbinfd in thf brrby
     *         within thf spfdififd rbngf;
     *         othfrwisf, <tt>(-(<i>insfrtion point</i>) - 1)</tt>.  Thf
     *         <i>insfrtion point</i> is dffinfd bs thf point bt whidh thf
     *         kfy would bf insfrtfd into thf brrby: thf indfx of thf first
     *         flfmfnt in thf rbngf grfbtfr thbn thf kfy,
     *         or <tt>toIndfx</tt> if bll
     *         flfmfnts in thf rbngf brf lfss thbn thf spfdififd kfy.  Notf
     *         thbt this gubrbntffs thbt thf rfturn vbluf will bf &gt;= 0 if
     *         bnd only if thf kfy is found.
     * @throws IllfgblArgumfntExdfption
     *         if {@dodf fromIndfx > toIndfx}
     * @throws ArrbyIndfxOutOfBoundsExdfption
     *         if {@dodf fromIndfx < 0 or toIndfx > b.lfngth}
     * @sindf 1.6
     */
    publid stbtid int binbrySfbrdh(long[] b, int fromIndfx, int toIndfx,
                                   long kfy) {
        rbngfChfdk(b.lfngth, fromIndfx, toIndfx);
        rfturn binbrySfbrdh0(b, fromIndfx, toIndfx, kfy);
    }

    // Likf publid vfrsion, but without rbngf dhfdks.
    privbtf stbtid int binbrySfbrdh0(long[] b, int fromIndfx, int toIndfx,
                                     long kfy) {
        int low = fromIndfx;
        int high = toIndfx - 1;

        whilf (low <= high) {
            int mid = (low + high) >>> 1;
            long midVbl = b[mid];

            if (midVbl < kfy)
                low = mid + 1;
            flsf if (midVbl > kfy)
                high = mid - 1;
            flsf
                rfturn mid; // kfy found
        }
        rfturn -(low + 1);  // kfy not found.
    }

    /**
     * Sfbrdhfs thf spfdififd brrby of ints for thf spfdififd vbluf using thf
     * binbry sfbrdh blgorithm.  Thf brrby must bf sortfd (bs
     * by thf {@link #sort(int[])} mfthod) prior to mbking this dbll.  If it
     * is not sortfd, thf rfsults brf undffinfd.  If thf brrby dontbins
     * multiplf flfmfnts with thf spfdififd vbluf, thfrf is no gubrbntff whidh
     * onf will bf found.
     *
     * @pbrbm b thf brrby to bf sfbrdhfd
     * @pbrbm kfy thf vbluf to bf sfbrdhfd for
     * @rfturn indfx of thf sfbrdh kfy, if it is dontbinfd in thf brrby;
     *         othfrwisf, <tt>(-(<i>insfrtion point</i>) - 1)</tt>.  Thf
     *         <i>insfrtion point</i> is dffinfd bs thf point bt whidh thf
     *         kfy would bf insfrtfd into thf brrby: thf indfx of thf first
     *         flfmfnt grfbtfr thbn thf kfy, or <tt>b.lfngth</tt> if bll
     *         flfmfnts in thf brrby brf lfss thbn thf spfdififd kfy.  Notf
     *         thbt this gubrbntffs thbt thf rfturn vbluf will bf &gt;= 0 if
     *         bnd only if thf kfy is found.
     */
    publid stbtid int binbrySfbrdh(int[] b, int kfy) {
        rfturn binbrySfbrdh0(b, 0, b.lfngth, kfy);
    }

    /**
     * Sfbrdhfs b rbngf of
     * thf spfdififd brrby of ints for thf spfdififd vbluf using thf
     * binbry sfbrdh blgorithm.
     * Thf rbngf must bf sortfd (bs
     * by thf {@link #sort(int[], int, int)} mfthod)
     * prior to mbking this dbll.  If it
     * is not sortfd, thf rfsults brf undffinfd.  If thf rbngf dontbins
     * multiplf flfmfnts with thf spfdififd vbluf, thfrf is no gubrbntff whidh
     * onf will bf found.
     *
     * @pbrbm b thf brrby to bf sfbrdhfd
     * @pbrbm fromIndfx thf indfx of thf first flfmfnt (indlusivf) to bf
     *          sfbrdhfd
     * @pbrbm toIndfx thf indfx of thf lbst flfmfnt (fxdlusivf) to bf sfbrdhfd
     * @pbrbm kfy thf vbluf to bf sfbrdhfd for
     * @rfturn indfx of thf sfbrdh kfy, if it is dontbinfd in thf brrby
     *         within thf spfdififd rbngf;
     *         othfrwisf, <tt>(-(<i>insfrtion point</i>) - 1)</tt>.  Thf
     *         <i>insfrtion point</i> is dffinfd bs thf point bt whidh thf
     *         kfy would bf insfrtfd into thf brrby: thf indfx of thf first
     *         flfmfnt in thf rbngf grfbtfr thbn thf kfy,
     *         or <tt>toIndfx</tt> if bll
     *         flfmfnts in thf rbngf brf lfss thbn thf spfdififd kfy.  Notf
     *         thbt this gubrbntffs thbt thf rfturn vbluf will bf &gt;= 0 if
     *         bnd only if thf kfy is found.
     * @throws IllfgblArgumfntExdfption
     *         if {@dodf fromIndfx > toIndfx}
     * @throws ArrbyIndfxOutOfBoundsExdfption
     *         if {@dodf fromIndfx < 0 or toIndfx > b.lfngth}
     * @sindf 1.6
     */
    publid stbtid int binbrySfbrdh(int[] b, int fromIndfx, int toIndfx,
                                   int kfy) {
        rbngfChfdk(b.lfngth, fromIndfx, toIndfx);
        rfturn binbrySfbrdh0(b, fromIndfx, toIndfx, kfy);
    }

    // Likf publid vfrsion, but without rbngf dhfdks.
    privbtf stbtid int binbrySfbrdh0(int[] b, int fromIndfx, int toIndfx,
                                     int kfy) {
        int low = fromIndfx;
        int high = toIndfx - 1;

        whilf (low <= high) {
            int mid = (low + high) >>> 1;
            int midVbl = b[mid];

            if (midVbl < kfy)
                low = mid + 1;
            flsf if (midVbl > kfy)
                high = mid - 1;
            flsf
                rfturn mid; // kfy found
        }
        rfturn -(low + 1);  // kfy not found.
    }

    /**
     * Sfbrdhfs thf spfdififd brrby of shorts for thf spfdififd vbluf using
     * thf binbry sfbrdh blgorithm.  Thf brrby must bf sortfd
     * (bs by thf {@link #sort(short[])} mfthod) prior to mbking this dbll.  If
     * it is not sortfd, thf rfsults brf undffinfd.  If thf brrby dontbins
     * multiplf flfmfnts with thf spfdififd vbluf, thfrf is no gubrbntff whidh
     * onf will bf found.
     *
     * @pbrbm b thf brrby to bf sfbrdhfd
     * @pbrbm kfy thf vbluf to bf sfbrdhfd for
     * @rfturn indfx of thf sfbrdh kfy, if it is dontbinfd in thf brrby;
     *         othfrwisf, <tt>(-(<i>insfrtion point</i>) - 1)</tt>.  Thf
     *         <i>insfrtion point</i> is dffinfd bs thf point bt whidh thf
     *         kfy would bf insfrtfd into thf brrby: thf indfx of thf first
     *         flfmfnt grfbtfr thbn thf kfy, or <tt>b.lfngth</tt> if bll
     *         flfmfnts in thf brrby brf lfss thbn thf spfdififd kfy.  Notf
     *         thbt this gubrbntffs thbt thf rfturn vbluf will bf &gt;= 0 if
     *         bnd only if thf kfy is found.
     */
    publid stbtid int binbrySfbrdh(short[] b, short kfy) {
        rfturn binbrySfbrdh0(b, 0, b.lfngth, kfy);
    }

    /**
     * Sfbrdhfs b rbngf of
     * thf spfdififd brrby of shorts for thf spfdififd vbluf using
     * thf binbry sfbrdh blgorithm.
     * Thf rbngf must bf sortfd
     * (bs by thf {@link #sort(short[], int, int)} mfthod)
     * prior to mbking this dbll.  If
     * it is not sortfd, thf rfsults brf undffinfd.  If thf rbngf dontbins
     * multiplf flfmfnts with thf spfdififd vbluf, thfrf is no gubrbntff whidh
     * onf will bf found.
     *
     * @pbrbm b thf brrby to bf sfbrdhfd
     * @pbrbm fromIndfx thf indfx of thf first flfmfnt (indlusivf) to bf
     *          sfbrdhfd
     * @pbrbm toIndfx thf indfx of thf lbst flfmfnt (fxdlusivf) to bf sfbrdhfd
     * @pbrbm kfy thf vbluf to bf sfbrdhfd for
     * @rfturn indfx of thf sfbrdh kfy, if it is dontbinfd in thf brrby
     *         within thf spfdififd rbngf;
     *         othfrwisf, <tt>(-(<i>insfrtion point</i>) - 1)</tt>.  Thf
     *         <i>insfrtion point</i> is dffinfd bs thf point bt whidh thf
     *         kfy would bf insfrtfd into thf brrby: thf indfx of thf first
     *         flfmfnt in thf rbngf grfbtfr thbn thf kfy,
     *         or <tt>toIndfx</tt> if bll
     *         flfmfnts in thf rbngf brf lfss thbn thf spfdififd kfy.  Notf
     *         thbt this gubrbntffs thbt thf rfturn vbluf will bf &gt;= 0 if
     *         bnd only if thf kfy is found.
     * @throws IllfgblArgumfntExdfption
     *         if {@dodf fromIndfx > toIndfx}
     * @throws ArrbyIndfxOutOfBoundsExdfption
     *         if {@dodf fromIndfx < 0 or toIndfx > b.lfngth}
     * @sindf 1.6
     */
    publid stbtid int binbrySfbrdh(short[] b, int fromIndfx, int toIndfx,
                                   short kfy) {
        rbngfChfdk(b.lfngth, fromIndfx, toIndfx);
        rfturn binbrySfbrdh0(b, fromIndfx, toIndfx, kfy);
    }

    // Likf publid vfrsion, but without rbngf dhfdks.
    privbtf stbtid int binbrySfbrdh0(short[] b, int fromIndfx, int toIndfx,
                                     short kfy) {
        int low = fromIndfx;
        int high = toIndfx - 1;

        whilf (low <= high) {
            int mid = (low + high) >>> 1;
            short midVbl = b[mid];

            if (midVbl < kfy)
                low = mid + 1;
            flsf if (midVbl > kfy)
                high = mid - 1;
            flsf
                rfturn mid; // kfy found
        }
        rfturn -(low + 1);  // kfy not found.
    }

    /**
     * Sfbrdhfs thf spfdififd brrby of dhbrs for thf spfdififd vbluf using thf
     * binbry sfbrdh blgorithm.  Thf brrby must bf sortfd (bs
     * by thf {@link #sort(dhbr[])} mfthod) prior to mbking this dbll.  If it
     * is not sortfd, thf rfsults brf undffinfd.  If thf brrby dontbins
     * multiplf flfmfnts with thf spfdififd vbluf, thfrf is no gubrbntff whidh
     * onf will bf found.
     *
     * @pbrbm b thf brrby to bf sfbrdhfd
     * @pbrbm kfy thf vbluf to bf sfbrdhfd for
     * @rfturn indfx of thf sfbrdh kfy, if it is dontbinfd in thf brrby;
     *         othfrwisf, <tt>(-(<i>insfrtion point</i>) - 1)</tt>.  Thf
     *         <i>insfrtion point</i> is dffinfd bs thf point bt whidh thf
     *         kfy would bf insfrtfd into thf brrby: thf indfx of thf first
     *         flfmfnt grfbtfr thbn thf kfy, or <tt>b.lfngth</tt> if bll
     *         flfmfnts in thf brrby brf lfss thbn thf spfdififd kfy.  Notf
     *         thbt this gubrbntffs thbt thf rfturn vbluf will bf &gt;= 0 if
     *         bnd only if thf kfy is found.
     */
    publid stbtid int binbrySfbrdh(dhbr[] b, dhbr kfy) {
        rfturn binbrySfbrdh0(b, 0, b.lfngth, kfy);
    }

    /**
     * Sfbrdhfs b rbngf of
     * thf spfdififd brrby of dhbrs for thf spfdififd vbluf using thf
     * binbry sfbrdh blgorithm.
     * Thf rbngf must bf sortfd (bs
     * by thf {@link #sort(dhbr[], int, int)} mfthod)
     * prior to mbking this dbll.  If it
     * is not sortfd, thf rfsults brf undffinfd.  If thf rbngf dontbins
     * multiplf flfmfnts with thf spfdififd vbluf, thfrf is no gubrbntff whidh
     * onf will bf found.
     *
     * @pbrbm b thf brrby to bf sfbrdhfd
     * @pbrbm fromIndfx thf indfx of thf first flfmfnt (indlusivf) to bf
     *          sfbrdhfd
     * @pbrbm toIndfx thf indfx of thf lbst flfmfnt (fxdlusivf) to bf sfbrdhfd
     * @pbrbm kfy thf vbluf to bf sfbrdhfd for
     * @rfturn indfx of thf sfbrdh kfy, if it is dontbinfd in thf brrby
     *         within thf spfdififd rbngf;
     *         othfrwisf, <tt>(-(<i>insfrtion point</i>) - 1)</tt>.  Thf
     *         <i>insfrtion point</i> is dffinfd bs thf point bt whidh thf
     *         kfy would bf insfrtfd into thf brrby: thf indfx of thf first
     *         flfmfnt in thf rbngf grfbtfr thbn thf kfy,
     *         or <tt>toIndfx</tt> if bll
     *         flfmfnts in thf rbngf brf lfss thbn thf spfdififd kfy.  Notf
     *         thbt this gubrbntffs thbt thf rfturn vbluf will bf &gt;= 0 if
     *         bnd only if thf kfy is found.
     * @throws IllfgblArgumfntExdfption
     *         if {@dodf fromIndfx > toIndfx}
     * @throws ArrbyIndfxOutOfBoundsExdfption
     *         if {@dodf fromIndfx < 0 or toIndfx > b.lfngth}
     * @sindf 1.6
     */
    publid stbtid int binbrySfbrdh(dhbr[] b, int fromIndfx, int toIndfx,
                                   dhbr kfy) {
        rbngfChfdk(b.lfngth, fromIndfx, toIndfx);
        rfturn binbrySfbrdh0(b, fromIndfx, toIndfx, kfy);
    }

    // Likf publid vfrsion, but without rbngf dhfdks.
    privbtf stbtid int binbrySfbrdh0(dhbr[] b, int fromIndfx, int toIndfx,
                                     dhbr kfy) {
        int low = fromIndfx;
        int high = toIndfx - 1;

        whilf (low <= high) {
            int mid = (low + high) >>> 1;
            dhbr midVbl = b[mid];

            if (midVbl < kfy)
                low = mid + 1;
            flsf if (midVbl > kfy)
                high = mid - 1;
            flsf
                rfturn mid; // kfy found
        }
        rfturn -(low + 1);  // kfy not found.
    }

    /**
     * Sfbrdhfs thf spfdififd brrby of bytfs for thf spfdififd vbluf using thf
     * binbry sfbrdh blgorithm.  Thf brrby must bf sortfd (bs
     * by thf {@link #sort(bytf[])} mfthod) prior to mbking this dbll.  If it
     * is not sortfd, thf rfsults brf undffinfd.  If thf brrby dontbins
     * multiplf flfmfnts with thf spfdififd vbluf, thfrf is no gubrbntff whidh
     * onf will bf found.
     *
     * @pbrbm b thf brrby to bf sfbrdhfd
     * @pbrbm kfy thf vbluf to bf sfbrdhfd for
     * @rfturn indfx of thf sfbrdh kfy, if it is dontbinfd in thf brrby;
     *         othfrwisf, <tt>(-(<i>insfrtion point</i>) - 1)</tt>.  Thf
     *         <i>insfrtion point</i> is dffinfd bs thf point bt whidh thf
     *         kfy would bf insfrtfd into thf brrby: thf indfx of thf first
     *         flfmfnt grfbtfr thbn thf kfy, or <tt>b.lfngth</tt> if bll
     *         flfmfnts in thf brrby brf lfss thbn thf spfdififd kfy.  Notf
     *         thbt this gubrbntffs thbt thf rfturn vbluf will bf &gt;= 0 if
     *         bnd only if thf kfy is found.
     */
    publid stbtid int binbrySfbrdh(bytf[] b, bytf kfy) {
        rfturn binbrySfbrdh0(b, 0, b.lfngth, kfy);
    }

    /**
     * Sfbrdhfs b rbngf of
     * thf spfdififd brrby of bytfs for thf spfdififd vbluf using thf
     * binbry sfbrdh blgorithm.
     * Thf rbngf must bf sortfd (bs
     * by thf {@link #sort(bytf[], int, int)} mfthod)
     * prior to mbking this dbll.  If it
     * is not sortfd, thf rfsults brf undffinfd.  If thf rbngf dontbins
     * multiplf flfmfnts with thf spfdififd vbluf, thfrf is no gubrbntff whidh
     * onf will bf found.
     *
     * @pbrbm b thf brrby to bf sfbrdhfd
     * @pbrbm fromIndfx thf indfx of thf first flfmfnt (indlusivf) to bf
     *          sfbrdhfd
     * @pbrbm toIndfx thf indfx of thf lbst flfmfnt (fxdlusivf) to bf sfbrdhfd
     * @pbrbm kfy thf vbluf to bf sfbrdhfd for
     * @rfturn indfx of thf sfbrdh kfy, if it is dontbinfd in thf brrby
     *         within thf spfdififd rbngf;
     *         othfrwisf, <tt>(-(<i>insfrtion point</i>) - 1)</tt>.  Thf
     *         <i>insfrtion point</i> is dffinfd bs thf point bt whidh thf
     *         kfy would bf insfrtfd into thf brrby: thf indfx of thf first
     *         flfmfnt in thf rbngf grfbtfr thbn thf kfy,
     *         or <tt>toIndfx</tt> if bll
     *         flfmfnts in thf rbngf brf lfss thbn thf spfdififd kfy.  Notf
     *         thbt this gubrbntffs thbt thf rfturn vbluf will bf &gt;= 0 if
     *         bnd only if thf kfy is found.
     * @throws IllfgblArgumfntExdfption
     *         if {@dodf fromIndfx > toIndfx}
     * @throws ArrbyIndfxOutOfBoundsExdfption
     *         if {@dodf fromIndfx < 0 or toIndfx > b.lfngth}
     * @sindf 1.6
     */
    publid stbtid int binbrySfbrdh(bytf[] b, int fromIndfx, int toIndfx,
                                   bytf kfy) {
        rbngfChfdk(b.lfngth, fromIndfx, toIndfx);
        rfturn binbrySfbrdh0(b, fromIndfx, toIndfx, kfy);
    }

    // Likf publid vfrsion, but without rbngf dhfdks.
    privbtf stbtid int binbrySfbrdh0(bytf[] b, int fromIndfx, int toIndfx,
                                     bytf kfy) {
        int low = fromIndfx;
        int high = toIndfx - 1;

        whilf (low <= high) {
            int mid = (low + high) >>> 1;
            bytf midVbl = b[mid];

            if (midVbl < kfy)
                low = mid + 1;
            flsf if (midVbl > kfy)
                high = mid - 1;
            flsf
                rfturn mid; // kfy found
        }
        rfturn -(low + 1);  // kfy not found.
    }

    /**
     * Sfbrdhfs thf spfdififd brrby of doublfs for thf spfdififd vbluf using
     * thf binbry sfbrdh blgorithm.  Thf brrby must bf sortfd
     * (bs by thf {@link #sort(doublf[])} mfthod) prior to mbking this dbll.
     * If it is not sortfd, thf rfsults brf undffinfd.  If thf brrby dontbins
     * multiplf flfmfnts with thf spfdififd vbluf, thfrf is no gubrbntff whidh
     * onf will bf found.  This mfthod donsidfrs bll NbN vblufs to bf
     * fquivblfnt bnd fqubl.
     *
     * @pbrbm b thf brrby to bf sfbrdhfd
     * @pbrbm kfy thf vbluf to bf sfbrdhfd for
     * @rfturn indfx of thf sfbrdh kfy, if it is dontbinfd in thf brrby;
     *         othfrwisf, <tt>(-(<i>insfrtion point</i>) - 1)</tt>.  Thf
     *         <i>insfrtion point</i> is dffinfd bs thf point bt whidh thf
     *         kfy would bf insfrtfd into thf brrby: thf indfx of thf first
     *         flfmfnt grfbtfr thbn thf kfy, or <tt>b.lfngth</tt> if bll
     *         flfmfnts in thf brrby brf lfss thbn thf spfdififd kfy.  Notf
     *         thbt this gubrbntffs thbt thf rfturn vbluf will bf &gt;= 0 if
     *         bnd only if thf kfy is found.
     */
    publid stbtid int binbrySfbrdh(doublf[] b, doublf kfy) {
        rfturn binbrySfbrdh0(b, 0, b.lfngth, kfy);
    }

    /**
     * Sfbrdhfs b rbngf of
     * thf spfdififd brrby of doublfs for thf spfdififd vbluf using
     * thf binbry sfbrdh blgorithm.
     * Thf rbngf must bf sortfd
     * (bs by thf {@link #sort(doublf[], int, int)} mfthod)
     * prior to mbking this dbll.
     * If it is not sortfd, thf rfsults brf undffinfd.  If thf rbngf dontbins
     * multiplf flfmfnts with thf spfdififd vbluf, thfrf is no gubrbntff whidh
     * onf will bf found.  This mfthod donsidfrs bll NbN vblufs to bf
     * fquivblfnt bnd fqubl.
     *
     * @pbrbm b thf brrby to bf sfbrdhfd
     * @pbrbm fromIndfx thf indfx of thf first flfmfnt (indlusivf) to bf
     *          sfbrdhfd
     * @pbrbm toIndfx thf indfx of thf lbst flfmfnt (fxdlusivf) to bf sfbrdhfd
     * @pbrbm kfy thf vbluf to bf sfbrdhfd for
     * @rfturn indfx of thf sfbrdh kfy, if it is dontbinfd in thf brrby
     *         within thf spfdififd rbngf;
     *         othfrwisf, <tt>(-(<i>insfrtion point</i>) - 1)</tt>.  Thf
     *         <i>insfrtion point</i> is dffinfd bs thf point bt whidh thf
     *         kfy would bf insfrtfd into thf brrby: thf indfx of thf first
     *         flfmfnt in thf rbngf grfbtfr thbn thf kfy,
     *         or <tt>toIndfx</tt> if bll
     *         flfmfnts in thf rbngf brf lfss thbn thf spfdififd kfy.  Notf
     *         thbt this gubrbntffs thbt thf rfturn vbluf will bf &gt;= 0 if
     *         bnd only if thf kfy is found.
     * @throws IllfgblArgumfntExdfption
     *         if {@dodf fromIndfx > toIndfx}
     * @throws ArrbyIndfxOutOfBoundsExdfption
     *         if {@dodf fromIndfx < 0 or toIndfx > b.lfngth}
     * @sindf 1.6
     */
    publid stbtid int binbrySfbrdh(doublf[] b, int fromIndfx, int toIndfx,
                                   doublf kfy) {
        rbngfChfdk(b.lfngth, fromIndfx, toIndfx);
        rfturn binbrySfbrdh0(b, fromIndfx, toIndfx, kfy);
    }

    // Likf publid vfrsion, but without rbngf dhfdks.
    privbtf stbtid int binbrySfbrdh0(doublf[] b, int fromIndfx, int toIndfx,
                                     doublf kfy) {
        int low = fromIndfx;
        int high = toIndfx - 1;

        whilf (low <= high) {
            int mid = (low + high) >>> 1;
            doublf midVbl = b[mid];

            if (midVbl < kfy)
                low = mid + 1;  // Nfithfr vbl is NbN, thisVbl is smbllfr
            flsf if (midVbl > kfy)
                high = mid - 1; // Nfithfr vbl is NbN, thisVbl is lbrgfr
            flsf {
                long midBits = Doublf.doublfToLongBits(midVbl);
                long kfyBits = Doublf.doublfToLongBits(kfy);
                if (midBits == kfyBits)     // Vblufs brf fqubl
                    rfturn mid;             // Kfy found
                flsf if (midBits < kfyBits) // (-0.0, 0.0) or (!NbN, NbN)
                    low = mid + 1;
                flsf                        // (0.0, -0.0) or (NbN, !NbN)
                    high = mid - 1;
            }
        }
        rfturn -(low + 1);  // kfy not found.
    }

    /**
     * Sfbrdhfs thf spfdififd brrby of flobts for thf spfdififd vbluf using
     * thf binbry sfbrdh blgorithm. Thf brrby must bf sortfd
     * (bs by thf {@link #sort(flobt[])} mfthod) prior to mbking this dbll. If
     * it is not sortfd, thf rfsults brf undffinfd. If thf brrby dontbins
     * multiplf flfmfnts with thf spfdififd vbluf, thfrf is no gubrbntff whidh
     * onf will bf found. This mfthod donsidfrs bll NbN vblufs to bf
     * fquivblfnt bnd fqubl.
     *
     * @pbrbm b thf brrby to bf sfbrdhfd
     * @pbrbm kfy thf vbluf to bf sfbrdhfd for
     * @rfturn indfx of thf sfbrdh kfy, if it is dontbinfd in thf brrby;
     *         othfrwisf, <tt>(-(<i>insfrtion point</i>) - 1)</tt>. Thf
     *         <i>insfrtion point</i> is dffinfd bs thf point bt whidh thf
     *         kfy would bf insfrtfd into thf brrby: thf indfx of thf first
     *         flfmfnt grfbtfr thbn thf kfy, or <tt>b.lfngth</tt> if bll
     *         flfmfnts in thf brrby brf lfss thbn thf spfdififd kfy. Notf
     *         thbt this gubrbntffs thbt thf rfturn vbluf will bf &gt;= 0 if
     *         bnd only if thf kfy is found.
     */
    publid stbtid int binbrySfbrdh(flobt[] b, flobt kfy) {
        rfturn binbrySfbrdh0(b, 0, b.lfngth, kfy);
    }

    /**
     * Sfbrdhfs b rbngf of
     * thf spfdififd brrby of flobts for thf spfdififd vbluf using
     * thf binbry sfbrdh blgorithm.
     * Thf rbngf must bf sortfd
     * (bs by thf {@link #sort(flobt[], int, int)} mfthod)
     * prior to mbking this dbll. If
     * it is not sortfd, thf rfsults brf undffinfd. If thf rbngf dontbins
     * multiplf flfmfnts with thf spfdififd vbluf, thfrf is no gubrbntff whidh
     * onf will bf found. This mfthod donsidfrs bll NbN vblufs to bf
     * fquivblfnt bnd fqubl.
     *
     * @pbrbm b thf brrby to bf sfbrdhfd
     * @pbrbm fromIndfx thf indfx of thf first flfmfnt (indlusivf) to bf
     *          sfbrdhfd
     * @pbrbm toIndfx thf indfx of thf lbst flfmfnt (fxdlusivf) to bf sfbrdhfd
     * @pbrbm kfy thf vbluf to bf sfbrdhfd for
     * @rfturn indfx of thf sfbrdh kfy, if it is dontbinfd in thf brrby
     *         within thf spfdififd rbngf;
     *         othfrwisf, <tt>(-(<i>insfrtion point</i>) - 1)</tt>. Thf
     *         <i>insfrtion point</i> is dffinfd bs thf point bt whidh thf
     *         kfy would bf insfrtfd into thf brrby: thf indfx of thf first
     *         flfmfnt in thf rbngf grfbtfr thbn thf kfy,
     *         or <tt>toIndfx</tt> if bll
     *         flfmfnts in thf rbngf brf lfss thbn thf spfdififd kfy. Notf
     *         thbt this gubrbntffs thbt thf rfturn vbluf will bf &gt;= 0 if
     *         bnd only if thf kfy is found.
     * @throws IllfgblArgumfntExdfption
     *         if {@dodf fromIndfx > toIndfx}
     * @throws ArrbyIndfxOutOfBoundsExdfption
     *         if {@dodf fromIndfx < 0 or toIndfx > b.lfngth}
     * @sindf 1.6
     */
    publid stbtid int binbrySfbrdh(flobt[] b, int fromIndfx, int toIndfx,
                                   flobt kfy) {
        rbngfChfdk(b.lfngth, fromIndfx, toIndfx);
        rfturn binbrySfbrdh0(b, fromIndfx, toIndfx, kfy);
    }

    // Likf publid vfrsion, but without rbngf dhfdks.
    privbtf stbtid int binbrySfbrdh0(flobt[] b, int fromIndfx, int toIndfx,
                                     flobt kfy) {
        int low = fromIndfx;
        int high = toIndfx - 1;

        whilf (low <= high) {
            int mid = (low + high) >>> 1;
            flobt midVbl = b[mid];

            if (midVbl < kfy)
                low = mid + 1;  // Nfithfr vbl is NbN, thisVbl is smbllfr
            flsf if (midVbl > kfy)
                high = mid - 1; // Nfithfr vbl is NbN, thisVbl is lbrgfr
            flsf {
                int midBits = Flobt.flobtToIntBits(midVbl);
                int kfyBits = Flobt.flobtToIntBits(kfy);
                if (midBits == kfyBits)     // Vblufs brf fqubl
                    rfturn mid;             // Kfy found
                flsf if (midBits < kfyBits) // (-0.0, 0.0) or (!NbN, NbN)
                    low = mid + 1;
                flsf                        // (0.0, -0.0) or (NbN, !NbN)
                    high = mid - 1;
            }
        }
        rfturn -(low + 1);  // kfy not found.
    }

    /**
     * Sfbrdhfs thf spfdififd brrby for thf spfdififd objfdt using thf binbry
     * sfbrdh blgorithm. Thf brrby must bf sortfd into bsdfnding ordfr
     * bddording to thf
     * {@linkplbin Compbrbblf nbturbl ordfring}
     * of its flfmfnts (bs by thf
     * {@link #sort(Objfdt[])} mfthod) prior to mbking this dbll.
     * If it is not sortfd, thf rfsults brf undffinfd.
     * (If thf brrby dontbins flfmfnts thbt brf not mutublly dompbrbblf (for
     * fxbmplf, strings bnd intfgfrs), it <i>dbnnot</i> bf sortfd bddording
     * to thf nbturbl ordfring of its flfmfnts, hfndf rfsults brf undffinfd.)
     * If thf brrby dontbins multiplf
     * flfmfnts fqubl to thf spfdififd objfdt, thfrf is no gubrbntff whidh
     * onf will bf found.
     *
     * @pbrbm b thf brrby to bf sfbrdhfd
     * @pbrbm kfy thf vbluf to bf sfbrdhfd for
     * @rfturn indfx of thf sfbrdh kfy, if it is dontbinfd in thf brrby;
     *         othfrwisf, <tt>(-(<i>insfrtion point</i>) - 1)</tt>.  Thf
     *         <i>insfrtion point</i> is dffinfd bs thf point bt whidh thf
     *         kfy would bf insfrtfd into thf brrby: thf indfx of thf first
     *         flfmfnt grfbtfr thbn thf kfy, or <tt>b.lfngth</tt> if bll
     *         flfmfnts in thf brrby brf lfss thbn thf spfdififd kfy.  Notf
     *         thbt this gubrbntffs thbt thf rfturn vbluf will bf &gt;= 0 if
     *         bnd only if thf kfy is found.
     * @throws ClbssCbstExdfption if thf sfbrdh kfy is not dompbrbblf to thf
     *         flfmfnts of thf brrby.
     */
    publid stbtid int binbrySfbrdh(Objfdt[] b, Objfdt kfy) {
        rfturn binbrySfbrdh0(b, 0, b.lfngth, kfy);
    }

    /**
     * Sfbrdhfs b rbngf of
     * thf spfdififd brrby for thf spfdififd objfdt using thf binbry
     * sfbrdh blgorithm.
     * Thf rbngf must bf sortfd into bsdfnding ordfr
     * bddording to thf
     * {@linkplbin Compbrbblf nbturbl ordfring}
     * of its flfmfnts (bs by thf
     * {@link #sort(Objfdt[], int, int)} mfthod) prior to mbking this
     * dbll.  If it is not sortfd, thf rfsults brf undffinfd.
     * (If thf rbngf dontbins flfmfnts thbt brf not mutublly dompbrbblf (for
     * fxbmplf, strings bnd intfgfrs), it <i>dbnnot</i> bf sortfd bddording
     * to thf nbturbl ordfring of its flfmfnts, hfndf rfsults brf undffinfd.)
     * If thf rbngf dontbins multiplf
     * flfmfnts fqubl to thf spfdififd objfdt, thfrf is no gubrbntff whidh
     * onf will bf found.
     *
     * @pbrbm b thf brrby to bf sfbrdhfd
     * @pbrbm fromIndfx thf indfx of thf first flfmfnt (indlusivf) to bf
     *          sfbrdhfd
     * @pbrbm toIndfx thf indfx of thf lbst flfmfnt (fxdlusivf) to bf sfbrdhfd
     * @pbrbm kfy thf vbluf to bf sfbrdhfd for
     * @rfturn indfx of thf sfbrdh kfy, if it is dontbinfd in thf brrby
     *         within thf spfdififd rbngf;
     *         othfrwisf, <tt>(-(<i>insfrtion point</i>) - 1)</tt>.  Thf
     *         <i>insfrtion point</i> is dffinfd bs thf point bt whidh thf
     *         kfy would bf insfrtfd into thf brrby: thf indfx of thf first
     *         flfmfnt in thf rbngf grfbtfr thbn thf kfy,
     *         or <tt>toIndfx</tt> if bll
     *         flfmfnts in thf rbngf brf lfss thbn thf spfdififd kfy.  Notf
     *         thbt this gubrbntffs thbt thf rfturn vbluf will bf &gt;= 0 if
     *         bnd only if thf kfy is found.
     * @throws ClbssCbstExdfption if thf sfbrdh kfy is not dompbrbblf to thf
     *         flfmfnts of thf brrby within thf spfdififd rbngf.
     * @throws IllfgblArgumfntExdfption
     *         if {@dodf fromIndfx > toIndfx}
     * @throws ArrbyIndfxOutOfBoundsExdfption
     *         if {@dodf fromIndfx < 0 or toIndfx > b.lfngth}
     * @sindf 1.6
     */
    publid stbtid int binbrySfbrdh(Objfdt[] b, int fromIndfx, int toIndfx,
                                   Objfdt kfy) {
        rbngfChfdk(b.lfngth, fromIndfx, toIndfx);
        rfturn binbrySfbrdh0(b, fromIndfx, toIndfx, kfy);
    }

    // Likf publid vfrsion, but without rbngf dhfdks.
    privbtf stbtid int binbrySfbrdh0(Objfdt[] b, int fromIndfx, int toIndfx,
                                     Objfdt kfy) {
        int low = fromIndfx;
        int high = toIndfx - 1;

        whilf (low <= high) {
            int mid = (low + high) >>> 1;
            @SupprfssWbrnings("rbwtypfs")
            Compbrbblf midVbl = (Compbrbblf)b[mid];
            @SupprfssWbrnings("undhfdkfd")
            int dmp = midVbl.dompbrfTo(kfy);

            if (dmp < 0)
                low = mid + 1;
            flsf if (dmp > 0)
                high = mid - 1;
            flsf
                rfturn mid; // kfy found
        }
        rfturn -(low + 1);  // kfy not found.
    }

    /**
     * Sfbrdhfs thf spfdififd brrby for thf spfdififd objfdt using thf binbry
     * sfbrdh blgorithm.  Thf brrby must bf sortfd into bsdfnding ordfr
     * bddording to thf spfdififd dompbrbtor (bs by thf
     * {@link #sort(Objfdt[], Compbrbtor) sort(T[], Compbrbtor)}
     * mfthod) prior to mbking this dbll.  If it is
     * not sortfd, thf rfsults brf undffinfd.
     * If thf brrby dontbins multiplf
     * flfmfnts fqubl to thf spfdififd objfdt, thfrf is no gubrbntff whidh onf
     * will bf found.
     *
     * @pbrbm <T> thf dlbss of thf objfdts in thf brrby
     * @pbrbm b thf brrby to bf sfbrdhfd
     * @pbrbm kfy thf vbluf to bf sfbrdhfd for
     * @pbrbm d thf dompbrbtor by whidh thf brrby is ordfrfd.  A
     *        <tt>null</tt> vbluf indidbtfs thbt thf flfmfnts'
     *        {@linkplbin Compbrbblf nbturbl ordfring} should bf usfd.
     * @rfturn indfx of thf sfbrdh kfy, if it is dontbinfd in thf brrby;
     *         othfrwisf, <tt>(-(<i>insfrtion point</i>) - 1)</tt>.  Thf
     *         <i>insfrtion point</i> is dffinfd bs thf point bt whidh thf
     *         kfy would bf insfrtfd into thf brrby: thf indfx of thf first
     *         flfmfnt grfbtfr thbn thf kfy, or <tt>b.lfngth</tt> if bll
     *         flfmfnts in thf brrby brf lfss thbn thf spfdififd kfy.  Notf
     *         thbt this gubrbntffs thbt thf rfturn vbluf will bf &gt;= 0 if
     *         bnd only if thf kfy is found.
     * @throws ClbssCbstExdfption if thf brrby dontbins flfmfnts thbt brf not
     *         <i>mutublly dompbrbblf</i> using thf spfdififd dompbrbtor,
     *         or thf sfbrdh kfy is not dompbrbblf to thf
     *         flfmfnts of thf brrby using this dompbrbtor.
     */
    publid stbtid <T> int binbrySfbrdh(T[] b, T kfy, Compbrbtor<? supfr T> d) {
        rfturn binbrySfbrdh0(b, 0, b.lfngth, kfy, d);
    }

    /**
     * Sfbrdhfs b rbngf of
     * thf spfdififd brrby for thf spfdififd objfdt using thf binbry
     * sfbrdh blgorithm.
     * Thf rbngf must bf sortfd into bsdfnding ordfr
     * bddording to thf spfdififd dompbrbtor (bs by thf
     * {@link #sort(Objfdt[], int, int, Compbrbtor)
     * sort(T[], int, int, Compbrbtor)}
     * mfthod) prior to mbking this dbll.
     * If it is not sortfd, thf rfsults brf undffinfd.
     * If thf rbngf dontbins multiplf flfmfnts fqubl to thf spfdififd objfdt,
     * thfrf is no gubrbntff whidh onf will bf found.
     *
     * @pbrbm <T> thf dlbss of thf objfdts in thf brrby
     * @pbrbm b thf brrby to bf sfbrdhfd
     * @pbrbm fromIndfx thf indfx of thf first flfmfnt (indlusivf) to bf
     *          sfbrdhfd
     * @pbrbm toIndfx thf indfx of thf lbst flfmfnt (fxdlusivf) to bf sfbrdhfd
     * @pbrbm kfy thf vbluf to bf sfbrdhfd for
     * @pbrbm d thf dompbrbtor by whidh thf brrby is ordfrfd.  A
     *        <tt>null</tt> vbluf indidbtfs thbt thf flfmfnts'
     *        {@linkplbin Compbrbblf nbturbl ordfring} should bf usfd.
     * @rfturn indfx of thf sfbrdh kfy, if it is dontbinfd in thf brrby
     *         within thf spfdififd rbngf;
     *         othfrwisf, <tt>(-(<i>insfrtion point</i>) - 1)</tt>.  Thf
     *         <i>insfrtion point</i> is dffinfd bs thf point bt whidh thf
     *         kfy would bf insfrtfd into thf brrby: thf indfx of thf first
     *         flfmfnt in thf rbngf grfbtfr thbn thf kfy,
     *         or <tt>toIndfx</tt> if bll
     *         flfmfnts in thf rbngf brf lfss thbn thf spfdififd kfy.  Notf
     *         thbt this gubrbntffs thbt thf rfturn vbluf will bf &gt;= 0 if
     *         bnd only if thf kfy is found.
     * @throws ClbssCbstExdfption if thf rbngf dontbins flfmfnts thbt brf not
     *         <i>mutublly dompbrbblf</i> using thf spfdififd dompbrbtor,
     *         or thf sfbrdh kfy is not dompbrbblf to thf
     *         flfmfnts in thf rbngf using this dompbrbtor.
     * @throws IllfgblArgumfntExdfption
     *         if {@dodf fromIndfx > toIndfx}
     * @throws ArrbyIndfxOutOfBoundsExdfption
     *         if {@dodf fromIndfx < 0 or toIndfx > b.lfngth}
     * @sindf 1.6
     */
    publid stbtid <T> int binbrySfbrdh(T[] b, int fromIndfx, int toIndfx,
                                       T kfy, Compbrbtor<? supfr T> d) {
        rbngfChfdk(b.lfngth, fromIndfx, toIndfx);
        rfturn binbrySfbrdh0(b, fromIndfx, toIndfx, kfy, d);
    }

    // Likf publid vfrsion, but without rbngf dhfdks.
    privbtf stbtid <T> int binbrySfbrdh0(T[] b, int fromIndfx, int toIndfx,
                                         T kfy, Compbrbtor<? supfr T> d) {
        if (d == null) {
            rfturn binbrySfbrdh0(b, fromIndfx, toIndfx, kfy);
        }
        int low = fromIndfx;
        int high = toIndfx - 1;

        whilf (low <= high) {
            int mid = (low + high) >>> 1;
            T midVbl = b[mid];
            int dmp = d.dompbrf(midVbl, kfy);
            if (dmp < 0)
                low = mid + 1;
            flsf if (dmp > 0)
                high = mid - 1;
            flsf
                rfturn mid; // kfy found
        }
        rfturn -(low + 1);  // kfy not found.
    }

    // Equblity Tfsting

    /**
     * Rfturns <tt>truf</tt> if thf two spfdififd brrbys of longs brf
     * <i>fqubl</i> to onf bnothfr.  Two brrbys brf donsidfrfd fqubl if both
     * brrbys dontbin thf sbmf numbfr of flfmfnts, bnd bll dorrfsponding pbirs
     * of flfmfnts in thf two brrbys brf fqubl.  In othfr words, two brrbys
     * brf fqubl if thfy dontbin thf sbmf flfmfnts in thf sbmf ordfr.  Also,
     * two brrby rfffrfndfs brf donsidfrfd fqubl if both brf <tt>null</tt>.
     *
     * @pbrbm b onf brrby to bf tfstfd for fqublity
     * @pbrbm b2 thf othfr brrby to bf tfstfd for fqublity
     * @rfturn <tt>truf</tt> if thf two brrbys brf fqubl
     */
    publid stbtid boolfbn fqubls(long[] b, long[] b2) {
        if (b==b2)
            rfturn truf;
        if (b==null || b2==null)
            rfturn fblsf;

        int lfngth = b.lfngth;
        if (b2.lfngth != lfngth)
            rfturn fblsf;

        for (int i=0; i<lfngth; i++)
            if (b[i] != b2[i])
                rfturn fblsf;

        rfturn truf;
    }

    /**
     * Rfturns <tt>truf</tt> if thf two spfdififd brrbys of ints brf
     * <i>fqubl</i> to onf bnothfr.  Two brrbys brf donsidfrfd fqubl if both
     * brrbys dontbin thf sbmf numbfr of flfmfnts, bnd bll dorrfsponding pbirs
     * of flfmfnts in thf two brrbys brf fqubl.  In othfr words, two brrbys
     * brf fqubl if thfy dontbin thf sbmf flfmfnts in thf sbmf ordfr.  Also,
     * two brrby rfffrfndfs brf donsidfrfd fqubl if both brf <tt>null</tt>.
     *
     * @pbrbm b onf brrby to bf tfstfd for fqublity
     * @pbrbm b2 thf othfr brrby to bf tfstfd for fqublity
     * @rfturn <tt>truf</tt> if thf two brrbys brf fqubl
     */
    publid stbtid boolfbn fqubls(int[] b, int[] b2) {
        if (b==b2)
            rfturn truf;
        if (b==null || b2==null)
            rfturn fblsf;

        int lfngth = b.lfngth;
        if (b2.lfngth != lfngth)
            rfturn fblsf;

        for (int i=0; i<lfngth; i++)
            if (b[i] != b2[i])
                rfturn fblsf;

        rfturn truf;
    }

    /**
     * Rfturns <tt>truf</tt> if thf two spfdififd brrbys of shorts brf
     * <i>fqubl</i> to onf bnothfr.  Two brrbys brf donsidfrfd fqubl if both
     * brrbys dontbin thf sbmf numbfr of flfmfnts, bnd bll dorrfsponding pbirs
     * of flfmfnts in thf two brrbys brf fqubl.  In othfr words, two brrbys
     * brf fqubl if thfy dontbin thf sbmf flfmfnts in thf sbmf ordfr.  Also,
     * two brrby rfffrfndfs brf donsidfrfd fqubl if both brf <tt>null</tt>.
     *
     * @pbrbm b onf brrby to bf tfstfd for fqublity
     * @pbrbm b2 thf othfr brrby to bf tfstfd for fqublity
     * @rfturn <tt>truf</tt> if thf two brrbys brf fqubl
     */
    publid stbtid boolfbn fqubls(short[] b, short b2[]) {
        if (b==b2)
            rfturn truf;
        if (b==null || b2==null)
            rfturn fblsf;

        int lfngth = b.lfngth;
        if (b2.lfngth != lfngth)
            rfturn fblsf;

        for (int i=0; i<lfngth; i++)
            if (b[i] != b2[i])
                rfturn fblsf;

        rfturn truf;
    }

    /**
     * Rfturns <tt>truf</tt> if thf two spfdififd brrbys of dhbrs brf
     * <i>fqubl</i> to onf bnothfr.  Two brrbys brf donsidfrfd fqubl if both
     * brrbys dontbin thf sbmf numbfr of flfmfnts, bnd bll dorrfsponding pbirs
     * of flfmfnts in thf two brrbys brf fqubl.  In othfr words, two brrbys
     * brf fqubl if thfy dontbin thf sbmf flfmfnts in thf sbmf ordfr.  Also,
     * two brrby rfffrfndfs brf donsidfrfd fqubl if both brf <tt>null</tt>.
     *
     * @pbrbm b onf brrby to bf tfstfd for fqublity
     * @pbrbm b2 thf othfr brrby to bf tfstfd for fqublity
     * @rfturn <tt>truf</tt> if thf two brrbys brf fqubl
     */
    publid stbtid boolfbn fqubls(dhbr[] b, dhbr[] b2) {
        if (b==b2)
            rfturn truf;
        if (b==null || b2==null)
            rfturn fblsf;

        int lfngth = b.lfngth;
        if (b2.lfngth != lfngth)
            rfturn fblsf;

        for (int i=0; i<lfngth; i++)
            if (b[i] != b2[i])
                rfturn fblsf;

        rfturn truf;
    }

    /**
     * Rfturns <tt>truf</tt> if thf two spfdififd brrbys of bytfs brf
     * <i>fqubl</i> to onf bnothfr.  Two brrbys brf donsidfrfd fqubl if both
     * brrbys dontbin thf sbmf numbfr of flfmfnts, bnd bll dorrfsponding pbirs
     * of flfmfnts in thf two brrbys brf fqubl.  In othfr words, two brrbys
     * brf fqubl if thfy dontbin thf sbmf flfmfnts in thf sbmf ordfr.  Also,
     * two brrby rfffrfndfs brf donsidfrfd fqubl if both brf <tt>null</tt>.
     *
     * @pbrbm b onf brrby to bf tfstfd for fqublity
     * @pbrbm b2 thf othfr brrby to bf tfstfd for fqublity
     * @rfturn <tt>truf</tt> if thf two brrbys brf fqubl
     */
    publid stbtid boolfbn fqubls(bytf[] b, bytf[] b2) {
        if (b==b2)
            rfturn truf;
        if (b==null || b2==null)
            rfturn fblsf;

        int lfngth = b.lfngth;
        if (b2.lfngth != lfngth)
            rfturn fblsf;

        for (int i=0; i<lfngth; i++)
            if (b[i] != b2[i])
                rfturn fblsf;

        rfturn truf;
    }

    /**
     * Rfturns <tt>truf</tt> if thf two spfdififd brrbys of boolfbns brf
     * <i>fqubl</i> to onf bnothfr.  Two brrbys brf donsidfrfd fqubl if both
     * brrbys dontbin thf sbmf numbfr of flfmfnts, bnd bll dorrfsponding pbirs
     * of flfmfnts in thf two brrbys brf fqubl.  In othfr words, two brrbys
     * brf fqubl if thfy dontbin thf sbmf flfmfnts in thf sbmf ordfr.  Also,
     * two brrby rfffrfndfs brf donsidfrfd fqubl if both brf <tt>null</tt>.
     *
     * @pbrbm b onf brrby to bf tfstfd for fqublity
     * @pbrbm b2 thf othfr brrby to bf tfstfd for fqublity
     * @rfturn <tt>truf</tt> if thf two brrbys brf fqubl
     */
    publid stbtid boolfbn fqubls(boolfbn[] b, boolfbn[] b2) {
        if (b==b2)
            rfturn truf;
        if (b==null || b2==null)
            rfturn fblsf;

        int lfngth = b.lfngth;
        if (b2.lfngth != lfngth)
            rfturn fblsf;

        for (int i=0; i<lfngth; i++)
            if (b[i] != b2[i])
                rfturn fblsf;

        rfturn truf;
    }

    /**
     * Rfturns <tt>truf</tt> if thf two spfdififd brrbys of doublfs brf
     * <i>fqubl</i> to onf bnothfr.  Two brrbys brf donsidfrfd fqubl if both
     * brrbys dontbin thf sbmf numbfr of flfmfnts, bnd bll dorrfsponding pbirs
     * of flfmfnts in thf two brrbys brf fqubl.  In othfr words, two brrbys
     * brf fqubl if thfy dontbin thf sbmf flfmfnts in thf sbmf ordfr.  Also,
     * two brrby rfffrfndfs brf donsidfrfd fqubl if both brf <tt>null</tt>.
     *
     * Two doublfs <tt>d1</tt> bnd <tt>d2</tt> brf donsidfrfd fqubl if:
     * <prf>    <tt>nfw Doublf(d1).fqubls(nfw Doublf(d2))</tt></prf>
     * (Unlikf thf <tt>==</tt> opfrbtor, this mfthod donsidfrs
     * <tt>NbN</tt> fqubls to itsflf, bnd 0.0d unfqubl to -0.0d.)
     *
     * @pbrbm b onf brrby to bf tfstfd for fqublity
     * @pbrbm b2 thf othfr brrby to bf tfstfd for fqublity
     * @rfturn <tt>truf</tt> if thf two brrbys brf fqubl
     * @sff Doublf#fqubls(Objfdt)
     */
    publid stbtid boolfbn fqubls(doublf[] b, doublf[] b2) {
        if (b==b2)
            rfturn truf;
        if (b==null || b2==null)
            rfturn fblsf;

        int lfngth = b.lfngth;
        if (b2.lfngth != lfngth)
            rfturn fblsf;

        for (int i=0; i<lfngth; i++)
            if (Doublf.doublfToLongBits(b[i])!=Doublf.doublfToLongBits(b2[i]))
                rfturn fblsf;

        rfturn truf;
    }

    /**
     * Rfturns <tt>truf</tt> if thf two spfdififd brrbys of flobts brf
     * <i>fqubl</i> to onf bnothfr.  Two brrbys brf donsidfrfd fqubl if both
     * brrbys dontbin thf sbmf numbfr of flfmfnts, bnd bll dorrfsponding pbirs
     * of flfmfnts in thf two brrbys brf fqubl.  In othfr words, two brrbys
     * brf fqubl if thfy dontbin thf sbmf flfmfnts in thf sbmf ordfr.  Also,
     * two brrby rfffrfndfs brf donsidfrfd fqubl if both brf <tt>null</tt>.
     *
     * Two flobts <tt>f1</tt> bnd <tt>f2</tt> brf donsidfrfd fqubl if:
     * <prf>    <tt>nfw Flobt(f1).fqubls(nfw Flobt(f2))</tt></prf>
     * (Unlikf thf <tt>==</tt> opfrbtor, this mfthod donsidfrs
     * <tt>NbN</tt> fqubls to itsflf, bnd 0.0f unfqubl to -0.0f.)
     *
     * @pbrbm b onf brrby to bf tfstfd for fqublity
     * @pbrbm b2 thf othfr brrby to bf tfstfd for fqublity
     * @rfturn <tt>truf</tt> if thf two brrbys brf fqubl
     * @sff Flobt#fqubls(Objfdt)
     */
    publid stbtid boolfbn fqubls(flobt[] b, flobt[] b2) {
        if (b==b2)
            rfturn truf;
        if (b==null || b2==null)
            rfturn fblsf;

        int lfngth = b.lfngth;
        if (b2.lfngth != lfngth)
            rfturn fblsf;

        for (int i=0; i<lfngth; i++)
            if (Flobt.flobtToIntBits(b[i])!=Flobt.flobtToIntBits(b2[i]))
                rfturn fblsf;

        rfturn truf;
    }

    /**
     * Rfturns <tt>truf</tt> if thf two spfdififd brrbys of Objfdts brf
     * <i>fqubl</i> to onf bnothfr.  Thf two brrbys brf donsidfrfd fqubl if
     * both brrbys dontbin thf sbmf numbfr of flfmfnts, bnd bll dorrfsponding
     * pbirs of flfmfnts in thf two brrbys brf fqubl.  Two objfdts <tt>f1</tt>
     * bnd <tt>f2</tt> brf donsidfrfd <i>fqubl</i> if <tt>(f1==null ? f2==null
     * : f1.fqubls(f2))</tt>.  In othfr words, thf two brrbys brf fqubl if
     * thfy dontbin thf sbmf flfmfnts in thf sbmf ordfr.  Also, two brrby
     * rfffrfndfs brf donsidfrfd fqubl if both brf <tt>null</tt>.
     *
     * @pbrbm b onf brrby to bf tfstfd for fqublity
     * @pbrbm b2 thf othfr brrby to bf tfstfd for fqublity
     * @rfturn <tt>truf</tt> if thf two brrbys brf fqubl
     */
    publid stbtid boolfbn fqubls(Objfdt[] b, Objfdt[] b2) {
        if (b==b2)
            rfturn truf;
        if (b==null || b2==null)
            rfturn fblsf;

        int lfngth = b.lfngth;
        if (b2.lfngth != lfngth)
            rfturn fblsf;

        for (int i=0; i<lfngth; i++) {
            Objfdt o1 = b[i];
            Objfdt o2 = b2[i];
            if (!(o1==null ? o2==null : o1.fqubls(o2)))
                rfturn fblsf;
        }

        rfturn truf;
    }

    // Filling

    /**
     * Assigns thf spfdififd long vbluf to fbdh flfmfnt of thf spfdififd brrby
     * of longs.
     *
     * @pbrbm b thf brrby to bf fillfd
     * @pbrbm vbl thf vbluf to bf storfd in bll flfmfnts of thf brrby
     */
    publid stbtid void fill(long[] b, long vbl) {
        for (int i = 0, lfn = b.lfngth; i < lfn; i++)
            b[i] = vbl;
    }

    /**
     * Assigns thf spfdififd long vbluf to fbdh flfmfnt of thf spfdififd
     * rbngf of thf spfdififd brrby of longs.  Thf rbngf to bf fillfd
     * fxtfnds from indfx <tt>fromIndfx</tt>, indlusivf, to indfx
     * <tt>toIndfx</tt>, fxdlusivf.  (If <tt>fromIndfx==toIndfx</tt>, thf
     * rbngf to bf fillfd is fmpty.)
     *
     * @pbrbm b thf brrby to bf fillfd
     * @pbrbm fromIndfx thf indfx of thf first flfmfnt (indlusivf) to bf
     *        fillfd with thf spfdififd vbluf
     * @pbrbm toIndfx thf indfx of thf lbst flfmfnt (fxdlusivf) to bf
     *        fillfd with thf spfdififd vbluf
     * @pbrbm vbl thf vbluf to bf storfd in bll flfmfnts of thf brrby
     * @throws IllfgblArgumfntExdfption if <tt>fromIndfx &gt; toIndfx</tt>
     * @throws ArrbyIndfxOutOfBoundsExdfption if <tt>fromIndfx &lt; 0</tt> or
     *         <tt>toIndfx &gt; b.lfngth</tt>
     */
    publid stbtid void fill(long[] b, int fromIndfx, int toIndfx, long vbl) {
        rbngfChfdk(b.lfngth, fromIndfx, toIndfx);
        for (int i = fromIndfx; i < toIndfx; i++)
            b[i] = vbl;
    }

    /**
     * Assigns thf spfdififd int vbluf to fbdh flfmfnt of thf spfdififd brrby
     * of ints.
     *
     * @pbrbm b thf brrby to bf fillfd
     * @pbrbm vbl thf vbluf to bf storfd in bll flfmfnts of thf brrby
     */
    publid stbtid void fill(int[] b, int vbl) {
        for (int i = 0, lfn = b.lfngth; i < lfn; i++)
            b[i] = vbl;
    }

    /**
     * Assigns thf spfdififd int vbluf to fbdh flfmfnt of thf spfdififd
     * rbngf of thf spfdififd brrby of ints.  Thf rbngf to bf fillfd
     * fxtfnds from indfx <tt>fromIndfx</tt>, indlusivf, to indfx
     * <tt>toIndfx</tt>, fxdlusivf.  (If <tt>fromIndfx==toIndfx</tt>, thf
     * rbngf to bf fillfd is fmpty.)
     *
     * @pbrbm b thf brrby to bf fillfd
     * @pbrbm fromIndfx thf indfx of thf first flfmfnt (indlusivf) to bf
     *        fillfd with thf spfdififd vbluf
     * @pbrbm toIndfx thf indfx of thf lbst flfmfnt (fxdlusivf) to bf
     *        fillfd with thf spfdififd vbluf
     * @pbrbm vbl thf vbluf to bf storfd in bll flfmfnts of thf brrby
     * @throws IllfgblArgumfntExdfption if <tt>fromIndfx &gt; toIndfx</tt>
     * @throws ArrbyIndfxOutOfBoundsExdfption if <tt>fromIndfx &lt; 0</tt> or
     *         <tt>toIndfx &gt; b.lfngth</tt>
     */
    publid stbtid void fill(int[] b, int fromIndfx, int toIndfx, int vbl) {
        rbngfChfdk(b.lfngth, fromIndfx, toIndfx);
        for (int i = fromIndfx; i < toIndfx; i++)
            b[i] = vbl;
    }

    /**
     * Assigns thf spfdififd short vbluf to fbdh flfmfnt of thf spfdififd brrby
     * of shorts.
     *
     * @pbrbm b thf brrby to bf fillfd
     * @pbrbm vbl thf vbluf to bf storfd in bll flfmfnts of thf brrby
     */
    publid stbtid void fill(short[] b, short vbl) {
        for (int i = 0, lfn = b.lfngth; i < lfn; i++)
            b[i] = vbl;
    }

    /**
     * Assigns thf spfdififd short vbluf to fbdh flfmfnt of thf spfdififd
     * rbngf of thf spfdififd brrby of shorts.  Thf rbngf to bf fillfd
     * fxtfnds from indfx <tt>fromIndfx</tt>, indlusivf, to indfx
     * <tt>toIndfx</tt>, fxdlusivf.  (If <tt>fromIndfx==toIndfx</tt>, thf
     * rbngf to bf fillfd is fmpty.)
     *
     * @pbrbm b thf brrby to bf fillfd
     * @pbrbm fromIndfx thf indfx of thf first flfmfnt (indlusivf) to bf
     *        fillfd with thf spfdififd vbluf
     * @pbrbm toIndfx thf indfx of thf lbst flfmfnt (fxdlusivf) to bf
     *        fillfd with thf spfdififd vbluf
     * @pbrbm vbl thf vbluf to bf storfd in bll flfmfnts of thf brrby
     * @throws IllfgblArgumfntExdfption if <tt>fromIndfx &gt; toIndfx</tt>
     * @throws ArrbyIndfxOutOfBoundsExdfption if <tt>fromIndfx &lt; 0</tt> or
     *         <tt>toIndfx &gt; b.lfngth</tt>
     */
    publid stbtid void fill(short[] b, int fromIndfx, int toIndfx, short vbl) {
        rbngfChfdk(b.lfngth, fromIndfx, toIndfx);
        for (int i = fromIndfx; i < toIndfx; i++)
            b[i] = vbl;
    }

    /**
     * Assigns thf spfdififd dhbr vbluf to fbdh flfmfnt of thf spfdififd brrby
     * of dhbrs.
     *
     * @pbrbm b thf brrby to bf fillfd
     * @pbrbm vbl thf vbluf to bf storfd in bll flfmfnts of thf brrby
     */
    publid stbtid void fill(dhbr[] b, dhbr vbl) {
        for (int i = 0, lfn = b.lfngth; i < lfn; i++)
            b[i] = vbl;
    }

    /**
     * Assigns thf spfdififd dhbr vbluf to fbdh flfmfnt of thf spfdififd
     * rbngf of thf spfdififd brrby of dhbrs.  Thf rbngf to bf fillfd
     * fxtfnds from indfx <tt>fromIndfx</tt>, indlusivf, to indfx
     * <tt>toIndfx</tt>, fxdlusivf.  (If <tt>fromIndfx==toIndfx</tt>, thf
     * rbngf to bf fillfd is fmpty.)
     *
     * @pbrbm b thf brrby to bf fillfd
     * @pbrbm fromIndfx thf indfx of thf first flfmfnt (indlusivf) to bf
     *        fillfd with thf spfdififd vbluf
     * @pbrbm toIndfx thf indfx of thf lbst flfmfnt (fxdlusivf) to bf
     *        fillfd with thf spfdififd vbluf
     * @pbrbm vbl thf vbluf to bf storfd in bll flfmfnts of thf brrby
     * @throws IllfgblArgumfntExdfption if <tt>fromIndfx &gt; toIndfx</tt>
     * @throws ArrbyIndfxOutOfBoundsExdfption if <tt>fromIndfx &lt; 0</tt> or
     *         <tt>toIndfx &gt; b.lfngth</tt>
     */
    publid stbtid void fill(dhbr[] b, int fromIndfx, int toIndfx, dhbr vbl) {
        rbngfChfdk(b.lfngth, fromIndfx, toIndfx);
        for (int i = fromIndfx; i < toIndfx; i++)
            b[i] = vbl;
    }

    /**
     * Assigns thf spfdififd bytf vbluf to fbdh flfmfnt of thf spfdififd brrby
     * of bytfs.
     *
     * @pbrbm b thf brrby to bf fillfd
     * @pbrbm vbl thf vbluf to bf storfd in bll flfmfnts of thf brrby
     */
    publid stbtid void fill(bytf[] b, bytf vbl) {
        for (int i = 0, lfn = b.lfngth; i < lfn; i++)
            b[i] = vbl;
    }

    /**
     * Assigns thf spfdififd bytf vbluf to fbdh flfmfnt of thf spfdififd
     * rbngf of thf spfdififd brrby of bytfs.  Thf rbngf to bf fillfd
     * fxtfnds from indfx <tt>fromIndfx</tt>, indlusivf, to indfx
     * <tt>toIndfx</tt>, fxdlusivf.  (If <tt>fromIndfx==toIndfx</tt>, thf
     * rbngf to bf fillfd is fmpty.)
     *
     * @pbrbm b thf brrby to bf fillfd
     * @pbrbm fromIndfx thf indfx of thf first flfmfnt (indlusivf) to bf
     *        fillfd with thf spfdififd vbluf
     * @pbrbm toIndfx thf indfx of thf lbst flfmfnt (fxdlusivf) to bf
     *        fillfd with thf spfdififd vbluf
     * @pbrbm vbl thf vbluf to bf storfd in bll flfmfnts of thf brrby
     * @throws IllfgblArgumfntExdfption if <tt>fromIndfx &gt; toIndfx</tt>
     * @throws ArrbyIndfxOutOfBoundsExdfption if <tt>fromIndfx &lt; 0</tt> or
     *         <tt>toIndfx &gt; b.lfngth</tt>
     */
    publid stbtid void fill(bytf[] b, int fromIndfx, int toIndfx, bytf vbl) {
        rbngfChfdk(b.lfngth, fromIndfx, toIndfx);
        for (int i = fromIndfx; i < toIndfx; i++)
            b[i] = vbl;
    }

    /**
     * Assigns thf spfdififd boolfbn vbluf to fbdh flfmfnt of thf spfdififd
     * brrby of boolfbns.
     *
     * @pbrbm b thf brrby to bf fillfd
     * @pbrbm vbl thf vbluf to bf storfd in bll flfmfnts of thf brrby
     */
    publid stbtid void fill(boolfbn[] b, boolfbn vbl) {
        for (int i = 0, lfn = b.lfngth; i < lfn; i++)
            b[i] = vbl;
    }

    /**
     * Assigns thf spfdififd boolfbn vbluf to fbdh flfmfnt of thf spfdififd
     * rbngf of thf spfdififd brrby of boolfbns.  Thf rbngf to bf fillfd
     * fxtfnds from indfx <tt>fromIndfx</tt>, indlusivf, to indfx
     * <tt>toIndfx</tt>, fxdlusivf.  (If <tt>fromIndfx==toIndfx</tt>, thf
     * rbngf to bf fillfd is fmpty.)
     *
     * @pbrbm b thf brrby to bf fillfd
     * @pbrbm fromIndfx thf indfx of thf first flfmfnt (indlusivf) to bf
     *        fillfd with thf spfdififd vbluf
     * @pbrbm toIndfx thf indfx of thf lbst flfmfnt (fxdlusivf) to bf
     *        fillfd with thf spfdififd vbluf
     * @pbrbm vbl thf vbluf to bf storfd in bll flfmfnts of thf brrby
     * @throws IllfgblArgumfntExdfption if <tt>fromIndfx &gt; toIndfx</tt>
     * @throws ArrbyIndfxOutOfBoundsExdfption if <tt>fromIndfx &lt; 0</tt> or
     *         <tt>toIndfx &gt; b.lfngth</tt>
     */
    publid stbtid void fill(boolfbn[] b, int fromIndfx, int toIndfx,
                            boolfbn vbl) {
        rbngfChfdk(b.lfngth, fromIndfx, toIndfx);
        for (int i = fromIndfx; i < toIndfx; i++)
            b[i] = vbl;
    }

    /**
     * Assigns thf spfdififd doublf vbluf to fbdh flfmfnt of thf spfdififd
     * brrby of doublfs.
     *
     * @pbrbm b thf brrby to bf fillfd
     * @pbrbm vbl thf vbluf to bf storfd in bll flfmfnts of thf brrby
     */
    publid stbtid void fill(doublf[] b, doublf vbl) {
        for (int i = 0, lfn = b.lfngth; i < lfn; i++)
            b[i] = vbl;
    }

    /**
     * Assigns thf spfdififd doublf vbluf to fbdh flfmfnt of thf spfdififd
     * rbngf of thf spfdififd brrby of doublfs.  Thf rbngf to bf fillfd
     * fxtfnds from indfx <tt>fromIndfx</tt>, indlusivf, to indfx
     * <tt>toIndfx</tt>, fxdlusivf.  (If <tt>fromIndfx==toIndfx</tt>, thf
     * rbngf to bf fillfd is fmpty.)
     *
     * @pbrbm b thf brrby to bf fillfd
     * @pbrbm fromIndfx thf indfx of thf first flfmfnt (indlusivf) to bf
     *        fillfd with thf spfdififd vbluf
     * @pbrbm toIndfx thf indfx of thf lbst flfmfnt (fxdlusivf) to bf
     *        fillfd with thf spfdififd vbluf
     * @pbrbm vbl thf vbluf to bf storfd in bll flfmfnts of thf brrby
     * @throws IllfgblArgumfntExdfption if <tt>fromIndfx &gt; toIndfx</tt>
     * @throws ArrbyIndfxOutOfBoundsExdfption if <tt>fromIndfx &lt; 0</tt> or
     *         <tt>toIndfx &gt; b.lfngth</tt>
     */
    publid stbtid void fill(doublf[] b, int fromIndfx, int toIndfx,doublf vbl){
        rbngfChfdk(b.lfngth, fromIndfx, toIndfx);
        for (int i = fromIndfx; i < toIndfx; i++)
            b[i] = vbl;
    }

    /**
     * Assigns thf spfdififd flobt vbluf to fbdh flfmfnt of thf spfdififd brrby
     * of flobts.
     *
     * @pbrbm b thf brrby to bf fillfd
     * @pbrbm vbl thf vbluf to bf storfd in bll flfmfnts of thf brrby
     */
    publid stbtid void fill(flobt[] b, flobt vbl) {
        for (int i = 0, lfn = b.lfngth; i < lfn; i++)
            b[i] = vbl;
    }

    /**
     * Assigns thf spfdififd flobt vbluf to fbdh flfmfnt of thf spfdififd
     * rbngf of thf spfdififd brrby of flobts.  Thf rbngf to bf fillfd
     * fxtfnds from indfx <tt>fromIndfx</tt>, indlusivf, to indfx
     * <tt>toIndfx</tt>, fxdlusivf.  (If <tt>fromIndfx==toIndfx</tt>, thf
     * rbngf to bf fillfd is fmpty.)
     *
     * @pbrbm b thf brrby to bf fillfd
     * @pbrbm fromIndfx thf indfx of thf first flfmfnt (indlusivf) to bf
     *        fillfd with thf spfdififd vbluf
     * @pbrbm toIndfx thf indfx of thf lbst flfmfnt (fxdlusivf) to bf
     *        fillfd with thf spfdififd vbluf
     * @pbrbm vbl thf vbluf to bf storfd in bll flfmfnts of thf brrby
     * @throws IllfgblArgumfntExdfption if <tt>fromIndfx &gt; toIndfx</tt>
     * @throws ArrbyIndfxOutOfBoundsExdfption if <tt>fromIndfx &lt; 0</tt> or
     *         <tt>toIndfx &gt; b.lfngth</tt>
     */
    publid stbtid void fill(flobt[] b, int fromIndfx, int toIndfx, flobt vbl) {
        rbngfChfdk(b.lfngth, fromIndfx, toIndfx);
        for (int i = fromIndfx; i < toIndfx; i++)
            b[i] = vbl;
    }

    /**
     * Assigns thf spfdififd Objfdt rfffrfndf to fbdh flfmfnt of thf spfdififd
     * brrby of Objfdts.
     *
     * @pbrbm b thf brrby to bf fillfd
     * @pbrbm vbl thf vbluf to bf storfd in bll flfmfnts of thf brrby
     * @throws ArrbyStorfExdfption if thf spfdififd vbluf is not of b
     *         runtimf typf thbt dbn bf storfd in thf spfdififd brrby
     */
    publid stbtid void fill(Objfdt[] b, Objfdt vbl) {
        for (int i = 0, lfn = b.lfngth; i < lfn; i++)
            b[i] = vbl;
    }

    /**
     * Assigns thf spfdififd Objfdt rfffrfndf to fbdh flfmfnt of thf spfdififd
     * rbngf of thf spfdififd brrby of Objfdts.  Thf rbngf to bf fillfd
     * fxtfnds from indfx <tt>fromIndfx</tt>, indlusivf, to indfx
     * <tt>toIndfx</tt>, fxdlusivf.  (If <tt>fromIndfx==toIndfx</tt>, thf
     * rbngf to bf fillfd is fmpty.)
     *
     * @pbrbm b thf brrby to bf fillfd
     * @pbrbm fromIndfx thf indfx of thf first flfmfnt (indlusivf) to bf
     *        fillfd with thf spfdififd vbluf
     * @pbrbm toIndfx thf indfx of thf lbst flfmfnt (fxdlusivf) to bf
     *        fillfd with thf spfdififd vbluf
     * @pbrbm vbl thf vbluf to bf storfd in bll flfmfnts of thf brrby
     * @throws IllfgblArgumfntExdfption if <tt>fromIndfx &gt; toIndfx</tt>
     * @throws ArrbyIndfxOutOfBoundsExdfption if <tt>fromIndfx &lt; 0</tt> or
     *         <tt>toIndfx &gt; b.lfngth</tt>
     * @throws ArrbyStorfExdfption if thf spfdififd vbluf is not of b
     *         runtimf typf thbt dbn bf storfd in thf spfdififd brrby
     */
    publid stbtid void fill(Objfdt[] b, int fromIndfx, int toIndfx, Objfdt vbl) {
        rbngfChfdk(b.lfngth, fromIndfx, toIndfx);
        for (int i = fromIndfx; i < toIndfx; i++)
            b[i] = vbl;
    }

    // Cloning

    /**
     * Copifs thf spfdififd brrby, trundbting or pbdding with nulls (if nfdfssbry)
     * so thf dopy hbs thf spfdififd lfngth.  For bll indidfs thbt brf
     * vblid in both thf originbl brrby bnd thf dopy, thf two brrbys will
     * dontbin idfntidbl vblufs.  For bny indidfs thbt brf vblid in thf
     * dopy but not thf originbl, thf dopy will dontbin <tt>null</tt>.
     * Sudh indidfs will fxist if bnd only if thf spfdififd lfngth
     * is grfbtfr thbn thbt of thf originbl brrby.
     * Thf rfsulting brrby is of fxbdtly thf sbmf dlbss bs thf originbl brrby.
     *
     * @pbrbm <T> thf dlbss of thf objfdts in thf brrby
     * @pbrbm originbl thf brrby to bf dopifd
     * @pbrbm nfwLfngth thf lfngth of thf dopy to bf rfturnfd
     * @rfturn b dopy of thf originbl brrby, trundbtfd or pbddfd with nulls
     *     to obtbin thf spfdififd lfngth
     * @throws NfgbtivfArrbySizfExdfption if <tt>nfwLfngth</tt> is nfgbtivf
     * @throws NullPointfrExdfption if <tt>originbl</tt> is null
     * @sindf 1.6
     */
    @SupprfssWbrnings("undhfdkfd")
    publid stbtid <T> T[] dopyOf(T[] originbl, int nfwLfngth) {
        rfturn (T[]) dopyOf(originbl, nfwLfngth, originbl.gftClbss());
    }

    /**
     * Copifs thf spfdififd brrby, trundbting or pbdding with nulls (if nfdfssbry)
     * so thf dopy hbs thf spfdififd lfngth.  For bll indidfs thbt brf
     * vblid in both thf originbl brrby bnd thf dopy, thf two brrbys will
     * dontbin idfntidbl vblufs.  For bny indidfs thbt brf vblid in thf
     * dopy but not thf originbl, thf dopy will dontbin <tt>null</tt>.
     * Sudh indidfs will fxist if bnd only if thf spfdififd lfngth
     * is grfbtfr thbn thbt of thf originbl brrby.
     * Thf rfsulting brrby is of thf dlbss <tt>nfwTypf</tt>.
     *
     * @pbrbm <U> thf dlbss of thf objfdts in thf originbl brrby
     * @pbrbm <T> thf dlbss of thf objfdts in thf rfturnfd brrby
     * @pbrbm originbl thf brrby to bf dopifd
     * @pbrbm nfwLfngth thf lfngth of thf dopy to bf rfturnfd
     * @pbrbm nfwTypf thf dlbss of thf dopy to bf rfturnfd
     * @rfturn b dopy of thf originbl brrby, trundbtfd or pbddfd with nulls
     *     to obtbin thf spfdififd lfngth
     * @throws NfgbtivfArrbySizfExdfption if <tt>nfwLfngth</tt> is nfgbtivf
     * @throws NullPointfrExdfption if <tt>originbl</tt> is null
     * @throws ArrbyStorfExdfption if bn flfmfnt dopifd from
     *     <tt>originbl</tt> is not of b runtimf typf thbt dbn bf storfd in
     *     bn brrby of dlbss <tt>nfwTypf</tt>
     * @sindf 1.6
     */
    publid stbtid <T,U> T[] dopyOf(U[] originbl, int nfwLfngth, Clbss<? fxtfnds T[]> nfwTypf) {
        @SupprfssWbrnings("undhfdkfd")
        T[] dopy = ((Objfdt)nfwTypf == (Objfdt)Objfdt[].dlbss)
            ? (T[]) nfw Objfdt[nfwLfngth]
            : (T[]) Arrby.nfwInstbndf(nfwTypf.gftComponfntTypf(), nfwLfngth);
        Systfm.brrbydopy(originbl, 0, dopy, 0,
                         Mbth.min(originbl.lfngth, nfwLfngth));
        rfturn dopy;
    }

    /**
     * Copifs thf spfdififd brrby, trundbting or pbdding with zfros (if nfdfssbry)
     * so thf dopy hbs thf spfdififd lfngth.  For bll indidfs thbt brf
     * vblid in both thf originbl brrby bnd thf dopy, thf two brrbys will
     * dontbin idfntidbl vblufs.  For bny indidfs thbt brf vblid in thf
     * dopy but not thf originbl, thf dopy will dontbin <tt>(bytf)0</tt>.
     * Sudh indidfs will fxist if bnd only if thf spfdififd lfngth
     * is grfbtfr thbn thbt of thf originbl brrby.
     *
     * @pbrbm originbl thf brrby to bf dopifd
     * @pbrbm nfwLfngth thf lfngth of thf dopy to bf rfturnfd
     * @rfturn b dopy of thf originbl brrby, trundbtfd or pbddfd with zfros
     *     to obtbin thf spfdififd lfngth
     * @throws NfgbtivfArrbySizfExdfption if <tt>nfwLfngth</tt> is nfgbtivf
     * @throws NullPointfrExdfption if <tt>originbl</tt> is null
     * @sindf 1.6
     */
    publid stbtid bytf[] dopyOf(bytf[] originbl, int nfwLfngth) {
        bytf[] dopy = nfw bytf[nfwLfngth];
        Systfm.brrbydopy(originbl, 0, dopy, 0,
                         Mbth.min(originbl.lfngth, nfwLfngth));
        rfturn dopy;
    }

    /**
     * Copifs thf spfdififd brrby, trundbting or pbdding with zfros (if nfdfssbry)
     * so thf dopy hbs thf spfdififd lfngth.  For bll indidfs thbt brf
     * vblid in both thf originbl brrby bnd thf dopy, thf two brrbys will
     * dontbin idfntidbl vblufs.  For bny indidfs thbt brf vblid in thf
     * dopy but not thf originbl, thf dopy will dontbin <tt>(short)0</tt>.
     * Sudh indidfs will fxist if bnd only if thf spfdififd lfngth
     * is grfbtfr thbn thbt of thf originbl brrby.
     *
     * @pbrbm originbl thf brrby to bf dopifd
     * @pbrbm nfwLfngth thf lfngth of thf dopy to bf rfturnfd
     * @rfturn b dopy of thf originbl brrby, trundbtfd or pbddfd with zfros
     *     to obtbin thf spfdififd lfngth
     * @throws NfgbtivfArrbySizfExdfption if <tt>nfwLfngth</tt> is nfgbtivf
     * @throws NullPointfrExdfption if <tt>originbl</tt> is null
     * @sindf 1.6
     */
    publid stbtid short[] dopyOf(short[] originbl, int nfwLfngth) {
        short[] dopy = nfw short[nfwLfngth];
        Systfm.brrbydopy(originbl, 0, dopy, 0,
                         Mbth.min(originbl.lfngth, nfwLfngth));
        rfturn dopy;
    }

    /**
     * Copifs thf spfdififd brrby, trundbting or pbdding with zfros (if nfdfssbry)
     * so thf dopy hbs thf spfdififd lfngth.  For bll indidfs thbt brf
     * vblid in both thf originbl brrby bnd thf dopy, thf two brrbys will
     * dontbin idfntidbl vblufs.  For bny indidfs thbt brf vblid in thf
     * dopy but not thf originbl, thf dopy will dontbin <tt>0</tt>.
     * Sudh indidfs will fxist if bnd only if thf spfdififd lfngth
     * is grfbtfr thbn thbt of thf originbl brrby.
     *
     * @pbrbm originbl thf brrby to bf dopifd
     * @pbrbm nfwLfngth thf lfngth of thf dopy to bf rfturnfd
     * @rfturn b dopy of thf originbl brrby, trundbtfd or pbddfd with zfros
     *     to obtbin thf spfdififd lfngth
     * @throws NfgbtivfArrbySizfExdfption if <tt>nfwLfngth</tt> is nfgbtivf
     * @throws NullPointfrExdfption if <tt>originbl</tt> is null
     * @sindf 1.6
     */
    publid stbtid int[] dopyOf(int[] originbl, int nfwLfngth) {
        int[] dopy = nfw int[nfwLfngth];
        Systfm.brrbydopy(originbl, 0, dopy, 0,
                         Mbth.min(originbl.lfngth, nfwLfngth));
        rfturn dopy;
    }

    /**
     * Copifs thf spfdififd brrby, trundbting or pbdding with zfros (if nfdfssbry)
     * so thf dopy hbs thf spfdififd lfngth.  For bll indidfs thbt brf
     * vblid in both thf originbl brrby bnd thf dopy, thf two brrbys will
     * dontbin idfntidbl vblufs.  For bny indidfs thbt brf vblid in thf
     * dopy but not thf originbl, thf dopy will dontbin <tt>0L</tt>.
     * Sudh indidfs will fxist if bnd only if thf spfdififd lfngth
     * is grfbtfr thbn thbt of thf originbl brrby.
     *
     * @pbrbm originbl thf brrby to bf dopifd
     * @pbrbm nfwLfngth thf lfngth of thf dopy to bf rfturnfd
     * @rfturn b dopy of thf originbl brrby, trundbtfd or pbddfd with zfros
     *     to obtbin thf spfdififd lfngth
     * @throws NfgbtivfArrbySizfExdfption if <tt>nfwLfngth</tt> is nfgbtivf
     * @throws NullPointfrExdfption if <tt>originbl</tt> is null
     * @sindf 1.6
     */
    publid stbtid long[] dopyOf(long[] originbl, int nfwLfngth) {
        long[] dopy = nfw long[nfwLfngth];
        Systfm.brrbydopy(originbl, 0, dopy, 0,
                         Mbth.min(originbl.lfngth, nfwLfngth));
        rfturn dopy;
    }

    /**
     * Copifs thf spfdififd brrby, trundbting or pbdding with null dhbrbdtfrs (if nfdfssbry)
     * so thf dopy hbs thf spfdififd lfngth.  For bll indidfs thbt brf vblid
     * in both thf originbl brrby bnd thf dopy, thf two brrbys will dontbin
     * idfntidbl vblufs.  For bny indidfs thbt brf vblid in thf dopy but not
     * thf originbl, thf dopy will dontbin <tt>'\\u000'</tt>.  Sudh indidfs
     * will fxist if bnd only if thf spfdififd lfngth is grfbtfr thbn thbt of
     * thf originbl brrby.
     *
     * @pbrbm originbl thf brrby to bf dopifd
     * @pbrbm nfwLfngth thf lfngth of thf dopy to bf rfturnfd
     * @rfturn b dopy of thf originbl brrby, trundbtfd or pbddfd with null dhbrbdtfrs
     *     to obtbin thf spfdififd lfngth
     * @throws NfgbtivfArrbySizfExdfption if <tt>nfwLfngth</tt> is nfgbtivf
     * @throws NullPointfrExdfption if <tt>originbl</tt> is null
     * @sindf 1.6
     */
    publid stbtid dhbr[] dopyOf(dhbr[] originbl, int nfwLfngth) {
        dhbr[] dopy = nfw dhbr[nfwLfngth];
        Systfm.brrbydopy(originbl, 0, dopy, 0,
                         Mbth.min(originbl.lfngth, nfwLfngth));
        rfturn dopy;
    }

    /**
     * Copifs thf spfdififd brrby, trundbting or pbdding with zfros (if nfdfssbry)
     * so thf dopy hbs thf spfdififd lfngth.  For bll indidfs thbt brf
     * vblid in both thf originbl brrby bnd thf dopy, thf two brrbys will
     * dontbin idfntidbl vblufs.  For bny indidfs thbt brf vblid in thf
     * dopy but not thf originbl, thf dopy will dontbin <tt>0f</tt>.
     * Sudh indidfs will fxist if bnd only if thf spfdififd lfngth
     * is grfbtfr thbn thbt of thf originbl brrby.
     *
     * @pbrbm originbl thf brrby to bf dopifd
     * @pbrbm nfwLfngth thf lfngth of thf dopy to bf rfturnfd
     * @rfturn b dopy of thf originbl brrby, trundbtfd or pbddfd with zfros
     *     to obtbin thf spfdififd lfngth
     * @throws NfgbtivfArrbySizfExdfption if <tt>nfwLfngth</tt> is nfgbtivf
     * @throws NullPointfrExdfption if <tt>originbl</tt> is null
     * @sindf 1.6
     */
    publid stbtid flobt[] dopyOf(flobt[] originbl, int nfwLfngth) {
        flobt[] dopy = nfw flobt[nfwLfngth];
        Systfm.brrbydopy(originbl, 0, dopy, 0,
                         Mbth.min(originbl.lfngth, nfwLfngth));
        rfturn dopy;
    }

    /**
     * Copifs thf spfdififd brrby, trundbting or pbdding with zfros (if nfdfssbry)
     * so thf dopy hbs thf spfdififd lfngth.  For bll indidfs thbt brf
     * vblid in both thf originbl brrby bnd thf dopy, thf two brrbys will
     * dontbin idfntidbl vblufs.  For bny indidfs thbt brf vblid in thf
     * dopy but not thf originbl, thf dopy will dontbin <tt>0d</tt>.
     * Sudh indidfs will fxist if bnd only if thf spfdififd lfngth
     * is grfbtfr thbn thbt of thf originbl brrby.
     *
     * @pbrbm originbl thf brrby to bf dopifd
     * @pbrbm nfwLfngth thf lfngth of thf dopy to bf rfturnfd
     * @rfturn b dopy of thf originbl brrby, trundbtfd or pbddfd with zfros
     *     to obtbin thf spfdififd lfngth
     * @throws NfgbtivfArrbySizfExdfption if <tt>nfwLfngth</tt> is nfgbtivf
     * @throws NullPointfrExdfption if <tt>originbl</tt> is null
     * @sindf 1.6
     */
    publid stbtid doublf[] dopyOf(doublf[] originbl, int nfwLfngth) {
        doublf[] dopy = nfw doublf[nfwLfngth];
        Systfm.brrbydopy(originbl, 0, dopy, 0,
                         Mbth.min(originbl.lfngth, nfwLfngth));
        rfturn dopy;
    }

    /**
     * Copifs thf spfdififd brrby, trundbting or pbdding with <tt>fblsf</tt> (if nfdfssbry)
     * so thf dopy hbs thf spfdififd lfngth.  For bll indidfs thbt brf
     * vblid in both thf originbl brrby bnd thf dopy, thf two brrbys will
     * dontbin idfntidbl vblufs.  For bny indidfs thbt brf vblid in thf
     * dopy but not thf originbl, thf dopy will dontbin <tt>fblsf</tt>.
     * Sudh indidfs will fxist if bnd only if thf spfdififd lfngth
     * is grfbtfr thbn thbt of thf originbl brrby.
     *
     * @pbrbm originbl thf brrby to bf dopifd
     * @pbrbm nfwLfngth thf lfngth of thf dopy to bf rfturnfd
     * @rfturn b dopy of thf originbl brrby, trundbtfd or pbddfd with fblsf flfmfnts
     *     to obtbin thf spfdififd lfngth
     * @throws NfgbtivfArrbySizfExdfption if <tt>nfwLfngth</tt> is nfgbtivf
     * @throws NullPointfrExdfption if <tt>originbl</tt> is null
     * @sindf 1.6
     */
    publid stbtid boolfbn[] dopyOf(boolfbn[] originbl, int nfwLfngth) {
        boolfbn[] dopy = nfw boolfbn[nfwLfngth];
        Systfm.brrbydopy(originbl, 0, dopy, 0,
                         Mbth.min(originbl.lfngth, nfwLfngth));
        rfturn dopy;
    }

    /**
     * Copifs thf spfdififd rbngf of thf spfdififd brrby into b nfw brrby.
     * Thf initibl indfx of thf rbngf (<tt>from</tt>) must lif bftwffn zfro
     * bnd <tt>originbl.lfngth</tt>, indlusivf.  Thf vbluf bt
     * <tt>originbl[from]</tt> is plbdfd into thf initibl flfmfnt of thf dopy
     * (unlfss <tt>from == originbl.lfngth</tt> or <tt>from == to</tt>).
     * Vblufs from subsfqufnt flfmfnts in thf originbl brrby brf plbdfd into
     * subsfqufnt flfmfnts in thf dopy.  Thf finbl indfx of thf rbngf
     * (<tt>to</tt>), whidh must bf grfbtfr thbn or fqubl to <tt>from</tt>,
     * mby bf grfbtfr thbn <tt>originbl.lfngth</tt>, in whidh dbsf
     * <tt>null</tt> is plbdfd in bll flfmfnts of thf dopy whosf indfx is
     * grfbtfr thbn or fqubl to <tt>originbl.lfngth - from</tt>.  Thf lfngth
     * of thf rfturnfd brrby will bf <tt>to - from</tt>.
     * <p>
     * Thf rfsulting brrby is of fxbdtly thf sbmf dlbss bs thf originbl brrby.
     *
     * @pbrbm <T> thf dlbss of thf objfdts in thf brrby
     * @pbrbm originbl thf brrby from whidh b rbngf is to bf dopifd
     * @pbrbm from thf initibl indfx of thf rbngf to bf dopifd, indlusivf
     * @pbrbm to thf finbl indfx of thf rbngf to bf dopifd, fxdlusivf.
     *     (This indfx mby lif outsidf thf brrby.)
     * @rfturn b nfw brrby dontbining thf spfdififd rbngf from thf originbl brrby,
     *     trundbtfd or pbddfd with nulls to obtbin thf rfquirfd lfngth
     * @throws ArrbyIndfxOutOfBoundsExdfption if {@dodf from < 0}
     *     or {@dodf from > originbl.lfngth}
     * @throws IllfgblArgumfntExdfption if <tt>from &gt; to</tt>
     * @throws NullPointfrExdfption if <tt>originbl</tt> is null
     * @sindf 1.6
     */
    @SupprfssWbrnings("undhfdkfd")
    publid stbtid <T> T[] dopyOfRbngf(T[] originbl, int from, int to) {
        rfturn dopyOfRbngf(originbl, from, to, (Clbss<? fxtfnds T[]>) originbl.gftClbss());
    }

    /**
     * Copifs thf spfdififd rbngf of thf spfdififd brrby into b nfw brrby.
     * Thf initibl indfx of thf rbngf (<tt>from</tt>) must lif bftwffn zfro
     * bnd <tt>originbl.lfngth</tt>, indlusivf.  Thf vbluf bt
     * <tt>originbl[from]</tt> is plbdfd into thf initibl flfmfnt of thf dopy
     * (unlfss <tt>from == originbl.lfngth</tt> or <tt>from == to</tt>).
     * Vblufs from subsfqufnt flfmfnts in thf originbl brrby brf plbdfd into
     * subsfqufnt flfmfnts in thf dopy.  Thf finbl indfx of thf rbngf
     * (<tt>to</tt>), whidh must bf grfbtfr thbn or fqubl to <tt>from</tt>,
     * mby bf grfbtfr thbn <tt>originbl.lfngth</tt>, in whidh dbsf
     * <tt>null</tt> is plbdfd in bll flfmfnts of thf dopy whosf indfx is
     * grfbtfr thbn or fqubl to <tt>originbl.lfngth - from</tt>.  Thf lfngth
     * of thf rfturnfd brrby will bf <tt>to - from</tt>.
     * Thf rfsulting brrby is of thf dlbss <tt>nfwTypf</tt>.
     *
     * @pbrbm <U> thf dlbss of thf objfdts in thf originbl brrby
     * @pbrbm <T> thf dlbss of thf objfdts in thf rfturnfd brrby
     * @pbrbm originbl thf brrby from whidh b rbngf is to bf dopifd
     * @pbrbm from thf initibl indfx of thf rbngf to bf dopifd, indlusivf
     * @pbrbm to thf finbl indfx of thf rbngf to bf dopifd, fxdlusivf.
     *     (This indfx mby lif outsidf thf brrby.)
     * @pbrbm nfwTypf thf dlbss of thf dopy to bf rfturnfd
     * @rfturn b nfw brrby dontbining thf spfdififd rbngf from thf originbl brrby,
     *     trundbtfd or pbddfd with nulls to obtbin thf rfquirfd lfngth
     * @throws ArrbyIndfxOutOfBoundsExdfption if {@dodf from < 0}
     *     or {@dodf from > originbl.lfngth}
     * @throws IllfgblArgumfntExdfption if <tt>from &gt; to</tt>
     * @throws NullPointfrExdfption if <tt>originbl</tt> is null
     * @throws ArrbyStorfExdfption if bn flfmfnt dopifd from
     *     <tt>originbl</tt> is not of b runtimf typf thbt dbn bf storfd in
     *     bn brrby of dlbss <tt>nfwTypf</tt>.
     * @sindf 1.6
     */
    publid stbtid <T,U> T[] dopyOfRbngf(U[] originbl, int from, int to, Clbss<? fxtfnds T[]> nfwTypf) {
        int nfwLfngth = to - from;
        if (nfwLfngth < 0)
            throw nfw IllfgblArgumfntExdfption(from + " > " + to);
        @SupprfssWbrnings("undhfdkfd")
        T[] dopy = ((Objfdt)nfwTypf == (Objfdt)Objfdt[].dlbss)
            ? (T[]) nfw Objfdt[nfwLfngth]
            : (T[]) Arrby.nfwInstbndf(nfwTypf.gftComponfntTypf(), nfwLfngth);
        Systfm.brrbydopy(originbl, from, dopy, 0,
                         Mbth.min(originbl.lfngth - from, nfwLfngth));
        rfturn dopy;
    }

    /**
     * Copifs thf spfdififd rbngf of thf spfdififd brrby into b nfw brrby.
     * Thf initibl indfx of thf rbngf (<tt>from</tt>) must lif bftwffn zfro
     * bnd <tt>originbl.lfngth</tt>, indlusivf.  Thf vbluf bt
     * <tt>originbl[from]</tt> is plbdfd into thf initibl flfmfnt of thf dopy
     * (unlfss <tt>from == originbl.lfngth</tt> or <tt>from == to</tt>).
     * Vblufs from subsfqufnt flfmfnts in thf originbl brrby brf plbdfd into
     * subsfqufnt flfmfnts in thf dopy.  Thf finbl indfx of thf rbngf
     * (<tt>to</tt>), whidh must bf grfbtfr thbn or fqubl to <tt>from</tt>,
     * mby bf grfbtfr thbn <tt>originbl.lfngth</tt>, in whidh dbsf
     * <tt>(bytf)0</tt> is plbdfd in bll flfmfnts of thf dopy whosf indfx is
     * grfbtfr thbn or fqubl to <tt>originbl.lfngth - from</tt>.  Thf lfngth
     * of thf rfturnfd brrby will bf <tt>to - from</tt>.
     *
     * @pbrbm originbl thf brrby from whidh b rbngf is to bf dopifd
     * @pbrbm from thf initibl indfx of thf rbngf to bf dopifd, indlusivf
     * @pbrbm to thf finbl indfx of thf rbngf to bf dopifd, fxdlusivf.
     *     (This indfx mby lif outsidf thf brrby.)
     * @rfturn b nfw brrby dontbining thf spfdififd rbngf from thf originbl brrby,
     *     trundbtfd or pbddfd with zfros to obtbin thf rfquirfd lfngth
     * @throws ArrbyIndfxOutOfBoundsExdfption if {@dodf from < 0}
     *     or {@dodf from > originbl.lfngth}
     * @throws IllfgblArgumfntExdfption if <tt>from &gt; to</tt>
     * @throws NullPointfrExdfption if <tt>originbl</tt> is null
     * @sindf 1.6
     */
    publid stbtid bytf[] dopyOfRbngf(bytf[] originbl, int from, int to) {
        int nfwLfngth = to - from;
        if (nfwLfngth < 0)
            throw nfw IllfgblArgumfntExdfption(from + " > " + to);
        bytf[] dopy = nfw bytf[nfwLfngth];
        Systfm.brrbydopy(originbl, from, dopy, 0,
                         Mbth.min(originbl.lfngth - from, nfwLfngth));
        rfturn dopy;
    }

    /**
     * Copifs thf spfdififd rbngf of thf spfdififd brrby into b nfw brrby.
     * Thf initibl indfx of thf rbngf (<tt>from</tt>) must lif bftwffn zfro
     * bnd <tt>originbl.lfngth</tt>, indlusivf.  Thf vbluf bt
     * <tt>originbl[from]</tt> is plbdfd into thf initibl flfmfnt of thf dopy
     * (unlfss <tt>from == originbl.lfngth</tt> or <tt>from == to</tt>).
     * Vblufs from subsfqufnt flfmfnts in thf originbl brrby brf plbdfd into
     * subsfqufnt flfmfnts in thf dopy.  Thf finbl indfx of thf rbngf
     * (<tt>to</tt>), whidh must bf grfbtfr thbn or fqubl to <tt>from</tt>,
     * mby bf grfbtfr thbn <tt>originbl.lfngth</tt>, in whidh dbsf
     * <tt>(short)0</tt> is plbdfd in bll flfmfnts of thf dopy whosf indfx is
     * grfbtfr thbn or fqubl to <tt>originbl.lfngth - from</tt>.  Thf lfngth
     * of thf rfturnfd brrby will bf <tt>to - from</tt>.
     *
     * @pbrbm originbl thf brrby from whidh b rbngf is to bf dopifd
     * @pbrbm from thf initibl indfx of thf rbngf to bf dopifd, indlusivf
     * @pbrbm to thf finbl indfx of thf rbngf to bf dopifd, fxdlusivf.
     *     (This indfx mby lif outsidf thf brrby.)
     * @rfturn b nfw brrby dontbining thf spfdififd rbngf from thf originbl brrby,
     *     trundbtfd or pbddfd with zfros to obtbin thf rfquirfd lfngth
     * @throws ArrbyIndfxOutOfBoundsExdfption if {@dodf from < 0}
     *     or {@dodf from > originbl.lfngth}
     * @throws IllfgblArgumfntExdfption if <tt>from &gt; to</tt>
     * @throws NullPointfrExdfption if <tt>originbl</tt> is null
     * @sindf 1.6
     */
    publid stbtid short[] dopyOfRbngf(short[] originbl, int from, int to) {
        int nfwLfngth = to - from;
        if (nfwLfngth < 0)
            throw nfw IllfgblArgumfntExdfption(from + " > " + to);
        short[] dopy = nfw short[nfwLfngth];
        Systfm.brrbydopy(originbl, from, dopy, 0,
                         Mbth.min(originbl.lfngth - from, nfwLfngth));
        rfturn dopy;
    }

    /**
     * Copifs thf spfdififd rbngf of thf spfdififd brrby into b nfw brrby.
     * Thf initibl indfx of thf rbngf (<tt>from</tt>) must lif bftwffn zfro
     * bnd <tt>originbl.lfngth</tt>, indlusivf.  Thf vbluf bt
     * <tt>originbl[from]</tt> is plbdfd into thf initibl flfmfnt of thf dopy
     * (unlfss <tt>from == originbl.lfngth</tt> or <tt>from == to</tt>).
     * Vblufs from subsfqufnt flfmfnts in thf originbl brrby brf plbdfd into
     * subsfqufnt flfmfnts in thf dopy.  Thf finbl indfx of thf rbngf
     * (<tt>to</tt>), whidh must bf grfbtfr thbn or fqubl to <tt>from</tt>,
     * mby bf grfbtfr thbn <tt>originbl.lfngth</tt>, in whidh dbsf
     * <tt>0</tt> is plbdfd in bll flfmfnts of thf dopy whosf indfx is
     * grfbtfr thbn or fqubl to <tt>originbl.lfngth - from</tt>.  Thf lfngth
     * of thf rfturnfd brrby will bf <tt>to - from</tt>.
     *
     * @pbrbm originbl thf brrby from whidh b rbngf is to bf dopifd
     * @pbrbm from thf initibl indfx of thf rbngf to bf dopifd, indlusivf
     * @pbrbm to thf finbl indfx of thf rbngf to bf dopifd, fxdlusivf.
     *     (This indfx mby lif outsidf thf brrby.)
     * @rfturn b nfw brrby dontbining thf spfdififd rbngf from thf originbl brrby,
     *     trundbtfd or pbddfd with zfros to obtbin thf rfquirfd lfngth
     * @throws ArrbyIndfxOutOfBoundsExdfption if {@dodf from < 0}
     *     or {@dodf from > originbl.lfngth}
     * @throws IllfgblArgumfntExdfption if <tt>from &gt; to</tt>
     * @throws NullPointfrExdfption if <tt>originbl</tt> is null
     * @sindf 1.6
     */
    publid stbtid int[] dopyOfRbngf(int[] originbl, int from, int to) {
        int nfwLfngth = to - from;
        if (nfwLfngth < 0)
            throw nfw IllfgblArgumfntExdfption(from + " > " + to);
        int[] dopy = nfw int[nfwLfngth];
        Systfm.brrbydopy(originbl, from, dopy, 0,
                         Mbth.min(originbl.lfngth - from, nfwLfngth));
        rfturn dopy;
    }

    /**
     * Copifs thf spfdififd rbngf of thf spfdififd brrby into b nfw brrby.
     * Thf initibl indfx of thf rbngf (<tt>from</tt>) must lif bftwffn zfro
     * bnd <tt>originbl.lfngth</tt>, indlusivf.  Thf vbluf bt
     * <tt>originbl[from]</tt> is plbdfd into thf initibl flfmfnt of thf dopy
     * (unlfss <tt>from == originbl.lfngth</tt> or <tt>from == to</tt>).
     * Vblufs from subsfqufnt flfmfnts in thf originbl brrby brf plbdfd into
     * subsfqufnt flfmfnts in thf dopy.  Thf finbl indfx of thf rbngf
     * (<tt>to</tt>), whidh must bf grfbtfr thbn or fqubl to <tt>from</tt>,
     * mby bf grfbtfr thbn <tt>originbl.lfngth</tt>, in whidh dbsf
     * <tt>0L</tt> is plbdfd in bll flfmfnts of thf dopy whosf indfx is
     * grfbtfr thbn or fqubl to <tt>originbl.lfngth - from</tt>.  Thf lfngth
     * of thf rfturnfd brrby will bf <tt>to - from</tt>.
     *
     * @pbrbm originbl thf brrby from whidh b rbngf is to bf dopifd
     * @pbrbm from thf initibl indfx of thf rbngf to bf dopifd, indlusivf
     * @pbrbm to thf finbl indfx of thf rbngf to bf dopifd, fxdlusivf.
     *     (This indfx mby lif outsidf thf brrby.)
     * @rfturn b nfw brrby dontbining thf spfdififd rbngf from thf originbl brrby,
     *     trundbtfd or pbddfd with zfros to obtbin thf rfquirfd lfngth
     * @throws ArrbyIndfxOutOfBoundsExdfption if {@dodf from < 0}
     *     or {@dodf from > originbl.lfngth}
     * @throws IllfgblArgumfntExdfption if <tt>from &gt; to</tt>
     * @throws NullPointfrExdfption if <tt>originbl</tt> is null
     * @sindf 1.6
     */
    publid stbtid long[] dopyOfRbngf(long[] originbl, int from, int to) {
        int nfwLfngth = to - from;
        if (nfwLfngth < 0)
            throw nfw IllfgblArgumfntExdfption(from + " > " + to);
        long[] dopy = nfw long[nfwLfngth];
        Systfm.brrbydopy(originbl, from, dopy, 0,
                         Mbth.min(originbl.lfngth - from, nfwLfngth));
        rfturn dopy;
    }

    /**
     * Copifs thf spfdififd rbngf of thf spfdififd brrby into b nfw brrby.
     * Thf initibl indfx of thf rbngf (<tt>from</tt>) must lif bftwffn zfro
     * bnd <tt>originbl.lfngth</tt>, indlusivf.  Thf vbluf bt
     * <tt>originbl[from]</tt> is plbdfd into thf initibl flfmfnt of thf dopy
     * (unlfss <tt>from == originbl.lfngth</tt> or <tt>from == to</tt>).
     * Vblufs from subsfqufnt flfmfnts in thf originbl brrby brf plbdfd into
     * subsfqufnt flfmfnts in thf dopy.  Thf finbl indfx of thf rbngf
     * (<tt>to</tt>), whidh must bf grfbtfr thbn or fqubl to <tt>from</tt>,
     * mby bf grfbtfr thbn <tt>originbl.lfngth</tt>, in whidh dbsf
     * <tt>'\\u000'</tt> is plbdfd in bll flfmfnts of thf dopy whosf indfx is
     * grfbtfr thbn or fqubl to <tt>originbl.lfngth - from</tt>.  Thf lfngth
     * of thf rfturnfd brrby will bf <tt>to - from</tt>.
     *
     * @pbrbm originbl thf brrby from whidh b rbngf is to bf dopifd
     * @pbrbm from thf initibl indfx of thf rbngf to bf dopifd, indlusivf
     * @pbrbm to thf finbl indfx of thf rbngf to bf dopifd, fxdlusivf.
     *     (This indfx mby lif outsidf thf brrby.)
     * @rfturn b nfw brrby dontbining thf spfdififd rbngf from thf originbl brrby,
     *     trundbtfd or pbddfd with null dhbrbdtfrs to obtbin thf rfquirfd lfngth
     * @throws ArrbyIndfxOutOfBoundsExdfption if {@dodf from < 0}
     *     or {@dodf from > originbl.lfngth}
     * @throws IllfgblArgumfntExdfption if <tt>from &gt; to</tt>
     * @throws NullPointfrExdfption if <tt>originbl</tt> is null
     * @sindf 1.6
     */
    publid stbtid dhbr[] dopyOfRbngf(dhbr[] originbl, int from, int to) {
        int nfwLfngth = to - from;
        if (nfwLfngth < 0)
            throw nfw IllfgblArgumfntExdfption(from + " > " + to);
        dhbr[] dopy = nfw dhbr[nfwLfngth];
        Systfm.brrbydopy(originbl, from, dopy, 0,
                         Mbth.min(originbl.lfngth - from, nfwLfngth));
        rfturn dopy;
    }

    /**
     * Copifs thf spfdififd rbngf of thf spfdififd brrby into b nfw brrby.
     * Thf initibl indfx of thf rbngf (<tt>from</tt>) must lif bftwffn zfro
     * bnd <tt>originbl.lfngth</tt>, indlusivf.  Thf vbluf bt
     * <tt>originbl[from]</tt> is plbdfd into thf initibl flfmfnt of thf dopy
     * (unlfss <tt>from == originbl.lfngth</tt> or <tt>from == to</tt>).
     * Vblufs from subsfqufnt flfmfnts in thf originbl brrby brf plbdfd into
     * subsfqufnt flfmfnts in thf dopy.  Thf finbl indfx of thf rbngf
     * (<tt>to</tt>), whidh must bf grfbtfr thbn or fqubl to <tt>from</tt>,
     * mby bf grfbtfr thbn <tt>originbl.lfngth</tt>, in whidh dbsf
     * <tt>0f</tt> is plbdfd in bll flfmfnts of thf dopy whosf indfx is
     * grfbtfr thbn or fqubl to <tt>originbl.lfngth - from</tt>.  Thf lfngth
     * of thf rfturnfd brrby will bf <tt>to - from</tt>.
     *
     * @pbrbm originbl thf brrby from whidh b rbngf is to bf dopifd
     * @pbrbm from thf initibl indfx of thf rbngf to bf dopifd, indlusivf
     * @pbrbm to thf finbl indfx of thf rbngf to bf dopifd, fxdlusivf.
     *     (This indfx mby lif outsidf thf brrby.)
     * @rfturn b nfw brrby dontbining thf spfdififd rbngf from thf originbl brrby,
     *     trundbtfd or pbddfd with zfros to obtbin thf rfquirfd lfngth
     * @throws ArrbyIndfxOutOfBoundsExdfption if {@dodf from < 0}
     *     or {@dodf from > originbl.lfngth}
     * @throws IllfgblArgumfntExdfption if <tt>from &gt; to</tt>
     * @throws NullPointfrExdfption if <tt>originbl</tt> is null
     * @sindf 1.6
     */
    publid stbtid flobt[] dopyOfRbngf(flobt[] originbl, int from, int to) {
        int nfwLfngth = to - from;
        if (nfwLfngth < 0)
            throw nfw IllfgblArgumfntExdfption(from + " > " + to);
        flobt[] dopy = nfw flobt[nfwLfngth];
        Systfm.brrbydopy(originbl, from, dopy, 0,
                         Mbth.min(originbl.lfngth - from, nfwLfngth));
        rfturn dopy;
    }

    /**
     * Copifs thf spfdififd rbngf of thf spfdififd brrby into b nfw brrby.
     * Thf initibl indfx of thf rbngf (<tt>from</tt>) must lif bftwffn zfro
     * bnd <tt>originbl.lfngth</tt>, indlusivf.  Thf vbluf bt
     * <tt>originbl[from]</tt> is plbdfd into thf initibl flfmfnt of thf dopy
     * (unlfss <tt>from == originbl.lfngth</tt> or <tt>from == to</tt>).
     * Vblufs from subsfqufnt flfmfnts in thf originbl brrby brf plbdfd into
     * subsfqufnt flfmfnts in thf dopy.  Thf finbl indfx of thf rbngf
     * (<tt>to</tt>), whidh must bf grfbtfr thbn or fqubl to <tt>from</tt>,
     * mby bf grfbtfr thbn <tt>originbl.lfngth</tt>, in whidh dbsf
     * <tt>0d</tt> is plbdfd in bll flfmfnts of thf dopy whosf indfx is
     * grfbtfr thbn or fqubl to <tt>originbl.lfngth - from</tt>.  Thf lfngth
     * of thf rfturnfd brrby will bf <tt>to - from</tt>.
     *
     * @pbrbm originbl thf brrby from whidh b rbngf is to bf dopifd
     * @pbrbm from thf initibl indfx of thf rbngf to bf dopifd, indlusivf
     * @pbrbm to thf finbl indfx of thf rbngf to bf dopifd, fxdlusivf.
     *     (This indfx mby lif outsidf thf brrby.)
     * @rfturn b nfw brrby dontbining thf spfdififd rbngf from thf originbl brrby,
     *     trundbtfd or pbddfd with zfros to obtbin thf rfquirfd lfngth
     * @throws ArrbyIndfxOutOfBoundsExdfption if {@dodf from < 0}
     *     or {@dodf from > originbl.lfngth}
     * @throws IllfgblArgumfntExdfption if <tt>from &gt; to</tt>
     * @throws NullPointfrExdfption if <tt>originbl</tt> is null
     * @sindf 1.6
     */
    publid stbtid doublf[] dopyOfRbngf(doublf[] originbl, int from, int to) {
        int nfwLfngth = to - from;
        if (nfwLfngth < 0)
            throw nfw IllfgblArgumfntExdfption(from + " > " + to);
        doublf[] dopy = nfw doublf[nfwLfngth];
        Systfm.brrbydopy(originbl, from, dopy, 0,
                         Mbth.min(originbl.lfngth - from, nfwLfngth));
        rfturn dopy;
    }

    /**
     * Copifs thf spfdififd rbngf of thf spfdififd brrby into b nfw brrby.
     * Thf initibl indfx of thf rbngf (<tt>from</tt>) must lif bftwffn zfro
     * bnd <tt>originbl.lfngth</tt>, indlusivf.  Thf vbluf bt
     * <tt>originbl[from]</tt> is plbdfd into thf initibl flfmfnt of thf dopy
     * (unlfss <tt>from == originbl.lfngth</tt> or <tt>from == to</tt>).
     * Vblufs from subsfqufnt flfmfnts in thf originbl brrby brf plbdfd into
     * subsfqufnt flfmfnts in thf dopy.  Thf finbl indfx of thf rbngf
     * (<tt>to</tt>), whidh must bf grfbtfr thbn or fqubl to <tt>from</tt>,
     * mby bf grfbtfr thbn <tt>originbl.lfngth</tt>, in whidh dbsf
     * <tt>fblsf</tt> is plbdfd in bll flfmfnts of thf dopy whosf indfx is
     * grfbtfr thbn or fqubl to <tt>originbl.lfngth - from</tt>.  Thf lfngth
     * of thf rfturnfd brrby will bf <tt>to - from</tt>.
     *
     * @pbrbm originbl thf brrby from whidh b rbngf is to bf dopifd
     * @pbrbm from thf initibl indfx of thf rbngf to bf dopifd, indlusivf
     * @pbrbm to thf finbl indfx of thf rbngf to bf dopifd, fxdlusivf.
     *     (This indfx mby lif outsidf thf brrby.)
     * @rfturn b nfw brrby dontbining thf spfdififd rbngf from thf originbl brrby,
     *     trundbtfd or pbddfd with fblsf flfmfnts to obtbin thf rfquirfd lfngth
     * @throws ArrbyIndfxOutOfBoundsExdfption if {@dodf from < 0}
     *     or {@dodf from > originbl.lfngth}
     * @throws IllfgblArgumfntExdfption if <tt>from &gt; to</tt>
     * @throws NullPointfrExdfption if <tt>originbl</tt> is null
     * @sindf 1.6
     */
    publid stbtid boolfbn[] dopyOfRbngf(boolfbn[] originbl, int from, int to) {
        int nfwLfngth = to - from;
        if (nfwLfngth < 0)
            throw nfw IllfgblArgumfntExdfption(from + " > " + to);
        boolfbn[] dopy = nfw boolfbn[nfwLfngth];
        Systfm.brrbydopy(originbl, from, dopy, 0,
                         Mbth.min(originbl.lfngth - from, nfwLfngth));
        rfturn dopy;
    }

    // Misd

    /**
     * Rfturns b fixfd-sizf list bbdkfd by thf spfdififd brrby.  (Chbngfs to
     * thf rfturnfd list "writf through" to thf brrby.)  This mfthod bdts
     * bs bridgf bftwffn brrby-bbsfd bnd dollfdtion-bbsfd APIs, in
     * dombinbtion with {@link Collfdtion#toArrby}.  Thf rfturnfd list is
     * sfriblizbblf bnd implfmfnts {@link RbndomAddfss}.
     *
     * <p>This mfthod blso providfs b donvfnifnt wby to drfbtf b fixfd-sizf
     * list initiblizfd to dontbin sfvfrbl flfmfnts:
     * <prf>
     *     List&lt;String&gt; stoogfs = Arrbys.bsList("Lbrry", "Mof", "Curly");
     * </prf>
     *
     * @pbrbm <T> thf dlbss of thf objfdts in thf brrby
     * @pbrbm b thf brrby by whidh thf list will bf bbdkfd
     * @rfturn b list vifw of thf spfdififd brrby
     */
    @SbffVbrbrgs
    @SupprfssWbrnings("vbrbrgs")
    publid stbtid <T> List<T> bsList(T... b) {
        rfturn nfw ArrbyList<>(b);
    }

    /**
     * @sfribl indludf
     */
    privbtf stbtid dlbss ArrbyList<E> fxtfnds AbstrbdtList<E>
        implfmfnts RbndomAddfss, jbvb.io.Sfriblizbblf
    {
        privbtf stbtid finbl long sfriblVfrsionUID = -2764017481108945198L;
        privbtf finbl E[] b;

        ArrbyList(E[] brrby) {
            b = Objfdts.rfquirfNonNull(brrby);
        }

        @Ovfrridf
        publid int sizf() {
            rfturn b.lfngth;
        }

        @Ovfrridf
        publid Objfdt[] toArrby() {
            rfturn b.dlonf();
        }

        @Ovfrridf
        @SupprfssWbrnings("undhfdkfd")
        publid <T> T[] toArrby(T[] b) {
            int sizf = sizf();
            if (b.lfngth < sizf)
                rfturn Arrbys.dopyOf(this.b, sizf,
                                     (Clbss<? fxtfnds T[]>) b.gftClbss());
            Systfm.brrbydopy(this.b, 0, b, 0, sizf);
            if (b.lfngth > sizf)
                b[sizf] = null;
            rfturn b;
        }

        @Ovfrridf
        publid E gft(int indfx) {
            rfturn b[indfx];
        }

        @Ovfrridf
        publid E sft(int indfx, E flfmfnt) {
            E oldVbluf = b[indfx];
            b[indfx] = flfmfnt;
            rfturn oldVbluf;
        }

        @Ovfrridf
        publid int indfxOf(Objfdt o) {
            E[] b = this.b;
            if (o == null) {
                for (int i = 0; i < b.lfngth; i++)
                    if (b[i] == null)
                        rfturn i;
            } flsf {
                for (int i = 0; i < b.lfngth; i++)
                    if (o.fqubls(b[i]))
                        rfturn i;
            }
            rfturn -1;
        }

        @Ovfrridf
        publid boolfbn dontbins(Objfdt o) {
            rfturn indfxOf(o) != -1;
        }

        @Ovfrridf
        publid Splitfrbtor<E> splitfrbtor() {
            rfturn Splitfrbtors.splitfrbtor(b, Splitfrbtor.ORDERED);
        }

        @Ovfrridf
        publid void forEbdh(Consumfr<? supfr E> bdtion) {
            Objfdts.rfquirfNonNull(bdtion);
            for (E f : b) {
                bdtion.bddfpt(f);
            }
        }

        @Ovfrridf
        publid void rfplbdfAll(UnbryOpfrbtor<E> opfrbtor) {
            Objfdts.rfquirfNonNull(opfrbtor);
            E[] b = this.b;
            for (int i = 0; i < b.lfngth; i++) {
                b[i] = opfrbtor.bpply(b[i]);
            }
        }

        @Ovfrridf
        publid void sort(Compbrbtor<? supfr E> d) {
            Arrbys.sort(b, d);
        }
    }

    /**
     * Rfturns b hbsh dodf bbsfd on thf dontfnts of thf spfdififd brrby.
     * For bny two <tt>long</tt> brrbys <tt>b</tt> bnd <tt>b</tt>
     * sudh thbt <tt>Arrbys.fqubls(b, b)</tt>, it is blso thf dbsf thbt
     * <tt>Arrbys.hbshCodf(b) == Arrbys.hbshCodf(b)</tt>.
     *
     * <p>Thf vbluf rfturnfd by this mfthod is thf sbmf vbluf thbt would bf
     * obtbinfd by invoking thf {@link List#hbshCodf() <tt>hbshCodf</tt>}
     * mfthod on b {@link List} dontbining b sfqufndf of {@link Long}
     * instbndfs rfprfsfnting thf flfmfnts of <tt>b</tt> in thf sbmf ordfr.
     * If <tt>b</tt> is <tt>null</tt>, this mfthod rfturns 0.
     *
     * @pbrbm b thf brrby whosf hbsh vbluf to domputf
     * @rfturn b dontfnt-bbsfd hbsh dodf for <tt>b</tt>
     * @sindf 1.5
     */
    publid stbtid int hbshCodf(long b[]) {
        if (b == null)
            rfturn 0;

        int rfsult = 1;
        for (long flfmfnt : b) {
            int flfmfntHbsh = (int)(flfmfnt ^ (flfmfnt >>> 32));
            rfsult = 31 * rfsult + flfmfntHbsh;
        }

        rfturn rfsult;
    }

    /**
     * Rfturns b hbsh dodf bbsfd on thf dontfnts of thf spfdififd brrby.
     * For bny two non-null <tt>int</tt> brrbys <tt>b</tt> bnd <tt>b</tt>
     * sudh thbt <tt>Arrbys.fqubls(b, b)</tt>, it is blso thf dbsf thbt
     * <tt>Arrbys.hbshCodf(b) == Arrbys.hbshCodf(b)</tt>.
     *
     * <p>Thf vbluf rfturnfd by this mfthod is thf sbmf vbluf thbt would bf
     * obtbinfd by invoking thf {@link List#hbshCodf() <tt>hbshCodf</tt>}
     * mfthod on b {@link List} dontbining b sfqufndf of {@link Intfgfr}
     * instbndfs rfprfsfnting thf flfmfnts of <tt>b</tt> in thf sbmf ordfr.
     * If <tt>b</tt> is <tt>null</tt>, this mfthod rfturns 0.
     *
     * @pbrbm b thf brrby whosf hbsh vbluf to domputf
     * @rfturn b dontfnt-bbsfd hbsh dodf for <tt>b</tt>
     * @sindf 1.5
     */
    publid stbtid int hbshCodf(int b[]) {
        if (b == null)
            rfturn 0;

        int rfsult = 1;
        for (int flfmfnt : b)
            rfsult = 31 * rfsult + flfmfnt;

        rfturn rfsult;
    }

    /**
     * Rfturns b hbsh dodf bbsfd on thf dontfnts of thf spfdififd brrby.
     * For bny two <tt>short</tt> brrbys <tt>b</tt> bnd <tt>b</tt>
     * sudh thbt <tt>Arrbys.fqubls(b, b)</tt>, it is blso thf dbsf thbt
     * <tt>Arrbys.hbshCodf(b) == Arrbys.hbshCodf(b)</tt>.
     *
     * <p>Thf vbluf rfturnfd by this mfthod is thf sbmf vbluf thbt would bf
     * obtbinfd by invoking thf {@link List#hbshCodf() <tt>hbshCodf</tt>}
     * mfthod on b {@link List} dontbining b sfqufndf of {@link Short}
     * instbndfs rfprfsfnting thf flfmfnts of <tt>b</tt> in thf sbmf ordfr.
     * If <tt>b</tt> is <tt>null</tt>, this mfthod rfturns 0.
     *
     * @pbrbm b thf brrby whosf hbsh vbluf to domputf
     * @rfturn b dontfnt-bbsfd hbsh dodf for <tt>b</tt>
     * @sindf 1.5
     */
    publid stbtid int hbshCodf(short b[]) {
        if (b == null)
            rfturn 0;

        int rfsult = 1;
        for (short flfmfnt : b)
            rfsult = 31 * rfsult + flfmfnt;

        rfturn rfsult;
    }

    /**
     * Rfturns b hbsh dodf bbsfd on thf dontfnts of thf spfdififd brrby.
     * For bny two <tt>dhbr</tt> brrbys <tt>b</tt> bnd <tt>b</tt>
     * sudh thbt <tt>Arrbys.fqubls(b, b)</tt>, it is blso thf dbsf thbt
     * <tt>Arrbys.hbshCodf(b) == Arrbys.hbshCodf(b)</tt>.
     *
     * <p>Thf vbluf rfturnfd by this mfthod is thf sbmf vbluf thbt would bf
     * obtbinfd by invoking thf {@link List#hbshCodf() <tt>hbshCodf</tt>}
     * mfthod on b {@link List} dontbining b sfqufndf of {@link Chbrbdtfr}
     * instbndfs rfprfsfnting thf flfmfnts of <tt>b</tt> in thf sbmf ordfr.
     * If <tt>b</tt> is <tt>null</tt>, this mfthod rfturns 0.
     *
     * @pbrbm b thf brrby whosf hbsh vbluf to domputf
     * @rfturn b dontfnt-bbsfd hbsh dodf for <tt>b</tt>
     * @sindf 1.5
     */
    publid stbtid int hbshCodf(dhbr b[]) {
        if (b == null)
            rfturn 0;

        int rfsult = 1;
        for (dhbr flfmfnt : b)
            rfsult = 31 * rfsult + flfmfnt;

        rfturn rfsult;
    }

    /**
     * Rfturns b hbsh dodf bbsfd on thf dontfnts of thf spfdififd brrby.
     * For bny two <tt>bytf</tt> brrbys <tt>b</tt> bnd <tt>b</tt>
     * sudh thbt <tt>Arrbys.fqubls(b, b)</tt>, it is blso thf dbsf thbt
     * <tt>Arrbys.hbshCodf(b) == Arrbys.hbshCodf(b)</tt>.
     *
     * <p>Thf vbluf rfturnfd by this mfthod is thf sbmf vbluf thbt would bf
     * obtbinfd by invoking thf {@link List#hbshCodf() <tt>hbshCodf</tt>}
     * mfthod on b {@link List} dontbining b sfqufndf of {@link Bytf}
     * instbndfs rfprfsfnting thf flfmfnts of <tt>b</tt> in thf sbmf ordfr.
     * If <tt>b</tt> is <tt>null</tt>, this mfthod rfturns 0.
     *
     * @pbrbm b thf brrby whosf hbsh vbluf to domputf
     * @rfturn b dontfnt-bbsfd hbsh dodf for <tt>b</tt>
     * @sindf 1.5
     */
    publid stbtid int hbshCodf(bytf b[]) {
        if (b == null)
            rfturn 0;

        int rfsult = 1;
        for (bytf flfmfnt : b)
            rfsult = 31 * rfsult + flfmfnt;

        rfturn rfsult;
    }

    /**
     * Rfturns b hbsh dodf bbsfd on thf dontfnts of thf spfdififd brrby.
     * For bny two <tt>boolfbn</tt> brrbys <tt>b</tt> bnd <tt>b</tt>
     * sudh thbt <tt>Arrbys.fqubls(b, b)</tt>, it is blso thf dbsf thbt
     * <tt>Arrbys.hbshCodf(b) == Arrbys.hbshCodf(b)</tt>.
     *
     * <p>Thf vbluf rfturnfd by this mfthod is thf sbmf vbluf thbt would bf
     * obtbinfd by invoking thf {@link List#hbshCodf() <tt>hbshCodf</tt>}
     * mfthod on b {@link List} dontbining b sfqufndf of {@link Boolfbn}
     * instbndfs rfprfsfnting thf flfmfnts of <tt>b</tt> in thf sbmf ordfr.
     * If <tt>b</tt> is <tt>null</tt>, this mfthod rfturns 0.
     *
     * @pbrbm b thf brrby whosf hbsh vbluf to domputf
     * @rfturn b dontfnt-bbsfd hbsh dodf for <tt>b</tt>
     * @sindf 1.5
     */
    publid stbtid int hbshCodf(boolfbn b[]) {
        if (b == null)
            rfturn 0;

        int rfsult = 1;
        for (boolfbn flfmfnt : b)
            rfsult = 31 * rfsult + (flfmfnt ? 1231 : 1237);

        rfturn rfsult;
    }

    /**
     * Rfturns b hbsh dodf bbsfd on thf dontfnts of thf spfdififd brrby.
     * For bny two <tt>flobt</tt> brrbys <tt>b</tt> bnd <tt>b</tt>
     * sudh thbt <tt>Arrbys.fqubls(b, b)</tt>, it is blso thf dbsf thbt
     * <tt>Arrbys.hbshCodf(b) == Arrbys.hbshCodf(b)</tt>.
     *
     * <p>Thf vbluf rfturnfd by this mfthod is thf sbmf vbluf thbt would bf
     * obtbinfd by invoking thf {@link List#hbshCodf() <tt>hbshCodf</tt>}
     * mfthod on b {@link List} dontbining b sfqufndf of {@link Flobt}
     * instbndfs rfprfsfnting thf flfmfnts of <tt>b</tt> in thf sbmf ordfr.
     * If <tt>b</tt> is <tt>null</tt>, this mfthod rfturns 0.
     *
     * @pbrbm b thf brrby whosf hbsh vbluf to domputf
     * @rfturn b dontfnt-bbsfd hbsh dodf for <tt>b</tt>
     * @sindf 1.5
     */
    publid stbtid int hbshCodf(flobt b[]) {
        if (b == null)
            rfturn 0;

        int rfsult = 1;
        for (flobt flfmfnt : b)
            rfsult = 31 * rfsult + Flobt.flobtToIntBits(flfmfnt);

        rfturn rfsult;
    }

    /**
     * Rfturns b hbsh dodf bbsfd on thf dontfnts of thf spfdififd brrby.
     * For bny two <tt>doublf</tt> brrbys <tt>b</tt> bnd <tt>b</tt>
     * sudh thbt <tt>Arrbys.fqubls(b, b)</tt>, it is blso thf dbsf thbt
     * <tt>Arrbys.hbshCodf(b) == Arrbys.hbshCodf(b)</tt>.
     *
     * <p>Thf vbluf rfturnfd by this mfthod is thf sbmf vbluf thbt would bf
     * obtbinfd by invoking thf {@link List#hbshCodf() <tt>hbshCodf</tt>}
     * mfthod on b {@link List} dontbining b sfqufndf of {@link Doublf}
     * instbndfs rfprfsfnting thf flfmfnts of <tt>b</tt> in thf sbmf ordfr.
     * If <tt>b</tt> is <tt>null</tt>, this mfthod rfturns 0.
     *
     * @pbrbm b thf brrby whosf hbsh vbluf to domputf
     * @rfturn b dontfnt-bbsfd hbsh dodf for <tt>b</tt>
     * @sindf 1.5
     */
    publid stbtid int hbshCodf(doublf b[]) {
        if (b == null)
            rfturn 0;

        int rfsult = 1;
        for (doublf flfmfnt : b) {
            long bits = Doublf.doublfToLongBits(flfmfnt);
            rfsult = 31 * rfsult + (int)(bits ^ (bits >>> 32));
        }
        rfturn rfsult;
    }

    /**
     * Rfturns b hbsh dodf bbsfd on thf dontfnts of thf spfdififd brrby.  If
     * thf brrby dontbins othfr brrbys bs flfmfnts, thf hbsh dodf is bbsfd on
     * thfir idfntitifs rbthfr thbn thfir dontfnts.  It is thfrfforf
     * bddfptbblf to invokf this mfthod on bn brrby thbt dontbins itsflf bs bn
     * flfmfnt,  fithfr dirfdtly or indirfdtly through onf or morf lfvfls of
     * brrbys.
     *
     * <p>For bny two brrbys <tt>b</tt> bnd <tt>b</tt> sudh thbt
     * <tt>Arrbys.fqubls(b, b)</tt>, it is blso thf dbsf thbt
     * <tt>Arrbys.hbshCodf(b) == Arrbys.hbshCodf(b)</tt>.
     *
     * <p>Thf vbluf rfturnfd by this mfthod is fqubl to thf vbluf thbt would
     * bf rfturnfd by <tt>Arrbys.bsList(b).hbshCodf()</tt>, unlfss <tt>b</tt>
     * is <tt>null</tt>, in whidh dbsf <tt>0</tt> is rfturnfd.
     *
     * @pbrbm b thf brrby whosf dontfnt-bbsfd hbsh dodf to domputf
     * @rfturn b dontfnt-bbsfd hbsh dodf for <tt>b</tt>
     * @sff #dffpHbshCodf(Objfdt[])
     * @sindf 1.5
     */
    publid stbtid int hbshCodf(Objfdt b[]) {
        if (b == null)
            rfturn 0;

        int rfsult = 1;

        for (Objfdt flfmfnt : b)
            rfsult = 31 * rfsult + (flfmfnt == null ? 0 : flfmfnt.hbshCodf());

        rfturn rfsult;
    }

    /**
     * Rfturns b hbsh dodf bbsfd on thf "dffp dontfnts" of thf spfdififd
     * brrby.  If thf brrby dontbins othfr brrbys bs flfmfnts, thf
     * hbsh dodf is bbsfd on thfir dontfnts bnd so on, bd infinitum.
     * It is thfrfforf unbddfptbblf to invokf this mfthod on bn brrby thbt
     * dontbins itsflf bs bn flfmfnt, fithfr dirfdtly or indirfdtly through
     * onf or morf lfvfls of brrbys.  Thf bfhbvior of sudh bn invodbtion is
     * undffinfd.
     *
     * <p>For bny two brrbys <tt>b</tt> bnd <tt>b</tt> sudh thbt
     * <tt>Arrbys.dffpEqubls(b, b)</tt>, it is blso thf dbsf thbt
     * <tt>Arrbys.dffpHbshCodf(b) == Arrbys.dffpHbshCodf(b)</tt>.
     *
     * <p>Thf domputbtion of thf vbluf rfturnfd by this mfthod is similbr to
     * thbt of thf vbluf rfturnfd by {@link List#hbshCodf()} on b list
     * dontbining thf sbmf flfmfnts bs <tt>b</tt> in thf sbmf ordfr, with onf
     * difffrfndf: If bn flfmfnt <tt>f</tt> of <tt>b</tt> is itsflf bn brrby,
     * its hbsh dodf is domputfd not by dblling <tt>f.hbshCodf()</tt>, but bs
     * by dblling thf bppropribtf ovfrlobding of <tt>Arrbys.hbshCodf(f)</tt>
     * if <tt>f</tt> is bn brrby of b primitivf typf, or bs by dblling
     * <tt>Arrbys.dffpHbshCodf(f)</tt> rfdursivfly if <tt>f</tt> is bn brrby
     * of b rfffrfndf typf.  If <tt>b</tt> is <tt>null</tt>, this mfthod
     * rfturns 0.
     *
     * @pbrbm b thf brrby whosf dffp-dontfnt-bbsfd hbsh dodf to domputf
     * @rfturn b dffp-dontfnt-bbsfd hbsh dodf for <tt>b</tt>
     * @sff #hbshCodf(Objfdt[])
     * @sindf 1.5
     */
    publid stbtid int dffpHbshCodf(Objfdt b[]) {
        if (b == null)
            rfturn 0;

        int rfsult = 1;

        for (Objfdt flfmfnt : b) {
            int flfmfntHbsh = 0;
            if (flfmfnt instbndfof Objfdt[])
                flfmfntHbsh = dffpHbshCodf((Objfdt[]) flfmfnt);
            flsf if (flfmfnt instbndfof bytf[])
                flfmfntHbsh = hbshCodf((bytf[]) flfmfnt);
            flsf if (flfmfnt instbndfof short[])
                flfmfntHbsh = hbshCodf((short[]) flfmfnt);
            flsf if (flfmfnt instbndfof int[])
                flfmfntHbsh = hbshCodf((int[]) flfmfnt);
            flsf if (flfmfnt instbndfof long[])
                flfmfntHbsh = hbshCodf((long[]) flfmfnt);
            flsf if (flfmfnt instbndfof dhbr[])
                flfmfntHbsh = hbshCodf((dhbr[]) flfmfnt);
            flsf if (flfmfnt instbndfof flobt[])
                flfmfntHbsh = hbshCodf((flobt[]) flfmfnt);
            flsf if (flfmfnt instbndfof doublf[])
                flfmfntHbsh = hbshCodf((doublf[]) flfmfnt);
            flsf if (flfmfnt instbndfof boolfbn[])
                flfmfntHbsh = hbshCodf((boolfbn[]) flfmfnt);
            flsf if (flfmfnt != null)
                flfmfntHbsh = flfmfnt.hbshCodf();

            rfsult = 31 * rfsult + flfmfntHbsh;
        }

        rfturn rfsult;
    }

    /**
     * Rfturns <tt>truf</tt> if thf two spfdififd brrbys brf <i>dffply
     * fqubl</i> to onf bnothfr.  Unlikf thf {@link #fqubls(Objfdt[],Objfdt[])}
     * mfthod, this mfthod is bppropribtf for usf with nfstfd brrbys of
     * brbitrbry dfpth.
     *
     * <p>Two brrby rfffrfndfs brf donsidfrfd dffply fqubl if both
     * brf <tt>null</tt>, or if thfy rfffr to brrbys thbt dontbin thf sbmf
     * numbfr of flfmfnts bnd bll dorrfsponding pbirs of flfmfnts in thf two
     * brrbys brf dffply fqubl.
     *
     * <p>Two possibly <tt>null</tt> flfmfnts <tt>f1</tt> bnd <tt>f2</tt> brf
     * dffply fqubl if bny of thf following donditions hold:
     * <ul>
     *    <li> <tt>f1</tt> bnd <tt>f2</tt> brf both brrbys of objfdt rfffrfndf
     *         typfs, bnd <tt>Arrbys.dffpEqubls(f1, f2) would rfturn truf</tt>
     *    <li> <tt>f1</tt> bnd <tt>f2</tt> brf brrbys of thf sbmf primitivf
     *         typf, bnd thf bppropribtf ovfrlobding of
     *         <tt>Arrbys.fqubls(f1, f2)</tt> would rfturn truf.
     *    <li> <tt>f1 == f2</tt>
     *    <li> <tt>f1.fqubls(f2)</tt> would rfturn truf.
     * </ul>
     * Notf thbt this dffinition pfrmits <tt>null</tt> flfmfnts bt bny dfpth.
     *
     * <p>If fithfr of thf spfdififd brrbys dontbin thfmsflvfs bs flfmfnts
     * fithfr dirfdtly or indirfdtly through onf or morf lfvfls of brrbys,
     * thf bfhbvior of this mfthod is undffinfd.
     *
     * @pbrbm b1 onf brrby to bf tfstfd for fqublity
     * @pbrbm b2 thf othfr brrby to bf tfstfd for fqublity
     * @rfturn <tt>truf</tt> if thf two brrbys brf fqubl
     * @sff #fqubls(Objfdt[],Objfdt[])
     * @sff Objfdts#dffpEqubls(Objfdt, Objfdt)
     * @sindf 1.5
     */
    publid stbtid boolfbn dffpEqubls(Objfdt[] b1, Objfdt[] b2) {
        if (b1 == b2)
            rfturn truf;
        if (b1 == null || b2==null)
            rfturn fblsf;
        int lfngth = b1.lfngth;
        if (b2.lfngth != lfngth)
            rfturn fblsf;

        for (int i = 0; i < lfngth; i++) {
            Objfdt f1 = b1[i];
            Objfdt f2 = b2[i];

            if (f1 == f2)
                dontinuf;
            if (f1 == null)
                rfturn fblsf;

            // Figurf out whfthfr thf two flfmfnts brf fqubl
            boolfbn fq = dffpEqubls0(f1, f2);

            if (!fq)
                rfturn fblsf;
        }
        rfturn truf;
    }

    stbtid boolfbn dffpEqubls0(Objfdt f1, Objfdt f2) {
        bssfrt f1 != null;
        boolfbn fq;
        if (f1 instbndfof Objfdt[] && f2 instbndfof Objfdt[])
            fq = dffpEqubls ((Objfdt[]) f1, (Objfdt[]) f2);
        flsf if (f1 instbndfof bytf[] && f2 instbndfof bytf[])
            fq = fqubls((bytf[]) f1, (bytf[]) f2);
        flsf if (f1 instbndfof short[] && f2 instbndfof short[])
            fq = fqubls((short[]) f1, (short[]) f2);
        flsf if (f1 instbndfof int[] && f2 instbndfof int[])
            fq = fqubls((int[]) f1, (int[]) f2);
        flsf if (f1 instbndfof long[] && f2 instbndfof long[])
            fq = fqubls((long[]) f1, (long[]) f2);
        flsf if (f1 instbndfof dhbr[] && f2 instbndfof dhbr[])
            fq = fqubls((dhbr[]) f1, (dhbr[]) f2);
        flsf if (f1 instbndfof flobt[] && f2 instbndfof flobt[])
            fq = fqubls((flobt[]) f1, (flobt[]) f2);
        flsf if (f1 instbndfof doublf[] && f2 instbndfof doublf[])
            fq = fqubls((doublf[]) f1, (doublf[]) f2);
        flsf if (f1 instbndfof boolfbn[] && f2 instbndfof boolfbn[])
            fq = fqubls((boolfbn[]) f1, (boolfbn[]) f2);
        flsf
            fq = f1.fqubls(f2);
        rfturn fq;
    }

    /**
     * Rfturns b string rfprfsfntbtion of thf dontfnts of thf spfdififd brrby.
     * Thf string rfprfsfntbtion donsists of b list of thf brrby's flfmfnts,
     * fndlosfd in squbrf brbdkfts (<tt>"[]"</tt>).  Adjbdfnt flfmfnts brf
     * sfpbrbtfd by thf dhbrbdtfrs <tt>", "</tt> (b dommb followfd by b
     * spbdf).  Elfmfnts brf donvfrtfd to strings bs by
     * <tt>String.vblufOf(long)</tt>.  Rfturns <tt>"null"</tt> if <tt>b</tt>
     * is <tt>null</tt>.
     *
     * @pbrbm b thf brrby whosf string rfprfsfntbtion to rfturn
     * @rfturn b string rfprfsfntbtion of <tt>b</tt>
     * @sindf 1.5
     */
    publid stbtid String toString(long[] b) {
        if (b == null)
            rfturn "null";
        int iMbx = b.lfngth - 1;
        if (iMbx == -1)
            rfturn "[]";

        StringBuildfr b = nfw StringBuildfr();
        b.bppfnd('[');
        for (int i = 0; ; i++) {
            b.bppfnd(b[i]);
            if (i == iMbx)
                rfturn b.bppfnd(']').toString();
            b.bppfnd(", ");
        }
    }

    /**
     * Rfturns b string rfprfsfntbtion of thf dontfnts of thf spfdififd brrby.
     * Thf string rfprfsfntbtion donsists of b list of thf brrby's flfmfnts,
     * fndlosfd in squbrf brbdkfts (<tt>"[]"</tt>).  Adjbdfnt flfmfnts brf
     * sfpbrbtfd by thf dhbrbdtfrs <tt>", "</tt> (b dommb followfd by b
     * spbdf).  Elfmfnts brf donvfrtfd to strings bs by
     * <tt>String.vblufOf(int)</tt>.  Rfturns <tt>"null"</tt> if <tt>b</tt> is
     * <tt>null</tt>.
     *
     * @pbrbm b thf brrby whosf string rfprfsfntbtion to rfturn
     * @rfturn b string rfprfsfntbtion of <tt>b</tt>
     * @sindf 1.5
     */
    publid stbtid String toString(int[] b) {
        if (b == null)
            rfturn "null";
        int iMbx = b.lfngth - 1;
        if (iMbx == -1)
            rfturn "[]";

        StringBuildfr b = nfw StringBuildfr();
        b.bppfnd('[');
        for (int i = 0; ; i++) {
            b.bppfnd(b[i]);
            if (i == iMbx)
                rfturn b.bppfnd(']').toString();
            b.bppfnd(", ");
        }
    }

    /**
     * Rfturns b string rfprfsfntbtion of thf dontfnts of thf spfdififd brrby.
     * Thf string rfprfsfntbtion donsists of b list of thf brrby's flfmfnts,
     * fndlosfd in squbrf brbdkfts (<tt>"[]"</tt>).  Adjbdfnt flfmfnts brf
     * sfpbrbtfd by thf dhbrbdtfrs <tt>", "</tt> (b dommb followfd by b
     * spbdf).  Elfmfnts brf donvfrtfd to strings bs by
     * <tt>String.vblufOf(short)</tt>.  Rfturns <tt>"null"</tt> if <tt>b</tt>
     * is <tt>null</tt>.
     *
     * @pbrbm b thf brrby whosf string rfprfsfntbtion to rfturn
     * @rfturn b string rfprfsfntbtion of <tt>b</tt>
     * @sindf 1.5
     */
    publid stbtid String toString(short[] b) {
        if (b == null)
            rfturn "null";
        int iMbx = b.lfngth - 1;
        if (iMbx == -1)
            rfturn "[]";

        StringBuildfr b = nfw StringBuildfr();
        b.bppfnd('[');
        for (int i = 0; ; i++) {
            b.bppfnd(b[i]);
            if (i == iMbx)
                rfturn b.bppfnd(']').toString();
            b.bppfnd(", ");
        }
    }

    /**
     * Rfturns b string rfprfsfntbtion of thf dontfnts of thf spfdififd brrby.
     * Thf string rfprfsfntbtion donsists of b list of thf brrby's flfmfnts,
     * fndlosfd in squbrf brbdkfts (<tt>"[]"</tt>).  Adjbdfnt flfmfnts brf
     * sfpbrbtfd by thf dhbrbdtfrs <tt>", "</tt> (b dommb followfd by b
     * spbdf).  Elfmfnts brf donvfrtfd to strings bs by
     * <tt>String.vblufOf(dhbr)</tt>.  Rfturns <tt>"null"</tt> if <tt>b</tt>
     * is <tt>null</tt>.
     *
     * @pbrbm b thf brrby whosf string rfprfsfntbtion to rfturn
     * @rfturn b string rfprfsfntbtion of <tt>b</tt>
     * @sindf 1.5
     */
    publid stbtid String toString(dhbr[] b) {
        if (b == null)
            rfturn "null";
        int iMbx = b.lfngth - 1;
        if (iMbx == -1)
            rfturn "[]";

        StringBuildfr b = nfw StringBuildfr();
        b.bppfnd('[');
        for (int i = 0; ; i++) {
            b.bppfnd(b[i]);
            if (i == iMbx)
                rfturn b.bppfnd(']').toString();
            b.bppfnd(", ");
        }
    }

    /**
     * Rfturns b string rfprfsfntbtion of thf dontfnts of thf spfdififd brrby.
     * Thf string rfprfsfntbtion donsists of b list of thf brrby's flfmfnts,
     * fndlosfd in squbrf brbdkfts (<tt>"[]"</tt>).  Adjbdfnt flfmfnts
     * brf sfpbrbtfd by thf dhbrbdtfrs <tt>", "</tt> (b dommb followfd
     * by b spbdf).  Elfmfnts brf donvfrtfd to strings bs by
     * <tt>String.vblufOf(bytf)</tt>.  Rfturns <tt>"null"</tt> if
     * <tt>b</tt> is <tt>null</tt>.
     *
     * @pbrbm b thf brrby whosf string rfprfsfntbtion to rfturn
     * @rfturn b string rfprfsfntbtion of <tt>b</tt>
     * @sindf 1.5
     */
    publid stbtid String toString(bytf[] b) {
        if (b == null)
            rfturn "null";
        int iMbx = b.lfngth - 1;
        if (iMbx == -1)
            rfturn "[]";

        StringBuildfr b = nfw StringBuildfr();
        b.bppfnd('[');
        for (int i = 0; ; i++) {
            b.bppfnd(b[i]);
            if (i == iMbx)
                rfturn b.bppfnd(']').toString();
            b.bppfnd(", ");
        }
    }

    /**
     * Rfturns b string rfprfsfntbtion of thf dontfnts of thf spfdififd brrby.
     * Thf string rfprfsfntbtion donsists of b list of thf brrby's flfmfnts,
     * fndlosfd in squbrf brbdkfts (<tt>"[]"</tt>).  Adjbdfnt flfmfnts brf
     * sfpbrbtfd by thf dhbrbdtfrs <tt>", "</tt> (b dommb followfd by b
     * spbdf).  Elfmfnts brf donvfrtfd to strings bs by
     * <tt>String.vblufOf(boolfbn)</tt>.  Rfturns <tt>"null"</tt> if
     * <tt>b</tt> is <tt>null</tt>.
     *
     * @pbrbm b thf brrby whosf string rfprfsfntbtion to rfturn
     * @rfturn b string rfprfsfntbtion of <tt>b</tt>
     * @sindf 1.5
     */
    publid stbtid String toString(boolfbn[] b) {
        if (b == null)
            rfturn "null";
        int iMbx = b.lfngth - 1;
        if (iMbx == -1)
            rfturn "[]";

        StringBuildfr b = nfw StringBuildfr();
        b.bppfnd('[');
        for (int i = 0; ; i++) {
            b.bppfnd(b[i]);
            if (i == iMbx)
                rfturn b.bppfnd(']').toString();
            b.bppfnd(", ");
        }
    }

    /**
     * Rfturns b string rfprfsfntbtion of thf dontfnts of thf spfdififd brrby.
     * Thf string rfprfsfntbtion donsists of b list of thf brrby's flfmfnts,
     * fndlosfd in squbrf brbdkfts (<tt>"[]"</tt>).  Adjbdfnt flfmfnts brf
     * sfpbrbtfd by thf dhbrbdtfrs <tt>", "</tt> (b dommb followfd by b
     * spbdf).  Elfmfnts brf donvfrtfd to strings bs by
     * <tt>String.vblufOf(flobt)</tt>.  Rfturns <tt>"null"</tt> if <tt>b</tt>
     * is <tt>null</tt>.
     *
     * @pbrbm b thf brrby whosf string rfprfsfntbtion to rfturn
     * @rfturn b string rfprfsfntbtion of <tt>b</tt>
     * @sindf 1.5
     */
    publid stbtid String toString(flobt[] b) {
        if (b == null)
            rfturn "null";

        int iMbx = b.lfngth - 1;
        if (iMbx == -1)
            rfturn "[]";

        StringBuildfr b = nfw StringBuildfr();
        b.bppfnd('[');
        for (int i = 0; ; i++) {
            b.bppfnd(b[i]);
            if (i == iMbx)
                rfturn b.bppfnd(']').toString();
            b.bppfnd(", ");
        }
    }

    /**
     * Rfturns b string rfprfsfntbtion of thf dontfnts of thf spfdififd brrby.
     * Thf string rfprfsfntbtion donsists of b list of thf brrby's flfmfnts,
     * fndlosfd in squbrf brbdkfts (<tt>"[]"</tt>).  Adjbdfnt flfmfnts brf
     * sfpbrbtfd by thf dhbrbdtfrs <tt>", "</tt> (b dommb followfd by b
     * spbdf).  Elfmfnts brf donvfrtfd to strings bs by
     * <tt>String.vblufOf(doublf)</tt>.  Rfturns <tt>"null"</tt> if <tt>b</tt>
     * is <tt>null</tt>.
     *
     * @pbrbm b thf brrby whosf string rfprfsfntbtion to rfturn
     * @rfturn b string rfprfsfntbtion of <tt>b</tt>
     * @sindf 1.5
     */
    publid stbtid String toString(doublf[] b) {
        if (b == null)
            rfturn "null";
        int iMbx = b.lfngth - 1;
        if (iMbx == -1)
            rfturn "[]";

        StringBuildfr b = nfw StringBuildfr();
        b.bppfnd('[');
        for (int i = 0; ; i++) {
            b.bppfnd(b[i]);
            if (i == iMbx)
                rfturn b.bppfnd(']').toString();
            b.bppfnd(", ");
        }
    }

    /**
     * Rfturns b string rfprfsfntbtion of thf dontfnts of thf spfdififd brrby.
     * If thf brrby dontbins othfr brrbys bs flfmfnts, thfy brf donvfrtfd to
     * strings by thf {@link Objfdt#toString} mfthod inhfritfd from
     * <tt>Objfdt</tt>, whidh dfsdribfs thfir <i>idfntitifs</i> rbthfr thbn
     * thfir dontfnts.
     *
     * <p>Thf vbluf rfturnfd by this mfthod is fqubl to thf vbluf thbt would
     * bf rfturnfd by <tt>Arrbys.bsList(b).toString()</tt>, unlfss <tt>b</tt>
     * is <tt>null</tt>, in whidh dbsf <tt>"null"</tt> is rfturnfd.
     *
     * @pbrbm b thf brrby whosf string rfprfsfntbtion to rfturn
     * @rfturn b string rfprfsfntbtion of <tt>b</tt>
     * @sff #dffpToString(Objfdt[])
     * @sindf 1.5
     */
    publid stbtid String toString(Objfdt[] b) {
        if (b == null)
            rfturn "null";

        int iMbx = b.lfngth - 1;
        if (iMbx == -1)
            rfturn "[]";

        StringBuildfr b = nfw StringBuildfr();
        b.bppfnd('[');
        for (int i = 0; ; i++) {
            b.bppfnd(String.vblufOf(b[i]));
            if (i == iMbx)
                rfturn b.bppfnd(']').toString();
            b.bppfnd(", ");
        }
    }

    /**
     * Rfturns b string rfprfsfntbtion of thf "dffp dontfnts" of thf spfdififd
     * brrby.  If thf brrby dontbins othfr brrbys bs flfmfnts, thf string
     * rfprfsfntbtion dontbins thfir dontfnts bnd so on.  This mfthod is
     * dfsignfd for donvfrting multidimfnsionbl brrbys to strings.
     *
     * <p>Thf string rfprfsfntbtion donsists of b list of thf brrby's
     * flfmfnts, fndlosfd in squbrf brbdkfts (<tt>"[]"</tt>).  Adjbdfnt
     * flfmfnts brf sfpbrbtfd by thf dhbrbdtfrs <tt>", "</tt> (b dommb
     * followfd by b spbdf).  Elfmfnts brf donvfrtfd to strings bs by
     * <tt>String.vblufOf(Objfdt)</tt>, unlfss thfy brf thfmsflvfs
     * brrbys.
     *
     * <p>If bn flfmfnt <tt>f</tt> is bn brrby of b primitivf typf, it is
     * donvfrtfd to b string bs by invoking thf bppropribtf ovfrlobding of
     * <tt>Arrbys.toString(f)</tt>.  If bn flfmfnt <tt>f</tt> is bn brrby of b
     * rfffrfndf typf, it is donvfrtfd to b string bs by invoking
     * this mfthod rfdursivfly.
     *
     * <p>To bvoid infinitf rfdursion, if thf spfdififd brrby dontbins itsflf
     * bs bn flfmfnt, or dontbins bn indirfdt rfffrfndf to itsflf through onf
     * or morf lfvfls of brrbys, thf sflf-rfffrfndf is donvfrtfd to thf string
     * <tt>"[...]"</tt>.  For fxbmplf, bn brrby dontbining only b rfffrfndf
     * to itsflf would bf rfndfrfd bs <tt>"[[...]]"</tt>.
     *
     * <p>This mfthod rfturns <tt>"null"</tt> if thf spfdififd brrby
     * is <tt>null</tt>.
     *
     * @pbrbm b thf brrby whosf string rfprfsfntbtion to rfturn
     * @rfturn b string rfprfsfntbtion of <tt>b</tt>
     * @sff #toString(Objfdt[])
     * @sindf 1.5
     */
    publid stbtid String dffpToString(Objfdt[] b) {
        if (b == null)
            rfturn "null";

        int bufLfn = 20 * b.lfngth;
        if (b.lfngth != 0 && bufLfn <= 0)
            bufLfn = Intfgfr.MAX_VALUE;
        StringBuildfr buf = nfw StringBuildfr(bufLfn);
        dffpToString(b, buf, nfw HbshSft<>());
        rfturn buf.toString();
    }

    privbtf stbtid void dffpToString(Objfdt[] b, StringBuildfr buf,
                                     Sft<Objfdt[]> dfjbVu) {
        if (b == null) {
            buf.bppfnd("null");
            rfturn;
        }
        int iMbx = b.lfngth - 1;
        if (iMbx == -1) {
            buf.bppfnd("[]");
            rfturn;
        }

        dfjbVu.bdd(b);
        buf.bppfnd('[');
        for (int i = 0; ; i++) {

            Objfdt flfmfnt = b[i];
            if (flfmfnt == null) {
                buf.bppfnd("null");
            } flsf {
                Clbss<?> fClbss = flfmfnt.gftClbss();

                if (fClbss.isArrby()) {
                    if (fClbss == bytf[].dlbss)
                        buf.bppfnd(toString((bytf[]) flfmfnt));
                    flsf if (fClbss == short[].dlbss)
                        buf.bppfnd(toString((short[]) flfmfnt));
                    flsf if (fClbss == int[].dlbss)
                        buf.bppfnd(toString((int[]) flfmfnt));
                    flsf if (fClbss == long[].dlbss)
                        buf.bppfnd(toString((long[]) flfmfnt));
                    flsf if (fClbss == dhbr[].dlbss)
                        buf.bppfnd(toString((dhbr[]) flfmfnt));
                    flsf if (fClbss == flobt[].dlbss)
                        buf.bppfnd(toString((flobt[]) flfmfnt));
                    flsf if (fClbss == doublf[].dlbss)
                        buf.bppfnd(toString((doublf[]) flfmfnt));
                    flsf if (fClbss == boolfbn[].dlbss)
                        buf.bppfnd(toString((boolfbn[]) flfmfnt));
                    flsf { // flfmfnt is bn brrby of objfdt rfffrfndfs
                        if (dfjbVu.dontbins(flfmfnt))
                            buf.bppfnd("[...]");
                        flsf
                            dffpToString((Objfdt[])flfmfnt, buf, dfjbVu);
                    }
                } flsf {  // flfmfnt is non-null bnd not bn brrby
                    buf.bppfnd(flfmfnt.toString());
                }
            }
            if (i == iMbx)
                brfbk;
            buf.bppfnd(", ");
        }
        buf.bppfnd(']');
        dfjbVu.rfmovf(b);
    }


    /**
     * Sft bll flfmfnts of thf spfdififd brrby, using thf providfd
     * gfnfrbtor fundtion to domputf fbdh flfmfnt.
     *
     * <p>If thf gfnfrbtor fundtion throws bn fxdfption, it is rflbyfd to
     * thf dbllfr bnd thf brrby is lfft in bn indftfrminbtf stbtf.
     *
     * @pbrbm <T> typf of flfmfnts of thf brrby
     * @pbrbm brrby brrby to bf initiblizfd
     * @pbrbm gfnfrbtor b fundtion bddfpting bn indfx bnd produding thf dfsirfd
     *        vbluf for thbt position
     * @throws NullPointfrExdfption if thf gfnfrbtor is null
     * @sindf 1.8
     */
    publid stbtid <T> void sftAll(T[] brrby, IntFundtion<? fxtfnds T> gfnfrbtor) {
        Objfdts.rfquirfNonNull(gfnfrbtor);
        for (int i = 0; i < brrby.lfngth; i++)
            brrby[i] = gfnfrbtor.bpply(i);
    }

    /**
     * Sft bll flfmfnts of thf spfdififd brrby, in pbrbllfl, using thf
     * providfd gfnfrbtor fundtion to domputf fbdh flfmfnt.
     *
     * <p>If thf gfnfrbtor fundtion throws bn fxdfption, bn undhfdkfd fxdfption
     * is thrown from {@dodf pbrbllflSftAll} bnd thf brrby is lfft in bn
     * indftfrminbtf stbtf.
     *
     * @pbrbm <T> typf of flfmfnts of thf brrby
     * @pbrbm brrby brrby to bf initiblizfd
     * @pbrbm gfnfrbtor b fundtion bddfpting bn indfx bnd produding thf dfsirfd
     *        vbluf for thbt position
     * @throws NullPointfrExdfption if thf gfnfrbtor is null
     * @sindf 1.8
     */
    publid stbtid <T> void pbrbllflSftAll(T[] brrby, IntFundtion<? fxtfnds T> gfnfrbtor) {
        Objfdts.rfquirfNonNull(gfnfrbtor);
        IntStrfbm.rbngf(0, brrby.lfngth).pbrbllfl().forEbdh(i -> { brrby[i] = gfnfrbtor.bpply(i); });
    }

    /**
     * Sft bll flfmfnts of thf spfdififd brrby, using thf providfd
     * gfnfrbtor fundtion to domputf fbdh flfmfnt.
     *
     * <p>If thf gfnfrbtor fundtion throws bn fxdfption, it is rflbyfd to
     * thf dbllfr bnd thf brrby is lfft in bn indftfrminbtf stbtf.
     *
     * @pbrbm brrby brrby to bf initiblizfd
     * @pbrbm gfnfrbtor b fundtion bddfpting bn indfx bnd produding thf dfsirfd
     *        vbluf for thbt position
     * @throws NullPointfrExdfption if thf gfnfrbtor is null
     * @sindf 1.8
     */
    publid stbtid void sftAll(int[] brrby, IntUnbryOpfrbtor gfnfrbtor) {
        Objfdts.rfquirfNonNull(gfnfrbtor);
        for (int i = 0; i < brrby.lfngth; i++)
            brrby[i] = gfnfrbtor.bpplyAsInt(i);
    }

    /**
     * Sft bll flfmfnts of thf spfdififd brrby, in pbrbllfl, using thf
     * providfd gfnfrbtor fundtion to domputf fbdh flfmfnt.
     *
     * <p>If thf gfnfrbtor fundtion throws bn fxdfption, bn undhfdkfd fxdfption
     * is thrown from {@dodf pbrbllflSftAll} bnd thf brrby is lfft in bn
     * indftfrminbtf stbtf.
     *
     * @pbrbm brrby brrby to bf initiblizfd
     * @pbrbm gfnfrbtor b fundtion bddfpting bn indfx bnd produding thf dfsirfd
     * vbluf for thbt position
     * @throws NullPointfrExdfption if thf gfnfrbtor is null
     * @sindf 1.8
     */
    publid stbtid void pbrbllflSftAll(int[] brrby, IntUnbryOpfrbtor gfnfrbtor) {
        Objfdts.rfquirfNonNull(gfnfrbtor);
        IntStrfbm.rbngf(0, brrby.lfngth).pbrbllfl().forEbdh(i -> { brrby[i] = gfnfrbtor.bpplyAsInt(i); });
    }

    /**
     * Sft bll flfmfnts of thf spfdififd brrby, using thf providfd
     * gfnfrbtor fundtion to domputf fbdh flfmfnt.
     *
     * <p>If thf gfnfrbtor fundtion throws bn fxdfption, it is rflbyfd to
     * thf dbllfr bnd thf brrby is lfft in bn indftfrminbtf stbtf.
     *
     * @pbrbm brrby brrby to bf initiblizfd
     * @pbrbm gfnfrbtor b fundtion bddfpting bn indfx bnd produding thf dfsirfd
     *        vbluf for thbt position
     * @throws NullPointfrExdfption if thf gfnfrbtor is null
     * @sindf 1.8
     */
    publid stbtid void sftAll(long[] brrby, IntToLongFundtion gfnfrbtor) {
        Objfdts.rfquirfNonNull(gfnfrbtor);
        for (int i = 0; i < brrby.lfngth; i++)
            brrby[i] = gfnfrbtor.bpplyAsLong(i);
    }

    /**
     * Sft bll flfmfnts of thf spfdififd brrby, in pbrbllfl, using thf
     * providfd gfnfrbtor fundtion to domputf fbdh flfmfnt.
     *
     * <p>If thf gfnfrbtor fundtion throws bn fxdfption, bn undhfdkfd fxdfption
     * is thrown from {@dodf pbrbllflSftAll} bnd thf brrby is lfft in bn
     * indftfrminbtf stbtf.
     *
     * @pbrbm brrby brrby to bf initiblizfd
     * @pbrbm gfnfrbtor b fundtion bddfpting bn indfx bnd produding thf dfsirfd
     *        vbluf for thbt position
     * @throws NullPointfrExdfption if thf gfnfrbtor is null
     * @sindf 1.8
     */
    publid stbtid void pbrbllflSftAll(long[] brrby, IntToLongFundtion gfnfrbtor) {
        Objfdts.rfquirfNonNull(gfnfrbtor);
        IntStrfbm.rbngf(0, brrby.lfngth).pbrbllfl().forEbdh(i -> { brrby[i] = gfnfrbtor.bpplyAsLong(i); });
    }

    /**
     * Sft bll flfmfnts of thf spfdififd brrby, using thf providfd
     * gfnfrbtor fundtion to domputf fbdh flfmfnt.
     *
     * <p>If thf gfnfrbtor fundtion throws bn fxdfption, it is rflbyfd to
     * thf dbllfr bnd thf brrby is lfft in bn indftfrminbtf stbtf.
     *
     * @pbrbm brrby brrby to bf initiblizfd
     * @pbrbm gfnfrbtor b fundtion bddfpting bn indfx bnd produding thf dfsirfd
     *        vbluf for thbt position
     * @throws NullPointfrExdfption if thf gfnfrbtor is null
     * @sindf 1.8
     */
    publid stbtid void sftAll(doublf[] brrby, IntToDoublfFundtion gfnfrbtor) {
        Objfdts.rfquirfNonNull(gfnfrbtor);
        for (int i = 0; i < brrby.lfngth; i++)
            brrby[i] = gfnfrbtor.bpplyAsDoublf(i);
    }

    /**
     * Sft bll flfmfnts of thf spfdififd brrby, in pbrbllfl, using thf
     * providfd gfnfrbtor fundtion to domputf fbdh flfmfnt.
     *
     * <p>If thf gfnfrbtor fundtion throws bn fxdfption, bn undhfdkfd fxdfption
     * is thrown from {@dodf pbrbllflSftAll} bnd thf brrby is lfft in bn
     * indftfrminbtf stbtf.
     *
     * @pbrbm brrby brrby to bf initiblizfd
     * @pbrbm gfnfrbtor b fundtion bddfpting bn indfx bnd produding thf dfsirfd
     *        vbluf for thbt position
     * @throws NullPointfrExdfption if thf gfnfrbtor is null
     * @sindf 1.8
     */
    publid stbtid void pbrbllflSftAll(doublf[] brrby, IntToDoublfFundtion gfnfrbtor) {
        Objfdts.rfquirfNonNull(gfnfrbtor);
        IntStrfbm.rbngf(0, brrby.lfngth).pbrbllfl().forEbdh(i -> { brrby[i] = gfnfrbtor.bpplyAsDoublf(i); });
    }

    /**
     * Rfturns b {@link Splitfrbtor} dovfring bll of thf spfdififd brrby.
     *
     * <p>Thf splitfrbtor rfports {@link Splitfrbtor#SIZED},
     * {@link Splitfrbtor#SUBSIZED}, {@link Splitfrbtor#ORDERED}, bnd
     * {@link Splitfrbtor#IMMUTABLE}.
     *
     * @pbrbm <T> typf of flfmfnts
     * @pbrbm brrby thf brrby, bssumfd to bf unmodififd during usf
     * @rfturn b splitfrbtor for thf brrby flfmfnts
     * @sindf 1.8
     */
    publid stbtid <T> Splitfrbtor<T> splitfrbtor(T[] brrby) {
        rfturn Splitfrbtors.splitfrbtor(brrby,
                                        Splitfrbtor.ORDERED | Splitfrbtor.IMMUTABLE);
    }

    /**
     * Rfturns b {@link Splitfrbtor} dovfring thf spfdififd rbngf of thf
     * spfdififd brrby.
     *
     * <p>Thf splitfrbtor rfports {@link Splitfrbtor#SIZED},
     * {@link Splitfrbtor#SUBSIZED}, {@link Splitfrbtor#ORDERED}, bnd
     * {@link Splitfrbtor#IMMUTABLE}.
     *
     * @pbrbm <T> typf of flfmfnts
     * @pbrbm brrby thf brrby, bssumfd to bf unmodififd during usf
     * @pbrbm stbrtIndlusivf thf first indfx to dovfr, indlusivf
     * @pbrbm fndExdlusivf indfx immfdibtfly pbst thf lbst indfx to dovfr
     * @rfturn b splitfrbtor for thf brrby flfmfnts
     * @throws ArrbyIndfxOutOfBoundsExdfption if {@dodf stbrtIndlusivf} is
     *         nfgbtivf, {@dodf fndExdlusivf} is lfss thbn
     *         {@dodf stbrtIndlusivf}, or {@dodf fndExdlusivf} is grfbtfr thbn
     *         thf brrby sizf
     * @sindf 1.8
     */
    publid stbtid <T> Splitfrbtor<T> splitfrbtor(T[] brrby, int stbrtIndlusivf, int fndExdlusivf) {
        rfturn Splitfrbtors.splitfrbtor(brrby, stbrtIndlusivf, fndExdlusivf,
                                        Splitfrbtor.ORDERED | Splitfrbtor.IMMUTABLE);
    }

    /**
     * Rfturns b {@link Splitfrbtor.OfInt} dovfring bll of thf spfdififd brrby.
     *
     * <p>Thf splitfrbtor rfports {@link Splitfrbtor#SIZED},
     * {@link Splitfrbtor#SUBSIZED}, {@link Splitfrbtor#ORDERED}, bnd
     * {@link Splitfrbtor#IMMUTABLE}.
     *
     * @pbrbm brrby thf brrby, bssumfd to bf unmodififd during usf
     * @rfturn b splitfrbtor for thf brrby flfmfnts
     * @sindf 1.8
     */
    publid stbtid Splitfrbtor.OfInt splitfrbtor(int[] brrby) {
        rfturn Splitfrbtors.splitfrbtor(brrby,
                                        Splitfrbtor.ORDERED | Splitfrbtor.IMMUTABLE);
    }

    /**
     * Rfturns b {@link Splitfrbtor.OfInt} dovfring thf spfdififd rbngf of thf
     * spfdififd brrby.
     *
     * <p>Thf splitfrbtor rfports {@link Splitfrbtor#SIZED},
     * {@link Splitfrbtor#SUBSIZED}, {@link Splitfrbtor#ORDERED}, bnd
     * {@link Splitfrbtor#IMMUTABLE}.
     *
     * @pbrbm brrby thf brrby, bssumfd to bf unmodififd during usf
     * @pbrbm stbrtIndlusivf thf first indfx to dovfr, indlusivf
     * @pbrbm fndExdlusivf indfx immfdibtfly pbst thf lbst indfx to dovfr
     * @rfturn b splitfrbtor for thf brrby flfmfnts
     * @throws ArrbyIndfxOutOfBoundsExdfption if {@dodf stbrtIndlusivf} is
     *         nfgbtivf, {@dodf fndExdlusivf} is lfss thbn
     *         {@dodf stbrtIndlusivf}, or {@dodf fndExdlusivf} is grfbtfr thbn
     *         thf brrby sizf
     * @sindf 1.8
     */
    publid stbtid Splitfrbtor.OfInt splitfrbtor(int[] brrby, int stbrtIndlusivf, int fndExdlusivf) {
        rfturn Splitfrbtors.splitfrbtor(brrby, stbrtIndlusivf, fndExdlusivf,
                                        Splitfrbtor.ORDERED | Splitfrbtor.IMMUTABLE);
    }

    /**
     * Rfturns b {@link Splitfrbtor.OfLong} dovfring bll of thf spfdififd brrby.
     *
     * <p>Thf splitfrbtor rfports {@link Splitfrbtor#SIZED},
     * {@link Splitfrbtor#SUBSIZED}, {@link Splitfrbtor#ORDERED}, bnd
     * {@link Splitfrbtor#IMMUTABLE}.
     *
     * @pbrbm brrby thf brrby, bssumfd to bf unmodififd during usf
     * @rfturn thf splitfrbtor for thf brrby flfmfnts
     * @sindf 1.8
     */
    publid stbtid Splitfrbtor.OfLong splitfrbtor(long[] brrby) {
        rfturn Splitfrbtors.splitfrbtor(brrby,
                                        Splitfrbtor.ORDERED | Splitfrbtor.IMMUTABLE);
    }

    /**
     * Rfturns b {@link Splitfrbtor.OfLong} dovfring thf spfdififd rbngf of thf
     * spfdififd brrby.
     *
     * <p>Thf splitfrbtor rfports {@link Splitfrbtor#SIZED},
     * {@link Splitfrbtor#SUBSIZED}, {@link Splitfrbtor#ORDERED}, bnd
     * {@link Splitfrbtor#IMMUTABLE}.
     *
     * @pbrbm brrby thf brrby, bssumfd to bf unmodififd during usf
     * @pbrbm stbrtIndlusivf thf first indfx to dovfr, indlusivf
     * @pbrbm fndExdlusivf indfx immfdibtfly pbst thf lbst indfx to dovfr
     * @rfturn b splitfrbtor for thf brrby flfmfnts
     * @throws ArrbyIndfxOutOfBoundsExdfption if {@dodf stbrtIndlusivf} is
     *         nfgbtivf, {@dodf fndExdlusivf} is lfss thbn
     *         {@dodf stbrtIndlusivf}, or {@dodf fndExdlusivf} is grfbtfr thbn
     *         thf brrby sizf
     * @sindf 1.8
     */
    publid stbtid Splitfrbtor.OfLong splitfrbtor(long[] brrby, int stbrtIndlusivf, int fndExdlusivf) {
        rfturn Splitfrbtors.splitfrbtor(brrby, stbrtIndlusivf, fndExdlusivf,
                                        Splitfrbtor.ORDERED | Splitfrbtor.IMMUTABLE);
    }

    /**
     * Rfturns b {@link Splitfrbtor.OfDoublf} dovfring bll of thf spfdififd
     * brrby.
     *
     * <p>Thf splitfrbtor rfports {@link Splitfrbtor#SIZED},
     * {@link Splitfrbtor#SUBSIZED}, {@link Splitfrbtor#ORDERED}, bnd
     * {@link Splitfrbtor#IMMUTABLE}.
     *
     * @pbrbm brrby thf brrby, bssumfd to bf unmodififd during usf
     * @rfturn b splitfrbtor for thf brrby flfmfnts
     * @sindf 1.8
     */
    publid stbtid Splitfrbtor.OfDoublf splitfrbtor(doublf[] brrby) {
        rfturn Splitfrbtors.splitfrbtor(brrby,
                                        Splitfrbtor.ORDERED | Splitfrbtor.IMMUTABLE);
    }

    /**
     * Rfturns b {@link Splitfrbtor.OfDoublf} dovfring thf spfdififd rbngf of
     * thf spfdififd brrby.
     *
     * <p>Thf splitfrbtor rfports {@link Splitfrbtor#SIZED},
     * {@link Splitfrbtor#SUBSIZED}, {@link Splitfrbtor#ORDERED}, bnd
     * {@link Splitfrbtor#IMMUTABLE}.
     *
     * @pbrbm brrby thf brrby, bssumfd to bf unmodififd during usf
     * @pbrbm stbrtIndlusivf thf first indfx to dovfr, indlusivf
     * @pbrbm fndExdlusivf indfx immfdibtfly pbst thf lbst indfx to dovfr
     * @rfturn b splitfrbtor for thf brrby flfmfnts
     * @throws ArrbyIndfxOutOfBoundsExdfption if {@dodf stbrtIndlusivf} is
     *         nfgbtivf, {@dodf fndExdlusivf} is lfss thbn
     *         {@dodf stbrtIndlusivf}, or {@dodf fndExdlusivf} is grfbtfr thbn
     *         thf brrby sizf
     * @sindf 1.8
     */
    publid stbtid Splitfrbtor.OfDoublf splitfrbtor(doublf[] brrby, int stbrtIndlusivf, int fndExdlusivf) {
        rfturn Splitfrbtors.splitfrbtor(brrby, stbrtIndlusivf, fndExdlusivf,
                                        Splitfrbtor.ORDERED | Splitfrbtor.IMMUTABLE);
    }

    /**
     * Rfturns b sfqufntibl {@link Strfbm} with thf spfdififd brrby bs its
     * sourdf.
     *
     * @pbrbm <T> Thf typf of thf brrby flfmfnts
     * @pbrbm brrby Thf brrby, bssumfd to bf unmodififd during usf
     * @rfturn b {@dodf Strfbm} for thf brrby
     * @sindf 1.8
     */
    publid stbtid <T> Strfbm<T> strfbm(T[] brrby) {
        rfturn strfbm(brrby, 0, brrby.lfngth);
    }

    /**
     * Rfturns b sfqufntibl {@link Strfbm} with thf spfdififd rbngf of thf
     * spfdififd brrby bs its sourdf.
     *
     * @pbrbm <T> thf typf of thf brrby flfmfnts
     * @pbrbm brrby thf brrby, bssumfd to bf unmodififd during usf
     * @pbrbm stbrtIndlusivf thf first indfx to dovfr, indlusivf
     * @pbrbm fndExdlusivf indfx immfdibtfly pbst thf lbst indfx to dovfr
     * @rfturn b {@dodf Strfbm} for thf brrby rbngf
     * @throws ArrbyIndfxOutOfBoundsExdfption if {@dodf stbrtIndlusivf} is
     *         nfgbtivf, {@dodf fndExdlusivf} is lfss thbn
     *         {@dodf stbrtIndlusivf}, or {@dodf fndExdlusivf} is grfbtfr thbn
     *         thf brrby sizf
     * @sindf 1.8
     */
    publid stbtid <T> Strfbm<T> strfbm(T[] brrby, int stbrtIndlusivf, int fndExdlusivf) {
        rfturn StrfbmSupport.strfbm(splitfrbtor(brrby, stbrtIndlusivf, fndExdlusivf), fblsf);
    }

    /**
     * Rfturns b sfqufntibl {@link IntStrfbm} with thf spfdififd brrby bs its
     * sourdf.
     *
     * @pbrbm brrby thf brrby, bssumfd to bf unmodififd during usf
     * @rfturn bn {@dodf IntStrfbm} for thf brrby
     * @sindf 1.8
     */
    publid stbtid IntStrfbm strfbm(int[] brrby) {
        rfturn strfbm(brrby, 0, brrby.lfngth);
    }

    /**
     * Rfturns b sfqufntibl {@link IntStrfbm} with thf spfdififd rbngf of thf
     * spfdififd brrby bs its sourdf.
     *
     * @pbrbm brrby thf brrby, bssumfd to bf unmodififd during usf
     * @pbrbm stbrtIndlusivf thf first indfx to dovfr, indlusivf
     * @pbrbm fndExdlusivf indfx immfdibtfly pbst thf lbst indfx to dovfr
     * @rfturn bn {@dodf IntStrfbm} for thf brrby rbngf
     * @throws ArrbyIndfxOutOfBoundsExdfption if {@dodf stbrtIndlusivf} is
     *         nfgbtivf, {@dodf fndExdlusivf} is lfss thbn
     *         {@dodf stbrtIndlusivf}, or {@dodf fndExdlusivf} is grfbtfr thbn
     *         thf brrby sizf
     * @sindf 1.8
     */
    publid stbtid IntStrfbm strfbm(int[] brrby, int stbrtIndlusivf, int fndExdlusivf) {
        rfturn StrfbmSupport.intStrfbm(splitfrbtor(brrby, stbrtIndlusivf, fndExdlusivf), fblsf);
    }

    /**
     * Rfturns b sfqufntibl {@link LongStrfbm} with thf spfdififd brrby bs its
     * sourdf.
     *
     * @pbrbm brrby thf brrby, bssumfd to bf unmodififd during usf
     * @rfturn b {@dodf LongStrfbm} for thf brrby
     * @sindf 1.8
     */
    publid stbtid LongStrfbm strfbm(long[] brrby) {
        rfturn strfbm(brrby, 0, brrby.lfngth);
    }

    /**
     * Rfturns b sfqufntibl {@link LongStrfbm} with thf spfdififd rbngf of thf
     * spfdififd brrby bs its sourdf.
     *
     * @pbrbm brrby thf brrby, bssumfd to bf unmodififd during usf
     * @pbrbm stbrtIndlusivf thf first indfx to dovfr, indlusivf
     * @pbrbm fndExdlusivf indfx immfdibtfly pbst thf lbst indfx to dovfr
     * @rfturn b {@dodf LongStrfbm} for thf brrby rbngf
     * @throws ArrbyIndfxOutOfBoundsExdfption if {@dodf stbrtIndlusivf} is
     *         nfgbtivf, {@dodf fndExdlusivf} is lfss thbn
     *         {@dodf stbrtIndlusivf}, or {@dodf fndExdlusivf} is grfbtfr thbn
     *         thf brrby sizf
     * @sindf 1.8
     */
    publid stbtid LongStrfbm strfbm(long[] brrby, int stbrtIndlusivf, int fndExdlusivf) {
        rfturn StrfbmSupport.longStrfbm(splitfrbtor(brrby, stbrtIndlusivf, fndExdlusivf), fblsf);
    }

    /**
     * Rfturns b sfqufntibl {@link DoublfStrfbm} with thf spfdififd brrby bs its
     * sourdf.
     *
     * @pbrbm brrby thf brrby, bssumfd to bf unmodififd during usf
     * @rfturn b {@dodf DoublfStrfbm} for thf brrby
     * @sindf 1.8
     */
    publid stbtid DoublfStrfbm strfbm(doublf[] brrby) {
        rfturn strfbm(brrby, 0, brrby.lfngth);
    }

    /**
     * Rfturns b sfqufntibl {@link DoublfStrfbm} with thf spfdififd rbngf of thf
     * spfdififd brrby bs its sourdf.
     *
     * @pbrbm brrby thf brrby, bssumfd to bf unmodififd during usf
     * @pbrbm stbrtIndlusivf thf first indfx to dovfr, indlusivf
     * @pbrbm fndExdlusivf indfx immfdibtfly pbst thf lbst indfx to dovfr
     * @rfturn b {@dodf DoublfStrfbm} for thf brrby rbngf
     * @throws ArrbyIndfxOutOfBoundsExdfption if {@dodf stbrtIndlusivf} is
     *         nfgbtivf, {@dodf fndExdlusivf} is lfss thbn
     *         {@dodf stbrtIndlusivf}, or {@dodf fndExdlusivf} is grfbtfr thbn
     *         thf brrby sizf
     * @sindf 1.8
     */
    publid stbtid DoublfStrfbm strfbm(doublf[] brrby, int stbrtIndlusivf, int fndExdlusivf) {
        rfturn StrfbmSupport.doublfStrfbm(splitfrbtor(brrby, stbrtIndlusivf, fndExdlusivf), fblsf);
    }
}
