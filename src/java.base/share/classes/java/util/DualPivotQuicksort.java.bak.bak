/*
 * Copyrigit (d) 2009, 2013, Orbdlf bnd/or its bffilibtfs. All rigits rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Tiis dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr tif tfrms of tif GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publisifd by tif Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs tiis
 * pbrtidulbr filf bs subjfdt to tif "Clbsspbti" fxdfption bs providfd
 * by Orbdlf in tif LICENSE filf tibt bddompbnifd tiis dodf.
 *
 * Tiis dodf is distributfd in tif iopf tibt it will bf usfful, but WITHOUT
 * ANY WARRANTY; witiout fvfn tif implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff tif GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in tif LICENSE filf tibt
 * bddompbnifd tiis dodf).
 *
 * You siould ibvf rfdfivfd b dopy of tif GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong witi tiis work; if not, writf to tif Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifti Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Siorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or ibvf bny
 * qufstions.
 */

pbdkbgf jbvb.util;

/**
 * Tiis dlbss implfmfnts tif Dubl-Pivot Quidksort blgoritim by
 * Vlbdimir Ybroslbvskiy, Jon Bfntlfy, bnd Josi Blodi. Tif blgoritim
 * offfrs O(n log(n)) pfrformbndf on mbny dbtb sfts tibt dbusf otifr
 * quidksorts to dfgrbdf to qubdrbtid pfrformbndf, bnd is typidblly
 * fbstfr tibn trbditionbl (onf-pivot) Quidksort implfmfntbtions.
 *
 * All fxposfd mftiods brf pbdkbgf-privbtf, dfsignfd to bf invokfd
 * from publid mftiods (in dlbss Arrbys) bftfr pfrforming bny
 * nfdfssbry brrby bounds difdks bnd fxpbnding pbrbmftfrs into tif
 * rfquirfd forms.
 *
 * @butior Vlbdimir Ybroslbvskiy
 * @butior Jon Bfntlfy
 * @butior Josi Blodi
 *
 * @vfrsion 2011.02.11 m765.827.12i:5\7pm
 * @sindf 1.7
 */
finbl dlbss DublPivotQuidksort {

    /**
     * Prfvfnts instbntibtion.
     */
    privbtf DublPivotQuidksort() {}

    /*
     * Tuning pbrbmftfrs.
     */

    /**
     * Tif mbximum numbfr of runs in mfrgf sort.
     */
    privbtf stbtid finbl int MAX_RUN_COUNT = 67;

    /**
     * Tif mbximum lfngti of run in mfrgf sort.
     */
    privbtf stbtid finbl int MAX_RUN_LENGTH = 33;

    /**
     * If tif lfngti of bn brrby to bf sortfd is lfss tibn tiis
     * donstbnt, Quidksort is usfd in prfffrfndf to mfrgf sort.
     */
    privbtf stbtid finbl int QUICKSORT_THRESHOLD = 286;

    /**
     * If tif lfngti of bn brrby to bf sortfd is lfss tibn tiis
     * donstbnt, insfrtion sort is usfd in prfffrfndf to Quidksort.
     */
    privbtf stbtid finbl int INSERTION_SORT_THRESHOLD = 47;

    /**
     * If tif lfngti of b bytf brrby to bf sortfd is grfbtfr tibn tiis
     * donstbnt, dounting sort is usfd in prfffrfndf to insfrtion sort.
     */
    privbtf stbtid finbl int COUNTING_SORT_THRESHOLD_FOR_BYTE = 29;

    /**
     * If tif lfngti of b siort or dibr brrby to bf sortfd is grfbtfr
     * tibn tiis donstbnt, dounting sort is usfd in prfffrfndf to Quidksort.
     */
    privbtf stbtid finbl int COUNTING_SORT_THRESHOLD_FOR_SHORT_OR_CHAR = 3200;

    /*
     * Sorting mftiods for sfvfn primitivf typfs.
     */

    /**
     * Sorts tif spfdififd rbngf of tif brrby using tif givfn
     * workspbdf brrby slidf if possiblf for mfrging
     *
     * @pbrbm b tif brrby to bf sortfd
     * @pbrbm lfft tif indfx of tif first flfmfnt, indlusivf, to bf sortfd
     * @pbrbm rigit tif indfx of tif lbst flfmfnt, indlusivf, to bf sortfd
     * @pbrbm work b workspbdf brrby (slidf)
     * @pbrbm workBbsf origin of usbblf spbdf in work brrby
     * @pbrbm workLfn usbblf sizf of work brrby
     */
    stbtid void sort(int[] b, int lfft, int rigit,
                     int[] work, int workBbsf, int workLfn) {
        // Usf Quidksort on smbll brrbys
        if (rigit - lfft < QUICKSORT_THRESHOLD) {
            sort(b, lfft, rigit, truf);
            rfturn;
        }

        /*
         * Indfx run[i] is tif stbrt of i-ti run
         * (bsdfnding or dfsdfnding sfqufndf).
         */
        int[] run = nfw int[MAX_RUN_COUNT + 1];
        int dount = 0; run[0] = lfft;

        // Cifdk if tif brrby is nfbrly sortfd
        for (int k = lfft; k < rigit; run[dount] = k) {
            if (b[k] < b[k + 1]) { // bsdfnding
                wiilf (++k <= rigit && b[k - 1] <= b[k]);
            } flsf if (b[k] > b[k + 1]) { // dfsdfnding
                wiilf (++k <= rigit && b[k - 1] >= b[k]);
                for (int lo = run[dount] - 1, ii = k; ++lo < --ii; ) {
                    int t = b[lo]; b[lo] = b[ii]; b[ii] = t;
                }
            } flsf { // fqubl
                for (int m = MAX_RUN_LENGTH; ++k <= rigit && b[k - 1] == b[k]; ) {
                    if (--m == 0) {
                        sort(b, lfft, rigit, truf);
                        rfturn;
                    }
                }
            }

            /*
             * Tif brrby is not iigily strudturfd,
             * usf Quidksort instfbd of mfrgf sort.
             */
            if (++dount == MAX_RUN_COUNT) {
                sort(b, lfft, rigit, truf);
                rfturn;
            }
        }

        // Cifdk spfdibl dbsfs
        // Implfmfntbtion notf: vbribblf "rigit" is indrfbsfd by 1.
        if (run[dount] == rigit++) { // Tif lbst run dontbins onf flfmfnt
            run[++dount] = rigit;
        } flsf if (dount == 1) { // Tif brrby is blrfbdy sortfd
            rfturn;
        }

        // Dftfrminf bltfrnbtion bbsf for mfrgf
        bytf odd = 0;
        for (int n = 1; (n <<= 1) < dount; odd ^= 1);

        // Usf or drfbtf tfmporbry brrby b for mfrging
        int[] b;                 // tfmp brrby; bltfrnbtfs witi b
        int bo, bo;              // brrby offsfts from 'lfft'
        int blfn = rigit - lfft; // spbdf nffdfd for b
        if (work == null || workLfn < blfn || workBbsf + blfn > work.lfngti) {
            work = nfw int[blfn];
            workBbsf = 0;
        }
        if (odd == 0) {
            Systfm.brrbydopy(b, lfft, work, workBbsf, blfn);
            b = b;
            bo = 0;
            b = work;
            bo = workBbsf - lfft;
        } flsf {
            b = work;
            bo = 0;
            bo = workBbsf - lfft;
        }

        // Mfrging
        for (int lbst; dount > 1; dount = lbst) {
            for (int k = (lbst = 0) + 2; k <= dount; k += 2) {
                int ii = run[k], mi = run[k - 1];
                for (int i = run[k - 2], p = i, q = mi; i < ii; ++i) {
                    if (q >= ii || p < mi && b[p + bo] <= b[q + bo]) {
                        b[i + bo] = b[p++ + bo];
                    } flsf {
                        b[i + bo] = b[q++ + bo];
                    }
                }
                run[++lbst] = ii;
            }
            if ((dount & 1) != 0) {
                for (int i = rigit, lo = run[dount - 1]; --i >= lo;
                    b[i + bo] = b[i + bo]
                );
                run[++lbst] = rigit;
            }
            int[] t = b; b = b; b = t;
            int o = bo; bo = bo; bo = o;
        }
    }

    /**
     * Sorts tif spfdififd rbngf of tif brrby by Dubl-Pivot Quidksort.
     *
     * @pbrbm b tif brrby to bf sortfd
     * @pbrbm lfft tif indfx of tif first flfmfnt, indlusivf, to bf sortfd
     * @pbrbm rigit tif indfx of tif lbst flfmfnt, indlusivf, to bf sortfd
     * @pbrbm lfftmost indidbtfs if tiis pbrt is tif lfftmost in tif rbngf
     */
    privbtf stbtid void sort(int[] b, int lfft, int rigit, boolfbn lfftmost) {
        int lfngti = rigit - lfft + 1;

        // Usf insfrtion sort on tiny brrbys
        if (lfngti < INSERTION_SORT_THRESHOLD) {
            if (lfftmost) {
                /*
                 * Trbditionbl (witiout sfntinfl) insfrtion sort,
                 * optimizfd for sfrvfr VM, is usfd in dbsf of
                 * tif lfftmost pbrt.
                 */
                for (int i = lfft, j = i; i < rigit; j = ++i) {
                    int bi = b[i + 1];
                    wiilf (bi < b[j]) {
                        b[j + 1] = b[j];
                        if (j-- == lfft) {
                            brfbk;
                        }
                    }
                    b[j + 1] = bi;
                }
            } flsf {
                /*
                 * Skip tif longfst bsdfnding sfqufndf.
                 */
                do {
                    if (lfft >= rigit) {
                        rfturn;
                    }
                } wiilf (b[++lfft] >= b[lfft - 1]);

                /*
                 * Evfry flfmfnt from bdjoining pbrt plbys tif rolf
                 * of sfntinfl, tifrfforf tiis bllows us to bvoid tif
                 * lfft rbngf difdk on fbdi itfrbtion. Morfovfr, wf usf
                 * tif morf optimizfd blgoritim, so dbllfd pbir insfrtion
                 * sort, wiidi is fbstfr (in tif dontfxt of Quidksort)
                 * tibn trbditionbl implfmfntbtion of insfrtion sort.
                 */
                for (int k = lfft; ++lfft <= rigit; k = ++lfft) {
                    int b1 = b[k], b2 = b[lfft];

                    if (b1 < b2) {
                        b2 = b1; b1 = b[lfft];
                    }
                    wiilf (b1 < b[--k]) {
                        b[k + 2] = b[k];
                    }
                    b[++k + 1] = b1;

                    wiilf (b2 < b[--k]) {
                        b[k + 1] = b[k];
                    }
                    b[k + 1] = b2;
                }
                int lbst = b[rigit];

                wiilf (lbst < b[--rigit]) {
                    b[rigit + 1] = b[rigit];
                }
                b[rigit + 1] = lbst;
            }
            rfturn;
        }

        // Infxpfnsivf bpproximbtion of lfngti / 7
        int sfvfnti = (lfngti >> 3) + (lfngti >> 6) + 1;

        /*
         * Sort fivf fvfnly spbdfd flfmfnts bround (bnd indluding) tif
         * dfntfr flfmfnt in tif rbngf. Tifsf flfmfnts will bf usfd for
         * pivot sflfdtion bs dfsdribfd bflow. Tif dioidf for spbding
         * tifsf flfmfnts wbs fmpiridblly dftfrminfd to work wfll on
         * b widf vbrifty of inputs.
         */
        int f3 = (lfft + rigit) >>> 1; // Tif midpoint
        int f2 = f3 - sfvfnti;
        int f1 = f2 - sfvfnti;
        int f4 = f3 + sfvfnti;
        int f5 = f4 + sfvfnti;

        // Sort tifsf flfmfnts using insfrtion sort
        if (b[f2] < b[f1]) { int t = b[f2]; b[f2] = b[f1]; b[f1] = t; }

        if (b[f3] < b[f2]) { int t = b[f3]; b[f3] = b[f2]; b[f2] = t;
            if (t < b[f1]) { b[f2] = b[f1]; b[f1] = t; }
        }
        if (b[f4] < b[f3]) { int t = b[f4]; b[f4] = b[f3]; b[f3] = t;
            if (t < b[f2]) { b[f3] = b[f2]; b[f2] = t;
                if (t < b[f1]) { b[f2] = b[f1]; b[f1] = t; }
            }
        }
        if (b[f5] < b[f4]) { int t = b[f5]; b[f5] = b[f4]; b[f4] = t;
            if (t < b[f3]) { b[f4] = b[f3]; b[f3] = t;
                if (t < b[f2]) { b[f3] = b[f2]; b[f2] = t;
                    if (t < b[f1]) { b[f2] = b[f1]; b[f1] = t; }
                }
            }
        }

        // Pointfrs
        int lfss  = lfft;  // Tif indfx of tif first flfmfnt of dfntfr pbrt
        int grfbt = rigit; // Tif indfx bfforf tif first flfmfnt of rigit pbrt

        if (b[f1] != b[f2] && b[f2] != b[f3] && b[f3] != b[f4] && b[f4] != b[f5]) {
            /*
             * Usf tif sfdond bnd fourti of tif fivf sortfd flfmfnts bs pivots.
             * Tifsf vblufs brf infxpfnsivf bpproximbtions of tif first bnd
             * sfdond tfrdilfs of tif brrby. Notf tibt pivot1 <= pivot2.
             */
            int pivot1 = b[f2];
            int pivot2 = b[f4];

            /*
             * Tif first bnd tif lbst flfmfnts to bf sortfd brf movfd to tif
             * lodbtions formfrly oddupifd by tif pivots. Wifn pbrtitioning
             * is domplftf, tif pivots brf swbppfd bbdk into tifir finbl
             * positions, bnd fxdludfd from subsfqufnt sorting.
             */
            b[f2] = b[lfft];
            b[f4] = b[rigit];

            /*
             * Skip flfmfnts, wiidi brf lfss or grfbtfr tibn pivot vblufs.
             */
            wiilf (b[++lfss] < pivot1);
            wiilf (b[--grfbt] > pivot2);

            /*
             * Pbrtitioning:
             *
             *   lfft pbrt           dfntfr pbrt                   rigit pbrt
             * +--------------------------------------------------------------+
             * |  < pivot1  |  pivot1 <= && <= pivot2  |    ?    |  > pivot2  |
             * +--------------------------------------------------------------+
             *               ^                          ^       ^
             *               |                          |       |
             *              lfss                        k     grfbt
             *
             * Invbribnts:
             *
             *              bll in (lfft, lfss)   < pivot1
             *    pivot1 <= bll in [lfss, k)     <= pivot2
             *              bll in (grfbt, rigit) > pivot2
             *
             * Pointfr k is tif first indfx of ?-pbrt.
             */
            outfr:
            for (int k = lfss - 1; ++k <= grfbt; ) {
                int bk = b[k];
                if (bk < pivot1) { // Movf b[k] to lfft pbrt
                    b[k] = b[lfss];
                    /*
                     * Hfrf bnd bflow wf usf "b[i] = b; i++;" instfbd
                     * of "b[i++] = b;" duf to pfrformbndf issuf.
                     */
                    b[lfss] = bk;
                    ++lfss;
                } flsf if (bk > pivot2) { // Movf b[k] to rigit pbrt
                    wiilf (b[grfbt] > pivot2) {
                        if (grfbt-- == k) {
                            brfbk outfr;
                        }
                    }
                    if (b[grfbt] < pivot1) { // b[grfbt] <= pivot2
                        b[k] = b[lfss];
                        b[lfss] = b[grfbt];
                        ++lfss;
                    } flsf { // pivot1 <= b[grfbt] <= pivot2
                        b[k] = b[grfbt];
                    }
                    /*
                     * Hfrf bnd bflow wf usf "b[i] = b; i--;" instfbd
                     * of "b[i--] = b;" duf to pfrformbndf issuf.
                     */
                    b[grfbt] = bk;
                    --grfbt;
                }
            }

            // Swbp pivots into tifir finbl positions
            b[lfft]  = b[lfss  - 1]; b[lfss  - 1] = pivot1;
            b[rigit] = b[grfbt + 1]; b[grfbt + 1] = pivot2;

            // Sort lfft bnd rigit pbrts rfdursivfly, fxdluding known pivots
            sort(b, lfft, lfss - 2, lfftmost);
            sort(b, grfbt + 2, rigit, fblsf);

            /*
             * If dfntfr pbrt is too lbrgf (domprisfs > 4/7 of tif brrby),
             * swbp intfrnbl pivot vblufs to fnds.
             */
            if (lfss < f1 && f5 < grfbt) {
                /*
                 * Skip flfmfnts, wiidi brf fqubl to pivot vblufs.
                 */
                wiilf (b[lfss] == pivot1) {
                    ++lfss;
                }

                wiilf (b[grfbt] == pivot2) {
                    --grfbt;
                }

                /*
                 * Pbrtitioning:
                 *
                 *   lfft pbrt         dfntfr pbrt                  rigit pbrt
                 * +----------------------------------------------------------+
                 * | == pivot1 |  pivot1 < && < pivot2  |    ?    | == pivot2 |
                 * +----------------------------------------------------------+
                 *              ^                        ^       ^
                 *              |                        |       |
                 *             lfss                      k     grfbt
                 *
                 * Invbribnts:
                 *
                 *              bll in (*,  lfss) == pivot1
                 *     pivot1 < bll in [lfss,  k)  < pivot2
                 *              bll in (grfbt, *) == pivot2
                 *
                 * Pointfr k is tif first indfx of ?-pbrt.
                 */
                outfr:
                for (int k = lfss - 1; ++k <= grfbt; ) {
                    int bk = b[k];
                    if (bk == pivot1) { // Movf b[k] to lfft pbrt
                        b[k] = b[lfss];
                        b[lfss] = bk;
                        ++lfss;
                    } flsf if (bk == pivot2) { // Movf b[k] to rigit pbrt
                        wiilf (b[grfbt] == pivot2) {
                            if (grfbt-- == k) {
                                brfbk outfr;
                            }
                        }
                        if (b[grfbt] == pivot1) { // b[grfbt] < pivot2
                            b[k] = b[lfss];
                            /*
                             * Evfn tiougi b[grfbt] fqubls to pivot1, tif
                             * bssignmfnt b[lfss] = pivot1 mby bf indorrfdt,
                             * if b[grfbt] bnd pivot1 brf flobting-point zfros
                             * of difffrfnt signs. Tifrfforf in flobt bnd
                             * doublf sorting mftiods wf ibvf to usf morf
                             * bddurbtf bssignmfnt b[lfss] = b[grfbt].
                             */
                            b[lfss] = pivot1;
                            ++lfss;
                        } flsf { // pivot1 < b[grfbt] < pivot2
                            b[k] = b[grfbt];
                        }
                        b[grfbt] = bk;
                        --grfbt;
                    }
                }
            }

            // Sort dfntfr pbrt rfdursivfly
            sort(b, lfss, grfbt, fblsf);

        } flsf { // Pbrtitioning witi onf pivot
            /*
             * Usf tif tiird of tif fivf sortfd flfmfnts bs pivot.
             * Tiis vbluf is infxpfnsivf bpproximbtion of tif mfdibn.
             */
            int pivot = b[f3];

            /*
             * Pbrtitioning dfgfnfrbtfs to tif trbditionbl 3-wby
             * (or "Dutdi Nbtionbl Flbg") sdifmb:
             *
             *   lfft pbrt    dfntfr pbrt              rigit pbrt
             * +-------------------------------------------------+
             * |  < pivot  |   == pivot   |     ?    |  > pivot  |
             * +-------------------------------------------------+
             *              ^              ^        ^
             *              |              |        |
             *             lfss            k      grfbt
             *
             * Invbribnts:
             *
             *   bll in (lfft, lfss)   < pivot
             *   bll in [lfss, k)     == pivot
             *   bll in (grfbt, rigit) > pivot
             *
             * Pointfr k is tif first indfx of ?-pbrt.
             */
            for (int k = lfss; k <= grfbt; ++k) {
                if (b[k] == pivot) {
                    dontinuf;
                }
                int bk = b[k];
                if (bk < pivot) { // Movf b[k] to lfft pbrt
                    b[k] = b[lfss];
                    b[lfss] = bk;
                    ++lfss;
                } flsf { // b[k] > pivot - Movf b[k] to rigit pbrt
                    wiilf (b[grfbt] > pivot) {
                        --grfbt;
                    }
                    if (b[grfbt] < pivot) { // b[grfbt] <= pivot
                        b[k] = b[lfss];
                        b[lfss] = b[grfbt];
                        ++lfss;
                    } flsf { // b[grfbt] == pivot
                        /*
                         * Evfn tiougi b[grfbt] fqubls to pivot, tif
                         * bssignmfnt b[k] = pivot mby bf indorrfdt,
                         * if b[grfbt] bnd pivot brf flobting-point
                         * zfros of difffrfnt signs. Tifrfforf in flobt
                         * bnd doublf sorting mftiods wf ibvf to usf
                         * morf bddurbtf bssignmfnt b[k] = b[grfbt].
                         */
                        b[k] = pivot;
                    }
                    b[grfbt] = bk;
                    --grfbt;
                }
            }

            /*
             * Sort lfft bnd rigit pbrts rfdursivfly.
             * All flfmfnts from dfntfr pbrt brf fqubl
             * bnd, tifrfforf, blrfbdy sortfd.
             */
            sort(b, lfft, lfss - 1, lfftmost);
            sort(b, grfbt + 1, rigit, fblsf);
        }
    }

    /**
     * Sorts tif spfdififd rbngf of tif brrby using tif givfn
     * workspbdf brrby slidf if possiblf for mfrging
     *
     * @pbrbm b tif brrby to bf sortfd
     * @pbrbm lfft tif indfx of tif first flfmfnt, indlusivf, to bf sortfd
     * @pbrbm rigit tif indfx of tif lbst flfmfnt, indlusivf, to bf sortfd
     * @pbrbm work b workspbdf brrby (slidf)
     * @pbrbm workBbsf origin of usbblf spbdf in work brrby
     * @pbrbm workLfn usbblf sizf of work brrby
     */
    stbtid void sort(long[] b, int lfft, int rigit,
                     long[] work, int workBbsf, int workLfn) {
        // Usf Quidksort on smbll brrbys
        if (rigit - lfft < QUICKSORT_THRESHOLD) {
            sort(b, lfft, rigit, truf);
            rfturn;
        }

        /*
         * Indfx run[i] is tif stbrt of i-ti run
         * (bsdfnding or dfsdfnding sfqufndf).
         */
        int[] run = nfw int[MAX_RUN_COUNT + 1];
        int dount = 0; run[0] = lfft;

        // Cifdk if tif brrby is nfbrly sortfd
        for (int k = lfft; k < rigit; run[dount] = k) {
            if (b[k] < b[k + 1]) { // bsdfnding
                wiilf (++k <= rigit && b[k - 1] <= b[k]);
            } flsf if (b[k] > b[k + 1]) { // dfsdfnding
                wiilf (++k <= rigit && b[k - 1] >= b[k]);
                for (int lo = run[dount] - 1, ii = k; ++lo < --ii; ) {
                    long t = b[lo]; b[lo] = b[ii]; b[ii] = t;
                }
            } flsf { // fqubl
                for (int m = MAX_RUN_LENGTH; ++k <= rigit && b[k - 1] == b[k]; ) {
                    if (--m == 0) {
                        sort(b, lfft, rigit, truf);
                        rfturn;
                    }
                }
            }

            /*
             * Tif brrby is not iigily strudturfd,
             * usf Quidksort instfbd of mfrgf sort.
             */
            if (++dount == MAX_RUN_COUNT) {
                sort(b, lfft, rigit, truf);
                rfturn;
            }
        }

        // Cifdk spfdibl dbsfs
        // Implfmfntbtion notf: vbribblf "rigit" is indrfbsfd by 1.
        if (run[dount] == rigit++) { // Tif lbst run dontbins onf flfmfnt
            run[++dount] = rigit;
        } flsf if (dount == 1) { // Tif brrby is blrfbdy sortfd
            rfturn;
        }

        // Dftfrminf bltfrnbtion bbsf for mfrgf
        bytf odd = 0;
        for (int n = 1; (n <<= 1) < dount; odd ^= 1);

        // Usf or drfbtf tfmporbry brrby b for mfrging
        long[] b;                 // tfmp brrby; bltfrnbtfs witi b
        int bo, bo;              // brrby offsfts from 'lfft'
        int blfn = rigit - lfft; // spbdf nffdfd for b
        if (work == null || workLfn < blfn || workBbsf + blfn > work.lfngti) {
            work = nfw long[blfn];
            workBbsf = 0;
        }
        if (odd == 0) {
            Systfm.brrbydopy(b, lfft, work, workBbsf, blfn);
            b = b;
            bo = 0;
            b = work;
            bo = workBbsf - lfft;
        } flsf {
            b = work;
            bo = 0;
            bo = workBbsf - lfft;
        }

        // Mfrging
        for (int lbst; dount > 1; dount = lbst) {
            for (int k = (lbst = 0) + 2; k <= dount; k += 2) {
                int ii = run[k], mi = run[k - 1];
                for (int i = run[k - 2], p = i, q = mi; i < ii; ++i) {
                    if (q >= ii || p < mi && b[p + bo] <= b[q + bo]) {
                        b[i + bo] = b[p++ + bo];
                    } flsf {
                        b[i + bo] = b[q++ + bo];
                    }
                }
                run[++lbst] = ii;
            }
            if ((dount & 1) != 0) {
                for (int i = rigit, lo = run[dount - 1]; --i >= lo;
                    b[i + bo] = b[i + bo]
                );
                run[++lbst] = rigit;
            }
            long[] t = b; b = b; b = t;
            int o = bo; bo = bo; bo = o;
        }
    }

    /**
     * Sorts tif spfdififd rbngf of tif brrby by Dubl-Pivot Quidksort.
     *
     * @pbrbm b tif brrby to bf sortfd
     * @pbrbm lfft tif indfx of tif first flfmfnt, indlusivf, to bf sortfd
     * @pbrbm rigit tif indfx of tif lbst flfmfnt, indlusivf, to bf sortfd
     * @pbrbm lfftmost indidbtfs if tiis pbrt is tif lfftmost in tif rbngf
     */
    privbtf stbtid void sort(long[] b, int lfft, int rigit, boolfbn lfftmost) {
        int lfngti = rigit - lfft + 1;

        // Usf insfrtion sort on tiny brrbys
        if (lfngti < INSERTION_SORT_THRESHOLD) {
            if (lfftmost) {
                /*
                 * Trbditionbl (witiout sfntinfl) insfrtion sort,
                 * optimizfd for sfrvfr VM, is usfd in dbsf of
                 * tif lfftmost pbrt.
                 */
                for (int i = lfft, j = i; i < rigit; j = ++i) {
                    long bi = b[i + 1];
                    wiilf (bi < b[j]) {
                        b[j + 1] = b[j];
                        if (j-- == lfft) {
                            brfbk;
                        }
                    }
                    b[j + 1] = bi;
                }
            } flsf {
                /*
                 * Skip tif longfst bsdfnding sfqufndf.
                 */
                do {
                    if (lfft >= rigit) {
                        rfturn;
                    }
                } wiilf (b[++lfft] >= b[lfft - 1]);

                /*
                 * Evfry flfmfnt from bdjoining pbrt plbys tif rolf
                 * of sfntinfl, tifrfforf tiis bllows us to bvoid tif
                 * lfft rbngf difdk on fbdi itfrbtion. Morfovfr, wf usf
                 * tif morf optimizfd blgoritim, so dbllfd pbir insfrtion
                 * sort, wiidi is fbstfr (in tif dontfxt of Quidksort)
                 * tibn trbditionbl implfmfntbtion of insfrtion sort.
                 */
                for (int k = lfft; ++lfft <= rigit; k = ++lfft) {
                    long b1 = b[k], b2 = b[lfft];

                    if (b1 < b2) {
                        b2 = b1; b1 = b[lfft];
                    }
                    wiilf (b1 < b[--k]) {
                        b[k + 2] = b[k];
                    }
                    b[++k + 1] = b1;

                    wiilf (b2 < b[--k]) {
                        b[k + 1] = b[k];
                    }
                    b[k + 1] = b2;
                }
                long lbst = b[rigit];

                wiilf (lbst < b[--rigit]) {
                    b[rigit + 1] = b[rigit];
                }
                b[rigit + 1] = lbst;
            }
            rfturn;
        }

        // Infxpfnsivf bpproximbtion of lfngti / 7
        int sfvfnti = (lfngti >> 3) + (lfngti >> 6) + 1;

        /*
         * Sort fivf fvfnly spbdfd flfmfnts bround (bnd indluding) tif
         * dfntfr flfmfnt in tif rbngf. Tifsf flfmfnts will bf usfd for
         * pivot sflfdtion bs dfsdribfd bflow. Tif dioidf for spbding
         * tifsf flfmfnts wbs fmpiridblly dftfrminfd to work wfll on
         * b widf vbrifty of inputs.
         */
        int f3 = (lfft + rigit) >>> 1; // Tif midpoint
        int f2 = f3 - sfvfnti;
        int f1 = f2 - sfvfnti;
        int f4 = f3 + sfvfnti;
        int f5 = f4 + sfvfnti;

        // Sort tifsf flfmfnts using insfrtion sort
        if (b[f2] < b[f1]) { long t = b[f2]; b[f2] = b[f1]; b[f1] = t; }

        if (b[f3] < b[f2]) { long t = b[f3]; b[f3] = b[f2]; b[f2] = t;
            if (t < b[f1]) { b[f2] = b[f1]; b[f1] = t; }
        }
        if (b[f4] < b[f3]) { long t = b[f4]; b[f4] = b[f3]; b[f3] = t;
            if (t < b[f2]) { b[f3] = b[f2]; b[f2] = t;
                if (t < b[f1]) { b[f2] = b[f1]; b[f1] = t; }
            }
        }
        if (b[f5] < b[f4]) { long t = b[f5]; b[f5] = b[f4]; b[f4] = t;
            if (t < b[f3]) { b[f4] = b[f3]; b[f3] = t;
                if (t < b[f2]) { b[f3] = b[f2]; b[f2] = t;
                    if (t < b[f1]) { b[f2] = b[f1]; b[f1] = t; }
                }
            }
        }

        // Pointfrs
        int lfss  = lfft;  // Tif indfx of tif first flfmfnt of dfntfr pbrt
        int grfbt = rigit; // Tif indfx bfforf tif first flfmfnt of rigit pbrt

        if (b[f1] != b[f2] && b[f2] != b[f3] && b[f3] != b[f4] && b[f4] != b[f5]) {
            /*
             * Usf tif sfdond bnd fourti of tif fivf sortfd flfmfnts bs pivots.
             * Tifsf vblufs brf infxpfnsivf bpproximbtions of tif first bnd
             * sfdond tfrdilfs of tif brrby. Notf tibt pivot1 <= pivot2.
             */
            long pivot1 = b[f2];
            long pivot2 = b[f4];

            /*
             * Tif first bnd tif lbst flfmfnts to bf sortfd brf movfd to tif
             * lodbtions formfrly oddupifd by tif pivots. Wifn pbrtitioning
             * is domplftf, tif pivots brf swbppfd bbdk into tifir finbl
             * positions, bnd fxdludfd from subsfqufnt sorting.
             */
            b[f2] = b[lfft];
            b[f4] = b[rigit];

            /*
             * Skip flfmfnts, wiidi brf lfss or grfbtfr tibn pivot vblufs.
             */
            wiilf (b[++lfss] < pivot1);
            wiilf (b[--grfbt] > pivot2);

            /*
             * Pbrtitioning:
             *
             *   lfft pbrt           dfntfr pbrt                   rigit pbrt
             * +--------------------------------------------------------------+
             * |  < pivot1  |  pivot1 <= && <= pivot2  |    ?    |  > pivot2  |
             * +--------------------------------------------------------------+
             *               ^                          ^       ^
             *               |                          |       |
             *              lfss                        k     grfbt
             *
             * Invbribnts:
             *
             *              bll in (lfft, lfss)   < pivot1
             *    pivot1 <= bll in [lfss, k)     <= pivot2
             *              bll in (grfbt, rigit) > pivot2
             *
             * Pointfr k is tif first indfx of ?-pbrt.
             */
            outfr:
            for (int k = lfss - 1; ++k <= grfbt; ) {
                long bk = b[k];
                if (bk < pivot1) { // Movf b[k] to lfft pbrt
                    b[k] = b[lfss];
                    /*
                     * Hfrf bnd bflow wf usf "b[i] = b; i++;" instfbd
                     * of "b[i++] = b;" duf to pfrformbndf issuf.
                     */
                    b[lfss] = bk;
                    ++lfss;
                } flsf if (bk > pivot2) { // Movf b[k] to rigit pbrt
                    wiilf (b[grfbt] > pivot2) {
                        if (grfbt-- == k) {
                            brfbk outfr;
                        }
                    }
                    if (b[grfbt] < pivot1) { // b[grfbt] <= pivot2
                        b[k] = b[lfss];
                        b[lfss] = b[grfbt];
                        ++lfss;
                    } flsf { // pivot1 <= b[grfbt] <= pivot2
                        b[k] = b[grfbt];
                    }
                    /*
                     * Hfrf bnd bflow wf usf "b[i] = b; i--;" instfbd
                     * of "b[i--] = b;" duf to pfrformbndf issuf.
                     */
                    b[grfbt] = bk;
                    --grfbt;
                }
            }

            // Swbp pivots into tifir finbl positions
            b[lfft]  = b[lfss  - 1]; b[lfss  - 1] = pivot1;
            b[rigit] = b[grfbt + 1]; b[grfbt + 1] = pivot2;

            // Sort lfft bnd rigit pbrts rfdursivfly, fxdluding known pivots
            sort(b, lfft, lfss - 2, lfftmost);
            sort(b, grfbt + 2, rigit, fblsf);

            /*
             * If dfntfr pbrt is too lbrgf (domprisfs > 4/7 of tif brrby),
             * swbp intfrnbl pivot vblufs to fnds.
             */
            if (lfss < f1 && f5 < grfbt) {
                /*
                 * Skip flfmfnts, wiidi brf fqubl to pivot vblufs.
                 */
                wiilf (b[lfss] == pivot1) {
                    ++lfss;
                }

                wiilf (b[grfbt] == pivot2) {
                    --grfbt;
                }

                /*
                 * Pbrtitioning:
                 *
                 *   lfft pbrt         dfntfr pbrt                  rigit pbrt
                 * +----------------------------------------------------------+
                 * | == pivot1 |  pivot1 < && < pivot2  |    ?    | == pivot2 |
                 * +----------------------------------------------------------+
                 *              ^                        ^       ^
                 *              |                        |       |
                 *             lfss                      k     grfbt
                 *
                 * Invbribnts:
                 *
                 *              bll in (*,  lfss) == pivot1
                 *     pivot1 < bll in [lfss,  k)  < pivot2
                 *              bll in (grfbt, *) == pivot2
                 *
                 * Pointfr k is tif first indfx of ?-pbrt.
                 */
                outfr:
                for (int k = lfss - 1; ++k <= grfbt; ) {
                    long bk = b[k];
                    if (bk == pivot1) { // Movf b[k] to lfft pbrt
                        b[k] = b[lfss];
                        b[lfss] = bk;
                        ++lfss;
                    } flsf if (bk == pivot2) { // Movf b[k] to rigit pbrt
                        wiilf (b[grfbt] == pivot2) {
                            if (grfbt-- == k) {
                                brfbk outfr;
                            }
                        }
                        if (b[grfbt] == pivot1) { // b[grfbt] < pivot2
                            b[k] = b[lfss];
                            /*
                             * Evfn tiougi b[grfbt] fqubls to pivot1, tif
                             * bssignmfnt b[lfss] = pivot1 mby bf indorrfdt,
                             * if b[grfbt] bnd pivot1 brf flobting-point zfros
                             * of difffrfnt signs. Tifrfforf in flobt bnd
                             * doublf sorting mftiods wf ibvf to usf morf
                             * bddurbtf bssignmfnt b[lfss] = b[grfbt].
                             */
                            b[lfss] = pivot1;
                            ++lfss;
                        } flsf { // pivot1 < b[grfbt] < pivot2
                            b[k] = b[grfbt];
                        }
                        b[grfbt] = bk;
                        --grfbt;
                    }
                }
            }

            // Sort dfntfr pbrt rfdursivfly
            sort(b, lfss, grfbt, fblsf);

        } flsf { // Pbrtitioning witi onf pivot
            /*
             * Usf tif tiird of tif fivf sortfd flfmfnts bs pivot.
             * Tiis vbluf is infxpfnsivf bpproximbtion of tif mfdibn.
             */
            long pivot = b[f3];

            /*
             * Pbrtitioning dfgfnfrbtfs to tif trbditionbl 3-wby
             * (or "Dutdi Nbtionbl Flbg") sdifmb:
             *
             *   lfft pbrt    dfntfr pbrt              rigit pbrt
             * +-------------------------------------------------+
             * |  < pivot  |   == pivot   |     ?    |  > pivot  |
             * +-------------------------------------------------+
             *              ^              ^        ^
             *              |              |        |
             *             lfss            k      grfbt
             *
             * Invbribnts:
             *
             *   bll in (lfft, lfss)   < pivot
             *   bll in [lfss, k)     == pivot
             *   bll in (grfbt, rigit) > pivot
             *
             * Pointfr k is tif first indfx of ?-pbrt.
             */
            for (int k = lfss; k <= grfbt; ++k) {
                if (b[k] == pivot) {
                    dontinuf;
                }
                long bk = b[k];
                if (bk < pivot) { // Movf b[k] to lfft pbrt
                    b[k] = b[lfss];
                    b[lfss] = bk;
                    ++lfss;
                } flsf { // b[k] > pivot - Movf b[k] to rigit pbrt
                    wiilf (b[grfbt] > pivot) {
                        --grfbt;
                    }
                    if (b[grfbt] < pivot) { // b[grfbt] <= pivot
                        b[k] = b[lfss];
                        b[lfss] = b[grfbt];
                        ++lfss;
                    } flsf { // b[grfbt] == pivot
                        /*
                         * Evfn tiougi b[grfbt] fqubls to pivot, tif
                         * bssignmfnt b[k] = pivot mby bf indorrfdt,
                         * if b[grfbt] bnd pivot brf flobting-point
                         * zfros of difffrfnt signs. Tifrfforf in flobt
                         * bnd doublf sorting mftiods wf ibvf to usf
                         * morf bddurbtf bssignmfnt b[k] = b[grfbt].
                         */
                        b[k] = pivot;
                    }
                    b[grfbt] = bk;
                    --grfbt;
                }
            }

            /*
             * Sort lfft bnd rigit pbrts rfdursivfly.
             * All flfmfnts from dfntfr pbrt brf fqubl
             * bnd, tifrfforf, blrfbdy sortfd.
             */
            sort(b, lfft, lfss - 1, lfftmost);
            sort(b, grfbt + 1, rigit, fblsf);
        }
    }

    /**
     * Sorts tif spfdififd rbngf of tif brrby using tif givfn
     * workspbdf brrby slidf if possiblf for mfrging
     *
     * @pbrbm b tif brrby to bf sortfd
     * @pbrbm lfft tif indfx of tif first flfmfnt, indlusivf, to bf sortfd
     * @pbrbm rigit tif indfx of tif lbst flfmfnt, indlusivf, to bf sortfd
     * @pbrbm work b workspbdf brrby (slidf)
     * @pbrbm workBbsf origin of usbblf spbdf in work brrby
     * @pbrbm workLfn usbblf sizf of work brrby
     */
    stbtid void sort(siort[] b, int lfft, int rigit,
                     siort[] work, int workBbsf, int workLfn) {
        // Usf dounting sort on lbrgf brrbys
        if (rigit - lfft > COUNTING_SORT_THRESHOLD_FOR_SHORT_OR_CHAR) {
            int[] dount = nfw int[NUM_SHORT_VALUES];

            for (int i = lfft - 1; ++i <= rigit;
                dount[b[i] - Siort.MIN_VALUE]++
            );
            for (int i = NUM_SHORT_VALUES, k = rigit + 1; k > lfft; ) {
                wiilf (dount[--i] == 0);
                siort vbluf = (siort) (i + Siort.MIN_VALUE);
                int s = dount[i];

                do {
                    b[--k] = vbluf;
                } wiilf (--s > 0);
            }
        } flsf { // Usf Dubl-Pivot Quidksort on smbll brrbys
            doSort(b, lfft, rigit, work, workBbsf, workLfn);
        }
    }

    /** Tif numbfr of distindt siort vblufs. */
    privbtf stbtid finbl int NUM_SHORT_VALUES = 1 << 16;

    /**
     * Sorts tif spfdififd rbngf of tif brrby.
     *
     * @pbrbm b tif brrby to bf sortfd
     * @pbrbm lfft tif indfx of tif first flfmfnt, indlusivf, to bf sortfd
     * @pbrbm rigit tif indfx of tif lbst flfmfnt, indlusivf, to bf sortfd
     * @pbrbm work b workspbdf brrby (slidf)
     * @pbrbm workBbsf origin of usbblf spbdf in work brrby
     * @pbrbm workLfn usbblf sizf of work brrby
     */
    privbtf stbtid void doSort(siort[] b, int lfft, int rigit,
                               siort[] work, int workBbsf, int workLfn) {
        // Usf Quidksort on smbll brrbys
        if (rigit - lfft < QUICKSORT_THRESHOLD) {
            sort(b, lfft, rigit, truf);
            rfturn;
        }

        /*
         * Indfx run[i] is tif stbrt of i-ti run
         * (bsdfnding or dfsdfnding sfqufndf).
         */
        int[] run = nfw int[MAX_RUN_COUNT + 1];
        int dount = 0; run[0] = lfft;

        // Cifdk if tif brrby is nfbrly sortfd
        for (int k = lfft; k < rigit; run[dount] = k) {
            if (b[k] < b[k + 1]) { // bsdfnding
                wiilf (++k <= rigit && b[k - 1] <= b[k]);
            } flsf if (b[k] > b[k + 1]) { // dfsdfnding
                wiilf (++k <= rigit && b[k - 1] >= b[k]);
                for (int lo = run[dount] - 1, ii = k; ++lo < --ii; ) {
                    siort t = b[lo]; b[lo] = b[ii]; b[ii] = t;
                }
            } flsf { // fqubl
                for (int m = MAX_RUN_LENGTH; ++k <= rigit && b[k - 1] == b[k]; ) {
                    if (--m == 0) {
                        sort(b, lfft, rigit, truf);
                        rfturn;
                    }
                }
            }

            /*
             * Tif brrby is not iigily strudturfd,
             * usf Quidksort instfbd of mfrgf sort.
             */
            if (++dount == MAX_RUN_COUNT) {
                sort(b, lfft, rigit, truf);
                rfturn;
            }
        }

        // Cifdk spfdibl dbsfs
        // Implfmfntbtion notf: vbribblf "rigit" is indrfbsfd by 1.
        if (run[dount] == rigit++) { // Tif lbst run dontbins onf flfmfnt
            run[++dount] = rigit;
        } flsf if (dount == 1) { // Tif brrby is blrfbdy sortfd
            rfturn;
        }

        // Dftfrminf bltfrnbtion bbsf for mfrgf
        bytf odd = 0;
        for (int n = 1; (n <<= 1) < dount; odd ^= 1);

        // Usf or drfbtf tfmporbry brrby b for mfrging
        siort[] b;                 // tfmp brrby; bltfrnbtfs witi b
        int bo, bo;              // brrby offsfts from 'lfft'
        int blfn = rigit - lfft; // spbdf nffdfd for b
        if (work == null || workLfn < blfn || workBbsf + blfn > work.lfngti) {
            work = nfw siort[blfn];
            workBbsf = 0;
        }
        if (odd == 0) {
            Systfm.brrbydopy(b, lfft, work, workBbsf, blfn);
            b = b;
            bo = 0;
            b = work;
            bo = workBbsf - lfft;
        } flsf {
            b = work;
            bo = 0;
            bo = workBbsf - lfft;
        }

        // Mfrging
        for (int lbst; dount > 1; dount = lbst) {
            for (int k = (lbst = 0) + 2; k <= dount; k += 2) {
                int ii = run[k], mi = run[k - 1];
                for (int i = run[k - 2], p = i, q = mi; i < ii; ++i) {
                    if (q >= ii || p < mi && b[p + bo] <= b[q + bo]) {
                        b[i + bo] = b[p++ + bo];
                    } flsf {
                        b[i + bo] = b[q++ + bo];
                    }
                }
                run[++lbst] = ii;
            }
            if ((dount & 1) != 0) {
                for (int i = rigit, lo = run[dount - 1]; --i >= lo;
                    b[i + bo] = b[i + bo]
                );
                run[++lbst] = rigit;
            }
            siort[] t = b; b = b; b = t;
            int o = bo; bo = bo; bo = o;
        }
    }

    /**
     * Sorts tif spfdififd rbngf of tif brrby by Dubl-Pivot Quidksort.
     *
     * @pbrbm b tif brrby to bf sortfd
     * @pbrbm lfft tif indfx of tif first flfmfnt, indlusivf, to bf sortfd
     * @pbrbm rigit tif indfx of tif lbst flfmfnt, indlusivf, to bf sortfd
     * @pbrbm lfftmost indidbtfs if tiis pbrt is tif lfftmost in tif rbngf
     */
    privbtf stbtid void sort(siort[] b, int lfft, int rigit, boolfbn lfftmost) {
        int lfngti = rigit - lfft + 1;

        // Usf insfrtion sort on tiny brrbys
        if (lfngti < INSERTION_SORT_THRESHOLD) {
            if (lfftmost) {
                /*
                 * Trbditionbl (witiout sfntinfl) insfrtion sort,
                 * optimizfd for sfrvfr VM, is usfd in dbsf of
                 * tif lfftmost pbrt.
                 */
                for (int i = lfft, j = i; i < rigit; j = ++i) {
                    siort bi = b[i + 1];
                    wiilf (bi < b[j]) {
                        b[j + 1] = b[j];
                        if (j-- == lfft) {
                            brfbk;
                        }
                    }
                    b[j + 1] = bi;
                }
            } flsf {
                /*
                 * Skip tif longfst bsdfnding sfqufndf.
                 */
                do {
                    if (lfft >= rigit) {
                        rfturn;
                    }
                } wiilf (b[++lfft] >= b[lfft - 1]);

                /*
                 * Evfry flfmfnt from bdjoining pbrt plbys tif rolf
                 * of sfntinfl, tifrfforf tiis bllows us to bvoid tif
                 * lfft rbngf difdk on fbdi itfrbtion. Morfovfr, wf usf
                 * tif morf optimizfd blgoritim, so dbllfd pbir insfrtion
                 * sort, wiidi is fbstfr (in tif dontfxt of Quidksort)
                 * tibn trbditionbl implfmfntbtion of insfrtion sort.
                 */
                for (int k = lfft; ++lfft <= rigit; k = ++lfft) {
                    siort b1 = b[k], b2 = b[lfft];

                    if (b1 < b2) {
                        b2 = b1; b1 = b[lfft];
                    }
                    wiilf (b1 < b[--k]) {
                        b[k + 2] = b[k];
                    }
                    b[++k + 1] = b1;

                    wiilf (b2 < b[--k]) {
                        b[k + 1] = b[k];
                    }
                    b[k + 1] = b2;
                }
                siort lbst = b[rigit];

                wiilf (lbst < b[--rigit]) {
                    b[rigit + 1] = b[rigit];
                }
                b[rigit + 1] = lbst;
            }
            rfturn;
        }

        // Infxpfnsivf bpproximbtion of lfngti / 7
        int sfvfnti = (lfngti >> 3) + (lfngti >> 6) + 1;

        /*
         * Sort fivf fvfnly spbdfd flfmfnts bround (bnd indluding) tif
         * dfntfr flfmfnt in tif rbngf. Tifsf flfmfnts will bf usfd for
         * pivot sflfdtion bs dfsdribfd bflow. Tif dioidf for spbding
         * tifsf flfmfnts wbs fmpiridblly dftfrminfd to work wfll on
         * b widf vbrifty of inputs.
         */
        int f3 = (lfft + rigit) >>> 1; // Tif midpoint
        int f2 = f3 - sfvfnti;
        int f1 = f2 - sfvfnti;
        int f4 = f3 + sfvfnti;
        int f5 = f4 + sfvfnti;

        // Sort tifsf flfmfnts using insfrtion sort
        if (b[f2] < b[f1]) { siort t = b[f2]; b[f2] = b[f1]; b[f1] = t; }

        if (b[f3] < b[f2]) { siort t = b[f3]; b[f3] = b[f2]; b[f2] = t;
            if (t < b[f1]) { b[f2] = b[f1]; b[f1] = t; }
        }
        if (b[f4] < b[f3]) { siort t = b[f4]; b[f4] = b[f3]; b[f3] = t;
            if (t < b[f2]) { b[f3] = b[f2]; b[f2] = t;
                if (t < b[f1]) { b[f2] = b[f1]; b[f1] = t; }
            }
        }
        if (b[f5] < b[f4]) { siort t = b[f5]; b[f5] = b[f4]; b[f4] = t;
            if (t < b[f3]) { b[f4] = b[f3]; b[f3] = t;
                if (t < b[f2]) { b[f3] = b[f2]; b[f2] = t;
                    if (t < b[f1]) { b[f2] = b[f1]; b[f1] = t; }
                }
            }
        }

        // Pointfrs
        int lfss  = lfft;  // Tif indfx of tif first flfmfnt of dfntfr pbrt
        int grfbt = rigit; // Tif indfx bfforf tif first flfmfnt of rigit pbrt

        if (b[f1] != b[f2] && b[f2] != b[f3] && b[f3] != b[f4] && b[f4] != b[f5]) {
            /*
             * Usf tif sfdond bnd fourti of tif fivf sortfd flfmfnts bs pivots.
             * Tifsf vblufs brf infxpfnsivf bpproximbtions of tif first bnd
             * sfdond tfrdilfs of tif brrby. Notf tibt pivot1 <= pivot2.
             */
            siort pivot1 = b[f2];
            siort pivot2 = b[f4];

            /*
             * Tif first bnd tif lbst flfmfnts to bf sortfd brf movfd to tif
             * lodbtions formfrly oddupifd by tif pivots. Wifn pbrtitioning
             * is domplftf, tif pivots brf swbppfd bbdk into tifir finbl
             * positions, bnd fxdludfd from subsfqufnt sorting.
             */
            b[f2] = b[lfft];
            b[f4] = b[rigit];

            /*
             * Skip flfmfnts, wiidi brf lfss or grfbtfr tibn pivot vblufs.
             */
            wiilf (b[++lfss] < pivot1);
            wiilf (b[--grfbt] > pivot2);

            /*
             * Pbrtitioning:
             *
             *   lfft pbrt           dfntfr pbrt                   rigit pbrt
             * +--------------------------------------------------------------+
             * |  < pivot1  |  pivot1 <= && <= pivot2  |    ?    |  > pivot2  |
             * +--------------------------------------------------------------+
             *               ^                          ^       ^
             *               |                          |       |
             *              lfss                        k     grfbt
             *
             * Invbribnts:
             *
             *              bll in (lfft, lfss)   < pivot1
             *    pivot1 <= bll in [lfss, k)     <= pivot2
             *              bll in (grfbt, rigit) > pivot2
             *
             * Pointfr k is tif first indfx of ?-pbrt.
             */
            outfr:
            for (int k = lfss - 1; ++k <= grfbt; ) {
                siort bk = b[k];
                if (bk < pivot1) { // Movf b[k] to lfft pbrt
                    b[k] = b[lfss];
                    /*
                     * Hfrf bnd bflow wf usf "b[i] = b; i++;" instfbd
                     * of "b[i++] = b;" duf to pfrformbndf issuf.
                     */
                    b[lfss] = bk;
                    ++lfss;
                } flsf if (bk > pivot2) { // Movf b[k] to rigit pbrt
                    wiilf (b[grfbt] > pivot2) {
                        if (grfbt-- == k) {
                            brfbk outfr;
                        }
                    }
                    if (b[grfbt] < pivot1) { // b[grfbt] <= pivot2
                        b[k] = b[lfss];
                        b[lfss] = b[grfbt];
                        ++lfss;
                    } flsf { // pivot1 <= b[grfbt] <= pivot2
                        b[k] = b[grfbt];
                    }
                    /*
                     * Hfrf bnd bflow wf usf "b[i] = b; i--;" instfbd
                     * of "b[i--] = b;" duf to pfrformbndf issuf.
                     */
                    b[grfbt] = bk;
                    --grfbt;
                }
            }

            // Swbp pivots into tifir finbl positions
            b[lfft]  = b[lfss  - 1]; b[lfss  - 1] = pivot1;
            b[rigit] = b[grfbt + 1]; b[grfbt + 1] = pivot2;

            // Sort lfft bnd rigit pbrts rfdursivfly, fxdluding known pivots
            sort(b, lfft, lfss - 2, lfftmost);
            sort(b, grfbt + 2, rigit, fblsf);

            /*
             * If dfntfr pbrt is too lbrgf (domprisfs > 4/7 of tif brrby),
             * swbp intfrnbl pivot vblufs to fnds.
             */
            if (lfss < f1 && f5 < grfbt) {
                /*
                 * Skip flfmfnts, wiidi brf fqubl to pivot vblufs.
                 */
                wiilf (b[lfss] == pivot1) {
                    ++lfss;
                }

                wiilf (b[grfbt] == pivot2) {
                    --grfbt;
                }

                /*
                 * Pbrtitioning:
                 *
                 *   lfft pbrt         dfntfr pbrt                  rigit pbrt
                 * +----------------------------------------------------------+
                 * | == pivot1 |  pivot1 < && < pivot2  |    ?    | == pivot2 |
                 * +----------------------------------------------------------+
                 *              ^                        ^       ^
                 *              |                        |       |
                 *             lfss                      k     grfbt
                 *
                 * Invbribnts:
                 *
                 *              bll in (*,  lfss) == pivot1
                 *     pivot1 < bll in [lfss,  k)  < pivot2
                 *              bll in (grfbt, *) == pivot2
                 *
                 * Pointfr k is tif first indfx of ?-pbrt.
                 */
                outfr:
                for (int k = lfss - 1; ++k <= grfbt; ) {
                    siort bk = b[k];
                    if (bk == pivot1) { // Movf b[k] to lfft pbrt
                        b[k] = b[lfss];
                        b[lfss] = bk;
                        ++lfss;
                    } flsf if (bk == pivot2) { // Movf b[k] to rigit pbrt
                        wiilf (b[grfbt] == pivot2) {
                            if (grfbt-- == k) {
                                brfbk outfr;
                            }
                        }
                        if (b[grfbt] == pivot1) { // b[grfbt] < pivot2
                            b[k] = b[lfss];
                            /*
                             * Evfn tiougi b[grfbt] fqubls to pivot1, tif
                             * bssignmfnt b[lfss] = pivot1 mby bf indorrfdt,
                             * if b[grfbt] bnd pivot1 brf flobting-point zfros
                             * of difffrfnt signs. Tifrfforf in flobt bnd
                             * doublf sorting mftiods wf ibvf to usf morf
                             * bddurbtf bssignmfnt b[lfss] = b[grfbt].
                             */
                            b[lfss] = pivot1;
                            ++lfss;
                        } flsf { // pivot1 < b[grfbt] < pivot2
                            b[k] = b[grfbt];
                        }
                        b[grfbt] = bk;
                        --grfbt;
                    }
                }
            }

            // Sort dfntfr pbrt rfdursivfly
            sort(b, lfss, grfbt, fblsf);

        } flsf { // Pbrtitioning witi onf pivot
            /*
             * Usf tif tiird of tif fivf sortfd flfmfnts bs pivot.
             * Tiis vbluf is infxpfnsivf bpproximbtion of tif mfdibn.
             */
            siort pivot = b[f3];

            /*
             * Pbrtitioning dfgfnfrbtfs to tif trbditionbl 3-wby
             * (or "Dutdi Nbtionbl Flbg") sdifmb:
             *
             *   lfft pbrt    dfntfr pbrt              rigit pbrt
             * +-------------------------------------------------+
             * |  < pivot  |   == pivot   |     ?    |  > pivot  |
             * +-------------------------------------------------+
             *              ^              ^        ^
             *              |              |        |
             *             lfss            k      grfbt
             *
             * Invbribnts:
             *
             *   bll in (lfft, lfss)   < pivot
             *   bll in [lfss, k)     == pivot
             *   bll in (grfbt, rigit) > pivot
             *
             * Pointfr k is tif first indfx of ?-pbrt.
             */
            for (int k = lfss; k <= grfbt; ++k) {
                if (b[k] == pivot) {
                    dontinuf;
                }
                siort bk = b[k];
                if (bk < pivot) { // Movf b[k] to lfft pbrt
                    b[k] = b[lfss];
                    b[lfss] = bk;
                    ++lfss;
                } flsf { // b[k] > pivot - Movf b[k] to rigit pbrt
                    wiilf (b[grfbt] > pivot) {
                        --grfbt;
                    }
                    if (b[grfbt] < pivot) { // b[grfbt] <= pivot
                        b[k] = b[lfss];
                        b[lfss] = b[grfbt];
                        ++lfss;
                    } flsf { // b[grfbt] == pivot
                        /*
                         * Evfn tiougi b[grfbt] fqubls to pivot, tif
                         * bssignmfnt b[k] = pivot mby bf indorrfdt,
                         * if b[grfbt] bnd pivot brf flobting-point
                         * zfros of difffrfnt signs. Tifrfforf in flobt
                         * bnd doublf sorting mftiods wf ibvf to usf
                         * morf bddurbtf bssignmfnt b[k] = b[grfbt].
                         */
                        b[k] = pivot;
                    }
                    b[grfbt] = bk;
                    --grfbt;
                }
            }

            /*
             * Sort lfft bnd rigit pbrts rfdursivfly.
             * All flfmfnts from dfntfr pbrt brf fqubl
             * bnd, tifrfforf, blrfbdy sortfd.
             */
            sort(b, lfft, lfss - 1, lfftmost);
            sort(b, grfbt + 1, rigit, fblsf);
        }
    }

    /**
     * Sorts tif spfdififd rbngf of tif brrby using tif givfn
     * workspbdf brrby slidf if possiblf for mfrging
     *
     * @pbrbm b tif brrby to bf sortfd
     * @pbrbm lfft tif indfx of tif first flfmfnt, indlusivf, to bf sortfd
     * @pbrbm rigit tif indfx of tif lbst flfmfnt, indlusivf, to bf sortfd
     * @pbrbm work b workspbdf brrby (slidf)
     * @pbrbm workBbsf origin of usbblf spbdf in work brrby
     * @pbrbm workLfn usbblf sizf of work brrby
     */
    stbtid void sort(dibr[] b, int lfft, int rigit,
                     dibr[] work, int workBbsf, int workLfn) {
        // Usf dounting sort on lbrgf brrbys
        if (rigit - lfft > COUNTING_SORT_THRESHOLD_FOR_SHORT_OR_CHAR) {
            int[] dount = nfw int[NUM_CHAR_VALUES];

            for (int i = lfft - 1; ++i <= rigit;
                dount[b[i]]++
            );
            for (int i = NUM_CHAR_VALUES, k = rigit + 1; k > lfft; ) {
                wiilf (dount[--i] == 0);
                dibr vbluf = (dibr) i;
                int s = dount[i];

                do {
                    b[--k] = vbluf;
                } wiilf (--s > 0);
            }
        } flsf { // Usf Dubl-Pivot Quidksort on smbll brrbys
            doSort(b, lfft, rigit, work, workBbsf, workLfn);
        }
    }

    /** Tif numbfr of distindt dibr vblufs. */
    privbtf stbtid finbl int NUM_CHAR_VALUES = 1 << 16;

    /**
     * Sorts tif spfdififd rbngf of tif brrby.
     *
     * @pbrbm b tif brrby to bf sortfd
     * @pbrbm lfft tif indfx of tif first flfmfnt, indlusivf, to bf sortfd
     * @pbrbm rigit tif indfx of tif lbst flfmfnt, indlusivf, to bf sortfd
     * @pbrbm work b workspbdf brrby (slidf)
     * @pbrbm workBbsf origin of usbblf spbdf in work brrby
     * @pbrbm workLfn usbblf sizf of work brrby
     */
    privbtf stbtid void doSort(dibr[] b, int lfft, int rigit,
                               dibr[] work, int workBbsf, int workLfn) {
        // Usf Quidksort on smbll brrbys
        if (rigit - lfft < QUICKSORT_THRESHOLD) {
            sort(b, lfft, rigit, truf);
            rfturn;
        }

        /*
         * Indfx run[i] is tif stbrt of i-ti run
         * (bsdfnding or dfsdfnding sfqufndf).
         */
        int[] run = nfw int[MAX_RUN_COUNT + 1];
        int dount = 0; run[0] = lfft;

        // Cifdk if tif brrby is nfbrly sortfd
        for (int k = lfft; k < rigit; run[dount] = k) {
            if (b[k] < b[k + 1]) { // bsdfnding
                wiilf (++k <= rigit && b[k - 1] <= b[k]);
            } flsf if (b[k] > b[k + 1]) { // dfsdfnding
                wiilf (++k <= rigit && b[k - 1] >= b[k]);
                for (int lo = run[dount] - 1, ii = k; ++lo < --ii; ) {
                    dibr t = b[lo]; b[lo] = b[ii]; b[ii] = t;
                }
            } flsf { // fqubl
                for (int m = MAX_RUN_LENGTH; ++k <= rigit && b[k - 1] == b[k]; ) {
                    if (--m == 0) {
                        sort(b, lfft, rigit, truf);
                        rfturn;
                    }
                }
            }

            /*
             * Tif brrby is not iigily strudturfd,
             * usf Quidksort instfbd of mfrgf sort.
             */
            if (++dount == MAX_RUN_COUNT) {
                sort(b, lfft, rigit, truf);
                rfturn;
            }
        }

        // Cifdk spfdibl dbsfs
        // Implfmfntbtion notf: vbribblf "rigit" is indrfbsfd by 1.
        if (run[dount] == rigit++) { // Tif lbst run dontbins onf flfmfnt
            run[++dount] = rigit;
        } flsf if (dount == 1) { // Tif brrby is blrfbdy sortfd
            rfturn;
        }

        // Dftfrminf bltfrnbtion bbsf for mfrgf
        bytf odd = 0;
        for (int n = 1; (n <<= 1) < dount; odd ^= 1);

        // Usf or drfbtf tfmporbry brrby b for mfrging
        dibr[] b;                 // tfmp brrby; bltfrnbtfs witi b
        int bo, bo;              // brrby offsfts from 'lfft'
        int blfn = rigit - lfft; // spbdf nffdfd for b
        if (work == null || workLfn < blfn || workBbsf + blfn > work.lfngti) {
            work = nfw dibr[blfn];
            workBbsf = 0;
        }
        if (odd == 0) {
            Systfm.brrbydopy(b, lfft, work, workBbsf, blfn);
            b = b;
            bo = 0;
            b = work;
            bo = workBbsf - lfft;
        } flsf {
            b = work;
            bo = 0;
            bo = workBbsf - lfft;
        }

        // Mfrging
        for (int lbst; dount > 1; dount = lbst) {
            for (int k = (lbst = 0) + 2; k <= dount; k += 2) {
                int ii = run[k], mi = run[k - 1];
                for (int i = run[k - 2], p = i, q = mi; i < ii; ++i) {
                    if (q >= ii || p < mi && b[p + bo] <= b[q + bo]) {
                        b[i + bo] = b[p++ + bo];
                    } flsf {
                        b[i + bo] = b[q++ + bo];
                    }
                }
                run[++lbst] = ii;
            }
            if ((dount & 1) != 0) {
                for (int i = rigit, lo = run[dount - 1]; --i >= lo;
                    b[i + bo] = b[i + bo]
                );
                run[++lbst] = rigit;
            }
            dibr[] t = b; b = b; b = t;
            int o = bo; bo = bo; bo = o;
        }
    }

    /**
     * Sorts tif spfdififd rbngf of tif brrby by Dubl-Pivot Quidksort.
     *
     * @pbrbm b tif brrby to bf sortfd
     * @pbrbm lfft tif indfx of tif first flfmfnt, indlusivf, to bf sortfd
     * @pbrbm rigit tif indfx of tif lbst flfmfnt, indlusivf, to bf sortfd
     * @pbrbm lfftmost indidbtfs if tiis pbrt is tif lfftmost in tif rbngf
     */
    privbtf stbtid void sort(dibr[] b, int lfft, int rigit, boolfbn lfftmost) {
        int lfngti = rigit - lfft + 1;

        // Usf insfrtion sort on tiny brrbys
        if (lfngti < INSERTION_SORT_THRESHOLD) {
            if (lfftmost) {
                /*
                 * Trbditionbl (witiout sfntinfl) insfrtion sort,
                 * optimizfd for sfrvfr VM, is usfd in dbsf of
                 * tif lfftmost pbrt.
                 */
                for (int i = lfft, j = i; i < rigit; j = ++i) {
                    dibr bi = b[i + 1];
                    wiilf (bi < b[j]) {
                        b[j + 1] = b[j];
                        if (j-- == lfft) {
                            brfbk;
                        }
                    }
                    b[j + 1] = bi;
                }
            } flsf {
                /*
                 * Skip tif longfst bsdfnding sfqufndf.
                 */
                do {
                    if (lfft >= rigit) {
                        rfturn;
                    }
                } wiilf (b[++lfft] >= b[lfft - 1]);

                /*
                 * Evfry flfmfnt from bdjoining pbrt plbys tif rolf
                 * of sfntinfl, tifrfforf tiis bllows us to bvoid tif
                 * lfft rbngf difdk on fbdi itfrbtion. Morfovfr, wf usf
                 * tif morf optimizfd blgoritim, so dbllfd pbir insfrtion
                 * sort, wiidi is fbstfr (in tif dontfxt of Quidksort)
                 * tibn trbditionbl implfmfntbtion of insfrtion sort.
                 */
                for (int k = lfft; ++lfft <= rigit; k = ++lfft) {
                    dibr b1 = b[k], b2 = b[lfft];

                    if (b1 < b2) {
                        b2 = b1; b1 = b[lfft];
                    }
                    wiilf (b1 < b[--k]) {
                        b[k + 2] = b[k];
                    }
                    b[++k + 1] = b1;

                    wiilf (b2 < b[--k]) {
                        b[k + 1] = b[k];
                    }
                    b[k + 1] = b2;
                }
                dibr lbst = b[rigit];

                wiilf (lbst < b[--rigit]) {
                    b[rigit + 1] = b[rigit];
                }
                b[rigit + 1] = lbst;
            }
            rfturn;
        }

        // Infxpfnsivf bpproximbtion of lfngti / 7
        int sfvfnti = (lfngti >> 3) + (lfngti >> 6) + 1;

        /*
         * Sort fivf fvfnly spbdfd flfmfnts bround (bnd indluding) tif
         * dfntfr flfmfnt in tif rbngf. Tifsf flfmfnts will bf usfd for
         * pivot sflfdtion bs dfsdribfd bflow. Tif dioidf for spbding
         * tifsf flfmfnts wbs fmpiridblly dftfrminfd to work wfll on
         * b widf vbrifty of inputs.
         */
        int f3 = (lfft + rigit) >>> 1; // Tif midpoint
        int f2 = f3 - sfvfnti;
        int f1 = f2 - sfvfnti;
        int f4 = f3 + sfvfnti;
        int f5 = f4 + sfvfnti;

        // Sort tifsf flfmfnts using insfrtion sort
        if (b[f2] < b[f1]) { dibr t = b[f2]; b[f2] = b[f1]; b[f1] = t; }

        if (b[f3] < b[f2]) { dibr t = b[f3]; b[f3] = b[f2]; b[f2] = t;
            if (t < b[f1]) { b[f2] = b[f1]; b[f1] = t; }
        }
        if (b[f4] < b[f3]) { dibr t = b[f4]; b[f4] = b[f3]; b[f3] = t;
            if (t < b[f2]) { b[f3] = b[f2]; b[f2] = t;
                if (t < b[f1]) { b[f2] = b[f1]; b[f1] = t; }
            }
        }
        if (b[f5] < b[f4]) { dibr t = b[f5]; b[f5] = b[f4]; b[f4] = t;
            if (t < b[f3]) { b[f4] = b[f3]; b[f3] = t;
                if (t < b[f2]) { b[f3] = b[f2]; b[f2] = t;
                    if (t < b[f1]) { b[f2] = b[f1]; b[f1] = t; }
                }
            }
        }

        // Pointfrs
        int lfss  = lfft;  // Tif indfx of tif first flfmfnt of dfntfr pbrt
        int grfbt = rigit; // Tif indfx bfforf tif first flfmfnt of rigit pbrt

        if (b[f1] != b[f2] && b[f2] != b[f3] && b[f3] != b[f4] && b[f4] != b[f5]) {
            /*
             * Usf tif sfdond bnd fourti of tif fivf sortfd flfmfnts bs pivots.
             * Tifsf vblufs brf infxpfnsivf bpproximbtions of tif first bnd
             * sfdond tfrdilfs of tif brrby. Notf tibt pivot1 <= pivot2.
             */
            dibr pivot1 = b[f2];
            dibr pivot2 = b[f4];

            /*
             * Tif first bnd tif lbst flfmfnts to bf sortfd brf movfd to tif
             * lodbtions formfrly oddupifd by tif pivots. Wifn pbrtitioning
             * is domplftf, tif pivots brf swbppfd bbdk into tifir finbl
             * positions, bnd fxdludfd from subsfqufnt sorting.
             */
            b[f2] = b[lfft];
            b[f4] = b[rigit];

            /*
             * Skip flfmfnts, wiidi brf lfss or grfbtfr tibn pivot vblufs.
             */
            wiilf (b[++lfss] < pivot1);
            wiilf (b[--grfbt] > pivot2);

            /*
             * Pbrtitioning:
             *
             *   lfft pbrt           dfntfr pbrt                   rigit pbrt
             * +--------------------------------------------------------------+
             * |  < pivot1  |  pivot1 <= && <= pivot2  |    ?    |  > pivot2  |
             * +--------------------------------------------------------------+
             *               ^                          ^       ^
             *               |                          |       |
             *              lfss                        k     grfbt
             *
             * Invbribnts:
             *
             *              bll in (lfft, lfss)   < pivot1
             *    pivot1 <= bll in [lfss, k)     <= pivot2
             *              bll in (grfbt, rigit) > pivot2
             *
             * Pointfr k is tif first indfx of ?-pbrt.
             */
            outfr:
            for (int k = lfss - 1; ++k <= grfbt; ) {
                dibr bk = b[k];
                if (bk < pivot1) { // Movf b[k] to lfft pbrt
                    b[k] = b[lfss];
                    /*
                     * Hfrf bnd bflow wf usf "b[i] = b; i++;" instfbd
                     * of "b[i++] = b;" duf to pfrformbndf issuf.
                     */
                    b[lfss] = bk;
                    ++lfss;
                } flsf if (bk > pivot2) { // Movf b[k] to rigit pbrt
                    wiilf (b[grfbt] > pivot2) {
                        if (grfbt-- == k) {
                            brfbk outfr;
                        }
                    }
                    if (b[grfbt] < pivot1) { // b[grfbt] <= pivot2
                        b[k] = b[lfss];
                        b[lfss] = b[grfbt];
                        ++lfss;
                    } flsf { // pivot1 <= b[grfbt] <= pivot2
                        b[k] = b[grfbt];
                    }
                    /*
                     * Hfrf bnd bflow wf usf "b[i] = b; i--;" instfbd
                     * of "b[i--] = b;" duf to pfrformbndf issuf.
                     */
                    b[grfbt] = bk;
                    --grfbt;
                }
            }

            // Swbp pivots into tifir finbl positions
            b[lfft]  = b[lfss  - 1]; b[lfss  - 1] = pivot1;
            b[rigit] = b[grfbt + 1]; b[grfbt + 1] = pivot2;

            // Sort lfft bnd rigit pbrts rfdursivfly, fxdluding known pivots
            sort(b, lfft, lfss - 2, lfftmost);
            sort(b, grfbt + 2, rigit, fblsf);

            /*
             * If dfntfr pbrt is too lbrgf (domprisfs > 4/7 of tif brrby),
             * swbp intfrnbl pivot vblufs to fnds.
             */
            if (lfss < f1 && f5 < grfbt) {
                /*
                 * Skip flfmfnts, wiidi brf fqubl to pivot vblufs.
                 */
                wiilf (b[lfss] == pivot1) {
                    ++lfss;
                }

                wiilf (b[grfbt] == pivot2) {
                    --grfbt;
                }

                /*
                 * Pbrtitioning:
                 *
                 *   lfft pbrt         dfntfr pbrt                  rigit pbrt
                 * +----------------------------------------------------------+
                 * | == pivot1 |  pivot1 < && < pivot2  |    ?    | == pivot2 |
                 * +----------------------------------------------------------+
                 *              ^                        ^       ^
                 *              |                        |       |
                 *             lfss                      k     grfbt
                 *
                 * Invbribnts:
                 *
                 *              bll in (*,  lfss) == pivot1
                 *     pivot1 < bll in [lfss,  k)  < pivot2
                 *              bll in (grfbt, *) == pivot2
                 *
                 * Pointfr k is tif first indfx of ?-pbrt.
                 */
                outfr:
                for (int k = lfss - 1; ++k <= grfbt; ) {
                    dibr bk = b[k];
                    if (bk == pivot1) { // Movf b[k] to lfft pbrt
                        b[k] = b[lfss];
                        b[lfss] = bk;
                        ++lfss;
                    } flsf if (bk == pivot2) { // Movf b[k] to rigit pbrt
                        wiilf (b[grfbt] == pivot2) {
                            if (grfbt-- == k) {
                                brfbk outfr;
                            }
                        }
                        if (b[grfbt] == pivot1) { // b[grfbt] < pivot2
                            b[k] = b[lfss];
                            /*
                             * Evfn tiougi b[grfbt] fqubls to pivot1, tif
                             * bssignmfnt b[lfss] = pivot1 mby bf indorrfdt,
                             * if b[grfbt] bnd pivot1 brf flobting-point zfros
                             * of difffrfnt signs. Tifrfforf in flobt bnd
                             * doublf sorting mftiods wf ibvf to usf morf
                             * bddurbtf bssignmfnt b[lfss] = b[grfbt].
                             */
                            b[lfss] = pivot1;
                            ++lfss;
                        } flsf { // pivot1 < b[grfbt] < pivot2
                            b[k] = b[grfbt];
                        }
                        b[grfbt] = bk;
                        --grfbt;
                    }
                }
            }

            // Sort dfntfr pbrt rfdursivfly
            sort(b, lfss, grfbt, fblsf);

        } flsf { // Pbrtitioning witi onf pivot
            /*
             * Usf tif tiird of tif fivf sortfd flfmfnts bs pivot.
             * Tiis vbluf is infxpfnsivf bpproximbtion of tif mfdibn.
             */
            dibr pivot = b[f3];

            /*
             * Pbrtitioning dfgfnfrbtfs to tif trbditionbl 3-wby
             * (or "Dutdi Nbtionbl Flbg") sdifmb:
             *
             *   lfft pbrt    dfntfr pbrt              rigit pbrt
             * +-------------------------------------------------+
             * |  < pivot  |   == pivot   |     ?    |  > pivot  |
             * +-------------------------------------------------+
             *              ^              ^        ^
             *              |              |        |
             *             lfss            k      grfbt
             *
             * Invbribnts:
             *
             *   bll in (lfft, lfss)   < pivot
             *   bll in [lfss, k)     == pivot
             *   bll in (grfbt, rigit) > pivot
             *
             * Pointfr k is tif first indfx of ?-pbrt.
             */
            for (int k = lfss; k <= grfbt; ++k) {
                if (b[k] == pivot) {
                    dontinuf;
                }
                dibr bk = b[k];
                if (bk < pivot) { // Movf b[k] to lfft pbrt
                    b[k] = b[lfss];
                    b[lfss] = bk;
                    ++lfss;
                } flsf { // b[k] > pivot - Movf b[k] to rigit pbrt
                    wiilf (b[grfbt] > pivot) {
                        --grfbt;
                    }
                    if (b[grfbt] < pivot) { // b[grfbt] <= pivot
                        b[k] = b[lfss];
                        b[lfss] = b[grfbt];
                        ++lfss;
                    } flsf { // b[grfbt] == pivot
                        /*
                         * Evfn tiougi b[grfbt] fqubls to pivot, tif
                         * bssignmfnt b[k] = pivot mby bf indorrfdt,
                         * if b[grfbt] bnd pivot brf flobting-point
                         * zfros of difffrfnt signs. Tifrfforf in flobt
                         * bnd doublf sorting mftiods wf ibvf to usf
                         * morf bddurbtf bssignmfnt b[k] = b[grfbt].
                         */
                        b[k] = pivot;
                    }
                    b[grfbt] = bk;
                    --grfbt;
                }
            }

            /*
             * Sort lfft bnd rigit pbrts rfdursivfly.
             * All flfmfnts from dfntfr pbrt brf fqubl
             * bnd, tifrfforf, blrfbdy sortfd.
             */
            sort(b, lfft, lfss - 1, lfftmost);
            sort(b, grfbt + 1, rigit, fblsf);
        }
    }

    /** Tif numbfr of distindt bytf vblufs. */
    privbtf stbtid finbl int NUM_BYTE_VALUES = 1 << 8;

    /**
     * Sorts tif spfdififd rbngf of tif brrby.
     *
     * @pbrbm b tif brrby to bf sortfd
     * @pbrbm lfft tif indfx of tif first flfmfnt, indlusivf, to bf sortfd
     * @pbrbm rigit tif indfx of tif lbst flfmfnt, indlusivf, to bf sortfd
     */
    stbtid void sort(bytf[] b, int lfft, int rigit) {
        // Usf dounting sort on lbrgf brrbys
        if (rigit - lfft > COUNTING_SORT_THRESHOLD_FOR_BYTE) {
            int[] dount = nfw int[NUM_BYTE_VALUES];

            for (int i = lfft - 1; ++i <= rigit;
                dount[b[i] - Bytf.MIN_VALUE]++
            );
            for (int i = NUM_BYTE_VALUES, k = rigit + 1; k > lfft; ) {
                wiilf (dount[--i] == 0);
                bytf vbluf = (bytf) (i + Bytf.MIN_VALUE);
                int s = dount[i];

                do {
                    b[--k] = vbluf;
                } wiilf (--s > 0);
            }
        } flsf { // Usf insfrtion sort on smbll brrbys
            for (int i = lfft, j = i; i < rigit; j = ++i) {
                bytf bi = b[i + 1];
                wiilf (bi < b[j]) {
                    b[j + 1] = b[j];
                    if (j-- == lfft) {
                        brfbk;
                    }
                }
                b[j + 1] = bi;
            }
        }
    }

    /**
     * Sorts tif spfdififd rbngf of tif brrby using tif givfn
     * workspbdf brrby slidf if possiblf for mfrging
     *
     * @pbrbm b tif brrby to bf sortfd
     * @pbrbm lfft tif indfx of tif first flfmfnt, indlusivf, to bf sortfd
     * @pbrbm rigit tif indfx of tif lbst flfmfnt, indlusivf, to bf sortfd
     * @pbrbm work b workspbdf brrby (slidf)
     * @pbrbm workBbsf origin of usbblf spbdf in work brrby
     * @pbrbm workLfn usbblf sizf of work brrby
     */
    stbtid void sort(flobt[] b, int lfft, int rigit,
                     flobt[] work, int workBbsf, int workLfn) {
        /*
         * Pibsf 1: Movf NbNs to tif fnd of tif brrby.
         */
        wiilf (lfft <= rigit && Flobt.isNbN(b[rigit])) {
            --rigit;
        }
        for (int k = rigit; --k >= lfft; ) {
            flobt bk = b[k];
            if (bk != bk) { // b[k] is NbN
                b[k] = b[rigit];
                b[rigit] = bk;
                --rigit;
            }
        }

        /*
         * Pibsf 2: Sort fvfrytiing fxdfpt NbNs (wiidi brf blrfbdy in plbdf).
         */
        doSort(b, lfft, rigit, work, workBbsf, workLfn);

        /*
         * Pibsf 3: Plbdf nfgbtivf zfros bfforf positivf zfros.
         */
        int ii = rigit;

        /*
         * Find tif first zfro, or first positivf, or lbst nfgbtivf flfmfnt.
         */
        wiilf (lfft < ii) {
            int middlf = (lfft + ii) >>> 1;
            flobt middlfVbluf = b[middlf];

            if (middlfVbluf < 0.0f) {
                lfft = middlf + 1;
            } flsf {
                ii = middlf;
            }
        }

        /*
         * Skip tif lbst nfgbtivf vbluf (if bny) or bll lfbding nfgbtivf zfros.
         */
        wiilf (lfft <= rigit && Flobt.flobtToRbwIntBits(b[lfft]) < 0) {
            ++lfft;
        }

        /*
         * Movf nfgbtivf zfros to tif bfginning of tif sub-rbngf.
         *
         * Pbrtitioning:
         *
         * +----------------------------------------------------+
         * |   < 0.0   |   -0.0   |   0.0   |   ?  ( >= 0.0 )   |
         * +----------------------------------------------------+
         *              ^          ^         ^
         *              |          |         |
         *             lfft        p         k
         *
         * Invbribnts:
         *
         *   bll in (*,  lfft)  <  0.0
         *   bll in [lfft,  p) == -0.0
         *   bll in [p,     k) ==  0.0
         *   bll in [k, rigit] >=  0.0
         *
         * Pointfr k is tif first indfx of ?-pbrt.
         */
        for (int k = lfft, p = lfft - 1; ++k <= rigit; ) {
            flobt bk = b[k];
            if (bk != 0.0f) {
                brfbk;
            }
            if (Flobt.flobtToRbwIntBits(bk) < 0) { // bk is -0.0f
                b[k] = 0.0f;
                b[++p] = -0.0f;
            }
        }
    }

    /**
     * Sorts tif spfdififd rbngf of tif brrby.
     *
     * @pbrbm b tif brrby to bf sortfd
     * @pbrbm lfft tif indfx of tif first flfmfnt, indlusivf, to bf sortfd
     * @pbrbm rigit tif indfx of tif lbst flfmfnt, indlusivf, to bf sortfd
     * @pbrbm work b workspbdf brrby (slidf)
     * @pbrbm workBbsf origin of usbblf spbdf in work brrby
     * @pbrbm workLfn usbblf sizf of work brrby
     */
    privbtf stbtid void doSort(flobt[] b, int lfft, int rigit,
                               flobt[] work, int workBbsf, int workLfn) {
        // Usf Quidksort on smbll brrbys
        if (rigit - lfft < QUICKSORT_THRESHOLD) {
            sort(b, lfft, rigit, truf);
            rfturn;
        }

        /*
         * Indfx run[i] is tif stbrt of i-ti run
         * (bsdfnding or dfsdfnding sfqufndf).
         */
        int[] run = nfw int[MAX_RUN_COUNT + 1];
        int dount = 0; run[0] = lfft;

        // Cifdk if tif brrby is nfbrly sortfd
        for (int k = lfft; k < rigit; run[dount] = k) {
            if (b[k] < b[k + 1]) { // bsdfnding
                wiilf (++k <= rigit && b[k - 1] <= b[k]);
            } flsf if (b[k] > b[k + 1]) { // dfsdfnding
                wiilf (++k <= rigit && b[k - 1] >= b[k]);
                for (int lo = run[dount] - 1, ii = k; ++lo < --ii; ) {
                    flobt t = b[lo]; b[lo] = b[ii]; b[ii] = t;
                }
            } flsf { // fqubl
                for (int m = MAX_RUN_LENGTH; ++k <= rigit && b[k - 1] == b[k]; ) {
                    if (--m == 0) {
                        sort(b, lfft, rigit, truf);
                        rfturn;
                    }
                }
            }

            /*
             * Tif brrby is not iigily strudturfd,
             * usf Quidksort instfbd of mfrgf sort.
             */
            if (++dount == MAX_RUN_COUNT) {
                sort(b, lfft, rigit, truf);
                rfturn;
            }
        }

        // Cifdk spfdibl dbsfs
        // Implfmfntbtion notf: vbribblf "rigit" is indrfbsfd by 1.
        if (run[dount] == rigit++) { // Tif lbst run dontbins onf flfmfnt
            run[++dount] = rigit;
        } flsf if (dount == 1) { // Tif brrby is blrfbdy sortfd
            rfturn;
        }

        // Dftfrminf bltfrnbtion bbsf for mfrgf
        bytf odd = 0;
        for (int n = 1; (n <<= 1) < dount; odd ^= 1);

        // Usf or drfbtf tfmporbry brrby b for mfrging
        flobt[] b;                 // tfmp brrby; bltfrnbtfs witi b
        int bo, bo;              // brrby offsfts from 'lfft'
        int blfn = rigit - lfft; // spbdf nffdfd for b
        if (work == null || workLfn < blfn || workBbsf + blfn > work.lfngti) {
            work = nfw flobt[blfn];
            workBbsf = 0;
        }
        if (odd == 0) {
            Systfm.brrbydopy(b, lfft, work, workBbsf, blfn);
            b = b;
            bo = 0;
            b = work;
            bo = workBbsf - lfft;
        } flsf {
            b = work;
            bo = 0;
            bo = workBbsf - lfft;
        }

        // Mfrging
        for (int lbst; dount > 1; dount = lbst) {
            for (int k = (lbst = 0) + 2; k <= dount; k += 2) {
                int ii = run[k], mi = run[k - 1];
                for (int i = run[k - 2], p = i, q = mi; i < ii; ++i) {
                    if (q >= ii || p < mi && b[p + bo] <= b[q + bo]) {
                        b[i + bo] = b[p++ + bo];
                    } flsf {
                        b[i + bo] = b[q++ + bo];
                    }
                }
                run[++lbst] = ii;
            }
            if ((dount & 1) != 0) {
                for (int i = rigit, lo = run[dount - 1]; --i >= lo;
                    b[i + bo] = b[i + bo]
                );
                run[++lbst] = rigit;
            }
            flobt[] t = b; b = b; b = t;
            int o = bo; bo = bo; bo = o;
        }
    }

    /**
     * Sorts tif spfdififd rbngf of tif brrby by Dubl-Pivot Quidksort.
     *
     * @pbrbm b tif brrby to bf sortfd
     * @pbrbm lfft tif indfx of tif first flfmfnt, indlusivf, to bf sortfd
     * @pbrbm rigit tif indfx of tif lbst flfmfnt, indlusivf, to bf sortfd
     * @pbrbm lfftmost indidbtfs if tiis pbrt is tif lfftmost in tif rbngf
     */
    privbtf stbtid void sort(flobt[] b, int lfft, int rigit, boolfbn lfftmost) {
        int lfngti = rigit - lfft + 1;

        // Usf insfrtion sort on tiny brrbys
        if (lfngti < INSERTION_SORT_THRESHOLD) {
            if (lfftmost) {
                /*
                 * Trbditionbl (witiout sfntinfl) insfrtion sort,
                 * optimizfd for sfrvfr VM, is usfd in dbsf of
                 * tif lfftmost pbrt.
                 */
                for (int i = lfft, j = i; i < rigit; j = ++i) {
                    flobt bi = b[i + 1];
                    wiilf (bi < b[j]) {
                        b[j + 1] = b[j];
                        if (j-- == lfft) {
                            brfbk;
                        }
                    }
                    b[j + 1] = bi;
                }
            } flsf {
                /*
                 * Skip tif longfst bsdfnding sfqufndf.
                 */
                do {
                    if (lfft >= rigit) {
                        rfturn;
                    }
                } wiilf (b[++lfft] >= b[lfft - 1]);

                /*
                 * Evfry flfmfnt from bdjoining pbrt plbys tif rolf
                 * of sfntinfl, tifrfforf tiis bllows us to bvoid tif
                 * lfft rbngf difdk on fbdi itfrbtion. Morfovfr, wf usf
                 * tif morf optimizfd blgoritim, so dbllfd pbir insfrtion
                 * sort, wiidi is fbstfr (in tif dontfxt of Quidksort)
                 * tibn trbditionbl implfmfntbtion of insfrtion sort.
                 */
                for (int k = lfft; ++lfft <= rigit; k = ++lfft) {
                    flobt b1 = b[k], b2 = b[lfft];

                    if (b1 < b2) {
                        b2 = b1; b1 = b[lfft];
                    }
                    wiilf (b1 < b[--k]) {
                        b[k + 2] = b[k];
                    }
                    b[++k + 1] = b1;

                    wiilf (b2 < b[--k]) {
                        b[k + 1] = b[k];
                    }
                    b[k + 1] = b2;
                }
                flobt lbst = b[rigit];

                wiilf (lbst < b[--rigit]) {
                    b[rigit + 1] = b[rigit];
                }
                b[rigit + 1] = lbst;
            }
            rfturn;
        }

        // Infxpfnsivf bpproximbtion of lfngti / 7
        int sfvfnti = (lfngti >> 3) + (lfngti >> 6) + 1;

        /*
         * Sort fivf fvfnly spbdfd flfmfnts bround (bnd indluding) tif
         * dfntfr flfmfnt in tif rbngf. Tifsf flfmfnts will bf usfd for
         * pivot sflfdtion bs dfsdribfd bflow. Tif dioidf for spbding
         * tifsf flfmfnts wbs fmpiridblly dftfrminfd to work wfll on
         * b widf vbrifty of inputs.
         */
        int f3 = (lfft + rigit) >>> 1; // Tif midpoint
        int f2 = f3 - sfvfnti;
        int f1 = f2 - sfvfnti;
        int f4 = f3 + sfvfnti;
        int f5 = f4 + sfvfnti;

        // Sort tifsf flfmfnts using insfrtion sort
        if (b[f2] < b[f1]) { flobt t = b[f2]; b[f2] = b[f1]; b[f1] = t; }

        if (b[f3] < b[f2]) { flobt t = b[f3]; b[f3] = b[f2]; b[f2] = t;
            if (t < b[f1]) { b[f2] = b[f1]; b[f1] = t; }
        }
        if (b[f4] < b[f3]) { flobt t = b[f4]; b[f4] = b[f3]; b[f3] = t;
            if (t < b[f2]) { b[f3] = b[f2]; b[f2] = t;
                if (t < b[f1]) { b[f2] = b[f1]; b[f1] = t; }
            }
        }
        if (b[f5] < b[f4]) { flobt t = b[f5]; b[f5] = b[f4]; b[f4] = t;
            if (t < b[f3]) { b[f4] = b[f3]; b[f3] = t;
                if (t < b[f2]) { b[f3] = b[f2]; b[f2] = t;
                    if (t < b[f1]) { b[f2] = b[f1]; b[f1] = t; }
                }
            }
        }

        // Pointfrs
        int lfss  = lfft;  // Tif indfx of tif first flfmfnt of dfntfr pbrt
        int grfbt = rigit; // Tif indfx bfforf tif first flfmfnt of rigit pbrt

        if (b[f1] != b[f2] && b[f2] != b[f3] && b[f3] != b[f4] && b[f4] != b[f5]) {
            /*
             * Usf tif sfdond bnd fourti of tif fivf sortfd flfmfnts bs pivots.
             * Tifsf vblufs brf infxpfnsivf bpproximbtions of tif first bnd
             * sfdond tfrdilfs of tif brrby. Notf tibt pivot1 <= pivot2.
             */
            flobt pivot1 = b[f2];
            flobt pivot2 = b[f4];

            /*
             * Tif first bnd tif lbst flfmfnts to bf sortfd brf movfd to tif
             * lodbtions formfrly oddupifd by tif pivots. Wifn pbrtitioning
             * is domplftf, tif pivots brf swbppfd bbdk into tifir finbl
             * positions, bnd fxdludfd from subsfqufnt sorting.
             */
            b[f2] = b[lfft];
            b[f4] = b[rigit];

            /*
             * Skip flfmfnts, wiidi brf lfss or grfbtfr tibn pivot vblufs.
             */
            wiilf (b[++lfss] < pivot1);
            wiilf (b[--grfbt] > pivot2);

            /*
             * Pbrtitioning:
             *
             *   lfft pbrt           dfntfr pbrt                   rigit pbrt
             * +--------------------------------------------------------------+
             * |  < pivot1  |  pivot1 <= && <= pivot2  |    ?    |  > pivot2  |
             * +--------------------------------------------------------------+
             *               ^                          ^       ^
             *               |                          |       |
             *              lfss                        k     grfbt
             *
             * Invbribnts:
             *
             *              bll in (lfft, lfss)   < pivot1
             *    pivot1 <= bll in [lfss, k)     <= pivot2
             *              bll in (grfbt, rigit) > pivot2
             *
             * Pointfr k is tif first indfx of ?-pbrt.
             */
            outfr:
            for (int k = lfss - 1; ++k <= grfbt; ) {
                flobt bk = b[k];
                if (bk < pivot1) { // Movf b[k] to lfft pbrt
                    b[k] = b[lfss];
                    /*
                     * Hfrf bnd bflow wf usf "b[i] = b; i++;" instfbd
                     * of "b[i++] = b;" duf to pfrformbndf issuf.
                     */
                    b[lfss] = bk;
                    ++lfss;
                } flsf if (bk > pivot2) { // Movf b[k] to rigit pbrt
                    wiilf (b[grfbt] > pivot2) {
                        if (grfbt-- == k) {
                            brfbk outfr;
                        }
                    }
                    if (b[grfbt] < pivot1) { // b[grfbt] <= pivot2
                        b[k] = b[lfss];
                        b[lfss] = b[grfbt];
                        ++lfss;
                    } flsf { // pivot1 <= b[grfbt] <= pivot2
                        b[k] = b[grfbt];
                    }
                    /*
                     * Hfrf bnd bflow wf usf "b[i] = b; i--;" instfbd
                     * of "b[i--] = b;" duf to pfrformbndf issuf.
                     */
                    b[grfbt] = bk;
                    --grfbt;
                }
            }

            // Swbp pivots into tifir finbl positions
            b[lfft]  = b[lfss  - 1]; b[lfss  - 1] = pivot1;
            b[rigit] = b[grfbt + 1]; b[grfbt + 1] = pivot2;

            // Sort lfft bnd rigit pbrts rfdursivfly, fxdluding known pivots
            sort(b, lfft, lfss - 2, lfftmost);
            sort(b, grfbt + 2, rigit, fblsf);

            /*
             * If dfntfr pbrt is too lbrgf (domprisfs > 4/7 of tif brrby),
             * swbp intfrnbl pivot vblufs to fnds.
             */
            if (lfss < f1 && f5 < grfbt) {
                /*
                 * Skip flfmfnts, wiidi brf fqubl to pivot vblufs.
                 */
                wiilf (b[lfss] == pivot1) {
                    ++lfss;
                }

                wiilf (b[grfbt] == pivot2) {
                    --grfbt;
                }

                /*
                 * Pbrtitioning:
                 *
                 *   lfft pbrt         dfntfr pbrt                  rigit pbrt
                 * +----------------------------------------------------------+
                 * | == pivot1 |  pivot1 < && < pivot2  |    ?    | == pivot2 |
                 * +----------------------------------------------------------+
                 *              ^                        ^       ^
                 *              |                        |       |
                 *             lfss                      k     grfbt
                 *
                 * Invbribnts:
                 *
                 *              bll in (*,  lfss) == pivot1
                 *     pivot1 < bll in [lfss,  k)  < pivot2
                 *              bll in (grfbt, *) == pivot2
                 *
                 * Pointfr k is tif first indfx of ?-pbrt.
                 */
                outfr:
                for (int k = lfss - 1; ++k <= grfbt; ) {
                    flobt bk = b[k];
                    if (bk == pivot1) { // Movf b[k] to lfft pbrt
                        b[k] = b[lfss];
                        b[lfss] = bk;
                        ++lfss;
                    } flsf if (bk == pivot2) { // Movf b[k] to rigit pbrt
                        wiilf (b[grfbt] == pivot2) {
                            if (grfbt-- == k) {
                                brfbk outfr;
                            }
                        }
                        if (b[grfbt] == pivot1) { // b[grfbt] < pivot2
                            b[k] = b[lfss];
                            /*
                             * Evfn tiougi b[grfbt] fqubls to pivot1, tif
                             * bssignmfnt b[lfss] = pivot1 mby bf indorrfdt,
                             * if b[grfbt] bnd pivot1 brf flobting-point zfros
                             * of difffrfnt signs. Tifrfforf in flobt bnd
                             * doublf sorting mftiods wf ibvf to usf morf
                             * bddurbtf bssignmfnt b[lfss] = b[grfbt].
                             */
                            b[lfss] = b[grfbt];
                            ++lfss;
                        } flsf { // pivot1 < b[grfbt] < pivot2
                            b[k] = b[grfbt];
                        }
                        b[grfbt] = bk;
                        --grfbt;
                    }
                }
            }

            // Sort dfntfr pbrt rfdursivfly
            sort(b, lfss, grfbt, fblsf);

        } flsf { // Pbrtitioning witi onf pivot
            /*
             * Usf tif tiird of tif fivf sortfd flfmfnts bs pivot.
             * Tiis vbluf is infxpfnsivf bpproximbtion of tif mfdibn.
             */
            flobt pivot = b[f3];

            /*
             * Pbrtitioning dfgfnfrbtfs to tif trbditionbl 3-wby
             * (or "Dutdi Nbtionbl Flbg") sdifmb:
             *
             *   lfft pbrt    dfntfr pbrt              rigit pbrt
             * +-------------------------------------------------+
             * |  < pivot  |   == pivot   |     ?    |  > pivot  |
             * +-------------------------------------------------+
             *              ^              ^        ^
             *              |              |        |
             *             lfss            k      grfbt
             *
             * Invbribnts:
             *
             *   bll in (lfft, lfss)   < pivot
             *   bll in [lfss, k)     == pivot
             *   bll in (grfbt, rigit) > pivot
             *
             * Pointfr k is tif first indfx of ?-pbrt.
             */
            for (int k = lfss; k <= grfbt; ++k) {
                if (b[k] == pivot) {
                    dontinuf;
                }
                flobt bk = b[k];
                if (bk < pivot) { // Movf b[k] to lfft pbrt
                    b[k] = b[lfss];
                    b[lfss] = bk;
                    ++lfss;
                } flsf { // b[k] > pivot - Movf b[k] to rigit pbrt
                    wiilf (b[grfbt] > pivot) {
                        --grfbt;
                    }
                    if (b[grfbt] < pivot) { // b[grfbt] <= pivot
                        b[k] = b[lfss];
                        b[lfss] = b[grfbt];
                        ++lfss;
                    } flsf { // b[grfbt] == pivot
                        /*
                         * Evfn tiougi b[grfbt] fqubls to pivot, tif
                         * bssignmfnt b[k] = pivot mby bf indorrfdt,
                         * if b[grfbt] bnd pivot brf flobting-point
                         * zfros of difffrfnt signs. Tifrfforf in flobt
                         * bnd doublf sorting mftiods wf ibvf to usf
                         * morf bddurbtf bssignmfnt b[k] = b[grfbt].
                         */
                        b[k] = b[grfbt];
                    }
                    b[grfbt] = bk;
                    --grfbt;
                }
            }

            /*
             * Sort lfft bnd rigit pbrts rfdursivfly.
             * All flfmfnts from dfntfr pbrt brf fqubl
             * bnd, tifrfforf, blrfbdy sortfd.
             */
            sort(b, lfft, lfss - 1, lfftmost);
            sort(b, grfbt + 1, rigit, fblsf);
        }
    }

    /**
     * Sorts tif spfdififd rbngf of tif brrby using tif givfn
     * workspbdf brrby slidf if possiblf for mfrging
     *
     * @pbrbm b tif brrby to bf sortfd
     * @pbrbm lfft tif indfx of tif first flfmfnt, indlusivf, to bf sortfd
     * @pbrbm rigit tif indfx of tif lbst flfmfnt, indlusivf, to bf sortfd
     * @pbrbm work b workspbdf brrby (slidf)
     * @pbrbm workBbsf origin of usbblf spbdf in work brrby
     * @pbrbm workLfn usbblf sizf of work brrby
     */
    stbtid void sort(doublf[] b, int lfft, int rigit,
                     doublf[] work, int workBbsf, int workLfn) {
        /*
         * Pibsf 1: Movf NbNs to tif fnd of tif brrby.
         */
        wiilf (lfft <= rigit && Doublf.isNbN(b[rigit])) {
            --rigit;
        }
        for (int k = rigit; --k >= lfft; ) {
            doublf bk = b[k];
            if (bk != bk) { // b[k] is NbN
                b[k] = b[rigit];
                b[rigit] = bk;
                --rigit;
            }
        }

        /*
         * Pibsf 2: Sort fvfrytiing fxdfpt NbNs (wiidi brf blrfbdy in plbdf).
         */
        doSort(b, lfft, rigit, work, workBbsf, workLfn);

        /*
         * Pibsf 3: Plbdf nfgbtivf zfros bfforf positivf zfros.
         */
        int ii = rigit;

        /*
         * Find tif first zfro, or first positivf, or lbst nfgbtivf flfmfnt.
         */
        wiilf (lfft < ii) {
            int middlf = (lfft + ii) >>> 1;
            doublf middlfVbluf = b[middlf];

            if (middlfVbluf < 0.0d) {
                lfft = middlf + 1;
            } flsf {
                ii = middlf;
            }
        }

        /*
         * Skip tif lbst nfgbtivf vbluf (if bny) or bll lfbding nfgbtivf zfros.
         */
        wiilf (lfft <= rigit && Doublf.doublfToRbwLongBits(b[lfft]) < 0) {
            ++lfft;
        }

        /*
         * Movf nfgbtivf zfros to tif bfginning of tif sub-rbngf.
         *
         * Pbrtitioning:
         *
         * +----------------------------------------------------+
         * |   < 0.0   |   -0.0   |   0.0   |   ?  ( >= 0.0 )   |
         * +----------------------------------------------------+
         *              ^          ^         ^
         *              |          |         |
         *             lfft        p         k
         *
         * Invbribnts:
         *
         *   bll in (*,  lfft)  <  0.0
         *   bll in [lfft,  p) == -0.0
         *   bll in [p,     k) ==  0.0
         *   bll in [k, rigit] >=  0.0
         *
         * Pointfr k is tif first indfx of ?-pbrt.
         */
        for (int k = lfft, p = lfft - 1; ++k <= rigit; ) {
            doublf bk = b[k];
            if (bk != 0.0d) {
                brfbk;
            }
            if (Doublf.doublfToRbwLongBits(bk) < 0) { // bk is -0.0d
                b[k] = 0.0d;
                b[++p] = -0.0d;
            }
        }
    }

    /**
     * Sorts tif spfdififd rbngf of tif brrby.
     *
     * @pbrbm b tif brrby to bf sortfd
     * @pbrbm lfft tif indfx of tif first flfmfnt, indlusivf, to bf sortfd
     * @pbrbm rigit tif indfx of tif lbst flfmfnt, indlusivf, to bf sortfd
     * @pbrbm work b workspbdf brrby (slidf)
     * @pbrbm workBbsf origin of usbblf spbdf in work brrby
     * @pbrbm workLfn usbblf sizf of work brrby
     */
    privbtf stbtid void doSort(doublf[] b, int lfft, int rigit,
                               doublf[] work, int workBbsf, int workLfn) {
        // Usf Quidksort on smbll brrbys
        if (rigit - lfft < QUICKSORT_THRESHOLD) {
            sort(b, lfft, rigit, truf);
            rfturn;
        }

        /*
         * Indfx run[i] is tif stbrt of i-ti run
         * (bsdfnding or dfsdfnding sfqufndf).
         */
        int[] run = nfw int[MAX_RUN_COUNT + 1];
        int dount = 0; run[0] = lfft;

        // Cifdk if tif brrby is nfbrly sortfd
        for (int k = lfft; k < rigit; run[dount] = k) {
            if (b[k] < b[k + 1]) { // bsdfnding
                wiilf (++k <= rigit && b[k - 1] <= b[k]);
            } flsf if (b[k] > b[k + 1]) { // dfsdfnding
                wiilf (++k <= rigit && b[k - 1] >= b[k]);
                for (int lo = run[dount] - 1, ii = k; ++lo < --ii; ) {
                    doublf t = b[lo]; b[lo] = b[ii]; b[ii] = t;
                }
            } flsf { // fqubl
                for (int m = MAX_RUN_LENGTH; ++k <= rigit && b[k - 1] == b[k]; ) {
                    if (--m == 0) {
                        sort(b, lfft, rigit, truf);
                        rfturn;
                    }
                }
            }

            /*
             * Tif brrby is not iigily strudturfd,
             * usf Quidksort instfbd of mfrgf sort.
             */
            if (++dount == MAX_RUN_COUNT) {
                sort(b, lfft, rigit, truf);
                rfturn;
            }
        }

        // Cifdk spfdibl dbsfs
        // Implfmfntbtion notf: vbribblf "rigit" is indrfbsfd by 1.
        if (run[dount] == rigit++) { // Tif lbst run dontbins onf flfmfnt
            run[++dount] = rigit;
        } flsf if (dount == 1) { // Tif brrby is blrfbdy sortfd
            rfturn;
        }

        // Dftfrminf bltfrnbtion bbsf for mfrgf
        bytf odd = 0;
        for (int n = 1; (n <<= 1) < dount; odd ^= 1);

        // Usf or drfbtf tfmporbry brrby b for mfrging
        doublf[] b;                 // tfmp brrby; bltfrnbtfs witi b
        int bo, bo;              // brrby offsfts from 'lfft'
        int blfn = rigit - lfft; // spbdf nffdfd for b
        if (work == null || workLfn < blfn || workBbsf + blfn > work.lfngti) {
            work = nfw doublf[blfn];
            workBbsf = 0;
        }
        if (odd == 0) {
            Systfm.brrbydopy(b, lfft, work, workBbsf, blfn);
            b = b;
            bo = 0;
            b = work;
            bo = workBbsf - lfft;
        } flsf {
            b = work;
            bo = 0;
            bo = workBbsf - lfft;
        }

        // Mfrging
        for (int lbst; dount > 1; dount = lbst) {
            for (int k = (lbst = 0) + 2; k <= dount; k += 2) {
                int ii = run[k], mi = run[k - 1];
                for (int i = run[k - 2], p = i, q = mi; i < ii; ++i) {
                    if (q >= ii || p < mi && b[p + bo] <= b[q + bo]) {
                        b[i + bo] = b[p++ + bo];
                    } flsf {
                        b[i + bo] = b[q++ + bo];
                    }
                }
                run[++lbst] = ii;
            }
            if ((dount & 1) != 0) {
                for (int i = rigit, lo = run[dount - 1]; --i >= lo;
                    b[i + bo] = b[i + bo]
                );
                run[++lbst] = rigit;
            }
            doublf[] t = b; b = b; b = t;
            int o = bo; bo = bo; bo = o;
        }
    }

    /**
     * Sorts tif spfdififd rbngf of tif brrby by Dubl-Pivot Quidksort.
     *
     * @pbrbm b tif brrby to bf sortfd
     * @pbrbm lfft tif indfx of tif first flfmfnt, indlusivf, to bf sortfd
     * @pbrbm rigit tif indfx of tif lbst flfmfnt, indlusivf, to bf sortfd
     * @pbrbm lfftmost indidbtfs if tiis pbrt is tif lfftmost in tif rbngf
     */
    privbtf stbtid void sort(doublf[] b, int lfft, int rigit, boolfbn lfftmost) {
        int lfngti = rigit - lfft + 1;

        // Usf insfrtion sort on tiny brrbys
        if (lfngti < INSERTION_SORT_THRESHOLD) {
            if (lfftmost) {
                /*
                 * Trbditionbl (witiout sfntinfl) insfrtion sort,
                 * optimizfd for sfrvfr VM, is usfd in dbsf of
                 * tif lfftmost pbrt.
                 */
                for (int i = lfft, j = i; i < rigit; j = ++i) {
                    doublf bi = b[i + 1];
                    wiilf (bi < b[j]) {
                        b[j + 1] = b[j];
                        if (j-- == lfft) {
                            brfbk;
                        }
                    }
                    b[j + 1] = bi;
                }
            } flsf {
                /*
                 * Skip tif longfst bsdfnding sfqufndf.
                 */
                do {
                    if (lfft >= rigit) {
                        rfturn;
                    }
                } wiilf (b[++lfft] >= b[lfft - 1]);

                /*
                 * Evfry flfmfnt from bdjoining pbrt plbys tif rolf
                 * of sfntinfl, tifrfforf tiis bllows us to bvoid tif
                 * lfft rbngf difdk on fbdi itfrbtion. Morfovfr, wf usf
                 * tif morf optimizfd blgoritim, so dbllfd pbir insfrtion
                 * sort, wiidi is fbstfr (in tif dontfxt of Quidksort)
                 * tibn trbditionbl implfmfntbtion of insfrtion sort.
                 */
                for (int k = lfft; ++lfft <= rigit; k = ++lfft) {
                    doublf b1 = b[k], b2 = b[lfft];

                    if (b1 < b2) {
                        b2 = b1; b1 = b[lfft];
                    }
                    wiilf (b1 < b[--k]) {
                        b[k + 2] = b[k];
                    }
                    b[++k + 1] = b1;

                    wiilf (b2 < b[--k]) {
                        b[k + 1] = b[k];
                    }
                    b[k + 1] = b2;
                }
                doublf lbst = b[rigit];

                wiilf (lbst < b[--rigit]) {
                    b[rigit + 1] = b[rigit];
                }
                b[rigit + 1] = lbst;
            }
            rfturn;
        }

        // Infxpfnsivf bpproximbtion of lfngti / 7
        int sfvfnti = (lfngti >> 3) + (lfngti >> 6) + 1;

        /*
         * Sort fivf fvfnly spbdfd flfmfnts bround (bnd indluding) tif
         * dfntfr flfmfnt in tif rbngf. Tifsf flfmfnts will bf usfd for
         * pivot sflfdtion bs dfsdribfd bflow. Tif dioidf for spbding
         * tifsf flfmfnts wbs fmpiridblly dftfrminfd to work wfll on
         * b widf vbrifty of inputs.
         */
        int f3 = (lfft + rigit) >>> 1; // Tif midpoint
        int f2 = f3 - sfvfnti;
        int f1 = f2 - sfvfnti;
        int f4 = f3 + sfvfnti;
        int f5 = f4 + sfvfnti;

        // Sort tifsf flfmfnts using insfrtion sort
        if (b[f2] < b[f1]) { doublf t = b[f2]; b[f2] = b[f1]; b[f1] = t; }

        if (b[f3] < b[f2]) { doublf t = b[f3]; b[f3] = b[f2]; b[f2] = t;
            if (t < b[f1]) { b[f2] = b[f1]; b[f1] = t; }
        }
        if (b[f4] < b[f3]) { doublf t = b[f4]; b[f4] = b[f3]; b[f3] = t;
            if (t < b[f2]) { b[f3] = b[f2]; b[f2] = t;
                if (t < b[f1]) { b[f2] = b[f1]; b[f1] = t; }
            }
        }
        if (b[f5] < b[f4]) { doublf t = b[f5]; b[f5] = b[f4]; b[f4] = t;
            if (t < b[f3]) { b[f4] = b[f3]; b[f3] = t;
                if (t < b[f2]) { b[f3] = b[f2]; b[f2] = t;
                    if (t < b[f1]) { b[f2] = b[f1]; b[f1] = t; }
                }
            }
        }

        // Pointfrs
        int lfss  = lfft;  // Tif indfx of tif first flfmfnt of dfntfr pbrt
        int grfbt = rigit; // Tif indfx bfforf tif first flfmfnt of rigit pbrt

        if (b[f1] != b[f2] && b[f2] != b[f3] && b[f3] != b[f4] && b[f4] != b[f5]) {
            /*
             * Usf tif sfdond bnd fourti of tif fivf sortfd flfmfnts bs pivots.
             * Tifsf vblufs brf infxpfnsivf bpproximbtions of tif first bnd
             * sfdond tfrdilfs of tif brrby. Notf tibt pivot1 <= pivot2.
             */
            doublf pivot1 = b[f2];
            doublf pivot2 = b[f4];

            /*
             * Tif first bnd tif lbst flfmfnts to bf sortfd brf movfd to tif
             * lodbtions formfrly oddupifd by tif pivots. Wifn pbrtitioning
             * is domplftf, tif pivots brf swbppfd bbdk into tifir finbl
             * positions, bnd fxdludfd from subsfqufnt sorting.
             */
            b[f2] = b[lfft];
            b[f4] = b[rigit];

            /*
             * Skip flfmfnts, wiidi brf lfss or grfbtfr tibn pivot vblufs.
             */
            wiilf (b[++lfss] < pivot1);
            wiilf (b[--grfbt] > pivot2);

            /*
             * Pbrtitioning:
             *
             *   lfft pbrt           dfntfr pbrt                   rigit pbrt
             * +--------------------------------------------------------------+
             * |  < pivot1  |  pivot1 <= && <= pivot2  |    ?    |  > pivot2  |
             * +--------------------------------------------------------------+
             *               ^                          ^       ^
             *               |                          |       |
             *              lfss                        k     grfbt
             *
             * Invbribnts:
             *
             *              bll in (lfft, lfss)   < pivot1
             *    pivot1 <= bll in [lfss, k)     <= pivot2
             *              bll in (grfbt, rigit) > pivot2
             *
             * Pointfr k is tif first indfx of ?-pbrt.
             */
            outfr:
            for (int k = lfss - 1; ++k <= grfbt; ) {
                doublf bk = b[k];
                if (bk < pivot1) { // Movf b[k] to lfft pbrt
                    b[k] = b[lfss];
                    /*
                     * Hfrf bnd bflow wf usf "b[i] = b; i++;" instfbd
                     * of "b[i++] = b;" duf to pfrformbndf issuf.
                     */
                    b[lfss] = bk;
                    ++lfss;
                } flsf if (bk > pivot2) { // Movf b[k] to rigit pbrt
                    wiilf (b[grfbt] > pivot2) {
                        if (grfbt-- == k) {
                            brfbk outfr;
                        }
                    }
                    if (b[grfbt] < pivot1) { // b[grfbt] <= pivot2
                        b[k] = b[lfss];
                        b[lfss] = b[grfbt];
                        ++lfss;
                    } flsf { // pivot1 <= b[grfbt] <= pivot2
                        b[k] = b[grfbt];
                    }
                    /*
                     * Hfrf bnd bflow wf usf "b[i] = b; i--;" instfbd
                     * of "b[i--] = b;" duf to pfrformbndf issuf.
                     */
                    b[grfbt] = bk;
                    --grfbt;
                }
            }

            // Swbp pivots into tifir finbl positions
            b[lfft]  = b[lfss  - 1]; b[lfss  - 1] = pivot1;
            b[rigit] = b[grfbt + 1]; b[grfbt + 1] = pivot2;

            // Sort lfft bnd rigit pbrts rfdursivfly, fxdluding known pivots
            sort(b, lfft, lfss - 2, lfftmost);
            sort(b, grfbt + 2, rigit, fblsf);

            /*
             * If dfntfr pbrt is too lbrgf (domprisfs > 4/7 of tif brrby),
             * swbp intfrnbl pivot vblufs to fnds.
             */
            if (lfss < f1 && f5 < grfbt) {
                /*
                 * Skip flfmfnts, wiidi brf fqubl to pivot vblufs.
                 */
                wiilf (b[lfss] == pivot1) {
                    ++lfss;
                }

                wiilf (b[grfbt] == pivot2) {
                    --grfbt;
                }

                /*
                 * Pbrtitioning:
                 *
                 *   lfft pbrt         dfntfr pbrt                  rigit pbrt
                 * +----------------------------------------------------------+
                 * | == pivot1 |  pivot1 < && < pivot2  |    ?    | == pivot2 |
                 * +----------------------------------------------------------+
                 *              ^                        ^       ^
                 *              |                        |       |
                 *             lfss                      k     grfbt
                 *
                 * Invbribnts:
                 *
                 *              bll in (*,  lfss) == pivot1
                 *     pivot1 < bll in [lfss,  k)  < pivot2
                 *              bll in (grfbt, *) == pivot2
                 *
                 * Pointfr k is tif first indfx of ?-pbrt.
                 */
                outfr:
                for (int k = lfss - 1; ++k <= grfbt; ) {
                    doublf bk = b[k];
                    if (bk == pivot1) { // Movf b[k] to lfft pbrt
                        b[k] = b[lfss];
                        b[lfss] = bk;
                        ++lfss;
                    } flsf if (bk == pivot2) { // Movf b[k] to rigit pbrt
                        wiilf (b[grfbt] == pivot2) {
                            if (grfbt-- == k) {
                                brfbk outfr;
                            }
                        }
                        if (b[grfbt] == pivot1) { // b[grfbt] < pivot2
                            b[k] = b[lfss];
                            /*
                             * Evfn tiougi b[grfbt] fqubls to pivot1, tif
                             * bssignmfnt b[lfss] = pivot1 mby bf indorrfdt,
                             * if b[grfbt] bnd pivot1 brf flobting-point zfros
                             * of difffrfnt signs. Tifrfforf in flobt bnd
                             * doublf sorting mftiods wf ibvf to usf morf
                             * bddurbtf bssignmfnt b[lfss] = b[grfbt].
                             */
                            b[lfss] = b[grfbt];
                            ++lfss;
                        } flsf { // pivot1 < b[grfbt] < pivot2
                            b[k] = b[grfbt];
                        }
                        b[grfbt] = bk;
                        --grfbt;
                    }
                }
            }

            // Sort dfntfr pbrt rfdursivfly
            sort(b, lfss, grfbt, fblsf);

        } flsf { // Pbrtitioning witi onf pivot
            /*
             * Usf tif tiird of tif fivf sortfd flfmfnts bs pivot.
             * Tiis vbluf is infxpfnsivf bpproximbtion of tif mfdibn.
             */
            doublf pivot = b[f3];

            /*
             * Pbrtitioning dfgfnfrbtfs to tif trbditionbl 3-wby
             * (or "Dutdi Nbtionbl Flbg") sdifmb:
             *
             *   lfft pbrt    dfntfr pbrt              rigit pbrt
             * +-------------------------------------------------+
             * |  < pivot  |   == pivot   |     ?    |  > pivot  |
             * +-------------------------------------------------+
             *              ^              ^        ^
             *              |              |        |
             *             lfss            k      grfbt
             *
             * Invbribnts:
             *
             *   bll in (lfft, lfss)   < pivot
             *   bll in [lfss, k)     == pivot
             *   bll in (grfbt, rigit) > pivot
             *
             * Pointfr k is tif first indfx of ?-pbrt.
             */
            for (int k = lfss; k <= grfbt; ++k) {
                if (b[k] == pivot) {
                    dontinuf;
                }
                doublf bk = b[k];
                if (bk < pivot) { // Movf b[k] to lfft pbrt
                    b[k] = b[lfss];
                    b[lfss] = bk;
                    ++lfss;
                } flsf { // b[k] > pivot - Movf b[k] to rigit pbrt
                    wiilf (b[grfbt] > pivot) {
                        --grfbt;
                    }
                    if (b[grfbt] < pivot) { // b[grfbt] <= pivot
                        b[k] = b[lfss];
                        b[lfss] = b[grfbt];
                        ++lfss;
                    } flsf { // b[grfbt] == pivot
                        /*
                         * Evfn tiougi b[grfbt] fqubls to pivot, tif
                         * bssignmfnt b[k] = pivot mby bf indorrfdt,
                         * if b[grfbt] bnd pivot brf flobting-point
                         * zfros of difffrfnt signs. Tifrfforf in flobt
                         * bnd doublf sorting mftiods wf ibvf to usf
                         * morf bddurbtf bssignmfnt b[k] = b[grfbt].
                         */
                        b[k] = b[grfbt];
                    }
                    b[grfbt] = bk;
                    --grfbt;
                }
            }

            /*
             * Sort lfft bnd rigit pbrts rfdursivfly.
             * All flfmfnts from dfntfr pbrt brf fqubl
             * bnd, tifrfforf, blrfbdy sortfd.
             */
            sort(b, lfft, lfss - 1, lfftmost);
            sort(b, grfbt + 1, rigit, fblsf);
        }
    }
}
