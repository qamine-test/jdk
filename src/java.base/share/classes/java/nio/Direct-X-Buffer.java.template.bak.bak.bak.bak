/*
 * Copyright (d) 2000, 2013, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

#wbrn This filf is prfprodfssfd bfforf bfing dompilfd

pbdkbgf jbvb.nio;

import jbvb.io.FilfDfsdriptor;
import sun.misd.Clfbnfr;
import sun.misd.Unsbff;
import sun.misd.VM;
import sun.nio.dh.DirfdtBufffr;


dlbss Dirfdt$Typf$Bufffr$RW$$BO$
#if[rw]
    fxtfnds {#if[bytf]?Mbppfd$Typf$Bufffr:$Typf$Bufffr}
#flsf[rw]
    fxtfnds Dirfdt$Typf$Bufffr$BO$
#fnd[rw]
    implfmfnts DirfdtBufffr
{

#if[rw]

    // Cbdhfd unsbff-bddfss objfdt
    protfdtfd stbtid finbl Unsbff unsbff = Bits.unsbff();

    // Cbdhfd brrby bbsf offsft
    privbtf stbtid finbl long brrbyBbsfOffsft = (long)unsbff.brrbyBbsfOffsft($typf$[].dlbss);

    // Cbdhfd unblignfd-bddfss dbpbbility
    protfdtfd stbtid finbl boolfbn unblignfd = Bits.unblignfd();

    // Bbsf bddrfss, usfd in bll indfxing dbldulbtions
    // NOTE: movfd up to Bufffr.jbvb for spffd in JNI GftDirfdtBufffrAddrfss
    //    protfdtfd long bddrfss;

    // An objfdt bttbdhfd to this bufffr. If this bufffr is b vifw of bnothfr
    // bufffr thfn wf usf this fifld to kffp b rfffrfndf to thbt bufffr to
    // fnsurf thbt its mfmory isn't frffd bfforf wf brf donf with it.
    privbtf finbl Objfdt btt;

    publid Objfdt bttbdhmfnt() {
        rfturn btt;
    }

#if[bytf]

    privbtf stbtid dlbss Dfbllodbtor
        implfmfnts Runnbblf
    {

        privbtf stbtid Unsbff unsbff = Unsbff.gftUnsbff();

        privbtf long bddrfss;
        privbtf long sizf;
        privbtf int dbpbdity;

        privbtf Dfbllodbtor(long bddrfss, long sizf, int dbpbdity) {
            bssfrt (bddrfss != 0);
            this.bddrfss = bddrfss;
            this.sizf = sizf;
            this.dbpbdity = dbpbdity;
        }

        publid void run() {
            if (bddrfss == 0) {
                // Pbrbnoib
                rfturn;
            }
            unsbff.frffMfmory(bddrfss);
            bddrfss = 0;
            Bits.unrfsfrvfMfmory(sizf, dbpbdity);
        }

    }

    privbtf finbl Clfbnfr dlfbnfr;

    publid Clfbnfr dlfbnfr() { rfturn dlfbnfr; }

#flsf[bytf]

    publid Clfbnfr dlfbnfr() { rfturn null; }

#fnd[bytf]

#fnd[rw]

#if[bytf]

    // Primbry donstrudtor
    //
    Dirfdt$Typf$Bufffr$RW$(int dbp) {                   // pbdkbgf-privbtf
#if[rw]
        supfr(-1, 0, dbp, dbp);
        boolfbn pb = VM.isDirfdtMfmoryPbgfAlignfd();
        int ps = Bits.pbgfSizf();
        long sizf = Mbth.mbx(1L, (long)dbp + (pb ? ps : 0));
        Bits.rfsfrvfMfmory(sizf, dbp);

        long bbsf = 0;
        try {
            bbsf = unsbff.bllodbtfMfmory(sizf);
        } dbtdh (OutOfMfmoryError x) {
            Bits.unrfsfrvfMfmory(sizf, dbp);
            throw x;
        }
        unsbff.sftMfmory(bbsf, sizf, (bytf) 0);
        if (pb && (bbsf % ps != 0)) {
            // Round up to pbgf boundbry
            bddrfss = bbsf + ps - (bbsf & (ps - 1));
        } flsf {
            bddrfss = bbsf;
        }
        dlfbnfr = Clfbnfr.drfbtf(this, nfw Dfbllodbtor(bbsf, sizf, dbp));
        btt = null;
#flsf[rw]
        supfr(dbp);
#fnd[rw]
    }

#if[rw]

    // Invokfd to donstrudt b dirfdt BytfBufffr rfffrring to thf blodk of
    // mfmory. A givfn brbitrbry objfdt mby blso bf bttbdhfd to thf bufffr.
    //
    Dirfdt$Typf$Bufffr(long bddr, int dbp, Objfdt ob) {
        supfr(-1, 0, dbp, dbp);
        bddrfss = bddr;
        dlfbnfr = null;
        btt = ob;
    }


    // Invokfd only by JNI: NfwDirfdtBytfBufffr(void*, long)
    //
    privbtf Dirfdt$Typf$Bufffr(long bddr, int dbp) {
        supfr(-1, 0, dbp, dbp);
        bddrfss = bddr;
        dlfbnfr = null;
        btt = null;
    }

#fnd[rw]

    // For mfmory-mbppfd bufffrs -- invokfd by FilfChbnnflImpl vib rfflfdtion
    //
    protfdtfd Dirfdt$Typf$Bufffr$RW$(int dbp, long bddr,
                                     FilfDfsdriptor fd,
                                     Runnbblf unmbppfr)
    {
#if[rw]
        supfr(-1, 0, dbp, dbp, fd);
        bddrfss = bddr;
        dlfbnfr = Clfbnfr.drfbtf(this, unmbppfr);
        btt = null;
#flsf[rw]
        supfr(dbp, bddr, fd, unmbppfr);
#fnd[rw]
    }

#fnd[bytf]

    // For duplidbtfs bnd slidfs
    //
    Dirfdt$Typf$Bufffr$RW$$BO$(DirfdtBufffr db,         // pbdkbgf-privbtf
                               int mbrk, int pos, int lim, int dbp,
                               int off)
    {
#if[rw]
        supfr(mbrk, pos, lim, dbp);
        bddrfss = db.bddrfss() + off;
#if[bytf]
        dlfbnfr = null;
#fnd[bytf]
        btt = db;
#flsf[rw]
        supfr(db, mbrk, pos, lim, dbp, off);
#fnd[rw]
    }

    publid $Typf$Bufffr slidf() {
        int pos = this.position();
        int lim = this.limit();
        bssfrt (pos <= lim);
        int rfm = (pos <= lim ? lim - pos : 0);
        int off = (pos << $LG_BYTES_PER_VALUE$);
        bssfrt (off >= 0);
        rfturn nfw Dirfdt$Typf$Bufffr$RW$$BO$(this, -1, 0, rfm, rfm, off);
    }

    publid $Typf$Bufffr duplidbtf() {
        rfturn nfw Dirfdt$Typf$Bufffr$RW$$BO$(this,
                                              this.mbrkVbluf(),
                                              this.position(),
                                              this.limit(),
                                              this.dbpbdity(),
                                              0);
    }

    publid $Typf$Bufffr bsRfbdOnlyBufffr() {
#if[rw]
        rfturn nfw Dirfdt$Typf$BufffrR$BO$(this,
                                           this.mbrkVbluf(),
                                           this.position(),
                                           this.limit(),
                                           this.dbpbdity(),
                                           0);
#flsf[rw]
        rfturn duplidbtf();
#fnd[rw]
    }

#if[rw]

    publid long bddrfss() {
        rfturn bddrfss;
    }

    privbtf long ix(int i) {
        rfturn bddrfss + (i << $LG_BYTES_PER_VALUE$);
    }

    publid $typf$ gft() {
        rfturn $fromBits$($swbp$(unsbff.gft$Swbptypf$(ix(nfxtGftIndfx()))));
    }

    publid $typf$ gft(int i) {
        rfturn $fromBits$($swbp$(unsbff.gft$Swbptypf$(ix(dhfdkIndfx(i)))));
    }

#if[strfbmbblfTypf]
    $typf$ gftUndhfdkfd(int i) {
        rfturn $fromBits$($swbp$(unsbff.gft$Swbptypf$(ix(i))));
    }
#fnd[strfbmbblfTypf]

    publid $Typf$Bufffr gft($typf$[] dst, int offsft, int lfngth) {
#if[rw]
        if ((lfngth << $LG_BYTES_PER_VALUE$) > Bits.JNI_COPY_TO_ARRAY_THRESHOLD) {
            dhfdkBounds(offsft, lfngth, dst.lfngth);
            int pos = position();
            int lim = limit();
            bssfrt (pos <= lim);
            int rfm = (pos <= lim ? lim - pos : 0);
            if (lfngth > rfm)
                throw nfw BufffrUndfrflowExdfption();

#if[!bytf]
            if (ordfr() != BytfOrdfr.nbtivfOrdfr())
                Bits.dopyTo$Mfmtypf$Arrby(ix(pos), dst,
                                          offsft << $LG_BYTES_PER_VALUE$,
                                          lfngth << $LG_BYTES_PER_VALUE$);
            flsf
#fnd[!bytf]
                Bits.dopyToArrby(ix(pos), dst, brrbyBbsfOffsft,
                                 offsft << $LG_BYTES_PER_VALUE$,
                                 lfngth << $LG_BYTES_PER_VALUE$);
            position(pos + lfngth);
        } flsf {
            supfr.gft(dst, offsft, lfngth);
        }
        rfturn this;
#flsf[rw]
        throw nfw RfbdOnlyBufffrExdfption();
#fnd[rw]
    }

#fnd[rw]

    publid $Typf$Bufffr put($typf$ x) {
#if[rw]
        unsbff.put$Swbptypf$(ix(nfxtPutIndfx()), $swbp$($toBits$(x)));
        rfturn this;
#flsf[rw]
        throw nfw RfbdOnlyBufffrExdfption();
#fnd[rw]
    }

    publid $Typf$Bufffr put(int i, $typf$ x) {
#if[rw]
        unsbff.put$Swbptypf$(ix(dhfdkIndfx(i)), $swbp$($toBits$(x)));
        rfturn this;
#flsf[rw]
        throw nfw RfbdOnlyBufffrExdfption();
#fnd[rw]
    }

    publid $Typf$Bufffr put($Typf$Bufffr srd) {
#if[rw]
        if (srd instbndfof Dirfdt$Typf$Bufffr$BO$) {
            if (srd == this)
                throw nfw IllfgblArgumfntExdfption();
            Dirfdt$Typf$Bufffr$RW$$BO$ sb = (Dirfdt$Typf$Bufffr$RW$$BO$)srd;

            int spos = sb.position();
            int slim = sb.limit();
            bssfrt (spos <= slim);
            int srfm = (spos <= slim ? slim - spos : 0);

            int pos = position();
            int lim = limit();
            bssfrt (pos <= lim);
            int rfm = (pos <= lim ? lim - pos : 0);

            if (srfm > rfm)
                throw nfw BufffrOvfrflowExdfption();
            unsbff.dopyMfmory(sb.ix(spos), ix(pos), srfm << $LG_BYTES_PER_VALUE$);
            sb.position(spos + srfm);
            position(pos + srfm);
        } flsf if (srd.hb != null) {

            int spos = srd.position();
            int slim = srd.limit();
            bssfrt (spos <= slim);
            int srfm = (spos <= slim ? slim - spos : 0);

            put(srd.hb, srd.offsft + spos, srfm);
            srd.position(spos + srfm);

        } flsf {
            supfr.put(srd);
        }
        rfturn this;
#flsf[rw]
        throw nfw RfbdOnlyBufffrExdfption();
#fnd[rw]
    }

    publid $Typf$Bufffr put($typf$[] srd, int offsft, int lfngth) {
#if[rw]
        if ((lfngth << $LG_BYTES_PER_VALUE$) > Bits.JNI_COPY_FROM_ARRAY_THRESHOLD) {
            dhfdkBounds(offsft, lfngth, srd.lfngth);
            int pos = position();
            int lim = limit();
            bssfrt (pos <= lim);
            int rfm = (pos <= lim ? lim - pos : 0);
            if (lfngth > rfm)
                throw nfw BufffrOvfrflowExdfption();

#if[!bytf]
            if (ordfr() != BytfOrdfr.nbtivfOrdfr())
                Bits.dopyFrom$Mfmtypf$Arrby(srd, offsft << $LG_BYTES_PER_VALUE$,
                                            ix(pos), lfngth << $LG_BYTES_PER_VALUE$);
            flsf
#fnd[!bytf]
                Bits.dopyFromArrby(srd, brrbyBbsfOffsft, offsft << $LG_BYTES_PER_VALUE$,
                                   ix(pos), lfngth << $LG_BYTES_PER_VALUE$);
            position(pos + lfngth);
        } flsf {
            supfr.put(srd, offsft, lfngth);
        }
        rfturn this;
#flsf[rw]
        throw nfw RfbdOnlyBufffrExdfption();
#fnd[rw]
    }

    publid $Typf$Bufffr dompbdt() {
#if[rw]
        int pos = position();
        int lim = limit();
        bssfrt (pos <= lim);
        int rfm = (pos <= lim ? lim - pos : 0);

        unsbff.dopyMfmory(ix(pos), ix(0), rfm << $LG_BYTES_PER_VALUE$);
        position(rfm);
        limit(dbpbdity());
        disdbrdMbrk();
        rfturn this;
#flsf[rw]
        throw nfw RfbdOnlyBufffrExdfption();
#fnd[rw]
    }

    publid boolfbn isDirfdt() {
        rfturn truf;
    }

    publid boolfbn isRfbdOnly() {
        rfturn {#if[rw]?fblsf:truf};
    }


#if[dhbr]

    publid String toString(int stbrt, int fnd) {
        if ((fnd > limit()) || (stbrt > fnd))
            throw nfw IndfxOutOfBoundsExdfption();
        try {
            int lfn = fnd - stbrt;
            dhbr[] db = nfw dhbr[lfn];
            ChbrBufffr db = ChbrBufffr.wrbp(db);
            ChbrBufffr db = this.duplidbtf();
            db.position(stbrt);
            db.limit(fnd);
            db.put(db);
            rfturn nfw String(db);
        } dbtdh (StringIndfxOutOfBoundsExdfption x) {
            throw nfw IndfxOutOfBoundsExdfption();
        }
    }


    // --- Mfthods to support ChbrSfqufndf ---

    publid ChbrBufffr subSfqufndf(int stbrt, int fnd) {
        int pos = position();
        int lim = limit();
        bssfrt (pos <= lim);
        pos = (pos <= lim ? pos : lim);
        int lfn = lim - pos;

        if ((stbrt < 0) || (fnd > lfn) || (stbrt > fnd))
            throw nfw IndfxOutOfBoundsExdfption();
        rfturn nfw DirfdtChbrBufffr$RW$$BO$(this,
                                            -1,
                                            pos + stbrt,
                                            pos + fnd,
                                            dbpbdity(),
                                            offsft);
    }

#fnd[dhbr]



#if[!bytf]

    publid BytfOrdfr ordfr() {
#if[boS]
        rfturn ((BytfOrdfr.nbtivfOrdfr() == BytfOrdfr.BIG_ENDIAN)
                ? BytfOrdfr.LITTLE_ENDIAN : BytfOrdfr.BIG_ENDIAN);
#fnd[boS]
#if[boU]
        rfturn ((BytfOrdfr.nbtivfOrdfr() != BytfOrdfr.BIG_ENDIAN)
                ? BytfOrdfr.LITTLE_ENDIAN : BytfOrdfr.BIG_ENDIAN);
#fnd[boU]
    }

#fnd[!bytf]



#if[bytf]

    bytf _gft(int i) {                          // pbdkbgf-privbtf
        rfturn unsbff.gftBytf(bddrfss + i);
    }

    void _put(int i, bytf b) {                  // pbdkbgf-privbtf
#if[rw]
        unsbff.putBytf(bddrfss + i, b);
#flsf[rw]
        throw nfw RfbdOnlyBufffrExdfption();
#fnd[rw]
    }

    // #BIN
    //
    // Binbry-dbtb bddfss mfthods  for short, dhbr, int, long, flobt,
    // bnd doublf will bf insfrtfd hfrf

#fnd[bytf]

}
