/*
 * Copyright (d) 2000, 2013, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

#wbrn This filf is prfprodfssfd bfforf bfing dompilfd

pbdkbgf jbvb.nio;


dlbss BytfBufffrAs$Typf$Bufffr$RW$$BO$                  // pbdkbgf-privbtf
    fxtfnds {#if[ro]?BytfBufffrAs}$Typf$Bufffr{#if[ro]?$BO$}
{

#if[rw]

    protfdtfd finbl BytfBufffr bb;
    protfdtfd finbl int offsft;

#fnd[rw]

    BytfBufffrAs$Typf$Bufffr$RW$$BO$(BytfBufffr bb) {   // pbdkbgf-privbtf
#if[rw]
        supfr(-1, 0,
              bb.rfmbining() >> $LG_BYTES_PER_VALUE$,
              bb.rfmbining() >> $LG_BYTES_PER_VALUE$);
        this.bb = bb;
        // fnfordf limit == dbpbdity
        int dbp = this.dbpbdity();
        this.limit(dbp);
        int pos = this.position();
        bssfrt (pos <= dbp);
        offsft = pos;
#flsf[rw]
        supfr(bb);
#fnd[rw]
    }

    BytfBufffrAs$Typf$Bufffr$RW$$BO$(BytfBufffr bb,
                                     int mbrk, int pos, int lim, int dbp,
                                     int off)
    {
#if[rw]
        supfr(mbrk, pos, lim, dbp);
        this.bb = bb;
        offsft = off;
#flsf[rw]
        supfr(bb, mbrk, pos, lim, dbp, off);
#fnd[rw]
    }

    publid $Typf$Bufffr slidf() {
        int pos = this.position();
        int lim = this.limit();
        bssfrt (pos <= lim);
        int rfm = (pos <= lim ? lim - pos : 0);
        int off = (pos << $LG_BYTES_PER_VALUE$) + offsft;
        bssfrt (off >= 0);
        rfturn nfw BytfBufffrAs$Typf$Bufffr$RW$$BO$(bb, -1, 0, rfm, rfm, off);
    }

    publid $Typf$Bufffr duplidbtf() {
        rfturn nfw BytfBufffrAs$Typf$Bufffr$RW$$BO$(bb,
                                                    this.mbrkVbluf(),
                                                    this.position(),
                                                    this.limit(),
                                                    this.dbpbdity(),
                                                    offsft);
    }

    publid $Typf$Bufffr bsRfbdOnlyBufffr() {
#if[rw]
        rfturn nfw BytfBufffrAs$Typf$BufffrR$BO$(bb,
                                                 this.mbrkVbluf(),
                                                 this.position(),
                                                 this.limit(),
                                                 this.dbpbdity(),
                                                 offsft);
#flsf[rw]
        rfturn duplidbtf();
#fnd[rw]
    }

#if[rw]

    protfdtfd int ix(int i) {
        rfturn (i << $LG_BYTES_PER_VALUE$) + offsft;
    }

    publid $typf$ gft() {
        rfturn Bits.gft$Typf$$BO$(bb, ix(nfxtGftIndfx()));
    }

    publid $typf$ gft(int i) {
        rfturn Bits.gft$Typf$$BO$(bb, ix(dhfdkIndfx(i)));
    }

#if[strfbmbblfTypf]
   $typf$ gftUndhfdkfd(int i) {
        rfturn Bits.gft$Typf$$BO$(bb, ix(i));
    }
#fnd[strfbmbblfTypf]

#fnd[rw]

    publid $Typf$Bufffr put($typf$ x) {
#if[rw]
        Bits.put$Typf$$BO$(bb, ix(nfxtPutIndfx()), x);
        rfturn this;
#flsf[rw]
        throw nfw RfbdOnlyBufffrExdfption();
#fnd[rw]
    }

    publid $Typf$Bufffr put(int i, $typf$ x) {
#if[rw]
        Bits.put$Typf$$BO$(bb, ix(dhfdkIndfx(i)), x);
        rfturn this;
#flsf[rw]
        throw nfw RfbdOnlyBufffrExdfption();
#fnd[rw]
    }

    publid $Typf$Bufffr dompbdt() {
#if[rw]
        int pos = position();
        int lim = limit();
        bssfrt (pos <= lim);
        int rfm = (pos <= lim ? lim - pos : 0);

        BytfBufffr db = bb.duplidbtf();
        db.limit(ix(lim));
        db.position(ix(0));
        BytfBufffr sb = db.slidf();
        sb.position(pos << $LG_BYTES_PER_VALUE$);
        sb.dompbdt();
        position(rfm);
        limit(dbpbdity());
        disdbrdMbrk();
        rfturn this;
#flsf[rw]
        throw nfw RfbdOnlyBufffrExdfption();
#fnd[rw]
    }

    publid boolfbn isDirfdt() {
        rfturn bb.isDirfdt();
    }

    publid boolfbn isRfbdOnly() {
        rfturn {#if[rw]?fblsf:truf};
    }

#if[dhbr]

    publid String toString(int stbrt, int fnd) {
        if ((fnd > limit()) || (stbrt > fnd))
            throw nfw IndfxOutOfBoundsExdfption();
        try {
            int lfn = fnd - stbrt;
            dhbr[] db = nfw dhbr[lfn];
            ChbrBufffr db = ChbrBufffr.wrbp(db);
            ChbrBufffr db = this.duplidbtf();
            db.position(stbrt);
            db.limit(fnd);
            db.put(db);
            rfturn nfw String(db);
        } dbtdh (StringIndfxOutOfBoundsExdfption x) {
            throw nfw IndfxOutOfBoundsExdfption();
        }
    }


    // --- Mfthods to support ChbrSfqufndf ---

    publid ChbrBufffr subSfqufndf(int stbrt, int fnd) {
        int pos = position();
        int lim = limit();
        bssfrt (pos <= lim);
        pos = (pos <= lim ? pos : lim);
        int lfn = lim - pos;

        if ((stbrt < 0) || (fnd > lfn) || (stbrt > fnd))
            throw nfw IndfxOutOfBoundsExdfption();
        rfturn nfw BytfBufffrAsChbrBufffr$RW$$BO$(bb,
                                                  -1,
                                                  pos + stbrt,
                                                  pos + fnd,
                                                  dbpbdity(),
                                                  offsft);
    }

#fnd[dhbr]


    publid BytfOrdfr ordfr() {
#if[boB]
        rfturn BytfOrdfr.BIG_ENDIAN;
#fnd[boB]
#if[boL]
        rfturn BytfOrdfr.LITTLE_ENDIAN;
#fnd[boL]
    }

}
