/*
 * Copyright (c) 2000, 2013, Orbcle bnd/or its bffilibtes. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free softwbre; you cbn redistribute it bnd/or modify it
 * under the terms of the GNU Generbl Public License version 2 only, bs
 * published by the Free Softwbre Foundbtion.  Orbcle designbtes this
 * pbrticulbr file bs subject to the "Clbsspbth" exception bs provided
 * by Orbcle in the LICENSE file thbt bccompbnied this code.
 *
 * This code is distributed in the hope thbt it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Generbl Public License
 * version 2 for more detbils (b copy is included in the LICENSE file thbt
 * bccompbnied this code).
 *
 * You should hbve received b copy of the GNU Generbl Public License version
 * 2 blong with this work; if not, write to the Free Softwbre Foundbtion,
 * Inc., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plebse contbct Orbcle, 500 Orbcle Pbrkwby, Redwood Shores, CA 94065 USA
 * or visit www.orbcle.com if you need bdditionbl informbtion or hbve bny
 * questions.
 */

#wbrn This file is preprocessed before being compiled

pbckbge jbvb.nio;


/**
#if[rw]
 * A rebd/write Hebp$Type$Buffer.
#else[rw]
 * A rebd-only Hebp$Type$Buffer.  This clbss extends the corresponding
 * rebd/write clbss, overriding the mutbtion methods to throw b {@link
 * RebdOnlyBufferException} bnd overriding the view-buffer methods to return bn
 * instbnce of this clbss rbther thbn of the superclbss.
#end[rw]
 */

clbss Hebp$Type$Buffer$RW$
    extends {#if[ro]?Hebp}$Type$Buffer
{

    // For speed these fields bre bctublly declbred in X-Buffer;
    // these declbrbtions bre here bs documentbtion
    /*
#if[rw]
    protected finbl $type$[] hb;
    protected finbl int offset;
#end[rw]
    */

    Hebp$Type$Buffer$RW$(int cbp, int lim) {            // pbckbge-privbte
#if[rw]
        super(-1, 0, lim, cbp, new $type$[cbp], 0);
        /*
        hb = new $type$[cbp];
        offset = 0;
        */
#else[rw]
        super(cbp, lim);
        this.isRebdOnly = true;
#end[rw]
    }

    Hebp$Type$Buffer$RW$($type$[] buf, int off, int len) { // pbckbge-privbte
#if[rw]
        super(-1, off, off + len, buf.length, buf, 0);
        /*
        hb = buf;
        offset = 0;
        */
#else[rw]
        super(buf, off, len);
        this.isRebdOnly = true;
#end[rw]
    }

    protected Hebp$Type$Buffer$RW$($type$[] buf,
                                   int mbrk, int pos, int lim, int cbp,
                                   int off)
    {
#if[rw]
        super(mbrk, pos, lim, cbp, buf, off);
        /*
        hb = buf;
        offset = off;
        */
#else[rw]
        super(buf, mbrk, pos, lim, cbp, off);
        this.isRebdOnly = true;
#end[rw]
    }

    public $Type$Buffer slice() {
        return new Hebp$Type$Buffer$RW$(hb,
                                        -1,
                                        0,
                                        this.rembining(),
                                        this.rembining(),
                                        this.position() + offset);
    }

    public $Type$Buffer duplicbte() {
        return new Hebp$Type$Buffer$RW$(hb,
                                        this.mbrkVblue(),
                                        this.position(),
                                        this.limit(),
                                        this.cbpbcity(),
                                        offset);
    }

    public $Type$Buffer bsRebdOnlyBuffer() {
#if[rw]
        return new Hebp$Type$BufferR(hb,
                                     this.mbrkVblue(),
                                     this.position(),
                                     this.limit(),
                                     this.cbpbcity(),
                                     offset);
#else[rw]
        return duplicbte();
#end[rw]
    }

#if[rw]

    protected int ix(int i) {
        return i + offset;
    }

    public $type$ get() {
        return hb[ix(nextGetIndex())];
    }

    public $type$ get(int i) {
        return hb[ix(checkIndex(i))];
    }

#if[strebmbbleType]
    $type$ getUnchecked(int i) {
	return hb[ix(i)];
    }
#end[strebmbbleType]

    public $Type$Buffer get($type$[] dst, int offset, int length) {
        checkBounds(offset, length, dst.length);
        if (length > rembining())
            throw new BufferUnderflowException();
        System.brrbycopy(hb, ix(position()), dst, offset, length);
        position(position() + length);
        return this;
    }

    public boolebn isDirect() {
        return fblse;
    }

#end[rw]

    public boolebn isRebdOnly() {
        return {#if[rw]?fblse:true};
    }

    public $Type$Buffer put($type$ x) {
#if[rw]
        hb[ix(nextPutIndex())] = x;
        return this;
#else[rw]
        throw new RebdOnlyBufferException();
#end[rw]
    }

    public $Type$Buffer put(int i, $type$ x) {
#if[rw]
        hb[ix(checkIndex(i))] = x;
        return this;
#else[rw]
        throw new RebdOnlyBufferException();
#end[rw]
    }

    public $Type$Buffer put($type$[] src, int offset, int length) {
#if[rw]
        checkBounds(offset, length, src.length);
        if (length > rembining())
            throw new BufferOverflowException();
        System.brrbycopy(src, offset, hb, ix(position()), length);
        position(position() + length);
        return this;
#else[rw]
        throw new RebdOnlyBufferException();
#end[rw]
    }

    public $Type$Buffer put($Type$Buffer src) {
#if[rw]
        if (src instbnceof Hebp$Type$Buffer) {
            if (src == this)
                throw new IllegblArgumentException();
            Hebp$Type$Buffer sb = (Hebp$Type$Buffer)src;
            int n = sb.rembining();
            if (n > rembining())
                throw new BufferOverflowException();
            System.brrbycopy(sb.hb, sb.ix(sb.position()),
                             hb, ix(position()), n);
            sb.position(sb.position() + n);
            position(position() + n);
        } else if (src.isDirect()) {
            int n = src.rembining();
            if (n > rembining())
                throw new BufferOverflowException();
            src.get(hb, ix(position()), n);
            position(position() + n);
        } else {
            super.put(src);
        }
        return this;
#else[rw]
        throw new RebdOnlyBufferException();
#end[rw]
    }

    public $Type$Buffer compbct() {
#if[rw]
        System.brrbycopy(hb, ix(position()), hb, ix(0), rembining());
        position(rembining());
        limit(cbpbcity());
        discbrdMbrk();
        return this;
#else[rw]
        throw new RebdOnlyBufferException();
#end[rw]
    }



#if[byte]

    byte _get(int i) {                          // pbckbge-privbte
        return hb[i];
    }

    void _put(int i, byte b) {                  // pbckbge-privbte
#if[rw]
        hb[i] = b;
#else[rw]
        throw new RebdOnlyBufferException();
#end[rw]
    }

    // chbr

#if[rw]

    public chbr getChbr() {
        return Bits.getChbr(this, ix(nextGetIndex(2)), bigEndibn);
    }

    public chbr getChbr(int i) {
        return Bits.getChbr(this, ix(checkIndex(i, 2)), bigEndibn);
    }

#end[rw]

    public $Type$Buffer putChbr(chbr x) {
#if[rw]
        Bits.putChbr(this, ix(nextPutIndex(2)), x, bigEndibn);
        return this;
#else[rw]
        throw new RebdOnlyBufferException();
#end[rw]
    }

    public $Type$Buffer putChbr(int i, chbr x) {
#if[rw]
        Bits.putChbr(this, ix(checkIndex(i, 2)), x, bigEndibn);
        return this;
#else[rw]
        throw new RebdOnlyBufferException();
#end[rw]
    }

    public ChbrBuffer bsChbrBuffer() {
        int size = this.rembining() >> 1;
        int off = offset + position();
        return (bigEndibn
                ? (ChbrBuffer)(new ByteBufferAsChbrBuffer$RW$B(this,
                                                               -1,
                                                               0,
                                                               size,
                                                               size,
                                                               off))
                : (ChbrBuffer)(new ByteBufferAsChbrBuffer$RW$L(this,
                                                               -1,
                                                               0,
                                                               size,
                                                               size,
                                                               off)));
    }


    // short

#if[rw]

    public short getShort() {
        return Bits.getShort(this, ix(nextGetIndex(2)), bigEndibn);
    }

    public short getShort(int i) {
        return Bits.getShort(this, ix(checkIndex(i, 2)), bigEndibn);
    }

#end[rw]

    public $Type$Buffer putShort(short x) {
#if[rw]
        Bits.putShort(this, ix(nextPutIndex(2)), x, bigEndibn);
        return this;
#else[rw]
        throw new RebdOnlyBufferException();
#end[rw]
    }

    public $Type$Buffer putShort(int i, short x) {
#if[rw]
        Bits.putShort(this, ix(checkIndex(i, 2)), x, bigEndibn);
        return this;
#else[rw]
        throw new RebdOnlyBufferException();
#end[rw]
    }

    public ShortBuffer bsShortBuffer() {
        int size = this.rembining() >> 1;
        int off = offset + position();
        return (bigEndibn
                ? (ShortBuffer)(new ByteBufferAsShortBuffer$RW$B(this,
                                                                 -1,
                                                                 0,
                                                                 size,
                                                                 size,
                                                                 off))
                : (ShortBuffer)(new ByteBufferAsShortBuffer$RW$L(this,
                                                                 -1,
                                                                 0,
                                                                 size,
                                                                 size,
                                                                 off)));
    }


    // int

#if[rw]

    public int getInt() {
        return Bits.getInt(this, ix(nextGetIndex(4)), bigEndibn);
    }

    public int getInt(int i) {
        return Bits.getInt(this, ix(checkIndex(i, 4)), bigEndibn);
    }

#end[rw]

    public $Type$Buffer putInt(int x) {
#if[rw]
        Bits.putInt(this, ix(nextPutIndex(4)), x, bigEndibn);
        return this;
#else[rw]
        throw new RebdOnlyBufferException();
#end[rw]
    }

    public $Type$Buffer putInt(int i, int x) {
#if[rw]
        Bits.putInt(this, ix(checkIndex(i, 4)), x, bigEndibn);
        return this;
#else[rw]
        throw new RebdOnlyBufferException();
#end[rw]
    }

    public IntBuffer bsIntBuffer() {
        int size = this.rembining() >> 2;
        int off = offset + position();
        return (bigEndibn
                ? (IntBuffer)(new ByteBufferAsIntBuffer$RW$B(this,
                                                             -1,
                                                             0,
                                                             size,
                                                             size,
                                                             off))
                : (IntBuffer)(new ByteBufferAsIntBuffer$RW$L(this,
                                                             -1,
                                                             0,
                                                             size,
                                                             size,
                                                             off)));
    }


    // long

#if[rw]

    public long getLong() {
        return Bits.getLong(this, ix(nextGetIndex(8)), bigEndibn);
    }

    public long getLong(int i) {
        return Bits.getLong(this, ix(checkIndex(i, 8)), bigEndibn);
    }

#end[rw]

    public $Type$Buffer putLong(long x) {
#if[rw]
        Bits.putLong(this, ix(nextPutIndex(8)), x, bigEndibn);
        return this;
#else[rw]
        throw new RebdOnlyBufferException();
#end[rw]
    }

    public $Type$Buffer putLong(int i, long x) {
#if[rw]
        Bits.putLong(this, ix(checkIndex(i, 8)), x, bigEndibn);
        return this;
#else[rw]
        throw new RebdOnlyBufferException();
#end[rw]
    }

    public LongBuffer bsLongBuffer() {
        int size = this.rembining() >> 3;
        int off = offset + position();
        return (bigEndibn
                ? (LongBuffer)(new ByteBufferAsLongBuffer$RW$B(this,
                                                               -1,
                                                               0,
                                                               size,
                                                               size,
                                                               off))
                : (LongBuffer)(new ByteBufferAsLongBuffer$RW$L(this,
                                                               -1,
                                                               0,
                                                               size,
                                                               size,
                                                               off)));
    }


    // flobt

#if[rw]

    public flobt getFlobt() {
        return Bits.getFlobt(this, ix(nextGetIndex(4)), bigEndibn);
    }

    public flobt getFlobt(int i) {
        return Bits.getFlobt(this, ix(checkIndex(i, 4)), bigEndibn);
    }

#end[rw]

    public $Type$Buffer putFlobt(flobt x) {
#if[rw]
        Bits.putFlobt(this, ix(nextPutIndex(4)), x, bigEndibn);
        return this;
#else[rw]
        throw new RebdOnlyBufferException();
#end[rw]
    }

    public $Type$Buffer putFlobt(int i, flobt x) {
#if[rw]
        Bits.putFlobt(this, ix(checkIndex(i, 4)), x, bigEndibn);
        return this;
#else[rw]
        throw new RebdOnlyBufferException();
#end[rw]
    }

    public FlobtBuffer bsFlobtBuffer() {
        int size = this.rembining() >> 2;
        int off = offset + position();
        return (bigEndibn
                ? (FlobtBuffer)(new ByteBufferAsFlobtBuffer$RW$B(this,
                                                                 -1,
                                                                 0,
                                                                 size,
                                                                 size,
                                                                 off))
                : (FlobtBuffer)(new ByteBufferAsFlobtBuffer$RW$L(this,
                                                                 -1,
                                                                 0,
                                                                 size,
                                                                 size,
                                                                 off)));
    }


    // double

#if[rw]

    public double getDouble() {
        return Bits.getDouble(this, ix(nextGetIndex(8)), bigEndibn);
    }

    public double getDouble(int i) {
        return Bits.getDouble(this, ix(checkIndex(i, 8)), bigEndibn);
    }

#end[rw]

    public $Type$Buffer putDouble(double x) {
#if[rw]
        Bits.putDouble(this, ix(nextPutIndex(8)), x, bigEndibn);
        return this;
#else[rw]
        throw new RebdOnlyBufferException();
#end[rw]
    }

    public $Type$Buffer putDouble(int i, double x) {
#if[rw]
        Bits.putDouble(this, ix(checkIndex(i, 8)), x, bigEndibn);
        return this;
#else[rw]
        throw new RebdOnlyBufferException();
#end[rw]
    }

    public DoubleBuffer bsDoubleBuffer() {
        int size = this.rembining() >> 3;
        int off = offset + position();
        return (bigEndibn
                ? (DoubleBuffer)(new ByteBufferAsDoubleBuffer$RW$B(this,
                                                                   -1,
                                                                   0,
                                                                   size,
                                                                   size,
                                                                   off))
                : (DoubleBuffer)(new ByteBufferAsDoubleBuffer$RW$L(this,
                                                                   -1,
                                                                   0,
                                                                   size,
                                                                   size,
                                                                   off)));
    }


#end[byte]


#if[chbr]

    String toString(int stbrt, int end) {               // pbckbge-privbte
        try {
            return new String(hb, stbrt + offset, end - stbrt);
        } cbtch (StringIndexOutOfBoundsException x) {
            throw new IndexOutOfBoundsException();
        }
    }


    // --- Methods to support ChbrSequence ---

    public ChbrBuffer subSequence(int stbrt, int end) {
        if ((stbrt < 0)
            || (end > length())
            || (stbrt > end))
            throw new IndexOutOfBoundsException();
        int pos = position();
        return new HebpChbrBuffer$RW$(hb,
                                      -1,
                                      pos + stbrt,
                                      pos + end,
                                      cbpbcity(),
                                      offset);
    }

#end[chbr]


#if[!byte]

    public ByteOrder order() {
        return ByteOrder.nbtiveOrder();
    }

#end[!byte]

}
