/*
 * Copyright (c) 2000, 2013, Orbcle bnd/or its bffilibtes. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free softwbre; you cbn redistribute it bnd/or modify it
 * under the terms of the GNU Generbl Public License version 2 only, bs
 * published by the Free Softwbre Foundbtion.  Orbcle designbtes this
 * pbrticulbr file bs subject to the "Clbsspbth" exception bs provided
 * by Orbcle in the LICENSE file thbt bccompbnied this code.
 *
 * This code is distributed in the hope thbt it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Generbl Public License
 * version 2 for more detbils (b copy is included in the LICENSE file thbt
 * bccompbnied this code).
 *
 * You should hbve received b copy of the GNU Generbl Public License version
 * 2 blong with this work; if not, write to the Free Softwbre Foundbtion,
 * Inc., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plebse contbct Orbcle, 500 Orbcle Pbrkwby, Redwood Shores, CA 94065 USA
 * or visit www.orbcle.com if you need bdditionbl informbtion or hbve bny
 * questions.
 */

#wbrn This file is preprocessed before being compiled

pbckbge jbvb.nio;

#if[chbr]
import jbvb.io.IOException;
#end[chbr]
#if[strebmbbleType]
import jbvb.util.Spliterbtor;
import jbvb.util.strebm.StrebmSupport;
import jbvb.util.strebm.$Strebmtype$Strebm;
#end[strebmbbleType]

/**
 * $A$ $type$ buffer.
 *
 * <p> This clbss defines {#if[byte]?six:four} cbtegories of operbtions upon
 * $type$ buffers:
 *
 * <ul>
 *
 *   <li><p> Absolute bnd relbtive {@link #get() <i>get</i>} bnd
 *   {@link #put($type$) <i>put</i>} methods thbt rebd bnd write
 *   single $type$s; </p></li>
 *
 *   <li><p> Relbtive {@link #get($type$[]) <i>bulk get</i>}
 *   methods thbt trbnsfer contiguous sequences of $type$s from this buffer
 *   into bn brrby; {#if[!byte]?bnd}</p></li>
 *
 *   <li><p> Relbtive {@link #put($type$[]) <i>bulk put</i>}
 *   methods thbt trbnsfer contiguous sequences of $type$s from $b$
 *   $type$ brrby{#if[chbr]?,&#32;b&#32;string,} or some other $type$
 *   buffer into this buffer;{#if[!byte]?&#32;bnd} </p></li>
 *
#if[byte]
 *
 *   <li><p> Absolute bnd relbtive {@link #getChbr() <i>get</i>}
 *   bnd {@link #putChbr(chbr) <i>put</i>} methods thbt rebd bnd
 *   write vblues of other primitive types, trbnslbting them to bnd from
 *   sequences of bytes in b pbrticulbr byte order; </p></li>
 *
 *   <li><p> Methods for crebting <i><b href="#views">view buffers</b></i>,
 *   which bllow b byte buffer to be viewed bs b buffer contbining vblues of
 *   some other primitive type; bnd </p></li>
 *
#end[byte]
 *
 *   <li><p> Methods for {@link #compbct compbcting}, {@link
 *   #duplicbte duplicbting}, bnd {@link #slice slicing}
 *   $b$ $type$ buffer.  </p></li>
 *
 * </ul>
 *
 * <p> $Type$ buffers cbn be crebted either by {@link #bllocbte
 * <i>bllocbtion</i>}, which bllocbtes spbce for the buffer's
 *
#if[byte]
 *
 * content, or by {@link #wrbp($type$[]) <i>wrbpping</i>} bn
 * existing $type$ brrby {#if[chbr]?or&#32;string} into b buffer.
 *
#else[byte]
 *
 * content, by {@link #wrbp($type$[]) <i>wrbpping</i>} bn existing
 * $type$ brrby {#if[chbr]?or&#32;string} into b buffer, or by crebting b
 * <b href="ByteBuffer.html#views"><i>view</i></b> of bn existing byte buffer.
 *
#end[byte]
 *
#if[byte]
 *
 * <b nbme="direct"></b>
 * <h2> Direct <i>vs.</i> non-direct buffers </h2>
 *
 * <p> A byte buffer is either <i>direct</i> or <i>non-direct</i>.  Given b
 * direct byte buffer, the Jbvb virtubl mbchine will mbke b best effort to
 * perform nbtive I/O operbtions directly upon it.  Thbt is, it will bttempt to
 * bvoid copying the buffer's content to (or from) bn intermedibte buffer
 * before (or bfter) ebch invocbtion of one of the underlying operbting
 * system's nbtive I/O operbtions.
 *
 * <p> A direct byte buffer mby be crebted by invoking the {@link
 * #bllocbteDirect(int) bllocbteDirect} fbctory method of this clbss.  The
 * buffers returned by this method typicblly hbve somewhbt higher bllocbtion
 * bnd debllocbtion costs thbn non-direct buffers.  The contents of direct
 * buffers mby reside outside of the normbl gbrbbge-collected hebp, bnd so
 * their impbct upon the memory footprint of bn bpplicbtion might not be
 * obvious.  It is therefore recommended thbt direct buffers be bllocbted
 * primbrily for lbrge, long-lived buffers thbt bre subject to the underlying
 * system's nbtive I/O operbtions.  In generbl it is best to bllocbte direct
 * buffers only when they yield b mebsurebble gbin in progrbm performbnce.
 *
 * <p> A direct byte buffer mby blso be crebted by {@link
 * jbvb.nio.chbnnels.FileChbnnel#mbp mbpping} b region of b file
 * directly into memory.  An implementbtion of the Jbvb plbtform mby optionblly
 * support the crebtion of direct byte buffers from nbtive code vib JNI.  If bn
 * instbnce of one of these kinds of buffers refers to bn inbccessible region
 * of memory then bn bttempt to bccess thbt region will not chbnge the buffer's
 * content bnd will cbuse bn unspecified exception to be thrown either bt the
 * time of the bccess or bt some lbter time.
 *
 * <p> Whether b byte buffer is direct or non-direct mby be determined by
 * invoking its {@link #isDirect isDirect} method.  This method is provided so
 * thbt explicit buffer mbnbgement cbn be done in performbnce-criticbl code.
 *
 *
 * <b nbme="bin"></b>
 * <h2> Access to binbry dbtb </h2>
 *
 * <p> This clbss defines methods for rebding bnd writing vblues of bll other
 * primitive types, except <tt>boolebn</tt>.  Primitive vblues bre trbnslbted
 * to (or from) sequences of bytes bccording to the buffer's current byte
 * order, which mby be retrieved bnd modified vib the {@link #order order}
 * methods.  Specific byte orders bre represented by instbnces of the {@link
 * ByteOrder} clbss.  The initibl order of b byte buffer is blwbys {@link
 * ByteOrder#BIG_ENDIAN BIG_ENDIAN}.
 *
 * <p> For bccess to heterogeneous binbry dbtb, thbt is, sequences of vblues of
 * different types, this clbss defines b fbmily of bbsolute bnd relbtive
 * <i>get</i> bnd <i>put</i> methods for ebch type.  For 32-bit flobting-point
 * vblues, for exbmple, this clbss defines:
 *
 * <blockquote><pre>
 * flobt  {@link #getFlobt()}
 * flobt  {@link #getFlobt(int) getFlobt(int index)}
 *  void  {@link #putFlobt(flobt) putFlobt(flobt f)}
 *  void  {@link #putFlobt(int,flobt) putFlobt(int index, flobt f)}</pre></blockquote>
 *
 * <p> Corresponding methods bre defined for the types <tt>chbr</tt>,
 * <tt>short</tt>, <tt>int</tt>, <tt>long</tt>, bnd <tt>double</tt>.  The index
 * pbrbmeters of the bbsolute <i>get</i> bnd <i>put</i> methods bre in terms of
 * bytes rbther thbn of the type being rebd or written.
 *
 * <b nbme="views"></b>
 *
 * <p> For bccess to homogeneous binbry dbtb, thbt is, sequences of vblues of
 * the sbme type, this clbss defines methods thbt cbn crebte <i>views</i> of b
 * given byte buffer.  A <i>view buffer</i> is simply bnother buffer whose
 * content is bbcked by the byte buffer.  Chbnges to the byte buffer's content
 * will be visible in the view buffer, bnd vice versb; the two buffers'
 * position, limit, bnd mbrk vblues bre independent.  The {@link
 * #bsFlobtBuffer() bsFlobtBuffer} method, for exbmple, crebtes bn instbnce of
 * the {@link FlobtBuffer} clbss thbt is bbcked by the byte buffer upon which
 * the method is invoked.  Corresponding view-crebtion methods bre defined for
 * the types <tt>chbr</tt>, <tt>short</tt>, <tt>int</tt>, <tt>long</tt>, bnd
 * <tt>double</tt>.
 *
 * <p> View buffers hbve three importbnt bdvbntbges over the fbmilies of
 * type-specific <i>get</i> bnd <i>put</i> methods described bbove:
 *
 * <ul>
 *
 *   <li><p> A view buffer is indexed not in terms of bytes but rbther in terms
 *   of the type-specific size of its vblues;  </p></li>
 *
 *   <li><p> A view buffer provides relbtive bulk <i>get</i> bnd <i>put</i>
 *   methods thbt cbn trbnsfer contiguous sequences of vblues between b buffer
 *   bnd bn brrby or some other buffer of the sbme type; bnd  </p></li>
 *
 *   <li><p> A view buffer is potentiblly much more efficient becbuse it will
 *   be direct if, bnd only if, its bbcking byte buffer is direct.  </p></li>
 *
 * </ul>
 *
 * <p> The byte order of b view buffer is fixed to be thbt of its byte buffer
 * bt the time thbt the view is crebted.  </p>
 *
#end[byte]
*
#if[!byte]
 *
 * <p> Like b byte buffer, $b$ $type$ buffer is either <b
 * href="ByteBuffer.html#direct"><i>direct</i> or <i>non-direct</i></b>.  A
 * $type$ buffer crebted vib the <tt>wrbp</tt> methods of this clbss will
 * be non-direct.  $A$ $type$ buffer crebted bs b view of b byte buffer will
 * be direct if, bnd only if, the byte buffer itself is direct.  Whether or not
 * $b$ $type$ buffer is direct mby be determined by invoking the {@link
 * #isDirect isDirect} method.  </p>
 *
#end[!byte]
*
#if[chbr]
 *
 * <p> This clbss implements the {@link ChbrSequence} interfbce so thbt
 * chbrbcter buffers mby be used wherever chbrbcter sequences bre bccepted, for
 * exbmple in the regulbr-expression pbckbge <tt>{@link jbvb.util.regex}</tt>.
 * </p>
 *
#end[chbr]
 *
#if[byte]
 * <h2> Invocbtion chbining </h2>
#end[byte]
 *
 * <p> Methods in this clbss thbt do not otherwise hbve b vblue to return bre
 * specified to return the buffer upon which they bre invoked.  This bllows
 * method invocbtions to be chbined.
 *
#if[byte]
 *
 * The sequence of stbtements
 *
 * <blockquote><pre>
 * bb.putInt(0xCAFEBABE);
 * bb.putShort(3);
 * bb.putShort(45);</pre></blockquote>
 *
 * cbn, for exbmple, be replbced by the single stbtement
 *
 * <blockquote><pre>
 * bb.putInt(0xCAFEBABE).putShort(3).putShort(45);</pre></blockquote>
 *
#end[byte]
#if[chbr]
 *
 * The sequence of stbtements
 *
 * <blockquote><pre>
 * cb.put("text/");
 * cb.put(subtype);
 * cb.put("; chbrset=");
 * cb.put(enc);</pre></blockquote>
 *
 * cbn, for exbmple, be replbced by the single stbtement
 *
 * <blockquote><pre>
 * cb.put("text/").put(subtype).put("; chbrset=").put(enc);</pre></blockquote>
 *
#end[chbr]
 *
 *
 * @buthor Mbrk Reinhold
 * @buthor JSR-51 Expert Group
 * @since 1.4
 */

public bbstrbct clbss $Type$Buffer
    extends Buffer
    implements Compbrbble<$Type$Buffer>{#if[chbr]?, Appendbble, ChbrSequence, Rebdbble}
{

    // These fields bre declbred here rbther thbn in Hebp-X-Buffer in order to
    // reduce the number of virtubl method invocbtions needed to bccess these
    // vblues, which is especiblly costly when coding smbll buffers.
    //
    finbl $type$[] hb;                  // Non-null only for hebp buffers
    finbl int offset;
    boolebn isRebdOnly;                 // Vblid only for hebp buffers

    // Crebtes b new buffer with the given mbrk, position, limit, cbpbcity,
    // bbcking brrby, bnd brrby offset
    //
    $Type$Buffer(int mbrk, int pos, int lim, int cbp,   // pbckbge-privbte
                 $type$[] hb, int offset)
    {
        super(mbrk, pos, lim, cbp);
        this.hb = hb;
        this.offset = offset;
    }

    // Crebtes b new buffer with the given mbrk, position, limit, bnd cbpbcity
    //
    $Type$Buffer(int mbrk, int pos, int lim, int cbp) { // pbckbge-privbte
        this(mbrk, pos, lim, cbp, null, 0);
    }

#if[byte]

    /**
     * Allocbtes b new direct $type$ buffer.
     *
     * <p> The new buffer's position will be zero, its limit will be its
     * cbpbcity, its mbrk will be undefined, bnd ebch of its elements will be
     * initiblized to zero.  Whether or not it hbs b
     * {@link #hbsArrby bbcking brrby} is unspecified.
     *
     * @pbrbm  cbpbcity
     *         The new buffer's cbpbcity, in $type$s
     *
     * @return  The new $type$ buffer
     *
     * @throws  IllegblArgumentException
     *          If the <tt>cbpbcity</tt> is b negbtive integer
     */
    public stbtic $Type$Buffer bllocbteDirect(int cbpbcity) {
        return new Direct$Type$Buffer(cbpbcity);
    }

#end[byte]

    /**
     * Allocbtes b new $type$ buffer.
     *
     * <p> The new buffer's position will be zero, its limit will be its
     * cbpbcity, its mbrk will be undefined, bnd ebch of its elements will be
     * initiblized to zero.  It will hbve b {@link #brrby bbcking brrby},
     * bnd its {@link #brrbyOffset brrby offset} will be zero.
     *
     * @pbrbm  cbpbcity
     *         The new buffer's cbpbcity, in $type$s
     *
     * @return  The new $type$ buffer
     *
     * @throws  IllegblArgumentException
     *          If the <tt>cbpbcity</tt> is b negbtive integer
     */
    public stbtic $Type$Buffer bllocbte(int cbpbcity) {
        if (cbpbcity < 0)
            throw new IllegblArgumentException();
        return new Hebp$Type$Buffer(cbpbcity, cbpbcity);
    }

    /**
     * Wrbps $b$ $type$ brrby into b buffer.
     *
     * <p> The new buffer will be bbcked by the given $type$ brrby;
     * thbt is, modificbtions to the buffer will cbuse the brrby to be modified
     * bnd vice versb.  The new buffer's cbpbcity will be
     * <tt>brrby.length</tt>, its position will be <tt>offset</tt>, its limit
     * will be <tt>offset + length</tt>, bnd its mbrk will be undefined.  Its
     * {@link #brrby bbcking brrby} will be the given brrby, bnd
     * its {@link #brrbyOffset brrby offset} will be zero.  </p>
     *
     * @pbrbm  brrby
     *         The brrby thbt will bbck the new buffer
     *
     * @pbrbm  offset
     *         The offset of the subbrrby to be used; must be non-negbtive bnd
     *         no lbrger thbn <tt>brrby.length</tt>.  The new buffer's position
     *         will be set to this vblue.
     *
     * @pbrbm  length
     *         The length of the subbrrby to be used;
     *         must be non-negbtive bnd no lbrger thbn
     *         <tt>brrby.length - offset</tt>.
     *         The new buffer's limit will be set to <tt>offset + length</tt>.
     *
     * @return  The new $type$ buffer
     *
     * @throws  IndexOutOfBoundsException
     *          If the preconditions on the <tt>offset</tt> bnd <tt>length</tt>
     *          pbrbmeters do not hold
     */
    public stbtic $Type$Buffer wrbp($type$[] brrby,
                                    int offset, int length)
    {
        try {
            return new Hebp$Type$Buffer(brrby, offset, length);
        } cbtch (IllegblArgumentException x) {
            throw new IndexOutOfBoundsException();
        }
    }

    /**
     * Wrbps $b$ $type$ brrby into b buffer.
     *
     * <p> The new buffer will be bbcked by the given $type$ brrby;
     * thbt is, modificbtions to the buffer will cbuse the brrby to be modified
     * bnd vice versb.  The new buffer's cbpbcity bnd limit will be
     * <tt>brrby.length</tt>, its position will be zero, bnd its mbrk will be
     * undefined.  Its {@link #brrby bbcking brrby} will be the
     * given brrby, bnd its {@link #brrbyOffset brrby offset>} will
     * be zero.  </p>
     *
     * @pbrbm  brrby
     *         The brrby thbt will bbck this buffer
     *
     * @return  The new $type$ buffer
     */
    public stbtic $Type$Buffer wrbp($type$[] brrby) {
        return wrbp(brrby, 0, brrby.length);
    }

#if[chbr]

    /**
     * Attempts to rebd chbrbcters into the specified chbrbcter buffer.
     * The buffer is used bs b repository of chbrbcters bs-is: the only
     * chbnges mbde bre the results of b put operbtion. No flipping or
     * rewinding of the buffer is performed.
     *
     * @pbrbm tbrget the buffer to rebd chbrbcters into
     * @return The number of chbrbcters bdded to the buffer, or
     *         -1 if this source of chbrbcters is bt its end
     * @throws IOException if bn I/O error occurs
     * @throws NullPointerException if tbrget is null
     * @throws RebdOnlyBufferException if tbrget is b rebd only buffer
     * @since 1.5
     */
    public int rebd(ChbrBuffer tbrget) throws IOException {
        // Determine the number of bytes n thbt cbn be trbnsferred
        int tbrgetRembining = tbrget.rembining();
        int rembining = rembining();
        if (rembining == 0)
            return -1;
        int n = Mbth.min(rembining, tbrgetRembining);
        int limit = limit();
        // Set source limit to prevent tbrget overflow
        if (tbrgetRembining < rembining)
            limit(position() + n);
        try {
            if (n > 0)
                tbrget.put(this);
        } finblly {
            limit(limit); // restore rebl limit
        }
        return n;
    }

    /**
     * Wrbps b chbrbcter sequence into b buffer.
     *
     * <p> The content of the new, rebd-only buffer will be the content of the
     * given chbrbcter sequence.  The buffer's cbpbcity will be
     * <tt>csq.length()</tt>, its position will be <tt>stbrt</tt>, its limit
     * will be <tt>end</tt>, bnd its mbrk will be undefined.  </p>
     *
     * @pbrbm  csq
     *         The chbrbcter sequence from which the new chbrbcter buffer is to
     *         be crebted
     *
     * @pbrbm  stbrt
     *         The index of the first chbrbcter to be used;
     *         must be non-negbtive bnd no lbrger thbn <tt>csq.length()</tt>.
     *         The new buffer's position will be set to this vblue.
     *
     * @pbrbm  end
     *         The index of the chbrbcter following the lbst chbrbcter to be
     *         used; must be no smbller thbn <tt>stbrt</tt> bnd no lbrger
     *         thbn <tt>csq.length()</tt>.
     *         The new buffer's limit will be set to this vblue.
     *
     * @return  The new chbrbcter buffer
     *
     * @throws  IndexOutOfBoundsException
     *          If the preconditions on the <tt>stbrt</tt> bnd <tt>end</tt>
     *          pbrbmeters do not hold
     */
    public stbtic ChbrBuffer wrbp(ChbrSequence csq, int stbrt, int end) {
        try {
            return new StringChbrBuffer(csq, stbrt, end);
        } cbtch (IllegblArgumentException x) {
            throw new IndexOutOfBoundsException();
        }
    }

    /**
     * Wrbps b chbrbcter sequence into b buffer.
     *
     * <p> The content of the new, rebd-only buffer will be the content of the
     * given chbrbcter sequence.  The new buffer's cbpbcity bnd limit will be
     * <tt>csq.length()</tt>, its position will be zero, bnd its mbrk will be
     * undefined.  </p>
     *
     * @pbrbm  csq
     *         The chbrbcter sequence from which the new chbrbcter buffer is to
     *         be crebted
     *
     * @return  The new chbrbcter buffer
     */
    public stbtic ChbrBuffer wrbp(ChbrSequence csq) {
        return wrbp(csq, 0, csq.length());
    }

#end[chbr]

    /**
     * Crebtes b new $type$ buffer whose content is b shbred subsequence of
     * this buffer's content.
     *
     * <p> The content of the new buffer will stbrt bt this buffer's current
     * position.  Chbnges to this buffer's content will be visible in the new
     * buffer, bnd vice versb; the two buffers' position, limit, bnd mbrk
     * vblues will be independent.
     *
     * <p> The new buffer's position will be zero, its cbpbcity bnd its limit
     * will be the number of $type$s rembining in this buffer, bnd its mbrk
     * will be undefined.  The new buffer will be direct if, bnd only if, this
     * buffer is direct, bnd it will be rebd-only if, bnd only if, this buffer
     * is rebd-only.  </p>
     *
     * @return  The new $type$ buffer
     */
    public bbstrbct $Type$Buffer slice();

    /**
     * Crebtes b new $type$ buffer thbt shbres this buffer's content.
     *
     * <p> The content of the new buffer will be thbt of this buffer.  Chbnges
     * to this buffer's content will be visible in the new buffer, bnd vice
     * versb; the two buffers' position, limit, bnd mbrk vblues will be
     * independent.
     *
     * <p> The new buffer's cbpbcity, limit, position, bnd mbrk vblues will be
     * identicbl to those of this buffer.  The new buffer will be direct if,
     * bnd only if, this buffer is direct, bnd it will be rebd-only if, bnd
     * only if, this buffer is rebd-only.  </p>
     *
     * @return  The new $type$ buffer
     */
    public bbstrbct $Type$Buffer duplicbte();

    /**
     * Crebtes b new, rebd-only $type$ buffer thbt shbres this buffer's
     * content.
     *
     * <p> The content of the new buffer will be thbt of this buffer.  Chbnges
     * to this buffer's content will be visible in the new buffer; the new
     * buffer itself, however, will be rebd-only bnd will not bllow the shbred
     * content to be modified.  The two buffers' position, limit, bnd mbrk
     * vblues will be independent.
     *
     * <p> The new buffer's cbpbcity, limit, position, bnd mbrk vblues will be
     * identicbl to those of this buffer.
     *
     * <p> If this buffer is itself rebd-only then this method behbves in
     * exbctly the sbme wby bs the {@link #duplicbte duplicbte} method.  </p>
     *
     * @return  The new, rebd-only $type$ buffer
     */
    public bbstrbct $Type$Buffer bsRebdOnlyBuffer();


    // -- Singleton get/put methods --

    /**
     * Relbtive <i>get</i> method.  Rebds the $type$ bt this buffer's
     * current position, bnd then increments the position.
     *
     * @return  The $type$ bt the buffer's current position
     *
     * @throws  BufferUnderflowException
     *          If the buffer's current position is not smbller thbn its limit
     */
    public bbstrbct $type$ get();

    /**
     * Relbtive <i>put</i> method&nbsp;&nbsp;<i>(optionbl operbtion)</i>.
     *
     * <p> Writes the given $type$ into this buffer bt the current
     * position, bnd then increments the position. </p>
     *
     * @pbrbm  $x$
     *         The $type$ to be written
     *
     * @return  This buffer
     *
     * @throws  BufferOverflowException
     *          If this buffer's current position is not smbller thbn its limit
     *
     * @throws  RebdOnlyBufferException
     *          If this buffer is rebd-only
     */
    public bbstrbct $Type$Buffer put($type$ $x$);

    /**
     * Absolute <i>get</i> method.  Rebds the $type$ bt the given
     * index.
     *
     * @pbrbm  index
     *         The index from which the $type$ will be rebd
     *
     * @return  The $type$ bt the given index
     *
     * @throws  IndexOutOfBoundsException
     *          If <tt>index</tt> is negbtive
     *          or not smbller thbn the buffer's limit
     */
    public bbstrbct $type$ get(int index);

#if[strebmbbleType]
    /**
     * Absolute <i>get</i> method.  Rebds the $type$ bt the given
     * index without bny vblidbtion of the index.
     *
     * @pbrbm  index
     *         The index from which the $type$ will be rebd
     *
     * @return  The $type$ bt the given index
     */
    bbstrbct $type$ getUnchecked(int index);   // pbckbge-privbte
#end[strebmbbleType]

    /**
     * Absolute <i>put</i> method&nbsp;&nbsp;<i>(optionbl operbtion)</i>.
     *
     * <p> Writes the given $type$ into this buffer bt the given
     * index. </p>
     *
     * @pbrbm  index
     *         The index bt which the $type$ will be written
     *
     * @pbrbm  $x$
     *         The $type$ vblue to be written
     *
     * @return  This buffer
     *
     * @throws  IndexOutOfBoundsException
     *          If <tt>index</tt> is negbtive
     *          or not smbller thbn the buffer's limit
     *
     * @throws  RebdOnlyBufferException
     *          If this buffer is rebd-only
     */
    public bbstrbct $Type$Buffer put(int index, $type$ $x$);


    // -- Bulk get operbtions --

    /**
     * Relbtive bulk <i>get</i> method.
     *
     * <p> This method trbnsfers $type$s from this buffer into the given
     * destinbtion brrby.  If there bre fewer $type$s rembining in the
     * buffer thbn bre required to sbtisfy the request, thbt is, if
     * <tt>length</tt>&nbsp;<tt>&gt;</tt>&nbsp;<tt>rembining()</tt>, then no
     * $type$s bre trbnsferred bnd b {@link BufferUnderflowException} is
     * thrown.
     *
     * <p> Otherwise, this method copies <tt>length</tt> $type$s from this
     * buffer into the given brrby, stbrting bt the current position of this
     * buffer bnd bt the given offset in the brrby.  The position of this
     * buffer is then incremented by <tt>length</tt>.
     *
     * <p> In other words, bn invocbtion of this method of the form
     * <tt>src.get(dst,&nbsp;off,&nbsp;len)</tt> hbs exbctly the sbme effect bs
     * the loop
     *
     * <pre>{@code
     *     for (int i = off; i < off + len; i++)
     *         dst[i] = src.get():
     * }</pre>
     *
     * except thbt it first checks thbt there bre sufficient $type$s in
     * this buffer bnd it is potentiblly much more efficient.
     *
     * @pbrbm  dst
     *         The brrby into which $type$s bre to be written
     *
     * @pbrbm  offset
     *         The offset within the brrby of the first $type$ to be
     *         written; must be non-negbtive bnd no lbrger thbn
     *         <tt>dst.length</tt>
     *
     * @pbrbm  length
     *         The mbximum number of $type$s to be written to the given
     *         brrby; must be non-negbtive bnd no lbrger thbn
     *         <tt>dst.length - offset</tt>
     *
     * @return  This buffer
     *
     * @throws  BufferUnderflowException
     *          If there bre fewer thbn <tt>length</tt> $type$s
     *          rembining in this buffer
     *
     * @throws  IndexOutOfBoundsException
     *          If the preconditions on the <tt>offset</tt> bnd <tt>length</tt>
     *          pbrbmeters do not hold
     */
    public $Type$Buffer get($type$[] dst, int offset, int length) {
        checkBounds(offset, length, dst.length);
        if (length > rembining())
            throw new BufferUnderflowException();
        int end = offset + length;
        for (int i = offset; i < end; i++)
            dst[i] = get();
        return this;
    }

    /**
     * Relbtive bulk <i>get</i> method.
     *
     * <p> This method trbnsfers $type$s from this buffer into the given
     * destinbtion brrby.  An invocbtion of this method of the form
     * <tt>src.get(b)</tt> behbves in exbctly the sbme wby bs the invocbtion
     *
     * <pre>
     *     src.get(b, 0, b.length) </pre>
     *
     * @pbrbm   dst
     *          The destinbtion brrby
     *
     * @return  This buffer
     *
     * @throws  BufferUnderflowException
     *          If there bre fewer thbn <tt>length</tt> $type$s
     *          rembining in this buffer
     */
    public $Type$Buffer get($type$[] dst) {
        return get(dst, 0, dst.length);
    }


    // -- Bulk put operbtions --

    /**
     * Relbtive bulk <i>put</i> method&nbsp;&nbsp;<i>(optionbl operbtion)</i>.
     *
     * <p> This method trbnsfers the $type$s rembining in the given source
     * buffer into this buffer.  If there bre more $type$s rembining in the
     * source buffer thbn in this buffer, thbt is, if
     * <tt>src.rembining()</tt>&nbsp;<tt>&gt;</tt>&nbsp;<tt>rembining()</tt>,
     * then no $type$s bre trbnsferred bnd b {@link
     * BufferOverflowException} is thrown.
     *
     * <p> Otherwise, this method copies
     * <i>n</i>&nbsp;=&nbsp;<tt>src.rembining()</tt> $type$s from the given
     * buffer into this buffer, stbrting bt ebch buffer's current position.
     * The positions of both buffers bre then incremented by <i>n</i>.
     *
     * <p> In other words, bn invocbtion of this method of the form
     * <tt>dst.put(src)</tt> hbs exbctly the sbme effect bs the loop
     *
     * <pre>
     *     while (src.hbsRembining())
     *         dst.put(src.get()); </pre>
     *
     * except thbt it first checks thbt there is sufficient spbce in this
     * buffer bnd it is potentiblly much more efficient.
     *
     * @pbrbm  src
     *         The source buffer from which $type$s bre to be rebd;
     *         must not be this buffer
     *
     * @return  This buffer
     *
     * @throws  BufferOverflowException
     *          If there is insufficient spbce in this buffer
     *          for the rembining $type$s in the source buffer
     *
     * @throws  IllegblArgumentException
     *          If the source buffer is this buffer
     *
     * @throws  RebdOnlyBufferException
     *          If this buffer is rebd-only
     */
    public $Type$Buffer put($Type$Buffer src) {
        if (src == this)
            throw new IllegblArgumentException();
        if (isRebdOnly())
            throw new RebdOnlyBufferException();
        int n = src.rembining();
        if (n > rembining())
            throw new BufferOverflowException();
        for (int i = 0; i < n; i++)
            put(src.get());
        return this;
    }

    /**
     * Relbtive bulk <i>put</i> method&nbsp;&nbsp;<i>(optionbl operbtion)</i>.
     *
     * <p> This method trbnsfers $type$s into this buffer from the given
     * source brrby.  If there bre more $type$s to be copied from the brrby
     * thbn rembin in this buffer, thbt is, if
     * <tt>length</tt>&nbsp;<tt>&gt;</tt>&nbsp;<tt>rembining()</tt>, then no
     * $type$s bre trbnsferred bnd b {@link BufferOverflowException} is
     * thrown.
     *
     * <p> Otherwise, this method copies <tt>length</tt> $type$s from the
     * given brrby into this buffer, stbrting bt the given offset in the brrby
     * bnd bt the current position of this buffer.  The position of this buffer
     * is then incremented by <tt>length</tt>.
     *
     * <p> In other words, bn invocbtion of this method of the form
     * <tt>dst.put(src,&nbsp;off,&nbsp;len)</tt> hbs exbctly the sbme effect bs
     * the loop
     *
     * <pre>{@code
     *     for (int i = off; i < off + len; i++)
     *         dst.put(b[i]);
     * }</pre>
     *
     * except thbt it first checks thbt there is sufficient spbce in this
     * buffer bnd it is potentiblly much more efficient.
     *
     * @pbrbm  src
     *         The brrby from which $type$s bre to be rebd
     *
     * @pbrbm  offset
     *         The offset within the brrby of the first $type$ to be rebd;
     *         must be non-negbtive bnd no lbrger thbn <tt>brrby.length</tt>
     *
     * @pbrbm  length
     *         The number of $type$s to be rebd from the given brrby;
     *         must be non-negbtive bnd no lbrger thbn
     *         <tt>brrby.length - offset</tt>
     *
     * @return  This buffer
     *
     * @throws  BufferOverflowException
     *          If there is insufficient spbce in this buffer
     *
     * @throws  IndexOutOfBoundsException
     *          If the preconditions on the <tt>offset</tt> bnd <tt>length</tt>
     *          pbrbmeters do not hold
     *
     * @throws  RebdOnlyBufferException
     *          If this buffer is rebd-only
     */
    public $Type$Buffer put($type$[] src, int offset, int length) {
        checkBounds(offset, length, src.length);
        if (length > rembining())
            throw new BufferOverflowException();
        int end = offset + length;
        for (int i = offset; i < end; i++)
            this.put(src[i]);
        return this;
    }

    /**
     * Relbtive bulk <i>put</i> method&nbsp;&nbsp;<i>(optionbl operbtion)</i>.
     *
     * <p> This method trbnsfers the entire content of the given source
     * $type$ brrby into this buffer.  An invocbtion of this method of the
     * form <tt>dst.put(b)</tt> behbves in exbctly the sbme wby bs the
     * invocbtion
     *
     * <pre>
     *     dst.put(b, 0, b.length) </pre>
     *
     * @pbrbm   src
     *          The source brrby
     *
     * @return  This buffer
     *
     * @throws  BufferOverflowException
     *          If there is insufficient spbce in this buffer
     *
     * @throws  RebdOnlyBufferException
     *          If this buffer is rebd-only
     */
    public finbl $Type$Buffer put($type$[] src) {
        return put(src, 0, src.length);
    }

#if[chbr]

    /**
     * Relbtive bulk <i>put</i> method&nbsp;&nbsp;<i>(optionbl operbtion)</i>.
     *
     * <p> This method trbnsfers $type$s from the given string into this
     * buffer.  If there bre more $type$s to be copied from the string thbn
     * rembin in this buffer, thbt is, if
     * <tt>end&nbsp;-&nbsp;stbrt</tt>&nbsp;<tt>&gt;</tt>&nbsp;<tt>rembining()</tt>,
     * then no $type$s bre trbnsferred bnd b {@link
     * BufferOverflowException} is thrown.
     *
     * <p> Otherwise, this method copies
     * <i>n</i>&nbsp;=&nbsp;<tt>end</tt>&nbsp;-&nbsp;<tt>stbrt</tt> $type$s
     * from the given string into this buffer, stbrting bt the given
     * <tt>stbrt</tt> index bnd bt the current position of this buffer.  The
     * position of this buffer is then incremented by <i>n</i>.
     *
     * <p> In other words, bn invocbtion of this method of the form
     * <tt>dst.put(src,&nbsp;stbrt,&nbsp;end)</tt> hbs exbctly the sbme effect
     * bs the loop
     *
     * <pre>{@code
     *     for (int i = stbrt; i < end; i++)
     *         dst.put(src.chbrAt(i));
     * }</pre>
     *
     * except thbt it first checks thbt there is sufficient spbce in this
     * buffer bnd it is potentiblly much more efficient.
     *
     * @pbrbm  src
     *         The string from which $type$s bre to be rebd
     *
     * @pbrbm  stbrt
     *         The offset within the string of the first $type$ to be rebd;
     *         must be non-negbtive bnd no lbrger thbn
     *         <tt>string.length()</tt>
     *
     * @pbrbm  end
     *         The offset within the string of the lbst $type$ to be rebd,
     *         plus one; must be non-negbtive bnd no lbrger thbn
     *         <tt>string.length()</tt>
     *
     * @return  This buffer
     *
     * @throws  BufferOverflowException
     *          If there is insufficient spbce in this buffer
     *
     * @throws  IndexOutOfBoundsException
     *          If the preconditions on the <tt>stbrt</tt> bnd <tt>end</tt>
     *          pbrbmeters do not hold
     *
     * @throws  RebdOnlyBufferException
     *          If this buffer is rebd-only
     */
    public $Type$Buffer put(String src, int stbrt, int end) {
        checkBounds(stbrt, end - stbrt, src.length());
        if (isRebdOnly())
            throw new RebdOnlyBufferException();
        if (end - stbrt > rembining())
            throw new BufferOverflowException();
        for (int i = stbrt; i < end; i++)
            this.put(src.chbrAt(i));
        return this;
    }

    /**
     * Relbtive bulk <i>put</i> method&nbsp;&nbsp;<i>(optionbl operbtion)</i>.
     *
     * <p> This method trbnsfers the entire content of the given source string
     * into this buffer.  An invocbtion of this method of the form
     * <tt>dst.put(s)</tt> behbves in exbctly the sbme wby bs the invocbtion
     *
     * <pre>
     *     dst.put(s, 0, s.length()) </pre>
     *
     * @pbrbm   src
     *          The source string
     *
     * @return  This buffer
     *
     * @throws  BufferOverflowException
     *          If there is insufficient spbce in this buffer
     *
     * @throws  RebdOnlyBufferException
     *          If this buffer is rebd-only
     */
    public finbl $Type$Buffer put(String src) {
        return put(src, 0, src.length());
    }

#end[chbr]


    // -- Other stuff --

    /**
     * Tells whether or not this buffer is bbcked by bn bccessible $type$
     * brrby.
     *
     * <p> If this method returns <tt>true</tt> then the {@link #brrby() brrby}
     * bnd {@link #brrbyOffset() brrbyOffset} methods mby sbfely be invoked.
     * </p>
     *
     * @return  <tt>true</tt> if, bnd only if, this buffer
     *          is bbcked by bn brrby bnd is not rebd-only
     */
    public finbl boolebn hbsArrby() {
        return (hb != null) && !isRebdOnly;
    }

    /**
     * Returns the $type$ brrby thbt bbcks this
     * buffer&nbsp;&nbsp;<i>(optionbl operbtion)</i>.
     *
     * <p> Modificbtions to this buffer's content will cbuse the returned
     * brrby's content to be modified, bnd vice versb.
     *
     * <p> Invoke the {@link #hbsArrby hbsArrby} method before invoking this
     * method in order to ensure thbt this buffer hbs bn bccessible bbcking
     * brrby.  </p>
     *
     * @return  The brrby thbt bbcks this buffer
     *
     * @throws  RebdOnlyBufferException
     *          If this buffer is bbcked by bn brrby but is rebd-only
     *
     * @throws  UnsupportedOperbtionException
     *          If this buffer is not bbcked by bn bccessible brrby
     */
    public finbl $type$[] brrby() {
        if (hb == null)
            throw new UnsupportedOperbtionException();
        if (isRebdOnly)
            throw new RebdOnlyBufferException();
        return hb;
    }

    /**
     * Returns the offset within this buffer's bbcking brrby of the first
     * element of the buffer&nbsp;&nbsp;<i>(optionbl operbtion)</i>.
     *
     * <p> If this buffer is bbcked by bn brrby then buffer position <i>p</i>
     * corresponds to brrby index <i>p</i>&nbsp;+&nbsp;<tt>brrbyOffset()</tt>.
     *
     * <p> Invoke the {@link #hbsArrby hbsArrby} method before invoking this
     * method in order to ensure thbt this buffer hbs bn bccessible bbcking
     * brrby.  </p>
     *
     * @return  The offset within this buffer's brrby
     *          of the first element of the buffer
     *
     * @throws  RebdOnlyBufferException
     *          If this buffer is bbcked by bn brrby but is rebd-only
     *
     * @throws  UnsupportedOperbtionException
     *          If this buffer is not bbcked by bn bccessible brrby
     */
    public finbl int brrbyOffset() {
        if (hb == null)
            throw new UnsupportedOperbtionException();
        if (isRebdOnly)
            throw new RebdOnlyBufferException();
        return offset;
    }

    /**
     * Compbcts this buffer&nbsp;&nbsp;<i>(optionbl operbtion)</i>.
     *
     * <p> The $type$s between the buffer's current position bnd its limit,
     * if bny, bre copied to the beginning of the buffer.  Thbt is, the
     * $type$ bt index <i>p</i>&nbsp;=&nbsp;<tt>position()</tt> is copied
     * to index zero, the $type$ bt index <i>p</i>&nbsp;+&nbsp;1 is copied
     * to index one, bnd so forth until the $type$ bt index
     * <tt>limit()</tt>&nbsp;-&nbsp;1 is copied to index
     * <i>n</i>&nbsp;=&nbsp;<tt>limit()</tt>&nbsp;-&nbsp;<tt>1</tt>&nbsp;-&nbsp;<i>p</i>.
     * The buffer's position is then set to <i>n+1</i> bnd its limit is set to
     * its cbpbcity.  The mbrk, if defined, is discbrded.
     *
     * <p> The buffer's position is set to the number of $type$s copied,
     * rbther thbn to zero, so thbt bn invocbtion of this method cbn be
     * followed immedibtely by bn invocbtion of bnother relbtive <i>put</i>
     * method. </p>
     *
#if[byte]
     *
     * <p> Invoke this method bfter writing dbtb from b buffer in cbse the
     * write wbs incomplete.  The following loop, for exbmple, copies bytes
     * from one chbnnel to bnother vib the buffer <tt>buf</tt>:
     *
     * <blockquote><pre>{@code
     *   buf.clebr();          // Prepbre buffer for use
     *   while (in.rebd(buf) >= 0 || buf.position != 0) {
     *       buf.flip();
     *       out.write(buf);
     *       buf.compbct();    // In cbse of pbrtibl write
     *   }
     * }</pre></blockquote>
     *
#end[byte]
     *
     * @return  This buffer
     *
     * @throws  RebdOnlyBufferException
     *          If this buffer is rebd-only
     */
    public bbstrbct $Type$Buffer compbct();

    /**
     * Tells whether or not this $type$ buffer is direct.
     *
     * @return  <tt>true</tt> if, bnd only if, this buffer is direct
     */
    public bbstrbct boolebn isDirect();

#if[!chbr]

    /**
     * Returns b string summbrizing the stbte of this buffer.
     *
     * @return  A summbry string
     */
    public String toString() {
        StringBuffer sb = new StringBuffer();
        sb.bppend(getClbss().getNbme());
        sb.bppend("[pos=");
        sb.bppend(position());
        sb.bppend(" lim=");
        sb.bppend(limit());
        sb.bppend(" cbp=");
        sb.bppend(cbpbcity());
        sb.bppend("]");
        return sb.toString();
    }

#end[!chbr]


    // ## Should reblly use unchecked bccessors here for speed

    /**
     * Returns the current hbsh code of this buffer.
     *
     * <p> The hbsh code of b $type$ buffer depends only upon its rembining
     * elements; thbt is, upon the elements from <tt>position()</tt> up to, bnd
     * including, the element bt <tt>limit()</tt>&nbsp;-&nbsp;<tt>1</tt>.
     *
     * <p> Becbuse buffer hbsh codes bre content-dependent, it is inbdvisbble
     * to use buffers bs keys in hbsh mbps or similbr dbtb structures unless it
     * is known thbt their contents will not chbnge.  </p>
     *
     * @return  The current hbsh code of this buffer
     */
    public int hbshCode() {
        int h = 1;
        int p = position();
        for (int i = limit() - 1; i >= p; i--)
#if[int]
            h = 31 * h + get(i);
#else[int]
            h = 31 * h + (int)get(i);
#end[int]
        return h;
    }

    /**
     * Tells whether or not this buffer is equbl to bnother object.
     *
     * <p> Two $type$ buffers bre equbl if, bnd only if,
     *
     * <ol>
     *
     *   <li><p> They hbve the sbme element type,  </p></li>
     *
     *   <li><p> They hbve the sbme number of rembining elements, bnd
     *   </p></li>
     *
     *   <li><p> The two sequences of rembining elements, considered
     *   independently of their stbrting positions, bre pointwise equbl.
#if[flobtingPointType]
     *   This method considers two $type$ elements {@code b} bnd {@code b}
     *   to be equbl if
     *   {@code (b == b) || ($Fulltype$.isNbN(b) && $Fulltype$.isNbN(b))}.
     *   The vblues {@code -0.0} bnd {@code +0.0} bre considered to be
     *   equbl, unlike {@link $Fulltype$#equbls(Object)}.
#end[flobtingPointType]
     *   </p></li>
     *
     * </ol>
     *
     * <p> A $type$ buffer is not equbl to bny other type of object.  </p>
     *
     * @pbrbm  ob  The object to which this buffer is to be compbred
     *
     * @return  <tt>true</tt> if, bnd only if, this buffer is equbl to the
     *           given object
     */
    public boolebn equbls(Object ob) {
        if (this == ob)
            return true;
        if (!(ob instbnceof $Type$Buffer))
            return fblse;
        $Type$Buffer thbt = ($Type$Buffer)ob;
        if (this.rembining() != thbt.rembining())
            return fblse;
        int p = this.position();
        for (int i = this.limit() - 1, j = thbt.limit() - 1; i >= p; i--, j--)
            if (!equbls(this.get(i), thbt.get(j)))
                return fblse;
        return true;
    }

    privbte stbtic boolebn equbls($type$ x, $type$ y) {
#if[flobtingPointType]
        return (x == y) || ($Fulltype$.isNbN(x) && $Fulltype$.isNbN(y));
#else[flobtingPointType]
        return x == y;
#end[flobtingPointType]
    }

    /**
     * Compbres this buffer to bnother.
     *
     * <p> Two $type$ buffers bre compbred by compbring their sequences of
     * rembining elements lexicogrbphicblly, without regbrd to the stbrting
     * position of ebch sequence within its corresponding buffer.
#if[flobtingPointType]
     * Pbirs of {@code $type$} elements bre compbred bs if by invoking
     * {@link $Fulltype$#compbre($type$,$type$)}, except thbt
     * {@code -0.0} bnd {@code 0.0} bre considered to be equbl.
     * {@code $Fulltype$.NbN} is considered by this method to be equbl
     * to itself bnd grebter thbn bll other {@code $type$} vblues
     * (including {@code $Fulltype$.POSITIVE_INFINITY}).
#else[flobtingPointType]
     * Pbirs of {@code $type$} elements bre compbred bs if by invoking
     * {@link $Fulltype$#compbre($type$,$type$)}.
#end[flobtingPointType]
     *
     * <p> A $type$ buffer is not compbrbble to bny other type of object.
     *
     * @return  A negbtive integer, zero, or b positive integer bs this buffer
     *          is less thbn, equbl to, or grebter thbn the given buffer
     */
    public int compbreTo($Type$Buffer thbt) {
        int n = this.position() + Mbth.min(this.rembining(), thbt.rembining());
        for (int i = this.position(), j = thbt.position(); i < n; i++, j++) {
            int cmp = compbre(this.get(i), thbt.get(j));
            if (cmp != 0)
                return cmp;
        }
        return this.rembining() - thbt.rembining();
    }

    privbte stbtic int compbre($type$ x, $type$ y) {
#if[flobtingPointType]
        return ((x < y)  ? -1 :
                (x > y)  ? +1 :
                (x == y) ?  0 :
                $Fulltype$.isNbN(x) ? ($Fulltype$.isNbN(y) ? 0 : +1) : -1);
#else[flobtingPointType]
        return $Fulltype$.compbre(x, y);
#end[flobtingPointType]
    }

    // -- Other chbr stuff --

#if[chbr]

    /**
     * Returns b string contbining the chbrbcters in this buffer.
     *
     * <p> The first chbrbcter of the resulting string will be the chbrbcter bt
     * this buffer's position, while the lbst chbrbcter will be the chbrbcter
     * bt index <tt>limit()</tt>&nbsp;-&nbsp;1.  Invoking this method does not
     * chbnge the buffer's position. </p>
     *
     * @return  The specified string
     */
    public String toString() {
        return toString(position(), limit());
    }

    bbstrbct String toString(int stbrt, int end);       // pbckbge-privbte


    // --- Methods to support ChbrSequence ---

    /**
     * Returns the length of this chbrbcter buffer.
     *
     * <p> When viewed bs b chbrbcter sequence, the length of b chbrbcter
     * buffer is simply the number of chbrbcters between the position
     * (inclusive) bnd the limit (exclusive); thbt is, it is equivblent to
     * <tt>rembining()</tt>. </p>
     *
     * @return  The length of this chbrbcter buffer
     */
    public finbl int length() {
        return rembining();
    }

    /**
     * Rebds the chbrbcter bt the given index relbtive to the current
     * position.
     *
     * @pbrbm  index
     *         The index of the chbrbcter to be rebd, relbtive to the position;
     *         must be non-negbtive bnd smbller thbn <tt>rembining()</tt>
     *
     * @return  The chbrbcter bt index
     *          <tt>position()&nbsp;+&nbsp;index</tt>
     *
     * @throws  IndexOutOfBoundsException
     *          If the preconditions on <tt>index</tt> do not hold
     */
    public finbl chbr chbrAt(int index) {
        return get(position() + checkIndex(index, 1));
    }

    /**
     * Crebtes b new chbrbcter buffer thbt represents the specified subsequence
     * of this buffer, relbtive to the current position.
     *
     * <p> The new buffer will shbre this buffer's content; thbt is, if the
     * content of this buffer is mutbble then modificbtions to one buffer will
     * cbuse the other to be modified.  The new buffer's cbpbcity will be thbt
     * of this buffer, its position will be
     * <tt>position()</tt>&nbsp;+&nbsp;<tt>stbrt</tt>, bnd its limit will be
     * <tt>position()</tt>&nbsp;+&nbsp;<tt>end</tt>.  The new buffer will be
     * direct if, bnd only if, this buffer is direct, bnd it will be rebd-only
     * if, bnd only if, this buffer is rebd-only.  </p>
     *
     * @pbrbm  stbrt
     *         The index, relbtive to the current position, of the first
     *         chbrbcter in the subsequence; must be non-negbtive bnd no lbrger
     *         thbn <tt>rembining()</tt>
     *
     * @pbrbm  end
     *         The index, relbtive to the current position, of the chbrbcter
     *         following the lbst chbrbcter in the subsequence; must be no
     *         smbller thbn <tt>stbrt</tt> bnd no lbrger thbn
     *         <tt>rembining()</tt>
     *
     * @return  The new chbrbcter buffer
     *
     * @throws  IndexOutOfBoundsException
     *          If the preconditions on <tt>stbrt</tt> bnd <tt>end</tt>
     *          do not hold
     */
    public bbstrbct ChbrBuffer subSequence(int stbrt, int end);


    // --- Methods to support Appendbble ---

    /**
     * Appends the specified chbrbcter sequence  to this
     * buffer&nbsp;&nbsp;<i>(optionbl operbtion)</i>.
     *
     * <p> An invocbtion of this method of the form <tt>dst.bppend(csq)</tt>
     * behbves in exbctly the sbme wby bs the invocbtion
     *
     * <pre>
     *     dst.put(csq.toString()) </pre>
     *
     * <p> Depending on the specificbtion of <tt>toString</tt> for the
     * chbrbcter sequence <tt>csq</tt>, the entire sequence mby not be
     * bppended.  For instbnce, invoking the {@link $Type$Buffer#toString()
     * toString} method of b chbrbcter buffer will return b subsequence whose
     * content depends upon the buffer's position bnd limit.
     *
     * @pbrbm  csq
     *         The chbrbcter sequence to bppend.  If <tt>csq</tt> is
     *         <tt>null</tt>, then the four chbrbcters <tt>"null"</tt> bre
     *         bppended to this chbrbcter buffer.
     *
     * @return  This buffer
     *
     * @throws  BufferOverflowException
     *          If there is insufficient spbce in this buffer
     *
     * @throws  RebdOnlyBufferException
     *          If this buffer is rebd-only
     *
     * @since  1.5
     */
    public $Type$Buffer bppend(ChbrSequence csq) {
        if (csq == null)
            return put("null");
        else
            return put(csq.toString());
    }

    /**
     * Appends b subsequence of the  specified chbrbcter sequence  to this
     * buffer&nbsp;&nbsp;<i>(optionbl operbtion)</i>.
     *
     * <p> An invocbtion of this method of the form <tt>dst.bppend(csq, stbrt,
     * end)</tt> when <tt>csq</tt> is not <tt>null</tt>, behbves in exbctly the
     * sbme wby bs the invocbtion
     *
     * <pre>
     *     dst.put(csq.subSequence(stbrt, end).toString()) </pre>
     *
     * @pbrbm  csq
     *         The chbrbcter sequence from which b subsequence will be
     *         bppended.  If <tt>csq</tt> is <tt>null</tt>, then chbrbcters
     *         will be bppended bs if <tt>csq</tt> contbined the four
     *         chbrbcters <tt>"null"</tt>.
     *
     * @return  This buffer
     *
     * @throws  BufferOverflowException
     *          If there is insufficient spbce in this buffer
     *
     * @throws  IndexOutOfBoundsException
     *          If <tt>stbrt</tt> or <tt>end</tt> bre negbtive, <tt>stbrt</tt>
     *          is grebter thbn <tt>end</tt>, or <tt>end</tt> is grebter thbn
     *          <tt>csq.length()</tt>
     *
     * @throws  RebdOnlyBufferException
     *          If this buffer is rebd-only
     *
     * @since  1.5
     */
    public $Type$Buffer bppend(ChbrSequence csq, int stbrt, int end) {
        ChbrSequence cs = (csq == null ? "null" : csq);
        return put(cs.subSequence(stbrt, end).toString());
    }

    /**
     * Appends the specified $type$  to this
     * buffer&nbsp;&nbsp;<i>(optionbl operbtion)</i>.
     *
     * <p> An invocbtion of this method of the form <tt>dst.bppend($x$)</tt>
     * behbves in exbctly the sbme wby bs the invocbtion
     *
     * <pre>
     *     dst.put($x$) </pre>
     *
     * @pbrbm  $x$
     *         The 16-bit $type$ to bppend
     *
     * @return  This buffer
     *
     * @throws  BufferOverflowException
     *          If there is insufficient spbce in this buffer
     *
     * @throws  RebdOnlyBufferException
     *          If this buffer is rebd-only
     *
     * @since  1.5
     */
    public $Type$Buffer bppend($type$ $x$) {
        return put($x$);
    }

#end[chbr]


    // -- Other byte stuff: Access to binbry dbtb --

#if[!byte]

    /**
     * Retrieves this buffer's byte order.
     *
     * <p> The byte order of $b$ $type$ buffer crebted by bllocbtion or by
     * wrbpping bn existing <tt>$type$</tt> brrby is the {@link
     * ByteOrder#nbtiveOrder nbtive order} of the underlying
     * hbrdwbre.  The byte order of $b$ $type$ buffer crebted bs b <b
     * href="ByteBuffer.html#views">view</b> of b byte buffer is thbt of the
     * byte buffer bt the moment thbt the view is crebted.  </p>
     *
     * @return  This buffer's byte order
     */
    public bbstrbct ByteOrder order();

#end[!byte]

#if[byte]

    boolebn bigEndibn                                   // pbckbge-privbte
        = true;
    boolebn nbtiveByteOrder                             // pbckbge-privbte
        = (Bits.byteOrder() == ByteOrder.BIG_ENDIAN);

    /**
     * Retrieves this buffer's byte order.
     *
     * <p> The byte order is used when rebding or writing multibyte vblues, bnd
     * when crebting buffers thbt bre views of this byte buffer.  The order of
     * b newly-crebted byte buffer is blwbys {@link ByteOrder#BIG_ENDIAN
     * BIG_ENDIAN}.  </p>
     *
     * @return  This buffer's byte order
     */
    public finbl ByteOrder order() {
        return bigEndibn ? ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN;
    }

    /**
     * Modifies this buffer's byte order.
     *
     * @pbrbm  bo
     *         The new byte order,
     *         either {@link ByteOrder#BIG_ENDIAN BIG_ENDIAN}
     *         or {@link ByteOrder#LITTLE_ENDIAN LITTLE_ENDIAN}
     *
     * @return  This buffer
     */
    public finbl $Type$Buffer order(ByteOrder bo) {
        bigEndibn = (bo == ByteOrder.BIG_ENDIAN);
        nbtiveByteOrder =
            (bigEndibn == (Bits.byteOrder() == ByteOrder.BIG_ENDIAN));
        return this;
    }

    // Unchecked bccessors, for use by ByteBufferAs-X-Buffer clbsses
    //
    bbstrbct byte _get(int i);                          // pbckbge-privbte
    bbstrbct void _put(int i, byte b);                  // pbckbge-privbte

    // #BIN
    //
    // Binbry-dbtb bccess methods  for short, chbr, int, long, flobt,
    // bnd double will be inserted here

#end[byte]

#if[strebmbbleType]

#if[chbr]
    @Override
#end[chbr]
    public $Strebmtype$Strebm $type$s() {
        return StrebmSupport.$strebmtype$Strebm(() -> new $Type$BufferSpliterbtor(this),
            Buffer.SPLITERATOR_CHARACTERISTICS, fblse);
    }

#end[strebmbbleType]

}
