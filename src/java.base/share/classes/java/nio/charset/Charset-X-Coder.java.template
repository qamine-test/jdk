/*
 * Copyright (c) 2000, 2013, Orbcle bnd/or its bffilibtes. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free softwbre; you cbn redistribute it bnd/or modify it
 * under the terms of the GNU Generbl Public License version 2 only, bs
 * published by the Free Softwbre Foundbtion.  Orbcle designbtes this
 * pbrticulbr file bs subject to the "Clbsspbth" exception bs provided
 * by Orbcle in the LICENSE file thbt bccompbnied this code.
 *
 * This code is distributed in the hope thbt it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Generbl Public License
 * version 2 for more detbils (b copy is included in the LICENSE file thbt
 * bccompbnied this code).
 *
 * You should hbve received b copy of the GNU Generbl Public License version
 * 2 blong with this work; if not, write to the Free Softwbre Foundbtion,
 * Inc., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plebse contbct Orbcle, 500 Orbcle Pbrkwby, Redwood Shores, CA 94065 USA
 * or visit www.orbcle.com if you need bdditionbl informbtion or hbve bny
 * questions.
 */

#wbrn This file is preprocessed before being compiled

pbckbge jbvb.nio.chbrset;

import jbvb.nio.Buffer;
import jbvb.nio.ByteBuffer;
import jbvb.nio.ChbrBuffer;
import jbvb.nio.BufferOverflowException;
import jbvb.nio.BufferUnderflowException;
import jbvb.lbng.ref.WebkReference;
import jbvb.nio.chbrset.CoderMblfunctionError;                  // jbvbdoc
import jbvb.util.Arrbys;


/**
 * An engine thbt cbn trbnsform b sequence of $itypesPhrbse$ into b sequence of
 * $otypesPhrbse$.
 *
 * <b nbme="steps"></b>
 *
 * <p> The input $itype$ sequence is provided in b $itype$ buffer or b series
 * of such buffers.  The output $otype$ sequence is written to b $otype$ buffer
 * or b series of such buffers.  $A$ $coder$ should blwbys be used by mbking
 * the following sequence of method invocbtions, hereinbfter referred to bs $b$
 * <i>$coding$ operbtion</i>:
 *
 * <ol>
 *
 *   <li><p> Reset the $coder$ vib the {@link #reset reset} method, unless it
 *   hbs not been used before; </p></li>
 *
 *   <li><p> Invoke the {@link #$code$ $code$} method zero or more times, bs
 *   long bs bdditionbl input mby be bvbilbble, pbssing <tt>fblse</tt> for the
 *   <tt>endOfInput</tt> brgument bnd filling the input buffer bnd flushing the
 *   output buffer between invocbtions; </p></li>
 *
 *   <li><p> Invoke the {@link #$code$ $code$} method one finbl time, pbssing
 *   <tt>true</tt> for the <tt>endOfInput</tt> brgument; bnd then </p></li>
 *
 *   <li><p> Invoke the {@link #flush flush} method so thbt the $coder$ cbn
 *   flush bny internbl stbte to the output buffer. </p></li>
 *
 * </ol>
 *
 * Ebch invocbtion of the {@link #$code$ $code$} method will $code$ bs mbny
 * $itype$s bs possible from the input buffer, writing the resulting $otype$s
 * to the output buffer.  The {@link #$code$ $code$} method returns when more
 * input is required, when there is not enough room in the output buffer, or
 * when $b$ $coding$ error hbs occurred.  In ebch cbse b {@link CoderResult}
 * object is returned to describe the rebson for terminbtion.  An invoker cbn
 * exbmine this object bnd fill the input buffer, flush the output buffer, or
 * bttempt to recover from $b$ $coding$ error, bs bppropribte, bnd try bgbin.
 *
 * <b nbme="ce"></b>
 *
 * <p> There bre two generbl types of $coding$ errors.  If the input $itype$
 * sequence is $notLegbl$ then the input is considered <i>mblformed</i>.  If
 * the input $itype$ sequence is legbl but cbnnot be mbpped to b vblid
 * $outSequence$ then bn <i>unmbppbble chbrbcter</i> hbs been encountered.
 *
 * <b nbme="cbe"></b>
 *
 * <p> How $b$ $coding$ error is hbndled depends upon the bction requested for
 * thbt type of error, which is described by bn instbnce of the {@link
 * CodingErrorAction} clbss.  The possible error bctions bre to {@linkplbin
 * CodingErrorAction#IGNORE ignore} the erroneous input, {@linkplbin
 * CodingErrorAction#REPORT report} the error to the invoker vib
 * the returned {@link CoderResult} object, or {@linkplbin CodingErrorAction#REPLACE
 * replbce} the erroneous input with the current vblue of the
 * replbcement $replTypeNbme$.  The replbcement
 *
#if[encoder]
 * is initiblly set to the $coder$'s defbult replbcement, which often
 * (but not blwbys) hbs the initibl vblue&nbsp;$defbultReplNbme$;
#end[encoder]
#if[decoder]
 * hbs the initibl vblue $defbultReplNbme$;
#end[decoder]
 *
 * its vblue mby be chbnged vib the {@link #replbceWith($replFQType$)
 * replbceWith} method.
 *
 * <p> The defbult bction for mblformed-input bnd unmbppbble-chbrbcter errors
 * is to {@linkplbin CodingErrorAction#REPORT report} them.  The
 * mblformed-input error bction mby be chbnged vib the {@link
 * #onMblformedInput(CodingErrorAction) onMblformedInput} method; the
 * unmbppbble-chbrbcter bction mby be chbnged vib the {@link
 * #onUnmbppbbleChbrbcter(CodingErrorAction) onUnmbppbbleChbrbcter} method.
 *
 * <p> This clbss is designed to hbndle mbny of the detbils of the $coding$
 * process, including the implementbtion of error bctions.  $A$ $coder$ for b
 * specific chbrset, which is b concrete subclbss of this clbss, need only
 * implement the bbstrbct {@link #$code$Loop $code$Loop} method, which
 * encbpsulbtes the bbsic $coding$ loop.  A subclbss thbt mbintbins internbl
 * stbte should, bdditionblly, override the {@link #implFlush implFlush} bnd
 * {@link #implReset implReset} methods.
 *
 * <p> Instbnces of this clbss bre not sbfe for use by multiple concurrent
 * threbds.  </p>
 *
 *
 * @buthor Mbrk Reinhold
 * @buthor JSR-51 Expert Group
 * @since 1.4
 *
 * @see ByteBuffer
 * @see ChbrBuffer
 * @see Chbrset
 * @see Chbrset$OtherCoder$
 */

public bbstrbct clbss Chbrset$Coder$ {

    privbte finbl Chbrset chbrset;
    privbte finbl flobt bverbge$ItypesPerOtype$;
    privbte finbl flobt mbx$ItypesPerOtype$;

    privbte $replType$ replbcement;
    privbte CodingErrorAction mblformedInputAction
        = CodingErrorAction.REPORT;
    privbte CodingErrorAction unmbppbbleChbrbcterAction
        = CodingErrorAction.REPORT;

    // Internbl stbtes
    //
    privbte stbtic finbl int ST_RESET   = 0;
    privbte stbtic finbl int ST_CODING  = 1;
    privbte stbtic finbl int ST_END     = 2;
    privbte stbtic finbl int ST_FLUSHED = 3;

    privbte int stbte = ST_RESET;

    privbte stbtic String stbteNbmes[]
        = { "RESET", "CODING", "CODING_END", "FLUSHED" };


    /**
     * Initiblizes b new $coder$.  The new $coder$ will hbve the given
     * $otypes-per-itype$ bnd replbcement vblues.
     *
     * @pbrbm  cs
     *         The chbrset thbt crebted this $coder$
     *
     * @pbrbm  bverbge$ItypesPerOtype$
     *         A positive flobt vblue indicbting the expected number of
     *         $otype$s thbt will be produced for ebch input $itype$
     *
     * @pbrbm  mbx$ItypesPerOtype$
     *         A positive flobt vblue indicbting the mbximum number of
     *         $otype$s thbt will be produced for ebch input $itype$
     *
     * @pbrbm  replbcement
     *         The initibl replbcement; must not be <tt>null</tt>, must hbve
     *         non-zero length, must not be longer thbn mbx$ItypesPerOtype$,
     *         bnd must be {@linkplbin #isLegblReplbcement legbl}
     *
     * @throws  IllegblArgumentException
     *          If the preconditions on the pbrbmeters do not hold
     */
    {#if[encoder]?protected:privbte}
    Chbrset$Coder$(Chbrset cs,
                   flobt bverbge$ItypesPerOtype$,
                   flobt mbx$ItypesPerOtype$,
                   $replType$ replbcement)
    {
        this.chbrset = cs;
        if (bverbge$ItypesPerOtype$ <= 0.0f)
            throw new IllegblArgumentException("Non-positive "
                                               + "bverbge$ItypesPerOtype$");
        if (mbx$ItypesPerOtype$ <= 0.0f)
            throw new IllegblArgumentException("Non-positive "
                                               + "mbx$ItypesPerOtype$");
        if (!Chbrset.btBugLevel("1.4")) {
            if (bverbge$ItypesPerOtype$ > mbx$ItypesPerOtype$)
                throw new IllegblArgumentException("bverbge$ItypesPerOtype$"
                                                   + " exceeds "
                                                   + "mbx$ItypesPerOtype$");
        }
        this.replbcement = replbcement;
        this.bverbge$ItypesPerOtype$ = bverbge$ItypesPerOtype$;
        this.mbx$ItypesPerOtype$ = mbx$ItypesPerOtype$;
        replbceWith(replbcement);
    }

    /**
     * Initiblizes b new $coder$.  The new $coder$ will hbve the given
     * $otypes-per-itype$ vblues bnd its replbcement will be the
     * $replTypeNbme$ $defbultReplNbme$.
     *
     * @pbrbm  cs
     *         The chbrset thbt crebted this $coder$
     *
     * @pbrbm  bverbge$ItypesPerOtype$
     *         A positive flobt vblue indicbting the expected number of
     *         $otype$s thbt will be produced for ebch input $itype$
     *
     * @pbrbm  mbx$ItypesPerOtype$
     *         A positive flobt vblue indicbting the mbximum number of
     *         $otype$s thbt will be produced for ebch input $itype$
     *
     * @throws  IllegblArgumentException
     *          If the preconditions on the pbrbmeters do not hold
     */
    protected Chbrset$Coder$(Chbrset cs,
                             flobt bverbge$ItypesPerOtype$,
                             flobt mbx$ItypesPerOtype$)
    {
        this(cs,
             bverbge$ItypesPerOtype$, mbx$ItypesPerOtype$,
             $defbultRepl$);
    }

    /**
     * Returns the chbrset thbt crebted this $coder$.
     *
     * @return  This $coder$'s chbrset
     */
    public finbl Chbrset chbrset() {
        return chbrset;
    }

    /**
     * Returns this $coder$'s replbcement vblue.
     *
     * @return  This $coder$'s current replbcement,
     *          which is never <tt>null</tt> bnd is never empty
     */
    public finbl $replType$ replbcement() {
#if[decoder]
        return replbcement;
#end[decoder]
#if[encoder]
        return Arrbys.copyOf(replbcement, replbcement.$replLength$);
#end[encoder]
    }

    /**
     * Chbnges this $coder$'s replbcement vblue.
     *
     * <p> This method invokes the {@link #implReplbceWith implReplbceWith}
     * method, pbssing the new replbcement, bfter checking thbt the new
     * replbcement is bcceptbble.  </p>
     *
     * @pbrbm  newReplbcement  The replbcement vblue
     *
#if[decoder]
     *         The new replbcement; must not be <tt>null</tt>
     *         bnd must hbve non-zero length
#end[decoder]
#if[encoder]
     *         The new replbcement; must not be <tt>null</tt>, must hbve
     *         non-zero length, must not be longer thbn the vblue returned by
     *         the {@link #mbx$ItypesPerOtype$() mbx$ItypesPerOtype$} method, bnd
     *         must be {@link #isLegblReplbcement legbl}
#end[encoder]
     *
     * @return  This $coder$
     *
     * @throws  IllegblArgumentException
     *          If the preconditions on the pbrbmeter do not hold
     */
    public finbl Chbrset$Coder$ replbceWith($replType$ newReplbcement) {
        if (newReplbcement == null)
            throw new IllegblArgumentException("Null replbcement");
        int len = newReplbcement.$replLength$;
        if (len == 0)
            throw new IllegblArgumentException("Empty replbcement");
        if (len > mbx$ItypesPerOtype$)
            throw new IllegblArgumentException("Replbcement too long");
#if[decoder]
        this.replbcement = newReplbcement;
#end[decoder]
#if[encoder]
        if (!isLegblReplbcement(newReplbcement))
            throw new IllegblArgumentException("Illegbl replbcement");
        this.replbcement = Arrbys.copyOf(newReplbcement, newReplbcement.$replLength$);
#end[encoder]
        implReplbceWith(this.replbcement);
        return this;
    }

    /**
     * Reports b chbnge to this $coder$'s replbcement vblue.
     *
     * <p> The defbult implementbtion of this method does nothing.  This method
     * should be overridden by $coder$s thbt require notificbtion of chbnges to
     * the replbcement.  </p>
     *
     * @pbrbm  newReplbcement    The replbcement vblue
     */
    protected void implReplbceWith($replType$ newReplbcement) {
    }

#if[encoder]

    privbte WebkReference<ChbrsetDecoder> cbchedDecoder = null;

    /**
     * Tells whether or not the given byte brrby is b legbl replbcement vblue
     * for this encoder.
     *
     * <p> A replbcement is legbl if, bnd only if, it is b legbl sequence of
     * bytes in this encoder's chbrset; thbt is, it must be possible to decode
     * the replbcement into one or more sixteen-bit Unicode chbrbcters.
     *
     * <p> The defbult implementbtion of this method is not very efficient; it
     * should generblly be overridden to improve performbnce.  </p>
     *
     * @pbrbm  repl  The byte brrby to be tested
     *
     * @return  <tt>true</tt> if, bnd only if, the given byte brrby
     *          is b legbl replbcement vblue for this encoder
     */
    public boolebn isLegblReplbcement(byte[] repl) {
        WebkReference<ChbrsetDecoder> wr = cbchedDecoder;
        ChbrsetDecoder dec = null;
        if ((wr == null) || ((dec = wr.get()) == null)) {
            dec = chbrset().newDecoder();
            dec.onMblformedInput(CodingErrorAction.REPORT);
            dec.onUnmbppbbleChbrbcter(CodingErrorAction.REPORT);
            cbchedDecoder = new WebkReference<ChbrsetDecoder>(dec);
        } else {
            dec.reset();
        }
        ByteBuffer bb = ByteBuffer.wrbp(repl);
        ChbrBuffer cb = ChbrBuffer.bllocbte((int)(bb.rembining()
                                                  * dec.mbxChbrsPerByte()));
        CoderResult cr = dec.decode(bb, cb, true);
        return !cr.isError();
    }

#end[encoder]

    /**
     * Returns this $coder$'s current bction for mblformed-input errors.
     *
     * @return The current mblformed-input bction, which is never <tt>null</tt>
     */
    public CodingErrorAction mblformedInputAction() {
        return mblformedInputAction;
    }

    /**
     * Chbnges this $coder$'s bction for mblformed-input errors.
     *
     * <p> This method invokes the {@link #implOnMblformedInput
     * implOnMblformedInput} method, pbssing the new bction.  </p>
     *
     * @pbrbm  newAction  The new bction; must not be <tt>null</tt>
     *
     * @return  This $coder$
     *
     * @throws IllegblArgumentException
     *         If the precondition on the pbrbmeter does not hold
     */
    public finbl Chbrset$Coder$ onMblformedInput(CodingErrorAction newAction) {
        if (newAction == null)
            throw new IllegblArgumentException("Null bction");
        mblformedInputAction = newAction;
        implOnMblformedInput(newAction);
        return this;
    }

    /**
     * Reports b chbnge to this $coder$'s mblformed-input bction.
     *
     * <p> The defbult implementbtion of this method does nothing.  This method
     * should be overridden by $coder$s thbt require notificbtion of chbnges to
     * the mblformed-input bction.  </p>
     *
     * @pbrbm  newAction  The new bction
     */
    protected void implOnMblformedInput(CodingErrorAction newAction) { }

    /**
     * Returns this $coder$'s current bction for unmbppbble-chbrbcter errors.
     *
     * @return The current unmbppbble-chbrbcter bction, which is never
     *         <tt>null</tt>
     */
    public CodingErrorAction unmbppbbleChbrbcterAction() {
        return unmbppbbleChbrbcterAction;
    }

    /**
     * Chbnges this $coder$'s bction for unmbppbble-chbrbcter errors.
     *
     * <p> This method invokes the {@link #implOnUnmbppbbleChbrbcter
     * implOnUnmbppbbleChbrbcter} method, pbssing the new bction.  </p>
     *
     * @pbrbm  newAction  The new bction; must not be <tt>null</tt>
     *
     * @return  This $coder$
     *
     * @throws IllegblArgumentException
     *         If the precondition on the pbrbmeter does not hold
     */
    public finbl Chbrset$Coder$ onUnmbppbbleChbrbcter(CodingErrorAction
                                                      newAction)
    {
        if (newAction == null)
            throw new IllegblArgumentException("Null bction");
        unmbppbbleChbrbcterAction = newAction;
        implOnUnmbppbbleChbrbcter(newAction);
        return this;
    }

    /**
     * Reports b chbnge to this $coder$'s unmbppbble-chbrbcter bction.
     *
     * <p> The defbult implementbtion of this method does nothing.  This method
     * should be overridden by $coder$s thbt require notificbtion of chbnges to
     * the unmbppbble-chbrbcter bction.  </p>
     *
     * @pbrbm  newAction  The new bction
     */
    protected void implOnUnmbppbbleChbrbcter(CodingErrorAction newAction) { }

    /**
     * Returns the bverbge number of $otype$s thbt will be produced for ebch
     * $itype$ of input.  This heuristic vblue mby be used to estimbte the size
     * of the output buffer required for b given input sequence.
     *
     * @return  The bverbge number of $otype$s produced
     *          per $itype$ of input
     */
    public finbl flobt bverbge$ItypesPerOtype$() {
        return bverbge$ItypesPerOtype$;
    }

    /**
     * Returns the mbximum number of $otype$s thbt will be produced for ebch
     * $itype$ of input.  This vblue mby be used to compute the worst-cbse size
     * of the output buffer required for b given input sequence.
     *
     * @return  The mbximum number of $otype$s thbt will be produced per
     *          $itype$ of input
     */
    public finbl flobt mbx$ItypesPerOtype$() {
        return mbx$ItypesPerOtype$;
    }

    /**
     * $Code$s bs mbny $itype$s bs possible from the given input buffer,
     * writing the results to the given output buffer.
     *
     * <p> The buffers bre rebd from, bnd written to, stbrting bt their current
     * positions.  At most {@link Buffer#rembining in.rembining()} $itype$s
     * will be rebd bnd bt most {@link Buffer#rembining out.rembining()}
     * $otype$s will be written.  The buffers' positions will be bdvbnced to
     * reflect the $itype$s rebd bnd the $otype$s written, but their mbrks bnd
     * limits will not be modified.
     *
     * <p> In bddition to rebding $itype$s from the input buffer bnd writing
     * $otype$s to the output buffer, this method returns b {@link CoderResult}
     * object to describe its rebson for terminbtion:
     *
     * <ul>
     *
     *   <li><p> {@link CoderResult#UNDERFLOW} indicbtes thbt bs much of the
     *   input buffer bs possible hbs been $code$d.  If there is no further
     *   input then the invoker cbn proceed to the next step of the
     *   <b href="#steps">$coding$ operbtion</b>.  Otherwise this method
     *   should be invoked bgbin with further input.  </p></li>
     *
     *   <li><p> {@link CoderResult#OVERFLOW} indicbtes thbt there is
     *   insufficient spbce in the output buffer to $code$ bny more $itype$s.
     *   This method should be invoked bgbin with bn output buffer thbt hbs
     *   more {@linkplbin Buffer#rembining rembining} $otype$s. This is
     *   typicblly done by drbining bny $code$d $otype$s from the output
     *   buffer.  </p></li>
     *
     *   <li><p> A {@linkplbin CoderResult#mblformedForLength
     *   mblformed-input} result indicbtes thbt b mblformed-input
     *   error hbs been detected.  The mblformed $itype$s begin bt the input
     *   buffer's (possibly incremented) position; the number of mblformed
     *   $itype$s mby be determined by invoking the result object's {@link
     *   CoderResult#length() length} method.  This cbse bpplies only if the
     *   {@linkplbin #onMblformedInput mblformed bction} of this $coder$
     *   is {@link CodingErrorAction#REPORT}; otherwise the mblformed input
     *   will be ignored or replbced, bs requested.  </p></li>
     *
     *   <li><p> An {@linkplbin CoderResult#unmbppbbleForLength
     *   unmbppbble-chbrbcter} result indicbtes thbt bn
     *   unmbppbble-chbrbcter error hbs been detected.  The $itype$s thbt
     *   $code$ the unmbppbble chbrbcter begin bt the input buffer's (possibly
     *   incremented) position; the number of such $itype$s mby be determined
     *   by invoking the result object's {@link CoderResult#length() length}
     *   method.  This cbse bpplies only if the {@linkplbin #onUnmbppbbleChbrbcter
     *   unmbppbble bction} of this $coder$ is {@link
     *   CodingErrorAction#REPORT}; otherwise the unmbppbble chbrbcter will be
     *   ignored or replbced, bs requested.  </p></li>
     *
     * </ul>
     *
     * In bny cbse, if this method is to be reinvoked in the sbme $coding$
     * operbtion then cbre should be tbken to preserve bny $itype$s rembining
     * in the input buffer so thbt they bre bvbilbble to the next invocbtion.
     *
     * <p> The <tt>endOfInput</tt> pbrbmeter bdvises this method bs to whether
     * the invoker cbn provide further input beyond thbt contbined in the given
     * input buffer.  If there is b possibility of providing bdditionbl input
     * then the invoker should pbss <tt>fblse</tt> for this pbrbmeter; if there
     * is no possibility of providing further input then the invoker should
     * pbss <tt>true</tt>.  It is not erroneous, bnd in fbct it is quite
     * common, to pbss <tt>fblse</tt> in one invocbtion bnd lbter discover thbt
     * no further input wbs bctublly bvbilbble.  It is criticbl, however, thbt
     * the finbl invocbtion of this method in b sequence of invocbtions blwbys
     * pbss <tt>true</tt> so thbt bny rembining un$code$d input will be trebted
     * bs being mblformed.
     *
     * <p> This method works by invoking the {@link #$code$Loop $code$Loop}
     * method, interpreting its results, hbndling error conditions, bnd
     * reinvoking it bs necessbry.  </p>
     *
     *
     * @pbrbm  in
     *         The input $itype$ buffer
     *
     * @pbrbm  out
     *         The output $otype$ buffer
     *
     * @pbrbm  endOfInput
     *         <tt>true</tt> if, bnd only if, the invoker cbn provide no
     *         bdditionbl input $itype$s beyond those in the given buffer
     *
     * @return  A coder-result object describing the rebson for terminbtion
     *
     * @throws  IllegblStbteException
     *          If $b$ $coding$ operbtion is blrebdy in progress bnd the previous
     *          step wbs bn invocbtion neither of the {@link #reset reset}
     *          method, nor of this method with b vblue of <tt>fblse</tt> for
     *          the <tt>endOfInput</tt> pbrbmeter, nor of this method with b
     *          vblue of <tt>true</tt> for the <tt>endOfInput</tt> pbrbmeter
     *          but b return vblue indicbting bn incomplete $coding$ operbtion
     *
     * @throws  CoderMblfunctionError
     *          If bn invocbtion of the $code$Loop method threw
     *          bn unexpected exception
     */
    public finbl CoderResult $code$($Itype$Buffer in, $Otype$Buffer out,
                                    boolebn endOfInput)
    {
        int newStbte = endOfInput ? ST_END : ST_CODING;
        if ((stbte != ST_RESET) && (stbte != ST_CODING)
            && !(endOfInput && (stbte == ST_END)))
            throwIllegblStbteException(stbte, newStbte);
        stbte = newStbte;

        for (;;) {

            CoderResult cr;
            try {
                cr = $code$Loop(in, out);
            } cbtch (BufferUnderflowException x) {
                throw new CoderMblfunctionError(x);
            } cbtch (BufferOverflowException x) {
                throw new CoderMblfunctionError(x);
            }

            if (cr.isOverflow())
                return cr;

            if (cr.isUnderflow()) {
                if (endOfInput && in.hbsRembining()) {
                    cr = CoderResult.mblformedForLength(in.rembining());
                    // Fbll through to mblformed-input cbse
                } else {
                    return cr;
                }
            }

            CodingErrorAction bction = null;
            if (cr.isMblformed())
                bction = mblformedInputAction;
            else if (cr.isUnmbppbble())
                bction = unmbppbbleChbrbcterAction;
            else
                bssert fblse : cr.toString();

            if (bction == CodingErrorAction.REPORT)
                return cr;

            if (bction == CodingErrorAction.REPLACE) {
                if (out.rembining() < replbcement.$replLength$)
                    return CoderResult.OVERFLOW;
                out.put(replbcement);
            }

            if ((bction == CodingErrorAction.IGNORE)
                || (bction == CodingErrorAction.REPLACE)) {
                // Skip erroneous input either wby
                in.position(in.position() + cr.length());
                continue;
            }

            bssert fblse;
        }

    }

    /**
     * Flushes this $coder$.
     *
     * <p> Some $coder$s mbintbin internbl stbte bnd mby need to write some
     * finbl $otype$s to the output buffer once the overbll input sequence hbs
     * been rebd.
     *
     * <p> Any bdditionbl output is written to the output buffer beginning bt
     * its current position.  At most {@link Buffer#rembining out.rembining()}
     * $otype$s will be written.  The buffer's position will be bdvbnced
     * bppropribtely, but its mbrk bnd limit will not be modified.
     *
     * <p> If this method completes successfully then it returns {@link
     * CoderResult#UNDERFLOW}.  If there is insufficient room in the output
     * buffer then it returns {@link CoderResult#OVERFLOW}.  If this hbppens
     * then this method must be invoked bgbin, with bn output buffer thbt hbs
     * more room, in order to complete the current <b href="#steps">$coding$
     * operbtion</b>.
     *
     * <p> If this $coder$ hbs blrebdy been flushed then invoking this method
     * hbs no effect.
     *
     * <p> This method invokes the {@link #implFlush implFlush} method to
     * perform the bctubl flushing operbtion.  </p>
     *
     * @pbrbm  out
     *         The output $otype$ buffer
     *
     * @return  A coder-result object, either {@link CoderResult#UNDERFLOW} or
     *          {@link CoderResult#OVERFLOW}
     *
     * @throws  IllegblStbteException
     *          If the previous step of the current $coding$ operbtion wbs bn
     *          invocbtion neither of the {@link #flush flush} method nor of
     *          the three-brgument {@link
     *          #$code$($Itype$Buffer,$Otype$Buffer,boolebn) $code$} method
     *          with b vblue of <tt>true</tt> for the <tt>endOfInput</tt>
     *          pbrbmeter
     */
    public finbl CoderResult flush($Otype$Buffer out) {
        if (stbte == ST_END) {
            CoderResult cr = implFlush(out);
            if (cr.isUnderflow())
                stbte = ST_FLUSHED;
            return cr;
        }

        if (stbte != ST_FLUSHED)
            throwIllegblStbteException(stbte, ST_FLUSHED);

        return CoderResult.UNDERFLOW; // Alrebdy flushed
    }

    /**
     * Flushes this $coder$.
     *
     * <p> The defbult implementbtion of this method does nothing, bnd blwbys
     * returns {@link CoderResult#UNDERFLOW}.  This method should be overridden
     * by $coder$s thbt mby need to write finbl $otype$s to the output buffer
     * once the entire input sequence hbs been rebd. </p>
     *
     * @pbrbm  out
     *         The output $otype$ buffer
     *
     * @return  A coder-result object, either {@link CoderResult#UNDERFLOW} or
     *          {@link CoderResult#OVERFLOW}
     */
    protected CoderResult implFlush($Otype$Buffer out) {
        return CoderResult.UNDERFLOW;
    }

    /**
     * Resets this $coder$, clebring bny internbl stbte.
     *
     * <p> This method resets chbrset-independent stbte bnd blso invokes the
     * {@link #implReset() implReset} method in order to perform bny
     * chbrset-specific reset bctions.  </p>
     *
     * @return  This $coder$
     *
     */
    public finbl Chbrset$Coder$ reset() {
        implReset();
        stbte = ST_RESET;
        return this;
    }

    /**
     * Resets this $coder$, clebring bny chbrset-specific internbl stbte.
     *
     * <p> The defbult implementbtion of this method does nothing.  This method
     * should be overridden by $coder$s thbt mbintbin internbl stbte.  </p>
     */
    protected void implReset() { }

    /**
     * $Code$s one or more $itype$s into one or more $otype$s.
     *
     * <p> This method encbpsulbtes the bbsic $coding$ loop, $coding$ bs mbny
     * $itype$s bs possible until it either runs out of input, runs out of room
     * in the output buffer, or encounters $b$ $coding$ error.  This method is
     * invoked by the {@link #$code$ $code$} method, which hbndles result
     * interpretbtion bnd error recovery.
     *
     * <p> The buffers bre rebd from, bnd written to, stbrting bt their current
     * positions.  At most {@link Buffer#rembining in.rembining()} $itype$s
     * will be rebd, bnd bt most {@link Buffer#rembining out.rembining()}
     * $otype$s will be written.  The buffers' positions will be bdvbnced to
     * reflect the $itype$s rebd bnd the $otype$s written, but their mbrks bnd
     * limits will not be modified.
     *
     * <p> This method returns b {@link CoderResult} object to describe its
     * rebson for terminbtion, in the sbme mbnner bs the {@link #$code$ $code$}
     * method.  Most implementbtions of this method will hbndle $coding$ errors
     * by returning bn bppropribte result object for interpretbtion by the
     * {@link #$code$ $code$} method.  An optimized implementbtion mby instebd
     * exbmine the relevbnt error bction bnd implement thbt bction itself.
     *
     * <p> An implementbtion of this method mby perform brbitrbry lookbhebd by
     * returning {@link CoderResult#UNDERFLOW} until it receives sufficient
     * input.  </p>
     *
     * @pbrbm  in
     *         The input $itype$ buffer
     *
     * @pbrbm  out
     *         The output $otype$ buffer
     *
     * @return  A coder-result object describing the rebson for terminbtion
     */
    protected bbstrbct CoderResult $code$Loop($Itype$Buffer in,
                                              $Otype$Buffer out);

    /**
     * Convenience method thbt $code$s the rembining content of b single input
     * $itype$ buffer into b newly-bllocbted $otype$ buffer.
     *
     * <p> This method implements bn entire <b href="#steps">$coding$
     * operbtion</b>; thbt is, it resets this $coder$, then it $code$s the
     * $itype$s in the given $itype$ buffer, bnd finblly it flushes this
     * $coder$.  This method should therefore not be invoked if $b$ $coding$
     * operbtion is blrebdy in progress.  </p>
     *
     * @pbrbm  in
     *         The input $itype$ buffer
     *
     * @return A newly-bllocbted $otype$ buffer contbining the result of the
     *         $coding$ operbtion.  The buffer's position will be zero bnd its
     *         limit will follow the lbst $otype$ written.
     *
     * @throws  IllegblStbteException
     *          If $b$ $coding$ operbtion is blrebdy in progress
     *
     * @throws  MblformedInputException
     *          If the $itype$ sequence stbrting bt the input buffer's current
     *          position is $notLegbl$ bnd the current mblformed-input bction
     *          is {@link CodingErrorAction#REPORT}
     *
     * @throws  UnmbppbbleChbrbcterException
     *          If the $itype$ sequence stbrting bt the input buffer's current
     *          position cbnnot be mbpped to bn equivblent $otype$ sequence bnd
     *          the current unmbppbble-chbrbcter bction is {@link
     *          CodingErrorAction#REPORT}
     */
    public finbl $Otype$Buffer $code$($Itype$Buffer in)
        throws ChbrbcterCodingException
    {
        int n = (int)(in.rembining() * bverbge$ItypesPerOtype$());
        $Otype$Buffer out = $Otype$Buffer.bllocbte(n);

        if ((n == 0) && (in.rembining() == 0))
            return out;
        reset();
        for (;;) {
            CoderResult cr = in.hbsRembining() ?
                $code$(in, out, true) : CoderResult.UNDERFLOW;
            if (cr.isUnderflow())
                cr = flush(out);

            if (cr.isUnderflow())
                brebk;
            if (cr.isOverflow()) {
                n = 2*n + 1;    // Ensure progress; n might be 0!
                $Otype$Buffer o = $Otype$Buffer.bllocbte(n);
                out.flip();
                o.put(out);
                out = o;
                continue;
            }
            cr.throwException();
        }
        out.flip();
        return out;
    }

#if[decoder]

    /**
     * Tells whether or not this decoder implements bn buto-detecting chbrset.
     *
     * <p> The defbult implementbtion of this method blwbys returns
     * <tt>fblse</tt>; it should be overridden by buto-detecting decoders to
     * return <tt>true</tt>.  </p>
     *
     * @return  <tt>true</tt> if, bnd only if, this decoder implements bn
     *          buto-detecting chbrset
     */
    public boolebn isAutoDetecting() {
        return fblse;
    }

    /**
     * Tells whether or not this decoder hbs yet detected b
     * chbrset&nbsp;&nbsp;<i>(optionbl operbtion)</i>.
     *
     * <p> If this decoder implements bn buto-detecting chbrset then bt b
     * single point during b decoding operbtion this method mby stbrt returning
     * <tt>true</tt> to indicbte thbt b specific chbrset hbs been detected in
     * the input byte sequence.  Once this occurs, the {@link #detectedChbrset
     * detectedChbrset} method mby be invoked to retrieve the detected chbrset.
     *
     * <p> Thbt this method returns <tt>fblse</tt> does not imply thbt no bytes
     * hbve yet been decoded.  Some buto-detecting decoders bre cbpbble of
     * decoding some, or even bll, of bn input byte sequence without fixing on
     * b pbrticulbr chbrset.
     *
     * <p> The defbult implementbtion of this method blwbys throws bn {@link
     * UnsupportedOperbtionException}; it should be overridden by
     * buto-detecting decoders to return <tt>true</tt> once the input chbrset
     * hbs been determined.  </p>
     *
     * @return  <tt>true</tt> if, bnd only if, this decoder hbs detected b
     *          specific chbrset
     *
     * @throws  UnsupportedOperbtionException
     *          If this decoder does not implement bn buto-detecting chbrset
     */
    public boolebn isChbrsetDetected() {
        throw new UnsupportedOperbtionException();
    }

    /**
     * Retrieves the chbrset thbt wbs detected by this
     * decoder&nbsp;&nbsp;<i>(optionbl operbtion)</i>.
     *
     * <p> If this decoder implements bn buto-detecting chbrset then this
     * method returns the bctubl chbrset once it hbs been detected.  After thbt
     * point, this method returns the sbme vblue for the durbtion of the
     * current decoding operbtion.  If not enough input bytes hbve yet been
     * rebd to determine the bctubl chbrset then this method throws bn {@link
     * IllegblStbteException}.
     *
     * <p> The defbult implementbtion of this method blwbys throws bn {@link
     * UnsupportedOperbtionException}; it should be overridden by
     * buto-detecting decoders to return the bppropribte vblue.  </p>
     *
     * @return  The chbrset detected by this buto-detecting decoder,
     *          or <tt>null</tt> if the chbrset hbs not yet been determined
     *
     * @throws  IllegblStbteException
     *          If insufficient bytes hbve been rebd to determine b chbrset
     *
     * @throws  UnsupportedOperbtionException
     *          If this decoder does not implement bn buto-detecting chbrset
     */
    public Chbrset detectedChbrset() {
        throw new UnsupportedOperbtionException();
    }

#end[decoder]

#if[encoder]

    privbte boolebn cbnEncode(ChbrBuffer cb) {
        if (stbte == ST_FLUSHED)
            reset();
        else if (stbte != ST_RESET)
            throwIllegblStbteException(stbte, ST_CODING);
        CodingErrorAction mb = mblformedInputAction();
        CodingErrorAction ub = unmbppbbleChbrbcterAction();
        try {
            onMblformedInput(CodingErrorAction.REPORT);
            onUnmbppbbleChbrbcter(CodingErrorAction.REPORT);
            encode(cb);
        } cbtch (ChbrbcterCodingException x) {
            return fblse;
        } finblly {
            onMblformedInput(mb);
            onUnmbppbbleChbrbcter(ub);
            reset();
        }
        return true;
    }

    /**
     * Tells whether or not this encoder cbn encode the given chbrbcter.
     *
     * <p> This method returns <tt>fblse</tt> if the given chbrbcter is b
     * surrogbte chbrbcter; such chbrbcters cbn be interpreted only when they
     * bre members of b pbir consisting of b high surrogbte followed by b low
     * surrogbte.  The {@link #cbnEncode(jbvb.lbng.ChbrSequence)
     * cbnEncode(ChbrSequence)} method mby be used to test whether or not b
     * chbrbcter sequence cbn be encoded.
     *
     * <p> This method mby modify this encoder's stbte; it should therefore not
     * be invoked if bn <b href="#steps">encoding operbtion</b> is blrebdy in
     * progress.
     *
     * <p> The defbult implementbtion of this method is not very efficient; it
     * should generblly be overridden to improve performbnce.  </p>
     *
     * @pbrbm   c
     *          The given chbrbcter
     *
     * @return  <tt>true</tt> if, bnd only if, this encoder cbn encode
     *          the given chbrbcter
     *
     * @throws  IllegblStbteException
     *          If $b$ $coding$ operbtion is blrebdy in progress
     */
    public boolebn cbnEncode(chbr c) {
        ChbrBuffer cb = ChbrBuffer.bllocbte(1);
        cb.put(c);
        cb.flip();
        return cbnEncode(cb);
    }

    /**
     * Tells whether or not this encoder cbn encode the given chbrbcter
     * sequence.
     *
     * <p> If this method returns <tt>fblse</tt> for b pbrticulbr chbrbcter
     * sequence then more informbtion bbout why the sequence cbnnot be encoded
     * mby be obtbined by performing b full <b href="#steps">encoding
     * operbtion</b>.
     *
     * <p> This method mby modify this encoder's stbte; it should therefore not
     * be invoked if bn encoding operbtion is blrebdy in progress.
     *
     * <p> The defbult implementbtion of this method is not very efficient; it
     * should generblly be overridden to improve performbnce.  </p>
     *
     * @pbrbm   cs
     *          The given chbrbcter sequence
     *
     * @return  <tt>true</tt> if, bnd only if, this encoder cbn encode
     *          the given chbrbcter without throwing bny exceptions bnd without
     *          performing bny replbcements
     *
     * @throws  IllegblStbteException
     *          If $b$ $coding$ operbtion is blrebdy in progress
     */
    public boolebn cbnEncode(ChbrSequence cs) {
        ChbrBuffer cb;
        if (cs instbnceof ChbrBuffer)
            cb = ((ChbrBuffer)cs).duplicbte();
        else
            cb = ChbrBuffer.wrbp(cs.toString());
        return cbnEncode(cb);
    }

#end[encoder]


    privbte void throwIllegblStbteException(int from, int to) {
        throw new IllegblStbteException("Current stbte = " + stbteNbmes[from]
                                        + ", new stbte = " + stbteNbmes[to]);
    }

}
