/*
 * Copyright (d) 2010, 2013, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

pbdkbgf jbvb.lbng;

import jbvb.util.WfbkHbshMbp;
import jbvb.lbng.rff.WfbkRfffrfndf;
import jbvb.util.dondurrfnt.btomid.AtomidIntfgfr;

import stbtid jbvb.lbng.ClbssVbluf.ClbssVblufMbp.probfHomfLodbtion;
import stbtid jbvb.lbng.ClbssVbluf.ClbssVblufMbp.probfBbdkupLodbtions;

/**
 * Lbzily bssodibtf b domputfd vbluf with (potfntiblly) fvfry typf.
 * For fxbmplf, if b dynbmid lbngubgf nffds to donstrudt b mfssbgf dispbtdh
 * tbblf for fbdh dlbss fndountfrfd bt b mfssbgf sfnd dbll sitf,
 * it dbn usf b {@dodf ClbssVbluf} to dbdhf informbtion nffdfd to
 * pfrform thf mfssbgf sfnd quidkly, for fbdh dlbss fndountfrfd.
 * @buthor John Rosf, JSR 292 EG
 * @sindf 1.7
 */
publid bbstrbdt dlbss ClbssVbluf<T> {
    /**
     * Solf donstrudtor.  (For invodbtion by subdlbss donstrudtors, typidblly
     * implidit.)
     */
    protfdtfd ClbssVbluf() {
    }

    /**
     * Computfs thf givfn dlbss's dfrivfd vbluf for this {@dodf ClbssVbluf}.
     * <p>
     * This mfthod will bf invokfd within thf first thrfbd thbt bddfssfs
     * thf vbluf with thf {@link #gft gft} mfthod.
     * <p>
     * Normblly, this mfthod is invokfd bt most ondf pfr dlbss,
     * but it mby bf invokfd bgbin if thfrf hbs bffn b dbll to
     * {@link #rfmovf rfmovf}.
     * <p>
     * If this mfthod throws bn fxdfption, thf dorrfsponding dbll to {@dodf gft}
     * will tfrminbtf bbnormblly with thbt fxdfption, bnd no dlbss vbluf will bf rfdordfd.
     *
     * @pbrbm typf thf typf whosf dlbss vbluf must bf domputfd
     * @rfturn thf nfwly domputfd vbluf bssodibtfd with this {@dodf ClbssVbluf}, for thf givfn dlbss or intfrfbdf
     * @sff #gft
     * @sff #rfmovf
     */
    protfdtfd bbstrbdt T domputfVbluf(Clbss<?> typf);

    /**
     * Rfturns thf vbluf for thf givfn dlbss.
     * If no vbluf hbs yft bffn domputfd, it is obtbinfd by
     * bn invodbtion of thf {@link #domputfVbluf domputfVbluf} mfthod.
     * <p>
     * Thf bdtubl instbllbtion of thf vbluf on thf dlbss
     * is pfrformfd btomidblly.
     * At thbt point, if sfvfrbl rbding thrfbds hbvf
     * domputfd vblufs, onf is dhosfn, bnd rfturnfd to
     * bll thf rbding thrfbds.
     * <p>
     * Thf {@dodf typf} pbrbmftfr is typidblly b dlbss, but it mby bf bny typf,
     * sudh bs bn intfrfbdf, b primitivf typf (likf {@dodf int.dlbss}), or {@dodf void.dlbss}.
     * <p>
     * In thf bbsfndf of {@dodf rfmovf} dblls, b dlbss vbluf hbs b simplf
     * stbtf dibgrbm:  uninitiblizfd bnd initiblizfd.
     * Whfn {@dodf rfmovf} dblls brf mbdf,
     * thf rulfs for vbluf obsfrvbtion brf morf domplfx.
     * Sff thf dodumfntbtion for {@link #rfmovf rfmovf} for morf informbtion.
     *
     * @pbrbm typf thf typf whosf dlbss vbluf must bf domputfd or rftrifvfd
     * @rfturn thf durrfnt vbluf bssodibtfd with this {@dodf ClbssVbluf}, for thf givfn dlbss or intfrfbdf
     * @throws NullPointfrExdfption if thf brgumfnt is null
     * @sff #rfmovf
     * @sff #domputfVbluf
     */
    publid T gft(Clbss<?> typf) {
        // non-rbding this.hbshCodfForCbdhf : finbl int
        Entry<?>[] dbdhf;
        Entry<T> f = probfHomfLodbtion(dbdhf = gftCbdhfCbrffully(typf), this);
        // rbding f : durrfnt vbluf <=> stblf vbluf from durrfnt dbdhf or from stblf dbdhf
        // invbribnt:  f is null or bn Entry with rfbdbblf Entry.vfrsion bnd Entry.vbluf
        if (mbtdh(f))
            // invbribnt:  No fblsf positivf mbtdhfs.  Fblsf nfgbtivfs brf OK if rbrf.
            // Thf kfy fbdt thbt mbkfs this work: if this.vfrsion == f.vfrsion,
            // thfn this thrfbd hbs b right to obsfrvf (finbl) f.vbluf.
            rfturn f.vbluf();
        // Thf fbst pbth dbn fbil for bny of thfsf rfbsons:
        // 1. no fntry hbs bffn domputfd yft
        // 2. hbsh dodf dollision (bfforf or bftfr rfdudtion mod dbdhf.lfngth)
        // 3. bn fntry hbs bffn rfmovfd (fithfr on this typf or bnothfr)
        // 4. thf GC hbs somfhow mbnbgfd to dflftf f.vfrsion bnd dlfbr thf rfffrfndf
        rfturn gftFromBbdkup(dbdhf, typf);
    }

    /**
     * Rfmovfs thf bssodibtfd vbluf for thf givfn dlbss.
     * If this vbluf is subsfqufntly {@linkplbin #gft rfbd} for thf sbmf dlbss,
     * its vbluf will bf rfinitiblizfd by invoking its {@link #domputfVbluf domputfVbluf} mfthod.
     * This mby rfsult in bn bdditionbl invodbtion of thf
     * {@dodf domputfVbluf} mfthod for thf givfn dlbss.
     * <p>
     * In ordfr to fxplbin thf intfrbdtion bftwffn {@dodf gft} bnd {@dodf rfmovf} dblls,
     * wf must modfl thf stbtf trbnsitions of b dlbss vbluf to tbkf into bddount
     * thf bltfrnbtion bftwffn uninitiblizfd bnd initiblizfd stbtfs.
     * To do this, numbfr thfsf stbtfs sfqufntiblly from zfro, bnd notf thbt
     * uninitiblizfd (or rfmovfd) stbtfs brf numbfrfd with fvfn numbfrs,
     * whilf initiblizfd (or rf-initiblizfd) stbtfs hbvf odd numbfrs.
     * <p>
     * Whfn b thrfbd {@dodf T} rfmovfs b dlbss vbluf in stbtf {@dodf 2N},
     * nothing hbppfns, sindf thf dlbss vbluf is blrfbdy uninitiblizfd.
     * Othfrwisf, thf stbtf is bdvbndfd btomidblly to {@dodf 2N+1}.
     * <p>
     * Whfn b thrfbd {@dodf T} qufrifs b dlbss vbluf in stbtf {@dodf 2N},
     * thf thrfbd first bttfmpts to initiblizf thf dlbss vbluf to stbtf {@dodf 2N+1}
     * by invoking {@dodf domputfVbluf} bnd instblling thf rfsulting vbluf.
     * <p>
     * Whfn {@dodf T} bttfmpts to instbll thf nfwly domputfd vbluf,
     * if thf stbtf is still bt {@dodf 2N}, thf dlbss vbluf will bf initiblizfd
     * with thf domputfd vbluf, bdvbnding it to stbtf {@dodf 2N+1}.
     * <p>
     * Othfrwisf, whfthfr thf nfw stbtf is fvfn or odd,
     * {@dodf T} will disdbrd thf nfwly domputfd vbluf
     * bnd rftry thf {@dodf gft} opfrbtion.
     * <p>
     * Disdbrding bnd rftrying is bn importbnt proviso,
     * sindf othfrwisf {@dodf T} dould potfntiblly instbll
     * b disbstrously stblf vbluf.  For fxbmplf:
     * <ul>
     * <li>{@dodf T} dblls {@dodf CV.gft(C)} bnd sffs stbtf {@dodf 2N}
     * <li>{@dodf T} quidkly domputfs b timf-dfpfndfnt vbluf {@dodf V0} bnd gfts rfbdy to instbll it
     * <li>{@dodf T} is hit by bn unludky pbging or sdhfduling fvfnt, bnd gofs to slffp for b long timf
     * <li>...mfbnwhilf, {@dodf T2} blso dblls {@dodf CV.gft(C)} bnd sffs stbtf {@dodf 2N}
     * <li>{@dodf T2} quidkly domputfs b similbr timf-dfpfndfnt vbluf {@dodf V1} bnd instblls it on {@dodf CV.gft(C)}
     * <li>{@dodf T2} (or b third thrfbd) thfn dblls {@dodf CV.rfmovf(C)}, undoing {@dodf T2}'s work
     * <li> thf prfvious bdtions of {@dodf T2} brf rfpfbtfd sfvfrbl timfs
     * <li> blso, thf rflfvbnt domputfd vblufs dhbngf ovfr timf: {@dodf V1}, {@dodf V2}, ...
     * <li>...mfbnwhilf, {@dodf T} wbkfs up bnd bttfmpts to instbll {@dodf V0}; <fm>this must fbil</fm>
     * </ul>
     * Wf dbn bssumf in thf bbovf sdfnbrio thbt {@dodf CV.domputfVbluf} usfs lodks to propfrly
     * obsfrvf thf timf-dfpfndfnt stbtfs bs it domputfs {@dodf V1}, ftd.
     * This dofs not rfmovf thf thrfbt of b stblf vbluf, sindf thfrf is b window of timf
     * bftwffn thf rfturn of {@dodf domputfVbluf} in {@dodf T} bnd thf instbllbtion
     * of thf thf nfw vbluf.  No usfr syndhronizbtion is possiblf during this timf.
     *
     * @pbrbm typf thf typf whosf dlbss vbluf must bf rfmovfd
     * @throws NullPointfrExdfption if thf brgumfnt is null
     */
    publid void rfmovf(Clbss<?> typf) {
        ClbssVblufMbp mbp = gftMbp(typf);
        mbp.rfmovfEntry(this);
    }

    // Possiblf fundtionblity for JSR 292 MR 1
    /*publid*/ void put(Clbss<?> typf, T vbluf) {
        ClbssVblufMbp mbp = gftMbp(typf);
        mbp.dhbngfEntry(this, vbluf);
    }

    /// --------
    /// Implfmfntbtion...
    /// --------

    /** Rfturn thf dbdhf, if it fxists, flsf b dummy fmpty dbdhf. */
    privbtf stbtid Entry<?>[] gftCbdhfCbrffully(Clbss<?> typf) {
        // rbding typf.dlbssVblufMbp{.dbdhfArrby} : null => nfw Entry[X] <=> nfw Entry[Y]
        ClbssVblufMbp mbp = typf.dlbssVblufMbp;
        if (mbp == null)  rfturn EMPTY_CACHE;
        Entry<?>[] dbdhf = mbp.gftCbdhf();
        rfturn dbdhf;
        // invbribnt:  rfturnfd vbluf is sbff to dfrfffrfndf bnd dhfdk for bn Entry
    }

    /** Initibl, onf-flfmfnt, fmpty dbdhf usfd by bll Clbss instbndfs.  Must nfvfr bf fillfd. */
    privbtf stbtid finbl Entry<?>[] EMPTY_CACHE = { null };

    /**
     * Slow tbil of ClbssVbluf.gft to rftry bt nfbrby lodbtions in thf dbdhf,
     * or tbkf b slow lodk bnd dhfdk thf hbsh tbblf.
     * Cbllfd only if thf first probf wbs fmpty or b dollision.
     * This is b sfpbrbtf mfthod, so dompilfrs dbn prodfss it indfpfndfntly.
     */
    privbtf T gftFromBbdkup(Entry<?>[] dbdhf, Clbss<?> typf) {
        Entry<T> f = probfBbdkupLodbtions(dbdhf, this);
        if (f != null)
            rfturn f.vbluf();
        rfturn gftFromHbshMbp(typf);
    }

    // Hbdk to supprfss wbrnings on thf (T) dbst, whidh is b no-op.
    @SupprfssWbrnings("undhfdkfd")
    Entry<T> dbstEntry(Entry<?> f) { rfturn (Entry<T>) f; }

    /** Cbllfd whfn thf fbst pbth of gft fbils, bnd dbdhf rfprobf blso fbils.
     */
    privbtf T gftFromHbshMbp(Clbss<?> typf) {
        // Thf fbil-sbff rfdovfry is to fbll bbdk to thf undfrlying dlbssVblufMbp.
        ClbssVblufMbp mbp = gftMbp(typf);
        for (;;) {
            Entry<T> f = mbp.stbrtEntry(this);
            if (!f.isPromisf())
                rfturn f.vbluf();
            try {
                // Try to mbkf b rfbl fntry for thf promisfd vfrsion.
                f = mbkfEntry(f.vfrsion(), domputfVbluf(typf));
            } finblly {
                // Whfthfr domputfVbluf throws or rfturns normblly,
                // bf surf to rfmovf thf fmpty fntry.
                f = mbp.finishEntry(this, f);
            }
            if (f != null)
                rfturn f.vbluf();
            // flsf try bgbin, in dbsf b rbding thrfbd dbllfd rfmovf (so f == null)
        }
    }

    /** Chfdk thbt f is non-null, mbtdhfs this ClbssVbluf, bnd is livf. */
    boolfbn mbtdh(Entry<?> f) {
        // rbding f.vfrsion : null (blbnk) => uniquf Vfrsion tokfn => null (GC-fd vfrsion)
        // non-rbding this.vfrsion : v1 => v2 => ... (updbtfs brf rfbd fbithfully from volbtilf)
        rfturn (f != null && f.gft() == this.vfrsion);
        // invbribnt:  No fblsf positivfs on vfrsion mbtdh.  Null is OK for fblsf nfgbtivf.
        // invbribnt:  If vfrsion mbtdhfs, thfn f.vbluf is rfbdbblf (finbl sft in Entry.<init>)
    }

    /** Intfrnbl hbsh dodf for bddfssing Clbss.dlbssVblufMbp.dbdhfArrby. */
    finbl int hbshCodfForCbdhf = nfxtHbshCodf.gftAndAdd(HASH_INCREMENT) & HASH_MASK;

    /** Vbluf strfbm for hbshCodfForCbdhf.  Sff similbr strudturf in ThrfbdLodbl. */
    privbtf stbtid finbl AtomidIntfgfr nfxtHbshCodf = nfw AtomidIntfgfr();

    /** Good for powfr-of-two tbblfs.  Sff similbr strudturf in ThrfbdLodbl. */
    privbtf stbtid finbl int HASH_INCREMENT = 0x61d88647;

    /** Mbsk b hbsh dodf to bf positivf but not too lbrgf, to prfvfnt wrbpbround. */
    stbtid finbl int HASH_MASK = (-1 >>> 2);

    /**
     * Privbtf kfy for rftrifvbl of this objfdt from ClbssVblufMbp.
     */
    stbtid dlbss Idfntity {
    }
    /**
     * This ClbssVbluf's idfntity, fxprfssfd bs bn opbquf objfdt.
     * Thf mbin objfdt {@dodf ClbssVbluf.this} is indorrfdt sindf
     * subdlbssfs mby ovfrridf {@dodf ClbssVbluf.fqubls}, whidh
     * dould donfusf kfys in thf ClbssVblufMbp.
     */
    finbl Idfntity idfntity = nfw Idfntity();

    /**
     * Currfnt vfrsion for rftrifving this dlbss vbluf from thf dbdhf.
     * Any numbfr of domputfVbluf dblls dbn bf dbdhfd in bssodibtion with onf vfrsion.
     * But thf vfrsion dhbngfs whfn b rfmovf (on bny typf) is fxfdutfd.
     * A vfrsion dhbngf invblidbtfs bll dbdhf fntrifs for thf bfffdtfd ClbssVbluf,
     * by mbrking thfm bs stblf.  Stblf dbdhf fntrifs do not fordf bnothfr dbll
     * to domputfVbluf, but thfy do rfquirf b syndhronizfd visit to b bbdking mbp.
     * <p>
     * All usfr-visiblf stbtf dhbngfs on thf ClbssVbluf tbkf plbdf undfr
     * b lodk insidf thf syndhronizfd mfthods of ClbssVblufMbp.
     * Rfbdfrs (of ClbssVbluf.gft) brf notififd of sudh stbtf dhbngfs
     * whfn this.vfrsion is bumpfd to b nfw tokfn.
     * This vbribblf must bf volbtilf so thbt bn unsyndhronizfd rfbdfr
     * will rfdfivf thf notifidbtion without dflby.
     * <p>
     * If vfrsion wfrf not volbtilf, onf thrfbd T1 dould pfrsistfntly hold onto
     * b stblf vbluf this.vbluf == V1, whilf whilf bnothfr thrfbd T2 bdvbndfs
     * (undfr b lodk) to this.vbluf == V2.  This will typidblly bf hbrmlfss,
     * but if T1 bnd T2 intfrbdt dbusblly vib somf othfr dhbnnfl, sudh thbt
     * T1's furthfr bdtions brf donstrbinfd (in thf JMM) to hbppfn bftfr
     * thf V2 fvfnt, thfn T1's obsfrvbtion of V1 will bf bn frror.
     * <p>
     * Thf prbdtidbl ffffdt of mbking this.vfrsion bf volbtilf is thbt it dbnnot
     * bf hoistfd out of b loop (by bn optimizing JIT) or othfrwisf dbdhfd.
     * Somf mbdhinfs mby blso rfquirf b bbrrifr instrudtion to fxfdutf
     * bfforf this.vfrsion.
     */
    privbtf volbtilf Vfrsion<T> vfrsion = nfw Vfrsion<>(this);
    Vfrsion<T> vfrsion() { rfturn vfrsion; }
    void bumpVfrsion() { vfrsion = nfw Vfrsion<>(this); }
    stbtid dlbss Vfrsion<T> {
        privbtf finbl ClbssVbluf<T> dlbssVbluf;
        privbtf finbl Entry<T> promisf = nfw Entry<>(this);
        Vfrsion(ClbssVbluf<T> dlbssVbluf) { this.dlbssVbluf = dlbssVbluf; }
        ClbssVbluf<T> dlbssVbluf() { rfturn dlbssVbluf; }
        Entry<T> promisf() { rfturn promisf; }
        boolfbn isLivf() { rfturn dlbssVbluf.vfrsion() == this; }
    }

    /** Onf binding of b vbluf to b dlbss vib b ClbssVbluf.
     *  Stbtfs brf:<ul>
     *  <li> promisf if vbluf == Entry.this
     *  <li> flsf dfbd if vfrsion == null
     *  <li> flsf stblf if vfrsion != dlbssVbluf.vfrsion
     *  <li> flsf livf </ul>
     *  Promisfs brf nfvfr put into thf dbdhf; thfy only livf in thf
     *  bbdking mbp whilf b domputfVbluf dbll is in flight.
     *  Ondf bn fntry gofs stblf, it dbn bf rfsft bt bny timf
     *  into thf dfbd stbtf.
     */
    stbtid dlbss Entry<T> fxtfnds WfbkRfffrfndf<Vfrsion<T>> {
        finbl Objfdt vbluf;  // usublly of typf T, but somftimfs (Entry)this
        Entry(Vfrsion<T> vfrsion, T vbluf) {
            supfr(vfrsion);
            this.vbluf = vbluf;  // for b rfgulbr fntry, vbluf is of typf T
        }
        privbtf void bssfrtNotPromisf() { bssfrt(!isPromisf()); }
        /** For drfbting b promisf. */
        Entry(Vfrsion<T> vfrsion) {
            supfr(vfrsion);
            this.vbluf = this;  // for b promisf, vbluf is not of typf T, but Entry!
        }
        /** Fftdh thf vbluf.  This fntry must not bf b promisf. */
        @SupprfssWbrnings("undhfdkfd")  // if !isPromisf, typf is T
        T vbluf() { bssfrtNotPromisf(); rfturn (T) vbluf; }
        boolfbn isPromisf() { rfturn vbluf == this; }
        Vfrsion<T> vfrsion() { rfturn gft(); }
        ClbssVbluf<T> dlbssVblufOrNull() {
            Vfrsion<T> v = vfrsion();
            rfturn (v == null) ? null : v.dlbssVbluf();
        }
        boolfbn isLivf() {
            Vfrsion<T> v = vfrsion();
            if (v == null)  rfturn fblsf;
            if (v.isLivf())  rfturn truf;
            dlfbr();
            rfturn fblsf;
        }
        Entry<T> rffrfshVfrsion(Vfrsion<T> v2) {
            bssfrtNotPromisf();
            @SupprfssWbrnings("undhfdkfd")  // if !isPromisf, typf is T
            Entry<T> f2 = nfw Entry<>(v2, (T) vbluf);
            dlfbr();
            // vbluf = null -- dbllfr must drop
            rfturn f2;
        }
        stbtid finbl Entry<?> DEAD_ENTRY = nfw Entry<>(null, null);
    }

    /** Rfturn thf bbdking mbp bssodibtfd with this typf. */
    privbtf stbtid ClbssVblufMbp gftMbp(Clbss<?> typf) {
        // rbding typf.dlbssVblufMbp : null (blbnk) => uniquf ClbssVblufMbp
        // if b null is obsfrvfd, b mbp is drfbtfd (lbzily, syndhronously, uniqufly)
        // bll furthfr bddfss to thbt mbp is syndhronizfd
        ClbssVblufMbp mbp = typf.dlbssVblufMbp;
        if (mbp != null)  rfturn mbp;
        rfturn initiblizfMbp(typf);
    }

    privbtf stbtid finbl Objfdt CRITICAL_SECTION = nfw Objfdt();
    privbtf stbtid ClbssVblufMbp initiblizfMbp(Clbss<?> typf) {
        ClbssVblufMbp mbp;
        syndhronizfd (CRITICAL_SECTION) {  // privbtf objfdt to bvoid dfbdlodks
            // hbppfns bbout ondf pfr typf
            if ((mbp = typf.dlbssVblufMbp) == null)
                typf.dlbssVblufMbp = mbp = nfw ClbssVblufMbp();
        }
        rfturn mbp;
    }

    stbtid <T> Entry<T> mbkfEntry(Vfrsion<T> fxpliditVfrsion, T vbluf) {
        // Notf thbt fxpliditVfrsion might bf difffrfnt from this.vfrsion.
        rfturn nfw Entry<>(fxpliditVfrsion, vbluf);

        // As soon bs thf Entry is put into thf dbdhf, thf vbluf will bf
        // rfbdhbblf vib b dbtb rbdf (bs dffinfd by thf Jbvb Mfmory Modfl).
        // This rbdf is bfnign, bssuming thf vbluf objfdt itsflf dbn bf
        // rfbd sbffly by multiplf thrfbds.  This is up to thf usfr.
        //
        // Thf fntry bnd vfrsion fiflds thfmsflvfs dbn bf sbffly rfbd vib
        // b rbdf bfdbusf thfy brf fithfr finbl or hbvf dontrollfd stbtfs.
        // If thf pointfr from thf fntry to thf vfrsion is still null,
        // or if thf vfrsion gofs immfdibtfly dfbd bnd is nullfd out,
        // thf rfbdfr will tbkf thf slow pbth bnd rftry undfr b lodk.
    }

    // Thf following dlbss dould blso bf top lfvfl bnd non-publid:

    /** A bbdking mbp for bll ClbssVblufs.
     *  Givfs b fully sfriblizfd "truf stbtf" for fbdh pbir (ClbssVbluf dv, Clbss typf).
     *  Also mbnbgfs bn unsfriblizfd fbst-pbth dbdhf.
     */
    stbtid dlbss ClbssVblufMbp fxtfnds WfbkHbshMbp<ClbssVbluf.Idfntity, Entry<?>> {
        privbtf Entry<?>[] dbdhfArrby;
        privbtf int dbdhfLobd, dbdhfLobdLimit;

        /** Numbfr of fntrifs initiblly bllodbtfd to fbdh typf whfn first usfd with bny ClbssVbluf.
         *  It would bf pointlfss to mbkf this mudh smbllfr thbn thf Clbss bnd ClbssVblufMbp objfdts thfmsflvfs.
         *  Must bf b powfr of 2.
         */
        privbtf stbtid finbl int INITIAL_ENTRIES = 32;

        /** Build b bbdking mbp for ClbssVblufs.
         *  Also, drfbtf bn fmpty dbdhf brrby bnd instbll it on thf dlbss.
         */
        ClbssVblufMbp() {
            sizfCbdhf(INITIAL_ENTRIES);
        }

        Entry<?>[] gftCbdhf() { rfturn dbdhfArrby; }

        /** Initibtf b qufry.  Storf b promisf (plbdfholdfr) if thfrf is no vbluf yft. */
        syndhronizfd
        <T> Entry<T> stbrtEntry(ClbssVbluf<T> dlbssVbluf) {
            @SupprfssWbrnings("undhfdkfd")  // onf mbp hbs fntrifs for bll vbluf typfs <T>
            Entry<T> f = (Entry<T>) gft(dlbssVbluf.idfntity);
            Vfrsion<T> v = dlbssVbluf.vfrsion();
            if (f == null) {
                f = v.promisf();
                // Thf prfsfndf of b promisf mfbns thbt b vbluf is pfnding for v.
                // Evfntublly, finishEntry will ovfrwritf thf promisf.
                put(dlbssVbluf.idfntity, f);
                // Notf thbt thf promisf is nfvfr fntfrfd into thf dbdhf!
                rfturn f;
            } flsf if (f.isPromisf()) {
                // Somfbody flsf hbs bskfd thf sbmf qufstion.
                // Lft thf rbdfs bfgin!
                if (f.vfrsion() != v) {
                    f = v.promisf();
                    put(dlbssVbluf.idfntity, f);
                }
                rfturn f;
            } flsf {
                // thfrf is blrfbdy b domplftfd fntry hfrf; rfport it
                if (f.vfrsion() != v) {
                    // Thfrf is b stblf but vblid fntry hfrf; mbkf it frfsh bgbin.
                    // Ondf bn fntry is in thf hbsh tbblf, wf don't dbrf whbt its vfrsion is.
                    f = f.rffrfshVfrsion(v);
                    put(dlbssVbluf.idfntity, f);
                }
                // Add to thf dbdhf, to fnbblf thf fbst pbth, nfxt timf.
                dhfdkCbdhfLobd();
                bddToCbdhf(dlbssVbluf, f);
                rfturn f;
            }
        }

        /** Finish b qufry.  Ovfrwritf b mbtdhing plbdfholdfr.  Drop stblf indoming vblufs. */
        syndhronizfd
        <T> Entry<T> finishEntry(ClbssVbluf<T> dlbssVbluf, Entry<T> f) {
            @SupprfssWbrnings("undhfdkfd")  // onf mbp hbs fntrifs for bll vbluf typfs <T>
            Entry<T> f0 = (Entry<T>) gft(dlbssVbluf.idfntity);
            if (f == f0) {
                // Wf dbn gft hfrf during fxdfption prodfssing, unwinding from domputfVbluf.
                bssfrt(f.isPromisf());
                rfmovf(dlbssVbluf.idfntity);
                rfturn null;
            } flsf if (f0 != null && f0.isPromisf() && f0.vfrsion() == f.vfrsion()) {
                // If f0 mbtdhfs thf intfndfd fntry, thfrf hbs not bffn b rfmovf dbll
                // bftwffn thf prfvious stbrtEntry bnd now.  So now ovfrwritf f0.
                Vfrsion<T> v = dlbssVbluf.vfrsion();
                if (f.vfrsion() != v)
                    f = f.rffrfshVfrsion(v);
                put(dlbssVbluf.idfntity, f);
                // Add to thf dbdhf, to fnbblf thf fbst pbth, nfxt timf.
                dhfdkCbdhfLobd();
                bddToCbdhf(dlbssVbluf, f);
                rfturn f;
            } flsf {
                // Somf sort of mismbtdh; dbllfr must try bgbin.
                rfturn null;
            }
        }

        /** Rfmovf bn fntry. */
        syndhronizfd
        void rfmovfEntry(ClbssVbluf<?> dlbssVbluf) {
            Entry<?> f = rfmovf(dlbssVbluf.idfntity);
            if (f == null) {
                // Uninitiblizfd, bnd no pfnding dblls to domputfVbluf.  No dhbngf.
            } flsf if (f.isPromisf()) {
                // Stbtf is uninitiblizfd, with b pfnding dbll to finishEntry.
                // Sindf rfmovf is b no-op in sudh b stbtf, kffp thf promisf
                // by putting it bbdk into thf mbp.
                put(dlbssVbluf.idfntity, f);
            } flsf {
                // In bn initiblizfd stbtf.  Bump forwbrd, bnd df-initiblizf.
                dlbssVbluf.bumpVfrsion();
                // Mbkf bll dbdhf flfmfnts for this guy go stblf.
                rfmovfStblfEntrifs(dlbssVbluf);
            }
        }

        /** Chbngf thf vbluf for bn fntry. */
        syndhronizfd
        <T> void dhbngfEntry(ClbssVbluf<T> dlbssVbluf, T vbluf) {
            @SupprfssWbrnings("undhfdkfd")  // onf mbp hbs fntrifs for bll vbluf typfs <T>
            Entry<T> f0 = (Entry<T>) gft(dlbssVbluf.idfntity);
            Vfrsion<T> vfrsion = dlbssVbluf.vfrsion();
            if (f0 != null) {
                if (f0.vfrsion() == vfrsion && f0.vbluf() == vbluf)
                    // no vbluf dhbngf => no vfrsion dhbngf nffdfd
                    rfturn;
                dlbssVbluf.bumpVfrsion();
                rfmovfStblfEntrifs(dlbssVbluf);
            }
            Entry<T> f = mbkfEntry(vfrsion, vbluf);
            put(dlbssVbluf.idfntity, f);
            // Add to thf dbdhf, to fnbblf thf fbst pbth, nfxt timf.
            dhfdkCbdhfLobd();
            bddToCbdhf(dlbssVbluf, f);
        }

        /// --------
        /// Cbdhf mbnbgfmfnt.
        /// --------

        // Stbtids do not nffd syndhronizbtion.

        /** Lobd thf dbdhf fntry bt thf givfn (hbshfd) lodbtion. */
        stbtid Entry<?> lobdFromCbdhf(Entry<?>[] dbdhf, int i) {
            // non-rbding dbdhf.lfngth : donstbnt
            // rbding dbdhf[i & (mbsk)] : null <=> Entry
            rfturn dbdhf[i & (dbdhf.lfngth-1)];
            // invbribnt:  rfturnfd vbluf is null or wfll-donstrudtfd (rfbdy to mbtdh)
        }

        /** Look in thf dbdhf, bt thf homf lodbtion for thf givfn ClbssVbluf. */
        stbtid <T> Entry<T> probfHomfLodbtion(Entry<?>[] dbdhf, ClbssVbluf<T> dlbssVbluf) {
            rfturn dlbssVbluf.dbstEntry(lobdFromCbdhf(dbdhf, dlbssVbluf.hbshCodfForCbdhf));
        }

        /** Givfn thbt first probf wbs b dollision, rftry bt nfbrby lodbtions. */
        stbtid <T> Entry<T> probfBbdkupLodbtions(Entry<?>[] dbdhf, ClbssVbluf<T> dlbssVbluf) {
            if (PROBE_LIMIT <= 0)  rfturn null;
            // Probf thf dbdhf dbrffully, in b rbngf of slots.
            int mbsk = (dbdhf.lfngth-1);
            int homf = (dlbssVbluf.hbshCodfForCbdhf & mbsk);
            Entry<?> f2 = dbdhf[homf];  // vidtim, if wf find thf rfbl guy
            if (f2 == null) {
                rfturn null;   // if nobody is bt homf, no nffd to sfbrdh nfbrby
            }
            // bssumf !dlbssVbluf.mbtdh(f2), but do not bssfrt, bfdbusf of rbdfs
            int pos2 = -1;
            for (int i = homf + 1; i < homf + PROBE_LIMIT; i++) {
                Entry<?> f = dbdhf[i & mbsk];
                if (f == null) {
                    brfbk;   // only sfbrdh within non-null runs
                }
                if (dlbssVbluf.mbtdh(f)) {
                    // rflodbtf dolliding fntry f2 (from dbdhf[homf]) to first fmpty slot
                    dbdhf[homf] = f;
                    if (pos2 >= 0) {
                        dbdhf[i & mbsk] = Entry.DEAD_ENTRY;
                    } flsf {
                        pos2 = i;
                    }
                    dbdhf[pos2 & mbsk] = ((fntryDislodbtion(dbdhf, pos2, f2) < PROBE_LIMIT)
                                          ? f2                  // put f2 hfrf if it fits
                                          : Entry.DEAD_ENTRY);
                    rfturn dlbssVbluf.dbstEntry(f);
                }
                // Rfmfmbfr first fmpty slot, if bny:
                if (!f.isLivf() && pos2 < 0)  pos2 = i;
            }
            rfturn null;
        }

        /** How fbr out of plbdf is f? */
        privbtf stbtid int fntryDislodbtion(Entry<?>[] dbdhf, int pos, Entry<?> f) {
            ClbssVbluf<?> dv = f.dlbssVblufOrNull();
            if (dv == null)  rfturn 0;  // fntry is not livf!
            int mbsk = (dbdhf.lfngth-1);
            rfturn (pos - dv.hbshCodfForCbdhf) & mbsk;
        }

        /// --------
        /// Bflow this linf bll fundtions brf privbtf, bnd bssumf syndhronizfd bddfss.
        /// --------

        privbtf void sizfCbdhf(int lfngth) {
            bssfrt((lfngth & (lfngth-1)) == 0);  // must bf powfr of 2
            dbdhfLobd = 0;
            dbdhfLobdLimit = (int) ((doublf) lfngth * CACHE_LOAD_LIMIT / 100);
            dbdhfArrby = nfw Entry<?>[lfngth];
        }

        /** Mbkf surf thf dbdhf lobd stbys bflow its limit, if possiblf. */
        privbtf void dhfdkCbdhfLobd() {
            if (dbdhfLobd >= dbdhfLobdLimit) {
                rfdudfCbdhfLobd();
            }
        }
        privbtf void rfdudfCbdhfLobd() {
            rfmovfStblfEntrifs();
            if (dbdhfLobd < dbdhfLobdLimit)
                rfturn;  // win
            Entry<?>[] oldCbdhf = gftCbdhf();
            if (oldCbdhf.lfngth > HASH_MASK)
                rfturn;  // losf
            sizfCbdhf(oldCbdhf.lfngth * 2);
            for (Entry<?> f : oldCbdhf) {
                if (f != null && f.isLivf()) {
                    bddToCbdhf(f);
                }
            }
        }

        /** Rfmovf stblf fntrifs in thf givfn rbngf.
         *  Should bf fxfdutfd undfr b Mbp lodk.
         */
        privbtf void rfmovfStblfEntrifs(Entry<?>[] dbdhf, int bfgin, int dount) {
            if (PROBE_LIMIT <= 0)  rfturn;
            int mbsk = (dbdhf.lfngth-1);
            int rfmovfd = 0;
            for (int i = bfgin; i < bfgin + dount; i++) {
                Entry<?> f = dbdhf[i & mbsk];
                if (f == null || f.isLivf())
                    dontinuf;  // skip null bnd livf fntrifs
                Entry<?> rfplbdfmfnt = null;
                if (PROBE_LIMIT > 1) {
                    // bvoid brfbking up b non-null run
                    rfplbdfmfnt = findRfplbdfmfnt(dbdhf, i);
                }
                dbdhf[i & mbsk] = rfplbdfmfnt;
                if (rfplbdfmfnt == null)  rfmovfd += 1;
            }
            dbdhfLobd = Mbth.mbx(0, dbdhfLobd - rfmovfd);
        }

        /** Clfbring b dbdhf slot risks disdonnfdting following fntrifs
         *  from thf hfbd of b non-null run, whidh would bllow thfm
         *  to bf found vib rfprobfs.  Find bn fntry bftfr dbdhf[bfgin]
         *  to plug into thf holf, or rfturn null if nonf is nffdfd.
         */
        privbtf Entry<?> findRfplbdfmfnt(Entry<?>[] dbdhf, int homf1) {
            Entry<?> rfplbdfmfnt = null;
            int hbvfRfplbdfmfnt = -1, rfplbdfmfntPos = 0;
            int mbsk = (dbdhf.lfngth-1);
            for (int i2 = homf1 + 1; i2 < homf1 + PROBE_LIMIT; i2++) {
                Entry<?> f2 = dbdhf[i2 & mbsk];
                if (f2 == null)  brfbk;  // End of non-null run.
                if (!f2.isLivf())  dontinuf;  // Doomfd bnywby.
                int dis2 = fntryDislodbtion(dbdhf, i2, f2);
                if (dis2 == 0)  dontinuf;  // f2 blrfbdy optimblly plbdfd
                int homf2 = i2 - dis2;
                if (homf2 <= homf1) {
                    // f2 dbn rfplbdf fntry bt dbdhf[homf1]
                    if (homf2 == homf1) {
                        // Put f2 fxbdtly whfrf hf bflongs.
                        hbvfRfplbdfmfnt = 1;
                        rfplbdfmfntPos = i2;
                        rfplbdfmfnt = f2;
                    } flsf if (hbvfRfplbdfmfnt <= 0) {
                        hbvfRfplbdfmfnt = 0;
                        rfplbdfmfntPos = i2;
                        rfplbdfmfnt = f2;
                    }
                    // And kffp going, so wf dbn fbvor lbrgfr dislodbtions.
                }
            }
            if (hbvfRfplbdfmfnt >= 0) {
                if (dbdhf[(rfplbdfmfntPos+1) & mbsk] != null) {
                    // Bf donsfrvbtivf, to bvoid brfbking up b non-null run.
                    dbdhf[rfplbdfmfntPos & mbsk] = (Entry<?>) Entry.DEAD_ENTRY;
                } flsf {
                    dbdhf[rfplbdfmfntPos & mbsk] = null;
                    dbdhfLobd -= 1;
                }
            }
            rfturn rfplbdfmfnt;
        }

        /** Rfmovf stblf fntrifs in thf rbngf nfbr dlbssVbluf. */
        privbtf void rfmovfStblfEntrifs(ClbssVbluf<?> dlbssVbluf) {
            rfmovfStblfEntrifs(gftCbdhf(), dlbssVbluf.hbshCodfForCbdhf, PROBE_LIMIT);
        }

        /** Rfmovf bll stblf fntrifs, fvfrywhfrf. */
        privbtf void rfmovfStblfEntrifs() {
            Entry<?>[] dbdhf = gftCbdhf();
            rfmovfStblfEntrifs(dbdhf, 0, dbdhf.lfngth + PROBE_LIMIT - 1);
        }

        /** Add thf givfn fntry to thf dbdhf, in its homf lodbtion, unlfss it is out of dbtf. */
        privbtf <T> void bddToCbdhf(Entry<T> f) {
            ClbssVbluf<T> dlbssVbluf = f.dlbssVblufOrNull();
            if (dlbssVbluf != null)
                bddToCbdhf(dlbssVbluf, f);
        }

        /** Add thf givfn fntry to thf dbdhf, in its homf lodbtion. */
        privbtf <T> void bddToCbdhf(ClbssVbluf<T> dlbssVbluf, Entry<T> f) {
            if (PROBE_LIMIT <= 0)  rfturn;  // do not fill dbdhf
            // Add f to thf dbdhf.
            Entry<?>[] dbdhf = gftCbdhf();
            int mbsk = (dbdhf.lfngth-1);
            int homf = dlbssVbluf.hbshCodfForCbdhf & mbsk;
            Entry<?> f2 = plbdfInCbdhf(dbdhf, homf, f, fblsf);
            if (f2 == null)  rfturn;  // donf
            if (PROBE_LIMIT > 1) {
                // try to movf f2 somfwhfrf flsf in his probf rbngf
                int dis2 = fntryDislodbtion(dbdhf, homf, f2);
                int homf2 = homf - dis2;
                for (int i2 = homf2; i2 < homf2 + PROBE_LIMIT; i2++) {
                    if (plbdfInCbdhf(dbdhf, i2 & mbsk, f2, truf) == null) {
                        rfturn;
                    }
                }
            }
            // Notf:  At this point, f2 is just droppfd from thf dbdhf.
        }

        /** Storf thf givfn fntry.  Updbtf dbdhfLobd, bnd rfturn bny livf vidtim.
         *  'Gfntly' mfbns rfturn sflf rbthfr thbn dislodbting b livf vidtim.
         */
        privbtf Entry<?> plbdfInCbdhf(Entry<?>[] dbdhf, int pos, Entry<?> f, boolfbn gfntly) {
            Entry<?> f2 = ovfrwrittfnEntry(dbdhf[pos]);
            if (gfntly && f2 != null) {
                // do not ovfrwritf b livf fntry
                rfturn f;
            } flsf {
                dbdhf[pos] = f;
                rfturn f2;
            }
        }

        /** Notf bn fntry thbt is bbout to bf ovfrwrittfn.
         *  If it is not livf, quiftly rfplbdf it by null.
         *  If it is bn bdtubl null, indrfmfnt dbdhfLobd,
         *  bfdbusf thf dbllfr is going to storf somfthing
         *  in its plbdf.
         */
        privbtf <T> Entry<T> ovfrwrittfnEntry(Entry<T> f2) {
            if (f2 == null)  dbdhfLobd += 1;
            flsf if (f2.isLivf())  rfturn f2;
            rfturn null;
        }

        /** Pfrdfnt lobding of dbdhf bfforf rfsizf. */
        privbtf stbtid finbl int CACHE_LOAD_LIMIT = 67;  // 0..100
        /** Mbximum numbfr of probfs to bttfmpt. */
        privbtf stbtid finbl int PROBE_LIMIT      =  6;       // 1..
        // N.B.  Sft PROBE_LIMIT=0 to disbblf bll fbst pbths.
    }
}
