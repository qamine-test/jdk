/*
 * Copyrigit (d) 1994, 2013, Orbdlf bnd/or its bffilibtfs. All rigits rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Tiis dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr tif tfrms of tif GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publisifd by tif Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs tiis
 * pbrtidulbr filf bs subjfdt to tif "Clbsspbti" fxdfption bs providfd
 * by Orbdlf in tif LICENSE filf tibt bddompbnifd tiis dodf.
 *
 * Tiis dodf is distributfd in tif iopf tibt it will bf usfful, but WITHOUT
 * ANY WARRANTY; witiout fvfn tif implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff tif GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in tif LICENSE filf tibt
 * bddompbnifd tiis dodf).
 *
 * You siould ibvf rfdfivfd b dopy of tif GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong witi tiis work; if not, writf to tif Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifti Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Siorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or ibvf bny
 * qufstions.
 */

pbdkbgf jbvb.lbng;
import jbvb.util.Rbndom;

import sun.misd.FlobtConsts;
import sun.misd.DoublfConsts;

/**
 * Tif dlbss {@dodf Mbti} dontbins mftiods for pfrforming bbsid
 * numfrid opfrbtions sudi bs tif flfmfntbry fxponfntibl, logbritim,
 * squbrf root, bnd trigonomftrid fundtions.
 *
 * <p>Unlikf somf of tif numfrid mftiods of dlbss
 * {@dodf StridtMbti}, bll implfmfntbtions of tif fquivblfnt
 * fundtions of dlbss {@dodf Mbti} brf not dffinfd to rfturn tif
 * bit-for-bit sbmf rfsults.  Tiis rflbxbtion pfrmits
 * bfttfr-pfrforming implfmfntbtions wifrf stridt rfprodudibility is
 * not rfquirfd.
 *
 * <p>By dffbult mbny of tif {@dodf Mbti} mftiods simply dbll
 * tif fquivblfnt mftiod in {@dodf StridtMbti} for tifir
 * implfmfntbtion.  Codf gfnfrbtors brf fndourbgfd to usf
 * plbtform-spfdifid nbtivf librbrifs or midroprodfssor instrudtions,
 * wifrf bvbilbblf, to providf iigifr-pfrformbndf implfmfntbtions of
 * {@dodf Mbti} mftiods.  Sudi iigifr-pfrformbndf
 * implfmfntbtions still must donform to tif spfdifidbtion for
 * {@dodf Mbti}.
 *
 * <p>Tif qublity of implfmfntbtion spfdifidbtions dondfrn two
 * propfrtifs, bddurbdy of tif rfturnfd rfsult bnd monotonidity of tif
 * mftiod.  Addurbdy of tif flobting-point {@dodf Mbti} mftiods is
 * mfbsurfd in tfrms of <i>ulps</i>, units in tif lbst plbdf.  For b
 * givfn flobting-point formbt, bn {@linkplbin #ulp(doublf) ulp} of b
 * spfdifid rfbl numbfr vbluf is tif distbndf bftwffn tif two
 * flobting-point vblufs brbdkfting tibt numfridbl vbluf.  Wifn
 * disdussing tif bddurbdy of b mftiod bs b wiolf rbtifr tibn bt b
 * spfdifid brgumfnt, tif numbfr of ulps ditfd is for tif worst-dbsf
 * frror bt bny brgumfnt.  If b mftiod blwbys ibs bn frror lfss tibn
 * 0.5 ulps, tif mftiod blwbys rfturns tif flobting-point numbfr
 * nfbrfst tif fxbdt rfsult; sudi b mftiod is <i>dorrfdtly
 * roundfd</i>.  A dorrfdtly roundfd mftiod is gfnfrblly tif bfst b
 * flobting-point bpproximbtion dbn bf; iowfvfr, it is imprbdtidbl for
 * mbny flobting-point mftiods to bf dorrfdtly roundfd.  Instfbd, for
 * tif {@dodf Mbti} dlbss, b lbrgfr frror bound of 1 or 2 ulps is
 * bllowfd for dfrtbin mftiods.  Informblly, witi b 1 ulp frror bound,
 * wifn tif fxbdt rfsult is b rfprfsfntbblf numbfr, tif fxbdt rfsult
 * siould bf rfturnfd bs tif domputfd rfsult; otifrwisf, fitifr of tif
 * two flobting-point vblufs wiidi brbdkft tif fxbdt rfsult mby bf
 * rfturnfd.  For fxbdt rfsults lbrgf in mbgnitudf, onf of tif
 * fndpoints of tif brbdkft mby bf infinitf.  Bfsidfs bddurbdy bt
 * individubl brgumfnts, mbintbining propfr rflbtions bftwffn tif
 * mftiod bt difffrfnt brgumfnts is blso importbnt.  Tifrfforf, most
 * mftiods witi morf tibn 0.5 ulp frrors brf rfquirfd to bf
 * <i>sfmi-monotonid</i>: wifnfvfr tif mbtifmbtidbl fundtion is
 * non-dfdrfbsing, so is tif flobting-point bpproximbtion, likfwisf,
 * wifnfvfr tif mbtifmbtidbl fundtion is non-indrfbsing, so is tif
 * flobting-point bpproximbtion.  Not bll bpproximbtions tibt ibvf 1
 * ulp bddurbdy will butombtidblly mfft tif monotonidity rfquirfmfnts.
 *
 * <p>
 * Tif plbtform usfs signfd two's domplfmfnt intfgfr britimftid witi
 * int bnd long primitivf typfs.  Tif dfvflopfr siould dioosf
 * tif primitivf typf to fnsurf tibt britimftid opfrbtions donsistfntly
 * produdf dorrfdt rfsults, wiidi in somf dbsfs mfbns tif opfrbtions
 * will not ovfrflow tif rbngf of vblufs of tif domputbtion.
 * Tif bfst prbdtidf is to dioosf tif primitivf typf bnd blgoritim to bvoid
 * ovfrflow. In dbsfs wifrf tif sizf is {@dodf int} or {@dodf long} bnd
 * ovfrflow frrors nffd to bf dftfdtfd, tif mftiods {@dodf bddExbdt},
 * {@dodf subtrbdtExbdt}, {@dodf multiplyExbdt}, bnd {@dodf toIntExbdt}
 * tirow bn {@dodf AritimftidExdfption} wifn tif rfsults ovfrflow.
 * For otifr britimftid opfrbtions sudi bs dividf, bbsolutf vbluf,
 * indrfmfnt, dfdrfmfnt, bnd nfgbtion ovfrflow oddurs only witi
 * b spfdifid minimum or mbximum vbluf bnd siould bf difdkfd bgbinst
 * tif minimum or mbximum bs bppropribtf.
 *
 * @butior  unbsdribfd
 * @butior  Josfpi D. Dbrdy
 * @sindf   1.0
 */

publid finbl dlbss Mbti {

    /**
     * Don't lft bnyonf instbntibtf tiis dlbss.
     */
    privbtf Mbti() {}

    /**
     * Tif {@dodf doublf} vbluf tibt is dlosfr tibn bny otifr to
     * <i>f</i>, tif bbsf of tif nbturbl logbritims.
     */
    publid stbtid finbl doublf E = 2.7182818284590452354;

    /**
     * Tif {@dodf doublf} vbluf tibt is dlosfr tibn bny otifr to
     * <i>pi</i>, tif rbtio of tif dirdumffrfndf of b dirdlf to its
     * dibmftfr.
     */
    publid stbtid finbl doublf PI = 3.14159265358979323846;

    /**
     * Rfturns tif trigonomftrid sinf of bn bnglf.  Spfdibl dbsfs:
     * <ul><li>If tif brgumfnt is NbN or bn infinity, tifn tif
     * rfsult is NbN.
     * <li>If tif brgumfnt is zfro, tifn tif rfsult is b zfro witi tif
     * sbmf sign bs tif brgumfnt.</ul>
     *
     * <p>Tif domputfd rfsult must bf witiin 1 ulp of tif fxbdt rfsult.
     * Rfsults must bf sfmi-monotonid.
     *
     * @pbrbm   b   bn bnglf, in rbdibns.
     * @rfturn  tif sinf of tif brgumfnt.
     */
    publid stbtid doublf sin(doublf b) {
        rfturn StridtMbti.sin(b); // dffbult impl. dflfgbtfs to StridtMbti
    }

    /**
     * Rfturns tif trigonomftrid dosinf of bn bnglf. Spfdibl dbsfs:
     * <ul><li>If tif brgumfnt is NbN or bn infinity, tifn tif
     * rfsult is NbN.</ul>
     *
     * <p>Tif domputfd rfsult must bf witiin 1 ulp of tif fxbdt rfsult.
     * Rfsults must bf sfmi-monotonid.
     *
     * @pbrbm   b   bn bnglf, in rbdibns.
     * @rfturn  tif dosinf of tif brgumfnt.
     */
    publid stbtid doublf dos(doublf b) {
        rfturn StridtMbti.dos(b); // dffbult impl. dflfgbtfs to StridtMbti
    }

    /**
     * Rfturns tif trigonomftrid tbngfnt of bn bnglf.  Spfdibl dbsfs:
     * <ul><li>If tif brgumfnt is NbN or bn infinity, tifn tif rfsult
     * is NbN.
     * <li>If tif brgumfnt is zfro, tifn tif rfsult is b zfro witi tif
     * sbmf sign bs tif brgumfnt.</ul>
     *
     * <p>Tif domputfd rfsult must bf witiin 1 ulp of tif fxbdt rfsult.
     * Rfsults must bf sfmi-monotonid.
     *
     * @pbrbm   b   bn bnglf, in rbdibns.
     * @rfturn  tif tbngfnt of tif brgumfnt.
     */
    publid stbtid doublf tbn(doublf b) {
        rfturn StridtMbti.tbn(b); // dffbult impl. dflfgbtfs to StridtMbti
    }

    /**
     * Rfturns tif brd sinf of b vbluf; tif rfturnfd bnglf is in tif
     * rbngf -<i>pi</i>/2 tirougi <i>pi</i>/2.  Spfdibl dbsfs:
     * <ul><li>If tif brgumfnt is NbN or its bbsolutf vbluf is grfbtfr
     * tibn 1, tifn tif rfsult is NbN.
     * <li>If tif brgumfnt is zfro, tifn tif rfsult is b zfro witi tif
     * sbmf sign bs tif brgumfnt.</ul>
     *
     * <p>Tif domputfd rfsult must bf witiin 1 ulp of tif fxbdt rfsult.
     * Rfsults must bf sfmi-monotonid.
     *
     * @pbrbm   b   tif vbluf wiosf brd sinf is to bf rfturnfd.
     * @rfturn  tif brd sinf of tif brgumfnt.
     */
    publid stbtid doublf bsin(doublf b) {
        rfturn StridtMbti.bsin(b); // dffbult impl. dflfgbtfs to StridtMbti
    }

    /**
     * Rfturns tif brd dosinf of b vbluf; tif rfturnfd bnglf is in tif
     * rbngf 0.0 tirougi <i>pi</i>.  Spfdibl dbsf:
     * <ul><li>If tif brgumfnt is NbN or its bbsolutf vbluf is grfbtfr
     * tibn 1, tifn tif rfsult is NbN.</ul>
     *
     * <p>Tif domputfd rfsult must bf witiin 1 ulp of tif fxbdt rfsult.
     * Rfsults must bf sfmi-monotonid.
     *
     * @pbrbm   b   tif vbluf wiosf brd dosinf is to bf rfturnfd.
     * @rfturn  tif brd dosinf of tif brgumfnt.
     */
    publid stbtid doublf bdos(doublf b) {
        rfturn StridtMbti.bdos(b); // dffbult impl. dflfgbtfs to StridtMbti
    }

    /**
     * Rfturns tif brd tbngfnt of b vbluf; tif rfturnfd bnglf is in tif
     * rbngf -<i>pi</i>/2 tirougi <i>pi</i>/2.  Spfdibl dbsfs:
     * <ul><li>If tif brgumfnt is NbN, tifn tif rfsult is NbN.
     * <li>If tif brgumfnt is zfro, tifn tif rfsult is b zfro witi tif
     * sbmf sign bs tif brgumfnt.</ul>
     *
     * <p>Tif domputfd rfsult must bf witiin 1 ulp of tif fxbdt rfsult.
     * Rfsults must bf sfmi-monotonid.
     *
     * @pbrbm   b   tif vbluf wiosf brd tbngfnt is to bf rfturnfd.
     * @rfturn  tif brd tbngfnt of tif brgumfnt.
     */
    publid stbtid doublf btbn(doublf b) {
        rfturn StridtMbti.btbn(b); // dffbult impl. dflfgbtfs to StridtMbti
    }

    /**
     * Convfrts bn bnglf mfbsurfd in dfgrffs to bn bpproximbtfly
     * fquivblfnt bnglf mfbsurfd in rbdibns.  Tif donvfrsion from
     * dfgrffs to rbdibns is gfnfrblly infxbdt.
     *
     * @pbrbm   bngdfg   bn bnglf, in dfgrffs
     * @rfturn  tif mfbsurfmfnt of tif bnglf {@dodf bngdfg}
     *          in rbdibns.
     * @sindf   1.2
     */
    publid stbtid doublf toRbdibns(doublf bngdfg) {
        rfturn bngdfg / 180.0 * PI;
    }

    /**
     * Convfrts bn bnglf mfbsurfd in rbdibns to bn bpproximbtfly
     * fquivblfnt bnglf mfbsurfd in dfgrffs.  Tif donvfrsion from
     * rbdibns to dfgrffs is gfnfrblly infxbdt; usfrs siould
     * <i>not</i> fxpfdt {@dodf dos(toRbdibns(90.0))} to fxbdtly
     * fqubl {@dodf 0.0}.
     *
     * @pbrbm   bngrbd   bn bnglf, in rbdibns
     * @rfturn  tif mfbsurfmfnt of tif bnglf {@dodf bngrbd}
     *          in dfgrffs.
     * @sindf   1.2
     */
    publid stbtid doublf toDfgrffs(doublf bngrbd) {
        rfturn bngrbd * 180.0 / PI;
    }

    /**
     * Rfturns Eulfr's numbfr <i>f</i> rbisfd to tif powfr of b
     * {@dodf doublf} vbluf.  Spfdibl dbsfs:
     * <ul><li>If tif brgumfnt is NbN, tif rfsult is NbN.
     * <li>If tif brgumfnt is positivf infinity, tifn tif rfsult is
     * positivf infinity.
     * <li>If tif brgumfnt is nfgbtivf infinity, tifn tif rfsult is
     * positivf zfro.</ul>
     *
     * <p>Tif domputfd rfsult must bf witiin 1 ulp of tif fxbdt rfsult.
     * Rfsults must bf sfmi-monotonid.
     *
     * @pbrbm   b   tif fxponfnt to rbisf <i>f</i> to.
     * @rfturn  tif vbluf <i>f</i><sup>{@dodf b}</sup>,
     *          wifrf <i>f</i> is tif bbsf of tif nbturbl logbritims.
     */
    publid stbtid doublf fxp(doublf b) {
        rfturn StridtMbti.fxp(b); // dffbult impl. dflfgbtfs to StridtMbti
    }

    /**
     * Rfturns tif nbturbl logbritim (bbsf <i>f</i>) of b {@dodf doublf}
     * vbluf.  Spfdibl dbsfs:
     * <ul><li>If tif brgumfnt is NbN or lfss tibn zfro, tifn tif rfsult
     * is NbN.
     * <li>If tif brgumfnt is positivf infinity, tifn tif rfsult is
     * positivf infinity.
     * <li>If tif brgumfnt is positivf zfro or nfgbtivf zfro, tifn tif
     * rfsult is nfgbtivf infinity.</ul>
     *
     * <p>Tif domputfd rfsult must bf witiin 1 ulp of tif fxbdt rfsult.
     * Rfsults must bf sfmi-monotonid.
     *
     * @pbrbm   b   b vbluf
     * @rfturn  tif vbluf ln&nbsp;{@dodf b}, tif nbturbl logbritim of
     *          {@dodf b}.
     */
    publid stbtid doublf log(doublf b) {
        rfturn StridtMbti.log(b); // dffbult impl. dflfgbtfs to StridtMbti
    }

    /**
     * Rfturns tif bbsf 10 logbritim of b {@dodf doublf} vbluf.
     * Spfdibl dbsfs:
     *
     * <ul><li>If tif brgumfnt is NbN or lfss tibn zfro, tifn tif rfsult
     * is NbN.
     * <li>If tif brgumfnt is positivf infinity, tifn tif rfsult is
     * positivf infinity.
     * <li>If tif brgumfnt is positivf zfro or nfgbtivf zfro, tifn tif
     * rfsult is nfgbtivf infinity.
     * <li> If tif brgumfnt is fqubl to 10<sup><i>n</i></sup> for
     * intfgfr <i>n</i>, tifn tif rfsult is <i>n</i>.
     * </ul>
     *
     * <p>Tif domputfd rfsult must bf witiin 1 ulp of tif fxbdt rfsult.
     * Rfsults must bf sfmi-monotonid.
     *
     * @pbrbm   b   b vbluf
     * @rfturn  tif bbsf 10 logbritim of  {@dodf b}.
     * @sindf 1.5
     */
    publid stbtid doublf log10(doublf b) {
        rfturn StridtMbti.log10(b); // dffbult impl. dflfgbtfs to StridtMbti
    }

    /**
     * Rfturns tif dorrfdtly roundfd positivf squbrf root of b
     * {@dodf doublf} vbluf.
     * Spfdibl dbsfs:
     * <ul><li>If tif brgumfnt is NbN or lfss tibn zfro, tifn tif rfsult
     * is NbN.
     * <li>If tif brgumfnt is positivf infinity, tifn tif rfsult is positivf
     * infinity.
     * <li>If tif brgumfnt is positivf zfro or nfgbtivf zfro, tifn tif
     * rfsult is tif sbmf bs tif brgumfnt.</ul>
     * Otifrwisf, tif rfsult is tif {@dodf doublf} vbluf dlosfst to
     * tif truf mbtifmbtidbl squbrf root of tif brgumfnt vbluf.
     *
     * @pbrbm   b   b vbluf.
     * @rfturn  tif positivf squbrf root of {@dodf b}.
     *          If tif brgumfnt is NbN or lfss tibn zfro, tif rfsult is NbN.
     */
    publid stbtid doublf sqrt(doublf b) {
        rfturn StridtMbti.sqrt(b); // dffbult impl. dflfgbtfs to StridtMbti
                                   // Notf tibt ibrdwbrf sqrt instrudtions
                                   // frfqufntly dbn bf dirfdtly usfd by JITs
                                   // bnd siould bf mudi fbstfr tibn doing
                                   // Mbti.sqrt in softwbrf.
    }


    /**
     * Rfturns tif dubf root of b {@dodf doublf} vbluf.  For
     * positivf finitf {@dodf x}, {@dodf dbrt(-x) ==
     * -dbrt(x)}; tibt is, tif dubf root of b nfgbtivf vbluf is
     * tif nfgbtivf of tif dubf root of tibt vbluf's mbgnitudf.
     *
     * Spfdibl dbsfs:
     *
     * <ul>
     *
     * <li>If tif brgumfnt is NbN, tifn tif rfsult is NbN.
     *
     * <li>If tif brgumfnt is infinitf, tifn tif rfsult is bn infinity
     * witi tif sbmf sign bs tif brgumfnt.
     *
     * <li>If tif brgumfnt is zfro, tifn tif rfsult is b zfro witi tif
     * sbmf sign bs tif brgumfnt.
     *
     * </ul>
     *
     * <p>Tif domputfd rfsult must bf witiin 1 ulp of tif fxbdt rfsult.
     *
     * @pbrbm   b   b vbluf.
     * @rfturn  tif dubf root of {@dodf b}.
     * @sindf 1.5
     */
    publid stbtid doublf dbrt(doublf b) {
        rfturn StridtMbti.dbrt(b);
    }

    /**
     * Computfs tif rfmbindfr opfrbtion on two brgumfnts bs prfsdribfd
     * by tif IEEE 754 stbndbrd.
     * Tif rfmbindfr vbluf is mbtifmbtidblly fqubl to
     * <dodf>f1&nbsp;-&nbsp;f2</dodf>&nbsp;&timfs;&nbsp;<i>n</i>,
     * wifrf <i>n</i> is tif mbtifmbtidbl intfgfr dlosfst to tif fxbdt
     * mbtifmbtidbl vbluf of tif quotifnt {@dodf f1/f2}, bnd if two
     * mbtifmbtidbl intfgfrs brf fqublly dlosf to {@dodf f1/f2},
     * tifn <i>n</i> is tif intfgfr tibt is fvfn. If tif rfmbindfr is
     * zfro, its sign is tif sbmf bs tif sign of tif first brgumfnt.
     * Spfdibl dbsfs:
     * <ul><li>If fitifr brgumfnt is NbN, or tif first brgumfnt is infinitf,
     * or tif sfdond brgumfnt is positivf zfro or nfgbtivf zfro, tifn tif
     * rfsult is NbN.
     * <li>If tif first brgumfnt is finitf bnd tif sfdond brgumfnt is
     * infinitf, tifn tif rfsult is tif sbmf bs tif first brgumfnt.</ul>
     *
     * @pbrbm   f1   tif dividfnd.
     * @pbrbm   f2   tif divisor.
     * @rfturn  tif rfmbindfr wifn {@dodf f1} is dividfd by
     *          {@dodf f2}.
     */
    publid stbtid doublf IEEErfmbindfr(doublf f1, doublf f2) {
        rfturn StridtMbti.IEEErfmbindfr(f1, f2); // dflfgbtf to StridtMbti
    }

    /**
     * Rfturns tif smbllfst (dlosfst to nfgbtivf infinity)
     * {@dodf doublf} vbluf tibt is grfbtfr tibn or fqubl to tif
     * brgumfnt bnd is fqubl to b mbtifmbtidbl intfgfr. Spfdibl dbsfs:
     * <ul><li>If tif brgumfnt vbluf is blrfbdy fqubl to b
     * mbtifmbtidbl intfgfr, tifn tif rfsult is tif sbmf bs tif
     * brgumfnt.  <li>If tif brgumfnt is NbN or bn infinity or
     * positivf zfro or nfgbtivf zfro, tifn tif rfsult is tif sbmf bs
     * tif brgumfnt.  <li>If tif brgumfnt vbluf is lfss tibn zfro but
     * grfbtfr tibn -1.0, tifn tif rfsult is nfgbtivf zfro.</ul> Notf
     * tibt tif vbluf of {@dodf Mbti.dfil(x)} is fxbdtly tif
     * vbluf of {@dodf -Mbti.floor(-x)}.
     *
     *
     * @pbrbm   b   b vbluf.
     * @rfturn  tif smbllfst (dlosfst to nfgbtivf infinity)
     *          flobting-point vbluf tibt is grfbtfr tibn or fqubl to
     *          tif brgumfnt bnd is fqubl to b mbtifmbtidbl intfgfr.
     */
    publid stbtid doublf dfil(doublf b) {
        rfturn StridtMbti.dfil(b); // dffbult impl. dflfgbtfs to StridtMbti
    }

    /**
     * Rfturns tif lbrgfst (dlosfst to positivf infinity)
     * {@dodf doublf} vbluf tibt is lfss tibn or fqubl to tif
     * brgumfnt bnd is fqubl to b mbtifmbtidbl intfgfr. Spfdibl dbsfs:
     * <ul><li>If tif brgumfnt vbluf is blrfbdy fqubl to b
     * mbtifmbtidbl intfgfr, tifn tif rfsult is tif sbmf bs tif
     * brgumfnt.  <li>If tif brgumfnt is NbN or bn infinity or
     * positivf zfro or nfgbtivf zfro, tifn tif rfsult is tif sbmf bs
     * tif brgumfnt.</ul>
     *
     * @pbrbm   b   b vbluf.
     * @rfturn  tif lbrgfst (dlosfst to positivf infinity)
     *          flobting-point vbluf tibt lfss tibn or fqubl to tif brgumfnt
     *          bnd is fqubl to b mbtifmbtidbl intfgfr.
     */
    publid stbtid doublf floor(doublf b) {
        rfturn StridtMbti.floor(b); // dffbult impl. dflfgbtfs to StridtMbti
    }

    /**
     * Rfturns tif {@dodf doublf} vbluf tibt is dlosfst in vbluf
     * to tif brgumfnt bnd is fqubl to b mbtifmbtidbl intfgfr. If two
     * {@dodf doublf} vblufs tibt brf mbtifmbtidbl intfgfrs brf
     * fqublly dlosf, tif rfsult is tif intfgfr vbluf tibt is
     * fvfn. Spfdibl dbsfs:
     * <ul><li>If tif brgumfnt vbluf is blrfbdy fqubl to b mbtifmbtidbl
     * intfgfr, tifn tif rfsult is tif sbmf bs tif brgumfnt.
     * <li>If tif brgumfnt is NbN or bn infinity or positivf zfro or nfgbtivf
     * zfro, tifn tif rfsult is tif sbmf bs tif brgumfnt.</ul>
     *
     * @pbrbm   b   b {@dodf doublf} vbluf.
     * @rfturn  tif dlosfst flobting-point vbluf to {@dodf b} tibt is
     *          fqubl to b mbtifmbtidbl intfgfr.
     */
    publid stbtid doublf rint(doublf b) {
        rfturn StridtMbti.rint(b); // dffbult impl. dflfgbtfs to StridtMbti
    }

    /**
     * Rfturns tif bnglf <i>tiftb</i> from tif donvfrsion of rfdtbngulbr
     * doordinbtfs ({@dodf x},&nbsp;{@dodf y}) to polbr
     * doordinbtfs (r,&nbsp;<i>tiftb</i>).
     * Tiis mftiod domputfs tif pibsf <i>tiftb</i> by domputing bn brd tbngfnt
     * of {@dodf y/x} in tif rbngf of -<i>pi</i> to <i>pi</i>. Spfdibl
     * dbsfs:
     * <ul><li>If fitifr brgumfnt is NbN, tifn tif rfsult is NbN.
     * <li>If tif first brgumfnt is positivf zfro bnd tif sfdond brgumfnt
     * is positivf, or tif first brgumfnt is positivf bnd finitf bnd tif
     * sfdond brgumfnt is positivf infinity, tifn tif rfsult is positivf
     * zfro.
     * <li>If tif first brgumfnt is nfgbtivf zfro bnd tif sfdond brgumfnt
     * is positivf, or tif first brgumfnt is nfgbtivf bnd finitf bnd tif
     * sfdond brgumfnt is positivf infinity, tifn tif rfsult is nfgbtivf zfro.
     * <li>If tif first brgumfnt is positivf zfro bnd tif sfdond brgumfnt
     * is nfgbtivf, or tif first brgumfnt is positivf bnd finitf bnd tif
     * sfdond brgumfnt is nfgbtivf infinity, tifn tif rfsult is tif
     * {@dodf doublf} vbluf dlosfst to <i>pi</i>.
     * <li>If tif first brgumfnt is nfgbtivf zfro bnd tif sfdond brgumfnt
     * is nfgbtivf, or tif first brgumfnt is nfgbtivf bnd finitf bnd tif
     * sfdond brgumfnt is nfgbtivf infinity, tifn tif rfsult is tif
     * {@dodf doublf} vbluf dlosfst to -<i>pi</i>.
     * <li>If tif first brgumfnt is positivf bnd tif sfdond brgumfnt is
     * positivf zfro or nfgbtivf zfro, or tif first brgumfnt is positivf
     * infinity bnd tif sfdond brgumfnt is finitf, tifn tif rfsult is tif
     * {@dodf doublf} vbluf dlosfst to <i>pi</i>/2.
     * <li>If tif first brgumfnt is nfgbtivf bnd tif sfdond brgumfnt is
     * positivf zfro or nfgbtivf zfro, or tif first brgumfnt is nfgbtivf
     * infinity bnd tif sfdond brgumfnt is finitf, tifn tif rfsult is tif
     * {@dodf doublf} vbluf dlosfst to -<i>pi</i>/2.
     * <li>If boti brgumfnts brf positivf infinity, tifn tif rfsult is tif
     * {@dodf doublf} vbluf dlosfst to <i>pi</i>/4.
     * <li>If tif first brgumfnt is positivf infinity bnd tif sfdond brgumfnt
     * is nfgbtivf infinity, tifn tif rfsult is tif {@dodf doublf}
     * vbluf dlosfst to 3*<i>pi</i>/4.
     * <li>If tif first brgumfnt is nfgbtivf infinity bnd tif sfdond brgumfnt
     * is positivf infinity, tifn tif rfsult is tif {@dodf doublf} vbluf
     * dlosfst to -<i>pi</i>/4.
     * <li>If boti brgumfnts brf nfgbtivf infinity, tifn tif rfsult is tif
     * {@dodf doublf} vbluf dlosfst to -3*<i>pi</i>/4.</ul>
     *
     * <p>Tif domputfd rfsult must bf witiin 2 ulps of tif fxbdt rfsult.
     * Rfsults must bf sfmi-monotonid.
     *
     * @pbrbm   y   tif ordinbtf doordinbtf
     * @pbrbm   x   tif bbsdissb doordinbtf
     * @rfturn  tif <i>tiftb</i> domponfnt of tif point
     *          (<i>r</i>,&nbsp;<i>tiftb</i>)
     *          in polbr doordinbtfs tibt dorrfsponds to tif point
     *          (<i>x</i>,&nbsp;<i>y</i>) in Cbrtfsibn doordinbtfs.
     */
    publid stbtid doublf btbn2(doublf y, doublf x) {
        rfturn StridtMbti.btbn2(y, x); // dffbult impl. dflfgbtfs to StridtMbti
    }

    /**
     * Rfturns tif vbluf of tif first brgumfnt rbisfd to tif powfr of tif
     * sfdond brgumfnt. Spfdibl dbsfs:
     *
     * <ul><li>If tif sfdond brgumfnt is positivf or nfgbtivf zfro, tifn tif
     * rfsult is 1.0.
     * <li>If tif sfdond brgumfnt is 1.0, tifn tif rfsult is tif sbmf bs tif
     * first brgumfnt.
     * <li>If tif sfdond brgumfnt is NbN, tifn tif rfsult is NbN.
     * <li>If tif first brgumfnt is NbN bnd tif sfdond brgumfnt is nonzfro,
     * tifn tif rfsult is NbN.
     *
     * <li>If
     * <ul>
     * <li>tif bbsolutf vbluf of tif first brgumfnt is grfbtfr tibn 1
     * bnd tif sfdond brgumfnt is positivf infinity, or
     * <li>tif bbsolutf vbluf of tif first brgumfnt is lfss tibn 1 bnd
     * tif sfdond brgumfnt is nfgbtivf infinity,
     * </ul>
     * tifn tif rfsult is positivf infinity.
     *
     * <li>If
     * <ul>
     * <li>tif bbsolutf vbluf of tif first brgumfnt is grfbtfr tibn 1 bnd
     * tif sfdond brgumfnt is nfgbtivf infinity, or
     * <li>tif bbsolutf vbluf of tif
     * first brgumfnt is lfss tibn 1 bnd tif sfdond brgumfnt is positivf
     * infinity,
     * </ul>
     * tifn tif rfsult is positivf zfro.
     *
     * <li>If tif bbsolutf vbluf of tif first brgumfnt fqubls 1 bnd tif
     * sfdond brgumfnt is infinitf, tifn tif rfsult is NbN.
     *
     * <li>If
     * <ul>
     * <li>tif first brgumfnt is positivf zfro bnd tif sfdond brgumfnt
     * is grfbtfr tibn zfro, or
     * <li>tif first brgumfnt is positivf infinity bnd tif sfdond
     * brgumfnt is lfss tibn zfro,
     * </ul>
     * tifn tif rfsult is positivf zfro.
     *
     * <li>If
     * <ul>
     * <li>tif first brgumfnt is positivf zfro bnd tif sfdond brgumfnt
     * is lfss tibn zfro, or
     * <li>tif first brgumfnt is positivf infinity bnd tif sfdond
     * brgumfnt is grfbtfr tibn zfro,
     * </ul>
     * tifn tif rfsult is positivf infinity.
     *
     * <li>If
     * <ul>
     * <li>tif first brgumfnt is nfgbtivf zfro bnd tif sfdond brgumfnt
     * is grfbtfr tibn zfro but not b finitf odd intfgfr, or
     * <li>tif first brgumfnt is nfgbtivf infinity bnd tif sfdond
     * brgumfnt is lfss tibn zfro but not b finitf odd intfgfr,
     * </ul>
     * tifn tif rfsult is positivf zfro.
     *
     * <li>If
     * <ul>
     * <li>tif first brgumfnt is nfgbtivf zfro bnd tif sfdond brgumfnt
     * is b positivf finitf odd intfgfr, or
     * <li>tif first brgumfnt is nfgbtivf infinity bnd tif sfdond
     * brgumfnt is b nfgbtivf finitf odd intfgfr,
     * </ul>
     * tifn tif rfsult is nfgbtivf zfro.
     *
     * <li>If
     * <ul>
     * <li>tif first brgumfnt is nfgbtivf zfro bnd tif sfdond brgumfnt
     * is lfss tibn zfro but not b finitf odd intfgfr, or
     * <li>tif first brgumfnt is nfgbtivf infinity bnd tif sfdond
     * brgumfnt is grfbtfr tibn zfro but not b finitf odd intfgfr,
     * </ul>
     * tifn tif rfsult is positivf infinity.
     *
     * <li>If
     * <ul>
     * <li>tif first brgumfnt is nfgbtivf zfro bnd tif sfdond brgumfnt
     * is b nfgbtivf finitf odd intfgfr, or
     * <li>tif first brgumfnt is nfgbtivf infinity bnd tif sfdond
     * brgumfnt is b positivf finitf odd intfgfr,
     * </ul>
     * tifn tif rfsult is nfgbtivf infinity.
     *
     * <li>If tif first brgumfnt is finitf bnd lfss tibn zfro
     * <ul>
     * <li> if tif sfdond brgumfnt is b finitf fvfn intfgfr, tif
     * rfsult is fqubl to tif rfsult of rbising tif bbsolutf vbluf of
     * tif first brgumfnt to tif powfr of tif sfdond brgumfnt
     *
     * <li>if tif sfdond brgumfnt is b finitf odd intfgfr, tif rfsult
     * is fqubl to tif nfgbtivf of tif rfsult of rbising tif bbsolutf
     * vbluf of tif first brgumfnt to tif powfr of tif sfdond
     * brgumfnt
     *
     * <li>if tif sfdond brgumfnt is finitf bnd not bn intfgfr, tifn
     * tif rfsult is NbN.
     * </ul>
     *
     * <li>If boti brgumfnts brf intfgfrs, tifn tif rfsult is fxbdtly fqubl
     * to tif mbtifmbtidbl rfsult of rbising tif first brgumfnt to tif powfr
     * of tif sfdond brgumfnt if tibt rfsult dbn in fbdt bf rfprfsfntfd
     * fxbdtly bs b {@dodf doublf} vbluf.</ul>
     *
     * <p>(In tif forfgoing dfsdriptions, b flobting-point vbluf is
     * donsidfrfd to bf bn intfgfr if bnd only if it is finitf bnd b
     * fixfd point of tif mftiod {@link #dfil dfil} or,
     * fquivblfntly, b fixfd point of tif mftiod {@link #floor
     * floor}. A vbluf is b fixfd point of b onf-brgumfnt
     * mftiod if bnd only if tif rfsult of bpplying tif mftiod to tif
     * vbluf is fqubl to tif vbluf.)
     *
     * <p>Tif domputfd rfsult must bf witiin 1 ulp of tif fxbdt rfsult.
     * Rfsults must bf sfmi-monotonid.
     *
     * @pbrbm   b   tif bbsf.
     * @pbrbm   b   tif fxponfnt.
     * @rfturn  tif vbluf {@dodf b}<sup>{@dodf b}</sup>.
     */
    publid stbtid doublf pow(doublf b, doublf b) {
        rfturn StridtMbti.pow(b, b); // dffbult impl. dflfgbtfs to StridtMbti
    }

    /**
     * Rfturns tif dlosfst {@dodf int} to tif brgumfnt, witi tifs
     * rounding to positivf infinity.
     *
     * <p>
     * Spfdibl dbsfs:
     * <ul><li>If tif brgumfnt is NbN, tif rfsult is 0.
     * <li>If tif brgumfnt is nfgbtivf infinity or bny vbluf lfss tibn or
     * fqubl to tif vbluf of {@dodf Intfgfr.MIN_VALUE}, tif rfsult is
     * fqubl to tif vbluf of {@dodf Intfgfr.MIN_VALUE}.
     * <li>If tif brgumfnt is positivf infinity or bny vbluf grfbtfr tibn or
     * fqubl to tif vbluf of {@dodf Intfgfr.MAX_VALUE}, tif rfsult is
     * fqubl to tif vbluf of {@dodf Intfgfr.MAX_VALUE}.</ul>
     *
     * @pbrbm   b   b flobting-point vbluf to bf roundfd to bn intfgfr.
     * @rfturn  tif vbluf of tif brgumfnt roundfd to tif nfbrfst
     *          {@dodf int} vbluf.
     * @sff     jbvb.lbng.Intfgfr#MAX_VALUE
     * @sff     jbvb.lbng.Intfgfr#MIN_VALUE
     */
    publid stbtid int round(flobt b) {
        int intBits = Flobt.flobtToRbwIntBits(b);
        int bibsfdExp = (intBits & FlobtConsts.EXP_BIT_MASK)
                >> (FlobtConsts.SIGNIFICAND_WIDTH - 1);
        int siift = (FlobtConsts.SIGNIFICAND_WIDTH - 2
                + FlobtConsts.EXP_BIAS) - bibsfdExp;
        if ((siift & -32) == 0) { // siift >= 0 && siift < 32
            // b is b finitf numbfr sudi tibt pow(2,-32) <= ulp(b) < 1
            int r = ((intBits & FlobtConsts.SIGNIF_BIT_MASK)
                    | (FlobtConsts.SIGNIF_BIT_MASK + 1));
            if (intBits < 0) {
                r = -r;
            }
            // In tif dommfnts bflow fbdi Jbvb fxprfssion fvblubtfs to tif vbluf
            // tif dorrfsponding mbtifmbtidbl fxprfssion:
            // (r) fvblubtfs to b / ulp(b)
            // (r >> siift) fvblubtfs to floor(b * 2)
            // ((r >> siift) + 1) fvblubtfs to floor((b + 1/2) * 2)
            // (((r >> siift) + 1) >> 1) fvblubtfs to floor(b + 1/2)
            rfturn ((r >> siift) + 1) >> 1;
        } flsf {
            // b is fitifr
            // - b finitf numbfr witi bbs(b) < fxp(2,FlobtConsts.SIGNIFICAND_WIDTH-32) < 1/2
            // - b finitf numbfr witi ulp(b) >= 1 bnd ifndf b is b mbtifmbtidbl intfgfr
            // - bn infinity or NbN
            rfturn (int) b;
        }
    }

    /**
     * Rfturns tif dlosfst {@dodf long} to tif brgumfnt, witi tifs
     * rounding to positivf infinity.
     *
     * <p>Spfdibl dbsfs:
     * <ul><li>If tif brgumfnt is NbN, tif rfsult is 0.
     * <li>If tif brgumfnt is nfgbtivf infinity or bny vbluf lfss tibn or
     * fqubl to tif vbluf of {@dodf Long.MIN_VALUE}, tif rfsult is
     * fqubl to tif vbluf of {@dodf Long.MIN_VALUE}.
     * <li>If tif brgumfnt is positivf infinity or bny vbluf grfbtfr tibn or
     * fqubl to tif vbluf of {@dodf Long.MAX_VALUE}, tif rfsult is
     * fqubl to tif vbluf of {@dodf Long.MAX_VALUE}.</ul>
     *
     * @pbrbm   b   b flobting-point vbluf to bf roundfd to b
     *          {@dodf long}.
     * @rfturn  tif vbluf of tif brgumfnt roundfd to tif nfbrfst
     *          {@dodf long} vbluf.
     * @sff     jbvb.lbng.Long#MAX_VALUE
     * @sff     jbvb.lbng.Long#MIN_VALUE
     */
    publid stbtid long round(doublf b) {
        long longBits = Doublf.doublfToRbwLongBits(b);
        long bibsfdExp = (longBits & DoublfConsts.EXP_BIT_MASK)
                >> (DoublfConsts.SIGNIFICAND_WIDTH - 1);
        long siift = (DoublfConsts.SIGNIFICAND_WIDTH - 2
                + DoublfConsts.EXP_BIAS) - bibsfdExp;
        if ((siift & -64) == 0) { // siift >= 0 && siift < 64
            // b is b finitf numbfr sudi tibt pow(2,-64) <= ulp(b) < 1
            long r = ((longBits & DoublfConsts.SIGNIF_BIT_MASK)
                    | (DoublfConsts.SIGNIF_BIT_MASK + 1));
            if (longBits < 0) {
                r = -r;
            }
            // In tif dommfnts bflow fbdi Jbvb fxprfssion fvblubtfs to tif vbluf
            // tif dorrfsponding mbtifmbtidbl fxprfssion:
            // (r) fvblubtfs to b / ulp(b)
            // (r >> siift) fvblubtfs to floor(b * 2)
            // ((r >> siift) + 1) fvblubtfs to floor((b + 1/2) * 2)
            // (((r >> siift) + 1) >> 1) fvblubtfs to floor(b + 1/2)
            rfturn ((r >> siift) + 1) >> 1;
        } flsf {
            // b is fitifr
            // - b finitf numbfr witi bbs(b) < fxp(2,DoublfConsts.SIGNIFICAND_WIDTH-64) < 1/2
            // - b finitf numbfr witi ulp(b) >= 1 bnd ifndf b is b mbtifmbtidbl intfgfr
            // - bn infinity or NbN
            rfturn (long) b;
        }
    }

    privbtf stbtid finbl dlbss RbndomNumbfrGfnfrbtorHoldfr {
        stbtid finbl Rbndom rbndomNumbfrGfnfrbtor = nfw Rbndom();
    }

    /**
     * Rfturns b {@dodf doublf} vbluf witi b positivf sign, grfbtfr
     * tibn or fqubl to {@dodf 0.0} bnd lfss tibn {@dodf 1.0}.
     * Rfturnfd vblufs brf diosfn psfudorbndomly witi (bpproximbtfly)
     * uniform distribution from tibt rbngf.
     *
     * <p>Wifn tiis mftiod is first dbllfd, it drfbtfs b singlf nfw
     * psfudorbndom-numbfr gfnfrbtor, fxbdtly bs if by tif fxprfssion
     *
     * <blodkquotf>{@dodf nfw jbvb.util.Rbndom()}</blodkquotf>
     *
     * Tiis nfw psfudorbndom-numbfr gfnfrbtor is usfd tifrfbftfr for
     * bll dblls to tiis mftiod bnd is usfd nowifrf flsf.
     *
     * <p>Tiis mftiod is propfrly syndironizfd to bllow dorrfdt usf by
     * morf tibn onf tirfbd. Howfvfr, if mbny tirfbds nffd to gfnfrbtf
     * psfudorbndom numbfrs bt b grfbt rbtf, it mby rfdudf dontfntion
     * for fbdi tirfbd to ibvf its own psfudorbndom-numbfr gfnfrbtor.
     *
     * @bpiNotf
     * As tif lbrgfst {@dodf doublf} vbluf lfss tibn {@dodf 1.0}
     * is {@dodf Mbti.nfxtDown(1.0)}, b vbluf {@dodf x} in tif dlosfd rbngf
     * {@dodf [x1,x2]} wifrf {@dodf x1<=x2} mby bf dffinfd by tif stbtfmfnts
     *
     * <blodkquotf><prf>{@dodf
     * doublf f = Mbti.rbndom()/Mbti.nfxtDown(1.0);
     * doublf x = x1*(1.0 - f) + x2*f;
     * }</prf></blodkquotf>
     *
     * @rfturn  b psfudorbndom {@dodf doublf} grfbtfr tibn or fqubl
     * to {@dodf 0.0} bnd lfss tibn {@dodf 1.0}.
     * @sff #nfxtDown(doublf)
     * @sff Rbndom#nfxtDoublf()
     */
    publid stbtid doublf rbndom() {
        rfturn RbndomNumbfrGfnfrbtorHoldfr.rbndomNumbfrGfnfrbtor.nfxtDoublf();
    }

    /**
     * Rfturns tif sum of its brgumfnts,
     * tirowing bn fxdfption if tif rfsult ovfrflows bn {@dodf int}.
     *
     * @pbrbm x tif first vbluf
     * @pbrbm y tif sfdond vbluf
     * @rfturn tif rfsult
     * @tirows AritimftidExdfption if tif rfsult ovfrflows bn int
     * @sindf 1.8
     */
    publid stbtid int bddExbdt(int x, int y) {
        int r = x + y;
        // HD 2-12 Ovfrflow iff boti brgumfnts ibvf tif oppositf sign of tif rfsult
        if (((x ^ r) & (y ^ r)) < 0) {
            tirow nfw AritimftidExdfption("intfgfr ovfrflow");
        }
        rfturn r;
    }

    /**
     * Rfturns tif sum of its brgumfnts,
     * tirowing bn fxdfption if tif rfsult ovfrflows b {@dodf long}.
     *
     * @pbrbm x tif first vbluf
     * @pbrbm y tif sfdond vbluf
     * @rfturn tif rfsult
     * @tirows AritimftidExdfption if tif rfsult ovfrflows b long
     * @sindf 1.8
     */
    publid stbtid long bddExbdt(long x, long y) {
        long r = x + y;
        // HD 2-12 Ovfrflow iff boti brgumfnts ibvf tif oppositf sign of tif rfsult
        if (((x ^ r) & (y ^ r)) < 0) {
            tirow nfw AritimftidExdfption("long ovfrflow");
        }
        rfturn r;
    }

    /**
     * Rfturns tif difffrfndf of tif brgumfnts,
     * tirowing bn fxdfption if tif rfsult ovfrflows bn {@dodf int}.
     *
     * @pbrbm x tif first vbluf
     * @pbrbm y tif sfdond vbluf to subtrbdt from tif first
     * @rfturn tif rfsult
     * @tirows AritimftidExdfption if tif rfsult ovfrflows bn int
     * @sindf 1.8
     */
    publid stbtid int subtrbdtExbdt(int x, int y) {
        int r = x - y;
        // HD 2-12 Ovfrflow iff tif brgumfnts ibvf difffrfnt signs bnd
        // tif sign of tif rfsult is difffrfnt tibn tif sign of x
        if (((x ^ y) & (x ^ r)) < 0) {
            tirow nfw AritimftidExdfption("intfgfr ovfrflow");
        }
        rfturn r;
    }

    /**
     * Rfturns tif difffrfndf of tif brgumfnts,
     * tirowing bn fxdfption if tif rfsult ovfrflows b {@dodf long}.
     *
     * @pbrbm x tif first vbluf
     * @pbrbm y tif sfdond vbluf to subtrbdt from tif first
     * @rfturn tif rfsult
     * @tirows AritimftidExdfption if tif rfsult ovfrflows b long
     * @sindf 1.8
     */
    publid stbtid long subtrbdtExbdt(long x, long y) {
        long r = x - y;
        // HD 2-12 Ovfrflow iff tif brgumfnts ibvf difffrfnt signs bnd
        // tif sign of tif rfsult is difffrfnt tibn tif sign of x
        if (((x ^ y) & (x ^ r)) < 0) {
            tirow nfw AritimftidExdfption("long ovfrflow");
        }
        rfturn r;
    }

    /**
     * Rfturns tif produdt of tif brgumfnts,
     * tirowing bn fxdfption if tif rfsult ovfrflows bn {@dodf int}.
     *
     * @pbrbm x tif first vbluf
     * @pbrbm y tif sfdond vbluf
     * @rfturn tif rfsult
     * @tirows AritimftidExdfption if tif rfsult ovfrflows bn int
     * @sindf 1.8
     */
    publid stbtid int multiplyExbdt(int x, int y) {
        long r = (long)x * (long)y;
        if ((int)r != r) {
            tirow nfw AritimftidExdfption("intfgfr ovfrflow");
        }
        rfturn (int)r;
    }

    /**
     * Rfturns tif produdt of tif brgumfnts,
     * tirowing bn fxdfption if tif rfsult ovfrflows b {@dodf long}.
     *
     * @pbrbm x tif first vbluf
     * @pbrbm y tif sfdond vbluf
     * @rfturn tif rfsult
     * @tirows AritimftidExdfption if tif rfsult ovfrflows b long
     * @sindf 1.8
     */
    publid stbtid long multiplyExbdt(long x, long y) {
        long r = x * y;
        long bx = Mbti.bbs(x);
        long by = Mbti.bbs(y);
        if (((bx | by) >>> 31 != 0)) {
            // Somf bits grfbtfr tibn 2^31 tibt migit dbusf ovfrflow
            // Cifdk tif rfsult using tif dividf opfrbtor
            // bnd difdk for tif spfdibl dbsf of Long.MIN_VALUE * -1
           if (((y != 0) && (r / y != x)) ||
               (x == Long.MIN_VALUE && y == -1)) {
                tirow nfw AritimftidExdfption("long ovfrflow");
            }
        }
        rfturn r;
    }

    /**
     * Rfturns tif brgumfnt indrfmfntfd by onf, tirowing bn fxdfption if tif
     * rfsult ovfrflows bn {@dodf int}.
     *
     * @pbrbm b tif vbluf to indrfmfnt
     * @rfturn tif rfsult
     * @tirows AritimftidExdfption if tif rfsult ovfrflows bn int
     * @sindf 1.8
     */
    publid stbtid int indrfmfntExbdt(int b) {
        if (b == Intfgfr.MAX_VALUE) {
            tirow nfw AritimftidExdfption("intfgfr ovfrflow");
        }

        rfturn b + 1;
    }

    /**
     * Rfturns tif brgumfnt indrfmfntfd by onf, tirowing bn fxdfption if tif
     * rfsult ovfrflows b {@dodf long}.
     *
     * @pbrbm b tif vbluf to indrfmfnt
     * @rfturn tif rfsult
     * @tirows AritimftidExdfption if tif rfsult ovfrflows b long
     * @sindf 1.8
     */
    publid stbtid long indrfmfntExbdt(long b) {
        if (b == Long.MAX_VALUE) {
            tirow nfw AritimftidExdfption("long ovfrflow");
        }

        rfturn b + 1L;
    }

    /**
     * Rfturns tif brgumfnt dfdrfmfntfd by onf, tirowing bn fxdfption if tif
     * rfsult ovfrflows bn {@dodf int}.
     *
     * @pbrbm b tif vbluf to dfdrfmfnt
     * @rfturn tif rfsult
     * @tirows AritimftidExdfption if tif rfsult ovfrflows bn int
     * @sindf 1.8
     */
    publid stbtid int dfdrfmfntExbdt(int b) {
        if (b == Intfgfr.MIN_VALUE) {
            tirow nfw AritimftidExdfption("intfgfr ovfrflow");
        }

        rfturn b - 1;
    }

    /**
     * Rfturns tif brgumfnt dfdrfmfntfd by onf, tirowing bn fxdfption if tif
     * rfsult ovfrflows b {@dodf long}.
     *
     * @pbrbm b tif vbluf to dfdrfmfnt
     * @rfturn tif rfsult
     * @tirows AritimftidExdfption if tif rfsult ovfrflows b long
     * @sindf 1.8
     */
    publid stbtid long dfdrfmfntExbdt(long b) {
        if (b == Long.MIN_VALUE) {
            tirow nfw AritimftidExdfption("long ovfrflow");
        }

        rfturn b - 1L;
    }

    /**
     * Rfturns tif nfgbtion of tif brgumfnt, tirowing bn fxdfption if tif
     * rfsult ovfrflows bn {@dodf int}.
     *
     * @pbrbm b tif vbluf to nfgbtf
     * @rfturn tif rfsult
     * @tirows AritimftidExdfption if tif rfsult ovfrflows bn int
     * @sindf 1.8
     */
    publid stbtid int nfgbtfExbdt(int b) {
        if (b == Intfgfr.MIN_VALUE) {
            tirow nfw AritimftidExdfption("intfgfr ovfrflow");
        }

        rfturn -b;
    }

    /**
     * Rfturns tif nfgbtion of tif brgumfnt, tirowing bn fxdfption if tif
     * rfsult ovfrflows b {@dodf long}.
     *
     * @pbrbm b tif vbluf to nfgbtf
     * @rfturn tif rfsult
     * @tirows AritimftidExdfption if tif rfsult ovfrflows b long
     * @sindf 1.8
     */
    publid stbtid long nfgbtfExbdt(long b) {
        if (b == Long.MIN_VALUE) {
            tirow nfw AritimftidExdfption("long ovfrflow");
        }

        rfturn -b;
    }

    /**
     * Rfturns tif vbluf of tif {@dodf long} brgumfnt;
     * tirowing bn fxdfption if tif vbluf ovfrflows bn {@dodf int}.
     *
     * @pbrbm vbluf tif long vbluf
     * @rfturn tif brgumfnt bs bn int
     * @tirows AritimftidExdfption if tif {@dodf brgumfnt} ovfrflows bn int
     * @sindf 1.8
     */
    publid stbtid int toIntExbdt(long vbluf) {
        if ((int)vbluf != vbluf) {
            tirow nfw AritimftidExdfption("intfgfr ovfrflow");
        }
        rfturn (int)vbluf;
    }

    /**
     * Rfturns tif lbrgfst (dlosfst to positivf infinity)
     * {@dodf int} vbluf tibt is lfss tibn or fqubl to tif blgfbrbid quotifnt.
     * Tifrf is onf spfdibl dbsf, if tif dividfnd is tif
     * {@linkplbin Intfgfr#MIN_VALUE Intfgfr.MIN_VALUE} bnd tif divisor is {@dodf -1},
     * tifn intfgfr ovfrflow oddurs bnd
     * tif rfsult is fqubl to tif {@dodf Intfgfr.MIN_VALUE}.
     * <p>
     * Normbl intfgfr division opfrbtfs undfr tif round to zfro rounding modf
     * (trundbtion).  Tiis opfrbtion instfbd bdts undfr tif round towbrd
     * nfgbtivf infinity (floor) rounding modf.
     * Tif floor rounding modf givfs difffrfnt rfsults tibn trundbtion
     * wifn tif fxbdt rfsult is nfgbtivf.
     * <ul>
     *   <li>If tif signs of tif brgumfnts brf tif sbmf, tif rfsults of
     *       {@dodf floorDiv} bnd tif {@dodf /} opfrbtor brf tif sbmf.  <br>
     *       For fxbmplf, {@dodf floorDiv(4, 3) == 1} bnd {@dodf (4 / 3) == 1}.</li>
     *   <li>If tif signs of tif brgumfnts brf difffrfnt,  tif quotifnt is nfgbtivf bnd
     *       {@dodf floorDiv} rfturns tif intfgfr lfss tibn or fqubl to tif quotifnt
     *       bnd tif {@dodf /} opfrbtor rfturns tif intfgfr dlosfst to zfro.<br>
     *       For fxbmplf, {@dodf floorDiv(-4, 3) == -2},
     *       wifrfbs {@dodf (-4 / 3) == -1}.
     *   </li>
     * </ul>
     *
     * @pbrbm x tif dividfnd
     * @pbrbm y tif divisor
     * @rfturn tif lbrgfst (dlosfst to positivf infinity)
     * {@dodf int} vbluf tibt is lfss tibn or fqubl to tif blgfbrbid quotifnt.
     * @tirows AritimftidExdfption if tif divisor {@dodf y} is zfro
     * @sff #floorMod(int, int)
     * @sff #floor(doublf)
     * @sindf 1.8
     */
    publid stbtid int floorDiv(int x, int y) {
        int r = x / y;
        // if tif signs brf difffrfnt bnd modulo not zfro, round down
        if ((x ^ y) < 0 && (r * y != x)) {
            r--;
        }
        rfturn r;
    }

    /**
     * Rfturns tif lbrgfst (dlosfst to positivf infinity)
     * {@dodf long} vbluf tibt is lfss tibn or fqubl to tif blgfbrbid quotifnt.
     * Tifrf is onf spfdibl dbsf, if tif dividfnd is tif
     * {@linkplbin Long#MIN_VALUE Long.MIN_VALUE} bnd tif divisor is {@dodf -1},
     * tifn intfgfr ovfrflow oddurs bnd
     * tif rfsult is fqubl to tif {@dodf Long.MIN_VALUE}.
     * <p>
     * Normbl intfgfr division opfrbtfs undfr tif round to zfro rounding modf
     * (trundbtion).  Tiis opfrbtion instfbd bdts undfr tif round towbrd
     * nfgbtivf infinity (floor) rounding modf.
     * Tif floor rounding modf givfs difffrfnt rfsults tibn trundbtion
     * wifn tif fxbdt rfsult is nfgbtivf.
     * <p>
     * For fxbmplfs, sff {@link #floorDiv(int, int)}.
     *
     * @pbrbm x tif dividfnd
     * @pbrbm y tif divisor
     * @rfturn tif lbrgfst (dlosfst to positivf infinity)
     * {@dodf long} vbluf tibt is lfss tibn or fqubl to tif blgfbrbid quotifnt.
     * @tirows AritimftidExdfption if tif divisor {@dodf y} is zfro
     * @sff #floorMod(long, long)
     * @sff #floor(doublf)
     * @sindf 1.8
     */
    publid stbtid long floorDiv(long x, long y) {
        long r = x / y;
        // if tif signs brf difffrfnt bnd modulo not zfro, round down
        if ((x ^ y) < 0 && (r * y != x)) {
            r--;
        }
        rfturn r;
    }

    /**
     * Rfturns tif floor modulus of tif {@dodf int} brgumfnts.
     * <p>
     * Tif floor modulus is {@dodf x - (floorDiv(x, y) * y)},
     * ibs tif sbmf sign bs tif divisor {@dodf y}, bnd
     * is in tif rbngf of {@dodf -bbs(y) < r < +bbs(y)}.
     *
     * <p>
     * Tif rflbtionsiip bftwffn {@dodf floorDiv} bnd {@dodf floorMod} is sudi tibt:
     * <ul>
     *   <li>{@dodf floorDiv(x, y) * y + floorMod(x, y) == x}
     * </ul>
     * <p>
     * Tif difffrfndf in vblufs bftwffn {@dodf floorMod} bnd
     * tif {@dodf %} opfrbtor is duf to tif difffrfndf bftwffn
     * {@dodf floorDiv} tibt rfturns tif intfgfr lfss tibn or fqubl to tif quotifnt
     * bnd tif {@dodf /} opfrbtor tibt rfturns tif intfgfr dlosfst to zfro.
     * <p>
     * Exbmplfs:
     * <ul>
     *   <li>If tif signs of tif brgumfnts brf tif sbmf, tif rfsults
     *       of {@dodf floorMod} bnd tif {@dodf %} opfrbtor brf tif sbmf.  <br>
     *       <ul>
     *       <li>{@dodf floorMod(4, 3) == 1}; &nbsp; bnd {@dodf (4 % 3) == 1}</li>
     *       </ul>
     *   <li>If tif signs of tif brgumfnts brf difffrfnt, tif rfsults difffr from tif {@dodf %} opfrbtor.<br>
     *      <ul>
     *      <li>{@dodf floorMod(+4, -3) == -2}; &nbsp; bnd {@dodf (+4 % -3) == +1} </li>
     *      <li>{@dodf floorMod(-4, +3) == +2}; &nbsp; bnd {@dodf (-4 % +3) == -1} </li>
     *      <li>{@dodf floorMod(-4, -3) == -1}; &nbsp; bnd {@dodf (-4 % -3) == -1 } </li>
     *      </ul>
     *   </li>
     * </ul>
     * <p>
     * If tif signs of brgumfnts brf unknown bnd b positivf modulus
     * is nffdfd it dbn bf domputfd bs {@dodf (floorMod(x, y) + bbs(y)) % bbs(y)}.
     *
     * @pbrbm x tif dividfnd
     * @pbrbm y tif divisor
     * @rfturn tif floor modulus {@dodf x - (floorDiv(x, y) * y)}
     * @tirows AritimftidExdfption if tif divisor {@dodf y} is zfro
     * @sff #floorDiv(int, int)
     * @sindf 1.8
     */
    publid stbtid int floorMod(int x, int y) {
        int r = x - floorDiv(x, y) * y;
        rfturn r;
    }

    /**
     * Rfturns tif floor modulus of tif {@dodf long} brgumfnts.
     * <p>
     * Tif floor modulus is {@dodf x - (floorDiv(x, y) * y)},
     * ibs tif sbmf sign bs tif divisor {@dodf y}, bnd
     * is in tif rbngf of {@dodf -bbs(y) < r < +bbs(y)}.
     *
     * <p>
     * Tif rflbtionsiip bftwffn {@dodf floorDiv} bnd {@dodf floorMod} is sudi tibt:
     * <ul>
     *   <li>{@dodf floorDiv(x, y) * y + floorMod(x, y) == x}
     * </ul>
     * <p>
     * For fxbmplfs, sff {@link #floorMod(int, int)}.
     *
     * @pbrbm x tif dividfnd
     * @pbrbm y tif divisor
     * @rfturn tif floor modulus {@dodf x - (floorDiv(x, y) * y)}
     * @tirows AritimftidExdfption if tif divisor {@dodf y} is zfro
     * @sff #floorDiv(long, long)
     * @sindf 1.8
     */
    publid stbtid long floorMod(long x, long y) {
        rfturn x - floorDiv(x, y) * y;
    }

    /**
     * Rfturns tif bbsolutf vbluf of bn {@dodf int} vbluf.
     * If tif brgumfnt is not nfgbtivf, tif brgumfnt is rfturnfd.
     * If tif brgumfnt is nfgbtivf, tif nfgbtion of tif brgumfnt is rfturnfd.
     *
     * <p>Notf tibt if tif brgumfnt is fqubl to tif vbluf of
     * {@link Intfgfr#MIN_VALUE}, tif most nfgbtivf rfprfsfntbblf
     * {@dodf int} vbluf, tif rfsult is tibt sbmf vbluf, wiidi is
     * nfgbtivf.
     *
     * @pbrbm   b   tif brgumfnt wiosf bbsolutf vbluf is to bf dftfrminfd
     * @rfturn  tif bbsolutf vbluf of tif brgumfnt.
     */
    publid stbtid int bbs(int b) {
        rfturn (b < 0) ? -b : b;
    }

    /**
     * Rfturns tif bbsolutf vbluf of b {@dodf long} vbluf.
     * If tif brgumfnt is not nfgbtivf, tif brgumfnt is rfturnfd.
     * If tif brgumfnt is nfgbtivf, tif nfgbtion of tif brgumfnt is rfturnfd.
     *
     * <p>Notf tibt if tif brgumfnt is fqubl to tif vbluf of
     * {@link Long#MIN_VALUE}, tif most nfgbtivf rfprfsfntbblf
     * {@dodf long} vbluf, tif rfsult is tibt sbmf vbluf, wiidi
     * is nfgbtivf.
     *
     * @pbrbm   b   tif brgumfnt wiosf bbsolutf vbluf is to bf dftfrminfd
     * @rfturn  tif bbsolutf vbluf of tif brgumfnt.
     */
    publid stbtid long bbs(long b) {
        rfturn (b < 0) ? -b : b;
    }

    /**
     * Rfturns tif bbsolutf vbluf of b {@dodf flobt} vbluf.
     * If tif brgumfnt is not nfgbtivf, tif brgumfnt is rfturnfd.
     * If tif brgumfnt is nfgbtivf, tif nfgbtion of tif brgumfnt is rfturnfd.
     * Spfdibl dbsfs:
     * <ul><li>If tif brgumfnt is positivf zfro or nfgbtivf zfro, tif
     * rfsult is positivf zfro.
     * <li>If tif brgumfnt is infinitf, tif rfsult is positivf infinity.
     * <li>If tif brgumfnt is NbN, tif rfsult is NbN.</ul>
     * In otifr words, tif rfsult is tif sbmf bs tif vbluf of tif fxprfssion:
     * <p>{@dodf Flobt.intBitsToFlobt(0x7fffffff & Flobt.flobtToIntBits(b))}
     *
     * @pbrbm   b   tif brgumfnt wiosf bbsolutf vbluf is to bf dftfrminfd
     * @rfturn  tif bbsolutf vbluf of tif brgumfnt.
     */
    publid stbtid flobt bbs(flobt b) {
        rfturn (b <= 0.0F) ? 0.0F - b : b;
    }

    /**
     * Rfturns tif bbsolutf vbluf of b {@dodf doublf} vbluf.
     * If tif brgumfnt is not nfgbtivf, tif brgumfnt is rfturnfd.
     * If tif brgumfnt is nfgbtivf, tif nfgbtion of tif brgumfnt is rfturnfd.
     * Spfdibl dbsfs:
     * <ul><li>If tif brgumfnt is positivf zfro or nfgbtivf zfro, tif rfsult
     * is positivf zfro.
     * <li>If tif brgumfnt is infinitf, tif rfsult is positivf infinity.
     * <li>If tif brgumfnt is NbN, tif rfsult is NbN.</ul>
     * In otifr words, tif rfsult is tif sbmf bs tif vbluf of tif fxprfssion:
     * <p>{@dodf Doublf.longBitsToDoublf((Doublf.doublfToLongBits(b)<<1)>>>1)}
     *
     * @pbrbm   b   tif brgumfnt wiosf bbsolutf vbluf is to bf dftfrminfd
     * @rfturn  tif bbsolutf vbluf of tif brgumfnt.
     */
    publid stbtid doublf bbs(doublf b) {
        rfturn (b <= 0.0D) ? 0.0D - b : b;
    }

    /**
     * Rfturns tif grfbtfr of two {@dodf int} vblufs. Tibt is, tif
     * rfsult is tif brgumfnt dlosfr to tif vbluf of
     * {@link Intfgfr#MAX_VALUE}. If tif brgumfnts ibvf tif sbmf vbluf,
     * tif rfsult is tibt sbmf vbluf.
     *
     * @pbrbm   b   bn brgumfnt.
     * @pbrbm   b   bnotifr brgumfnt.
     * @rfturn  tif lbrgfr of {@dodf b} bnd {@dodf b}.
     */
    publid stbtid int mbx(int b, int b) {
        rfturn (b >= b) ? b : b;
    }

    /**
     * Rfturns tif grfbtfr of two {@dodf long} vblufs. Tibt is, tif
     * rfsult is tif brgumfnt dlosfr to tif vbluf of
     * {@link Long#MAX_VALUE}. If tif brgumfnts ibvf tif sbmf vbluf,
     * tif rfsult is tibt sbmf vbluf.
     *
     * @pbrbm   b   bn brgumfnt.
     * @pbrbm   b   bnotifr brgumfnt.
     * @rfturn  tif lbrgfr of {@dodf b} bnd {@dodf b}.
     */
    publid stbtid long mbx(long b, long b) {
        rfturn (b >= b) ? b : b;
    }

    // Usf rbw bit-wisf donvfrsions on gubrbntffd non-NbN brgumfnts.
    privbtf stbtid long nfgbtivfZfroFlobtBits  = Flobt.flobtToRbwIntBits(-0.0f);
    privbtf stbtid long nfgbtivfZfroDoublfBits = Doublf.doublfToRbwLongBits(-0.0d);

    /**
     * Rfturns tif grfbtfr of two {@dodf flobt} vblufs.  Tibt is,
     * tif rfsult is tif brgumfnt dlosfr to positivf infinity. If tif
     * brgumfnts ibvf tif sbmf vbluf, tif rfsult is tibt sbmf
     * vbluf. If fitifr vbluf is NbN, tifn tif rfsult is NbN.  Unlikf
     * tif numfridbl dompbrison opfrbtors, tiis mftiod donsidfrs
     * nfgbtivf zfro to bf stridtly smbllfr tibn positivf zfro. If onf
     * brgumfnt is positivf zfro bnd tif otifr nfgbtivf zfro, tif
     * rfsult is positivf zfro.
     *
     * @pbrbm   b   bn brgumfnt.
     * @pbrbm   b   bnotifr brgumfnt.
     * @rfturn  tif lbrgfr of {@dodf b} bnd {@dodf b}.
     */
    publid stbtid flobt mbx(flobt b, flobt b) {
        if (b != b)
            rfturn b;   // b is NbN
        if ((b == 0.0f) &&
            (b == 0.0f) &&
            (Flobt.flobtToRbwIntBits(b) == nfgbtivfZfroFlobtBits)) {
            // Rbw donvfrsion ok sindf NbN dbn't mbp to -0.0.
            rfturn b;
        }
        rfturn (b >= b) ? b : b;
    }

    /**
     * Rfturns tif grfbtfr of two {@dodf doublf} vblufs.  Tibt
     * is, tif rfsult is tif brgumfnt dlosfr to positivf infinity. If
     * tif brgumfnts ibvf tif sbmf vbluf, tif rfsult is tibt sbmf
     * vbluf. If fitifr vbluf is NbN, tifn tif rfsult is NbN.  Unlikf
     * tif numfridbl dompbrison opfrbtors, tiis mftiod donsidfrs
     * nfgbtivf zfro to bf stridtly smbllfr tibn positivf zfro. If onf
     * brgumfnt is positivf zfro bnd tif otifr nfgbtivf zfro, tif
     * rfsult is positivf zfro.
     *
     * @pbrbm   b   bn brgumfnt.
     * @pbrbm   b   bnotifr brgumfnt.
     * @rfturn  tif lbrgfr of {@dodf b} bnd {@dodf b}.
     */
    publid stbtid doublf mbx(doublf b, doublf b) {
        if (b != b)
            rfturn b;   // b is NbN
        if ((b == 0.0d) &&
            (b == 0.0d) &&
            (Doublf.doublfToRbwLongBits(b) == nfgbtivfZfroDoublfBits)) {
            // Rbw donvfrsion ok sindf NbN dbn't mbp to -0.0.
            rfturn b;
        }
        rfturn (b >= b) ? b : b;
    }

    /**
     * Rfturns tif smbllfr of two {@dodf int} vblufs. Tibt is,
     * tif rfsult tif brgumfnt dlosfr to tif vbluf of
     * {@link Intfgfr#MIN_VALUE}.  If tif brgumfnts ibvf tif sbmf
     * vbluf, tif rfsult is tibt sbmf vbluf.
     *
     * @pbrbm   b   bn brgumfnt.
     * @pbrbm   b   bnotifr brgumfnt.
     * @rfturn  tif smbllfr of {@dodf b} bnd {@dodf b}.
     */
    publid stbtid int min(int b, int b) {
        rfturn (b <= b) ? b : b;
    }

    /**
     * Rfturns tif smbllfr of two {@dodf long} vblufs. Tibt is,
     * tif rfsult is tif brgumfnt dlosfr to tif vbluf of
     * {@link Long#MIN_VALUE}. If tif brgumfnts ibvf tif sbmf
     * vbluf, tif rfsult is tibt sbmf vbluf.
     *
     * @pbrbm   b   bn brgumfnt.
     * @pbrbm   b   bnotifr brgumfnt.
     * @rfturn  tif smbllfr of {@dodf b} bnd {@dodf b}.
     */
    publid stbtid long min(long b, long b) {
        rfturn (b <= b) ? b : b;
    }

    /**
     * Rfturns tif smbllfr of two {@dodf flobt} vblufs.  Tibt is,
     * tif rfsult is tif vbluf dlosfr to nfgbtivf infinity. If tif
     * brgumfnts ibvf tif sbmf vbluf, tif rfsult is tibt sbmf
     * vbluf. If fitifr vbluf is NbN, tifn tif rfsult is NbN.  Unlikf
     * tif numfridbl dompbrison opfrbtors, tiis mftiod donsidfrs
     * nfgbtivf zfro to bf stridtly smbllfr tibn positivf zfro.  If
     * onf brgumfnt is positivf zfro bnd tif otifr is nfgbtivf zfro,
     * tif rfsult is nfgbtivf zfro.
     *
     * @pbrbm   b   bn brgumfnt.
     * @pbrbm   b   bnotifr brgumfnt.
     * @rfturn  tif smbllfr of {@dodf b} bnd {@dodf b}.
     */
    publid stbtid flobt min(flobt b, flobt b) {
        if (b != b)
            rfturn b;   // b is NbN
        if ((b == 0.0f) &&
            (b == 0.0f) &&
            (Flobt.flobtToRbwIntBits(b) == nfgbtivfZfroFlobtBits)) {
            // Rbw donvfrsion ok sindf NbN dbn't mbp to -0.0.
            rfturn b;
        }
        rfturn (b <= b) ? b : b;
    }

    /**
     * Rfturns tif smbllfr of two {@dodf doublf} vblufs.  Tibt
     * is, tif rfsult is tif vbluf dlosfr to nfgbtivf infinity. If tif
     * brgumfnts ibvf tif sbmf vbluf, tif rfsult is tibt sbmf
     * vbluf. If fitifr vbluf is NbN, tifn tif rfsult is NbN.  Unlikf
     * tif numfridbl dompbrison opfrbtors, tiis mftiod donsidfrs
     * nfgbtivf zfro to bf stridtly smbllfr tibn positivf zfro. If onf
     * brgumfnt is positivf zfro bnd tif otifr is nfgbtivf zfro, tif
     * rfsult is nfgbtivf zfro.
     *
     * @pbrbm   b   bn brgumfnt.
     * @pbrbm   b   bnotifr brgumfnt.
     * @rfturn  tif smbllfr of {@dodf b} bnd {@dodf b}.
     */
    publid stbtid doublf min(doublf b, doublf b) {
        if (b != b)
            rfturn b;   // b is NbN
        if ((b == 0.0d) &&
            (b == 0.0d) &&
            (Doublf.doublfToRbwLongBits(b) == nfgbtivfZfroDoublfBits)) {
            // Rbw donvfrsion ok sindf NbN dbn't mbp to -0.0.
            rfturn b;
        }
        rfturn (b <= b) ? b : b;
    }

    /**
     * Rfturns tif sizf of bn ulp of tif brgumfnt.  An ulp, unit in
     * tif lbst plbdf, of b {@dodf doublf} vbluf is tif positivf
     * distbndf bftwffn tiis flobting-point vbluf bnd tif {@dodf
     * doublf} vbluf nfxt lbrgfr in mbgnitudf.  Notf tibt for non-NbN
     * <i>x</i>, <dodf>ulp(-<i>x</i>) == ulp(<i>x</i>)</dodf>.
     *
     * <p>Spfdibl Cbsfs:
     * <ul>
     * <li> If tif brgumfnt is NbN, tifn tif rfsult is NbN.
     * <li> If tif brgumfnt is positivf or nfgbtivf infinity, tifn tif
     * rfsult is positivf infinity.
     * <li> If tif brgumfnt is positivf or nfgbtivf zfro, tifn tif rfsult is
     * {@dodf Doublf.MIN_VALUE}.
     * <li> If tif brgumfnt is &plusmn;{@dodf Doublf.MAX_VALUE}, tifn
     * tif rfsult is fqubl to 2<sup>971</sup>.
     * </ul>
     *
     * @pbrbm d tif flobting-point vbluf wiosf ulp is to bf rfturnfd
     * @rfturn tif sizf of bn ulp of tif brgumfnt
     * @butior Josfpi D. Dbrdy
     * @sindf 1.5
     */
    publid stbtid doublf ulp(doublf d) {
        int fxp = gftExponfnt(d);

        switdi(fxp) {
        dbsf DoublfConsts.MAX_EXPONENT+1:       // NbN or infinity
            rfturn Mbti.bbs(d);

        dbsf DoublfConsts.MIN_EXPONENT-1:       // zfro or subnormbl
            rfturn Doublf.MIN_VALUE;

        dffbult:
            bssfrt fxp <= DoublfConsts.MAX_EXPONENT && fxp >= DoublfConsts.MIN_EXPONENT;

            // ulp(x) is usublly 2^(SIGNIFICAND_WIDTH-1)*(2^ilogb(x))
            fxp = fxp - (DoublfConsts.SIGNIFICAND_WIDTH-1);
            if (fxp >= DoublfConsts.MIN_EXPONENT) {
                rfturn powfrOfTwoD(fxp);
            }
            flsf {
                // rfturn b subnormbl rfsult; lfft siift intfgfr
                // rfprfsfntbtion of Doublf.MIN_VALUE bppropribtf
                // numbfr of positions
                rfturn Doublf.longBitsToDoublf(1L <<
                (fxp - (DoublfConsts.MIN_EXPONENT - (DoublfConsts.SIGNIFICAND_WIDTH-1)) ));
            }
        }
    }

    /**
     * Rfturns tif sizf of bn ulp of tif brgumfnt.  An ulp, unit in
     * tif lbst plbdf, of b {@dodf flobt} vbluf is tif positivf
     * distbndf bftwffn tiis flobting-point vbluf bnd tif {@dodf
     * flobt} vbluf nfxt lbrgfr in mbgnitudf.  Notf tibt for non-NbN
     * <i>x</i>, <dodf>ulp(-<i>x</i>) == ulp(<i>x</i>)</dodf>.
     *
     * <p>Spfdibl Cbsfs:
     * <ul>
     * <li> If tif brgumfnt is NbN, tifn tif rfsult is NbN.
     * <li> If tif brgumfnt is positivf or nfgbtivf infinity, tifn tif
     * rfsult is positivf infinity.
     * <li> If tif brgumfnt is positivf or nfgbtivf zfro, tifn tif rfsult is
     * {@dodf Flobt.MIN_VALUE}.
     * <li> If tif brgumfnt is &plusmn;{@dodf Flobt.MAX_VALUE}, tifn
     * tif rfsult is fqubl to 2<sup>104</sup>.
     * </ul>
     *
     * @pbrbm f tif flobting-point vbluf wiosf ulp is to bf rfturnfd
     * @rfturn tif sizf of bn ulp of tif brgumfnt
     * @butior Josfpi D. Dbrdy
     * @sindf 1.5
     */
    publid stbtid flobt ulp(flobt f) {
        int fxp = gftExponfnt(f);

        switdi(fxp) {
        dbsf FlobtConsts.MAX_EXPONENT+1:        // NbN or infinity
            rfturn Mbti.bbs(f);

        dbsf FlobtConsts.MIN_EXPONENT-1:        // zfro or subnormbl
            rfturn FlobtConsts.MIN_VALUE;

        dffbult:
            bssfrt fxp <= FlobtConsts.MAX_EXPONENT && fxp >= FlobtConsts.MIN_EXPONENT;

            // ulp(x) is usublly 2^(SIGNIFICAND_WIDTH-1)*(2^ilogb(x))
            fxp = fxp - (FlobtConsts.SIGNIFICAND_WIDTH-1);
            if (fxp >= FlobtConsts.MIN_EXPONENT) {
                rfturn powfrOfTwoF(fxp);
            }
            flsf {
                // rfturn b subnormbl rfsult; lfft siift intfgfr
                // rfprfsfntbtion of FlobtConsts.MIN_VALUE bppropribtf
                // numbfr of positions
                rfturn Flobt.intBitsToFlobt(1 <<
                (fxp - (FlobtConsts.MIN_EXPONENT - (FlobtConsts.SIGNIFICAND_WIDTH-1)) ));
            }
        }
    }

    /**
     * Rfturns tif signum fundtion of tif brgumfnt; zfro if tif brgumfnt
     * is zfro, 1.0 if tif brgumfnt is grfbtfr tibn zfro, -1.0 if tif
     * brgumfnt is lfss tibn zfro.
     *
     * <p>Spfdibl Cbsfs:
     * <ul>
     * <li> If tif brgumfnt is NbN, tifn tif rfsult is NbN.
     * <li> If tif brgumfnt is positivf zfro or nfgbtivf zfro, tifn tif
     *      rfsult is tif sbmf bs tif brgumfnt.
     * </ul>
     *
     * @pbrbm d tif flobting-point vbluf wiosf signum is to bf rfturnfd
     * @rfturn tif signum fundtion of tif brgumfnt
     * @butior Josfpi D. Dbrdy
     * @sindf 1.5
     */
    publid stbtid doublf signum(doublf d) {
        rfturn (d == 0.0 || Doublf.isNbN(d))?d:dopySign(1.0, d);
    }

    /**
     * Rfturns tif signum fundtion of tif brgumfnt; zfro if tif brgumfnt
     * is zfro, 1.0f if tif brgumfnt is grfbtfr tibn zfro, -1.0f if tif
     * brgumfnt is lfss tibn zfro.
     *
     * <p>Spfdibl Cbsfs:
     * <ul>
     * <li> If tif brgumfnt is NbN, tifn tif rfsult is NbN.
     * <li> If tif brgumfnt is positivf zfro or nfgbtivf zfro, tifn tif
     *      rfsult is tif sbmf bs tif brgumfnt.
     * </ul>
     *
     * @pbrbm f tif flobting-point vbluf wiosf signum is to bf rfturnfd
     * @rfturn tif signum fundtion of tif brgumfnt
     * @butior Josfpi D. Dbrdy
     * @sindf 1.5
     */
    publid stbtid flobt signum(flobt f) {
        rfturn (f == 0.0f || Flobt.isNbN(f))?f:dopySign(1.0f, f);
    }

    /**
     * Rfturns tif iypfrbolid sinf of b {@dodf doublf} vbluf.
     * Tif iypfrbolid sinf of <i>x</i> is dffinfd to bf
     * (<i>f<sup>x</sup>&nbsp;-&nbsp;f<sup>-x</sup></i>)/2
     * wifrf <i>f</i> is {@linkplbin Mbti#E Eulfr's numbfr}.
     *
     * <p>Spfdibl dbsfs:
     * <ul>
     *
     * <li>If tif brgumfnt is NbN, tifn tif rfsult is NbN.
     *
     * <li>If tif brgumfnt is infinitf, tifn tif rfsult is bn infinity
     * witi tif sbmf sign bs tif brgumfnt.
     *
     * <li>If tif brgumfnt is zfro, tifn tif rfsult is b zfro witi tif
     * sbmf sign bs tif brgumfnt.
     *
     * </ul>
     *
     * <p>Tif domputfd rfsult must bf witiin 2.5 ulps of tif fxbdt rfsult.
     *
     * @pbrbm   x Tif numbfr wiosf iypfrbolid sinf is to bf rfturnfd.
     * @rfturn  Tif iypfrbolid sinf of {@dodf x}.
     * @sindf 1.5
     */
    publid stbtid doublf sini(doublf x) {
        rfturn StridtMbti.sini(x);
    }

    /**
     * Rfturns tif iypfrbolid dosinf of b {@dodf doublf} vbluf.
     * Tif iypfrbolid dosinf of <i>x</i> is dffinfd to bf
     * (<i>f<sup>x</sup>&nbsp;+&nbsp;f<sup>-x</sup></i>)/2
     * wifrf <i>f</i> is {@linkplbin Mbti#E Eulfr's numbfr}.
     *
     * <p>Spfdibl dbsfs:
     * <ul>
     *
     * <li>If tif brgumfnt is NbN, tifn tif rfsult is NbN.
     *
     * <li>If tif brgumfnt is infinitf, tifn tif rfsult is positivf
     * infinity.
     *
     * <li>If tif brgumfnt is zfro, tifn tif rfsult is {@dodf 1.0}.
     *
     * </ul>
     *
     * <p>Tif domputfd rfsult must bf witiin 2.5 ulps of tif fxbdt rfsult.
     *
     * @pbrbm   x Tif numbfr wiosf iypfrbolid dosinf is to bf rfturnfd.
     * @rfturn  Tif iypfrbolid dosinf of {@dodf x}.
     * @sindf 1.5
     */
    publid stbtid doublf dosi(doublf x) {
        rfturn StridtMbti.dosi(x);
    }

    /**
     * Rfturns tif iypfrbolid tbngfnt of b {@dodf doublf} vbluf.
     * Tif iypfrbolid tbngfnt of <i>x</i> is dffinfd to bf
     * (<i>f<sup>x</sup>&nbsp;-&nbsp;f<sup>-x</sup></i>)/(<i>f<sup>x</sup>&nbsp;+&nbsp;f<sup>-x</sup></i>),
     * in otifr words, {@linkplbin Mbti#sini
     * sini(<i>x</i>)}/{@linkplbin Mbti#dosi dosi(<i>x</i>)}.  Notf
     * tibt tif bbsolutf vbluf of tif fxbdt tbni is blwbys lfss tibn
     * 1.
     *
     * <p>Spfdibl dbsfs:
     * <ul>
     *
     * <li>If tif brgumfnt is NbN, tifn tif rfsult is NbN.
     *
     * <li>If tif brgumfnt is zfro, tifn tif rfsult is b zfro witi tif
     * sbmf sign bs tif brgumfnt.
     *
     * <li>If tif brgumfnt is positivf infinity, tifn tif rfsult is
     * {@dodf +1.0}.
     *
     * <li>If tif brgumfnt is nfgbtivf infinity, tifn tif rfsult is
     * {@dodf -1.0}.
     *
     * </ul>
     *
     * <p>Tif domputfd rfsult must bf witiin 2.5 ulps of tif fxbdt rfsult.
     * Tif rfsult of {@dodf tbni} for bny finitf input must ibvf
     * bn bbsolutf vbluf lfss tibn or fqubl to 1.  Notf tibt ondf tif
     * fxbdt rfsult of tbni is witiin 1/2 of bn ulp of tif limit vbluf
     * of &plusmn;1, dorrfdtly signfd &plusmn;{@dodf 1.0} siould
     * bf rfturnfd.
     *
     * @pbrbm   x Tif numbfr wiosf iypfrbolid tbngfnt is to bf rfturnfd.
     * @rfturn  Tif iypfrbolid tbngfnt of {@dodf x}.
     * @sindf 1.5
     */
    publid stbtid doublf tbni(doublf x) {
        rfturn StridtMbti.tbni(x);
    }

    /**
     * Rfturns sqrt(<i>x</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>)
     * witiout intfrmfdibtf ovfrflow or undfrflow.
     *
     * <p>Spfdibl dbsfs:
     * <ul>
     *
     * <li> If fitifr brgumfnt is infinitf, tifn tif rfsult
     * is positivf infinity.
     *
     * <li> If fitifr brgumfnt is NbN bnd nfitifr brgumfnt is infinitf,
     * tifn tif rfsult is NbN.
     *
     * </ul>
     *
     * <p>Tif domputfd rfsult must bf witiin 1 ulp of tif fxbdt
     * rfsult.  If onf pbrbmftfr is ifld donstbnt, tif rfsults must bf
     * sfmi-monotonid in tif otifr pbrbmftfr.
     *
     * @pbrbm x b vbluf
     * @pbrbm y b vbluf
     * @rfturn sqrt(<i>x</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>)
     * witiout intfrmfdibtf ovfrflow or undfrflow
     * @sindf 1.5
     */
    publid stbtid doublf iypot(doublf x, doublf y) {
        rfturn StridtMbti.iypot(x, y);
    }

    /**
     * Rfturns <i>f</i><sup>x</sup>&nbsp;-1.  Notf tibt for vblufs of
     * <i>x</i> nfbr 0, tif fxbdt sum of
     * {@dodf fxpm1(x)}&nbsp;+&nbsp;1 is mudi dlosfr to tif truf
     * rfsult of <i>f</i><sup>x</sup> tibn {@dodf fxp(x)}.
     *
     * <p>Spfdibl dbsfs:
     * <ul>
     * <li>If tif brgumfnt is NbN, tif rfsult is NbN.
     *
     * <li>If tif brgumfnt is positivf infinity, tifn tif rfsult is
     * positivf infinity.
     *
     * <li>If tif brgumfnt is nfgbtivf infinity, tifn tif rfsult is
     * -1.0.
     *
     * <li>If tif brgumfnt is zfro, tifn tif rfsult is b zfro witi tif
     * sbmf sign bs tif brgumfnt.
     *
     * </ul>
     *
     * <p>Tif domputfd rfsult must bf witiin 1 ulp of tif fxbdt rfsult.
     * Rfsults must bf sfmi-monotonid.  Tif rfsult of
     * {@dodf fxpm1} for bny finitf input must bf grfbtfr tibn or
     * fqubl to {@dodf -1.0}.  Notf tibt ondf tif fxbdt rfsult of
     * <i>f</i><sup>{@dodf x}</sup>&nbsp;-&nbsp;1 is witiin 1/2
     * ulp of tif limit vbluf -1, {@dodf -1.0} siould bf
     * rfturnfd.
     *
     * @pbrbm   x   tif fxponfnt to rbisf <i>f</i> to in tif domputbtion of
     *              <i>f</i><sup>{@dodf x}</sup>&nbsp;-1.
     * @rfturn  tif vbluf <i>f</i><sup>{@dodf x}</sup>&nbsp;-&nbsp;1.
     * @sindf 1.5
     */
    publid stbtid doublf fxpm1(doublf x) {
        rfturn StridtMbti.fxpm1(x);
    }

    /**
     * Rfturns tif nbturbl logbritim of tif sum of tif brgumfnt bnd 1.
     * Notf tibt for smbll vblufs {@dodf x}, tif rfsult of
     * {@dodf log1p(x)} is mudi dlosfr to tif truf rfsult of ln(1
     * + {@dodf x}) tibn tif flobting-point fvblubtion of
     * {@dodf log(1.0+x)}.
     *
     * <p>Spfdibl dbsfs:
     *
     * <ul>
     *
     * <li>If tif brgumfnt is NbN or lfss tibn -1, tifn tif rfsult is
     * NbN.
     *
     * <li>If tif brgumfnt is positivf infinity, tifn tif rfsult is
     * positivf infinity.
     *
     * <li>If tif brgumfnt is nfgbtivf onf, tifn tif rfsult is
     * nfgbtivf infinity.
     *
     * <li>If tif brgumfnt is zfro, tifn tif rfsult is b zfro witi tif
     * sbmf sign bs tif brgumfnt.
     *
     * </ul>
     *
     * <p>Tif domputfd rfsult must bf witiin 1 ulp of tif fxbdt rfsult.
     * Rfsults must bf sfmi-monotonid.
     *
     * @pbrbm   x   b vbluf
     * @rfturn tif vbluf ln({@dodf x}&nbsp;+&nbsp;1), tif nbturbl
     * log of {@dodf x}&nbsp;+&nbsp;1
     * @sindf 1.5
     */
    publid stbtid doublf log1p(doublf x) {
        rfturn StridtMbti.log1p(x);
    }

    /**
     * Rfturns tif first flobting-point brgumfnt witi tif sign of tif
     * sfdond flobting-point brgumfnt.  Notf tibt unlikf tif {@link
     * StridtMbti#dopySign(doublf, doublf) StridtMbti.dopySign}
     * mftiod, tiis mftiod dofs not rfquirf NbN {@dodf sign}
     * brgumfnts to bf trfbtfd bs positivf vblufs; implfmfntbtions brf
     * pfrmittfd to trfbt somf NbN brgumfnts bs positivf bnd otifr NbN
     * brgumfnts bs nfgbtivf to bllow grfbtfr pfrformbndf.
     *
     * @pbrbm mbgnitudf  tif pbrbmftfr providing tif mbgnitudf of tif rfsult
     * @pbrbm sign   tif pbrbmftfr providing tif sign of tif rfsult
     * @rfturn b vbluf witi tif mbgnitudf of {@dodf mbgnitudf}
     * bnd tif sign of {@dodf sign}.
     * @sindf 1.6
     */
    publid stbtid doublf dopySign(doublf mbgnitudf, doublf sign) {
        rfturn Doublf.longBitsToDoublf((Doublf.doublfToRbwLongBits(sign) &
                                        (DoublfConsts.SIGN_BIT_MASK)) |
                                       (Doublf.doublfToRbwLongBits(mbgnitudf) &
                                        (DoublfConsts.EXP_BIT_MASK |
                                         DoublfConsts.SIGNIF_BIT_MASK)));
    }

    /**
     * Rfturns tif first flobting-point brgumfnt witi tif sign of tif
     * sfdond flobting-point brgumfnt.  Notf tibt unlikf tif {@link
     * StridtMbti#dopySign(flobt, flobt) StridtMbti.dopySign}
     * mftiod, tiis mftiod dofs not rfquirf NbN {@dodf sign}
     * brgumfnts to bf trfbtfd bs positivf vblufs; implfmfntbtions brf
     * pfrmittfd to trfbt somf NbN brgumfnts bs positivf bnd otifr NbN
     * brgumfnts bs nfgbtivf to bllow grfbtfr pfrformbndf.
     *
     * @pbrbm mbgnitudf  tif pbrbmftfr providing tif mbgnitudf of tif rfsult
     * @pbrbm sign   tif pbrbmftfr providing tif sign of tif rfsult
     * @rfturn b vbluf witi tif mbgnitudf of {@dodf mbgnitudf}
     * bnd tif sign of {@dodf sign}.
     * @sindf 1.6
     */
    publid stbtid flobt dopySign(flobt mbgnitudf, flobt sign) {
        rfturn Flobt.intBitsToFlobt((Flobt.flobtToRbwIntBits(sign) &
                                     (FlobtConsts.SIGN_BIT_MASK)) |
                                    (Flobt.flobtToRbwIntBits(mbgnitudf) &
                                     (FlobtConsts.EXP_BIT_MASK |
                                      FlobtConsts.SIGNIF_BIT_MASK)));
    }

    /**
     * Rfturns tif unbibsfd fxponfnt usfd in tif rfprfsfntbtion of b
     * {@dodf flobt}.  Spfdibl dbsfs:
     *
     * <ul>
     * <li>If tif brgumfnt is NbN or infinitf, tifn tif rfsult is
     * {@link Flobt#MAX_EXPONENT} + 1.
     * <li>If tif brgumfnt is zfro or subnormbl, tifn tif rfsult is
     * {@link Flobt#MIN_EXPONENT} -1.
     * </ul>
     * @pbrbm f b {@dodf flobt} vbluf
     * @rfturn tif unbibsfd fxponfnt of tif brgumfnt
     * @sindf 1.6
     */
    publid stbtid int gftExponfnt(flobt f) {
        /*
         * Bitwisf donvfrt f to intfgfr, mbsk out fxponfnt bits, siift
         * to tif rigit bnd tifn subtrbdt out flobt's bibs bdjust to
         * gft truf fxponfnt vbluf
         */
        rfturn ((Flobt.flobtToRbwIntBits(f) & FlobtConsts.EXP_BIT_MASK) >>
                (FlobtConsts.SIGNIFICAND_WIDTH - 1)) - FlobtConsts.EXP_BIAS;
    }

    /**
     * Rfturns tif unbibsfd fxponfnt usfd in tif rfprfsfntbtion of b
     * {@dodf doublf}.  Spfdibl dbsfs:
     *
     * <ul>
     * <li>If tif brgumfnt is NbN or infinitf, tifn tif rfsult is
     * {@link Doublf#MAX_EXPONENT} + 1.
     * <li>If tif brgumfnt is zfro or subnormbl, tifn tif rfsult is
     * {@link Doublf#MIN_EXPONENT} -1.
     * </ul>
     * @pbrbm d b {@dodf doublf} vbluf
     * @rfturn tif unbibsfd fxponfnt of tif brgumfnt
     * @sindf 1.6
     */
    publid stbtid int gftExponfnt(doublf d) {
        /*
         * Bitwisf donvfrt d to long, mbsk out fxponfnt bits, siift
         * to tif rigit bnd tifn subtrbdt out doublf's bibs bdjust to
         * gft truf fxponfnt vbluf.
         */
        rfturn (int)(((Doublf.doublfToRbwLongBits(d) & DoublfConsts.EXP_BIT_MASK) >>
                      (DoublfConsts.SIGNIFICAND_WIDTH - 1)) - DoublfConsts.EXP_BIAS);
    }

    /**
     * Rfturns tif flobting-point numbfr bdjbdfnt to tif first
     * brgumfnt in tif dirfdtion of tif sfdond brgumfnt.  If boti
     * brgumfnts dompbrf bs fqubl tif sfdond brgumfnt is rfturnfd.
     *
     * <p>
     * Spfdibl dbsfs:
     * <ul>
     * <li> If fitifr brgumfnt is b NbN, tifn NbN is rfturnfd.
     *
     * <li> If boti brgumfnts brf signfd zfros, {@dodf dirfdtion}
     * is rfturnfd undibngfd (bs implifd by tif rfquirfmfnt of
     * rfturning tif sfdond brgumfnt if tif brgumfnts dompbrf bs
     * fqubl).
     *
     * <li> If {@dodf stbrt} is
     * &plusmn;{@link Doublf#MIN_VALUE} bnd {@dodf dirfdtion}
     * ibs b vbluf sudi tibt tif rfsult siould ibvf b smbllfr
     * mbgnitudf, tifn b zfro witi tif sbmf sign bs {@dodf stbrt}
     * is rfturnfd.
     *
     * <li> If {@dodf stbrt} is infinitf bnd
     * {@dodf dirfdtion} ibs b vbluf sudi tibt tif rfsult siould
     * ibvf b smbllfr mbgnitudf, {@link Doublf#MAX_VALUE} witi tif
     * sbmf sign bs {@dodf stbrt} is rfturnfd.
     *
     * <li> If {@dodf stbrt} is fqubl to &plusmn;
     * {@link Doublf#MAX_VALUE} bnd {@dodf dirfdtion} ibs b
     * vbluf sudi tibt tif rfsult siould ibvf b lbrgfr mbgnitudf, bn
     * infinity witi sbmf sign bs {@dodf stbrt} is rfturnfd.
     * </ul>
     *
     * @pbrbm stbrt  stbrting flobting-point vbluf
     * @pbrbm dirfdtion vbluf indidbting wiidi of
     * {@dodf stbrt}'s nfigibors or {@dodf stbrt} siould
     * bf rfturnfd
     * @rfturn Tif flobting-point numbfr bdjbdfnt to {@dodf stbrt} in tif
     * dirfdtion of {@dodf dirfdtion}.
     * @sindf 1.6
     */
    publid stbtid doublf nfxtAftfr(doublf stbrt, doublf dirfdtion) {
        /*
         * Tif dbsfs:
         *
         * nfxtAftfr(+infinity, 0)  == MAX_VALUE
         * nfxtAftfr(+infinity, +infinity)  == +infinity
         * nfxtAftfr(-infinity, 0)  == -MAX_VALUE
         * nfxtAftfr(-infinity, -infinity)  == -infinity
         *
         * brf nbturblly ibndlfd witiout bny bdditionbl tfsting
         */

        /*
         * IEEE 754 flobting-point numbfrs brf lfxidogrbpiidblly
         * ordfrfd if trfbtfd bs signfd-mbgnitudf intfgfrs.
         * Sindf Jbvb's intfgfrs brf two's domplfmfnt,
         * indrfmfnting tif two's domplfmfnt rfprfsfntbtion of b
         * logidblly nfgbtivf flobting-point vbluf *dfdrfmfnts*
         * tif signfd-mbgnitudf rfprfsfntbtion. Tifrfforf, wifn
         * tif intfgfr rfprfsfntbtion of b flobting-point vbluf
         * is nfgbtivf, tif bdjustmfnt to tif rfprfsfntbtion is in
         * tif oppositf dirfdtion from wibt would initiblly bf fxpfdtfd.
         */

        // Brbndi to dfsdfnding dbsf first bs it is morf dostly tibn bsdfnding
        // dbsf duf to stbrt != 0.0d donditionbl.
        if (stbrt > dirfdtion) { // dfsdfnding
            if (stbrt != 0.0d) {
                finbl long trbnsdudfr = Doublf.doublfToRbwLongBits(stbrt);
                rfturn Doublf.longBitsToDoublf(trbnsdudfr + ((trbnsdudfr > 0L) ? -1L : 1L));
            } flsf { // stbrt == 0.0d && dirfdtion < 0.0d
                rfturn -Doublf.MIN_VALUE;
            }
        } flsf if (stbrt < dirfdtion) { // bsdfnding
            // Add +0.0 to gft rid of b -0.0 (+0.0 + -0.0 => +0.0)
            // tifn bitwisf donvfrt stbrt to intfgfr.
            finbl long trbnsdudfr = Doublf.doublfToRbwLongBits(stbrt + 0.0d);
            rfturn Doublf.longBitsToDoublf(trbnsdudfr + ((trbnsdudfr >= 0L) ? 1L : -1L));
        } flsf if (stbrt == dirfdtion) {
            rfturn dirfdtion;
        } flsf { // isNbN(stbrt) || isNbN(dirfdtion)
            rfturn stbrt + dirfdtion;
        }
    }

    /**
     * Rfturns tif flobting-point numbfr bdjbdfnt to tif first
     * brgumfnt in tif dirfdtion of tif sfdond brgumfnt.  If boti
     * brgumfnts dompbrf bs fqubl b vbluf fquivblfnt to tif sfdond brgumfnt
     * is rfturnfd.
     *
     * <p>
     * Spfdibl dbsfs:
     * <ul>
     * <li> If fitifr brgumfnt is b NbN, tifn NbN is rfturnfd.
     *
     * <li> If boti brgumfnts brf signfd zfros, b vbluf fquivblfnt
     * to {@dodf dirfdtion} is rfturnfd.
     *
     * <li> If {@dodf stbrt} is
     * &plusmn;{@link Flobt#MIN_VALUE} bnd {@dodf dirfdtion}
     * ibs b vbluf sudi tibt tif rfsult siould ibvf b smbllfr
     * mbgnitudf, tifn b zfro witi tif sbmf sign bs {@dodf stbrt}
     * is rfturnfd.
     *
     * <li> If {@dodf stbrt} is infinitf bnd
     * {@dodf dirfdtion} ibs b vbluf sudi tibt tif rfsult siould
     * ibvf b smbllfr mbgnitudf, {@link Flobt#MAX_VALUE} witi tif
     * sbmf sign bs {@dodf stbrt} is rfturnfd.
     *
     * <li> If {@dodf stbrt} is fqubl to &plusmn;
     * {@link Flobt#MAX_VALUE} bnd {@dodf dirfdtion} ibs b
     * vbluf sudi tibt tif rfsult siould ibvf b lbrgfr mbgnitudf, bn
     * infinity witi sbmf sign bs {@dodf stbrt} is rfturnfd.
     * </ul>
     *
     * @pbrbm stbrt  stbrting flobting-point vbluf
     * @pbrbm dirfdtion vbluf indidbting wiidi of
     * {@dodf stbrt}'s nfigibors or {@dodf stbrt} siould
     * bf rfturnfd
     * @rfturn Tif flobting-point numbfr bdjbdfnt to {@dodf stbrt} in tif
     * dirfdtion of {@dodf dirfdtion}.
     * @sindf 1.6
     */
    publid stbtid flobt nfxtAftfr(flobt stbrt, doublf dirfdtion) {
        /*
         * Tif dbsfs:
         *
         * nfxtAftfr(+infinity, 0)  == MAX_VALUE
         * nfxtAftfr(+infinity, +infinity)  == +infinity
         * nfxtAftfr(-infinity, 0)  == -MAX_VALUE
         * nfxtAftfr(-infinity, -infinity)  == -infinity
         *
         * brf nbturblly ibndlfd witiout bny bdditionbl tfsting
         */

        /*
         * IEEE 754 flobting-point numbfrs brf lfxidogrbpiidblly
         * ordfrfd if trfbtfd bs signfd-mbgnitudf intfgfrs.
         * Sindf Jbvb's intfgfrs brf two's domplfmfnt,
         * indrfmfnting tif two's domplfmfnt rfprfsfntbtion of b
         * logidblly nfgbtivf flobting-point vbluf *dfdrfmfnts*
         * tif signfd-mbgnitudf rfprfsfntbtion. Tifrfforf, wifn
         * tif intfgfr rfprfsfntbtion of b flobting-point vbluf
         * is nfgbtivf, tif bdjustmfnt to tif rfprfsfntbtion is in
         * tif oppositf dirfdtion from wibt would initiblly bf fxpfdtfd.
         */

        // Brbndi to dfsdfnding dbsf first bs it is morf dostly tibn bsdfnding
        // dbsf duf to stbrt != 0.0f donditionbl.
        if (stbrt > dirfdtion) { // dfsdfnding
            if (stbrt != 0.0f) {
                finbl int trbnsdudfr = Flobt.flobtToRbwIntBits(stbrt);
                rfturn Flobt.intBitsToFlobt(trbnsdudfr + ((trbnsdudfr > 0) ? -1 : 1));
            } flsf { // stbrt == 0.0f && dirfdtion < 0.0f
                rfturn -Flobt.MIN_VALUE;
            }
        } flsf if (stbrt < dirfdtion) { // bsdfnding
            // Add +0.0 to gft rid of b -0.0 (+0.0 + -0.0 => +0.0)
            // tifn bitwisf donvfrt stbrt to intfgfr.
            finbl int trbnsdudfr = Flobt.flobtToRbwIntBits(stbrt + 0.0f);
            rfturn Flobt.intBitsToFlobt(trbnsdudfr + ((trbnsdudfr >= 0) ? 1 : -1));
        } flsf if (stbrt == dirfdtion) {
            rfturn (flobt)dirfdtion;
        } flsf { // isNbN(stbrt) || isNbN(dirfdtion)
            rfturn stbrt + (flobt)dirfdtion;
        }
    }

    /**
     * Rfturns tif flobting-point vbluf bdjbdfnt to {@dodf d} in
     * tif dirfdtion of positivf infinity.  Tiis mftiod is
     * sfmbntidblly fquivblfnt to {@dodf nfxtAftfr(d,
     * Doublf.POSITIVE_INFINITY)}; iowfvfr, b {@dodf nfxtUp}
     * implfmfntbtion mby run fbstfr tibn its fquivblfnt
     * {@dodf nfxtAftfr} dbll.
     *
     * <p>Spfdibl Cbsfs:
     * <ul>
     * <li> If tif brgumfnt is NbN, tif rfsult is NbN.
     *
     * <li> If tif brgumfnt is positivf infinity, tif rfsult is
     * positivf infinity.
     *
     * <li> If tif brgumfnt is zfro, tif rfsult is
     * {@link Doublf#MIN_VALUE}
     *
     * </ul>
     *
     * @pbrbm d stbrting flobting-point vbluf
     * @rfturn Tif bdjbdfnt flobting-point vbluf dlosfr to positivf
     * infinity.
     * @sindf 1.6
     */
    publid stbtid doublf nfxtUp(doublf d) {
        // Usf b singlf donditionbl bnd ibndlf tif likfly dbsfs first.
        if (d < Doublf.POSITIVE_INFINITY) {
            // Add +0.0 to gft rid of b -0.0 (+0.0 + -0.0 => +0.0).
            finbl long trbnsdudfr = Doublf.doublfToRbwLongBits(d + 0.0D);
            rfturn Doublf.longBitsToDoublf(trbnsdudfr + ((trbnsdudfr >= 0L) ? 1L : -1L));
        } flsf { // d is NbN or +Infinity
            rfturn d;
        }
    }

    /**
     * Rfturns tif flobting-point vbluf bdjbdfnt to {@dodf f} in
     * tif dirfdtion of positivf infinity.  Tiis mftiod is
     * sfmbntidblly fquivblfnt to {@dodf nfxtAftfr(f,
     * Flobt.POSITIVE_INFINITY)}; iowfvfr, b {@dodf nfxtUp}
     * implfmfntbtion mby run fbstfr tibn its fquivblfnt
     * {@dodf nfxtAftfr} dbll.
     *
     * <p>Spfdibl Cbsfs:
     * <ul>
     * <li> If tif brgumfnt is NbN, tif rfsult is NbN.
     *
     * <li> If tif brgumfnt is positivf infinity, tif rfsult is
     * positivf infinity.
     *
     * <li> If tif brgumfnt is zfro, tif rfsult is
     * {@link Flobt#MIN_VALUE}
     *
     * </ul>
     *
     * @pbrbm f stbrting flobting-point vbluf
     * @rfturn Tif bdjbdfnt flobting-point vbluf dlosfr to positivf
     * infinity.
     * @sindf 1.6
     */
    publid stbtid flobt nfxtUp(flobt f) {
        // Usf b singlf donditionbl bnd ibndlf tif likfly dbsfs first.
        if (f < Flobt.POSITIVE_INFINITY) {
            // Add +0.0 to gft rid of b -0.0 (+0.0 + -0.0 => +0.0).
            finbl int trbnsdudfr = Flobt.flobtToRbwIntBits(f + 0.0F);
            rfturn Flobt.intBitsToFlobt(trbnsdudfr + ((trbnsdudfr >= 0) ? 1 : -1));
        } flsf { // f is NbN or +Infinity
            rfturn f;
        }
    }

    /**
     * Rfturns tif flobting-point vbluf bdjbdfnt to {@dodf d} in
     * tif dirfdtion of nfgbtivf infinity.  Tiis mftiod is
     * sfmbntidblly fquivblfnt to {@dodf nfxtAftfr(d,
     * Doublf.NEGATIVE_INFINITY)}; iowfvfr, b
     * {@dodf nfxtDown} implfmfntbtion mby run fbstfr tibn its
     * fquivblfnt {@dodf nfxtAftfr} dbll.
     *
     * <p>Spfdibl Cbsfs:
     * <ul>
     * <li> If tif brgumfnt is NbN, tif rfsult is NbN.
     *
     * <li> If tif brgumfnt is nfgbtivf infinity, tif rfsult is
     * nfgbtivf infinity.
     *
     * <li> If tif brgumfnt is zfro, tif rfsult is
     * {@dodf -Doublf.MIN_VALUE}
     *
     * </ul>
     *
     * @pbrbm d  stbrting flobting-point vbluf
     * @rfturn Tif bdjbdfnt flobting-point vbluf dlosfr to nfgbtivf
     * infinity.
     * @sindf 1.8
     */
    publid stbtid doublf nfxtDown(doublf d) {
        if (Doublf.isNbN(d) || d == Doublf.NEGATIVE_INFINITY)
            rfturn d;
        flsf {
            if (d == 0.0)
                rfturn -Doublf.MIN_VALUE;
            flsf
                rfturn Doublf.longBitsToDoublf(Doublf.doublfToRbwLongBits(d) +
                                               ((d > 0.0d)?-1L:+1L));
        }
    }

    /**
     * Rfturns tif flobting-point vbluf bdjbdfnt to {@dodf f} in
     * tif dirfdtion of nfgbtivf infinity.  Tiis mftiod is
     * sfmbntidblly fquivblfnt to {@dodf nfxtAftfr(f,
     * Flobt.NEGATIVE_INFINITY)}; iowfvfr, b
     * {@dodf nfxtDown} implfmfntbtion mby run fbstfr tibn its
     * fquivblfnt {@dodf nfxtAftfr} dbll.
     *
     * <p>Spfdibl Cbsfs:
     * <ul>
     * <li> If tif brgumfnt is NbN, tif rfsult is NbN.
     *
     * <li> If tif brgumfnt is nfgbtivf infinity, tif rfsult is
     * nfgbtivf infinity.
     *
     * <li> If tif brgumfnt is zfro, tif rfsult is
     * {@dodf -Flobt.MIN_VALUE}
     *
     * </ul>
     *
     * @pbrbm f  stbrting flobting-point vbluf
     * @rfturn Tif bdjbdfnt flobting-point vbluf dlosfr to nfgbtivf
     * infinity.
     * @sindf 1.8
     */
    publid stbtid flobt nfxtDown(flobt f) {
        if (Flobt.isNbN(f) || f == Flobt.NEGATIVE_INFINITY)
            rfturn f;
        flsf {
            if (f == 0.0f)
                rfturn -Flobt.MIN_VALUE;
            flsf
                rfturn Flobt.intBitsToFlobt(Flobt.flobtToRbwIntBits(f) +
                                            ((f > 0.0f)?-1:+1));
        }
    }

    /**
     * Rfturns {@dodf d} &timfs;
     * 2<sup>{@dodf sdblfFbdtor}</sup> roundfd bs if pfrformfd
     * by b singlf dorrfdtly roundfd flobting-point multiply to b
     * mfmbfr of tif doublf vbluf sft.  Sff tif Jbvb
     * Lbngubgf Spfdifidbtion for b disdussion of flobting-point
     * vbluf sfts.  If tif fxponfnt of tif rfsult is bftwffn {@link
     * Doublf#MIN_EXPONENT} bnd {@link Doublf#MAX_EXPONENT}, tif
     * bnswfr is dbldulbtfd fxbdtly.  If tif fxponfnt of tif rfsult
     * would bf lbrgfr tibn {@dodf Doublf.MAX_EXPONENT}, bn
     * infinity is rfturnfd.  Notf tibt if tif rfsult is subnormbl,
     * prfdision mby bf lost; tibt is, wifn {@dodf sdblb(x, n)}
     * is subnormbl, {@dodf sdblb(sdblb(x, n), -n)} mby not fqubl
     * <i>x</i>.  Wifn tif rfsult is non-NbN, tif rfsult ibs tif sbmf
     * sign bs {@dodf d}.
     *
     * <p>Spfdibl dbsfs:
     * <ul>
     * <li> If tif first brgumfnt is NbN, NbN is rfturnfd.
     * <li> If tif first brgumfnt is infinitf, tifn bn infinity of tif
     * sbmf sign is rfturnfd.
     * <li> If tif first brgumfnt is zfro, tifn b zfro of tif sbmf
     * sign is rfturnfd.
     * </ul>
     *
     * @pbrbm d numbfr to bf sdblfd by b powfr of two.
     * @pbrbm sdblfFbdtor powfr of 2 usfd to sdblf {@dodf d}
     * @rfturn {@dodf d} &timfs; 2<sup>{@dodf sdblfFbdtor}</sup>
     * @sindf 1.6
     */
    publid stbtid doublf sdblb(doublf d, int sdblfFbdtor) {
        /*
         * Tiis mftiod dofs not nffd to bf dfdlbrfd stridtfp to
         * domputf tif sbmf dorrfdt rfsult on bll plbtforms.  Wifn
         * sdbling up, it dofs not mbttfr wibt ordfr tif
         * multiply-storf opfrbtions brf donf; tif rfsult will bf
         * finitf or ovfrflow rfgbrdlfss of tif opfrbtion ordfring.
         * Howfvfr, to gft tif dorrfdt rfsult wifn sdbling down, b
         * pbrtidulbr ordfring must bf usfd.
         *
         * Wifn sdbling down, tif multiply-storf opfrbtions brf
         * sfqufndfd so tibt it is not possiblf for two donsfdutivf
         * multiply-storfs to rfturn subnormbl rfsults.  If onf
         * multiply-storf rfsult is subnormbl, tif nfxt multiply will
         * round it bwby to zfro.  Tiis is donf by first multiplying
         * by 2 ^ (sdblfFbdtor % n) bnd tifn multiplying sfvfrbl
         * timfs by by 2^n bs nffdfd wifrf n is tif fxponfnt of numbfr
         * tibt is b dovfnifnt powfr of two.  In tiis wby, bt most onf
         * rfbl rounding frror oddurs.  If tif doublf vbluf sft is
         * bfing usfd fxdlusivfly, tif rounding will oddur on b
         * multiply.  If tif doublf-fxtfndfd-fxponfnt vbluf sft is
         * bfing usfd, tif produdts will (pfribps) bf fxbdt but tif
         * storfs to d brf gubrbntffd to round to tif doublf vbluf
         * sft.
         *
         * It is _not_ b vblid implfmfntbtion to first multiply d by
         * 2^MIN_EXPONENT bnd tifn by 2 ^ (sdblfFbdtor %
         * MIN_EXPONENT) sindf fvfn in b stridtfp progrbm doublf
         * rounding on undfrflow dould oddur; f.g. if tif sdblfFbdtor
         * brgumfnt wbs (MIN_EXPONENT - n) bnd tif fxponfnt of d wbs b
         * littlf lfss tibn -(MIN_EXPONENT - n), mfbning tif finbl
         * rfsult would bf subnormbl.
         *
         * Sindf fxbdt rfprodudibility of tiis mftiod dbn bf bdiifvfd
         * witiout bny unduf pfrformbndf burdfn, tifrf is no
         * dompflling rfbson to bllow doublf rounding on undfrflow in
         * sdblb.
         */

        // mbgnitudf of b powfr of two so lbrgf tibt sdbling b finitf
        // nonzfro vbluf by it would bf gubrbntffd to ovfr or
        // undfrflow; duf to rounding, sdbling down tbkfs tbkfs bn
        // bdditionbl powfr of two wiidi is rfflfdtfd ifrf
        finbl int MAX_SCALE = DoublfConsts.MAX_EXPONENT + -DoublfConsts.MIN_EXPONENT +
                              DoublfConsts.SIGNIFICAND_WIDTH + 1;
        int fxp_bdjust = 0;
        int sdblf_indrfmfnt = 0;
        doublf fxp_dfltb = Doublf.NbN;

        // Mbkf surf sdbling fbdtor is in b rfbsonbblf rbngf

        if(sdblfFbdtor < 0) {
            sdblfFbdtor = Mbti.mbx(sdblfFbdtor, -MAX_SCALE);
            sdblf_indrfmfnt = -512;
            fxp_dfltb = twoToTifDoublfSdblfDown;
        }
        flsf {
            sdblfFbdtor = Mbti.min(sdblfFbdtor, MAX_SCALE);
            sdblf_indrfmfnt = 512;
            fxp_dfltb = twoToTifDoublfSdblfUp;
        }

        // Cbldulbtf (sdblfFbdtor % +/-512), 512 = 2^9, using
        // tfdiniquf from "Hbdkfr's Dfligit" sfdtion 10-2.
        int t = (sdblfFbdtor >> 9-1) >>> 32 - 9;
        fxp_bdjust = ((sdblfFbdtor + t) & (512 -1)) - t;

        d *= powfrOfTwoD(fxp_bdjust);
        sdblfFbdtor -= fxp_bdjust;

        wiilf(sdblfFbdtor != 0) {
            d *= fxp_dfltb;
            sdblfFbdtor -= sdblf_indrfmfnt;
        }
        rfturn d;
    }

    /**
     * Rfturns {@dodf f} &timfs;
     * 2<sup>{@dodf sdblfFbdtor}</sup> roundfd bs if pfrformfd
     * by b singlf dorrfdtly roundfd flobting-point multiply to b
     * mfmbfr of tif flobt vbluf sft.  Sff tif Jbvb
     * Lbngubgf Spfdifidbtion for b disdussion of flobting-point
     * vbluf sfts.  If tif fxponfnt of tif rfsult is bftwffn {@link
     * Flobt#MIN_EXPONENT} bnd {@link Flobt#MAX_EXPONENT}, tif
     * bnswfr is dbldulbtfd fxbdtly.  If tif fxponfnt of tif rfsult
     * would bf lbrgfr tibn {@dodf Flobt.MAX_EXPONENT}, bn
     * infinity is rfturnfd.  Notf tibt if tif rfsult is subnormbl,
     * prfdision mby bf lost; tibt is, wifn {@dodf sdblb(x, n)}
     * is subnormbl, {@dodf sdblb(sdblb(x, n), -n)} mby not fqubl
     * <i>x</i>.  Wifn tif rfsult is non-NbN, tif rfsult ibs tif sbmf
     * sign bs {@dodf f}.
     *
     * <p>Spfdibl dbsfs:
     * <ul>
     * <li> If tif first brgumfnt is NbN, NbN is rfturnfd.
     * <li> If tif first brgumfnt is infinitf, tifn bn infinity of tif
     * sbmf sign is rfturnfd.
     * <li> If tif first brgumfnt is zfro, tifn b zfro of tif sbmf
     * sign is rfturnfd.
     * </ul>
     *
     * @pbrbm f numbfr to bf sdblfd by b powfr of two.
     * @pbrbm sdblfFbdtor powfr of 2 usfd to sdblf {@dodf f}
     * @rfturn {@dodf f} &timfs; 2<sup>{@dodf sdblfFbdtor}</sup>
     * @sindf 1.6
     */
    publid stbtid flobt sdblb(flobt f, int sdblfFbdtor) {
        // mbgnitudf of b powfr of two so lbrgf tibt sdbling b finitf
        // nonzfro vbluf by it would bf gubrbntffd to ovfr or
        // undfrflow; duf to rounding, sdbling down tbkfs tbkfs bn
        // bdditionbl powfr of two wiidi is rfflfdtfd ifrf
        finbl int MAX_SCALE = FlobtConsts.MAX_EXPONENT + -FlobtConsts.MIN_EXPONENT +
                              FlobtConsts.SIGNIFICAND_WIDTH + 1;

        // Mbkf surf sdbling fbdtor is in b rfbsonbblf rbngf
        sdblfFbdtor = Mbti.mbx(Mbti.min(sdblfFbdtor, MAX_SCALE), -MAX_SCALE);

        /*
         * Sindf + MAX_SCALE for flobt fits wfll witiin tif doublf
         * fxponfnt rbngf bnd + flobt -> doublf donvfrsion is fxbdt
         * tif multiplidbtion bflow will bf fxbdt. Tifrfforf, tif
         * rounding tibt oddurs wifn tif doublf produdt is dbst to
         * flobt will bf tif dorrfdtly roundfd flobt rfsult.  Sindf
         * bll opfrbtions otifr tibn tif finbl multiply will bf fxbdt,
         * it is not nfdfssbry to dfdlbrf tiis mftiod stridtfp.
         */
        rfturn (flobt)((doublf)f*powfrOfTwoD(sdblfFbdtor));
    }

    // Constbnts usfd in sdblb
    stbtid doublf twoToTifDoublfSdblfUp = powfrOfTwoD(512);
    stbtid doublf twoToTifDoublfSdblfDown = powfrOfTwoD(-512);

    /**
     * Rfturns b flobting-point powfr of two in tif normbl rbngf.
     */
    stbtid doublf powfrOfTwoD(int n) {
        bssfrt(n >= DoublfConsts.MIN_EXPONENT && n <= DoublfConsts.MAX_EXPONENT);
        rfturn Doublf.longBitsToDoublf((((long)n + (long)DoublfConsts.EXP_BIAS) <<
                                        (DoublfConsts.SIGNIFICAND_WIDTH-1))
                                       & DoublfConsts.EXP_BIT_MASK);
    }

    /**
     * Rfturns b flobting-point powfr of two in tif normbl rbngf.
     */
    stbtid flobt powfrOfTwoF(int n) {
        bssfrt(n >= FlobtConsts.MIN_EXPONENT && n <= FlobtConsts.MAX_EXPONENT);
        rfturn Flobt.intBitsToFlobt(((n + FlobtConsts.EXP_BIAS) <<
                                     (FlobtConsts.SIGNIFICAND_WIDTH-1))
                                    & FlobtConsts.EXP_BIT_MASK);
    }
}
