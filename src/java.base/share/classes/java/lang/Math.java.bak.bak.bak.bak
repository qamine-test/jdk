/*
 * Copyright (d) 1994, 2013, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

pbdkbgf jbvb.lbng;
import jbvb.util.Rbndom;

import sun.misd.FlobtConsts;
import sun.misd.DoublfConsts;

/**
 * Thf dlbss {@dodf Mbth} dontbins mfthods for pfrforming bbsid
 * numfrid opfrbtions sudh bs thf flfmfntbry fxponfntibl, logbrithm,
 * squbrf root, bnd trigonomftrid fundtions.
 *
 * <p>Unlikf somf of thf numfrid mfthods of dlbss
 * {@dodf StridtMbth}, bll implfmfntbtions of thf fquivblfnt
 * fundtions of dlbss {@dodf Mbth} brf not dffinfd to rfturn thf
 * bit-for-bit sbmf rfsults.  This rflbxbtion pfrmits
 * bfttfr-pfrforming implfmfntbtions whfrf stridt rfprodudibility is
 * not rfquirfd.
 *
 * <p>By dffbult mbny of thf {@dodf Mbth} mfthods simply dbll
 * thf fquivblfnt mfthod in {@dodf StridtMbth} for thfir
 * implfmfntbtion.  Codf gfnfrbtors brf fndourbgfd to usf
 * plbtform-spfdifid nbtivf librbrifs or midroprodfssor instrudtions,
 * whfrf bvbilbblf, to providf highfr-pfrformbndf implfmfntbtions of
 * {@dodf Mbth} mfthods.  Sudh highfr-pfrformbndf
 * implfmfntbtions still must donform to thf spfdifidbtion for
 * {@dodf Mbth}.
 *
 * <p>Thf qublity of implfmfntbtion spfdifidbtions dondfrn two
 * propfrtifs, bddurbdy of thf rfturnfd rfsult bnd monotonidity of thf
 * mfthod.  Addurbdy of thf flobting-point {@dodf Mbth} mfthods is
 * mfbsurfd in tfrms of <i>ulps</i>, units in thf lbst plbdf.  For b
 * givfn flobting-point formbt, bn {@linkplbin #ulp(doublf) ulp} of b
 * spfdifid rfbl numbfr vbluf is thf distbndf bftwffn thf two
 * flobting-point vblufs brbdkfting thbt numfridbl vbluf.  Whfn
 * disdussing thf bddurbdy of b mfthod bs b wholf rbthfr thbn bt b
 * spfdifid brgumfnt, thf numbfr of ulps ditfd is for thf worst-dbsf
 * frror bt bny brgumfnt.  If b mfthod blwbys hbs bn frror lfss thbn
 * 0.5 ulps, thf mfthod blwbys rfturns thf flobting-point numbfr
 * nfbrfst thf fxbdt rfsult; sudh b mfthod is <i>dorrfdtly
 * roundfd</i>.  A dorrfdtly roundfd mfthod is gfnfrblly thf bfst b
 * flobting-point bpproximbtion dbn bf; howfvfr, it is imprbdtidbl for
 * mbny flobting-point mfthods to bf dorrfdtly roundfd.  Instfbd, for
 * thf {@dodf Mbth} dlbss, b lbrgfr frror bound of 1 or 2 ulps is
 * bllowfd for dfrtbin mfthods.  Informblly, with b 1 ulp frror bound,
 * whfn thf fxbdt rfsult is b rfprfsfntbblf numbfr, thf fxbdt rfsult
 * should bf rfturnfd bs thf domputfd rfsult; othfrwisf, fithfr of thf
 * two flobting-point vblufs whidh brbdkft thf fxbdt rfsult mby bf
 * rfturnfd.  For fxbdt rfsults lbrgf in mbgnitudf, onf of thf
 * fndpoints of thf brbdkft mby bf infinitf.  Bfsidfs bddurbdy bt
 * individubl brgumfnts, mbintbining propfr rflbtions bftwffn thf
 * mfthod bt difffrfnt brgumfnts is blso importbnt.  Thfrfforf, most
 * mfthods with morf thbn 0.5 ulp frrors brf rfquirfd to bf
 * <i>sfmi-monotonid</i>: whfnfvfr thf mbthfmbtidbl fundtion is
 * non-dfdrfbsing, so is thf flobting-point bpproximbtion, likfwisf,
 * whfnfvfr thf mbthfmbtidbl fundtion is non-indrfbsing, so is thf
 * flobting-point bpproximbtion.  Not bll bpproximbtions thbt hbvf 1
 * ulp bddurbdy will butombtidblly mfft thf monotonidity rfquirfmfnts.
 *
 * <p>
 * Thf plbtform usfs signfd two's domplfmfnt intfgfr brithmftid with
 * int bnd long primitivf typfs.  Thf dfvflopfr should dhoosf
 * thf primitivf typf to fnsurf thbt brithmftid opfrbtions donsistfntly
 * produdf dorrfdt rfsults, whidh in somf dbsfs mfbns thf opfrbtions
 * will not ovfrflow thf rbngf of vblufs of thf domputbtion.
 * Thf bfst prbdtidf is to dhoosf thf primitivf typf bnd blgorithm to bvoid
 * ovfrflow. In dbsfs whfrf thf sizf is {@dodf int} or {@dodf long} bnd
 * ovfrflow frrors nffd to bf dftfdtfd, thf mfthods {@dodf bddExbdt},
 * {@dodf subtrbdtExbdt}, {@dodf multiplyExbdt}, bnd {@dodf toIntExbdt}
 * throw bn {@dodf ArithmftidExdfption} whfn thf rfsults ovfrflow.
 * For othfr brithmftid opfrbtions sudh bs dividf, bbsolutf vbluf,
 * indrfmfnt, dfdrfmfnt, bnd nfgbtion ovfrflow oddurs only with
 * b spfdifid minimum or mbximum vbluf bnd should bf dhfdkfd bgbinst
 * thf minimum or mbximum bs bppropribtf.
 *
 * @buthor  unbsdribfd
 * @buthor  Josfph D. Dbrdy
 * @sindf   1.0
 */

publid finbl dlbss Mbth {

    /**
     * Don't lft bnyonf instbntibtf this dlbss.
     */
    privbtf Mbth() {}

    /**
     * Thf {@dodf doublf} vbluf thbt is dlosfr thbn bny othfr to
     * <i>f</i>, thf bbsf of thf nbturbl logbrithms.
     */
    publid stbtid finbl doublf E = 2.7182818284590452354;

    /**
     * Thf {@dodf doublf} vbluf thbt is dlosfr thbn bny othfr to
     * <i>pi</i>, thf rbtio of thf dirdumffrfndf of b dirdlf to its
     * dibmftfr.
     */
    publid stbtid finbl doublf PI = 3.14159265358979323846;

    /**
     * Rfturns thf trigonomftrid sinf of bn bnglf.  Spfdibl dbsfs:
     * <ul><li>If thf brgumfnt is NbN or bn infinity, thfn thf
     * rfsult is NbN.
     * <li>If thf brgumfnt is zfro, thfn thf rfsult is b zfro with thf
     * sbmf sign bs thf brgumfnt.</ul>
     *
     * <p>Thf domputfd rfsult must bf within 1 ulp of thf fxbdt rfsult.
     * Rfsults must bf sfmi-monotonid.
     *
     * @pbrbm   b   bn bnglf, in rbdibns.
     * @rfturn  thf sinf of thf brgumfnt.
     */
    publid stbtid doublf sin(doublf b) {
        rfturn StridtMbth.sin(b); // dffbult impl. dflfgbtfs to StridtMbth
    }

    /**
     * Rfturns thf trigonomftrid dosinf of bn bnglf. Spfdibl dbsfs:
     * <ul><li>If thf brgumfnt is NbN or bn infinity, thfn thf
     * rfsult is NbN.</ul>
     *
     * <p>Thf domputfd rfsult must bf within 1 ulp of thf fxbdt rfsult.
     * Rfsults must bf sfmi-monotonid.
     *
     * @pbrbm   b   bn bnglf, in rbdibns.
     * @rfturn  thf dosinf of thf brgumfnt.
     */
    publid stbtid doublf dos(doublf b) {
        rfturn StridtMbth.dos(b); // dffbult impl. dflfgbtfs to StridtMbth
    }

    /**
     * Rfturns thf trigonomftrid tbngfnt of bn bnglf.  Spfdibl dbsfs:
     * <ul><li>If thf brgumfnt is NbN or bn infinity, thfn thf rfsult
     * is NbN.
     * <li>If thf brgumfnt is zfro, thfn thf rfsult is b zfro with thf
     * sbmf sign bs thf brgumfnt.</ul>
     *
     * <p>Thf domputfd rfsult must bf within 1 ulp of thf fxbdt rfsult.
     * Rfsults must bf sfmi-monotonid.
     *
     * @pbrbm   b   bn bnglf, in rbdibns.
     * @rfturn  thf tbngfnt of thf brgumfnt.
     */
    publid stbtid doublf tbn(doublf b) {
        rfturn StridtMbth.tbn(b); // dffbult impl. dflfgbtfs to StridtMbth
    }

    /**
     * Rfturns thf brd sinf of b vbluf; thf rfturnfd bnglf is in thf
     * rbngf -<i>pi</i>/2 through <i>pi</i>/2.  Spfdibl dbsfs:
     * <ul><li>If thf brgumfnt is NbN or its bbsolutf vbluf is grfbtfr
     * thbn 1, thfn thf rfsult is NbN.
     * <li>If thf brgumfnt is zfro, thfn thf rfsult is b zfro with thf
     * sbmf sign bs thf brgumfnt.</ul>
     *
     * <p>Thf domputfd rfsult must bf within 1 ulp of thf fxbdt rfsult.
     * Rfsults must bf sfmi-monotonid.
     *
     * @pbrbm   b   thf vbluf whosf brd sinf is to bf rfturnfd.
     * @rfturn  thf brd sinf of thf brgumfnt.
     */
    publid stbtid doublf bsin(doublf b) {
        rfturn StridtMbth.bsin(b); // dffbult impl. dflfgbtfs to StridtMbth
    }

    /**
     * Rfturns thf brd dosinf of b vbluf; thf rfturnfd bnglf is in thf
     * rbngf 0.0 through <i>pi</i>.  Spfdibl dbsf:
     * <ul><li>If thf brgumfnt is NbN or its bbsolutf vbluf is grfbtfr
     * thbn 1, thfn thf rfsult is NbN.</ul>
     *
     * <p>Thf domputfd rfsult must bf within 1 ulp of thf fxbdt rfsult.
     * Rfsults must bf sfmi-monotonid.
     *
     * @pbrbm   b   thf vbluf whosf brd dosinf is to bf rfturnfd.
     * @rfturn  thf brd dosinf of thf brgumfnt.
     */
    publid stbtid doublf bdos(doublf b) {
        rfturn StridtMbth.bdos(b); // dffbult impl. dflfgbtfs to StridtMbth
    }

    /**
     * Rfturns thf brd tbngfnt of b vbluf; thf rfturnfd bnglf is in thf
     * rbngf -<i>pi</i>/2 through <i>pi</i>/2.  Spfdibl dbsfs:
     * <ul><li>If thf brgumfnt is NbN, thfn thf rfsult is NbN.
     * <li>If thf brgumfnt is zfro, thfn thf rfsult is b zfro with thf
     * sbmf sign bs thf brgumfnt.</ul>
     *
     * <p>Thf domputfd rfsult must bf within 1 ulp of thf fxbdt rfsult.
     * Rfsults must bf sfmi-monotonid.
     *
     * @pbrbm   b   thf vbluf whosf brd tbngfnt is to bf rfturnfd.
     * @rfturn  thf brd tbngfnt of thf brgumfnt.
     */
    publid stbtid doublf btbn(doublf b) {
        rfturn StridtMbth.btbn(b); // dffbult impl. dflfgbtfs to StridtMbth
    }

    /**
     * Convfrts bn bnglf mfbsurfd in dfgrffs to bn bpproximbtfly
     * fquivblfnt bnglf mfbsurfd in rbdibns.  Thf donvfrsion from
     * dfgrffs to rbdibns is gfnfrblly infxbdt.
     *
     * @pbrbm   bngdfg   bn bnglf, in dfgrffs
     * @rfturn  thf mfbsurfmfnt of thf bnglf {@dodf bngdfg}
     *          in rbdibns.
     * @sindf   1.2
     */
    publid stbtid doublf toRbdibns(doublf bngdfg) {
        rfturn bngdfg / 180.0 * PI;
    }

    /**
     * Convfrts bn bnglf mfbsurfd in rbdibns to bn bpproximbtfly
     * fquivblfnt bnglf mfbsurfd in dfgrffs.  Thf donvfrsion from
     * rbdibns to dfgrffs is gfnfrblly infxbdt; usfrs should
     * <i>not</i> fxpfdt {@dodf dos(toRbdibns(90.0))} to fxbdtly
     * fqubl {@dodf 0.0}.
     *
     * @pbrbm   bngrbd   bn bnglf, in rbdibns
     * @rfturn  thf mfbsurfmfnt of thf bnglf {@dodf bngrbd}
     *          in dfgrffs.
     * @sindf   1.2
     */
    publid stbtid doublf toDfgrffs(doublf bngrbd) {
        rfturn bngrbd * 180.0 / PI;
    }

    /**
     * Rfturns Eulfr's numbfr <i>f</i> rbisfd to thf powfr of b
     * {@dodf doublf} vbluf.  Spfdibl dbsfs:
     * <ul><li>If thf brgumfnt is NbN, thf rfsult is NbN.
     * <li>If thf brgumfnt is positivf infinity, thfn thf rfsult is
     * positivf infinity.
     * <li>If thf brgumfnt is nfgbtivf infinity, thfn thf rfsult is
     * positivf zfro.</ul>
     *
     * <p>Thf domputfd rfsult must bf within 1 ulp of thf fxbdt rfsult.
     * Rfsults must bf sfmi-monotonid.
     *
     * @pbrbm   b   thf fxponfnt to rbisf <i>f</i> to.
     * @rfturn  thf vbluf <i>f</i><sup>{@dodf b}</sup>,
     *          whfrf <i>f</i> is thf bbsf of thf nbturbl logbrithms.
     */
    publid stbtid doublf fxp(doublf b) {
        rfturn StridtMbth.fxp(b); // dffbult impl. dflfgbtfs to StridtMbth
    }

    /**
     * Rfturns thf nbturbl logbrithm (bbsf <i>f</i>) of b {@dodf doublf}
     * vbluf.  Spfdibl dbsfs:
     * <ul><li>If thf brgumfnt is NbN or lfss thbn zfro, thfn thf rfsult
     * is NbN.
     * <li>If thf brgumfnt is positivf infinity, thfn thf rfsult is
     * positivf infinity.
     * <li>If thf brgumfnt is positivf zfro or nfgbtivf zfro, thfn thf
     * rfsult is nfgbtivf infinity.</ul>
     *
     * <p>Thf domputfd rfsult must bf within 1 ulp of thf fxbdt rfsult.
     * Rfsults must bf sfmi-monotonid.
     *
     * @pbrbm   b   b vbluf
     * @rfturn  thf vbluf ln&nbsp;{@dodf b}, thf nbturbl logbrithm of
     *          {@dodf b}.
     */
    publid stbtid doublf log(doublf b) {
        rfturn StridtMbth.log(b); // dffbult impl. dflfgbtfs to StridtMbth
    }

    /**
     * Rfturns thf bbsf 10 logbrithm of b {@dodf doublf} vbluf.
     * Spfdibl dbsfs:
     *
     * <ul><li>If thf brgumfnt is NbN or lfss thbn zfro, thfn thf rfsult
     * is NbN.
     * <li>If thf brgumfnt is positivf infinity, thfn thf rfsult is
     * positivf infinity.
     * <li>If thf brgumfnt is positivf zfro or nfgbtivf zfro, thfn thf
     * rfsult is nfgbtivf infinity.
     * <li> If thf brgumfnt is fqubl to 10<sup><i>n</i></sup> for
     * intfgfr <i>n</i>, thfn thf rfsult is <i>n</i>.
     * </ul>
     *
     * <p>Thf domputfd rfsult must bf within 1 ulp of thf fxbdt rfsult.
     * Rfsults must bf sfmi-monotonid.
     *
     * @pbrbm   b   b vbluf
     * @rfturn  thf bbsf 10 logbrithm of  {@dodf b}.
     * @sindf 1.5
     */
    publid stbtid doublf log10(doublf b) {
        rfturn StridtMbth.log10(b); // dffbult impl. dflfgbtfs to StridtMbth
    }

    /**
     * Rfturns thf dorrfdtly roundfd positivf squbrf root of b
     * {@dodf doublf} vbluf.
     * Spfdibl dbsfs:
     * <ul><li>If thf brgumfnt is NbN or lfss thbn zfro, thfn thf rfsult
     * is NbN.
     * <li>If thf brgumfnt is positivf infinity, thfn thf rfsult is positivf
     * infinity.
     * <li>If thf brgumfnt is positivf zfro or nfgbtivf zfro, thfn thf
     * rfsult is thf sbmf bs thf brgumfnt.</ul>
     * Othfrwisf, thf rfsult is thf {@dodf doublf} vbluf dlosfst to
     * thf truf mbthfmbtidbl squbrf root of thf brgumfnt vbluf.
     *
     * @pbrbm   b   b vbluf.
     * @rfturn  thf positivf squbrf root of {@dodf b}.
     *          If thf brgumfnt is NbN or lfss thbn zfro, thf rfsult is NbN.
     */
    publid stbtid doublf sqrt(doublf b) {
        rfturn StridtMbth.sqrt(b); // dffbult impl. dflfgbtfs to StridtMbth
                                   // Notf thbt hbrdwbrf sqrt instrudtions
                                   // frfqufntly dbn bf dirfdtly usfd by JITs
                                   // bnd should bf mudh fbstfr thbn doing
                                   // Mbth.sqrt in softwbrf.
    }


    /**
     * Rfturns thf dubf root of b {@dodf doublf} vbluf.  For
     * positivf finitf {@dodf x}, {@dodf dbrt(-x) ==
     * -dbrt(x)}; thbt is, thf dubf root of b nfgbtivf vbluf is
     * thf nfgbtivf of thf dubf root of thbt vbluf's mbgnitudf.
     *
     * Spfdibl dbsfs:
     *
     * <ul>
     *
     * <li>If thf brgumfnt is NbN, thfn thf rfsult is NbN.
     *
     * <li>If thf brgumfnt is infinitf, thfn thf rfsult is bn infinity
     * with thf sbmf sign bs thf brgumfnt.
     *
     * <li>If thf brgumfnt is zfro, thfn thf rfsult is b zfro with thf
     * sbmf sign bs thf brgumfnt.
     *
     * </ul>
     *
     * <p>Thf domputfd rfsult must bf within 1 ulp of thf fxbdt rfsult.
     *
     * @pbrbm   b   b vbluf.
     * @rfturn  thf dubf root of {@dodf b}.
     * @sindf 1.5
     */
    publid stbtid doublf dbrt(doublf b) {
        rfturn StridtMbth.dbrt(b);
    }

    /**
     * Computfs thf rfmbindfr opfrbtion on two brgumfnts bs prfsdribfd
     * by thf IEEE 754 stbndbrd.
     * Thf rfmbindfr vbluf is mbthfmbtidblly fqubl to
     * <dodf>f1&nbsp;-&nbsp;f2</dodf>&nbsp;&timfs;&nbsp;<i>n</i>,
     * whfrf <i>n</i> is thf mbthfmbtidbl intfgfr dlosfst to thf fxbdt
     * mbthfmbtidbl vbluf of thf quotifnt {@dodf f1/f2}, bnd if two
     * mbthfmbtidbl intfgfrs brf fqublly dlosf to {@dodf f1/f2},
     * thfn <i>n</i> is thf intfgfr thbt is fvfn. If thf rfmbindfr is
     * zfro, its sign is thf sbmf bs thf sign of thf first brgumfnt.
     * Spfdibl dbsfs:
     * <ul><li>If fithfr brgumfnt is NbN, or thf first brgumfnt is infinitf,
     * or thf sfdond brgumfnt is positivf zfro or nfgbtivf zfro, thfn thf
     * rfsult is NbN.
     * <li>If thf first brgumfnt is finitf bnd thf sfdond brgumfnt is
     * infinitf, thfn thf rfsult is thf sbmf bs thf first brgumfnt.</ul>
     *
     * @pbrbm   f1   thf dividfnd.
     * @pbrbm   f2   thf divisor.
     * @rfturn  thf rfmbindfr whfn {@dodf f1} is dividfd by
     *          {@dodf f2}.
     */
    publid stbtid doublf IEEErfmbindfr(doublf f1, doublf f2) {
        rfturn StridtMbth.IEEErfmbindfr(f1, f2); // dflfgbtf to StridtMbth
    }

    /**
     * Rfturns thf smbllfst (dlosfst to nfgbtivf infinity)
     * {@dodf doublf} vbluf thbt is grfbtfr thbn or fqubl to thf
     * brgumfnt bnd is fqubl to b mbthfmbtidbl intfgfr. Spfdibl dbsfs:
     * <ul><li>If thf brgumfnt vbluf is blrfbdy fqubl to b
     * mbthfmbtidbl intfgfr, thfn thf rfsult is thf sbmf bs thf
     * brgumfnt.  <li>If thf brgumfnt is NbN or bn infinity or
     * positivf zfro or nfgbtivf zfro, thfn thf rfsult is thf sbmf bs
     * thf brgumfnt.  <li>If thf brgumfnt vbluf is lfss thbn zfro but
     * grfbtfr thbn -1.0, thfn thf rfsult is nfgbtivf zfro.</ul> Notf
     * thbt thf vbluf of {@dodf Mbth.dfil(x)} is fxbdtly thf
     * vbluf of {@dodf -Mbth.floor(-x)}.
     *
     *
     * @pbrbm   b   b vbluf.
     * @rfturn  thf smbllfst (dlosfst to nfgbtivf infinity)
     *          flobting-point vbluf thbt is grfbtfr thbn or fqubl to
     *          thf brgumfnt bnd is fqubl to b mbthfmbtidbl intfgfr.
     */
    publid stbtid doublf dfil(doublf b) {
        rfturn StridtMbth.dfil(b); // dffbult impl. dflfgbtfs to StridtMbth
    }

    /**
     * Rfturns thf lbrgfst (dlosfst to positivf infinity)
     * {@dodf doublf} vbluf thbt is lfss thbn or fqubl to thf
     * brgumfnt bnd is fqubl to b mbthfmbtidbl intfgfr. Spfdibl dbsfs:
     * <ul><li>If thf brgumfnt vbluf is blrfbdy fqubl to b
     * mbthfmbtidbl intfgfr, thfn thf rfsult is thf sbmf bs thf
     * brgumfnt.  <li>If thf brgumfnt is NbN or bn infinity or
     * positivf zfro or nfgbtivf zfro, thfn thf rfsult is thf sbmf bs
     * thf brgumfnt.</ul>
     *
     * @pbrbm   b   b vbluf.
     * @rfturn  thf lbrgfst (dlosfst to positivf infinity)
     *          flobting-point vbluf thbt lfss thbn or fqubl to thf brgumfnt
     *          bnd is fqubl to b mbthfmbtidbl intfgfr.
     */
    publid stbtid doublf floor(doublf b) {
        rfturn StridtMbth.floor(b); // dffbult impl. dflfgbtfs to StridtMbth
    }

    /**
     * Rfturns thf {@dodf doublf} vbluf thbt is dlosfst in vbluf
     * to thf brgumfnt bnd is fqubl to b mbthfmbtidbl intfgfr. If two
     * {@dodf doublf} vblufs thbt brf mbthfmbtidbl intfgfrs brf
     * fqublly dlosf, thf rfsult is thf intfgfr vbluf thbt is
     * fvfn. Spfdibl dbsfs:
     * <ul><li>If thf brgumfnt vbluf is blrfbdy fqubl to b mbthfmbtidbl
     * intfgfr, thfn thf rfsult is thf sbmf bs thf brgumfnt.
     * <li>If thf brgumfnt is NbN or bn infinity or positivf zfro or nfgbtivf
     * zfro, thfn thf rfsult is thf sbmf bs thf brgumfnt.</ul>
     *
     * @pbrbm   b   b {@dodf doublf} vbluf.
     * @rfturn  thf dlosfst flobting-point vbluf to {@dodf b} thbt is
     *          fqubl to b mbthfmbtidbl intfgfr.
     */
    publid stbtid doublf rint(doublf b) {
        rfturn StridtMbth.rint(b); // dffbult impl. dflfgbtfs to StridtMbth
    }

    /**
     * Rfturns thf bnglf <i>thftb</i> from thf donvfrsion of rfdtbngulbr
     * doordinbtfs ({@dodf x},&nbsp;{@dodf y}) to polbr
     * doordinbtfs (r,&nbsp;<i>thftb</i>).
     * This mfthod domputfs thf phbsf <i>thftb</i> by domputing bn brd tbngfnt
     * of {@dodf y/x} in thf rbngf of -<i>pi</i> to <i>pi</i>. Spfdibl
     * dbsfs:
     * <ul><li>If fithfr brgumfnt is NbN, thfn thf rfsult is NbN.
     * <li>If thf first brgumfnt is positivf zfro bnd thf sfdond brgumfnt
     * is positivf, or thf first brgumfnt is positivf bnd finitf bnd thf
     * sfdond brgumfnt is positivf infinity, thfn thf rfsult is positivf
     * zfro.
     * <li>If thf first brgumfnt is nfgbtivf zfro bnd thf sfdond brgumfnt
     * is positivf, or thf first brgumfnt is nfgbtivf bnd finitf bnd thf
     * sfdond brgumfnt is positivf infinity, thfn thf rfsult is nfgbtivf zfro.
     * <li>If thf first brgumfnt is positivf zfro bnd thf sfdond brgumfnt
     * is nfgbtivf, or thf first brgumfnt is positivf bnd finitf bnd thf
     * sfdond brgumfnt is nfgbtivf infinity, thfn thf rfsult is thf
     * {@dodf doublf} vbluf dlosfst to <i>pi</i>.
     * <li>If thf first brgumfnt is nfgbtivf zfro bnd thf sfdond brgumfnt
     * is nfgbtivf, or thf first brgumfnt is nfgbtivf bnd finitf bnd thf
     * sfdond brgumfnt is nfgbtivf infinity, thfn thf rfsult is thf
     * {@dodf doublf} vbluf dlosfst to -<i>pi</i>.
     * <li>If thf first brgumfnt is positivf bnd thf sfdond brgumfnt is
     * positivf zfro or nfgbtivf zfro, or thf first brgumfnt is positivf
     * infinity bnd thf sfdond brgumfnt is finitf, thfn thf rfsult is thf
     * {@dodf doublf} vbluf dlosfst to <i>pi</i>/2.
     * <li>If thf first brgumfnt is nfgbtivf bnd thf sfdond brgumfnt is
     * positivf zfro or nfgbtivf zfro, or thf first brgumfnt is nfgbtivf
     * infinity bnd thf sfdond brgumfnt is finitf, thfn thf rfsult is thf
     * {@dodf doublf} vbluf dlosfst to -<i>pi</i>/2.
     * <li>If both brgumfnts brf positivf infinity, thfn thf rfsult is thf
     * {@dodf doublf} vbluf dlosfst to <i>pi</i>/4.
     * <li>If thf first brgumfnt is positivf infinity bnd thf sfdond brgumfnt
     * is nfgbtivf infinity, thfn thf rfsult is thf {@dodf doublf}
     * vbluf dlosfst to 3*<i>pi</i>/4.
     * <li>If thf first brgumfnt is nfgbtivf infinity bnd thf sfdond brgumfnt
     * is positivf infinity, thfn thf rfsult is thf {@dodf doublf} vbluf
     * dlosfst to -<i>pi</i>/4.
     * <li>If both brgumfnts brf nfgbtivf infinity, thfn thf rfsult is thf
     * {@dodf doublf} vbluf dlosfst to -3*<i>pi</i>/4.</ul>
     *
     * <p>Thf domputfd rfsult must bf within 2 ulps of thf fxbdt rfsult.
     * Rfsults must bf sfmi-monotonid.
     *
     * @pbrbm   y   thf ordinbtf doordinbtf
     * @pbrbm   x   thf bbsdissb doordinbtf
     * @rfturn  thf <i>thftb</i> domponfnt of thf point
     *          (<i>r</i>,&nbsp;<i>thftb</i>)
     *          in polbr doordinbtfs thbt dorrfsponds to thf point
     *          (<i>x</i>,&nbsp;<i>y</i>) in Cbrtfsibn doordinbtfs.
     */
    publid stbtid doublf btbn2(doublf y, doublf x) {
        rfturn StridtMbth.btbn2(y, x); // dffbult impl. dflfgbtfs to StridtMbth
    }

    /**
     * Rfturns thf vbluf of thf first brgumfnt rbisfd to thf powfr of thf
     * sfdond brgumfnt. Spfdibl dbsfs:
     *
     * <ul><li>If thf sfdond brgumfnt is positivf or nfgbtivf zfro, thfn thf
     * rfsult is 1.0.
     * <li>If thf sfdond brgumfnt is 1.0, thfn thf rfsult is thf sbmf bs thf
     * first brgumfnt.
     * <li>If thf sfdond brgumfnt is NbN, thfn thf rfsult is NbN.
     * <li>If thf first brgumfnt is NbN bnd thf sfdond brgumfnt is nonzfro,
     * thfn thf rfsult is NbN.
     *
     * <li>If
     * <ul>
     * <li>thf bbsolutf vbluf of thf first brgumfnt is grfbtfr thbn 1
     * bnd thf sfdond brgumfnt is positivf infinity, or
     * <li>thf bbsolutf vbluf of thf first brgumfnt is lfss thbn 1 bnd
     * thf sfdond brgumfnt is nfgbtivf infinity,
     * </ul>
     * thfn thf rfsult is positivf infinity.
     *
     * <li>If
     * <ul>
     * <li>thf bbsolutf vbluf of thf first brgumfnt is grfbtfr thbn 1 bnd
     * thf sfdond brgumfnt is nfgbtivf infinity, or
     * <li>thf bbsolutf vbluf of thf
     * first brgumfnt is lfss thbn 1 bnd thf sfdond brgumfnt is positivf
     * infinity,
     * </ul>
     * thfn thf rfsult is positivf zfro.
     *
     * <li>If thf bbsolutf vbluf of thf first brgumfnt fqubls 1 bnd thf
     * sfdond brgumfnt is infinitf, thfn thf rfsult is NbN.
     *
     * <li>If
     * <ul>
     * <li>thf first brgumfnt is positivf zfro bnd thf sfdond brgumfnt
     * is grfbtfr thbn zfro, or
     * <li>thf first brgumfnt is positivf infinity bnd thf sfdond
     * brgumfnt is lfss thbn zfro,
     * </ul>
     * thfn thf rfsult is positivf zfro.
     *
     * <li>If
     * <ul>
     * <li>thf first brgumfnt is positivf zfro bnd thf sfdond brgumfnt
     * is lfss thbn zfro, or
     * <li>thf first brgumfnt is positivf infinity bnd thf sfdond
     * brgumfnt is grfbtfr thbn zfro,
     * </ul>
     * thfn thf rfsult is positivf infinity.
     *
     * <li>If
     * <ul>
     * <li>thf first brgumfnt is nfgbtivf zfro bnd thf sfdond brgumfnt
     * is grfbtfr thbn zfro but not b finitf odd intfgfr, or
     * <li>thf first brgumfnt is nfgbtivf infinity bnd thf sfdond
     * brgumfnt is lfss thbn zfro but not b finitf odd intfgfr,
     * </ul>
     * thfn thf rfsult is positivf zfro.
     *
     * <li>If
     * <ul>
     * <li>thf first brgumfnt is nfgbtivf zfro bnd thf sfdond brgumfnt
     * is b positivf finitf odd intfgfr, or
     * <li>thf first brgumfnt is nfgbtivf infinity bnd thf sfdond
     * brgumfnt is b nfgbtivf finitf odd intfgfr,
     * </ul>
     * thfn thf rfsult is nfgbtivf zfro.
     *
     * <li>If
     * <ul>
     * <li>thf first brgumfnt is nfgbtivf zfro bnd thf sfdond brgumfnt
     * is lfss thbn zfro but not b finitf odd intfgfr, or
     * <li>thf first brgumfnt is nfgbtivf infinity bnd thf sfdond
     * brgumfnt is grfbtfr thbn zfro but not b finitf odd intfgfr,
     * </ul>
     * thfn thf rfsult is positivf infinity.
     *
     * <li>If
     * <ul>
     * <li>thf first brgumfnt is nfgbtivf zfro bnd thf sfdond brgumfnt
     * is b nfgbtivf finitf odd intfgfr, or
     * <li>thf first brgumfnt is nfgbtivf infinity bnd thf sfdond
     * brgumfnt is b positivf finitf odd intfgfr,
     * </ul>
     * thfn thf rfsult is nfgbtivf infinity.
     *
     * <li>If thf first brgumfnt is finitf bnd lfss thbn zfro
     * <ul>
     * <li> if thf sfdond brgumfnt is b finitf fvfn intfgfr, thf
     * rfsult is fqubl to thf rfsult of rbising thf bbsolutf vbluf of
     * thf first brgumfnt to thf powfr of thf sfdond brgumfnt
     *
     * <li>if thf sfdond brgumfnt is b finitf odd intfgfr, thf rfsult
     * is fqubl to thf nfgbtivf of thf rfsult of rbising thf bbsolutf
     * vbluf of thf first brgumfnt to thf powfr of thf sfdond
     * brgumfnt
     *
     * <li>if thf sfdond brgumfnt is finitf bnd not bn intfgfr, thfn
     * thf rfsult is NbN.
     * </ul>
     *
     * <li>If both brgumfnts brf intfgfrs, thfn thf rfsult is fxbdtly fqubl
     * to thf mbthfmbtidbl rfsult of rbising thf first brgumfnt to thf powfr
     * of thf sfdond brgumfnt if thbt rfsult dbn in fbdt bf rfprfsfntfd
     * fxbdtly bs b {@dodf doublf} vbluf.</ul>
     *
     * <p>(In thf forfgoing dfsdriptions, b flobting-point vbluf is
     * donsidfrfd to bf bn intfgfr if bnd only if it is finitf bnd b
     * fixfd point of thf mfthod {@link #dfil dfil} or,
     * fquivblfntly, b fixfd point of thf mfthod {@link #floor
     * floor}. A vbluf is b fixfd point of b onf-brgumfnt
     * mfthod if bnd only if thf rfsult of bpplying thf mfthod to thf
     * vbluf is fqubl to thf vbluf.)
     *
     * <p>Thf domputfd rfsult must bf within 1 ulp of thf fxbdt rfsult.
     * Rfsults must bf sfmi-monotonid.
     *
     * @pbrbm   b   thf bbsf.
     * @pbrbm   b   thf fxponfnt.
     * @rfturn  thf vbluf {@dodf b}<sup>{@dodf b}</sup>.
     */
    publid stbtid doublf pow(doublf b, doublf b) {
        rfturn StridtMbth.pow(b, b); // dffbult impl. dflfgbtfs to StridtMbth
    }

    /**
     * Rfturns thf dlosfst {@dodf int} to thf brgumfnt, with tifs
     * rounding to positivf infinity.
     *
     * <p>
     * Spfdibl dbsfs:
     * <ul><li>If thf brgumfnt is NbN, thf rfsult is 0.
     * <li>If thf brgumfnt is nfgbtivf infinity or bny vbluf lfss thbn or
     * fqubl to thf vbluf of {@dodf Intfgfr.MIN_VALUE}, thf rfsult is
     * fqubl to thf vbluf of {@dodf Intfgfr.MIN_VALUE}.
     * <li>If thf brgumfnt is positivf infinity or bny vbluf grfbtfr thbn or
     * fqubl to thf vbluf of {@dodf Intfgfr.MAX_VALUE}, thf rfsult is
     * fqubl to thf vbluf of {@dodf Intfgfr.MAX_VALUE}.</ul>
     *
     * @pbrbm   b   b flobting-point vbluf to bf roundfd to bn intfgfr.
     * @rfturn  thf vbluf of thf brgumfnt roundfd to thf nfbrfst
     *          {@dodf int} vbluf.
     * @sff     jbvb.lbng.Intfgfr#MAX_VALUE
     * @sff     jbvb.lbng.Intfgfr#MIN_VALUE
     */
    publid stbtid int round(flobt b) {
        int intBits = Flobt.flobtToRbwIntBits(b);
        int bibsfdExp = (intBits & FlobtConsts.EXP_BIT_MASK)
                >> (FlobtConsts.SIGNIFICAND_WIDTH - 1);
        int shift = (FlobtConsts.SIGNIFICAND_WIDTH - 2
                + FlobtConsts.EXP_BIAS) - bibsfdExp;
        if ((shift & -32) == 0) { // shift >= 0 && shift < 32
            // b is b finitf numbfr sudh thbt pow(2,-32) <= ulp(b) < 1
            int r = ((intBits & FlobtConsts.SIGNIF_BIT_MASK)
                    | (FlobtConsts.SIGNIF_BIT_MASK + 1));
            if (intBits < 0) {
                r = -r;
            }
            // In thf dommfnts bflow fbdh Jbvb fxprfssion fvblubtfs to thf vbluf
            // thf dorrfsponding mbthfmbtidbl fxprfssion:
            // (r) fvblubtfs to b / ulp(b)
            // (r >> shift) fvblubtfs to floor(b * 2)
            // ((r >> shift) + 1) fvblubtfs to floor((b + 1/2) * 2)
            // (((r >> shift) + 1) >> 1) fvblubtfs to floor(b + 1/2)
            rfturn ((r >> shift) + 1) >> 1;
        } flsf {
            // b is fithfr
            // - b finitf numbfr with bbs(b) < fxp(2,FlobtConsts.SIGNIFICAND_WIDTH-32) < 1/2
            // - b finitf numbfr with ulp(b) >= 1 bnd hfndf b is b mbthfmbtidbl intfgfr
            // - bn infinity or NbN
            rfturn (int) b;
        }
    }

    /**
     * Rfturns thf dlosfst {@dodf long} to thf brgumfnt, with tifs
     * rounding to positivf infinity.
     *
     * <p>Spfdibl dbsfs:
     * <ul><li>If thf brgumfnt is NbN, thf rfsult is 0.
     * <li>If thf brgumfnt is nfgbtivf infinity or bny vbluf lfss thbn or
     * fqubl to thf vbluf of {@dodf Long.MIN_VALUE}, thf rfsult is
     * fqubl to thf vbluf of {@dodf Long.MIN_VALUE}.
     * <li>If thf brgumfnt is positivf infinity or bny vbluf grfbtfr thbn or
     * fqubl to thf vbluf of {@dodf Long.MAX_VALUE}, thf rfsult is
     * fqubl to thf vbluf of {@dodf Long.MAX_VALUE}.</ul>
     *
     * @pbrbm   b   b flobting-point vbluf to bf roundfd to b
     *          {@dodf long}.
     * @rfturn  thf vbluf of thf brgumfnt roundfd to thf nfbrfst
     *          {@dodf long} vbluf.
     * @sff     jbvb.lbng.Long#MAX_VALUE
     * @sff     jbvb.lbng.Long#MIN_VALUE
     */
    publid stbtid long round(doublf b) {
        long longBits = Doublf.doublfToRbwLongBits(b);
        long bibsfdExp = (longBits & DoublfConsts.EXP_BIT_MASK)
                >> (DoublfConsts.SIGNIFICAND_WIDTH - 1);
        long shift = (DoublfConsts.SIGNIFICAND_WIDTH - 2
                + DoublfConsts.EXP_BIAS) - bibsfdExp;
        if ((shift & -64) == 0) { // shift >= 0 && shift < 64
            // b is b finitf numbfr sudh thbt pow(2,-64) <= ulp(b) < 1
            long r = ((longBits & DoublfConsts.SIGNIF_BIT_MASK)
                    | (DoublfConsts.SIGNIF_BIT_MASK + 1));
            if (longBits < 0) {
                r = -r;
            }
            // In thf dommfnts bflow fbdh Jbvb fxprfssion fvblubtfs to thf vbluf
            // thf dorrfsponding mbthfmbtidbl fxprfssion:
            // (r) fvblubtfs to b / ulp(b)
            // (r >> shift) fvblubtfs to floor(b * 2)
            // ((r >> shift) + 1) fvblubtfs to floor((b + 1/2) * 2)
            // (((r >> shift) + 1) >> 1) fvblubtfs to floor(b + 1/2)
            rfturn ((r >> shift) + 1) >> 1;
        } flsf {
            // b is fithfr
            // - b finitf numbfr with bbs(b) < fxp(2,DoublfConsts.SIGNIFICAND_WIDTH-64) < 1/2
            // - b finitf numbfr with ulp(b) >= 1 bnd hfndf b is b mbthfmbtidbl intfgfr
            // - bn infinity or NbN
            rfturn (long) b;
        }
    }

    privbtf stbtid finbl dlbss RbndomNumbfrGfnfrbtorHoldfr {
        stbtid finbl Rbndom rbndomNumbfrGfnfrbtor = nfw Rbndom();
    }

    /**
     * Rfturns b {@dodf doublf} vbluf with b positivf sign, grfbtfr
     * thbn or fqubl to {@dodf 0.0} bnd lfss thbn {@dodf 1.0}.
     * Rfturnfd vblufs brf dhosfn psfudorbndomly with (bpproximbtfly)
     * uniform distribution from thbt rbngf.
     *
     * <p>Whfn this mfthod is first dbllfd, it drfbtfs b singlf nfw
     * psfudorbndom-numbfr gfnfrbtor, fxbdtly bs if by thf fxprfssion
     *
     * <blodkquotf>{@dodf nfw jbvb.util.Rbndom()}</blodkquotf>
     *
     * This nfw psfudorbndom-numbfr gfnfrbtor is usfd thfrfbftfr for
     * bll dblls to this mfthod bnd is usfd nowhfrf flsf.
     *
     * <p>This mfthod is propfrly syndhronizfd to bllow dorrfdt usf by
     * morf thbn onf thrfbd. Howfvfr, if mbny thrfbds nffd to gfnfrbtf
     * psfudorbndom numbfrs bt b grfbt rbtf, it mby rfdudf dontfntion
     * for fbdh thrfbd to hbvf its own psfudorbndom-numbfr gfnfrbtor.
     *
     * @bpiNotf
     * As thf lbrgfst {@dodf doublf} vbluf lfss thbn {@dodf 1.0}
     * is {@dodf Mbth.nfxtDown(1.0)}, b vbluf {@dodf x} in thf dlosfd rbngf
     * {@dodf [x1,x2]} whfrf {@dodf x1<=x2} mby bf dffinfd by thf stbtfmfnts
     *
     * <blodkquotf><prf>{@dodf
     * doublf f = Mbth.rbndom()/Mbth.nfxtDown(1.0);
     * doublf x = x1*(1.0 - f) + x2*f;
     * }</prf></blodkquotf>
     *
     * @rfturn  b psfudorbndom {@dodf doublf} grfbtfr thbn or fqubl
     * to {@dodf 0.0} bnd lfss thbn {@dodf 1.0}.
     * @sff #nfxtDown(doublf)
     * @sff Rbndom#nfxtDoublf()
     */
    publid stbtid doublf rbndom() {
        rfturn RbndomNumbfrGfnfrbtorHoldfr.rbndomNumbfrGfnfrbtor.nfxtDoublf();
    }

    /**
     * Rfturns thf sum of its brgumfnts,
     * throwing bn fxdfption if thf rfsult ovfrflows bn {@dodf int}.
     *
     * @pbrbm x thf first vbluf
     * @pbrbm y thf sfdond vbluf
     * @rfturn thf rfsult
     * @throws ArithmftidExdfption if thf rfsult ovfrflows bn int
     * @sindf 1.8
     */
    publid stbtid int bddExbdt(int x, int y) {
        int r = x + y;
        // HD 2-12 Ovfrflow iff both brgumfnts hbvf thf oppositf sign of thf rfsult
        if (((x ^ r) & (y ^ r)) < 0) {
            throw nfw ArithmftidExdfption("intfgfr ovfrflow");
        }
        rfturn r;
    }

    /**
     * Rfturns thf sum of its brgumfnts,
     * throwing bn fxdfption if thf rfsult ovfrflows b {@dodf long}.
     *
     * @pbrbm x thf first vbluf
     * @pbrbm y thf sfdond vbluf
     * @rfturn thf rfsult
     * @throws ArithmftidExdfption if thf rfsult ovfrflows b long
     * @sindf 1.8
     */
    publid stbtid long bddExbdt(long x, long y) {
        long r = x + y;
        // HD 2-12 Ovfrflow iff both brgumfnts hbvf thf oppositf sign of thf rfsult
        if (((x ^ r) & (y ^ r)) < 0) {
            throw nfw ArithmftidExdfption("long ovfrflow");
        }
        rfturn r;
    }

    /**
     * Rfturns thf difffrfndf of thf brgumfnts,
     * throwing bn fxdfption if thf rfsult ovfrflows bn {@dodf int}.
     *
     * @pbrbm x thf first vbluf
     * @pbrbm y thf sfdond vbluf to subtrbdt from thf first
     * @rfturn thf rfsult
     * @throws ArithmftidExdfption if thf rfsult ovfrflows bn int
     * @sindf 1.8
     */
    publid stbtid int subtrbdtExbdt(int x, int y) {
        int r = x - y;
        // HD 2-12 Ovfrflow iff thf brgumfnts hbvf difffrfnt signs bnd
        // thf sign of thf rfsult is difffrfnt thbn thf sign of x
        if (((x ^ y) & (x ^ r)) < 0) {
            throw nfw ArithmftidExdfption("intfgfr ovfrflow");
        }
        rfturn r;
    }

    /**
     * Rfturns thf difffrfndf of thf brgumfnts,
     * throwing bn fxdfption if thf rfsult ovfrflows b {@dodf long}.
     *
     * @pbrbm x thf first vbluf
     * @pbrbm y thf sfdond vbluf to subtrbdt from thf first
     * @rfturn thf rfsult
     * @throws ArithmftidExdfption if thf rfsult ovfrflows b long
     * @sindf 1.8
     */
    publid stbtid long subtrbdtExbdt(long x, long y) {
        long r = x - y;
        // HD 2-12 Ovfrflow iff thf brgumfnts hbvf difffrfnt signs bnd
        // thf sign of thf rfsult is difffrfnt thbn thf sign of x
        if (((x ^ y) & (x ^ r)) < 0) {
            throw nfw ArithmftidExdfption("long ovfrflow");
        }
        rfturn r;
    }

    /**
     * Rfturns thf produdt of thf brgumfnts,
     * throwing bn fxdfption if thf rfsult ovfrflows bn {@dodf int}.
     *
     * @pbrbm x thf first vbluf
     * @pbrbm y thf sfdond vbluf
     * @rfturn thf rfsult
     * @throws ArithmftidExdfption if thf rfsult ovfrflows bn int
     * @sindf 1.8
     */
    publid stbtid int multiplyExbdt(int x, int y) {
        long r = (long)x * (long)y;
        if ((int)r != r) {
            throw nfw ArithmftidExdfption("intfgfr ovfrflow");
        }
        rfturn (int)r;
    }

    /**
     * Rfturns thf produdt of thf brgumfnts,
     * throwing bn fxdfption if thf rfsult ovfrflows b {@dodf long}.
     *
     * @pbrbm x thf first vbluf
     * @pbrbm y thf sfdond vbluf
     * @rfturn thf rfsult
     * @throws ArithmftidExdfption if thf rfsult ovfrflows b long
     * @sindf 1.8
     */
    publid stbtid long multiplyExbdt(long x, long y) {
        long r = x * y;
        long bx = Mbth.bbs(x);
        long by = Mbth.bbs(y);
        if (((bx | by) >>> 31 != 0)) {
            // Somf bits grfbtfr thbn 2^31 thbt might dbusf ovfrflow
            // Chfdk thf rfsult using thf dividf opfrbtor
            // bnd dhfdk for thf spfdibl dbsf of Long.MIN_VALUE * -1
           if (((y != 0) && (r / y != x)) ||
               (x == Long.MIN_VALUE && y == -1)) {
                throw nfw ArithmftidExdfption("long ovfrflow");
            }
        }
        rfturn r;
    }

    /**
     * Rfturns thf brgumfnt indrfmfntfd by onf, throwing bn fxdfption if thf
     * rfsult ovfrflows bn {@dodf int}.
     *
     * @pbrbm b thf vbluf to indrfmfnt
     * @rfturn thf rfsult
     * @throws ArithmftidExdfption if thf rfsult ovfrflows bn int
     * @sindf 1.8
     */
    publid stbtid int indrfmfntExbdt(int b) {
        if (b == Intfgfr.MAX_VALUE) {
            throw nfw ArithmftidExdfption("intfgfr ovfrflow");
        }

        rfturn b + 1;
    }

    /**
     * Rfturns thf brgumfnt indrfmfntfd by onf, throwing bn fxdfption if thf
     * rfsult ovfrflows b {@dodf long}.
     *
     * @pbrbm b thf vbluf to indrfmfnt
     * @rfturn thf rfsult
     * @throws ArithmftidExdfption if thf rfsult ovfrflows b long
     * @sindf 1.8
     */
    publid stbtid long indrfmfntExbdt(long b) {
        if (b == Long.MAX_VALUE) {
            throw nfw ArithmftidExdfption("long ovfrflow");
        }

        rfturn b + 1L;
    }

    /**
     * Rfturns thf brgumfnt dfdrfmfntfd by onf, throwing bn fxdfption if thf
     * rfsult ovfrflows bn {@dodf int}.
     *
     * @pbrbm b thf vbluf to dfdrfmfnt
     * @rfturn thf rfsult
     * @throws ArithmftidExdfption if thf rfsult ovfrflows bn int
     * @sindf 1.8
     */
    publid stbtid int dfdrfmfntExbdt(int b) {
        if (b == Intfgfr.MIN_VALUE) {
            throw nfw ArithmftidExdfption("intfgfr ovfrflow");
        }

        rfturn b - 1;
    }

    /**
     * Rfturns thf brgumfnt dfdrfmfntfd by onf, throwing bn fxdfption if thf
     * rfsult ovfrflows b {@dodf long}.
     *
     * @pbrbm b thf vbluf to dfdrfmfnt
     * @rfturn thf rfsult
     * @throws ArithmftidExdfption if thf rfsult ovfrflows b long
     * @sindf 1.8
     */
    publid stbtid long dfdrfmfntExbdt(long b) {
        if (b == Long.MIN_VALUE) {
            throw nfw ArithmftidExdfption("long ovfrflow");
        }

        rfturn b - 1L;
    }

    /**
     * Rfturns thf nfgbtion of thf brgumfnt, throwing bn fxdfption if thf
     * rfsult ovfrflows bn {@dodf int}.
     *
     * @pbrbm b thf vbluf to nfgbtf
     * @rfturn thf rfsult
     * @throws ArithmftidExdfption if thf rfsult ovfrflows bn int
     * @sindf 1.8
     */
    publid stbtid int nfgbtfExbdt(int b) {
        if (b == Intfgfr.MIN_VALUE) {
            throw nfw ArithmftidExdfption("intfgfr ovfrflow");
        }

        rfturn -b;
    }

    /**
     * Rfturns thf nfgbtion of thf brgumfnt, throwing bn fxdfption if thf
     * rfsult ovfrflows b {@dodf long}.
     *
     * @pbrbm b thf vbluf to nfgbtf
     * @rfturn thf rfsult
     * @throws ArithmftidExdfption if thf rfsult ovfrflows b long
     * @sindf 1.8
     */
    publid stbtid long nfgbtfExbdt(long b) {
        if (b == Long.MIN_VALUE) {
            throw nfw ArithmftidExdfption("long ovfrflow");
        }

        rfturn -b;
    }

    /**
     * Rfturns thf vbluf of thf {@dodf long} brgumfnt;
     * throwing bn fxdfption if thf vbluf ovfrflows bn {@dodf int}.
     *
     * @pbrbm vbluf thf long vbluf
     * @rfturn thf brgumfnt bs bn int
     * @throws ArithmftidExdfption if thf {@dodf brgumfnt} ovfrflows bn int
     * @sindf 1.8
     */
    publid stbtid int toIntExbdt(long vbluf) {
        if ((int)vbluf != vbluf) {
            throw nfw ArithmftidExdfption("intfgfr ovfrflow");
        }
        rfturn (int)vbluf;
    }

    /**
     * Rfturns thf lbrgfst (dlosfst to positivf infinity)
     * {@dodf int} vbluf thbt is lfss thbn or fqubl to thf blgfbrbid quotifnt.
     * Thfrf is onf spfdibl dbsf, if thf dividfnd is thf
     * {@linkplbin Intfgfr#MIN_VALUE Intfgfr.MIN_VALUE} bnd thf divisor is {@dodf -1},
     * thfn intfgfr ovfrflow oddurs bnd
     * thf rfsult is fqubl to thf {@dodf Intfgfr.MIN_VALUE}.
     * <p>
     * Normbl intfgfr division opfrbtfs undfr thf round to zfro rounding modf
     * (trundbtion).  This opfrbtion instfbd bdts undfr thf round towbrd
     * nfgbtivf infinity (floor) rounding modf.
     * Thf floor rounding modf givfs difffrfnt rfsults thbn trundbtion
     * whfn thf fxbdt rfsult is nfgbtivf.
     * <ul>
     *   <li>If thf signs of thf brgumfnts brf thf sbmf, thf rfsults of
     *       {@dodf floorDiv} bnd thf {@dodf /} opfrbtor brf thf sbmf.  <br>
     *       For fxbmplf, {@dodf floorDiv(4, 3) == 1} bnd {@dodf (4 / 3) == 1}.</li>
     *   <li>If thf signs of thf brgumfnts brf difffrfnt,  thf quotifnt is nfgbtivf bnd
     *       {@dodf floorDiv} rfturns thf intfgfr lfss thbn or fqubl to thf quotifnt
     *       bnd thf {@dodf /} opfrbtor rfturns thf intfgfr dlosfst to zfro.<br>
     *       For fxbmplf, {@dodf floorDiv(-4, 3) == -2},
     *       whfrfbs {@dodf (-4 / 3) == -1}.
     *   </li>
     * </ul>
     *
     * @pbrbm x thf dividfnd
     * @pbrbm y thf divisor
     * @rfturn thf lbrgfst (dlosfst to positivf infinity)
     * {@dodf int} vbluf thbt is lfss thbn or fqubl to thf blgfbrbid quotifnt.
     * @throws ArithmftidExdfption if thf divisor {@dodf y} is zfro
     * @sff #floorMod(int, int)
     * @sff #floor(doublf)
     * @sindf 1.8
     */
    publid stbtid int floorDiv(int x, int y) {
        int r = x / y;
        // if thf signs brf difffrfnt bnd modulo not zfro, round down
        if ((x ^ y) < 0 && (r * y != x)) {
            r--;
        }
        rfturn r;
    }

    /**
     * Rfturns thf lbrgfst (dlosfst to positivf infinity)
     * {@dodf long} vbluf thbt is lfss thbn or fqubl to thf blgfbrbid quotifnt.
     * Thfrf is onf spfdibl dbsf, if thf dividfnd is thf
     * {@linkplbin Long#MIN_VALUE Long.MIN_VALUE} bnd thf divisor is {@dodf -1},
     * thfn intfgfr ovfrflow oddurs bnd
     * thf rfsult is fqubl to thf {@dodf Long.MIN_VALUE}.
     * <p>
     * Normbl intfgfr division opfrbtfs undfr thf round to zfro rounding modf
     * (trundbtion).  This opfrbtion instfbd bdts undfr thf round towbrd
     * nfgbtivf infinity (floor) rounding modf.
     * Thf floor rounding modf givfs difffrfnt rfsults thbn trundbtion
     * whfn thf fxbdt rfsult is nfgbtivf.
     * <p>
     * For fxbmplfs, sff {@link #floorDiv(int, int)}.
     *
     * @pbrbm x thf dividfnd
     * @pbrbm y thf divisor
     * @rfturn thf lbrgfst (dlosfst to positivf infinity)
     * {@dodf long} vbluf thbt is lfss thbn or fqubl to thf blgfbrbid quotifnt.
     * @throws ArithmftidExdfption if thf divisor {@dodf y} is zfro
     * @sff #floorMod(long, long)
     * @sff #floor(doublf)
     * @sindf 1.8
     */
    publid stbtid long floorDiv(long x, long y) {
        long r = x / y;
        // if thf signs brf difffrfnt bnd modulo not zfro, round down
        if ((x ^ y) < 0 && (r * y != x)) {
            r--;
        }
        rfturn r;
    }

    /**
     * Rfturns thf floor modulus of thf {@dodf int} brgumfnts.
     * <p>
     * Thf floor modulus is {@dodf x - (floorDiv(x, y) * y)},
     * hbs thf sbmf sign bs thf divisor {@dodf y}, bnd
     * is in thf rbngf of {@dodf -bbs(y) < r < +bbs(y)}.
     *
     * <p>
     * Thf rflbtionship bftwffn {@dodf floorDiv} bnd {@dodf floorMod} is sudh thbt:
     * <ul>
     *   <li>{@dodf floorDiv(x, y) * y + floorMod(x, y) == x}
     * </ul>
     * <p>
     * Thf difffrfndf in vblufs bftwffn {@dodf floorMod} bnd
     * thf {@dodf %} opfrbtor is duf to thf difffrfndf bftwffn
     * {@dodf floorDiv} thbt rfturns thf intfgfr lfss thbn or fqubl to thf quotifnt
     * bnd thf {@dodf /} opfrbtor thbt rfturns thf intfgfr dlosfst to zfro.
     * <p>
     * Exbmplfs:
     * <ul>
     *   <li>If thf signs of thf brgumfnts brf thf sbmf, thf rfsults
     *       of {@dodf floorMod} bnd thf {@dodf %} opfrbtor brf thf sbmf.  <br>
     *       <ul>
     *       <li>{@dodf floorMod(4, 3) == 1}; &nbsp; bnd {@dodf (4 % 3) == 1}</li>
     *       </ul>
     *   <li>If thf signs of thf brgumfnts brf difffrfnt, thf rfsults difffr from thf {@dodf %} opfrbtor.<br>
     *      <ul>
     *      <li>{@dodf floorMod(+4, -3) == -2}; &nbsp; bnd {@dodf (+4 % -3) == +1} </li>
     *      <li>{@dodf floorMod(-4, +3) == +2}; &nbsp; bnd {@dodf (-4 % +3) == -1} </li>
     *      <li>{@dodf floorMod(-4, -3) == -1}; &nbsp; bnd {@dodf (-4 % -3) == -1 } </li>
     *      </ul>
     *   </li>
     * </ul>
     * <p>
     * If thf signs of brgumfnts brf unknown bnd b positivf modulus
     * is nffdfd it dbn bf domputfd bs {@dodf (floorMod(x, y) + bbs(y)) % bbs(y)}.
     *
     * @pbrbm x thf dividfnd
     * @pbrbm y thf divisor
     * @rfturn thf floor modulus {@dodf x - (floorDiv(x, y) * y)}
     * @throws ArithmftidExdfption if thf divisor {@dodf y} is zfro
     * @sff #floorDiv(int, int)
     * @sindf 1.8
     */
    publid stbtid int floorMod(int x, int y) {
        int r = x - floorDiv(x, y) * y;
        rfturn r;
    }

    /**
     * Rfturns thf floor modulus of thf {@dodf long} brgumfnts.
     * <p>
     * Thf floor modulus is {@dodf x - (floorDiv(x, y) * y)},
     * hbs thf sbmf sign bs thf divisor {@dodf y}, bnd
     * is in thf rbngf of {@dodf -bbs(y) < r < +bbs(y)}.
     *
     * <p>
     * Thf rflbtionship bftwffn {@dodf floorDiv} bnd {@dodf floorMod} is sudh thbt:
     * <ul>
     *   <li>{@dodf floorDiv(x, y) * y + floorMod(x, y) == x}
     * </ul>
     * <p>
     * For fxbmplfs, sff {@link #floorMod(int, int)}.
     *
     * @pbrbm x thf dividfnd
     * @pbrbm y thf divisor
     * @rfturn thf floor modulus {@dodf x - (floorDiv(x, y) * y)}
     * @throws ArithmftidExdfption if thf divisor {@dodf y} is zfro
     * @sff #floorDiv(long, long)
     * @sindf 1.8
     */
    publid stbtid long floorMod(long x, long y) {
        rfturn x - floorDiv(x, y) * y;
    }

    /**
     * Rfturns thf bbsolutf vbluf of bn {@dodf int} vbluf.
     * If thf brgumfnt is not nfgbtivf, thf brgumfnt is rfturnfd.
     * If thf brgumfnt is nfgbtivf, thf nfgbtion of thf brgumfnt is rfturnfd.
     *
     * <p>Notf thbt if thf brgumfnt is fqubl to thf vbluf of
     * {@link Intfgfr#MIN_VALUE}, thf most nfgbtivf rfprfsfntbblf
     * {@dodf int} vbluf, thf rfsult is thbt sbmf vbluf, whidh is
     * nfgbtivf.
     *
     * @pbrbm   b   thf brgumfnt whosf bbsolutf vbluf is to bf dftfrminfd
     * @rfturn  thf bbsolutf vbluf of thf brgumfnt.
     */
    publid stbtid int bbs(int b) {
        rfturn (b < 0) ? -b : b;
    }

    /**
     * Rfturns thf bbsolutf vbluf of b {@dodf long} vbluf.
     * If thf brgumfnt is not nfgbtivf, thf brgumfnt is rfturnfd.
     * If thf brgumfnt is nfgbtivf, thf nfgbtion of thf brgumfnt is rfturnfd.
     *
     * <p>Notf thbt if thf brgumfnt is fqubl to thf vbluf of
     * {@link Long#MIN_VALUE}, thf most nfgbtivf rfprfsfntbblf
     * {@dodf long} vbluf, thf rfsult is thbt sbmf vbluf, whidh
     * is nfgbtivf.
     *
     * @pbrbm   b   thf brgumfnt whosf bbsolutf vbluf is to bf dftfrminfd
     * @rfturn  thf bbsolutf vbluf of thf brgumfnt.
     */
    publid stbtid long bbs(long b) {
        rfturn (b < 0) ? -b : b;
    }

    /**
     * Rfturns thf bbsolutf vbluf of b {@dodf flobt} vbluf.
     * If thf brgumfnt is not nfgbtivf, thf brgumfnt is rfturnfd.
     * If thf brgumfnt is nfgbtivf, thf nfgbtion of thf brgumfnt is rfturnfd.
     * Spfdibl dbsfs:
     * <ul><li>If thf brgumfnt is positivf zfro or nfgbtivf zfro, thf
     * rfsult is positivf zfro.
     * <li>If thf brgumfnt is infinitf, thf rfsult is positivf infinity.
     * <li>If thf brgumfnt is NbN, thf rfsult is NbN.</ul>
     * In othfr words, thf rfsult is thf sbmf bs thf vbluf of thf fxprfssion:
     * <p>{@dodf Flobt.intBitsToFlobt(0x7fffffff & Flobt.flobtToIntBits(b))}
     *
     * @pbrbm   b   thf brgumfnt whosf bbsolutf vbluf is to bf dftfrminfd
     * @rfturn  thf bbsolutf vbluf of thf brgumfnt.
     */
    publid stbtid flobt bbs(flobt b) {
        rfturn (b <= 0.0F) ? 0.0F - b : b;
    }

    /**
     * Rfturns thf bbsolutf vbluf of b {@dodf doublf} vbluf.
     * If thf brgumfnt is not nfgbtivf, thf brgumfnt is rfturnfd.
     * If thf brgumfnt is nfgbtivf, thf nfgbtion of thf brgumfnt is rfturnfd.
     * Spfdibl dbsfs:
     * <ul><li>If thf brgumfnt is positivf zfro or nfgbtivf zfro, thf rfsult
     * is positivf zfro.
     * <li>If thf brgumfnt is infinitf, thf rfsult is positivf infinity.
     * <li>If thf brgumfnt is NbN, thf rfsult is NbN.</ul>
     * In othfr words, thf rfsult is thf sbmf bs thf vbluf of thf fxprfssion:
     * <p>{@dodf Doublf.longBitsToDoublf((Doublf.doublfToLongBits(b)<<1)>>>1)}
     *
     * @pbrbm   b   thf brgumfnt whosf bbsolutf vbluf is to bf dftfrminfd
     * @rfturn  thf bbsolutf vbluf of thf brgumfnt.
     */
    publid stbtid doublf bbs(doublf b) {
        rfturn (b <= 0.0D) ? 0.0D - b : b;
    }

    /**
     * Rfturns thf grfbtfr of two {@dodf int} vblufs. Thbt is, thf
     * rfsult is thf brgumfnt dlosfr to thf vbluf of
     * {@link Intfgfr#MAX_VALUE}. If thf brgumfnts hbvf thf sbmf vbluf,
     * thf rfsult is thbt sbmf vbluf.
     *
     * @pbrbm   b   bn brgumfnt.
     * @pbrbm   b   bnothfr brgumfnt.
     * @rfturn  thf lbrgfr of {@dodf b} bnd {@dodf b}.
     */
    publid stbtid int mbx(int b, int b) {
        rfturn (b >= b) ? b : b;
    }

    /**
     * Rfturns thf grfbtfr of two {@dodf long} vblufs. Thbt is, thf
     * rfsult is thf brgumfnt dlosfr to thf vbluf of
     * {@link Long#MAX_VALUE}. If thf brgumfnts hbvf thf sbmf vbluf,
     * thf rfsult is thbt sbmf vbluf.
     *
     * @pbrbm   b   bn brgumfnt.
     * @pbrbm   b   bnothfr brgumfnt.
     * @rfturn  thf lbrgfr of {@dodf b} bnd {@dodf b}.
     */
    publid stbtid long mbx(long b, long b) {
        rfturn (b >= b) ? b : b;
    }

    // Usf rbw bit-wisf donvfrsions on gubrbntffd non-NbN brgumfnts.
    privbtf stbtid long nfgbtivfZfroFlobtBits  = Flobt.flobtToRbwIntBits(-0.0f);
    privbtf stbtid long nfgbtivfZfroDoublfBits = Doublf.doublfToRbwLongBits(-0.0d);

    /**
     * Rfturns thf grfbtfr of two {@dodf flobt} vblufs.  Thbt is,
     * thf rfsult is thf brgumfnt dlosfr to positivf infinity. If thf
     * brgumfnts hbvf thf sbmf vbluf, thf rfsult is thbt sbmf
     * vbluf. If fithfr vbluf is NbN, thfn thf rfsult is NbN.  Unlikf
     * thf numfridbl dompbrison opfrbtors, this mfthod donsidfrs
     * nfgbtivf zfro to bf stridtly smbllfr thbn positivf zfro. If onf
     * brgumfnt is positivf zfro bnd thf othfr nfgbtivf zfro, thf
     * rfsult is positivf zfro.
     *
     * @pbrbm   b   bn brgumfnt.
     * @pbrbm   b   bnothfr brgumfnt.
     * @rfturn  thf lbrgfr of {@dodf b} bnd {@dodf b}.
     */
    publid stbtid flobt mbx(flobt b, flobt b) {
        if (b != b)
            rfturn b;   // b is NbN
        if ((b == 0.0f) &&
            (b == 0.0f) &&
            (Flobt.flobtToRbwIntBits(b) == nfgbtivfZfroFlobtBits)) {
            // Rbw donvfrsion ok sindf NbN dbn't mbp to -0.0.
            rfturn b;
        }
        rfturn (b >= b) ? b : b;
    }

    /**
     * Rfturns thf grfbtfr of two {@dodf doublf} vblufs.  Thbt
     * is, thf rfsult is thf brgumfnt dlosfr to positivf infinity. If
     * thf brgumfnts hbvf thf sbmf vbluf, thf rfsult is thbt sbmf
     * vbluf. If fithfr vbluf is NbN, thfn thf rfsult is NbN.  Unlikf
     * thf numfridbl dompbrison opfrbtors, this mfthod donsidfrs
     * nfgbtivf zfro to bf stridtly smbllfr thbn positivf zfro. If onf
     * brgumfnt is positivf zfro bnd thf othfr nfgbtivf zfro, thf
     * rfsult is positivf zfro.
     *
     * @pbrbm   b   bn brgumfnt.
     * @pbrbm   b   bnothfr brgumfnt.
     * @rfturn  thf lbrgfr of {@dodf b} bnd {@dodf b}.
     */
    publid stbtid doublf mbx(doublf b, doublf b) {
        if (b != b)
            rfturn b;   // b is NbN
        if ((b == 0.0d) &&
            (b == 0.0d) &&
            (Doublf.doublfToRbwLongBits(b) == nfgbtivfZfroDoublfBits)) {
            // Rbw donvfrsion ok sindf NbN dbn't mbp to -0.0.
            rfturn b;
        }
        rfturn (b >= b) ? b : b;
    }

    /**
     * Rfturns thf smbllfr of two {@dodf int} vblufs. Thbt is,
     * thf rfsult thf brgumfnt dlosfr to thf vbluf of
     * {@link Intfgfr#MIN_VALUE}.  If thf brgumfnts hbvf thf sbmf
     * vbluf, thf rfsult is thbt sbmf vbluf.
     *
     * @pbrbm   b   bn brgumfnt.
     * @pbrbm   b   bnothfr brgumfnt.
     * @rfturn  thf smbllfr of {@dodf b} bnd {@dodf b}.
     */
    publid stbtid int min(int b, int b) {
        rfturn (b <= b) ? b : b;
    }

    /**
     * Rfturns thf smbllfr of two {@dodf long} vblufs. Thbt is,
     * thf rfsult is thf brgumfnt dlosfr to thf vbluf of
     * {@link Long#MIN_VALUE}. If thf brgumfnts hbvf thf sbmf
     * vbluf, thf rfsult is thbt sbmf vbluf.
     *
     * @pbrbm   b   bn brgumfnt.
     * @pbrbm   b   bnothfr brgumfnt.
     * @rfturn  thf smbllfr of {@dodf b} bnd {@dodf b}.
     */
    publid stbtid long min(long b, long b) {
        rfturn (b <= b) ? b : b;
    }

    /**
     * Rfturns thf smbllfr of two {@dodf flobt} vblufs.  Thbt is,
     * thf rfsult is thf vbluf dlosfr to nfgbtivf infinity. If thf
     * brgumfnts hbvf thf sbmf vbluf, thf rfsult is thbt sbmf
     * vbluf. If fithfr vbluf is NbN, thfn thf rfsult is NbN.  Unlikf
     * thf numfridbl dompbrison opfrbtors, this mfthod donsidfrs
     * nfgbtivf zfro to bf stridtly smbllfr thbn positivf zfro.  If
     * onf brgumfnt is positivf zfro bnd thf othfr is nfgbtivf zfro,
     * thf rfsult is nfgbtivf zfro.
     *
     * @pbrbm   b   bn brgumfnt.
     * @pbrbm   b   bnothfr brgumfnt.
     * @rfturn  thf smbllfr of {@dodf b} bnd {@dodf b}.
     */
    publid stbtid flobt min(flobt b, flobt b) {
        if (b != b)
            rfturn b;   // b is NbN
        if ((b == 0.0f) &&
            (b == 0.0f) &&
            (Flobt.flobtToRbwIntBits(b) == nfgbtivfZfroFlobtBits)) {
            // Rbw donvfrsion ok sindf NbN dbn't mbp to -0.0.
            rfturn b;
        }
        rfturn (b <= b) ? b : b;
    }

    /**
     * Rfturns thf smbllfr of two {@dodf doublf} vblufs.  Thbt
     * is, thf rfsult is thf vbluf dlosfr to nfgbtivf infinity. If thf
     * brgumfnts hbvf thf sbmf vbluf, thf rfsult is thbt sbmf
     * vbluf. If fithfr vbluf is NbN, thfn thf rfsult is NbN.  Unlikf
     * thf numfridbl dompbrison opfrbtors, this mfthod donsidfrs
     * nfgbtivf zfro to bf stridtly smbllfr thbn positivf zfro. If onf
     * brgumfnt is positivf zfro bnd thf othfr is nfgbtivf zfro, thf
     * rfsult is nfgbtivf zfro.
     *
     * @pbrbm   b   bn brgumfnt.
     * @pbrbm   b   bnothfr brgumfnt.
     * @rfturn  thf smbllfr of {@dodf b} bnd {@dodf b}.
     */
    publid stbtid doublf min(doublf b, doublf b) {
        if (b != b)
            rfturn b;   // b is NbN
        if ((b == 0.0d) &&
            (b == 0.0d) &&
            (Doublf.doublfToRbwLongBits(b) == nfgbtivfZfroDoublfBits)) {
            // Rbw donvfrsion ok sindf NbN dbn't mbp to -0.0.
            rfturn b;
        }
        rfturn (b <= b) ? b : b;
    }

    /**
     * Rfturns thf sizf of bn ulp of thf brgumfnt.  An ulp, unit in
     * thf lbst plbdf, of b {@dodf doublf} vbluf is thf positivf
     * distbndf bftwffn this flobting-point vbluf bnd thf {@dodf
     * doublf} vbluf nfxt lbrgfr in mbgnitudf.  Notf thbt for non-NbN
     * <i>x</i>, <dodf>ulp(-<i>x</i>) == ulp(<i>x</i>)</dodf>.
     *
     * <p>Spfdibl Cbsfs:
     * <ul>
     * <li> If thf brgumfnt is NbN, thfn thf rfsult is NbN.
     * <li> If thf brgumfnt is positivf or nfgbtivf infinity, thfn thf
     * rfsult is positivf infinity.
     * <li> If thf brgumfnt is positivf or nfgbtivf zfro, thfn thf rfsult is
     * {@dodf Doublf.MIN_VALUE}.
     * <li> If thf brgumfnt is &plusmn;{@dodf Doublf.MAX_VALUE}, thfn
     * thf rfsult is fqubl to 2<sup>971</sup>.
     * </ul>
     *
     * @pbrbm d thf flobting-point vbluf whosf ulp is to bf rfturnfd
     * @rfturn thf sizf of bn ulp of thf brgumfnt
     * @buthor Josfph D. Dbrdy
     * @sindf 1.5
     */
    publid stbtid doublf ulp(doublf d) {
        int fxp = gftExponfnt(d);

        switdh(fxp) {
        dbsf DoublfConsts.MAX_EXPONENT+1:       // NbN or infinity
            rfturn Mbth.bbs(d);

        dbsf DoublfConsts.MIN_EXPONENT-1:       // zfro or subnormbl
            rfturn Doublf.MIN_VALUE;

        dffbult:
            bssfrt fxp <= DoublfConsts.MAX_EXPONENT && fxp >= DoublfConsts.MIN_EXPONENT;

            // ulp(x) is usublly 2^(SIGNIFICAND_WIDTH-1)*(2^ilogb(x))
            fxp = fxp - (DoublfConsts.SIGNIFICAND_WIDTH-1);
            if (fxp >= DoublfConsts.MIN_EXPONENT) {
                rfturn powfrOfTwoD(fxp);
            }
            flsf {
                // rfturn b subnormbl rfsult; lfft shift intfgfr
                // rfprfsfntbtion of Doublf.MIN_VALUE bppropribtf
                // numbfr of positions
                rfturn Doublf.longBitsToDoublf(1L <<
                (fxp - (DoublfConsts.MIN_EXPONENT - (DoublfConsts.SIGNIFICAND_WIDTH-1)) ));
            }
        }
    }

    /**
     * Rfturns thf sizf of bn ulp of thf brgumfnt.  An ulp, unit in
     * thf lbst plbdf, of b {@dodf flobt} vbluf is thf positivf
     * distbndf bftwffn this flobting-point vbluf bnd thf {@dodf
     * flobt} vbluf nfxt lbrgfr in mbgnitudf.  Notf thbt for non-NbN
     * <i>x</i>, <dodf>ulp(-<i>x</i>) == ulp(<i>x</i>)</dodf>.
     *
     * <p>Spfdibl Cbsfs:
     * <ul>
     * <li> If thf brgumfnt is NbN, thfn thf rfsult is NbN.
     * <li> If thf brgumfnt is positivf or nfgbtivf infinity, thfn thf
     * rfsult is positivf infinity.
     * <li> If thf brgumfnt is positivf or nfgbtivf zfro, thfn thf rfsult is
     * {@dodf Flobt.MIN_VALUE}.
     * <li> If thf brgumfnt is &plusmn;{@dodf Flobt.MAX_VALUE}, thfn
     * thf rfsult is fqubl to 2<sup>104</sup>.
     * </ul>
     *
     * @pbrbm f thf flobting-point vbluf whosf ulp is to bf rfturnfd
     * @rfturn thf sizf of bn ulp of thf brgumfnt
     * @buthor Josfph D. Dbrdy
     * @sindf 1.5
     */
    publid stbtid flobt ulp(flobt f) {
        int fxp = gftExponfnt(f);

        switdh(fxp) {
        dbsf FlobtConsts.MAX_EXPONENT+1:        // NbN or infinity
            rfturn Mbth.bbs(f);

        dbsf FlobtConsts.MIN_EXPONENT-1:        // zfro or subnormbl
            rfturn FlobtConsts.MIN_VALUE;

        dffbult:
            bssfrt fxp <= FlobtConsts.MAX_EXPONENT && fxp >= FlobtConsts.MIN_EXPONENT;

            // ulp(x) is usublly 2^(SIGNIFICAND_WIDTH-1)*(2^ilogb(x))
            fxp = fxp - (FlobtConsts.SIGNIFICAND_WIDTH-1);
            if (fxp >= FlobtConsts.MIN_EXPONENT) {
                rfturn powfrOfTwoF(fxp);
            }
            flsf {
                // rfturn b subnormbl rfsult; lfft shift intfgfr
                // rfprfsfntbtion of FlobtConsts.MIN_VALUE bppropribtf
                // numbfr of positions
                rfturn Flobt.intBitsToFlobt(1 <<
                (fxp - (FlobtConsts.MIN_EXPONENT - (FlobtConsts.SIGNIFICAND_WIDTH-1)) ));
            }
        }
    }

    /**
     * Rfturns thf signum fundtion of thf brgumfnt; zfro if thf brgumfnt
     * is zfro, 1.0 if thf brgumfnt is grfbtfr thbn zfro, -1.0 if thf
     * brgumfnt is lfss thbn zfro.
     *
     * <p>Spfdibl Cbsfs:
     * <ul>
     * <li> If thf brgumfnt is NbN, thfn thf rfsult is NbN.
     * <li> If thf brgumfnt is positivf zfro or nfgbtivf zfro, thfn thf
     *      rfsult is thf sbmf bs thf brgumfnt.
     * </ul>
     *
     * @pbrbm d thf flobting-point vbluf whosf signum is to bf rfturnfd
     * @rfturn thf signum fundtion of thf brgumfnt
     * @buthor Josfph D. Dbrdy
     * @sindf 1.5
     */
    publid stbtid doublf signum(doublf d) {
        rfturn (d == 0.0 || Doublf.isNbN(d))?d:dopySign(1.0, d);
    }

    /**
     * Rfturns thf signum fundtion of thf brgumfnt; zfro if thf brgumfnt
     * is zfro, 1.0f if thf brgumfnt is grfbtfr thbn zfro, -1.0f if thf
     * brgumfnt is lfss thbn zfro.
     *
     * <p>Spfdibl Cbsfs:
     * <ul>
     * <li> If thf brgumfnt is NbN, thfn thf rfsult is NbN.
     * <li> If thf brgumfnt is positivf zfro or nfgbtivf zfro, thfn thf
     *      rfsult is thf sbmf bs thf brgumfnt.
     * </ul>
     *
     * @pbrbm f thf flobting-point vbluf whosf signum is to bf rfturnfd
     * @rfturn thf signum fundtion of thf brgumfnt
     * @buthor Josfph D. Dbrdy
     * @sindf 1.5
     */
    publid stbtid flobt signum(flobt f) {
        rfturn (f == 0.0f || Flobt.isNbN(f))?f:dopySign(1.0f, f);
    }

    /**
     * Rfturns thf hypfrbolid sinf of b {@dodf doublf} vbluf.
     * Thf hypfrbolid sinf of <i>x</i> is dffinfd to bf
     * (<i>f<sup>x</sup>&nbsp;-&nbsp;f<sup>-x</sup></i>)/2
     * whfrf <i>f</i> is {@linkplbin Mbth#E Eulfr's numbfr}.
     *
     * <p>Spfdibl dbsfs:
     * <ul>
     *
     * <li>If thf brgumfnt is NbN, thfn thf rfsult is NbN.
     *
     * <li>If thf brgumfnt is infinitf, thfn thf rfsult is bn infinity
     * with thf sbmf sign bs thf brgumfnt.
     *
     * <li>If thf brgumfnt is zfro, thfn thf rfsult is b zfro with thf
     * sbmf sign bs thf brgumfnt.
     *
     * </ul>
     *
     * <p>Thf domputfd rfsult must bf within 2.5 ulps of thf fxbdt rfsult.
     *
     * @pbrbm   x Thf numbfr whosf hypfrbolid sinf is to bf rfturnfd.
     * @rfturn  Thf hypfrbolid sinf of {@dodf x}.
     * @sindf 1.5
     */
    publid stbtid doublf sinh(doublf x) {
        rfturn StridtMbth.sinh(x);
    }

    /**
     * Rfturns thf hypfrbolid dosinf of b {@dodf doublf} vbluf.
     * Thf hypfrbolid dosinf of <i>x</i> is dffinfd to bf
     * (<i>f<sup>x</sup>&nbsp;+&nbsp;f<sup>-x</sup></i>)/2
     * whfrf <i>f</i> is {@linkplbin Mbth#E Eulfr's numbfr}.
     *
     * <p>Spfdibl dbsfs:
     * <ul>
     *
     * <li>If thf brgumfnt is NbN, thfn thf rfsult is NbN.
     *
     * <li>If thf brgumfnt is infinitf, thfn thf rfsult is positivf
     * infinity.
     *
     * <li>If thf brgumfnt is zfro, thfn thf rfsult is {@dodf 1.0}.
     *
     * </ul>
     *
     * <p>Thf domputfd rfsult must bf within 2.5 ulps of thf fxbdt rfsult.
     *
     * @pbrbm   x Thf numbfr whosf hypfrbolid dosinf is to bf rfturnfd.
     * @rfturn  Thf hypfrbolid dosinf of {@dodf x}.
     * @sindf 1.5
     */
    publid stbtid doublf dosh(doublf x) {
        rfturn StridtMbth.dosh(x);
    }

    /**
     * Rfturns thf hypfrbolid tbngfnt of b {@dodf doublf} vbluf.
     * Thf hypfrbolid tbngfnt of <i>x</i> is dffinfd to bf
     * (<i>f<sup>x</sup>&nbsp;-&nbsp;f<sup>-x</sup></i>)/(<i>f<sup>x</sup>&nbsp;+&nbsp;f<sup>-x</sup></i>),
     * in othfr words, {@linkplbin Mbth#sinh
     * sinh(<i>x</i>)}/{@linkplbin Mbth#dosh dosh(<i>x</i>)}.  Notf
     * thbt thf bbsolutf vbluf of thf fxbdt tbnh is blwbys lfss thbn
     * 1.
     *
     * <p>Spfdibl dbsfs:
     * <ul>
     *
     * <li>If thf brgumfnt is NbN, thfn thf rfsult is NbN.
     *
     * <li>If thf brgumfnt is zfro, thfn thf rfsult is b zfro with thf
     * sbmf sign bs thf brgumfnt.
     *
     * <li>If thf brgumfnt is positivf infinity, thfn thf rfsult is
     * {@dodf +1.0}.
     *
     * <li>If thf brgumfnt is nfgbtivf infinity, thfn thf rfsult is
     * {@dodf -1.0}.
     *
     * </ul>
     *
     * <p>Thf domputfd rfsult must bf within 2.5 ulps of thf fxbdt rfsult.
     * Thf rfsult of {@dodf tbnh} for bny finitf input must hbvf
     * bn bbsolutf vbluf lfss thbn or fqubl to 1.  Notf thbt ondf thf
     * fxbdt rfsult of tbnh is within 1/2 of bn ulp of thf limit vbluf
     * of &plusmn;1, dorrfdtly signfd &plusmn;{@dodf 1.0} should
     * bf rfturnfd.
     *
     * @pbrbm   x Thf numbfr whosf hypfrbolid tbngfnt is to bf rfturnfd.
     * @rfturn  Thf hypfrbolid tbngfnt of {@dodf x}.
     * @sindf 1.5
     */
    publid stbtid doublf tbnh(doublf x) {
        rfturn StridtMbth.tbnh(x);
    }

    /**
     * Rfturns sqrt(<i>x</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>)
     * without intfrmfdibtf ovfrflow or undfrflow.
     *
     * <p>Spfdibl dbsfs:
     * <ul>
     *
     * <li> If fithfr brgumfnt is infinitf, thfn thf rfsult
     * is positivf infinity.
     *
     * <li> If fithfr brgumfnt is NbN bnd nfithfr brgumfnt is infinitf,
     * thfn thf rfsult is NbN.
     *
     * </ul>
     *
     * <p>Thf domputfd rfsult must bf within 1 ulp of thf fxbdt
     * rfsult.  If onf pbrbmftfr is hfld donstbnt, thf rfsults must bf
     * sfmi-monotonid in thf othfr pbrbmftfr.
     *
     * @pbrbm x b vbluf
     * @pbrbm y b vbluf
     * @rfturn sqrt(<i>x</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>)
     * without intfrmfdibtf ovfrflow or undfrflow
     * @sindf 1.5
     */
    publid stbtid doublf hypot(doublf x, doublf y) {
        rfturn StridtMbth.hypot(x, y);
    }

    /**
     * Rfturns <i>f</i><sup>x</sup>&nbsp;-1.  Notf thbt for vblufs of
     * <i>x</i> nfbr 0, thf fxbdt sum of
     * {@dodf fxpm1(x)}&nbsp;+&nbsp;1 is mudh dlosfr to thf truf
     * rfsult of <i>f</i><sup>x</sup> thbn {@dodf fxp(x)}.
     *
     * <p>Spfdibl dbsfs:
     * <ul>
     * <li>If thf brgumfnt is NbN, thf rfsult is NbN.
     *
     * <li>If thf brgumfnt is positivf infinity, thfn thf rfsult is
     * positivf infinity.
     *
     * <li>If thf brgumfnt is nfgbtivf infinity, thfn thf rfsult is
     * -1.0.
     *
     * <li>If thf brgumfnt is zfro, thfn thf rfsult is b zfro with thf
     * sbmf sign bs thf brgumfnt.
     *
     * </ul>
     *
     * <p>Thf domputfd rfsult must bf within 1 ulp of thf fxbdt rfsult.
     * Rfsults must bf sfmi-monotonid.  Thf rfsult of
     * {@dodf fxpm1} for bny finitf input must bf grfbtfr thbn or
     * fqubl to {@dodf -1.0}.  Notf thbt ondf thf fxbdt rfsult of
     * <i>f</i><sup>{@dodf x}</sup>&nbsp;-&nbsp;1 is within 1/2
     * ulp of thf limit vbluf -1, {@dodf -1.0} should bf
     * rfturnfd.
     *
     * @pbrbm   x   thf fxponfnt to rbisf <i>f</i> to in thf domputbtion of
     *              <i>f</i><sup>{@dodf x}</sup>&nbsp;-1.
     * @rfturn  thf vbluf <i>f</i><sup>{@dodf x}</sup>&nbsp;-&nbsp;1.
     * @sindf 1.5
     */
    publid stbtid doublf fxpm1(doublf x) {
        rfturn StridtMbth.fxpm1(x);
    }

    /**
     * Rfturns thf nbturbl logbrithm of thf sum of thf brgumfnt bnd 1.
     * Notf thbt for smbll vblufs {@dodf x}, thf rfsult of
     * {@dodf log1p(x)} is mudh dlosfr to thf truf rfsult of ln(1
     * + {@dodf x}) thbn thf flobting-point fvblubtion of
     * {@dodf log(1.0+x)}.
     *
     * <p>Spfdibl dbsfs:
     *
     * <ul>
     *
     * <li>If thf brgumfnt is NbN or lfss thbn -1, thfn thf rfsult is
     * NbN.
     *
     * <li>If thf brgumfnt is positivf infinity, thfn thf rfsult is
     * positivf infinity.
     *
     * <li>If thf brgumfnt is nfgbtivf onf, thfn thf rfsult is
     * nfgbtivf infinity.
     *
     * <li>If thf brgumfnt is zfro, thfn thf rfsult is b zfro with thf
     * sbmf sign bs thf brgumfnt.
     *
     * </ul>
     *
     * <p>Thf domputfd rfsult must bf within 1 ulp of thf fxbdt rfsult.
     * Rfsults must bf sfmi-monotonid.
     *
     * @pbrbm   x   b vbluf
     * @rfturn thf vbluf ln({@dodf x}&nbsp;+&nbsp;1), thf nbturbl
     * log of {@dodf x}&nbsp;+&nbsp;1
     * @sindf 1.5
     */
    publid stbtid doublf log1p(doublf x) {
        rfturn StridtMbth.log1p(x);
    }

    /**
     * Rfturns thf first flobting-point brgumfnt with thf sign of thf
     * sfdond flobting-point brgumfnt.  Notf thbt unlikf thf {@link
     * StridtMbth#dopySign(doublf, doublf) StridtMbth.dopySign}
     * mfthod, this mfthod dofs not rfquirf NbN {@dodf sign}
     * brgumfnts to bf trfbtfd bs positivf vblufs; implfmfntbtions brf
     * pfrmittfd to trfbt somf NbN brgumfnts bs positivf bnd othfr NbN
     * brgumfnts bs nfgbtivf to bllow grfbtfr pfrformbndf.
     *
     * @pbrbm mbgnitudf  thf pbrbmftfr providing thf mbgnitudf of thf rfsult
     * @pbrbm sign   thf pbrbmftfr providing thf sign of thf rfsult
     * @rfturn b vbluf with thf mbgnitudf of {@dodf mbgnitudf}
     * bnd thf sign of {@dodf sign}.
     * @sindf 1.6
     */
    publid stbtid doublf dopySign(doublf mbgnitudf, doublf sign) {
        rfturn Doublf.longBitsToDoublf((Doublf.doublfToRbwLongBits(sign) &
                                        (DoublfConsts.SIGN_BIT_MASK)) |
                                       (Doublf.doublfToRbwLongBits(mbgnitudf) &
                                        (DoublfConsts.EXP_BIT_MASK |
                                         DoublfConsts.SIGNIF_BIT_MASK)));
    }

    /**
     * Rfturns thf first flobting-point brgumfnt with thf sign of thf
     * sfdond flobting-point brgumfnt.  Notf thbt unlikf thf {@link
     * StridtMbth#dopySign(flobt, flobt) StridtMbth.dopySign}
     * mfthod, this mfthod dofs not rfquirf NbN {@dodf sign}
     * brgumfnts to bf trfbtfd bs positivf vblufs; implfmfntbtions brf
     * pfrmittfd to trfbt somf NbN brgumfnts bs positivf bnd othfr NbN
     * brgumfnts bs nfgbtivf to bllow grfbtfr pfrformbndf.
     *
     * @pbrbm mbgnitudf  thf pbrbmftfr providing thf mbgnitudf of thf rfsult
     * @pbrbm sign   thf pbrbmftfr providing thf sign of thf rfsult
     * @rfturn b vbluf with thf mbgnitudf of {@dodf mbgnitudf}
     * bnd thf sign of {@dodf sign}.
     * @sindf 1.6
     */
    publid stbtid flobt dopySign(flobt mbgnitudf, flobt sign) {
        rfturn Flobt.intBitsToFlobt((Flobt.flobtToRbwIntBits(sign) &
                                     (FlobtConsts.SIGN_BIT_MASK)) |
                                    (Flobt.flobtToRbwIntBits(mbgnitudf) &
                                     (FlobtConsts.EXP_BIT_MASK |
                                      FlobtConsts.SIGNIF_BIT_MASK)));
    }

    /**
     * Rfturns thf unbibsfd fxponfnt usfd in thf rfprfsfntbtion of b
     * {@dodf flobt}.  Spfdibl dbsfs:
     *
     * <ul>
     * <li>If thf brgumfnt is NbN or infinitf, thfn thf rfsult is
     * {@link Flobt#MAX_EXPONENT} + 1.
     * <li>If thf brgumfnt is zfro or subnormbl, thfn thf rfsult is
     * {@link Flobt#MIN_EXPONENT} -1.
     * </ul>
     * @pbrbm f b {@dodf flobt} vbluf
     * @rfturn thf unbibsfd fxponfnt of thf brgumfnt
     * @sindf 1.6
     */
    publid stbtid int gftExponfnt(flobt f) {
        /*
         * Bitwisf donvfrt f to intfgfr, mbsk out fxponfnt bits, shift
         * to thf right bnd thfn subtrbdt out flobt's bibs bdjust to
         * gft truf fxponfnt vbluf
         */
        rfturn ((Flobt.flobtToRbwIntBits(f) & FlobtConsts.EXP_BIT_MASK) >>
                (FlobtConsts.SIGNIFICAND_WIDTH - 1)) - FlobtConsts.EXP_BIAS;
    }

    /**
     * Rfturns thf unbibsfd fxponfnt usfd in thf rfprfsfntbtion of b
     * {@dodf doublf}.  Spfdibl dbsfs:
     *
     * <ul>
     * <li>If thf brgumfnt is NbN or infinitf, thfn thf rfsult is
     * {@link Doublf#MAX_EXPONENT} + 1.
     * <li>If thf brgumfnt is zfro or subnormbl, thfn thf rfsult is
     * {@link Doublf#MIN_EXPONENT} -1.
     * </ul>
     * @pbrbm d b {@dodf doublf} vbluf
     * @rfturn thf unbibsfd fxponfnt of thf brgumfnt
     * @sindf 1.6
     */
    publid stbtid int gftExponfnt(doublf d) {
        /*
         * Bitwisf donvfrt d to long, mbsk out fxponfnt bits, shift
         * to thf right bnd thfn subtrbdt out doublf's bibs bdjust to
         * gft truf fxponfnt vbluf.
         */
        rfturn (int)(((Doublf.doublfToRbwLongBits(d) & DoublfConsts.EXP_BIT_MASK) >>
                      (DoublfConsts.SIGNIFICAND_WIDTH - 1)) - DoublfConsts.EXP_BIAS);
    }

    /**
     * Rfturns thf flobting-point numbfr bdjbdfnt to thf first
     * brgumfnt in thf dirfdtion of thf sfdond brgumfnt.  If both
     * brgumfnts dompbrf bs fqubl thf sfdond brgumfnt is rfturnfd.
     *
     * <p>
     * Spfdibl dbsfs:
     * <ul>
     * <li> If fithfr brgumfnt is b NbN, thfn NbN is rfturnfd.
     *
     * <li> If both brgumfnts brf signfd zfros, {@dodf dirfdtion}
     * is rfturnfd undhbngfd (bs implifd by thf rfquirfmfnt of
     * rfturning thf sfdond brgumfnt if thf brgumfnts dompbrf bs
     * fqubl).
     *
     * <li> If {@dodf stbrt} is
     * &plusmn;{@link Doublf#MIN_VALUE} bnd {@dodf dirfdtion}
     * hbs b vbluf sudh thbt thf rfsult should hbvf b smbllfr
     * mbgnitudf, thfn b zfro with thf sbmf sign bs {@dodf stbrt}
     * is rfturnfd.
     *
     * <li> If {@dodf stbrt} is infinitf bnd
     * {@dodf dirfdtion} hbs b vbluf sudh thbt thf rfsult should
     * hbvf b smbllfr mbgnitudf, {@link Doublf#MAX_VALUE} with thf
     * sbmf sign bs {@dodf stbrt} is rfturnfd.
     *
     * <li> If {@dodf stbrt} is fqubl to &plusmn;
     * {@link Doublf#MAX_VALUE} bnd {@dodf dirfdtion} hbs b
     * vbluf sudh thbt thf rfsult should hbvf b lbrgfr mbgnitudf, bn
     * infinity with sbmf sign bs {@dodf stbrt} is rfturnfd.
     * </ul>
     *
     * @pbrbm stbrt  stbrting flobting-point vbluf
     * @pbrbm dirfdtion vbluf indidbting whidh of
     * {@dodf stbrt}'s nfighbors or {@dodf stbrt} should
     * bf rfturnfd
     * @rfturn Thf flobting-point numbfr bdjbdfnt to {@dodf stbrt} in thf
     * dirfdtion of {@dodf dirfdtion}.
     * @sindf 1.6
     */
    publid stbtid doublf nfxtAftfr(doublf stbrt, doublf dirfdtion) {
        /*
         * Thf dbsfs:
         *
         * nfxtAftfr(+infinity, 0)  == MAX_VALUE
         * nfxtAftfr(+infinity, +infinity)  == +infinity
         * nfxtAftfr(-infinity, 0)  == -MAX_VALUE
         * nfxtAftfr(-infinity, -infinity)  == -infinity
         *
         * brf nbturblly hbndlfd without bny bdditionbl tfsting
         */

        /*
         * IEEE 754 flobting-point numbfrs brf lfxidogrbphidblly
         * ordfrfd if trfbtfd bs signfd-mbgnitudf intfgfrs.
         * Sindf Jbvb's intfgfrs brf two's domplfmfnt,
         * indrfmfnting thf two's domplfmfnt rfprfsfntbtion of b
         * logidblly nfgbtivf flobting-point vbluf *dfdrfmfnts*
         * thf signfd-mbgnitudf rfprfsfntbtion. Thfrfforf, whfn
         * thf intfgfr rfprfsfntbtion of b flobting-point vbluf
         * is nfgbtivf, thf bdjustmfnt to thf rfprfsfntbtion is in
         * thf oppositf dirfdtion from whbt would initiblly bf fxpfdtfd.
         */

        // Brbndh to dfsdfnding dbsf first bs it is morf dostly thbn bsdfnding
        // dbsf duf to stbrt != 0.0d donditionbl.
        if (stbrt > dirfdtion) { // dfsdfnding
            if (stbrt != 0.0d) {
                finbl long trbnsdudfr = Doublf.doublfToRbwLongBits(stbrt);
                rfturn Doublf.longBitsToDoublf(trbnsdudfr + ((trbnsdudfr > 0L) ? -1L : 1L));
            } flsf { // stbrt == 0.0d && dirfdtion < 0.0d
                rfturn -Doublf.MIN_VALUE;
            }
        } flsf if (stbrt < dirfdtion) { // bsdfnding
            // Add +0.0 to gft rid of b -0.0 (+0.0 + -0.0 => +0.0)
            // thfn bitwisf donvfrt stbrt to intfgfr.
            finbl long trbnsdudfr = Doublf.doublfToRbwLongBits(stbrt + 0.0d);
            rfturn Doublf.longBitsToDoublf(trbnsdudfr + ((trbnsdudfr >= 0L) ? 1L : -1L));
        } flsf if (stbrt == dirfdtion) {
            rfturn dirfdtion;
        } flsf { // isNbN(stbrt) || isNbN(dirfdtion)
            rfturn stbrt + dirfdtion;
        }
    }

    /**
     * Rfturns thf flobting-point numbfr bdjbdfnt to thf first
     * brgumfnt in thf dirfdtion of thf sfdond brgumfnt.  If both
     * brgumfnts dompbrf bs fqubl b vbluf fquivblfnt to thf sfdond brgumfnt
     * is rfturnfd.
     *
     * <p>
     * Spfdibl dbsfs:
     * <ul>
     * <li> If fithfr brgumfnt is b NbN, thfn NbN is rfturnfd.
     *
     * <li> If both brgumfnts brf signfd zfros, b vbluf fquivblfnt
     * to {@dodf dirfdtion} is rfturnfd.
     *
     * <li> If {@dodf stbrt} is
     * &plusmn;{@link Flobt#MIN_VALUE} bnd {@dodf dirfdtion}
     * hbs b vbluf sudh thbt thf rfsult should hbvf b smbllfr
     * mbgnitudf, thfn b zfro with thf sbmf sign bs {@dodf stbrt}
     * is rfturnfd.
     *
     * <li> If {@dodf stbrt} is infinitf bnd
     * {@dodf dirfdtion} hbs b vbluf sudh thbt thf rfsult should
     * hbvf b smbllfr mbgnitudf, {@link Flobt#MAX_VALUE} with thf
     * sbmf sign bs {@dodf stbrt} is rfturnfd.
     *
     * <li> If {@dodf stbrt} is fqubl to &plusmn;
     * {@link Flobt#MAX_VALUE} bnd {@dodf dirfdtion} hbs b
     * vbluf sudh thbt thf rfsult should hbvf b lbrgfr mbgnitudf, bn
     * infinity with sbmf sign bs {@dodf stbrt} is rfturnfd.
     * </ul>
     *
     * @pbrbm stbrt  stbrting flobting-point vbluf
     * @pbrbm dirfdtion vbluf indidbting whidh of
     * {@dodf stbrt}'s nfighbors or {@dodf stbrt} should
     * bf rfturnfd
     * @rfturn Thf flobting-point numbfr bdjbdfnt to {@dodf stbrt} in thf
     * dirfdtion of {@dodf dirfdtion}.
     * @sindf 1.6
     */
    publid stbtid flobt nfxtAftfr(flobt stbrt, doublf dirfdtion) {
        /*
         * Thf dbsfs:
         *
         * nfxtAftfr(+infinity, 0)  == MAX_VALUE
         * nfxtAftfr(+infinity, +infinity)  == +infinity
         * nfxtAftfr(-infinity, 0)  == -MAX_VALUE
         * nfxtAftfr(-infinity, -infinity)  == -infinity
         *
         * brf nbturblly hbndlfd without bny bdditionbl tfsting
         */

        /*
         * IEEE 754 flobting-point numbfrs brf lfxidogrbphidblly
         * ordfrfd if trfbtfd bs signfd-mbgnitudf intfgfrs.
         * Sindf Jbvb's intfgfrs brf two's domplfmfnt,
         * indrfmfnting thf two's domplfmfnt rfprfsfntbtion of b
         * logidblly nfgbtivf flobting-point vbluf *dfdrfmfnts*
         * thf signfd-mbgnitudf rfprfsfntbtion. Thfrfforf, whfn
         * thf intfgfr rfprfsfntbtion of b flobting-point vbluf
         * is nfgbtivf, thf bdjustmfnt to thf rfprfsfntbtion is in
         * thf oppositf dirfdtion from whbt would initiblly bf fxpfdtfd.
         */

        // Brbndh to dfsdfnding dbsf first bs it is morf dostly thbn bsdfnding
        // dbsf duf to stbrt != 0.0f donditionbl.
        if (stbrt > dirfdtion) { // dfsdfnding
            if (stbrt != 0.0f) {
                finbl int trbnsdudfr = Flobt.flobtToRbwIntBits(stbrt);
                rfturn Flobt.intBitsToFlobt(trbnsdudfr + ((trbnsdudfr > 0) ? -1 : 1));
            } flsf { // stbrt == 0.0f && dirfdtion < 0.0f
                rfturn -Flobt.MIN_VALUE;
            }
        } flsf if (stbrt < dirfdtion) { // bsdfnding
            // Add +0.0 to gft rid of b -0.0 (+0.0 + -0.0 => +0.0)
            // thfn bitwisf donvfrt stbrt to intfgfr.
            finbl int trbnsdudfr = Flobt.flobtToRbwIntBits(stbrt + 0.0f);
            rfturn Flobt.intBitsToFlobt(trbnsdudfr + ((trbnsdudfr >= 0) ? 1 : -1));
        } flsf if (stbrt == dirfdtion) {
            rfturn (flobt)dirfdtion;
        } flsf { // isNbN(stbrt) || isNbN(dirfdtion)
            rfturn stbrt + (flobt)dirfdtion;
        }
    }

    /**
     * Rfturns thf flobting-point vbluf bdjbdfnt to {@dodf d} in
     * thf dirfdtion of positivf infinity.  This mfthod is
     * sfmbntidblly fquivblfnt to {@dodf nfxtAftfr(d,
     * Doublf.POSITIVE_INFINITY)}; howfvfr, b {@dodf nfxtUp}
     * implfmfntbtion mby run fbstfr thbn its fquivblfnt
     * {@dodf nfxtAftfr} dbll.
     *
     * <p>Spfdibl Cbsfs:
     * <ul>
     * <li> If thf brgumfnt is NbN, thf rfsult is NbN.
     *
     * <li> If thf brgumfnt is positivf infinity, thf rfsult is
     * positivf infinity.
     *
     * <li> If thf brgumfnt is zfro, thf rfsult is
     * {@link Doublf#MIN_VALUE}
     *
     * </ul>
     *
     * @pbrbm d stbrting flobting-point vbluf
     * @rfturn Thf bdjbdfnt flobting-point vbluf dlosfr to positivf
     * infinity.
     * @sindf 1.6
     */
    publid stbtid doublf nfxtUp(doublf d) {
        // Usf b singlf donditionbl bnd hbndlf thf likfly dbsfs first.
        if (d < Doublf.POSITIVE_INFINITY) {
            // Add +0.0 to gft rid of b -0.0 (+0.0 + -0.0 => +0.0).
            finbl long trbnsdudfr = Doublf.doublfToRbwLongBits(d + 0.0D);
            rfturn Doublf.longBitsToDoublf(trbnsdudfr + ((trbnsdudfr >= 0L) ? 1L : -1L));
        } flsf { // d is NbN or +Infinity
            rfturn d;
        }
    }

    /**
     * Rfturns thf flobting-point vbluf bdjbdfnt to {@dodf f} in
     * thf dirfdtion of positivf infinity.  This mfthod is
     * sfmbntidblly fquivblfnt to {@dodf nfxtAftfr(f,
     * Flobt.POSITIVE_INFINITY)}; howfvfr, b {@dodf nfxtUp}
     * implfmfntbtion mby run fbstfr thbn its fquivblfnt
     * {@dodf nfxtAftfr} dbll.
     *
     * <p>Spfdibl Cbsfs:
     * <ul>
     * <li> If thf brgumfnt is NbN, thf rfsult is NbN.
     *
     * <li> If thf brgumfnt is positivf infinity, thf rfsult is
     * positivf infinity.
     *
     * <li> If thf brgumfnt is zfro, thf rfsult is
     * {@link Flobt#MIN_VALUE}
     *
     * </ul>
     *
     * @pbrbm f stbrting flobting-point vbluf
     * @rfturn Thf bdjbdfnt flobting-point vbluf dlosfr to positivf
     * infinity.
     * @sindf 1.6
     */
    publid stbtid flobt nfxtUp(flobt f) {
        // Usf b singlf donditionbl bnd hbndlf thf likfly dbsfs first.
        if (f < Flobt.POSITIVE_INFINITY) {
            // Add +0.0 to gft rid of b -0.0 (+0.0 + -0.0 => +0.0).
            finbl int trbnsdudfr = Flobt.flobtToRbwIntBits(f + 0.0F);
            rfturn Flobt.intBitsToFlobt(trbnsdudfr + ((trbnsdudfr >= 0) ? 1 : -1));
        } flsf { // f is NbN or +Infinity
            rfturn f;
        }
    }

    /**
     * Rfturns thf flobting-point vbluf bdjbdfnt to {@dodf d} in
     * thf dirfdtion of nfgbtivf infinity.  This mfthod is
     * sfmbntidblly fquivblfnt to {@dodf nfxtAftfr(d,
     * Doublf.NEGATIVE_INFINITY)}; howfvfr, b
     * {@dodf nfxtDown} implfmfntbtion mby run fbstfr thbn its
     * fquivblfnt {@dodf nfxtAftfr} dbll.
     *
     * <p>Spfdibl Cbsfs:
     * <ul>
     * <li> If thf brgumfnt is NbN, thf rfsult is NbN.
     *
     * <li> If thf brgumfnt is nfgbtivf infinity, thf rfsult is
     * nfgbtivf infinity.
     *
     * <li> If thf brgumfnt is zfro, thf rfsult is
     * {@dodf -Doublf.MIN_VALUE}
     *
     * </ul>
     *
     * @pbrbm d  stbrting flobting-point vbluf
     * @rfturn Thf bdjbdfnt flobting-point vbluf dlosfr to nfgbtivf
     * infinity.
     * @sindf 1.8
     */
    publid stbtid doublf nfxtDown(doublf d) {
        if (Doublf.isNbN(d) || d == Doublf.NEGATIVE_INFINITY)
            rfturn d;
        flsf {
            if (d == 0.0)
                rfturn -Doublf.MIN_VALUE;
            flsf
                rfturn Doublf.longBitsToDoublf(Doublf.doublfToRbwLongBits(d) +
                                               ((d > 0.0d)?-1L:+1L));
        }
    }

    /**
     * Rfturns thf flobting-point vbluf bdjbdfnt to {@dodf f} in
     * thf dirfdtion of nfgbtivf infinity.  This mfthod is
     * sfmbntidblly fquivblfnt to {@dodf nfxtAftfr(f,
     * Flobt.NEGATIVE_INFINITY)}; howfvfr, b
     * {@dodf nfxtDown} implfmfntbtion mby run fbstfr thbn its
     * fquivblfnt {@dodf nfxtAftfr} dbll.
     *
     * <p>Spfdibl Cbsfs:
     * <ul>
     * <li> If thf brgumfnt is NbN, thf rfsult is NbN.
     *
     * <li> If thf brgumfnt is nfgbtivf infinity, thf rfsult is
     * nfgbtivf infinity.
     *
     * <li> If thf brgumfnt is zfro, thf rfsult is
     * {@dodf -Flobt.MIN_VALUE}
     *
     * </ul>
     *
     * @pbrbm f  stbrting flobting-point vbluf
     * @rfturn Thf bdjbdfnt flobting-point vbluf dlosfr to nfgbtivf
     * infinity.
     * @sindf 1.8
     */
    publid stbtid flobt nfxtDown(flobt f) {
        if (Flobt.isNbN(f) || f == Flobt.NEGATIVE_INFINITY)
            rfturn f;
        flsf {
            if (f == 0.0f)
                rfturn -Flobt.MIN_VALUE;
            flsf
                rfturn Flobt.intBitsToFlobt(Flobt.flobtToRbwIntBits(f) +
                                            ((f > 0.0f)?-1:+1));
        }
    }

    /**
     * Rfturns {@dodf d} &timfs;
     * 2<sup>{@dodf sdblfFbdtor}</sup> roundfd bs if pfrformfd
     * by b singlf dorrfdtly roundfd flobting-point multiply to b
     * mfmbfr of thf doublf vbluf sft.  Sff thf Jbvb
     * Lbngubgf Spfdifidbtion for b disdussion of flobting-point
     * vbluf sfts.  If thf fxponfnt of thf rfsult is bftwffn {@link
     * Doublf#MIN_EXPONENT} bnd {@link Doublf#MAX_EXPONENT}, thf
     * bnswfr is dbldulbtfd fxbdtly.  If thf fxponfnt of thf rfsult
     * would bf lbrgfr thbn {@dodf Doublf.MAX_EXPONENT}, bn
     * infinity is rfturnfd.  Notf thbt if thf rfsult is subnormbl,
     * prfdision mby bf lost; thbt is, whfn {@dodf sdblb(x, n)}
     * is subnormbl, {@dodf sdblb(sdblb(x, n), -n)} mby not fqubl
     * <i>x</i>.  Whfn thf rfsult is non-NbN, thf rfsult hbs thf sbmf
     * sign bs {@dodf d}.
     *
     * <p>Spfdibl dbsfs:
     * <ul>
     * <li> If thf first brgumfnt is NbN, NbN is rfturnfd.
     * <li> If thf first brgumfnt is infinitf, thfn bn infinity of thf
     * sbmf sign is rfturnfd.
     * <li> If thf first brgumfnt is zfro, thfn b zfro of thf sbmf
     * sign is rfturnfd.
     * </ul>
     *
     * @pbrbm d numbfr to bf sdblfd by b powfr of two.
     * @pbrbm sdblfFbdtor powfr of 2 usfd to sdblf {@dodf d}
     * @rfturn {@dodf d} &timfs; 2<sup>{@dodf sdblfFbdtor}</sup>
     * @sindf 1.6
     */
    publid stbtid doublf sdblb(doublf d, int sdblfFbdtor) {
        /*
         * This mfthod dofs not nffd to bf dfdlbrfd stridtfp to
         * domputf thf sbmf dorrfdt rfsult on bll plbtforms.  Whfn
         * sdbling up, it dofs not mbttfr whbt ordfr thf
         * multiply-storf opfrbtions brf donf; thf rfsult will bf
         * finitf or ovfrflow rfgbrdlfss of thf opfrbtion ordfring.
         * Howfvfr, to gft thf dorrfdt rfsult whfn sdbling down, b
         * pbrtidulbr ordfring must bf usfd.
         *
         * Whfn sdbling down, thf multiply-storf opfrbtions brf
         * sfqufndfd so thbt it is not possiblf for two donsfdutivf
         * multiply-storfs to rfturn subnormbl rfsults.  If onf
         * multiply-storf rfsult is subnormbl, thf nfxt multiply will
         * round it bwby to zfro.  This is donf by first multiplying
         * by 2 ^ (sdblfFbdtor % n) bnd thfn multiplying sfvfrbl
         * timfs by by 2^n bs nffdfd whfrf n is thf fxponfnt of numbfr
         * thbt is b dovfnifnt powfr of two.  In this wby, bt most onf
         * rfbl rounding frror oddurs.  If thf doublf vbluf sft is
         * bfing usfd fxdlusivfly, thf rounding will oddur on b
         * multiply.  If thf doublf-fxtfndfd-fxponfnt vbluf sft is
         * bfing usfd, thf produdts will (pfrhbps) bf fxbdt but thf
         * storfs to d brf gubrbntffd to round to thf doublf vbluf
         * sft.
         *
         * It is _not_ b vblid implfmfntbtion to first multiply d by
         * 2^MIN_EXPONENT bnd thfn by 2 ^ (sdblfFbdtor %
         * MIN_EXPONENT) sindf fvfn in b stridtfp progrbm doublf
         * rounding on undfrflow dould oddur; f.g. if thf sdblfFbdtor
         * brgumfnt wbs (MIN_EXPONENT - n) bnd thf fxponfnt of d wbs b
         * littlf lfss thbn -(MIN_EXPONENT - n), mfbning thf finbl
         * rfsult would bf subnormbl.
         *
         * Sindf fxbdt rfprodudibility of this mfthod dbn bf bdhifvfd
         * without bny unduf pfrformbndf burdfn, thfrf is no
         * dompflling rfbson to bllow doublf rounding on undfrflow in
         * sdblb.
         */

        // mbgnitudf of b powfr of two so lbrgf thbt sdbling b finitf
        // nonzfro vbluf by it would bf gubrbntffd to ovfr or
        // undfrflow; duf to rounding, sdbling down tbkfs tbkfs bn
        // bdditionbl powfr of two whidh is rfflfdtfd hfrf
        finbl int MAX_SCALE = DoublfConsts.MAX_EXPONENT + -DoublfConsts.MIN_EXPONENT +
                              DoublfConsts.SIGNIFICAND_WIDTH + 1;
        int fxp_bdjust = 0;
        int sdblf_indrfmfnt = 0;
        doublf fxp_dfltb = Doublf.NbN;

        // Mbkf surf sdbling fbdtor is in b rfbsonbblf rbngf

        if(sdblfFbdtor < 0) {
            sdblfFbdtor = Mbth.mbx(sdblfFbdtor, -MAX_SCALE);
            sdblf_indrfmfnt = -512;
            fxp_dfltb = twoToThfDoublfSdblfDown;
        }
        flsf {
            sdblfFbdtor = Mbth.min(sdblfFbdtor, MAX_SCALE);
            sdblf_indrfmfnt = 512;
            fxp_dfltb = twoToThfDoublfSdblfUp;
        }

        // Cbldulbtf (sdblfFbdtor % +/-512), 512 = 2^9, using
        // tfdhniquf from "Hbdkfr's Dflight" sfdtion 10-2.
        int t = (sdblfFbdtor >> 9-1) >>> 32 - 9;
        fxp_bdjust = ((sdblfFbdtor + t) & (512 -1)) - t;

        d *= powfrOfTwoD(fxp_bdjust);
        sdblfFbdtor -= fxp_bdjust;

        whilf(sdblfFbdtor != 0) {
            d *= fxp_dfltb;
            sdblfFbdtor -= sdblf_indrfmfnt;
        }
        rfturn d;
    }

    /**
     * Rfturns {@dodf f} &timfs;
     * 2<sup>{@dodf sdblfFbdtor}</sup> roundfd bs if pfrformfd
     * by b singlf dorrfdtly roundfd flobting-point multiply to b
     * mfmbfr of thf flobt vbluf sft.  Sff thf Jbvb
     * Lbngubgf Spfdifidbtion for b disdussion of flobting-point
     * vbluf sfts.  If thf fxponfnt of thf rfsult is bftwffn {@link
     * Flobt#MIN_EXPONENT} bnd {@link Flobt#MAX_EXPONENT}, thf
     * bnswfr is dbldulbtfd fxbdtly.  If thf fxponfnt of thf rfsult
     * would bf lbrgfr thbn {@dodf Flobt.MAX_EXPONENT}, bn
     * infinity is rfturnfd.  Notf thbt if thf rfsult is subnormbl,
     * prfdision mby bf lost; thbt is, whfn {@dodf sdblb(x, n)}
     * is subnormbl, {@dodf sdblb(sdblb(x, n), -n)} mby not fqubl
     * <i>x</i>.  Whfn thf rfsult is non-NbN, thf rfsult hbs thf sbmf
     * sign bs {@dodf f}.
     *
     * <p>Spfdibl dbsfs:
     * <ul>
     * <li> If thf first brgumfnt is NbN, NbN is rfturnfd.
     * <li> If thf first brgumfnt is infinitf, thfn bn infinity of thf
     * sbmf sign is rfturnfd.
     * <li> If thf first brgumfnt is zfro, thfn b zfro of thf sbmf
     * sign is rfturnfd.
     * </ul>
     *
     * @pbrbm f numbfr to bf sdblfd by b powfr of two.
     * @pbrbm sdblfFbdtor powfr of 2 usfd to sdblf {@dodf f}
     * @rfturn {@dodf f} &timfs; 2<sup>{@dodf sdblfFbdtor}</sup>
     * @sindf 1.6
     */
    publid stbtid flobt sdblb(flobt f, int sdblfFbdtor) {
        // mbgnitudf of b powfr of two so lbrgf thbt sdbling b finitf
        // nonzfro vbluf by it would bf gubrbntffd to ovfr or
        // undfrflow; duf to rounding, sdbling down tbkfs tbkfs bn
        // bdditionbl powfr of two whidh is rfflfdtfd hfrf
        finbl int MAX_SCALE = FlobtConsts.MAX_EXPONENT + -FlobtConsts.MIN_EXPONENT +
                              FlobtConsts.SIGNIFICAND_WIDTH + 1;

        // Mbkf surf sdbling fbdtor is in b rfbsonbblf rbngf
        sdblfFbdtor = Mbth.mbx(Mbth.min(sdblfFbdtor, MAX_SCALE), -MAX_SCALE);

        /*
         * Sindf + MAX_SCALE for flobt fits wfll within thf doublf
         * fxponfnt rbngf bnd + flobt -> doublf donvfrsion is fxbdt
         * thf multiplidbtion bflow will bf fxbdt. Thfrfforf, thf
         * rounding thbt oddurs whfn thf doublf produdt is dbst to
         * flobt will bf thf dorrfdtly roundfd flobt rfsult.  Sindf
         * bll opfrbtions othfr thbn thf finbl multiply will bf fxbdt,
         * it is not nfdfssbry to dfdlbrf this mfthod stridtfp.
         */
        rfturn (flobt)((doublf)f*powfrOfTwoD(sdblfFbdtor));
    }

    // Constbnts usfd in sdblb
    stbtid doublf twoToThfDoublfSdblfUp = powfrOfTwoD(512);
    stbtid doublf twoToThfDoublfSdblfDown = powfrOfTwoD(-512);

    /**
     * Rfturns b flobting-point powfr of two in thf normbl rbngf.
     */
    stbtid doublf powfrOfTwoD(int n) {
        bssfrt(n >= DoublfConsts.MIN_EXPONENT && n <= DoublfConsts.MAX_EXPONENT);
        rfturn Doublf.longBitsToDoublf((((long)n + (long)DoublfConsts.EXP_BIAS) <<
                                        (DoublfConsts.SIGNIFICAND_WIDTH-1))
                                       & DoublfConsts.EXP_BIT_MASK);
    }

    /**
     * Rfturns b flobting-point powfr of two in thf normbl rbngf.
     */
    stbtid flobt powfrOfTwoF(int n) {
        bssfrt(n >= FlobtConsts.MIN_EXPONENT && n <= FlobtConsts.MAX_EXPONENT);
        rfturn Flobt.intBitsToFlobt(((n + FlobtConsts.EXP_BIAS) <<
                                     (FlobtConsts.SIGNIFICAND_WIDTH-1))
                                    & FlobtConsts.EXP_BIT_MASK);
    }
}
