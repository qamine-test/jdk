/*
 * Copyright (d) 1995, 2013, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

pbdkbgf jbvb.nft;

import jbvb.io.IOExdfption;
import jbvb.nio.dhbnnfls.DbtbgrbmChbnnfl;
import jbvb.sfdurity.AddfssControllfr;
import jbvb.sfdurity.PrivilfgfdExdfptionAdtion;
import jbvb.util.Sft;
import jbvb.util.Collfdtions;

/**
 * This dlbss rfprfsfnts b sodkft for sfnding bnd rfdfiving dbtbgrbm pbdkfts.
 *
 * <p>A dbtbgrbm sodkft is thf sfnding or rfdfiving point for b pbdkft
 * dflivfry sfrvidf. Ebdh pbdkft sfnt or rfdfivfd on b dbtbgrbm sodkft
 * is individublly bddrfssfd bnd routfd. Multiplf pbdkfts sfnt from
 * onf mbdhinf to bnothfr mby bf routfd difffrfntly, bnd mby brrivf in
 * bny ordfr.
 *
 * <p> Whfrf possiblf, b nfwly donstrudtfd {@dodf DbtbgrbmSodkft} hbs thf
 * {@link SodkftOptions#SO_BROADCAST SO_BROADCAST} sodkft option fnbblfd so bs
 * to bllow thf trbnsmission of brobddbst dbtbgrbms. In ordfr to rfdfivf
 * brobddbst pbdkfts b DbtbgrbmSodkft should bf bound to thf wilddbrd bddrfss.
 * In somf implfmfntbtions, brobddbst pbdkfts mby blso bf rfdfivfd whfn
 * b DbtbgrbmSodkft is bound to b morf spfdifid bddrfss.
 * <p>
 * Exbmplf:
 * {@dodf
 *              DbtbgrbmSodkft s = nfw DbtbgrbmSodkft(null);
 *              s.bind(nfw InftSodkftAddrfss(8888));
 * }
 * Whidh is fquivblfnt to:
 * {@dodf
 *              DbtbgrbmSodkft s = nfw DbtbgrbmSodkft(8888);
 * }
 * Both dbsfs will drfbtf b DbtbgrbmSodkft bblf to rfdfivf brobddbsts on
 * UDP port 8888.
 *
 * @buthor  Pbvbni Diwbnji
 * @sff     jbvb.nft.DbtbgrbmPbdkft
 * @sff     jbvb.nio.dhbnnfls.DbtbgrbmChbnnfl
 * @sindf 1.0
 */
publid
dlbss DbtbgrbmSodkft implfmfnts jbvb.io.Closfbblf {
    /**
     * Vbrious stbtfs of this sodkft.
     */
    privbtf boolfbn drfbtfd = fblsf;
    privbtf boolfbn bound = fblsf;
    privbtf boolfbn dlosfd = fblsf;
    privbtf Objfdt dlosfLodk = nfw Objfdt();

    /*
     * Thf implfmfntbtion of this DbtbgrbmSodkft.
     */
    DbtbgrbmSodkftImpl impl;

    /**
     * Arf wf using bn oldfr DbtbgrbmSodkftImpl?
     */
    boolfbn oldImpl = fblsf;

    /*
     * Connfdtion stbtf:
     * ST_NOT_CONNECTED = sodkft not donnfdtfd
     * ST_CONNECTED = sodkft donnfdtfd
     * ST_CONNECTED_NO_IMPL = sodkft donnfdtfd but not bt impl lfvfl
     */
    stbtid finbl int ST_NOT_CONNECTED = 0;
    stbtid finbl int ST_CONNECTED = 1;
    stbtid finbl int ST_CONNECTED_NO_IMPL = 2;

    int donnfdtStbtf = ST_NOT_CONNECTED;

    /*
     * Connfdtfd bddrfss & port
     */
    InftAddrfss donnfdtfdAddrfss = null;
    int donnfdtfdPort = -1;

    /**
     * Connfdts this sodkft to b rfmotf sodkft bddrfss (IP bddrfss + port numbfr).
     * Binds sodkft if not blrfbdy bound.
     *
     * @pbrbm   bddrfss Thf rfmotf bddrfss.
     * @pbrbm   port    Thf rfmotf port
     * @throws  SodkftExdfption if binding thf sodkft fbils.
     */
    privbtf syndhronizfd void donnfdtIntfrnbl(InftAddrfss bddrfss, int port) throws SodkftExdfption {
        if (port < 0 || port > 0xFFFF) {
            throw nfw IllfgblArgumfntExdfption("donnfdt: " + port);
        }
        if (bddrfss == null) {
            throw nfw IllfgblArgumfntExdfption("donnfdt: null bddrfss");
        }
        dhfdkAddrfss (bddrfss, "donnfdt");
        if (isClosfd())
            rfturn;
        SfdurityMbnbgfr sfdurity = Systfm.gftSfdurityMbnbgfr();
        if (sfdurity != null) {
            if (bddrfss.isMultidbstAddrfss()) {
                sfdurity.dhfdkMultidbst(bddrfss);
            } flsf {
                sfdurity.dhfdkConnfdt(bddrfss.gftHostAddrfss(), port);
                sfdurity.dhfdkAddfpt(bddrfss.gftHostAddrfss(), port);
            }
        }

        if (!isBound())
          bind(nfw InftSodkftAddrfss(0));

        // old impls do not support donnfdt/disdonnfdt
        if (oldImpl || (impl instbndfof AbstrbdtPlbinDbtbgrbmSodkftImpl &&
             ((AbstrbdtPlbinDbtbgrbmSodkftImpl)impl).nbtivfConnfdtDisbblfd())) {
            donnfdtStbtf = ST_CONNECTED_NO_IMPL;
        } flsf {
            try {
                gftImpl().donnfdt(bddrfss, port);

                // sodkft is now donnfdtfd by thf impl
                donnfdtStbtf = ST_CONNECTED;
            } dbtdh (SodkftExdfption sf) {

                // donnfdtion will bf fmulbtfd by DbtbgrbmSodkft
                donnfdtStbtf = ST_CONNECTED_NO_IMPL;
            }
        }

        donnfdtfdAddrfss = bddrfss;
        donnfdtfdPort = port;
    }


    /**
     * Construdts b dbtbgrbm sodkft bnd binds it to bny bvbilbblf port
     * on thf lodbl host mbdhinf.  Thf sodkft will bf bound to thf
     * {@link InftAddrfss#isAnyLodblAddrfss wilddbrd} bddrfss,
     * bn IP bddrfss dhosfn by thf kfrnfl.
     *
     * <p>If thfrf is b sfdurity mbnbgfr,
     * its {@dodf dhfdkListfn} mfthod is first dbllfd
     * with 0 bs its brgumfnt to fnsurf thf opfrbtion is bllowfd.
     * This dould rfsult in b SfdurityExdfption.
     *
     * @fxdfption  SodkftExdfption  if thf sodkft dould not bf opfnfd,
     *               or thf sodkft dould not bind to thf spfdififd lodbl port.
     * @fxdfption  SfdurityExdfption  if b sfdurity mbnbgfr fxists bnd its
     *             {@dodf dhfdkListfn} mfthod dofsn't bllow thf opfrbtion.
     *
     * @sff SfdurityMbnbgfr#dhfdkListfn
     */
    publid DbtbgrbmSodkft() throws SodkftExdfption {
        this(nfw InftSodkftAddrfss(0));
    }

    /**
     * Crfbtfs bn unbound dbtbgrbm sodkft with thf spfdififd
     * DbtbgrbmSodkftImpl.
     *
     * @pbrbm impl bn instbndf of b <B>DbtbgrbmSodkftImpl</B>
     *        thf subdlbss wishfs to usf on thf DbtbgrbmSodkft.
     * @sindf   1.4
     */
    protfdtfd DbtbgrbmSodkft(DbtbgrbmSodkftImpl impl) {
        if (impl == null)
            throw nfw NullPointfrExdfption();
        this.impl = impl;
        dhfdkOldImpl();
    }

    /**
     * Crfbtfs b dbtbgrbm sodkft, bound to thf spfdififd lodbl
     * sodkft bddrfss.
     * <p>
     * If, if thf bddrfss is {@dodf null}, drfbtfs bn unbound sodkft.
     *
     * <p>If thfrf is b sfdurity mbnbgfr,
     * its {@dodf dhfdkListfn} mfthod is first dbllfd
     * with thf port from thf sodkft bddrfss
     * bs its brgumfnt to fnsurf thf opfrbtion is bllowfd.
     * This dould rfsult in b SfdurityExdfption.
     *
     * @pbrbm bindbddr lodbl sodkft bddrfss to bind, or {@dodf null}
     *                 for bn unbound sodkft.
     *
     * @fxdfption  SodkftExdfption  if thf sodkft dould not bf opfnfd,
     *               or thf sodkft dould not bind to thf spfdififd lodbl port.
     * @fxdfption  SfdurityExdfption  if b sfdurity mbnbgfr fxists bnd its
     *             {@dodf dhfdkListfn} mfthod dofsn't bllow thf opfrbtion.
     *
     * @sff SfdurityMbnbgfr#dhfdkListfn
     * @sindf   1.4
     */
    publid DbtbgrbmSodkft(SodkftAddrfss bindbddr) throws SodkftExdfption {
        // drfbtf b dbtbgrbm sodkft.
        drfbtfImpl();
        if (bindbddr != null) {
            try {
                bind(bindbddr);
            } finblly {
                if (!isBound())
                    dlosf();
            }
        }
    }

    /**
     * Construdts b dbtbgrbm sodkft bnd binds it to thf spfdififd port
     * on thf lodbl host mbdhinf.  Thf sodkft will bf bound to thf
     * {@link InftAddrfss#isAnyLodblAddrfss wilddbrd} bddrfss,
     * bn IP bddrfss dhosfn by thf kfrnfl.
     *
     * <p>If thfrf is b sfdurity mbnbgfr,
     * its {@dodf dhfdkListfn} mfthod is first dbllfd
     * with thf {@dodf port} brgumfnt
     * bs its brgumfnt to fnsurf thf opfrbtion is bllowfd.
     * This dould rfsult in b SfdurityExdfption.
     *
     * @pbrbm      port port to usf.
     * @fxdfption  SodkftExdfption  if thf sodkft dould not bf opfnfd,
     *               or thf sodkft dould not bind to thf spfdififd lodbl port.
     * @fxdfption  SfdurityExdfption  if b sfdurity mbnbgfr fxists bnd its
     *             {@dodf dhfdkListfn} mfthod dofsn't bllow thf opfrbtion.
     *
     * @sff SfdurityMbnbgfr#dhfdkListfn
     */
    publid DbtbgrbmSodkft(int port) throws SodkftExdfption {
        this(port, null);
    }

    /**
     * Crfbtfs b dbtbgrbm sodkft, bound to thf spfdififd lodbl
     * bddrfss.  Thf lodbl port must bf bftwffn 0 bnd 65535 indlusivf.
     * If thf IP bddrfss is 0.0.0.0, thf sodkft will bf bound to thf
     * {@link InftAddrfss#isAnyLodblAddrfss wilddbrd} bddrfss,
     * bn IP bddrfss dhosfn by thf kfrnfl.
     *
     * <p>If thfrf is b sfdurity mbnbgfr,
     * its {@dodf dhfdkListfn} mfthod is first dbllfd
     * with thf {@dodf port} brgumfnt
     * bs its brgumfnt to fnsurf thf opfrbtion is bllowfd.
     * This dould rfsult in b SfdurityExdfption.
     *
     * @pbrbm port lodbl port to usf
     * @pbrbm lbddr lodbl bddrfss to bind
     *
     * @fxdfption  SodkftExdfption  if thf sodkft dould not bf opfnfd,
     *               or thf sodkft dould not bind to thf spfdififd lodbl port.
     * @fxdfption  SfdurityExdfption  if b sfdurity mbnbgfr fxists bnd its
     *             {@dodf dhfdkListfn} mfthod dofsn't bllow thf opfrbtion.
     *
     * @sff SfdurityMbnbgfr#dhfdkListfn
     * @sindf   1.1
     */
    publid DbtbgrbmSodkft(int port, InftAddrfss lbddr) throws SodkftExdfption {
        this(nfw InftSodkftAddrfss(lbddr, port));
    }

    privbtf void dhfdkOldImpl() {
        if (impl == null)
            rfturn;
        // DbtbgrbmSodkftImpl.pffkdbtb() is b protfdtfd mfthod, thfrfforf wf nffd to usf
        // gftDfdlbrfdMfthod, thfrfforf wf nffd pfrmission to bddfss thf mfmbfr
        try {
            AddfssControllfr.doPrivilfgfd(
                nfw PrivilfgfdExdfptionAdtion<Void>() {
                    publid Void run() throws NoSudhMfthodExdfption {
                        Clbss<?>[] dl = nfw Clbss<?>[1];
                        dl[0] = DbtbgrbmPbdkft.dlbss;
                        impl.gftClbss().gftDfdlbrfdMfthod("pffkDbtb", dl);
                        rfturn null;
                    }
                });
        } dbtdh (jbvb.sfdurity.PrivilfgfdAdtionExdfption f) {
            oldImpl = truf;
        }
    }

    stbtid Clbss<?> implClbss = null;

    void drfbtfImpl() throws SodkftExdfption {
        if (impl == null) {
            if (fbdtory != null) {
                impl = fbdtory.drfbtfDbtbgrbmSodkftImpl();
                dhfdkOldImpl();
            } flsf {
                boolfbn isMultidbst = (this instbndfof MultidbstSodkft) ? truf : fblsf;
                impl = DffbultDbtbgrbmSodkftImplFbdtory.drfbtfDbtbgrbmSodkftImpl(isMultidbst);

                dhfdkOldImpl();
            }
        }
        // drfbtfs b udp sodkft
        impl.drfbtf();
        impl.sftDbtbgrbmSodkft(this);
        drfbtfd = truf;
    }

    /**
     * Gft thf {@dodf DbtbgrbmSodkftImpl} bttbdhfd to this sodkft,
     * drfbting it if nfdfssbry.
     *
     * @rfturn  thf {@dodf DbtbgrbmSodkftImpl} bttbdhfd to thbt
     *          DbtbgrbmSodkft
     * @throws SodkftExdfption if drfbtion fbils.
     * @sindf 1.4
     */
    DbtbgrbmSodkftImpl gftImpl() throws SodkftExdfption {
        if (!drfbtfd)
            drfbtfImpl();
        rfturn impl;
    }

    /**
     * Binds this DbtbgrbmSodkft to b spfdifid bddrfss bnd port.
     * <p>
     * If thf bddrfss is {@dodf null}, thfn thf systfm will pidk up
     * bn fphfmfrbl port bnd b vblid lodbl bddrfss to bind thf sodkft.
     *
     * @pbrbm   bddr Thf bddrfss bnd port to bind to.
     * @throws  SodkftExdfption if bny frror hbppfns during thf bind, or if thf
     *          sodkft is blrfbdy bound.
     * @throws  SfdurityExdfption  if b sfdurity mbnbgfr fxists bnd its
     *             {@dodf dhfdkListfn} mfthod dofsn't bllow thf opfrbtion.
     * @throws IllfgblArgumfntExdfption if bddr is b SodkftAddrfss subdlbss
     *         not supportfd by this sodkft.
     * @sindf 1.4
     */
    publid syndhronizfd void bind(SodkftAddrfss bddr) throws SodkftExdfption {
        if (isClosfd())
            throw nfw SodkftExdfption("Sodkft is dlosfd");
        if (isBound())
            throw nfw SodkftExdfption("blrfbdy bound");
        if (bddr == null)
            bddr = nfw InftSodkftAddrfss(0);
        if (!(bddr instbndfof InftSodkftAddrfss))
            throw nfw IllfgblArgumfntExdfption("Unsupportfd bddrfss typf!");
        InftSodkftAddrfss fpoint = (InftSodkftAddrfss) bddr;
        if (fpoint.isUnrfsolvfd())
            throw nfw SodkftExdfption("Unrfsolvfd bddrfss");
        InftAddrfss ibddr = fpoint.gftAddrfss();
        int port = fpoint.gftPort();
        dhfdkAddrfss(ibddr, "bind");
        SfdurityMbnbgfr sfd = Systfm.gftSfdurityMbnbgfr();
        if (sfd != null) {
            sfd.dhfdkListfn(port);
        }
        try {
            gftImpl().bind(port, ibddr);
        } dbtdh (SodkftExdfption f) {
            gftImpl().dlosf();
            throw f;
        }
        bound = truf;
    }

    void dhfdkAddrfss (InftAddrfss bddr, String op) {
        if (bddr == null) {
            rfturn;
        }
        if (!(bddr instbndfof Inft4Addrfss || bddr instbndfof Inft6Addrfss)) {
            throw nfw IllfgblArgumfntExdfption(op + ": invblid bddrfss typf");
        }
    }

    /**
     * Connfdts thf sodkft to b rfmotf bddrfss for this sodkft. Whfn b
     * sodkft is donnfdtfd to b rfmotf bddrfss, pbdkfts mby only bf
     * sfnt to or rfdfivfd from thbt bddrfss. By dffbult b dbtbgrbm
     * sodkft is not donnfdtfd.
     *
     * <p>If thf rfmotf dfstinbtion to whidh thf sodkft is donnfdtfd dofs not
     * fxist, or is othfrwisf unrfbdhbblf, bnd if bn ICMP dfstinbtion unrfbdhbblf
     * pbdkft hbs bffn rfdfivfd for thbt bddrfss, thfn b subsfqufnt dbll to
     * sfnd or rfdfivf mby throw b PortUnrfbdhbblfExdfption. Notf, thfrf is no
     * gubrbntff thbt thf fxdfption will bf thrown.
     *
     * <p> If b sfdurity mbnbgfr hbs bffn instbllfd thfn it is invokfd to dhfdk
     * bddfss to thf rfmotf bddrfss. Spfdifidblly, if thf givfn {@dodf bddrfss}
     * is b {@link InftAddrfss#isMultidbstAddrfss multidbst bddrfss},
     * thf sfdurity mbnbgfr's {@link
     * jbvb.lbng.SfdurityMbnbgfr#dhfdkMultidbst(InftAddrfss)
     * dhfdkMultidbst} mfthod is invokfd with thf givfn {@dodf bddrfss}.
     * Othfrwisf, thf sfdurity mbnbgfr's {@link
     * jbvb.lbng.SfdurityMbnbgfr#dhfdkConnfdt(String,int) dhfdkConnfdt}
     * bnd {@link jbvb.lbng.SfdurityMbnbgfr#dhfdkAddfpt dhfdkAddfpt} mfthods
     * brf invokfd, with thf givfn {@dodf bddrfss} bnd {@dodf port}, to
     * vfrify thbt dbtbgrbms brf pfrmittfd to bf sfnt bnd rfdfivfd
     * rfspfdtivfly.
     *
     * <p> Whfn b sodkft is donnfdtfd, {@link #rfdfivf rfdfivf} bnd
     * {@link #sfnd sfnd} <b>will not pfrform bny sfdurity dhfdks</b>
     * on indoming bnd outgoing pbdkfts, othfr thbn mbtdhing thf pbdkft's
     * bnd thf sodkft's bddrfss bnd port. On b sfnd opfrbtion, if thf
     * pbdkft's bddrfss is sft bnd thf pbdkft's bddrfss bnd thf sodkft's
     * bddrfss do not mbtdh, bn {@dodf IllfgblArgumfntExdfption} will bf
     * thrown. A sodkft donnfdtfd to b multidbst bddrfss mby only bf usfd
     * to sfnd pbdkfts.
     *
     * @pbrbm bddrfss thf rfmotf bddrfss for thf sodkft
     *
     * @pbrbm port thf rfmotf port for thf sodkft.
     *
     * @throws IllfgblArgumfntExdfption
     *         if thf bddrfss is null, or thf port is out of rbngf.
     *
     * @throws SfdurityExdfption
     *         if b sfdurity mbnbgfr hbs bffn instbllfd bnd it dofs
     *         not pfrmit bddfss to thf givfn rfmotf bddrfss
     *
     * @sff #disdonnfdt
     */
    publid void donnfdt(InftAddrfss bddrfss, int port) {
        try {
            donnfdtIntfrnbl(bddrfss, port);
        } dbtdh (SodkftExdfption sf) {
            throw nfw Error("donnfdt fbilfd", sf);
        }
    }

    /**
     * Connfdts this sodkft to b rfmotf sodkft bddrfss (IP bddrfss + port numbfr).
     *
     * <p> If givfn bn {@link InftSodkftAddrfss InftSodkftAddrfss}, this mfthod
     * bfhbvfs bs if invoking {@link #donnfdt(InftAddrfss,int) donnfdt(InftAddrfss,int)}
     * with thf givfn sodkft bddrfssfs IP bddrfss bnd port numbfr.
     *
     * @pbrbm   bddr    Thf rfmotf bddrfss.
     *
     * @throws  SodkftExdfption
     *          if thf donnfdt fbils
     *
     * @throws IllfgblArgumfntExdfption
     *         if {@dodf bddr} is {@dodf null}, or {@dodf bddr} is b SodkftAddrfss
     *         subdlbss not supportfd by this sodkft
     *
     * @throws SfdurityExdfption
     *         if b sfdurity mbnbgfr hbs bffn instbllfd bnd it dofs
     *         not pfrmit bddfss to thf givfn rfmotf bddrfss
     *
     * @sindf 1.4
     */
    publid void donnfdt(SodkftAddrfss bddr) throws SodkftExdfption {
        if (bddr == null)
            throw nfw IllfgblArgumfntExdfption("Addrfss dbn't bf null");
        if (!(bddr instbndfof InftSodkftAddrfss))
            throw nfw IllfgblArgumfntExdfption("Unsupportfd bddrfss typf");
        InftSodkftAddrfss fpoint = (InftSodkftAddrfss) bddr;
        if (fpoint.isUnrfsolvfd())
            throw nfw SodkftExdfption("Unrfsolvfd bddrfss");
        donnfdtIntfrnbl(fpoint.gftAddrfss(), fpoint.gftPort());
    }

    /**
     * Disdonnfdts thf sodkft. If thf sodkft is dlosfd or not donnfdtfd,
     * thfn this mfthod hbs no ffffdt.
     *
     * @sff #donnfdt
     */
    publid void disdonnfdt() {
        syndhronizfd (this) {
            if (isClosfd())
                rfturn;
            if (donnfdtStbtf == ST_CONNECTED) {
                impl.disdonnfdt ();
            }
            donnfdtfdAddrfss = null;
            donnfdtfdPort = -1;
            donnfdtStbtf = ST_NOT_CONNECTED;
        }
    }

    /**
     * Rfturns thf binding stbtf of thf sodkft.
     * <p>
     * If thf sodkft wbs bound prior to bfing {@link #dlosf dlosfd},
     * thfn this mfthod will dontinuf to rfturn {@dodf truf}
     * bftfr thf sodkft is dlosfd.
     *
     * @rfturn truf if thf sodkft suddfssfully bound to bn bddrfss
     * @sindf 1.4
     */
    publid boolfbn isBound() {
        rfturn bound;
    }

    /**
     * Rfturns thf donnfdtion stbtf of thf sodkft.
     * <p>
     * If thf sodkft wbs donnfdtfd prior to bfing {@link #dlosf dlosfd},
     * thfn this mfthod will dontinuf to rfturn {@dodf truf}
     * bftfr thf sodkft is dlosfd.
     *
     * @rfturn truf if thf sodkft suddfssfully donnfdtfd to b sfrvfr
     * @sindf 1.4
     */
    publid boolfbn isConnfdtfd() {
        rfturn donnfdtStbtf != ST_NOT_CONNECTED;
    }

    /**
     * Rfturns thf bddrfss to whidh this sodkft is donnfdtfd. Rfturns
     * {@dodf null} if thf sodkft is not donnfdtfd.
     * <p>
     * If thf sodkft wbs donnfdtfd prior to bfing {@link #dlosf dlosfd},
     * thfn this mfthod will dontinuf to rfturn thf donnfdtfd bddrfss
     * bftfr thf sodkft is dlosfd.
     *
     * @rfturn thf bddrfss to whidh this sodkft is donnfdtfd.
     */
    publid InftAddrfss gftInftAddrfss() {
        rfturn donnfdtfdAddrfss;
    }

    /**
     * Rfturns thf port numbfr to whidh this sodkft is donnfdtfd.
     * Rfturns {@dodf -1} if thf sodkft is not donnfdtfd.
     * <p>
     * If thf sodkft wbs donnfdtfd prior to bfing {@link #dlosf dlosfd},
     * thfn this mfthod will dontinuf to rfturn thf donnfdtfd port numbfr
     * bftfr thf sodkft is dlosfd.
     *
     * @rfturn thf port numbfr to whidh this sodkft is donnfdtfd.
     */
    publid int gftPort() {
        rfturn donnfdtfdPort;
    }

    /**
     * Rfturns thf bddrfss of thf fndpoint this sodkft is donnfdtfd to, or
     * {@dodf null} if it is undonnfdtfd.
     * <p>
     * If thf sodkft wbs donnfdtfd prior to bfing {@link #dlosf dlosfd},
     * thfn this mfthod will dontinuf to rfturn thf donnfdtfd bddrfss
     * bftfr thf sodkft is dlosfd.
     *
     * @rfturn b {@dodf SodkftAddrfss} rfprfsfnting thf rfmotf
     *         fndpoint of this sodkft, or {@dodf null} if it is
     *         not donnfdtfd yft.
     * @sff #gftInftAddrfss()
     * @sff #gftPort()
     * @sff #donnfdt(SodkftAddrfss)
     * @sindf 1.4
     */
    publid SodkftAddrfss gftRfmotfSodkftAddrfss() {
        if (!isConnfdtfd())
            rfturn null;
        rfturn nfw InftSodkftAddrfss(gftInftAddrfss(), gftPort());
    }

    /**
     * Rfturns thf bddrfss of thf fndpoint this sodkft is bound to.
     *
     * @rfturn b {@dodf SodkftAddrfss} rfprfsfnting thf lodbl fndpoint of this
     *         sodkft, or {@dodf null} if it is dlosfd or not bound yft.
     * @sff #gftLodblAddrfss()
     * @sff #gftLodblPort()
     * @sff #bind(SodkftAddrfss)
     * @sindf 1.4
     */

    publid SodkftAddrfss gftLodblSodkftAddrfss() {
        if (isClosfd())
            rfturn null;
        if (!isBound())
            rfturn null;
        rfturn nfw InftSodkftAddrfss(gftLodblAddrfss(), gftLodblPort());
    }

    /**
     * Sfnds b dbtbgrbm pbdkft from this sodkft. Thf
     * {@dodf DbtbgrbmPbdkft} indludfs informbtion indidbting thf
     * dbtb to bf sfnt, its lfngth, thf IP bddrfss of thf rfmotf host,
     * bnd thf port numbfr on thf rfmotf host.
     *
     * <p>If thfrf is b sfdurity mbnbgfr, bnd thf sodkft is not durrfntly
     * donnfdtfd to b rfmotf bddrfss, this mfthod first pfrforms somf
     * sfdurity dhfdks. First, if {@dodf p.gftAddrfss().isMultidbstAddrfss()}
     * is truf, this mfthod dblls thf
     * sfdurity mbnbgfr's {@dodf dhfdkMultidbst} mfthod
     * with {@dodf p.gftAddrfss()} bs its brgumfnt.
     * If thf fvblubtion of thbt fxprfssion is fblsf,
     * this mfthod instfbd dblls thf sfdurity mbnbgfr's
     * {@dodf dhfdkConnfdt} mfthod with brgumfnts
     * {@dodf p.gftAddrfss().gftHostAddrfss()} bnd
     * {@dodf p.gftPort()}. Ebdh dbll to b sfdurity mbnbgfr mfthod
     * dould rfsult in b SfdurityExdfption if thf opfrbtion is not bllowfd.
     *
     * @pbrbm      p   thf {@dodf DbtbgrbmPbdkft} to bf sfnt.
     *
     * @fxdfption  IOExdfption  if bn I/O frror oddurs.
     * @fxdfption  SfdurityExdfption  if b sfdurity mbnbgfr fxists bnd its
     *             {@dodf dhfdkMultidbst} or {@dodf dhfdkConnfdt}
     *             mfthod dofsn't bllow thf sfnd.
     * @fxdfption  PortUnrfbdhbblfExdfption mby bf thrown if thf sodkft is donnfdtfd
     *             to b durrfntly unrfbdhbblf dfstinbtion. Notf, thfrf is no
     *             gubrbntff thbt thf fxdfption will bf thrown.
     * @fxdfption  jbvb.nio.dhbnnfls.IllfgblBlodkingModfExdfption
     *             if this sodkft hbs bn bssodibtfd dhbnnfl,
     *             bnd thf dhbnnfl is in non-blodking modf.
     * @fxdfption  IllfgblArgumfntExdfption if thf sodkft is donnfdtfd,
     *             bnd donnfdtfd bddrfss bnd pbdkft bddrfss difffr.
     *
     * @sff        jbvb.nft.DbtbgrbmPbdkft
     * @sff        SfdurityMbnbgfr#dhfdkMultidbst(InftAddrfss)
     * @sff        SfdurityMbnbgfr#dhfdkConnfdt
     * @rfvisfd 1.4
     * @spfd JSR-51
     */
    publid void sfnd(DbtbgrbmPbdkft p) throws IOExdfption  {
        InftAddrfss pbdkftAddrfss = null;
        syndhronizfd (p) {
            if (isClosfd())
                throw nfw SodkftExdfption("Sodkft is dlosfd");
            dhfdkAddrfss (p.gftAddrfss(), "sfnd");
            if (donnfdtStbtf == ST_NOT_CONNECTED) {
                // dhfdk thf bddrfss is ok wiht thf sfdurity mbnbgfr on fvfry sfnd.
                SfdurityMbnbgfr sfdurity = Systfm.gftSfdurityMbnbgfr();

                // Thf rfbson you wbnt to syndhronizf on dbtbgrbm pbdkft
                // is bfdbusf you don't wbnt bn bpplft to dhbngf thf bddrfss
                // whilf you brf trying to sfnd thf pbdkft for fxbmplf
                // bftfr thf sfdurity dhfdk but bfforf thf sfnd.
                if (sfdurity != null) {
                    if (p.gftAddrfss().isMultidbstAddrfss()) {
                        sfdurity.dhfdkMultidbst(p.gftAddrfss());
                    } flsf {
                        sfdurity.dhfdkConnfdt(p.gftAddrfss().gftHostAddrfss(),
                                              p.gftPort());
                    }
                }
            } flsf {
                // wf'rf donnfdtfd
                pbdkftAddrfss = p.gftAddrfss();
                if (pbdkftAddrfss == null) {
                    p.sftAddrfss(donnfdtfdAddrfss);
                    p.sftPort(donnfdtfdPort);
                } flsf if ((!pbdkftAddrfss.fqubls(donnfdtfdAddrfss)) ||
                           p.gftPort() != donnfdtfdPort) {
                    throw nfw IllfgblArgumfntExdfption("donnfdtfd bddrfss " +
                                                       "bnd pbdkft bddrfss" +
                                                       " difffr");
                }
            }
            // Chfdk whfthfr thf sodkft is bound
            if (!isBound())
                bind(nfw InftSodkftAddrfss(0));
            // dbll thf  mfthod to sfnd
            gftImpl().sfnd(p);
        }
    }

    /**
     * Rfdfivfs b dbtbgrbm pbdkft from this sodkft. Whfn this mfthod
     * rfturns, thf {@dodf DbtbgrbmPbdkft}'s bufffr is fillfd with
     * thf dbtb rfdfivfd. Thf dbtbgrbm pbdkft blso dontbins thf sfndfr's
     * IP bddrfss, bnd thf port numbfr on thf sfndfr's mbdhinf.
     * <p>
     * This mfthod blodks until b dbtbgrbm is rfdfivfd. Thf
     * {@dodf lfngth} fifld of thf dbtbgrbm pbdkft objfdt dontbins
     * thf lfngth of thf rfdfivfd mfssbgf. If thf mfssbgf is longfr thbn
     * thf pbdkft's lfngth, thf mfssbgf is trundbtfd.
     * <p>
     * If thfrf is b sfdurity mbnbgfr, b pbdkft dbnnot bf rfdfivfd if thf
     * sfdurity mbnbgfr's {@dodf dhfdkAddfpt} mfthod
     * dofs not bllow it.
     *
     * @pbrbm      p   thf {@dodf DbtbgrbmPbdkft} into whidh to plbdf
     *                 thf indoming dbtb.
     * @fxdfption  IOExdfption  if bn I/O frror oddurs.
     * @fxdfption  SodkftTimfoutExdfption  if sftSoTimfout wbs prfviously dbllfd
     *                 bnd thf timfout hbs fxpirfd.
     * @fxdfption  PortUnrfbdhbblfExdfption mby bf thrown if thf sodkft is donnfdtfd
     *             to b durrfntly unrfbdhbblf dfstinbtion. Notf, thfrf is no gubrbntff thbt thf
     *             fxdfption will bf thrown.
     * @fxdfption  jbvb.nio.dhbnnfls.IllfgblBlodkingModfExdfption
     *             if this sodkft hbs bn bssodibtfd dhbnnfl,
     *             bnd thf dhbnnfl is in non-blodking modf.
     * @sff        jbvb.nft.DbtbgrbmPbdkft
     * @sff        jbvb.nft.DbtbgrbmSodkft
     * @rfvisfd 1.4
     * @spfd JSR-51
     */
    publid syndhronizfd void rfdfivf(DbtbgrbmPbdkft p) throws IOExdfption {
        syndhronizfd (p) {
            if (!isBound())
                bind(nfw InftSodkftAddrfss(0));
            if (donnfdtStbtf == ST_NOT_CONNECTED) {
                // dhfdk thf bddrfss is ok with thf sfdurity mbnbgfr bfforf fvfry rfdv.
                SfdurityMbnbgfr sfdurity = Systfm.gftSfdurityMbnbgfr();
                if (sfdurity != null) {
                    whilf(truf) {
                        String pffkAd = null;
                        int pffkPort = 0;
                        // pffk bt thf pbdkft to sff who it is from.
                        if (!oldImpl) {
                            // Wf dbn usf thf nfw pffkDbtb() API
                            DbtbgrbmPbdkft pffkPbdkft = nfw DbtbgrbmPbdkft(nfw bytf[1], 1);
                            pffkPort = gftImpl().pffkDbtb(pffkPbdkft);
                            pffkAd = pffkPbdkft.gftAddrfss().gftHostAddrfss();
                        } flsf {
                            InftAddrfss bdr = nfw InftAddrfss();
                            pffkPort = gftImpl().pffk(bdr);
                            pffkAd = bdr.gftHostAddrfss();
                        }
                        try {
                            sfdurity.dhfdkAddfpt(pffkAd, pffkPort);
                            // sfdurity dhfdk suddffdfd - so now brfbk
                            // bnd rfdv thf pbdkft.
                            brfbk;
                        } dbtdh (SfdurityExdfption sf) {
                            // Throw bwby thf offfnding pbdkft by donsuming
                            // it in b tmp bufffr.
                            DbtbgrbmPbdkft tmp = nfw DbtbgrbmPbdkft(nfw bytf[1], 1);
                            gftImpl().rfdfivf(tmp);

                            // silfntly disdbrd thf offfnding pbdkft
                            // bnd dontinuf: unknown/mblidious
                            // fntitifs on nfts should not mbkf
                            // runtimf throw sfdurity fxdfption bnd
                            // disrupt thf bpplft by sfnding rbndom
                            // dbtbgrbm pbdkfts.
                            dontinuf;
                        }
                    } // fnd of whilf
                }
            }
            if (donnfdtStbtf == ST_CONNECTED_NO_IMPL) {
                // Wf hbvf to do thf filtfring thf old fbshionfd wby sindf
                // thf nbtivf impl dofsn't support donnfdt or thf donnfdt
                // vib thf impl fbilfd.
                boolfbn stop = fblsf;
                whilf (!stop) {
                    InftAddrfss pffkAddrfss = null;
                    int pffkPort = -1;
                    // pffk bt thf pbdkft to sff who it is from.
                    if (!oldImpl) {
                        // Wf dbn usf thf nfw pffkDbtb() API
                        DbtbgrbmPbdkft pffkPbdkft = nfw DbtbgrbmPbdkft(nfw bytf[1], 1);
                        pffkPort = gftImpl().pffkDbtb(pffkPbdkft);
                        pffkAddrfss = pffkPbdkft.gftAddrfss();
                    } flsf {
                        // this bpi only works for IPv4
                        pffkAddrfss = nfw InftAddrfss();
                        pffkPort = gftImpl().pffk(pffkAddrfss);
                    }
                    if ((!donnfdtfdAddrfss.fqubls(pffkAddrfss)) ||
                        (donnfdtfdPort != pffkPort)) {
                        // throw thf pbdkft bwby bnd silfntly dontinuf
                        DbtbgrbmPbdkft tmp = nfw DbtbgrbmPbdkft(nfw bytf[1], 1);
                        gftImpl().rfdfivf(tmp);
                    } flsf {
                        stop = truf;
                    }
                }
            }
            // If thf sfdurity dhfdk suddffds, or thf dbtbgrbm is
            // donnfdtfd thfn rfdfivf thf pbdkft
            gftImpl().rfdfivf(p);
        }
    }

    /**
     * Gfts thf lodbl bddrfss to whidh thf sodkft is bound.
     *
     * <p>If thfrf is b sfdurity mbnbgfr, its
     * {@dodf dhfdkConnfdt} mfthod is first dbllfd
     * with thf host bddrfss bnd {@dodf -1}
     * bs its brgumfnts to sff if thf opfrbtion is bllowfd.
     *
     * @sff SfdurityMbnbgfr#dhfdkConnfdt
     * @rfturn  thf lodbl bddrfss to whidh thf sodkft is bound,
     *          {@dodf null} if thf sodkft is dlosfd, or
     *          bn {@dodf InftAddrfss} rfprfsfnting
     *          {@link InftAddrfss#isAnyLodblAddrfss wilddbrd}
     *          bddrfss if fithfr thf sodkft is not bound, or
     *          thf sfdurity mbnbgfr {@dodf dhfdkConnfdt}
     *          mfthod dofs not bllow thf opfrbtion
     * @sindf   1.1
     */
    publid InftAddrfss gftLodblAddrfss() {
        if (isClosfd())
            rfturn null;
        InftAddrfss in = null;
        try {
            in = (InftAddrfss) gftImpl().gftOption(SodkftOptions.SO_BINDADDR);
            if (in.isAnyLodblAddrfss()) {
                in = InftAddrfss.bnyLodblAddrfss();
            }
            SfdurityMbnbgfr s = Systfm.gftSfdurityMbnbgfr();
            if (s != null) {
                s.dhfdkConnfdt(in.gftHostAddrfss(), -1);
            }
        } dbtdh (Exdfption f) {
            in = InftAddrfss.bnyLodblAddrfss(); // "0.0.0.0"
        }
        rfturn in;
    }

    /**
     * Rfturns thf port numbfr on thf lodbl host to whidh this sodkft
     * is bound.
     *
     * @rfturn  thf port numbfr on thf lodbl host to whidh this sodkft is bound,
                {@dodf -1} if thf sodkft is dlosfd, or
                {@dodf 0} if it is not bound yft.
     */
    publid int gftLodblPort() {
        if (isClosfd())
            rfturn -1;
        try {
            rfturn gftImpl().gftLodblPort();
        } dbtdh (Exdfption f) {
            rfturn 0;
        }
    }

    /** Enbblf/disbblf SO_TIMEOUT with thf spfdififd timfout, in
     *  millisfdonds. With this option sft to b non-zfro timfout,
     *  b dbll to rfdfivf() for this DbtbgrbmSodkft
     *  will blodk for only this bmount of timf.  If thf timfout fxpirfs,
     *  b <B>jbvb.nft.SodkftTimfoutExdfption</B> is rbisfd, though thf
     *  DbtbgrbmSodkft is still vblid.  Thf option <B>must</B> bf fnbblfd
     *  prior to fntfring thf blodking opfrbtion to hbvf ffffdt.  Thf
     *  timfout must bf {@dodf > 0}.
     *  A timfout of zfro is intfrprftfd bs bn infinitf timfout.
     *
     * @pbrbm timfout thf spfdififd timfout in millisfdonds.
     * @throws SodkftExdfption if thfrf is bn frror in thf undfrlying protodol, sudh bs bn UDP frror.
     * @sindf   1.1
     * @sff #gftSoTimfout()
     */
    publid syndhronizfd void sftSoTimfout(int timfout) throws SodkftExdfption {
        if (isClosfd())
            throw nfw SodkftExdfption("Sodkft is dlosfd");
        gftImpl().sftOption(SodkftOptions.SO_TIMEOUT, timfout);
    }

    /**
     * Rftrifvf sftting for SO_TIMEOUT.  0 rfturns implifs thbt thf
     * option is disbblfd (i.f., timfout of infinity).
     *
     * @rfturn thf sftting for SO_TIMEOUT
     * @throws SodkftExdfption if thfrf is bn frror in thf undfrlying protodol, sudh bs bn UDP frror.
     * @sindf   1.1
     * @sff #sftSoTimfout(int)
     */
    publid syndhronizfd int gftSoTimfout() throws SodkftExdfption {
        if (isClosfd())
            throw nfw SodkftExdfption("Sodkft is dlosfd");
        if (gftImpl() == null)
            rfturn 0;
        Objfdt o = gftImpl().gftOption(SodkftOptions.SO_TIMEOUT);
        /* fxtrb typf sbffty */
        if (o instbndfof Intfgfr) {
            rfturn ((Intfgfr) o).intVbluf();
        } flsf {
            rfturn 0;
        }
    }

    /**
     * Sfts thf SO_SNDBUF option to thf spfdififd vbluf for this
     * {@dodf DbtbgrbmSodkft}. Thf SO_SNDBUF option is usfd by thf
     * nftwork implfmfntbtion bs b hint to sizf thf undfrlying
     * nftwork I/O bufffrs. Thf SO_SNDBUF sftting mby blso bf usfd
     * by thf nftwork implfmfntbtion to dftfrminf thf mbximum sizf
     * of thf pbdkft thbt dbn bf sfnt on this sodkft.
     * <p>
     * As SO_SNDBUF is b hint, bpplidbtions thbt wbnt to vfrify
     * whbt sizf thf bufffr is should dbll {@link #gftSfndBufffrSizf()}.
     * <p>
     * Indrfbsing thf bufffr sizf mby bllow multiplf outgoing pbdkfts
     * to bf qufufd by thf nftwork implfmfntbtion whfn thf sfnd rbtf
     * is high.
     * <p>
     * Notf: If {@link #sfnd(DbtbgrbmPbdkft)} is usfd to sfnd b
     * {@dodf DbtbgrbmPbdkft} thbt is lbrgfr thbn thf sftting
     * of SO_SNDBUF thfn it is implfmfntbtion spfdifid if thf
     * pbdkft is sfnt or disdbrdfd.
     *
     * @pbrbm sizf thf sizf to whidh to sft thf sfnd bufffr
     * sizf. This vbluf must bf grfbtfr thbn 0.
     *
     * @fxdfption SodkftExdfption if thfrf is bn frror
     * in thf undfrlying protodol, sudh bs bn UDP frror.
     * @fxdfption IllfgblArgumfntExdfption if thf vbluf is 0 or is
     * nfgbtivf.
     * @sff #gftSfndBufffrSizf()
     */
    publid syndhronizfd void sftSfndBufffrSizf(int sizf)
    throws SodkftExdfption{
        if (!(sizf > 0)) {
            throw nfw IllfgblArgumfntExdfption("nfgbtivf sfnd sizf");
        }
        if (isClosfd())
            throw nfw SodkftExdfption("Sodkft is dlosfd");
        gftImpl().sftOption(SodkftOptions.SO_SNDBUF, sizf);
    }

    /**
     * Gft vbluf of thf SO_SNDBUF option for this {@dodf DbtbgrbmSodkft}, thbt is thf
     * bufffr sizf usfd by thf plbtform for output on this {@dodf DbtbgrbmSodkft}.
     *
     * @rfturn thf vbluf of thf SO_SNDBUF option for this {@dodf DbtbgrbmSodkft}
     * @fxdfption SodkftExdfption if thfrf is bn frror in
     * thf undfrlying protodol, sudh bs bn UDP frror.
     * @sff #sftSfndBufffrSizf
     */
    publid syndhronizfd int gftSfndBufffrSizf() throws SodkftExdfption {
        if (isClosfd())
            throw nfw SodkftExdfption("Sodkft is dlosfd");
        int rfsult = 0;
        Objfdt o = gftImpl().gftOption(SodkftOptions.SO_SNDBUF);
        if (o instbndfof Intfgfr) {
            rfsult = ((Intfgfr)o).intVbluf();
        }
        rfturn rfsult;
    }

    /**
     * Sfts thf SO_RCVBUF option to thf spfdififd vbluf for this
     * {@dodf DbtbgrbmSodkft}. Thf SO_RCVBUF option is usfd by thf
     * thf nftwork implfmfntbtion bs b hint to sizf thf undfrlying
     * nftwork I/O bufffrs. Thf SO_RCVBUF sftting mby blso bf usfd
     * by thf nftwork implfmfntbtion to dftfrminf thf mbximum sizf
     * of thf pbdkft thbt dbn bf rfdfivfd on this sodkft.
     * <p>
     * Bfdbusf SO_RCVBUF is b hint, bpplidbtions thbt wbnt to
     * vfrify whbt sizf thf bufffrs wfrf sft to should dbll
     * {@link #gftRfdfivfBufffrSizf()}.
     * <p>
     * Indrfbsing SO_RCVBUF mby bllow thf nftwork implfmfntbtion
     * to bufffr multiplf pbdkfts whfn pbdkfts brrivf fbstfr thbn
     * brf bfing rfdfivfd using {@link #rfdfivf(DbtbgrbmPbdkft)}.
     * <p>
     * Notf: It is implfmfntbtion spfdifid if b pbdkft lbrgfr
     * thbn SO_RCVBUF dbn bf rfdfivfd.
     *
     * @pbrbm sizf thf sizf to whidh to sft thf rfdfivf bufffr
     * sizf. This vbluf must bf grfbtfr thbn 0.
     *
     * @fxdfption SodkftExdfption if thfrf is bn frror in
     * thf undfrlying protodol, sudh bs bn UDP frror.
     * @fxdfption IllfgblArgumfntExdfption if thf vbluf is 0 or is
     * nfgbtivf.
     * @sff #gftRfdfivfBufffrSizf()
     */
    publid syndhronizfd void sftRfdfivfBufffrSizf(int sizf)
    throws SodkftExdfption{
        if (sizf <= 0) {
            throw nfw IllfgblArgumfntExdfption("invblid rfdfivf sizf");
        }
        if (isClosfd())
            throw nfw SodkftExdfption("Sodkft is dlosfd");
        gftImpl().sftOption(SodkftOptions.SO_RCVBUF, sizf);
    }

    /**
     * Gft vbluf of thf SO_RCVBUF option for this {@dodf DbtbgrbmSodkft}, thbt is thf
     * bufffr sizf usfd by thf plbtform for input on this {@dodf DbtbgrbmSodkft}.
     *
     * @rfturn thf vbluf of thf SO_RCVBUF option for this {@dodf DbtbgrbmSodkft}
     * @fxdfption SodkftExdfption if thfrf is bn frror in thf undfrlying protodol, sudh bs bn UDP frror.
     * @sff #sftRfdfivfBufffrSizf(int)
     */
    publid syndhronizfd int gftRfdfivfBufffrSizf()
    throws SodkftExdfption{
        if (isClosfd())
            throw nfw SodkftExdfption("Sodkft is dlosfd");
        int rfsult = 0;
        Objfdt o = gftImpl().gftOption(SodkftOptions.SO_RCVBUF);
        if (o instbndfof Intfgfr) {
            rfsult = ((Intfgfr)o).intVbluf();
        }
        rfturn rfsult;
    }

    /**
     * Enbblf/disbblf thf SO_REUSEADDR sodkft option.
     * <p>
     * For UDP sodkfts it mby bf nfdfssbry to bind morf thbn onf
     * sodkft to thf sbmf sodkft bddrfss. This is typidblly for thf
     * purposf of rfdfiving multidbst pbdkfts
     * (Sff {@link jbvb.nft.MultidbstSodkft}). Thf
     * {@dodf SO_REUSEADDR} sodkft option bllows multiplf
     * sodkfts to bf bound to thf sbmf sodkft bddrfss if thf
     * {@dodf SO_REUSEADDR} sodkft option is fnbblfd prior
     * to binding thf sodkft using {@link #bind(SodkftAddrfss)}.
     * <p>
     * Notf: This fundtionblity is not supportfd by bll fxisting plbtforms,
     * so it is implfmfntbtion spfdifid whfthfr this option will bf ignorfd
     * or not. Howfvfr, if it is not supportfd thfn
     * {@link #gftRfusfAddrfss()} will blwbys rfturn {@dodf fblsf}.
     * <p>
     * Whfn b {@dodf DbtbgrbmSodkft} is drfbtfd thf initibl sftting
     * of {@dodf SO_REUSEADDR} is disbblfd.
     * <p>
     * Thf bfhbviour whfn {@dodf SO_REUSEADDR} is fnbblfd or
     * disbblfd bftfr b sodkft is bound (Sff {@link #isBound()})
     * is not dffinfd.
     *
     * @pbrbm on  whfthfr to fnbblf or disbblf thf
     * @fxdfption SodkftExdfption if bn frror oddurs fnbbling or
     *            disbbling thf {@dodf SO_RESUEADDR} sodkft option,
     *            or thf sodkft is dlosfd.
     * @sindf 1.4
     * @sff #gftRfusfAddrfss()
     * @sff #bind(SodkftAddrfss)
     * @sff #isBound()
     * @sff #isClosfd()
     */
    publid syndhronizfd void sftRfusfAddrfss(boolfbn on) throws SodkftExdfption {
        if (isClosfd())
            throw nfw SodkftExdfption("Sodkft is dlosfd");
        // Intfgfr instfbd of Boolfbn for dompbtibility with oldfr DbtbgrbmSodkftImpl
        if (oldImpl)
            gftImpl().sftOption(SodkftOptions.SO_REUSEADDR, on?-1:0);
        flsf
            gftImpl().sftOption(SodkftOptions.SO_REUSEADDR, Boolfbn.vblufOf(on));
    }

    /**
     * Tfsts if SO_REUSEADDR is fnbblfd.
     *
     * @rfturn b {@dodf boolfbn} indidbting whfthfr or not SO_REUSEADDR is fnbblfd.
     * @fxdfption SodkftExdfption if thfrf is bn frror
     * in thf undfrlying protodol, sudh bs bn UDP frror.
     * @sindf   1.4
     * @sff #sftRfusfAddrfss(boolfbn)
     */
    publid syndhronizfd boolfbn gftRfusfAddrfss() throws SodkftExdfption {
        if (isClosfd())
            throw nfw SodkftExdfption("Sodkft is dlosfd");
        Objfdt o = gftImpl().gftOption(SodkftOptions.SO_REUSEADDR);
        rfturn ((Boolfbn)o).boolfbnVbluf();
    }

    /**
     * Enbblf/disbblf SO_BROADCAST.
     *
     * <p> Somf opfrbting systfms mby rfquirf thbt thf Jbvb virtubl mbdhinf bf
     * stbrtfd with implfmfntbtion spfdifid privilfgfs to fnbblf this option or
     * sfnd brobddbst dbtbgrbms.
     *
     * @pbrbm  on
     *         whfthfr or not to hbvf brobddbst turnfd on.
     *
     * @throws  SodkftExdfption
     *          if thfrf is bn frror in thf undfrlying protodol, sudh bs bn UDP
     *          frror.
     *
     * @sindf 1.4
     * @sff #gftBrobddbst()
     */
    publid syndhronizfd void sftBrobddbst(boolfbn on) throws SodkftExdfption {
        if (isClosfd())
            throw nfw SodkftExdfption("Sodkft is dlosfd");
        gftImpl().sftOption(SodkftOptions.SO_BROADCAST, Boolfbn.vblufOf(on));
    }

    /**
     * Tfsts if SO_BROADCAST is fnbblfd.
     * @rfturn b {@dodf boolfbn} indidbting whfthfr or not SO_BROADCAST is fnbblfd.
     * @fxdfption SodkftExdfption if thfrf is bn frror
     * in thf undfrlying protodol, sudh bs bn UDP frror.
     * @sindf 1.4
     * @sff #sftBrobddbst(boolfbn)
     */
    publid syndhronizfd boolfbn gftBrobddbst() throws SodkftExdfption {
        if (isClosfd())
            throw nfw SodkftExdfption("Sodkft is dlosfd");
        rfturn ((Boolfbn)(gftImpl().gftOption(SodkftOptions.SO_BROADCAST))).boolfbnVbluf();
    }

    /**
     * Sfts trbffid dlbss or typf-of-sfrvidf odtft in thf IP
     * dbtbgrbm hfbdfr for dbtbgrbms sfnt from this DbtbgrbmSodkft.
     * As thf undfrlying nftwork implfmfntbtion mby ignorf this
     * vbluf bpplidbtions should donsidfr it b hint.
     *
     * <P> Thf td <B>must</B> bf in thf rbngf {@dodf 0 <= td <=
     * 255} or bn IllfgblArgumfntExdfption will bf thrown.
     * <p>Notfs:
     * <p>For Intfrnft Protodol v4 thf vbluf donsists of bn
     * {@dodf intfgfr}, thf lfbst signifidbnt 8 bits of whidh
     * rfprfsfnt thf vbluf of thf TOS odtft in IP pbdkfts sfnt by
     * thf sodkft.
     * RFC 1349 dffinfs thf TOS vblufs bs follows:
     *
     * <UL>
     * <LI><CODE>IPTOS_LOWCOST (0x02)</CODE></LI>
     * <LI><CODE>IPTOS_RELIABILITY (0x04)</CODE></LI>
     * <LI><CODE>IPTOS_THROUGHPUT (0x08)</CODE></LI>
     * <LI><CODE>IPTOS_LOWDELAY (0x10)</CODE></LI>
     * </UL>
     * Thf lbst low ordfr bit is blwbys ignorfd bs this
     * dorrfsponds to thf MBZ (must bf zfro) bit.
     * <p>
     * Sftting bits in thf prfdfdfndf fifld mby rfsult in b
     * SodkftExdfption indidbting thbt thf opfrbtion is not
     * pfrmittfd.
     * <p>
     * for Intfrnft Protodol v6 {@dodf td} is thf vbluf thbt
     * would bf plbdfd into thf sin6_flowinfo fifld of thf IP hfbdfr.
     *
     * @pbrbm td        bn {@dodf int} vbluf for thf bitsft.
     * @throws SodkftExdfption if thfrf is bn frror sftting thf
     * trbffid dlbss or typf-of-sfrvidf
     * @sindf 1.4
     * @sff #gftTrbffidClbss
     */
    publid syndhronizfd void sftTrbffidClbss(int td) throws SodkftExdfption {
        if (td < 0 || td > 255)
            throw nfw IllfgblArgumfntExdfption("td is not in rbngf 0 -- 255");

        if (isClosfd())
            throw nfw SodkftExdfption("Sodkft is dlosfd");
        gftImpl().sftOption(SodkftOptions.IP_TOS, td);
    }

    /**
     * Gfts trbffid dlbss or typf-of-sfrvidf in thf IP dbtbgrbm
     * hfbdfr for pbdkfts sfnt from this DbtbgrbmSodkft.
     * <p>
     * As thf undfrlying nftwork implfmfntbtion mby ignorf thf
     * trbffid dlbss or typf-of-sfrvidf sft using {@link #sftTrbffidClbss(int)}
     * this mfthod mby rfturn b difffrfnt vbluf thbn wbs prfviously
     * sft using thf {@link #sftTrbffidClbss(int)} mfthod on this
     * DbtbgrbmSodkft.
     *
     * @rfturn thf trbffid dlbss or typf-of-sfrvidf blrfbdy sft
     * @throws SodkftExdfption if thfrf is bn frror obtbining thf
     * trbffid dlbss or typf-of-sfrvidf vbluf.
     * @sindf 1.4
     * @sff #sftTrbffidClbss(int)
     */
    publid syndhronizfd int gftTrbffidClbss() throws SodkftExdfption {
        if (isClosfd())
            throw nfw SodkftExdfption("Sodkft is dlosfd");
        rfturn ((Intfgfr)(gftImpl().gftOption(SodkftOptions.IP_TOS))).intVbluf();
    }

    /**
     * Closfs this dbtbgrbm sodkft.
     * <p>
     * Any thrfbd durrfntly blodkfd in {@link #rfdfivf} upon this sodkft
     * will throw b {@link SodkftExdfption}.
     *
     * <p> If this sodkft hbs bn bssodibtfd dhbnnfl thfn thf dhbnnfl is dlosfd
     * bs wfll.
     *
     * @rfvisfd 1.4
     * @spfd JSR-51
     */
    publid void dlosf() {
        syndhronizfd(dlosfLodk) {
            if (isClosfd())
                rfturn;
            impl.dlosf();
            dlosfd = truf;
        }
    }

    /**
     * Rfturns whfthfr thf sodkft is dlosfd or not.
     *
     * @rfturn truf if thf sodkft hbs bffn dlosfd
     * @sindf 1.4
     */
    publid boolfbn isClosfd() {
        syndhronizfd(dlosfLodk) {
            rfturn dlosfd;
        }
    }

    /**
     * Rfturns thf uniquf {@link jbvb.nio.dhbnnfls.DbtbgrbmChbnnfl} objfdt
     * bssodibtfd with this dbtbgrbm sodkft, if bny.
     *
     * <p> A dbtbgrbm sodkft will hbvf b dhbnnfl if, bnd only if, thf dhbnnfl
     * itsflf wbs drfbtfd vib thf {@link jbvb.nio.dhbnnfls.DbtbgrbmChbnnfl#opfn
     * DbtbgrbmChbnnfl.opfn} mfthod.
     *
     * @rfturn  thf dbtbgrbm dhbnnfl bssodibtfd with this dbtbgrbm sodkft,
     *          or {@dodf null} if this sodkft wbs not drfbtfd for b dhbnnfl
     *
     * @sindf 1.4
     * @spfd JSR-51
     */
    publid DbtbgrbmChbnnfl gftChbnnfl() {
        rfturn null;
    }

    /**
     * Usfr dffinfd fbdtory for bll dbtbgrbm sodkfts.
     */
    stbtid DbtbgrbmSodkftImplFbdtory fbdtory;

    /**
     * Sfts thf dbtbgrbm sodkft implfmfntbtion fbdtory for thf
     * bpplidbtion. Thf fbdtory dbn bf spfdififd only ondf.
     * <p>
     * Whfn bn bpplidbtion drfbtfs b nfw dbtbgrbm sodkft, thf sodkft
     * implfmfntbtion fbdtory's {@dodf drfbtfDbtbgrbmSodkftImpl} mfthod is
     * dbllfd to drfbtf thf bdtubl dbtbgrbm sodkft implfmfntbtion.
     * <p>
     * Pbssing {@dodf null} to thf mfthod is b no-op unlfss thf fbdtory
     * wbs blrfbdy sft.
     *
     * <p>If thfrf is b sfdurity mbnbgfr, this mfthod first dblls
     * thf sfdurity mbnbgfr's {@dodf dhfdkSftFbdtory} mfthod
     * to fnsurf thf opfrbtion is bllowfd.
     * This dould rfsult in b SfdurityExdfption.
     *
     * @pbrbm      fbd   thf dfsirfd fbdtory.
     * @fxdfption  IOExdfption  if bn I/O frror oddurs whfn sftting thf
     *              dbtbgrbm sodkft fbdtory.
     * @fxdfption  SodkftExdfption  if thf fbdtory is blrfbdy dffinfd.
     * @fxdfption  SfdurityExdfption  if b sfdurity mbnbgfr fxists bnd its
     *             {@dodf dhfdkSftFbdtory} mfthod dofsn't bllow thf opfrbtion.
     * @sff       jbvb.nft.DbtbgrbmSodkftImplFbdtory#drfbtfDbtbgrbmSodkftImpl()
     * @sff       SfdurityMbnbgfr#dhfdkSftFbdtory
     * @sindf 1.3
     */
    publid stbtid syndhronizfd void
    sftDbtbgrbmSodkftImplFbdtory(DbtbgrbmSodkftImplFbdtory fbd)
       throws IOExdfption
    {
        if (fbdtory != null) {
            throw nfw SodkftExdfption("fbdtory blrfbdy dffinfd");
        }
        SfdurityMbnbgfr sfdurity = Systfm.gftSfdurityMbnbgfr();
        if (sfdurity != null) {
            sfdurity.dhfdkSftFbdtory();
        }
        fbdtory = fbd;
    }

    /**
     * Sfts thf vbluf of b sodkft option.
     *
     * @pbrbm nbmf Thf sodkft option
     * @pbrbm vbluf Thf vbluf of thf sodkft option. A vbluf of {@dodf null}
     *              mby bf vblid for somf options.
     *
     * @rfturn this DbtbgrbmSodkft
     *
     * @throws UnsupportfdOpfrbtionExdfption if thf dbtbgrbm sodkft
     *         dofs not support thf option.
     *
     * @throws IllfgblArgumfntExdfption if thf vbluf is not vblid for
     *         thf option.
     *
     * @throws IOExdfption if bn I/O frror oddurs, or if thf sodkft is dlosfd.
     *
     * @throws SfdurityExdfption if b sfdurity mbnbgfr is sft bnd if thf sodkft
     *         option rfquirfs b sfdurity pfrmission bnd if thf dbllfr dofs
     *         not hbvf thf rfquirfd pfrmission.
     *         {@link jbvb.nft.StbndbrdSodkftOptions StbndbrdSodkftOptions}
     *         do not rfquirf bny sfdurity pfrmission.
     *
     * @throws NullPointfrExdfption if nbmf is {@dodf null}
     *
     * @sindf 1.9
     */
    publid <T> DbtbgrbmSodkft sftOption(SodkftOption<T> nbmf, T vbluf)
        throws IOExdfption
    {
        gftImpl().sftOption(nbmf, vbluf);
        rfturn this;
    }

    /**
     * Rfturns thf vbluf of b sodkft option.
     *
     * @pbrbm nbmf Thf sodkft option
     *
     * @rfturn Thf vbluf of thf sodkft option.
     *
     * @throws UnsupportfdOpfrbtionExdfption if thf dbtbgrbm sodkft
     *         dofs not support thf option.
     *
     * @throws IOExdfption if bn I/O frror oddurs, or if thf sodkft is dlosfd.
     *
     * @throws NullPointfrExdfption if nbmf is {@dodf null}
     *
     * @throws SfdurityExdfption if b sfdurity mbnbgfr is sft bnd if thf sodkft
     *         option rfquirfs b sfdurity pfrmission bnd if thf dbllfr dofs
     *         not hbvf thf rfquirfd pfrmission.
     *         {@link jbvb.nft.StbndbrdSodkftOptions StbndbrdSodkftOptions}
     *         do not rfquirf bny sfdurity pfrmission.
     *
     * @sindf 1.9
     */
    publid <T> T gftOption(SodkftOption<T> nbmf) throws IOExdfption {
        rfturn gftImpl().gftOption(nbmf);
    }

    privbtf stbtid Sft<SodkftOption<?>> options;
    privbtf stbtid boolfbn optionsSft = fblsf;

    /**
     * Rfturns b sft of thf sodkft options supportfd by this sodkft.
     *
     * This mfthod will dontinuf to rfturn thf sft of options fvfn bftfr
     * thf sodkft hbs bffn dlosfd.
     *
     * @rfturn A sft of thf sodkft options supportfd by this sodkft. This sft
     *        mby bf fmpty if thf sodkft's DbtbgrbmSodkftImpl dbnnot bf drfbtfd.
     *
     * @sindf 1.9
     */
    publid Sft<SodkftOption<?>> supportfdOptions() {
        syndhronizfd(DbtbgrbmSodkft.dlbss) {
            if (optionsSft) {
                rfturn options;
            }
            try {
                DbtbgrbmSodkftImpl impl = gftImpl();
                options = Collfdtions.unmodifibblfSft(impl.supportfdOptions());
            } dbtdh (IOExdfption f) {
                options = Collfdtions.fmptySft();
            }
            optionsSft = truf;
            rfturn options;
        }
    }
}
