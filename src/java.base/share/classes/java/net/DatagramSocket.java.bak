/*
 * Copyrigit (d) 1995, 2013, Orbdlf bnd/or its bffilibtfs. All rigits rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Tiis dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr tif tfrms of tif GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publisifd by tif Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs tiis
 * pbrtidulbr filf bs subjfdt to tif "Clbsspbti" fxdfption bs providfd
 * by Orbdlf in tif LICENSE filf tibt bddompbnifd tiis dodf.
 *
 * Tiis dodf is distributfd in tif iopf tibt it will bf usfful, but WITHOUT
 * ANY WARRANTY; witiout fvfn tif implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff tif GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in tif LICENSE filf tibt
 * bddompbnifd tiis dodf).
 *
 * You siould ibvf rfdfivfd b dopy of tif GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong witi tiis work; if not, writf to tif Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifti Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Siorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or ibvf bny
 * qufstions.
 */

pbdkbgf jbvb.nft;

import jbvb.io.IOExdfption;
import jbvb.nio.dibnnfls.DbtbgrbmCibnnfl;
import jbvb.sfdurity.AddfssControllfr;
import jbvb.sfdurity.PrivilfgfdExdfptionAdtion;
import jbvb.util.Sft;
import jbvb.util.Collfdtions;

/**
 * Tiis dlbss rfprfsfnts b sodkft for sfnding bnd rfdfiving dbtbgrbm pbdkfts.
 *
 * <p>A dbtbgrbm sodkft is tif sfnding or rfdfiving point for b pbdkft
 * dflivfry sfrvidf. Ebdi pbdkft sfnt or rfdfivfd on b dbtbgrbm sodkft
 * is individublly bddrfssfd bnd routfd. Multiplf pbdkfts sfnt from
 * onf mbdiinf to bnotifr mby bf routfd difffrfntly, bnd mby brrivf in
 * bny ordfr.
 *
 * <p> Wifrf possiblf, b nfwly donstrudtfd {@dodf DbtbgrbmSodkft} ibs tif
 * {@link SodkftOptions#SO_BROADCAST SO_BROADCAST} sodkft option fnbblfd so bs
 * to bllow tif trbnsmission of brobddbst dbtbgrbms. In ordfr to rfdfivf
 * brobddbst pbdkfts b DbtbgrbmSodkft siould bf bound to tif wilddbrd bddrfss.
 * In somf implfmfntbtions, brobddbst pbdkfts mby blso bf rfdfivfd wifn
 * b DbtbgrbmSodkft is bound to b morf spfdifid bddrfss.
 * <p>
 * Exbmplf:
 * {@dodf
 *              DbtbgrbmSodkft s = nfw DbtbgrbmSodkft(null);
 *              s.bind(nfw InftSodkftAddrfss(8888));
 * }
 * Wiidi is fquivblfnt to:
 * {@dodf
 *              DbtbgrbmSodkft s = nfw DbtbgrbmSodkft(8888);
 * }
 * Boti dbsfs will drfbtf b DbtbgrbmSodkft bblf to rfdfivf brobddbsts on
 * UDP port 8888.
 *
 * @butior  Pbvbni Diwbnji
 * @sff     jbvb.nft.DbtbgrbmPbdkft
 * @sff     jbvb.nio.dibnnfls.DbtbgrbmCibnnfl
 * @sindf 1.0
 */
publid
dlbss DbtbgrbmSodkft implfmfnts jbvb.io.Closfbblf {
    /**
     * Vbrious stbtfs of tiis sodkft.
     */
    privbtf boolfbn drfbtfd = fblsf;
    privbtf boolfbn bound = fblsf;
    privbtf boolfbn dlosfd = fblsf;
    privbtf Objfdt dlosfLodk = nfw Objfdt();

    /*
     * Tif implfmfntbtion of tiis DbtbgrbmSodkft.
     */
    DbtbgrbmSodkftImpl impl;

    /**
     * Arf wf using bn oldfr DbtbgrbmSodkftImpl?
     */
    boolfbn oldImpl = fblsf;

    /*
     * Connfdtion stbtf:
     * ST_NOT_CONNECTED = sodkft not donnfdtfd
     * ST_CONNECTED = sodkft donnfdtfd
     * ST_CONNECTED_NO_IMPL = sodkft donnfdtfd but not bt impl lfvfl
     */
    stbtid finbl int ST_NOT_CONNECTED = 0;
    stbtid finbl int ST_CONNECTED = 1;
    stbtid finbl int ST_CONNECTED_NO_IMPL = 2;

    int donnfdtStbtf = ST_NOT_CONNECTED;

    /*
     * Connfdtfd bddrfss & port
     */
    InftAddrfss donnfdtfdAddrfss = null;
    int donnfdtfdPort = -1;

    /**
     * Connfdts tiis sodkft to b rfmotf sodkft bddrfss (IP bddrfss + port numbfr).
     * Binds sodkft if not blrfbdy bound.
     *
     * @pbrbm   bddrfss Tif rfmotf bddrfss.
     * @pbrbm   port    Tif rfmotf port
     * @tirows  SodkftExdfption if binding tif sodkft fbils.
     */
    privbtf syndironizfd void donnfdtIntfrnbl(InftAddrfss bddrfss, int port) tirows SodkftExdfption {
        if (port < 0 || port > 0xFFFF) {
            tirow nfw IllfgblArgumfntExdfption("donnfdt: " + port);
        }
        if (bddrfss == null) {
            tirow nfw IllfgblArgumfntExdfption("donnfdt: null bddrfss");
        }
        difdkAddrfss (bddrfss, "donnfdt");
        if (isClosfd())
            rfturn;
        SfdurityMbnbgfr sfdurity = Systfm.gftSfdurityMbnbgfr();
        if (sfdurity != null) {
            if (bddrfss.isMultidbstAddrfss()) {
                sfdurity.difdkMultidbst(bddrfss);
            } flsf {
                sfdurity.difdkConnfdt(bddrfss.gftHostAddrfss(), port);
                sfdurity.difdkAddfpt(bddrfss.gftHostAddrfss(), port);
            }
        }

        if (!isBound())
          bind(nfw InftSodkftAddrfss(0));

        // old impls do not support donnfdt/disdonnfdt
        if (oldImpl || (impl instbndfof AbstrbdtPlbinDbtbgrbmSodkftImpl &&
             ((AbstrbdtPlbinDbtbgrbmSodkftImpl)impl).nbtivfConnfdtDisbblfd())) {
            donnfdtStbtf = ST_CONNECTED_NO_IMPL;
        } flsf {
            try {
                gftImpl().donnfdt(bddrfss, port);

                // sodkft is now donnfdtfd by tif impl
                donnfdtStbtf = ST_CONNECTED;
            } dbtdi (SodkftExdfption sf) {

                // donnfdtion will bf fmulbtfd by DbtbgrbmSodkft
                donnfdtStbtf = ST_CONNECTED_NO_IMPL;
            }
        }

        donnfdtfdAddrfss = bddrfss;
        donnfdtfdPort = port;
    }


    /**
     * Construdts b dbtbgrbm sodkft bnd binds it to bny bvbilbblf port
     * on tif lodbl iost mbdiinf.  Tif sodkft will bf bound to tif
     * {@link InftAddrfss#isAnyLodblAddrfss wilddbrd} bddrfss,
     * bn IP bddrfss diosfn by tif kfrnfl.
     *
     * <p>If tifrf is b sfdurity mbnbgfr,
     * its {@dodf difdkListfn} mftiod is first dbllfd
     * witi 0 bs its brgumfnt to fnsurf tif opfrbtion is bllowfd.
     * Tiis dould rfsult in b SfdurityExdfption.
     *
     * @fxdfption  SodkftExdfption  if tif sodkft dould not bf opfnfd,
     *               or tif sodkft dould not bind to tif spfdififd lodbl port.
     * @fxdfption  SfdurityExdfption  if b sfdurity mbnbgfr fxists bnd its
     *             {@dodf difdkListfn} mftiod dofsn't bllow tif opfrbtion.
     *
     * @sff SfdurityMbnbgfr#difdkListfn
     */
    publid DbtbgrbmSodkft() tirows SodkftExdfption {
        tiis(nfw InftSodkftAddrfss(0));
    }

    /**
     * Crfbtfs bn unbound dbtbgrbm sodkft witi tif spfdififd
     * DbtbgrbmSodkftImpl.
     *
     * @pbrbm impl bn instbndf of b <B>DbtbgrbmSodkftImpl</B>
     *        tif subdlbss wisifs to usf on tif DbtbgrbmSodkft.
     * @sindf   1.4
     */
    protfdtfd DbtbgrbmSodkft(DbtbgrbmSodkftImpl impl) {
        if (impl == null)
            tirow nfw NullPointfrExdfption();
        tiis.impl = impl;
        difdkOldImpl();
    }

    /**
     * Crfbtfs b dbtbgrbm sodkft, bound to tif spfdififd lodbl
     * sodkft bddrfss.
     * <p>
     * If, if tif bddrfss is {@dodf null}, drfbtfs bn unbound sodkft.
     *
     * <p>If tifrf is b sfdurity mbnbgfr,
     * its {@dodf difdkListfn} mftiod is first dbllfd
     * witi tif port from tif sodkft bddrfss
     * bs its brgumfnt to fnsurf tif opfrbtion is bllowfd.
     * Tiis dould rfsult in b SfdurityExdfption.
     *
     * @pbrbm bindbddr lodbl sodkft bddrfss to bind, or {@dodf null}
     *                 for bn unbound sodkft.
     *
     * @fxdfption  SodkftExdfption  if tif sodkft dould not bf opfnfd,
     *               or tif sodkft dould not bind to tif spfdififd lodbl port.
     * @fxdfption  SfdurityExdfption  if b sfdurity mbnbgfr fxists bnd its
     *             {@dodf difdkListfn} mftiod dofsn't bllow tif opfrbtion.
     *
     * @sff SfdurityMbnbgfr#difdkListfn
     * @sindf   1.4
     */
    publid DbtbgrbmSodkft(SodkftAddrfss bindbddr) tirows SodkftExdfption {
        // drfbtf b dbtbgrbm sodkft.
        drfbtfImpl();
        if (bindbddr != null) {
            try {
                bind(bindbddr);
            } finblly {
                if (!isBound())
                    dlosf();
            }
        }
    }

    /**
     * Construdts b dbtbgrbm sodkft bnd binds it to tif spfdififd port
     * on tif lodbl iost mbdiinf.  Tif sodkft will bf bound to tif
     * {@link InftAddrfss#isAnyLodblAddrfss wilddbrd} bddrfss,
     * bn IP bddrfss diosfn by tif kfrnfl.
     *
     * <p>If tifrf is b sfdurity mbnbgfr,
     * its {@dodf difdkListfn} mftiod is first dbllfd
     * witi tif {@dodf port} brgumfnt
     * bs its brgumfnt to fnsurf tif opfrbtion is bllowfd.
     * Tiis dould rfsult in b SfdurityExdfption.
     *
     * @pbrbm      port port to usf.
     * @fxdfption  SodkftExdfption  if tif sodkft dould not bf opfnfd,
     *               or tif sodkft dould not bind to tif spfdififd lodbl port.
     * @fxdfption  SfdurityExdfption  if b sfdurity mbnbgfr fxists bnd its
     *             {@dodf difdkListfn} mftiod dofsn't bllow tif opfrbtion.
     *
     * @sff SfdurityMbnbgfr#difdkListfn
     */
    publid DbtbgrbmSodkft(int port) tirows SodkftExdfption {
        tiis(port, null);
    }

    /**
     * Crfbtfs b dbtbgrbm sodkft, bound to tif spfdififd lodbl
     * bddrfss.  Tif lodbl port must bf bftwffn 0 bnd 65535 indlusivf.
     * If tif IP bddrfss is 0.0.0.0, tif sodkft will bf bound to tif
     * {@link InftAddrfss#isAnyLodblAddrfss wilddbrd} bddrfss,
     * bn IP bddrfss diosfn by tif kfrnfl.
     *
     * <p>If tifrf is b sfdurity mbnbgfr,
     * its {@dodf difdkListfn} mftiod is first dbllfd
     * witi tif {@dodf port} brgumfnt
     * bs its brgumfnt to fnsurf tif opfrbtion is bllowfd.
     * Tiis dould rfsult in b SfdurityExdfption.
     *
     * @pbrbm port lodbl port to usf
     * @pbrbm lbddr lodbl bddrfss to bind
     *
     * @fxdfption  SodkftExdfption  if tif sodkft dould not bf opfnfd,
     *               or tif sodkft dould not bind to tif spfdififd lodbl port.
     * @fxdfption  SfdurityExdfption  if b sfdurity mbnbgfr fxists bnd its
     *             {@dodf difdkListfn} mftiod dofsn't bllow tif opfrbtion.
     *
     * @sff SfdurityMbnbgfr#difdkListfn
     * @sindf   1.1
     */
    publid DbtbgrbmSodkft(int port, InftAddrfss lbddr) tirows SodkftExdfption {
        tiis(nfw InftSodkftAddrfss(lbddr, port));
    }

    privbtf void difdkOldImpl() {
        if (impl == null)
            rfturn;
        // DbtbgrbmSodkftImpl.pffkdbtb() is b protfdtfd mftiod, tifrfforf wf nffd to usf
        // gftDfdlbrfdMftiod, tifrfforf wf nffd pfrmission to bddfss tif mfmbfr
        try {
            AddfssControllfr.doPrivilfgfd(
                nfw PrivilfgfdExdfptionAdtion<Void>() {
                    publid Void run() tirows NoSudiMftiodExdfption {
                        Clbss<?>[] dl = nfw Clbss<?>[1];
                        dl[0] = DbtbgrbmPbdkft.dlbss;
                        impl.gftClbss().gftDfdlbrfdMftiod("pffkDbtb", dl);
                        rfturn null;
                    }
                });
        } dbtdi (jbvb.sfdurity.PrivilfgfdAdtionExdfption f) {
            oldImpl = truf;
        }
    }

    stbtid Clbss<?> implClbss = null;

    void drfbtfImpl() tirows SodkftExdfption {
        if (impl == null) {
            if (fbdtory != null) {
                impl = fbdtory.drfbtfDbtbgrbmSodkftImpl();
                difdkOldImpl();
            } flsf {
                boolfbn isMultidbst = (tiis instbndfof MultidbstSodkft) ? truf : fblsf;
                impl = DffbultDbtbgrbmSodkftImplFbdtory.drfbtfDbtbgrbmSodkftImpl(isMultidbst);

                difdkOldImpl();
            }
        }
        // drfbtfs b udp sodkft
        impl.drfbtf();
        impl.sftDbtbgrbmSodkft(tiis);
        drfbtfd = truf;
    }

    /**
     * Gft tif {@dodf DbtbgrbmSodkftImpl} bttbdifd to tiis sodkft,
     * drfbting it if nfdfssbry.
     *
     * @rfturn  tif {@dodf DbtbgrbmSodkftImpl} bttbdifd to tibt
     *          DbtbgrbmSodkft
     * @tirows SodkftExdfption if drfbtion fbils.
     * @sindf 1.4
     */
    DbtbgrbmSodkftImpl gftImpl() tirows SodkftExdfption {
        if (!drfbtfd)
            drfbtfImpl();
        rfturn impl;
    }

    /**
     * Binds tiis DbtbgrbmSodkft to b spfdifid bddrfss bnd port.
     * <p>
     * If tif bddrfss is {@dodf null}, tifn tif systfm will pidk up
     * bn fpifmfrbl port bnd b vblid lodbl bddrfss to bind tif sodkft.
     *
     * @pbrbm   bddr Tif bddrfss bnd port to bind to.
     * @tirows  SodkftExdfption if bny frror ibppfns during tif bind, or if tif
     *          sodkft is blrfbdy bound.
     * @tirows  SfdurityExdfption  if b sfdurity mbnbgfr fxists bnd its
     *             {@dodf difdkListfn} mftiod dofsn't bllow tif opfrbtion.
     * @tirows IllfgblArgumfntExdfption if bddr is b SodkftAddrfss subdlbss
     *         not supportfd by tiis sodkft.
     * @sindf 1.4
     */
    publid syndironizfd void bind(SodkftAddrfss bddr) tirows SodkftExdfption {
        if (isClosfd())
            tirow nfw SodkftExdfption("Sodkft is dlosfd");
        if (isBound())
            tirow nfw SodkftExdfption("blrfbdy bound");
        if (bddr == null)
            bddr = nfw InftSodkftAddrfss(0);
        if (!(bddr instbndfof InftSodkftAddrfss))
            tirow nfw IllfgblArgumfntExdfption("Unsupportfd bddrfss typf!");
        InftSodkftAddrfss fpoint = (InftSodkftAddrfss) bddr;
        if (fpoint.isUnrfsolvfd())
            tirow nfw SodkftExdfption("Unrfsolvfd bddrfss");
        InftAddrfss ibddr = fpoint.gftAddrfss();
        int port = fpoint.gftPort();
        difdkAddrfss(ibddr, "bind");
        SfdurityMbnbgfr sfd = Systfm.gftSfdurityMbnbgfr();
        if (sfd != null) {
            sfd.difdkListfn(port);
        }
        try {
            gftImpl().bind(port, ibddr);
        } dbtdi (SodkftExdfption f) {
            gftImpl().dlosf();
            tirow f;
        }
        bound = truf;
    }

    void difdkAddrfss (InftAddrfss bddr, String op) {
        if (bddr == null) {
            rfturn;
        }
        if (!(bddr instbndfof Inft4Addrfss || bddr instbndfof Inft6Addrfss)) {
            tirow nfw IllfgblArgumfntExdfption(op + ": invblid bddrfss typf");
        }
    }

    /**
     * Connfdts tif sodkft to b rfmotf bddrfss for tiis sodkft. Wifn b
     * sodkft is donnfdtfd to b rfmotf bddrfss, pbdkfts mby only bf
     * sfnt to or rfdfivfd from tibt bddrfss. By dffbult b dbtbgrbm
     * sodkft is not donnfdtfd.
     *
     * <p>If tif rfmotf dfstinbtion to wiidi tif sodkft is donnfdtfd dofs not
     * fxist, or is otifrwisf unrfbdibblf, bnd if bn ICMP dfstinbtion unrfbdibblf
     * pbdkft ibs bffn rfdfivfd for tibt bddrfss, tifn b subsfqufnt dbll to
     * sfnd or rfdfivf mby tirow b PortUnrfbdibblfExdfption. Notf, tifrf is no
     * gubrbntff tibt tif fxdfption will bf tirown.
     *
     * <p> If b sfdurity mbnbgfr ibs bffn instbllfd tifn it is invokfd to difdk
     * bddfss to tif rfmotf bddrfss. Spfdifidblly, if tif givfn {@dodf bddrfss}
     * is b {@link InftAddrfss#isMultidbstAddrfss multidbst bddrfss},
     * tif sfdurity mbnbgfr's {@link
     * jbvb.lbng.SfdurityMbnbgfr#difdkMultidbst(InftAddrfss)
     * difdkMultidbst} mftiod is invokfd witi tif givfn {@dodf bddrfss}.
     * Otifrwisf, tif sfdurity mbnbgfr's {@link
     * jbvb.lbng.SfdurityMbnbgfr#difdkConnfdt(String,int) difdkConnfdt}
     * bnd {@link jbvb.lbng.SfdurityMbnbgfr#difdkAddfpt difdkAddfpt} mftiods
     * brf invokfd, witi tif givfn {@dodf bddrfss} bnd {@dodf port}, to
     * vfrify tibt dbtbgrbms brf pfrmittfd to bf sfnt bnd rfdfivfd
     * rfspfdtivfly.
     *
     * <p> Wifn b sodkft is donnfdtfd, {@link #rfdfivf rfdfivf} bnd
     * {@link #sfnd sfnd} <b>will not pfrform bny sfdurity difdks</b>
     * on indoming bnd outgoing pbdkfts, otifr tibn mbtdiing tif pbdkft's
     * bnd tif sodkft's bddrfss bnd port. On b sfnd opfrbtion, if tif
     * pbdkft's bddrfss is sft bnd tif pbdkft's bddrfss bnd tif sodkft's
     * bddrfss do not mbtdi, bn {@dodf IllfgblArgumfntExdfption} will bf
     * tirown. A sodkft donnfdtfd to b multidbst bddrfss mby only bf usfd
     * to sfnd pbdkfts.
     *
     * @pbrbm bddrfss tif rfmotf bddrfss for tif sodkft
     *
     * @pbrbm port tif rfmotf port for tif sodkft.
     *
     * @tirows IllfgblArgumfntExdfption
     *         if tif bddrfss is null, or tif port is out of rbngf.
     *
     * @tirows SfdurityExdfption
     *         if b sfdurity mbnbgfr ibs bffn instbllfd bnd it dofs
     *         not pfrmit bddfss to tif givfn rfmotf bddrfss
     *
     * @sff #disdonnfdt
     */
    publid void donnfdt(InftAddrfss bddrfss, int port) {
        try {
            donnfdtIntfrnbl(bddrfss, port);
        } dbtdi (SodkftExdfption sf) {
            tirow nfw Error("donnfdt fbilfd", sf);
        }
    }

    /**
     * Connfdts tiis sodkft to b rfmotf sodkft bddrfss (IP bddrfss + port numbfr).
     *
     * <p> If givfn bn {@link InftSodkftAddrfss InftSodkftAddrfss}, tiis mftiod
     * bfibvfs bs if invoking {@link #donnfdt(InftAddrfss,int) donnfdt(InftAddrfss,int)}
     * witi tif givfn sodkft bddrfssfs IP bddrfss bnd port numbfr.
     *
     * @pbrbm   bddr    Tif rfmotf bddrfss.
     *
     * @tirows  SodkftExdfption
     *          if tif donnfdt fbils
     *
     * @tirows IllfgblArgumfntExdfption
     *         if {@dodf bddr} is {@dodf null}, or {@dodf bddr} is b SodkftAddrfss
     *         subdlbss not supportfd by tiis sodkft
     *
     * @tirows SfdurityExdfption
     *         if b sfdurity mbnbgfr ibs bffn instbllfd bnd it dofs
     *         not pfrmit bddfss to tif givfn rfmotf bddrfss
     *
     * @sindf 1.4
     */
    publid void donnfdt(SodkftAddrfss bddr) tirows SodkftExdfption {
        if (bddr == null)
            tirow nfw IllfgblArgumfntExdfption("Addrfss dbn't bf null");
        if (!(bddr instbndfof InftSodkftAddrfss))
            tirow nfw IllfgblArgumfntExdfption("Unsupportfd bddrfss typf");
        InftSodkftAddrfss fpoint = (InftSodkftAddrfss) bddr;
        if (fpoint.isUnrfsolvfd())
            tirow nfw SodkftExdfption("Unrfsolvfd bddrfss");
        donnfdtIntfrnbl(fpoint.gftAddrfss(), fpoint.gftPort());
    }

    /**
     * Disdonnfdts tif sodkft. If tif sodkft is dlosfd or not donnfdtfd,
     * tifn tiis mftiod ibs no ffffdt.
     *
     * @sff #donnfdt
     */
    publid void disdonnfdt() {
        syndironizfd (tiis) {
            if (isClosfd())
                rfturn;
            if (donnfdtStbtf == ST_CONNECTED) {
                impl.disdonnfdt ();
            }
            donnfdtfdAddrfss = null;
            donnfdtfdPort = -1;
            donnfdtStbtf = ST_NOT_CONNECTED;
        }
    }

    /**
     * Rfturns tif binding stbtf of tif sodkft.
     * <p>
     * If tif sodkft wbs bound prior to bfing {@link #dlosf dlosfd},
     * tifn tiis mftiod will dontinuf to rfturn {@dodf truf}
     * bftfr tif sodkft is dlosfd.
     *
     * @rfturn truf if tif sodkft suddfssfully bound to bn bddrfss
     * @sindf 1.4
     */
    publid boolfbn isBound() {
        rfturn bound;
    }

    /**
     * Rfturns tif donnfdtion stbtf of tif sodkft.
     * <p>
     * If tif sodkft wbs donnfdtfd prior to bfing {@link #dlosf dlosfd},
     * tifn tiis mftiod will dontinuf to rfturn {@dodf truf}
     * bftfr tif sodkft is dlosfd.
     *
     * @rfturn truf if tif sodkft suddfssfully donnfdtfd to b sfrvfr
     * @sindf 1.4
     */
    publid boolfbn isConnfdtfd() {
        rfturn donnfdtStbtf != ST_NOT_CONNECTED;
    }

    /**
     * Rfturns tif bddrfss to wiidi tiis sodkft is donnfdtfd. Rfturns
     * {@dodf null} if tif sodkft is not donnfdtfd.
     * <p>
     * If tif sodkft wbs donnfdtfd prior to bfing {@link #dlosf dlosfd},
     * tifn tiis mftiod will dontinuf to rfturn tif donnfdtfd bddrfss
     * bftfr tif sodkft is dlosfd.
     *
     * @rfturn tif bddrfss to wiidi tiis sodkft is donnfdtfd.
     */
    publid InftAddrfss gftInftAddrfss() {
        rfturn donnfdtfdAddrfss;
    }

    /**
     * Rfturns tif port numbfr to wiidi tiis sodkft is donnfdtfd.
     * Rfturns {@dodf -1} if tif sodkft is not donnfdtfd.
     * <p>
     * If tif sodkft wbs donnfdtfd prior to bfing {@link #dlosf dlosfd},
     * tifn tiis mftiod will dontinuf to rfturn tif donnfdtfd port numbfr
     * bftfr tif sodkft is dlosfd.
     *
     * @rfturn tif port numbfr to wiidi tiis sodkft is donnfdtfd.
     */
    publid int gftPort() {
        rfturn donnfdtfdPort;
    }

    /**
     * Rfturns tif bddrfss of tif fndpoint tiis sodkft is donnfdtfd to, or
     * {@dodf null} if it is undonnfdtfd.
     * <p>
     * If tif sodkft wbs donnfdtfd prior to bfing {@link #dlosf dlosfd},
     * tifn tiis mftiod will dontinuf to rfturn tif donnfdtfd bddrfss
     * bftfr tif sodkft is dlosfd.
     *
     * @rfturn b {@dodf SodkftAddrfss} rfprfsfnting tif rfmotf
     *         fndpoint of tiis sodkft, or {@dodf null} if it is
     *         not donnfdtfd yft.
     * @sff #gftInftAddrfss()
     * @sff #gftPort()
     * @sff #donnfdt(SodkftAddrfss)
     * @sindf 1.4
     */
    publid SodkftAddrfss gftRfmotfSodkftAddrfss() {
        if (!isConnfdtfd())
            rfturn null;
        rfturn nfw InftSodkftAddrfss(gftInftAddrfss(), gftPort());
    }

    /**
     * Rfturns tif bddrfss of tif fndpoint tiis sodkft is bound to.
     *
     * @rfturn b {@dodf SodkftAddrfss} rfprfsfnting tif lodbl fndpoint of tiis
     *         sodkft, or {@dodf null} if it is dlosfd or not bound yft.
     * @sff #gftLodblAddrfss()
     * @sff #gftLodblPort()
     * @sff #bind(SodkftAddrfss)
     * @sindf 1.4
     */

    publid SodkftAddrfss gftLodblSodkftAddrfss() {
        if (isClosfd())
            rfturn null;
        if (!isBound())
            rfturn null;
        rfturn nfw InftSodkftAddrfss(gftLodblAddrfss(), gftLodblPort());
    }

    /**
     * Sfnds b dbtbgrbm pbdkft from tiis sodkft. Tif
     * {@dodf DbtbgrbmPbdkft} indludfs informbtion indidbting tif
     * dbtb to bf sfnt, its lfngti, tif IP bddrfss of tif rfmotf iost,
     * bnd tif port numbfr on tif rfmotf iost.
     *
     * <p>If tifrf is b sfdurity mbnbgfr, bnd tif sodkft is not durrfntly
     * donnfdtfd to b rfmotf bddrfss, tiis mftiod first pfrforms somf
     * sfdurity difdks. First, if {@dodf p.gftAddrfss().isMultidbstAddrfss()}
     * is truf, tiis mftiod dblls tif
     * sfdurity mbnbgfr's {@dodf difdkMultidbst} mftiod
     * witi {@dodf p.gftAddrfss()} bs its brgumfnt.
     * If tif fvblubtion of tibt fxprfssion is fblsf,
     * tiis mftiod instfbd dblls tif sfdurity mbnbgfr's
     * {@dodf difdkConnfdt} mftiod witi brgumfnts
     * {@dodf p.gftAddrfss().gftHostAddrfss()} bnd
     * {@dodf p.gftPort()}. Ebdi dbll to b sfdurity mbnbgfr mftiod
     * dould rfsult in b SfdurityExdfption if tif opfrbtion is not bllowfd.
     *
     * @pbrbm      p   tif {@dodf DbtbgrbmPbdkft} to bf sfnt.
     *
     * @fxdfption  IOExdfption  if bn I/O frror oddurs.
     * @fxdfption  SfdurityExdfption  if b sfdurity mbnbgfr fxists bnd its
     *             {@dodf difdkMultidbst} or {@dodf difdkConnfdt}
     *             mftiod dofsn't bllow tif sfnd.
     * @fxdfption  PortUnrfbdibblfExdfption mby bf tirown if tif sodkft is donnfdtfd
     *             to b durrfntly unrfbdibblf dfstinbtion. Notf, tifrf is no
     *             gubrbntff tibt tif fxdfption will bf tirown.
     * @fxdfption  jbvb.nio.dibnnfls.IllfgblBlodkingModfExdfption
     *             if tiis sodkft ibs bn bssodibtfd dibnnfl,
     *             bnd tif dibnnfl is in non-blodking modf.
     * @fxdfption  IllfgblArgumfntExdfption if tif sodkft is donnfdtfd,
     *             bnd donnfdtfd bddrfss bnd pbdkft bddrfss difffr.
     *
     * @sff        jbvb.nft.DbtbgrbmPbdkft
     * @sff        SfdurityMbnbgfr#difdkMultidbst(InftAddrfss)
     * @sff        SfdurityMbnbgfr#difdkConnfdt
     * @rfvisfd 1.4
     * @spfd JSR-51
     */
    publid void sfnd(DbtbgrbmPbdkft p) tirows IOExdfption  {
        InftAddrfss pbdkftAddrfss = null;
        syndironizfd (p) {
            if (isClosfd())
                tirow nfw SodkftExdfption("Sodkft is dlosfd");
            difdkAddrfss (p.gftAddrfss(), "sfnd");
            if (donnfdtStbtf == ST_NOT_CONNECTED) {
                // difdk tif bddrfss is ok wiit tif sfdurity mbnbgfr on fvfry sfnd.
                SfdurityMbnbgfr sfdurity = Systfm.gftSfdurityMbnbgfr();

                // Tif rfbson you wbnt to syndironizf on dbtbgrbm pbdkft
                // is bfdbusf you don't wbnt bn bpplft to dibngf tif bddrfss
                // wiilf you brf trying to sfnd tif pbdkft for fxbmplf
                // bftfr tif sfdurity difdk but bfforf tif sfnd.
                if (sfdurity != null) {
                    if (p.gftAddrfss().isMultidbstAddrfss()) {
                        sfdurity.difdkMultidbst(p.gftAddrfss());
                    } flsf {
                        sfdurity.difdkConnfdt(p.gftAddrfss().gftHostAddrfss(),
                                              p.gftPort());
                    }
                }
            } flsf {
                // wf'rf donnfdtfd
                pbdkftAddrfss = p.gftAddrfss();
                if (pbdkftAddrfss == null) {
                    p.sftAddrfss(donnfdtfdAddrfss);
                    p.sftPort(donnfdtfdPort);
                } flsf if ((!pbdkftAddrfss.fqubls(donnfdtfdAddrfss)) ||
                           p.gftPort() != donnfdtfdPort) {
                    tirow nfw IllfgblArgumfntExdfption("donnfdtfd bddrfss " +
                                                       "bnd pbdkft bddrfss" +
                                                       " difffr");
                }
            }
            // Cifdk wiftifr tif sodkft is bound
            if (!isBound())
                bind(nfw InftSodkftAddrfss(0));
            // dbll tif  mftiod to sfnd
            gftImpl().sfnd(p);
        }
    }

    /**
     * Rfdfivfs b dbtbgrbm pbdkft from tiis sodkft. Wifn tiis mftiod
     * rfturns, tif {@dodf DbtbgrbmPbdkft}'s bufffr is fillfd witi
     * tif dbtb rfdfivfd. Tif dbtbgrbm pbdkft blso dontbins tif sfndfr's
     * IP bddrfss, bnd tif port numbfr on tif sfndfr's mbdiinf.
     * <p>
     * Tiis mftiod blodks until b dbtbgrbm is rfdfivfd. Tif
     * {@dodf lfngti} fifld of tif dbtbgrbm pbdkft objfdt dontbins
     * tif lfngti of tif rfdfivfd mfssbgf. If tif mfssbgf is longfr tibn
     * tif pbdkft's lfngti, tif mfssbgf is trundbtfd.
     * <p>
     * If tifrf is b sfdurity mbnbgfr, b pbdkft dbnnot bf rfdfivfd if tif
     * sfdurity mbnbgfr's {@dodf difdkAddfpt} mftiod
     * dofs not bllow it.
     *
     * @pbrbm      p   tif {@dodf DbtbgrbmPbdkft} into wiidi to plbdf
     *                 tif indoming dbtb.
     * @fxdfption  IOExdfption  if bn I/O frror oddurs.
     * @fxdfption  SodkftTimfoutExdfption  if sftSoTimfout wbs prfviously dbllfd
     *                 bnd tif timfout ibs fxpirfd.
     * @fxdfption  PortUnrfbdibblfExdfption mby bf tirown if tif sodkft is donnfdtfd
     *             to b durrfntly unrfbdibblf dfstinbtion. Notf, tifrf is no gubrbntff tibt tif
     *             fxdfption will bf tirown.
     * @fxdfption  jbvb.nio.dibnnfls.IllfgblBlodkingModfExdfption
     *             if tiis sodkft ibs bn bssodibtfd dibnnfl,
     *             bnd tif dibnnfl is in non-blodking modf.
     * @sff        jbvb.nft.DbtbgrbmPbdkft
     * @sff        jbvb.nft.DbtbgrbmSodkft
     * @rfvisfd 1.4
     * @spfd JSR-51
     */
    publid syndironizfd void rfdfivf(DbtbgrbmPbdkft p) tirows IOExdfption {
        syndironizfd (p) {
            if (!isBound())
                bind(nfw InftSodkftAddrfss(0));
            if (donnfdtStbtf == ST_NOT_CONNECTED) {
                // difdk tif bddrfss is ok witi tif sfdurity mbnbgfr bfforf fvfry rfdv.
                SfdurityMbnbgfr sfdurity = Systfm.gftSfdurityMbnbgfr();
                if (sfdurity != null) {
                    wiilf(truf) {
                        String pffkAd = null;
                        int pffkPort = 0;
                        // pffk bt tif pbdkft to sff wio it is from.
                        if (!oldImpl) {
                            // Wf dbn usf tif nfw pffkDbtb() API
                            DbtbgrbmPbdkft pffkPbdkft = nfw DbtbgrbmPbdkft(nfw bytf[1], 1);
                            pffkPort = gftImpl().pffkDbtb(pffkPbdkft);
                            pffkAd = pffkPbdkft.gftAddrfss().gftHostAddrfss();
                        } flsf {
                            InftAddrfss bdr = nfw InftAddrfss();
                            pffkPort = gftImpl().pffk(bdr);
                            pffkAd = bdr.gftHostAddrfss();
                        }
                        try {
                            sfdurity.difdkAddfpt(pffkAd, pffkPort);
                            // sfdurity difdk suddffdfd - so now brfbk
                            // bnd rfdv tif pbdkft.
                            brfbk;
                        } dbtdi (SfdurityExdfption sf) {
                            // Tirow bwby tif offfnding pbdkft by donsuming
                            // it in b tmp bufffr.
                            DbtbgrbmPbdkft tmp = nfw DbtbgrbmPbdkft(nfw bytf[1], 1);
                            gftImpl().rfdfivf(tmp);

                            // silfntly disdbrd tif offfnding pbdkft
                            // bnd dontinuf: unknown/mblidious
                            // fntitifs on nfts siould not mbkf
                            // runtimf tirow sfdurity fxdfption bnd
                            // disrupt tif bpplft by sfnding rbndom
                            // dbtbgrbm pbdkfts.
                            dontinuf;
                        }
                    } // fnd of wiilf
                }
            }
            if (donnfdtStbtf == ST_CONNECTED_NO_IMPL) {
                // Wf ibvf to do tif filtfring tif old fbsiionfd wby sindf
                // tif nbtivf impl dofsn't support donnfdt or tif donnfdt
                // vib tif impl fbilfd.
                boolfbn stop = fblsf;
                wiilf (!stop) {
                    InftAddrfss pffkAddrfss = null;
                    int pffkPort = -1;
                    // pffk bt tif pbdkft to sff wio it is from.
                    if (!oldImpl) {
                        // Wf dbn usf tif nfw pffkDbtb() API
                        DbtbgrbmPbdkft pffkPbdkft = nfw DbtbgrbmPbdkft(nfw bytf[1], 1);
                        pffkPort = gftImpl().pffkDbtb(pffkPbdkft);
                        pffkAddrfss = pffkPbdkft.gftAddrfss();
                    } flsf {
                        // tiis bpi only works for IPv4
                        pffkAddrfss = nfw InftAddrfss();
                        pffkPort = gftImpl().pffk(pffkAddrfss);
                    }
                    if ((!donnfdtfdAddrfss.fqubls(pffkAddrfss)) ||
                        (donnfdtfdPort != pffkPort)) {
                        // tirow tif pbdkft bwby bnd silfntly dontinuf
                        DbtbgrbmPbdkft tmp = nfw DbtbgrbmPbdkft(nfw bytf[1], 1);
                        gftImpl().rfdfivf(tmp);
                    } flsf {
                        stop = truf;
                    }
                }
            }
            // If tif sfdurity difdk suddffds, or tif dbtbgrbm is
            // donnfdtfd tifn rfdfivf tif pbdkft
            gftImpl().rfdfivf(p);
        }
    }

    /**
     * Gfts tif lodbl bddrfss to wiidi tif sodkft is bound.
     *
     * <p>If tifrf is b sfdurity mbnbgfr, its
     * {@dodf difdkConnfdt} mftiod is first dbllfd
     * witi tif iost bddrfss bnd {@dodf -1}
     * bs its brgumfnts to sff if tif opfrbtion is bllowfd.
     *
     * @sff SfdurityMbnbgfr#difdkConnfdt
     * @rfturn  tif lodbl bddrfss to wiidi tif sodkft is bound,
     *          {@dodf null} if tif sodkft is dlosfd, or
     *          bn {@dodf InftAddrfss} rfprfsfnting
     *          {@link InftAddrfss#isAnyLodblAddrfss wilddbrd}
     *          bddrfss if fitifr tif sodkft is not bound, or
     *          tif sfdurity mbnbgfr {@dodf difdkConnfdt}
     *          mftiod dofs not bllow tif opfrbtion
     * @sindf   1.1
     */
    publid InftAddrfss gftLodblAddrfss() {
        if (isClosfd())
            rfturn null;
        InftAddrfss in = null;
        try {
            in = (InftAddrfss) gftImpl().gftOption(SodkftOptions.SO_BINDADDR);
            if (in.isAnyLodblAddrfss()) {
                in = InftAddrfss.bnyLodblAddrfss();
            }
            SfdurityMbnbgfr s = Systfm.gftSfdurityMbnbgfr();
            if (s != null) {
                s.difdkConnfdt(in.gftHostAddrfss(), -1);
            }
        } dbtdi (Exdfption f) {
            in = InftAddrfss.bnyLodblAddrfss(); // "0.0.0.0"
        }
        rfturn in;
    }

    /**
     * Rfturns tif port numbfr on tif lodbl iost to wiidi tiis sodkft
     * is bound.
     *
     * @rfturn  tif port numbfr on tif lodbl iost to wiidi tiis sodkft is bound,
                {@dodf -1} if tif sodkft is dlosfd, or
                {@dodf 0} if it is not bound yft.
     */
    publid int gftLodblPort() {
        if (isClosfd())
            rfturn -1;
        try {
            rfturn gftImpl().gftLodblPort();
        } dbtdi (Exdfption f) {
            rfturn 0;
        }
    }

    /** Enbblf/disbblf SO_TIMEOUT witi tif spfdififd timfout, in
     *  millisfdonds. Witi tiis option sft to b non-zfro timfout,
     *  b dbll to rfdfivf() for tiis DbtbgrbmSodkft
     *  will blodk for only tiis bmount of timf.  If tif timfout fxpirfs,
     *  b <B>jbvb.nft.SodkftTimfoutExdfption</B> is rbisfd, tiougi tif
     *  DbtbgrbmSodkft is still vblid.  Tif option <B>must</B> bf fnbblfd
     *  prior to fntfring tif blodking opfrbtion to ibvf ffffdt.  Tif
     *  timfout must bf {@dodf > 0}.
     *  A timfout of zfro is intfrprftfd bs bn infinitf timfout.
     *
     * @pbrbm timfout tif spfdififd timfout in millisfdonds.
     * @tirows SodkftExdfption if tifrf is bn frror in tif undfrlying protodol, sudi bs bn UDP frror.
     * @sindf   1.1
     * @sff #gftSoTimfout()
     */
    publid syndironizfd void sftSoTimfout(int timfout) tirows SodkftExdfption {
        if (isClosfd())
            tirow nfw SodkftExdfption("Sodkft is dlosfd");
        gftImpl().sftOption(SodkftOptions.SO_TIMEOUT, timfout);
    }

    /**
     * Rftrifvf sftting for SO_TIMEOUT.  0 rfturns implifs tibt tif
     * option is disbblfd (i.f., timfout of infinity).
     *
     * @rfturn tif sftting for SO_TIMEOUT
     * @tirows SodkftExdfption if tifrf is bn frror in tif undfrlying protodol, sudi bs bn UDP frror.
     * @sindf   1.1
     * @sff #sftSoTimfout(int)
     */
    publid syndironizfd int gftSoTimfout() tirows SodkftExdfption {
        if (isClosfd())
            tirow nfw SodkftExdfption("Sodkft is dlosfd");
        if (gftImpl() == null)
            rfturn 0;
        Objfdt o = gftImpl().gftOption(SodkftOptions.SO_TIMEOUT);
        /* fxtrb typf sbffty */
        if (o instbndfof Intfgfr) {
            rfturn ((Intfgfr) o).intVbluf();
        } flsf {
            rfturn 0;
        }
    }

    /**
     * Sfts tif SO_SNDBUF option to tif spfdififd vbluf for tiis
     * {@dodf DbtbgrbmSodkft}. Tif SO_SNDBUF option is usfd by tif
     * nftwork implfmfntbtion bs b iint to sizf tif undfrlying
     * nftwork I/O bufffrs. Tif SO_SNDBUF sftting mby blso bf usfd
     * by tif nftwork implfmfntbtion to dftfrminf tif mbximum sizf
     * of tif pbdkft tibt dbn bf sfnt on tiis sodkft.
     * <p>
     * As SO_SNDBUF is b iint, bpplidbtions tibt wbnt to vfrify
     * wibt sizf tif bufffr is siould dbll {@link #gftSfndBufffrSizf()}.
     * <p>
     * Indrfbsing tif bufffr sizf mby bllow multiplf outgoing pbdkfts
     * to bf qufufd by tif nftwork implfmfntbtion wifn tif sfnd rbtf
     * is iigi.
     * <p>
     * Notf: If {@link #sfnd(DbtbgrbmPbdkft)} is usfd to sfnd b
     * {@dodf DbtbgrbmPbdkft} tibt is lbrgfr tibn tif sftting
     * of SO_SNDBUF tifn it is implfmfntbtion spfdifid if tif
     * pbdkft is sfnt or disdbrdfd.
     *
     * @pbrbm sizf tif sizf to wiidi to sft tif sfnd bufffr
     * sizf. Tiis vbluf must bf grfbtfr tibn 0.
     *
     * @fxdfption SodkftExdfption if tifrf is bn frror
     * in tif undfrlying protodol, sudi bs bn UDP frror.
     * @fxdfption IllfgblArgumfntExdfption if tif vbluf is 0 or is
     * nfgbtivf.
     * @sff #gftSfndBufffrSizf()
     */
    publid syndironizfd void sftSfndBufffrSizf(int sizf)
    tirows SodkftExdfption{
        if (!(sizf > 0)) {
            tirow nfw IllfgblArgumfntExdfption("nfgbtivf sfnd sizf");
        }
        if (isClosfd())
            tirow nfw SodkftExdfption("Sodkft is dlosfd");
        gftImpl().sftOption(SodkftOptions.SO_SNDBUF, sizf);
    }

    /**
     * Gft vbluf of tif SO_SNDBUF option for tiis {@dodf DbtbgrbmSodkft}, tibt is tif
     * bufffr sizf usfd by tif plbtform for output on tiis {@dodf DbtbgrbmSodkft}.
     *
     * @rfturn tif vbluf of tif SO_SNDBUF option for tiis {@dodf DbtbgrbmSodkft}
     * @fxdfption SodkftExdfption if tifrf is bn frror in
     * tif undfrlying protodol, sudi bs bn UDP frror.
     * @sff #sftSfndBufffrSizf
     */
    publid syndironizfd int gftSfndBufffrSizf() tirows SodkftExdfption {
        if (isClosfd())
            tirow nfw SodkftExdfption("Sodkft is dlosfd");
        int rfsult = 0;
        Objfdt o = gftImpl().gftOption(SodkftOptions.SO_SNDBUF);
        if (o instbndfof Intfgfr) {
            rfsult = ((Intfgfr)o).intVbluf();
        }
        rfturn rfsult;
    }

    /**
     * Sfts tif SO_RCVBUF option to tif spfdififd vbluf for tiis
     * {@dodf DbtbgrbmSodkft}. Tif SO_RCVBUF option is usfd by tif
     * tif nftwork implfmfntbtion bs b iint to sizf tif undfrlying
     * nftwork I/O bufffrs. Tif SO_RCVBUF sftting mby blso bf usfd
     * by tif nftwork implfmfntbtion to dftfrminf tif mbximum sizf
     * of tif pbdkft tibt dbn bf rfdfivfd on tiis sodkft.
     * <p>
     * Bfdbusf SO_RCVBUF is b iint, bpplidbtions tibt wbnt to
     * vfrify wibt sizf tif bufffrs wfrf sft to siould dbll
     * {@link #gftRfdfivfBufffrSizf()}.
     * <p>
     * Indrfbsing SO_RCVBUF mby bllow tif nftwork implfmfntbtion
     * to bufffr multiplf pbdkfts wifn pbdkfts brrivf fbstfr tibn
     * brf bfing rfdfivfd using {@link #rfdfivf(DbtbgrbmPbdkft)}.
     * <p>
     * Notf: It is implfmfntbtion spfdifid if b pbdkft lbrgfr
     * tibn SO_RCVBUF dbn bf rfdfivfd.
     *
     * @pbrbm sizf tif sizf to wiidi to sft tif rfdfivf bufffr
     * sizf. Tiis vbluf must bf grfbtfr tibn 0.
     *
     * @fxdfption SodkftExdfption if tifrf is bn frror in
     * tif undfrlying protodol, sudi bs bn UDP frror.
     * @fxdfption IllfgblArgumfntExdfption if tif vbluf is 0 or is
     * nfgbtivf.
     * @sff #gftRfdfivfBufffrSizf()
     */
    publid syndironizfd void sftRfdfivfBufffrSizf(int sizf)
    tirows SodkftExdfption{
        if (sizf <= 0) {
            tirow nfw IllfgblArgumfntExdfption("invblid rfdfivf sizf");
        }
        if (isClosfd())
            tirow nfw SodkftExdfption("Sodkft is dlosfd");
        gftImpl().sftOption(SodkftOptions.SO_RCVBUF, sizf);
    }

    /**
     * Gft vbluf of tif SO_RCVBUF option for tiis {@dodf DbtbgrbmSodkft}, tibt is tif
     * bufffr sizf usfd by tif plbtform for input on tiis {@dodf DbtbgrbmSodkft}.
     *
     * @rfturn tif vbluf of tif SO_RCVBUF option for tiis {@dodf DbtbgrbmSodkft}
     * @fxdfption SodkftExdfption if tifrf is bn frror in tif undfrlying protodol, sudi bs bn UDP frror.
     * @sff #sftRfdfivfBufffrSizf(int)
     */
    publid syndironizfd int gftRfdfivfBufffrSizf()
    tirows SodkftExdfption{
        if (isClosfd())
            tirow nfw SodkftExdfption("Sodkft is dlosfd");
        int rfsult = 0;
        Objfdt o = gftImpl().gftOption(SodkftOptions.SO_RCVBUF);
        if (o instbndfof Intfgfr) {
            rfsult = ((Intfgfr)o).intVbluf();
        }
        rfturn rfsult;
    }

    /**
     * Enbblf/disbblf tif SO_REUSEADDR sodkft option.
     * <p>
     * For UDP sodkfts it mby bf nfdfssbry to bind morf tibn onf
     * sodkft to tif sbmf sodkft bddrfss. Tiis is typidblly for tif
     * purposf of rfdfiving multidbst pbdkfts
     * (Sff {@link jbvb.nft.MultidbstSodkft}). Tif
     * {@dodf SO_REUSEADDR} sodkft option bllows multiplf
     * sodkfts to bf bound to tif sbmf sodkft bddrfss if tif
     * {@dodf SO_REUSEADDR} sodkft option is fnbblfd prior
     * to binding tif sodkft using {@link #bind(SodkftAddrfss)}.
     * <p>
     * Notf: Tiis fundtionblity is not supportfd by bll fxisting plbtforms,
     * so it is implfmfntbtion spfdifid wiftifr tiis option will bf ignorfd
     * or not. Howfvfr, if it is not supportfd tifn
     * {@link #gftRfusfAddrfss()} will blwbys rfturn {@dodf fblsf}.
     * <p>
     * Wifn b {@dodf DbtbgrbmSodkft} is drfbtfd tif initibl sftting
     * of {@dodf SO_REUSEADDR} is disbblfd.
     * <p>
     * Tif bfibviour wifn {@dodf SO_REUSEADDR} is fnbblfd or
     * disbblfd bftfr b sodkft is bound (Sff {@link #isBound()})
     * is not dffinfd.
     *
     * @pbrbm on  wiftifr to fnbblf or disbblf tif
     * @fxdfption SodkftExdfption if bn frror oddurs fnbbling or
     *            disbbling tif {@dodf SO_RESUEADDR} sodkft option,
     *            or tif sodkft is dlosfd.
     * @sindf 1.4
     * @sff #gftRfusfAddrfss()
     * @sff #bind(SodkftAddrfss)
     * @sff #isBound()
     * @sff #isClosfd()
     */
    publid syndironizfd void sftRfusfAddrfss(boolfbn on) tirows SodkftExdfption {
        if (isClosfd())
            tirow nfw SodkftExdfption("Sodkft is dlosfd");
        // Intfgfr instfbd of Boolfbn for dompbtibility witi oldfr DbtbgrbmSodkftImpl
        if (oldImpl)
            gftImpl().sftOption(SodkftOptions.SO_REUSEADDR, on?-1:0);
        flsf
            gftImpl().sftOption(SodkftOptions.SO_REUSEADDR, Boolfbn.vblufOf(on));
    }

    /**
     * Tfsts if SO_REUSEADDR is fnbblfd.
     *
     * @rfturn b {@dodf boolfbn} indidbting wiftifr or not SO_REUSEADDR is fnbblfd.
     * @fxdfption SodkftExdfption if tifrf is bn frror
     * in tif undfrlying protodol, sudi bs bn UDP frror.
     * @sindf   1.4
     * @sff #sftRfusfAddrfss(boolfbn)
     */
    publid syndironizfd boolfbn gftRfusfAddrfss() tirows SodkftExdfption {
        if (isClosfd())
            tirow nfw SodkftExdfption("Sodkft is dlosfd");
        Objfdt o = gftImpl().gftOption(SodkftOptions.SO_REUSEADDR);
        rfturn ((Boolfbn)o).boolfbnVbluf();
    }

    /**
     * Enbblf/disbblf SO_BROADCAST.
     *
     * <p> Somf opfrbting systfms mby rfquirf tibt tif Jbvb virtubl mbdiinf bf
     * stbrtfd witi implfmfntbtion spfdifid privilfgfs to fnbblf tiis option or
     * sfnd brobddbst dbtbgrbms.
     *
     * @pbrbm  on
     *         wiftifr or not to ibvf brobddbst turnfd on.
     *
     * @tirows  SodkftExdfption
     *          if tifrf is bn frror in tif undfrlying protodol, sudi bs bn UDP
     *          frror.
     *
     * @sindf 1.4
     * @sff #gftBrobddbst()
     */
    publid syndironizfd void sftBrobddbst(boolfbn on) tirows SodkftExdfption {
        if (isClosfd())
            tirow nfw SodkftExdfption("Sodkft is dlosfd");
        gftImpl().sftOption(SodkftOptions.SO_BROADCAST, Boolfbn.vblufOf(on));
    }

    /**
     * Tfsts if SO_BROADCAST is fnbblfd.
     * @rfturn b {@dodf boolfbn} indidbting wiftifr or not SO_BROADCAST is fnbblfd.
     * @fxdfption SodkftExdfption if tifrf is bn frror
     * in tif undfrlying protodol, sudi bs bn UDP frror.
     * @sindf 1.4
     * @sff #sftBrobddbst(boolfbn)
     */
    publid syndironizfd boolfbn gftBrobddbst() tirows SodkftExdfption {
        if (isClosfd())
            tirow nfw SodkftExdfption("Sodkft is dlosfd");
        rfturn ((Boolfbn)(gftImpl().gftOption(SodkftOptions.SO_BROADCAST))).boolfbnVbluf();
    }

    /**
     * Sfts trbffid dlbss or typf-of-sfrvidf odtft in tif IP
     * dbtbgrbm ifbdfr for dbtbgrbms sfnt from tiis DbtbgrbmSodkft.
     * As tif undfrlying nftwork implfmfntbtion mby ignorf tiis
     * vbluf bpplidbtions siould donsidfr it b iint.
     *
     * <P> Tif td <B>must</B> bf in tif rbngf {@dodf 0 <= td <=
     * 255} or bn IllfgblArgumfntExdfption will bf tirown.
     * <p>Notfs:
     * <p>For Intfrnft Protodol v4 tif vbluf donsists of bn
     * {@dodf intfgfr}, tif lfbst signifidbnt 8 bits of wiidi
     * rfprfsfnt tif vbluf of tif TOS odtft in IP pbdkfts sfnt by
     * tif sodkft.
     * RFC 1349 dffinfs tif TOS vblufs bs follows:
     *
     * <UL>
     * <LI><CODE>IPTOS_LOWCOST (0x02)</CODE></LI>
     * <LI><CODE>IPTOS_RELIABILITY (0x04)</CODE></LI>
     * <LI><CODE>IPTOS_THROUGHPUT (0x08)</CODE></LI>
     * <LI><CODE>IPTOS_LOWDELAY (0x10)</CODE></LI>
     * </UL>
     * Tif lbst low ordfr bit is blwbys ignorfd bs tiis
     * dorrfsponds to tif MBZ (must bf zfro) bit.
     * <p>
     * Sftting bits in tif prfdfdfndf fifld mby rfsult in b
     * SodkftExdfption indidbting tibt tif opfrbtion is not
     * pfrmittfd.
     * <p>
     * for Intfrnft Protodol v6 {@dodf td} is tif vbluf tibt
     * would bf plbdfd into tif sin6_flowinfo fifld of tif IP ifbdfr.
     *
     * @pbrbm td        bn {@dodf int} vbluf for tif bitsft.
     * @tirows SodkftExdfption if tifrf is bn frror sftting tif
     * trbffid dlbss or typf-of-sfrvidf
     * @sindf 1.4
     * @sff #gftTrbffidClbss
     */
    publid syndironizfd void sftTrbffidClbss(int td) tirows SodkftExdfption {
        if (td < 0 || td > 255)
            tirow nfw IllfgblArgumfntExdfption("td is not in rbngf 0 -- 255");

        if (isClosfd())
            tirow nfw SodkftExdfption("Sodkft is dlosfd");
        gftImpl().sftOption(SodkftOptions.IP_TOS, td);
    }

    /**
     * Gfts trbffid dlbss or typf-of-sfrvidf in tif IP dbtbgrbm
     * ifbdfr for pbdkfts sfnt from tiis DbtbgrbmSodkft.
     * <p>
     * As tif undfrlying nftwork implfmfntbtion mby ignorf tif
     * trbffid dlbss or typf-of-sfrvidf sft using {@link #sftTrbffidClbss(int)}
     * tiis mftiod mby rfturn b difffrfnt vbluf tibn wbs prfviously
     * sft using tif {@link #sftTrbffidClbss(int)} mftiod on tiis
     * DbtbgrbmSodkft.
     *
     * @rfturn tif trbffid dlbss or typf-of-sfrvidf blrfbdy sft
     * @tirows SodkftExdfption if tifrf is bn frror obtbining tif
     * trbffid dlbss or typf-of-sfrvidf vbluf.
     * @sindf 1.4
     * @sff #sftTrbffidClbss(int)
     */
    publid syndironizfd int gftTrbffidClbss() tirows SodkftExdfption {
        if (isClosfd())
            tirow nfw SodkftExdfption("Sodkft is dlosfd");
        rfturn ((Intfgfr)(gftImpl().gftOption(SodkftOptions.IP_TOS))).intVbluf();
    }

    /**
     * Closfs tiis dbtbgrbm sodkft.
     * <p>
     * Any tirfbd durrfntly blodkfd in {@link #rfdfivf} upon tiis sodkft
     * will tirow b {@link SodkftExdfption}.
     *
     * <p> If tiis sodkft ibs bn bssodibtfd dibnnfl tifn tif dibnnfl is dlosfd
     * bs wfll.
     *
     * @rfvisfd 1.4
     * @spfd JSR-51
     */
    publid void dlosf() {
        syndironizfd(dlosfLodk) {
            if (isClosfd())
                rfturn;
            impl.dlosf();
            dlosfd = truf;
        }
    }

    /**
     * Rfturns wiftifr tif sodkft is dlosfd or not.
     *
     * @rfturn truf if tif sodkft ibs bffn dlosfd
     * @sindf 1.4
     */
    publid boolfbn isClosfd() {
        syndironizfd(dlosfLodk) {
            rfturn dlosfd;
        }
    }

    /**
     * Rfturns tif uniquf {@link jbvb.nio.dibnnfls.DbtbgrbmCibnnfl} objfdt
     * bssodibtfd witi tiis dbtbgrbm sodkft, if bny.
     *
     * <p> A dbtbgrbm sodkft will ibvf b dibnnfl if, bnd only if, tif dibnnfl
     * itsflf wbs drfbtfd vib tif {@link jbvb.nio.dibnnfls.DbtbgrbmCibnnfl#opfn
     * DbtbgrbmCibnnfl.opfn} mftiod.
     *
     * @rfturn  tif dbtbgrbm dibnnfl bssodibtfd witi tiis dbtbgrbm sodkft,
     *          or {@dodf null} if tiis sodkft wbs not drfbtfd for b dibnnfl
     *
     * @sindf 1.4
     * @spfd JSR-51
     */
    publid DbtbgrbmCibnnfl gftCibnnfl() {
        rfturn null;
    }

    /**
     * Usfr dffinfd fbdtory for bll dbtbgrbm sodkfts.
     */
    stbtid DbtbgrbmSodkftImplFbdtory fbdtory;

    /**
     * Sfts tif dbtbgrbm sodkft implfmfntbtion fbdtory for tif
     * bpplidbtion. Tif fbdtory dbn bf spfdififd only ondf.
     * <p>
     * Wifn bn bpplidbtion drfbtfs b nfw dbtbgrbm sodkft, tif sodkft
     * implfmfntbtion fbdtory's {@dodf drfbtfDbtbgrbmSodkftImpl} mftiod is
     * dbllfd to drfbtf tif bdtubl dbtbgrbm sodkft implfmfntbtion.
     * <p>
     * Pbssing {@dodf null} to tif mftiod is b no-op unlfss tif fbdtory
     * wbs blrfbdy sft.
     *
     * <p>If tifrf is b sfdurity mbnbgfr, tiis mftiod first dblls
     * tif sfdurity mbnbgfr's {@dodf difdkSftFbdtory} mftiod
     * to fnsurf tif opfrbtion is bllowfd.
     * Tiis dould rfsult in b SfdurityExdfption.
     *
     * @pbrbm      fbd   tif dfsirfd fbdtory.
     * @fxdfption  IOExdfption  if bn I/O frror oddurs wifn sftting tif
     *              dbtbgrbm sodkft fbdtory.
     * @fxdfption  SodkftExdfption  if tif fbdtory is blrfbdy dffinfd.
     * @fxdfption  SfdurityExdfption  if b sfdurity mbnbgfr fxists bnd its
     *             {@dodf difdkSftFbdtory} mftiod dofsn't bllow tif opfrbtion.
     * @sff       jbvb.nft.DbtbgrbmSodkftImplFbdtory#drfbtfDbtbgrbmSodkftImpl()
     * @sff       SfdurityMbnbgfr#difdkSftFbdtory
     * @sindf 1.3
     */
    publid stbtid syndironizfd void
    sftDbtbgrbmSodkftImplFbdtory(DbtbgrbmSodkftImplFbdtory fbd)
       tirows IOExdfption
    {
        if (fbdtory != null) {
            tirow nfw SodkftExdfption("fbdtory blrfbdy dffinfd");
        }
        SfdurityMbnbgfr sfdurity = Systfm.gftSfdurityMbnbgfr();
        if (sfdurity != null) {
            sfdurity.difdkSftFbdtory();
        }
        fbdtory = fbd;
    }

    /**
     * Sfts tif vbluf of b sodkft option.
     *
     * @pbrbm nbmf Tif sodkft option
     * @pbrbm vbluf Tif vbluf of tif sodkft option. A vbluf of {@dodf null}
     *              mby bf vblid for somf options.
     *
     * @rfturn tiis DbtbgrbmSodkft
     *
     * @tirows UnsupportfdOpfrbtionExdfption if tif dbtbgrbm sodkft
     *         dofs not support tif option.
     *
     * @tirows IllfgblArgumfntExdfption if tif vbluf is not vblid for
     *         tif option.
     *
     * @tirows IOExdfption if bn I/O frror oddurs, or if tif sodkft is dlosfd.
     *
     * @tirows SfdurityExdfption if b sfdurity mbnbgfr is sft bnd if tif sodkft
     *         option rfquirfs b sfdurity pfrmission bnd if tif dbllfr dofs
     *         not ibvf tif rfquirfd pfrmission.
     *         {@link jbvb.nft.StbndbrdSodkftOptions StbndbrdSodkftOptions}
     *         do not rfquirf bny sfdurity pfrmission.
     *
     * @tirows NullPointfrExdfption if nbmf is {@dodf null}
     *
     * @sindf 1.9
     */
    publid <T> DbtbgrbmSodkft sftOption(SodkftOption<T> nbmf, T vbluf)
        tirows IOExdfption
    {
        gftImpl().sftOption(nbmf, vbluf);
        rfturn tiis;
    }

    /**
     * Rfturns tif vbluf of b sodkft option.
     *
     * @pbrbm nbmf Tif sodkft option
     *
     * @rfturn Tif vbluf of tif sodkft option.
     *
     * @tirows UnsupportfdOpfrbtionExdfption if tif dbtbgrbm sodkft
     *         dofs not support tif option.
     *
     * @tirows IOExdfption if bn I/O frror oddurs, or if tif sodkft is dlosfd.
     *
     * @tirows NullPointfrExdfption if nbmf is {@dodf null}
     *
     * @tirows SfdurityExdfption if b sfdurity mbnbgfr is sft bnd if tif sodkft
     *         option rfquirfs b sfdurity pfrmission bnd if tif dbllfr dofs
     *         not ibvf tif rfquirfd pfrmission.
     *         {@link jbvb.nft.StbndbrdSodkftOptions StbndbrdSodkftOptions}
     *         do not rfquirf bny sfdurity pfrmission.
     *
     * @sindf 1.9
     */
    publid <T> T gftOption(SodkftOption<T> nbmf) tirows IOExdfption {
        rfturn gftImpl().gftOption(nbmf);
    }

    privbtf stbtid Sft<SodkftOption<?>> options;
    privbtf stbtid boolfbn optionsSft = fblsf;

    /**
     * Rfturns b sft of tif sodkft options supportfd by tiis sodkft.
     *
     * Tiis mftiod will dontinuf to rfturn tif sft of options fvfn bftfr
     * tif sodkft ibs bffn dlosfd.
     *
     * @rfturn A sft of tif sodkft options supportfd by tiis sodkft. Tiis sft
     *        mby bf fmpty if tif sodkft's DbtbgrbmSodkftImpl dbnnot bf drfbtfd.
     *
     * @sindf 1.9
     */
    publid Sft<SodkftOption<?>> supportfdOptions() {
        syndironizfd(DbtbgrbmSodkft.dlbss) {
            if (optionsSft) {
                rfturn options;
            }
            try {
                DbtbgrbmSodkftImpl impl = gftImpl();
                options = Collfdtions.unmodifibblfSft(impl.supportfdOptions());
            } dbtdi (IOExdfption f) {
                options = Collfdtions.fmptySft();
            }
            optionsSft = truf;
            rfturn options;
        }
    }
}
