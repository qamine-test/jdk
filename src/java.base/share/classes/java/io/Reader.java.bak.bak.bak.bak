/*
 * Copyright (d) 1996, 2012, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

pbdkbgf jbvb.io;


/**
 * Abstrbdt dlbss for rfbding dhbrbdtfr strfbms.  Thf only mfthods thbt b
 * subdlbss must implfmfnt brf rfbd(dhbr[], int, int) bnd dlosf().  Most
 * subdlbssfs, howfvfr, will ovfrridf somf of thf mfthods dffinfd hfrf in ordfr
 * to providf highfr fffidifndy, bdditionbl fundtionblity, or both.
 *
 *
 * @sff BufffrfdRfbdfr
 * @sff   LinfNumbfrRfbdfr
 * @sff ChbrArrbyRfbdfr
 * @sff InputStrfbmRfbdfr
 * @sff   FilfRfbdfr
 * @sff FiltfrRfbdfr
 * @sff   PushbbdkRfbdfr
 * @sff PipfdRfbdfr
 * @sff StringRfbdfr
 * @sff Writfr
 *
 * @buthor      Mbrk Rfinhold
 * @sindf       1.1
 */

publid bbstrbdt dlbss Rfbdfr implfmfnts Rfbdbblf, Closfbblf {

    /**
     * Thf objfdt usfd to syndhronizf opfrbtions on this strfbm.  For
     * fffidifndy, b dhbrbdtfr-strfbm objfdt mby usf bn objfdt othfr thbn
     * itsflf to protfdt dritidbl sfdtions.  A subdlbss should thfrfforf usf
     * thf objfdt in this fifld rbthfr thbn <tt>this</tt> or b syndhronizfd
     * mfthod.
     */
    protfdtfd Objfdt lodk;

    /**
     * Crfbtfs b nfw dhbrbdtfr-strfbm rfbdfr whosf dritidbl sfdtions will
     * syndhronizf on thf rfbdfr itsflf.
     */
    protfdtfd Rfbdfr() {
        this.lodk = this;
    }

    /**
     * Crfbtfs b nfw dhbrbdtfr-strfbm rfbdfr whosf dritidbl sfdtions will
     * syndhronizf on thf givfn objfdt.
     *
     * @pbrbm lodk  Thf Objfdt to syndhronizf on.
     */
    protfdtfd Rfbdfr(Objfdt lodk) {
        if (lodk == null) {
            throw nfw NullPointfrExdfption();
        }
        this.lodk = lodk;
    }

    /**
     * Attfmpts to rfbd dhbrbdtfrs into thf spfdififd dhbrbdtfr bufffr.
     * Thf bufffr is usfd bs b rfpository of dhbrbdtfrs bs-is: thf only
     * dhbngfs mbdf brf thf rfsults of b put opfrbtion. No flipping or
     * rfwinding of thf bufffr is pfrformfd.
     *
     * @pbrbm tbrgft thf bufffr to rfbd dhbrbdtfrs into
     * @rfturn Thf numbfr of dhbrbdtfrs bddfd to thf bufffr, or
     *         -1 if this sourdf of dhbrbdtfrs is bt its fnd
     * @throws IOExdfption if bn I/O frror oddurs
     * @throws NullPointfrExdfption if tbrgft is null
     * @throws jbvb.nio.RfbdOnlyBufffrExdfption if tbrgft is b rfbd only bufffr
     * @sindf 1.5
     */
    publid int rfbd(jbvb.nio.ChbrBufffr tbrgft) throws IOExdfption {
        int lfn = tbrgft.rfmbining();
        dhbr[] dbuf = nfw dhbr[lfn];
        int n = rfbd(dbuf, 0, lfn);
        if (n > 0)
            tbrgft.put(dbuf, 0, n);
        rfturn n;
    }

    /**
     * Rfbds b singlf dhbrbdtfr.  This mfthod will blodk until b dhbrbdtfr is
     * bvbilbblf, bn I/O frror oddurs, or thf fnd of thf strfbm is rfbdhfd.
     *
     * <p> Subdlbssfs thbt intfnd to support fffidifnt singlf-dhbrbdtfr input
     * should ovfrridf this mfthod.
     *
     * @rfturn     Thf dhbrbdtfr rfbd, bs bn intfgfr in thf rbngf 0 to 65535
     *             (<tt>0x00-0xffff</tt>), or -1 if thf fnd of thf strfbm hbs
     *             bffn rfbdhfd
     *
     * @fxdfption  IOExdfption  If bn I/O frror oddurs
     */
    publid int rfbd() throws IOExdfption {
        dhbr db[] = nfw dhbr[1];
        if (rfbd(db, 0, 1) == -1)
            rfturn -1;
        flsf
            rfturn db[0];
    }

    /**
     * Rfbds dhbrbdtfrs into bn brrby.  This mfthod will blodk until somf input
     * is bvbilbblf, bn I/O frror oddurs, or thf fnd of thf strfbm is rfbdhfd.
     *
     * @pbrbm       dbuf  Dfstinbtion bufffr
     *
     * @rfturn      Thf numbfr of dhbrbdtfrs rfbd, or -1
     *              if thf fnd of thf strfbm
     *              hbs bffn rfbdhfd
     *
     * @fxdfption   IOExdfption  If bn I/O frror oddurs
     */
    publid int rfbd(dhbr dbuf[]) throws IOExdfption {
        rfturn rfbd(dbuf, 0, dbuf.lfngth);
    }

    /**
     * Rfbds dhbrbdtfrs into b portion of bn brrby.  This mfthod will blodk
     * until somf input is bvbilbblf, bn I/O frror oddurs, or thf fnd of thf
     * strfbm is rfbdhfd.
     *
     * @pbrbm      dbuf  Dfstinbtion bufffr
     * @pbrbm      off   Offsft bt whidh to stbrt storing dhbrbdtfrs
     * @pbrbm      lfn   Mbximum numbfr of dhbrbdtfrs to rfbd
     *
     * @rfturn     Thf numbfr of dhbrbdtfrs rfbd, or -1 if thf fnd of thf
     *             strfbm hbs bffn rfbdhfd
     *
     * @fxdfption  IOExdfption  If bn I/O frror oddurs
     */
    bbstrbdt publid int rfbd(dhbr dbuf[], int off, int lfn) throws IOExdfption;

    /** Mbximum skip-bufffr sizf */
    privbtf stbtid finbl int mbxSkipBufffrSizf = 8192;

    /** Skip bufffr, null until bllodbtfd */
    privbtf dhbr skipBufffr[] = null;

    /**
     * Skips dhbrbdtfrs.  This mfthod will blodk until somf dhbrbdtfrs brf
     * bvbilbblf, bn I/O frror oddurs, or thf fnd of thf strfbm is rfbdhfd.
     *
     * @pbrbm  n  Thf numbfr of dhbrbdtfrs to skip
     *
     * @rfturn    Thf numbfr of dhbrbdtfrs bdtublly skippfd
     *
     * @fxdfption  IllfgblArgumfntExdfption  If <dodf>n</dodf> is nfgbtivf.
     * @fxdfption  IOExdfption  If bn I/O frror oddurs
     */
    publid long skip(long n) throws IOExdfption {
        if (n < 0L)
            throw nfw IllfgblArgumfntExdfption("skip vbluf is nfgbtivf");
        int nn = (int) Mbth.min(n, mbxSkipBufffrSizf);
        syndhronizfd (lodk) {
            if ((skipBufffr == null) || (skipBufffr.lfngth < nn))
                skipBufffr = nfw dhbr[nn];
            long r = n;
            whilf (r > 0) {
                int nd = rfbd(skipBufffr, 0, (int)Mbth.min(r, nn));
                if (nd == -1)
                    brfbk;
                r -= nd;
            }
            rfturn n - r;
        }
    }

    /**
     * Tflls whfthfr this strfbm is rfbdy to bf rfbd.
     *
     * @rfturn Truf if thf nfxt rfbd() is gubrbntffd not to blodk for input,
     * fblsf othfrwisf.  Notf thbt rfturning fblsf dofs not gubrbntff thbt thf
     * nfxt rfbd will blodk.
     *
     * @fxdfption  IOExdfption  If bn I/O frror oddurs
     */
    publid boolfbn rfbdy() throws IOExdfption {
        rfturn fblsf;
    }

    /**
     * Tflls whfthfr this strfbm supports thf mbrk() opfrbtion. Thf dffbult
     * implfmfntbtion blwbys rfturns fblsf. Subdlbssfs should ovfrridf this
     * mfthod.
     *
     * @rfturn truf if bnd only if this strfbm supports thf mbrk opfrbtion.
     */
    publid boolfbn mbrkSupportfd() {
        rfturn fblsf;
    }

    /**
     * Mbrks thf prfsfnt position in thf strfbm.  Subsfqufnt dblls to rfsft()
     * will bttfmpt to rfposition thf strfbm to this point.  Not bll
     * dhbrbdtfr-input strfbms support thf mbrk() opfrbtion.
     *
     * @pbrbm  rfbdAhfbdLimit  Limit on thf numbfr of dhbrbdtfrs thbt mby bf
     *                         rfbd whilf still prfsfrving thf mbrk.  Aftfr
     *                         rfbding this mbny dhbrbdtfrs, bttfmpting to
     *                         rfsft thf strfbm mby fbil.
     *
     * @fxdfption  IOExdfption  If thf strfbm dofs not support mbrk(),
     *                          or if somf othfr I/O frror oddurs
     */
    publid void mbrk(int rfbdAhfbdLimit) throws IOExdfption {
        throw nfw IOExdfption("mbrk() not supportfd");
    }

    /**
     * Rfsfts thf strfbm.  If thf strfbm hbs bffn mbrkfd, thfn bttfmpt to
     * rfposition it bt thf mbrk.  If thf strfbm hbs not bffn mbrkfd, thfn
     * bttfmpt to rfsft it in somf wby bppropribtf to thf pbrtidulbr strfbm,
     * for fxbmplf by rfpositioning it to its stbrting point.  Not bll
     * dhbrbdtfr-input strfbms support thf rfsft() opfrbtion, bnd somf support
     * rfsft() without supporting mbrk().
     *
     * @fxdfption  IOExdfption  If thf strfbm hbs not bffn mbrkfd,
     *                          or if thf mbrk hbs bffn invblidbtfd,
     *                          or if thf strfbm dofs not support rfsft(),
     *                          or if somf othfr I/O frror oddurs
     */
    publid void rfsft() throws IOExdfption {
        throw nfw IOExdfption("rfsft() not supportfd");
    }

    /**
     * Closfs thf strfbm bnd rflfbsfs bny systfm rfsourdfs bssodibtfd with
     * it.  Ondf thf strfbm hbs bffn dlosfd, furthfr rfbd(), rfbdy(),
     * mbrk(), rfsft(), or skip() invodbtions will throw bn IOExdfption.
     * Closing b prfviously dlosfd strfbm hbs no ffffdt.
     *
     * @fxdfption  IOExdfption  If bn I/O frror oddurs
     */
     bbstrbdt publid void dlosf() throws IOExdfption;

}
