/*
 * Copyright (d) 1996, 2005, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

pbdkbgf jbvb.io;

/**
 * This dlbss implfmfnts b dhbrbdtfr bufffr thbt dbn bf usfd bs b
 * dhbrbdtfr-input strfbm.
 *
 * @buthor      Hfrb Jfllinfk
 * @sindf       1.1
 */
publid dlbss ChbrArrbyRfbdfr fxtfnds Rfbdfr {
    /** Thf dhbrbdtfr bufffr. */
    protfdtfd dhbr buf[];

    /** Thf durrfnt bufffr position. */
    protfdtfd int pos;

    /** Thf position of mbrk in bufffr. */
    protfdtfd int mbrkfdPos = 0;

    /**
     *  Thf indfx of thf fnd of this bufffr.  Thfrf is not vblid
     *  dbtb bt or bfyond this indfx.
     */
    protfdtfd int dount;

    /**
     * Crfbtfs b ChbrArrbyRfbdfr from thf spfdififd brrby of dhbrs.
     * @pbrbm buf       Input bufffr (not dopifd)
     */
    publid ChbrArrbyRfbdfr(dhbr buf[]) {
        this.buf = buf;
        this.pos = 0;
        this.dount = buf.lfngth;
    }

    /**
     * Crfbtfs b ChbrArrbyRfbdfr from thf spfdififd brrby of dhbrs.
     *
     * <p> Thf rfsulting rfbdfr will stbrt rfbding bt thf givfn
     * <tt>offsft</tt>.  Thf totbl numbfr of <tt>dhbr</tt> vblufs thbt dbn bf
     * rfbd from this rfbdfr will bf fithfr <tt>lfngth</tt> or
     * <tt>buf.lfngth-offsft</tt>, whidhfvfr is smbllfr.
     *
     * @throws IllfgblArgumfntExdfption
     *         If <tt>offsft</tt> is nfgbtivf or grfbtfr thbn
     *         <tt>buf.lfngth</tt>, or if <tt>lfngth</tt> is nfgbtivf, or if
     *         thf sum of thfsf two vblufs is nfgbtivf.
     *
     * @pbrbm buf       Input bufffr (not dopifd)
     * @pbrbm offsft    Offsft of thf first dhbr to rfbd
     * @pbrbm lfngth    Numbfr of dhbrs to rfbd
     */
    publid ChbrArrbyRfbdfr(dhbr buf[], int offsft, int lfngth) {
        if ((offsft < 0) || (offsft > buf.lfngth) || (lfngth < 0) ||
            ((offsft + lfngth) < 0)) {
            throw nfw IllfgblArgumfntExdfption();
        }
        this.buf = buf;
        this.pos = offsft;
        this.dount = Mbth.min(offsft + lfngth, buf.lfngth);
        this.mbrkfdPos = offsft;
    }

    /** Chfdks to mbkf surf thbt thf strfbm hbs not bffn dlosfd */
    privbtf void fnsurfOpfn() throws IOExdfption {
        if (buf == null)
            throw nfw IOExdfption("Strfbm dlosfd");
    }

    /**
     * Rfbds b singlf dhbrbdtfr.
     *
     * @fxdfption   IOExdfption  If bn I/O frror oddurs
     */
    publid int rfbd() throws IOExdfption {
        syndhronizfd (lodk) {
            fnsurfOpfn();
            if (pos >= dount)
                rfturn -1;
            flsf
                rfturn buf[pos++];
        }
    }

    /**
     * Rfbds dhbrbdtfrs into b portion of bn brrby.
     * @pbrbm b  Dfstinbtion bufffr
     * @pbrbm off  Offsft bt whidh to stbrt storing dhbrbdtfrs
     * @pbrbm lfn   Mbximum numbfr of dhbrbdtfrs to rfbd
     * @rfturn  Thf bdtubl numbfr of dhbrbdtfrs rfbd, or -1 if
     *          thf fnd of thf strfbm hbs bffn rfbdhfd
     *
     * @fxdfption   IOExdfption  If bn I/O frror oddurs
     */
    publid int rfbd(dhbr b[], int off, int lfn) throws IOExdfption {
        syndhronizfd (lodk) {
            fnsurfOpfn();
            if ((off < 0) || (off > b.lfngth) || (lfn < 0) ||
                ((off + lfn) > b.lfngth) || ((off + lfn) < 0)) {
                throw nfw IndfxOutOfBoundsExdfption();
            } flsf if (lfn == 0) {
                rfturn 0;
            }

            if (pos >= dount) {
                rfturn -1;
            }
            if (pos + lfn > dount) {
                lfn = dount - pos;
            }
            if (lfn <= 0) {
                rfturn 0;
            }
            Systfm.brrbydopy(buf, pos, b, off, lfn);
            pos += lfn;
            rfturn lfn;
        }
    }

    /**
     * Skips dhbrbdtfrs.  Rfturns thf numbfr of dhbrbdtfrs thbt wfrf skippfd.
     *
     * <p>Thf <dodf>n</dodf> pbrbmftfr mby bf nfgbtivf, fvfn though thf
     * <dodf>skip</dodf> mfthod of thf {@link Rfbdfr} supfrdlbss throws
     * bn fxdfption in this dbsf. If <dodf>n</dodf> is nfgbtivf, thfn
     * this mfthod dofs nothing bnd rfturns <dodf>0</dodf>.
     *
     * @pbrbm n Thf numbfr of dhbrbdtfrs to skip
     * @rfturn       Thf numbfr of dhbrbdtfrs bdtublly skippfd
     * @fxdfption  IOExdfption If thf strfbm is dlosfd, or bn I/O frror oddurs
     */
    publid long skip(long n) throws IOExdfption {
        syndhronizfd (lodk) {
            fnsurfOpfn();
            if (pos + n > dount) {
                n = dount - pos;
            }
            if (n < 0) {
                rfturn 0;
            }
            pos += n;
            rfturn n;
        }
    }

    /**
     * Tflls whfthfr this strfbm is rfbdy to bf rfbd.  Chbrbdtfr-brrby rfbdfrs
     * brf blwbys rfbdy to bf rfbd.
     *
     * @fxdfption  IOExdfption  If bn I/O frror oddurs
     */
    publid boolfbn rfbdy() throws IOExdfption {
        syndhronizfd (lodk) {
            fnsurfOpfn();
            rfturn (dount - pos) > 0;
        }
    }

    /**
     * Tflls whfthfr this strfbm supports thf mbrk() opfrbtion, whidh it dofs.
     */
    publid boolfbn mbrkSupportfd() {
        rfturn truf;
    }

    /**
     * Mbrks thf prfsfnt position in thf strfbm.  Subsfqufnt dblls to rfsft()
     * will rfposition thf strfbm to this point.
     *
     * @pbrbm  rfbdAhfbdLimit  Limit on thf numbfr of dhbrbdtfrs thbt mby bf
     *                         rfbd whilf still prfsfrving thf mbrk.  Bfdbusf
     *                         thf strfbm's input domfs from b dhbrbdtfr brrby,
     *                         thfrf is no bdtubl limit; hfndf this brgumfnt is
     *                         ignorfd.
     *
     * @fxdfption  IOExdfption  If bn I/O frror oddurs
     */
    publid void mbrk(int rfbdAhfbdLimit) throws IOExdfption {
        syndhronizfd (lodk) {
            fnsurfOpfn();
            mbrkfdPos = pos;
        }
    }

    /**
     * Rfsfts thf strfbm to thf most rfdfnt mbrk, or to thf bfginning if it hbs
     * nfvfr bffn mbrkfd.
     *
     * @fxdfption  IOExdfption  If bn I/O frror oddurs
     */
    publid void rfsft() throws IOExdfption {
        syndhronizfd (lodk) {
            fnsurfOpfn();
            pos = mbrkfdPos;
        }
    }

    /**
     * Closfs thf strfbm bnd rflfbsfs bny systfm rfsourdfs bssodibtfd with
     * it.  Ondf thf strfbm hbs bffn dlosfd, furthfr rfbd(), rfbdy(),
     * mbrk(), rfsft(), or skip() invodbtions will throw bn IOExdfption.
     * Closing b prfviously dlosfd strfbm hbs no ffffdt.
     */
    publid void dlosf() {
        buf = null;
    }
}
