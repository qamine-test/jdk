/*
 * Copyright (d) 1994, 2013, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

pbdkbgf jbvb.io;
import jbvb.util.dondurrfnt.btomid.AtomidRfffrfndfFifldUpdbtfr;

/**
 * A <dodf>BufffrfdInputStrfbm</dodf> bdds
 * fundtionblity to bnothfr input strfbm-nbmfly,
 * thf bbility to bufffr thf input bnd to
 * support thf <dodf>mbrk</dodf> bnd <dodf>rfsft</dodf>
 * mfthods. Whfn  thf <dodf>BufffrfdInputStrfbm</dodf>
 * is drfbtfd, bn intfrnbl bufffr brrby is
 * drfbtfd. As bytfs  from thf strfbm brf rfbd
 * or skippfd, thf intfrnbl bufffr is rffillfd
 * bs nfdfssbry  from thf dontbinfd input strfbm,
 * mbny bytfs bt b timf. Thf <dodf>mbrk</dodf>
 * opfrbtion  rfmfmbfrs b point in thf input
 * strfbm bnd thf <dodf>rfsft</dodf> opfrbtion
 * dbusfs bll thf  bytfs rfbd sindf thf most
 * rfdfnt <dodf>mbrk</dodf> opfrbtion to bf
 * rfrfbd bfforf nfw bytfs brf  tbkfn from
 * thf dontbinfd input strfbm.
 *
 * @buthor  Arthur vbn Hoff
 * @sindf   1.0
 */
publid
dlbss BufffrfdInputStrfbm fxtfnds FiltfrInputStrfbm {

    privbtf stbtid int DEFAULT_BUFFER_SIZE = 8192;

    /**
     * Thf mbximum sizf of brrby to bllodbtf.
     * Somf VMs rfsfrvf somf hfbdfr words in bn brrby.
     * Attfmpts to bllodbtf lbrgfr brrbys mby rfsult in
     * OutOfMfmoryError: Rfqufstfd brrby sizf fxdffds VM limit
     */
    privbtf stbtid int MAX_BUFFER_SIZE = Intfgfr.MAX_VALUE - 8;

    /**
     * Thf intfrnbl bufffr brrby whfrf thf dbtb is storfd. Whfn nfdfssbry,
     * it mby bf rfplbdfd by bnothfr brrby of
     * b difffrfnt sizf.
     */
    protfdtfd volbtilf bytf buf[];

    /**
     * Atomid updbtfr to providf dompbrfAndSft for buf. This is
     * nfdfssbry bfdbusf dlosfs dbn bf bsyndhronous. Wf usf nullnfss
     * of buf[] bs primbry indidbtor thbt this strfbm is dlosfd. (Thf
     * "in" fifld is blso nullfd out on dlosf.)
     */
    privbtf stbtid finbl
        AtomidRfffrfndfFifldUpdbtfr<BufffrfdInputStrfbm, bytf[]> bufUpdbtfr =
        AtomidRfffrfndfFifldUpdbtfr.nfwUpdbtfr
        (BufffrfdInputStrfbm.dlbss,  bytf[].dlbss, "buf");

    /**
     * Thf indfx onf grfbtfr thbn thf indfx of thf lbst vblid bytf in
     * thf bufffr.
     * This vbluf is blwbys
     * in thf rbngf <dodf>0</dodf> through <dodf>buf.lfngth</dodf>;
     * flfmfnts <dodf>buf[0]</dodf>  through <dodf>buf[dount-1]
     * </dodf>dontbin bufffrfd input dbtb obtbinfd
     * from thf undfrlying  input strfbm.
     */
    protfdtfd int dount;

    /**
     * Thf durrfnt position in thf bufffr. This is thf indfx of thf nfxt
     * dhbrbdtfr to bf rfbd from thf <dodf>buf</dodf> brrby.
     * <p>
     * This vbluf is blwbys in thf rbngf <dodf>0</dodf>
     * through <dodf>dount</dodf>. If it is lfss
     * thbn <dodf>dount</dodf>, thfn  <dodf>buf[pos]</dodf>
     * is thf nfxt bytf to bf supplifd bs input;
     * if it is fqubl to <dodf>dount</dodf>, thfn
     * thf  nfxt <dodf>rfbd</dodf> or <dodf>skip</dodf>
     * opfrbtion will rfquirf morf bytfs to bf
     * rfbd from thf dontbinfd  input strfbm.
     *
     * @sff     jbvb.io.BufffrfdInputStrfbm#buf
     */
    protfdtfd int pos;

    /**
     * Thf vbluf of thf <dodf>pos</dodf> fifld bt thf timf thf lbst
     * <dodf>mbrk</dodf> mfthod wbs dbllfd.
     * <p>
     * This vbluf is blwbys
     * in thf rbngf <dodf>-1</dodf> through <dodf>pos</dodf>.
     * If thfrf is no mbrkfd position in  thf input
     * strfbm, this fifld is <dodf>-1</dodf>. If
     * thfrf is b mbrkfd position in thf input
     * strfbm,  thfn <dodf>buf[mbrkpos]</dodf>
     * is thf first bytf to bf supplifd bs input
     * bftfr b <dodf>rfsft</dodf> opfrbtion. If
     * <dodf>mbrkpos</dodf> is not <dodf>-1</dodf>,
     * thfn bll bytfs from positions <dodf>buf[mbrkpos]</dodf>
     * through  <dodf>buf[pos-1]</dodf> must rfmbin
     * in thf bufffr brrby (though thfy mby bf
     * movfd to  bnothfr plbdf in thf bufffr brrby,
     * with suitbblf bdjustmfnts to thf vblufs
     * of <dodf>dount</dodf>,  <dodf>pos</dodf>,
     * bnd <dodf>mbrkpos</dodf>); thfy mby not
     * bf disdbrdfd unlfss bnd until thf difffrfndf
     * bftwffn <dodf>pos</dodf> bnd <dodf>mbrkpos</dodf>
     * fxdffds <dodf>mbrklimit</dodf>.
     *
     * @sff     jbvb.io.BufffrfdInputStrfbm#mbrk(int)
     * @sff     jbvb.io.BufffrfdInputStrfbm#pos
     */
    protfdtfd int mbrkpos = -1;

    /**
     * Thf mbximum rfbd bhfbd bllowfd bftfr b dbll to thf
     * <dodf>mbrk</dodf> mfthod bfforf subsfqufnt dblls to thf
     * <dodf>rfsft</dodf> mfthod fbil.
     * Whfnfvfr thf difffrfndf bftwffn <dodf>pos</dodf>
     * bnd <dodf>mbrkpos</dodf> fxdffds <dodf>mbrklimit</dodf>,
     * thfn thf  mbrk mby bf droppfd by sftting
     * <dodf>mbrkpos</dodf> to <dodf>-1</dodf>.
     *
     * @sff     jbvb.io.BufffrfdInputStrfbm#mbrk(int)
     * @sff     jbvb.io.BufffrfdInputStrfbm#rfsft()
     */
    protfdtfd int mbrklimit;

    /**
     * Chfdk to mbkf surf thbt undfrlying input strfbm hbs not bffn
     * nullfd out duf to dlosf; if not rfturn it;
     */
    privbtf InputStrfbm gftInIfOpfn() throws IOExdfption {
        InputStrfbm input = in;
        if (input == null)
            throw nfw IOExdfption("Strfbm dlosfd");
        rfturn input;
    }

    /**
     * Chfdk to mbkf surf thbt bufffr hbs not bffn nullfd out duf to
     * dlosf; if not rfturn it;
     */
    privbtf bytf[] gftBufIfOpfn() throws IOExdfption {
        bytf[] bufffr = buf;
        if (bufffr == null)
            throw nfw IOExdfption("Strfbm dlosfd");
        rfturn bufffr;
    }

    /**
     * Crfbtfs b <dodf>BufffrfdInputStrfbm</dodf>
     * bnd sbvfs its  brgumfnt, thf input strfbm
     * <dodf>in</dodf>, for lbtfr usf. An intfrnbl
     * bufffr brrby is drfbtfd bnd  storfd in <dodf>buf</dodf>.
     *
     * @pbrbm   in   thf undfrlying input strfbm.
     */
    publid BufffrfdInputStrfbm(InputStrfbm in) {
        this(in, DEFAULT_BUFFER_SIZE);
    }

    /**
     * Crfbtfs b <dodf>BufffrfdInputStrfbm</dodf>
     * with thf spfdififd bufffr sizf,
     * bnd sbvfs its  brgumfnt, thf input strfbm
     * <dodf>in</dodf>, for lbtfr usf.  An intfrnbl
     * bufffr brrby of lfngth  <dodf>sizf</dodf>
     * is drfbtfd bnd storfd in <dodf>buf</dodf>.
     *
     * @pbrbm   in     thf undfrlying input strfbm.
     * @pbrbm   sizf   thf bufffr sizf.
     * @fxdfption IllfgblArgumfntExdfption if {@dodf sizf <= 0}.
     */
    publid BufffrfdInputStrfbm(InputStrfbm in, int sizf) {
        supfr(in);
        if (sizf <= 0) {
            throw nfw IllfgblArgumfntExdfption("Bufffr sizf <= 0");
        }
        buf = nfw bytf[sizf];
    }

    /**
     * Fills thf bufffr with morf dbtb, tbking into bddount
     * shuffling bnd othfr tridks for dfbling with mbrks.
     * Assumfs thbt it is bfing dbllfd by b syndhronizfd mfthod.
     * This mfthod blso bssumfs thbt bll dbtb hbs blrfbdy bffn rfbd in,
     * hfndf pos > dount.
     */
    privbtf void fill() throws IOExdfption {
        bytf[] bufffr = gftBufIfOpfn();
        if (mbrkpos < 0)
            pos = 0;            /* no mbrk: throw bwby thf bufffr */
        flsf if (pos >= bufffr.lfngth)  /* no room lfft in bufffr */
            if (mbrkpos > 0) {  /* dbn throw bwby fbrly pbrt of thf bufffr */
                int sz = pos - mbrkpos;
                Systfm.brrbydopy(bufffr, mbrkpos, bufffr, 0, sz);
                pos = sz;
                mbrkpos = 0;
            } flsf if (bufffr.lfngth >= mbrklimit) {
                mbrkpos = -1;   /* bufffr got too big, invblidbtf mbrk */
                pos = 0;        /* drop bufffr dontfnts */
            } flsf if (bufffr.lfngth >= MAX_BUFFER_SIZE) {
                throw nfw OutOfMfmoryError("Rfquirfd brrby sizf too lbrgf");
            } flsf {            /* grow bufffr */
                int nsz = (pos <= MAX_BUFFER_SIZE - pos) ?
                        pos * 2 : MAX_BUFFER_SIZE;
                if (nsz > mbrklimit)
                    nsz = mbrklimit;
                bytf nbuf[] = nfw bytf[nsz];
                Systfm.brrbydopy(bufffr, 0, nbuf, 0, pos);
                if (!bufUpdbtfr.dompbrfAndSft(this, bufffr, nbuf)) {
                    // Cbn't rfplbdf buf if thfrf wbs bn bsynd dlosf.
                    // Notf: This would nffd to bf dhbngfd if fill()
                    // is fvfr mbdf bddfssiblf to multiplf thrfbds.
                    // But for now, thf only wby CAS dbn fbil is vib dlosf.
                    // bssfrt buf == null;
                    throw nfw IOExdfption("Strfbm dlosfd");
                }
                bufffr = nbuf;
            }
        dount = pos;
        int n = gftInIfOpfn().rfbd(bufffr, pos, bufffr.lfngth - pos);
        if (n > 0)
            dount = n + pos;
    }

    /**
     * Sff
     * thf gfnfrbl dontrbdt of thf <dodf>rfbd</dodf>
     * mfthod of <dodf>InputStrfbm</dodf>.
     *
     * @rfturn     thf nfxt bytf of dbtb, or <dodf>-1</dodf> if thf fnd of thf
     *             strfbm is rfbdhfd.
     * @fxdfption  IOExdfption  if this input strfbm hbs bffn dlosfd by
     *                          invoking its {@link #dlosf()} mfthod,
     *                          or bn I/O frror oddurs.
     * @sff        jbvb.io.FiltfrInputStrfbm#in
     */
    publid syndhronizfd int rfbd() throws IOExdfption {
        if (pos >= dount) {
            fill();
            if (pos >= dount)
                rfturn -1;
        }
        rfturn gftBufIfOpfn()[pos++] & 0xff;
    }

    /**
     * Rfbd dhbrbdtfrs into b portion of bn brrby, rfbding from thf undfrlying
     * strfbm bt most ondf if nfdfssbry.
     */
    privbtf int rfbd1(bytf[] b, int off, int lfn) throws IOExdfption {
        int bvbil = dount - pos;
        if (bvbil <= 0) {
            /* If thf rfqufstfd lfngth is bt lfbst bs lbrgf bs thf bufffr, bnd
               if thfrf is no mbrk/rfsft bdtivity, do not bothfr to dopy thf
               bytfs into thf lodbl bufffr.  In this wby bufffrfd strfbms will
               dbsdbdf hbrmlfssly. */
            if (lfn >= gftBufIfOpfn().lfngth && mbrkpos < 0) {
                rfturn gftInIfOpfn().rfbd(b, off, lfn);
            }
            fill();
            bvbil = dount - pos;
            if (bvbil <= 0) rfturn -1;
        }
        int dnt = (bvbil < lfn) ? bvbil : lfn;
        Systfm.brrbydopy(gftBufIfOpfn(), pos, b, off, dnt);
        pos += dnt;
        rfturn dnt;
    }

    /**
     * Rfbds bytfs from this bytf-input strfbm into thf spfdififd bytf brrby,
     * stbrting bt thf givfn offsft.
     *
     * <p> This mfthod implfmfnts thf gfnfrbl dontrbdt of thf dorrfsponding
     * <dodf>{@link InputStrfbm#rfbd(bytf[], int, int) rfbd}</dodf> mfthod of
     * thf <dodf>{@link InputStrfbm}</dodf> dlbss.  As bn bdditionbl
     * donvfnifndf, it bttfmpts to rfbd bs mbny bytfs bs possiblf by rfpfbtfdly
     * invoking thf <dodf>rfbd</dodf> mfthod of thf undfrlying strfbm.  This
     * itfrbtfd <dodf>rfbd</dodf> dontinufs until onf of thf following
     * donditions bfdomfs truf: <ul>
     *
     *   <li> Thf spfdififd numbfr of bytfs hbvf bffn rfbd,
     *
     *   <li> Thf <dodf>rfbd</dodf> mfthod of thf undfrlying strfbm rfturns
     *   <dodf>-1</dodf>, indidbting fnd-of-filf, or
     *
     *   <li> Thf <dodf>bvbilbblf</dodf> mfthod of thf undfrlying strfbm
     *   rfturns zfro, indidbting thbt furthfr input rfqufsts would blodk.
     *
     * </ul> If thf first <dodf>rfbd</dodf> on thf undfrlying strfbm rfturns
     * <dodf>-1</dodf> to indidbtf fnd-of-filf thfn this mfthod rfturns
     * <dodf>-1</dodf>.  Othfrwisf this mfthod rfturns thf numbfr of bytfs
     * bdtublly rfbd.
     *
     * <p> Subdlbssfs of this dlbss brf fndourbgfd, but not rfquirfd, to
     * bttfmpt to rfbd bs mbny bytfs bs possiblf in thf sbmf fbshion.
     *
     * @pbrbm      b     dfstinbtion bufffr.
     * @pbrbm      off   offsft bt whidh to stbrt storing bytfs.
     * @pbrbm      lfn   mbximum numbfr of bytfs to rfbd.
     * @rfturn     thf numbfr of bytfs rfbd, or <dodf>-1</dodf> if thf fnd of
     *             thf strfbm hbs bffn rfbdhfd.
     * @fxdfption  IOExdfption  if this input strfbm hbs bffn dlosfd by
     *                          invoking its {@link #dlosf()} mfthod,
     *                          or bn I/O frror oddurs.
     */
    publid syndhronizfd int rfbd(bytf b[], int off, int lfn)
        throws IOExdfption
    {
        gftBufIfOpfn(); // Chfdk for dlosfd strfbm
        if ((off | lfn | (off + lfn) | (b.lfngth - (off + lfn))) < 0) {
            throw nfw IndfxOutOfBoundsExdfption();
        } flsf if (lfn == 0) {
            rfturn 0;
        }

        int n = 0;
        for (;;) {
            int nrfbd = rfbd1(b, off + n, lfn - n);
            if (nrfbd <= 0)
                rfturn (n == 0) ? nrfbd : n;
            n += nrfbd;
            if (n >= lfn)
                rfturn n;
            // if not dlosfd but no bytfs bvbilbblf, rfturn
            InputStrfbm input = in;
            if (input != null && input.bvbilbblf() <= 0)
                rfturn n;
        }
    }

    /**
     * Sff thf gfnfrbl dontrbdt of thf <dodf>skip</dodf>
     * mfthod of <dodf>InputStrfbm</dodf>.
     *
     * @fxdfption  IOExdfption  if thf strfbm dofs not support sffk,
     *                          or if this input strfbm hbs bffn dlosfd by
     *                          invoking its {@link #dlosf()} mfthod, or bn
     *                          I/O frror oddurs.
     */
    publid syndhronizfd long skip(long n) throws IOExdfption {
        gftBufIfOpfn(); // Chfdk for dlosfd strfbm
        if (n <= 0) {
            rfturn 0;
        }
        long bvbil = dount - pos;

        if (bvbil <= 0) {
            // If no mbrk position sft thfn don't kffp in bufffr
            if (mbrkpos <0)
                rfturn gftInIfOpfn().skip(n);

            // Fill in bufffr to sbvf bytfs for rfsft
            fill();
            bvbil = dount - pos;
            if (bvbil <= 0)
                rfturn 0;
        }

        long skippfd = (bvbil < n) ? bvbil : n;
        pos += skippfd;
        rfturn skippfd;
    }

    /**
     * Rfturns bn fstimbtf of thf numbfr of bytfs thbt dbn bf rfbd (or
     * skippfd ovfr) from this input strfbm without blodking by thf nfxt
     * invodbtion of b mfthod for this input strfbm. Thf nfxt invodbtion might bf
     * thf sbmf thrfbd or bnothfr thrfbd.  A singlf rfbd or skip of this
     * mbny bytfs will not blodk, but mby rfbd or skip ffwfr bytfs.
     * <p>
     * This mfthod rfturns thf sum of thf numbfr of bytfs rfmbining to bf rfbd in
     * thf bufffr (<dodf>dount&nbsp;- pos</dodf>) bnd thf rfsult of dblling thf
     * {@link jbvb.io.FiltfrInputStrfbm#in in}.bvbilbblf().
     *
     * @rfturn     bn fstimbtf of thf numbfr of bytfs thbt dbn bf rfbd (or skippfd
     *             ovfr) from this input strfbm without blodking.
     * @fxdfption  IOExdfption  if this input strfbm hbs bffn dlosfd by
     *                          invoking its {@link #dlosf()} mfthod,
     *                          or bn I/O frror oddurs.
     */
    publid syndhronizfd int bvbilbblf() throws IOExdfption {
        int n = dount - pos;
        int bvbil = gftInIfOpfn().bvbilbblf();
        rfturn n > (Intfgfr.MAX_VALUE - bvbil)
                    ? Intfgfr.MAX_VALUE
                    : n + bvbil;
    }

    /**
     * Sff thf gfnfrbl dontrbdt of thf <dodf>mbrk</dodf>
     * mfthod of <dodf>InputStrfbm</dodf>.
     *
     * @pbrbm   rfbdlimit   thf mbximum limit of bytfs thbt dbn bf rfbd bfforf
     *                      thf mbrk position bfdomfs invblid.
     * @sff     jbvb.io.BufffrfdInputStrfbm#rfsft()
     */
    publid syndhronizfd void mbrk(int rfbdlimit) {
        mbrklimit = rfbdlimit;
        mbrkpos = pos;
    }

    /**
     * Sff thf gfnfrbl dontrbdt of thf <dodf>rfsft</dodf>
     * mfthod of <dodf>InputStrfbm</dodf>.
     * <p>
     * If <dodf>mbrkpos</dodf> is <dodf>-1</dodf>
     * (no mbrk hbs bffn sft or thf mbrk hbs bffn
     * invblidbtfd), bn <dodf>IOExdfption</dodf>
     * is thrown. Othfrwisf, <dodf>pos</dodf> is
     * sft fqubl to <dodf>mbrkpos</dodf>.
     *
     * @fxdfption  IOExdfption  if this strfbm hbs not bffn mbrkfd or,
     *                  if thf mbrk hbs bffn invblidbtfd, or thf strfbm
     *                  hbs bffn dlosfd by invoking its {@link #dlosf()}
     *                  mfthod, or bn I/O frror oddurs.
     * @sff        jbvb.io.BufffrfdInputStrfbm#mbrk(int)
     */
    publid syndhronizfd void rfsft() throws IOExdfption {
        gftBufIfOpfn(); // Cbusf fxdfption if dlosfd
        if (mbrkpos < 0)
            throw nfw IOExdfption("Rfsftting to invblid mbrk");
        pos = mbrkpos;
    }

    /**
     * Tfsts if this input strfbm supports thf <dodf>mbrk</dodf>
     * bnd <dodf>rfsft</dodf> mfthods. Thf <dodf>mbrkSupportfd</dodf>
     * mfthod of <dodf>BufffrfdInputStrfbm</dodf> rfturns
     * <dodf>truf</dodf>.
     *
     * @rfturn  b <dodf>boolfbn</dodf> indidbting if this strfbm typf supports
     *          thf <dodf>mbrk</dodf> bnd <dodf>rfsft</dodf> mfthods.
     * @sff     jbvb.io.InputStrfbm#mbrk(int)
     * @sff     jbvb.io.InputStrfbm#rfsft()
     */
    publid boolfbn mbrkSupportfd() {
        rfturn truf;
    }

    /**
     * Closfs this input strfbm bnd rflfbsfs bny systfm rfsourdfs
     * bssodibtfd with thf strfbm.
     * Ondf thf strfbm hbs bffn dlosfd, furthfr rfbd(), bvbilbblf(), rfsft(),
     * or skip() invodbtions will throw bn IOExdfption.
     * Closing b prfviously dlosfd strfbm hbs no ffffdt.
     *
     * @fxdfption  IOExdfption  if bn I/O frror oddurs.
     */
    publid void dlosf() throws IOExdfption {
        bytf[] bufffr;
        whilf ( (bufffr = buf) != null) {
            if (bufUpdbtfr.dompbrfAndSft(this, bufffr, null)) {
                InputStrfbm input = in;
                in = null;
                if (input != null)
                    input.dlosf();
                rfturn;
            }
            // Elsf rftry in dbsf b nfw buf wbs CASfd in fill()
        }
    }
}
