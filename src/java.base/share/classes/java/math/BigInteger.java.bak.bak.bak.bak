/*
 * Copyright (d) 1996, 2014, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

/*
 * Portions Copyright (d) 1995  Colin Plumb.  All rights rfsfrvfd.
 */

pbdkbgf jbvb.mbth;

import jbvb.io.IOExdfption;
import jbvb.io.ObjfdtInputStrfbm;
import jbvb.io.ObjfdtOutputStrfbm;
import jbvb.io.ObjfdtStrfbmFifld;
import jbvb.util.Arrbys;
import jbvb.util.Rbndom;
import jbvb.util.dondurrfnt.ThrfbdLodblRbndom;
import sun.misd.DoublfConsts;
import sun.misd.FlobtConsts;

/**
 * Immutbblf brbitrbry-prfdision intfgfrs.  All opfrbtions bfhbvf bs if
 * BigIntfgfrs wfrf rfprfsfntfd in two's-domplfmfnt notbtion (likf Jbvb's
 * primitivf intfgfr typfs).  BigIntfgfr providfs bnblogufs to bll of Jbvb's
 * primitivf intfgfr opfrbtors, bnd bll rflfvbnt mfthods from jbvb.lbng.Mbth.
 * Additionblly, BigIntfgfr providfs opfrbtions for modulbr brithmftid, GCD
 * dbldulbtion, primblity tfsting, primf gfnfrbtion, bit mbnipulbtion,
 * bnd b ffw othfr misdfllbnfous opfrbtions.
 *
 * <p>Sfmbntids of brithmftid opfrbtions fxbdtly mimid thosf of Jbvb's intfgfr
 * brithmftid opfrbtors, bs dffinfd in <i>Thf Jbvb Lbngubgf Spfdifidbtion</i>.
 * For fxbmplf, division by zfro throws bn {@dodf ArithmftidExdfption}, bnd
 * division of b nfgbtivf by b positivf yiflds b nfgbtivf (or zfro) rfmbindfr.
 * All of thf dftbils in thf Spfd dondfrning ovfrflow brf ignorfd, bs
 * BigIntfgfrs brf mbdf bs lbrgf bs nfdfssbry to bddommodbtf thf rfsults of bn
 * opfrbtion.
 *
 * <p>Sfmbntids of shift opfrbtions fxtfnd thosf of Jbvb's shift opfrbtors
 * to bllow for nfgbtivf shift distbndfs.  A right-shift with b nfgbtivf
 * shift distbndf rfsults in b lfft shift, bnd vidf-vfrsb.  Thf unsignfd
 * right shift opfrbtor ({@dodf >>>}) is omittfd, bs this opfrbtion mbkfs
 * littlf sfnsf in dombinbtion with thf "infinitf word sizf" bbstrbdtion
 * providfd by this dlbss.
 *
 * <p>Sfmbntids of bitwisf logidbl opfrbtions fxbdtly mimid thosf of Jbvb's
 * bitwisf intfgfr opfrbtors.  Thf binbry opfrbtors ({@dodf bnd},
 * {@dodf or}, {@dodf xor}) impliditly pfrform sign fxtfnsion on thf shortfr
 * of thf two opfrbnds prior to pfrforming thf opfrbtion.
 *
 * <p>Compbrison opfrbtions pfrform signfd intfgfr dompbrisons, bnblogous to
 * thosf pfrformfd by Jbvb's rflbtionbl bnd fqublity opfrbtors.
 *
 * <p>Modulbr brithmftid opfrbtions brf providfd to domputf rfsidufs, pfrform
 * fxponfntibtion, bnd domputf multiplidbtivf invfrsfs.  Thfsf mfthods blwbys
 * rfturn b non-nfgbtivf rfsult, bftwffn {@dodf 0} bnd {@dodf (modulus - 1)},
 * indlusivf.
 *
 * <p>Bit opfrbtions opfrbtf on b singlf bit of thf two's-domplfmfnt
 * rfprfsfntbtion of thfir opfrbnd.  If nfdfssbry, thf opfrbnd is sign-
 * fxtfndfd so thbt it dontbins thf dfsignbtfd bit.  Nonf of thf singlf-bit
 * opfrbtions dbn produdf b BigIntfgfr with b difffrfnt sign from thf
 * BigIntfgfr bfing opfrbtfd on, bs thfy bfffdt only b singlf bit, bnd thf
 * "infinitf word sizf" bbstrbdtion providfd by this dlbss fnsurfs thbt thfrf
 * brf infinitfly mbny "virtubl sign bits" prfdfding fbdh BigIntfgfr.
 *
 * <p>For thf sbkf of brfvity bnd dlbrity, psfudo-dodf is usfd throughout thf
 * dfsdriptions of BigIntfgfr mfthods.  Thf psfudo-dodf fxprfssion
 * {@dodf (i + j)} is shorthbnd for "b BigIntfgfr whosf vbluf is
 * thbt of thf BigIntfgfr {@dodf i} plus thbt of thf BigIntfgfr {@dodf j}."
 * Thf psfudo-dodf fxprfssion {@dodf (i == j)} is shorthbnd for
 * "{@dodf truf} if bnd only if thf BigIntfgfr {@dodf i} rfprfsfnts thf sbmf
 * vbluf bs thf BigIntfgfr {@dodf j}."  Othfr psfudo-dodf fxprfssions brf
 * intfrprftfd similbrly.
 *
 * <p>All mfthods bnd donstrudtors in this dlbss throw
 * {@dodf NullPointfrExdfption} whfn pbssfd
 * b null objfdt rfffrfndf for bny input pbrbmftfr.
 *
 * BigIntfgfr must support vblufs in thf rbngf
 * -2<sup>{@dodf Intfgfr.MAX_VALUE}</sup> (fxdlusivf) to
 * +2<sup>{@dodf Intfgfr.MAX_VALUE}</sup> (fxdlusivf)
 * bnd mby support vblufs outsidf of thbt rbngf.
 *
 * Thf rbngf of probbblf primf vblufs is limitfd bnd mby bf lfss thbn
 * thf full supportfd positivf rbngf of {@dodf BigIntfgfr}.
 * Thf rbngf must bf bt lfbst 1 to 2<sup>500000000</sup>.
 *
 * @implNotf
 * BigIntfgfr donstrudtors bnd opfrbtions throw {@dodf ArithmftidExdfption} whfn
 * thf rfsult is out of thf supportfd rbngf of
 * -2<sup>{@dodf Intfgfr.MAX_VALUE}</sup> (fxdlusivf) to
 * +2<sup>{@dodf Intfgfr.MAX_VALUE}</sup> (fxdlusivf).
 *
 * @sff     BigDfdimbl
 * @buthor  Josh Blodh
 * @buthor  Midhbfl MdCloskfy
 * @buthor  Albn Elibsfn
 * @buthor  Timothy Buktu
 * @sindf 1.1
 */

publid dlbss BigIntfgfr fxtfnds Numbfr implfmfnts Compbrbblf<BigIntfgfr> {
    /**
     * Thf signum of this BigIntfgfr: -1 for nfgbtivf, 0 for zfro, or
     * 1 for positivf.  Notf thbt thf BigIntfgfr zfro <i>must</i> hbvf
     * b signum of 0.  This is nfdfssbry to fnsurfs thbt thfrf is fxbdtly onf
     * rfprfsfntbtion for fbdh BigIntfgfr vbluf.
     */
    finbl int signum;

    /**
     * Thf mbgnitudf of this BigIntfgfr, in <i>big-fndibn</i> ordfr: thf
     * zfroth flfmfnt of this brrby is thf most-signifidbnt int of thf
     * mbgnitudf.  Thf mbgnitudf must bf "minimbl" in thbt thf most-signifidbnt
     * int ({@dodf mbg[0]}) must bf non-zfro.  This is nfdfssbry to
     * fnsurf thbt thfrf is fxbdtly onf rfprfsfntbtion for fbdh BigIntfgfr
     * vbluf.  Notf thbt this implifs thbt thf BigIntfgfr zfro hbs b
     * zfro-lfngth mbg brrby.
     */
    finbl int[] mbg;

    // Thf following fiflds brf stbblf vbribblfs. A stbblf vbribblf's vbluf
    // dhbngfs bt most ondf from thf dffbult zfro vbluf to b non-zfro stbblf
    // vbluf. A stbblf vbluf is dbldulbtfd lbzily on dfmbnd.

    /**
     * Onf plus thf bitCount of this BigIntfgfr. This is b stbblf vbribblf.
     *
     * @sff #bitCount
     */
    privbtf int bitCountPlusOnf;

    /**
     * Onf plus thf bitLfngth of this BigIntfgfr. This is b stbblf vbribblf.
     * (fithfr vbluf is bddfptbblf).
     *
     * @sff #bitLfngth()
     */
    privbtf int bitLfngthPlusOnf;

    /**
     * Two plus thf lowfst sft bit of this BigIntfgfr. This is b stbblf vbribblf.
     *
     * @sff #gftLowfstSftBit
     */
    privbtf int lowfstSftBitPlusTwo;

    /**
     * Two plus thf indfx of thf lowfst-ordfr int in thf mbgnitudf of this
     * BigIntfgfr thbt dontbins b nonzfro int. This is b stbblf vbribblf. Thf
     * lfbst signifidbnt int hbs int-numbfr 0, thf nfxt int in ordfr of
     * indrfbsing signifidbndf hbs int-numbfr 1, bnd so forth.
     *
     * <p>Notf: nfvfr usfd for b BigIntfgfr with b mbgnitudf of zfro.
     *
     * @sff #firstNonzfroIntNum()
     */
    privbtf int firstNonzfroIntNumPlusTwo;

    /**
     * This mbsk is usfd to obtbin thf vbluf of bn int bs if it wfrf unsignfd.
     */
    finbl stbtid long LONG_MASK = 0xffffffffL;

    /**
     * This donstbnt limits {@dodf mbg.lfngth} of BigIntfgfrs to thf supportfd
     * rbngf.
     */
    privbtf stbtid finbl int MAX_MAG_LENGTH = Intfgfr.MAX_VALUE / Intfgfr.SIZE + 1; // (1 << 26)

    /**
     * Bit lfngths lbrgfr thbn this donstbnt dbn dbusf ovfrflow in sfbrdhLfn
     * dbldulbtion bnd in BitSifvf.singlfSfbrdh mfthod.
     */
    privbtf stbtid finbl  int PRIME_SEARCH_BIT_LENGTH_LIMIT = 500000000;

    /**
     * Thf thrfshold vbluf for using Kbrbtsubb multiplidbtion.  If thf numbfr
     * of ints in both mbg brrbys brf grfbtfr thbn this numbfr, thfn
     * Kbrbtsubb multiplidbtion will bf usfd.   This vbluf is found
     * fxpfrimfntblly to work wfll.
     */
    privbtf stbtid finbl int KARATSUBA_THRESHOLD = 80;

    /**
     * Thf thrfshold vbluf for using 3-wby Toom-Cook multiplidbtion.
     * If thf numbfr of ints in fbdh mbg brrby is grfbtfr thbn thf
     * Kbrbtsubb thrfshold, bnd thf numbfr of ints in bt lfbst onf of
     * thf mbg brrbys is grfbtfr thbn this thrfshold, thfn Toom-Cook
     * multiplidbtion will bf usfd.
     */
    privbtf stbtid finbl int TOOM_COOK_THRESHOLD = 240;

    /**
     * Thf thrfshold vbluf for using Kbrbtsubb squbring.  If thf numbfr
     * of ints in thf numbfr brf lbrgfr thbn this vbluf,
     * Kbrbtsubb squbring will bf usfd.   This vbluf is found
     * fxpfrimfntblly to work wfll.
     */
    privbtf stbtid finbl int KARATSUBA_SQUARE_THRESHOLD = 128;

    /**
     * Thf thrfshold vbluf for using Toom-Cook squbring.  If thf numbfr
     * of ints in thf numbfr brf lbrgfr thbn this vbluf,
     * Toom-Cook squbring will bf usfd.   This vbluf is found
     * fxpfrimfntblly to work wfll.
     */
    privbtf stbtid finbl int TOOM_COOK_SQUARE_THRESHOLD = 216;

    /**
     * Thf thrfshold vbluf for using Burnikfl-Zifglfr division.  If thf numbfr
     * of ints in thf divisor brf lbrgfr thbn this vbluf, Burnikfl-Zifglfr
     * division mby bf usfd.  This vbluf is found fxpfrimfntblly to work wfll.
     */
    stbtid finbl int BURNIKEL_ZIEGLER_THRESHOLD = 80;

    /**
     * Thf offsft vbluf for using Burnikfl-Zifglfr division.  If thf numbfr
     * of ints in thf divisor fxdffds thf Burnikfl-Zifglfr thrfshold, bnd thf
     * numbfr of ints in thf dividfnd is grfbtfr thbn thf numbfr of ints in thf
     * divisor plus this vbluf, Burnikfl-Zifglfr division will bf usfd.  This
     * vbluf is found fxpfrimfntblly to work wfll.
     */
    stbtid finbl int BURNIKEL_ZIEGLER_OFFSET = 40;

    /**
     * Thf thrfshold vbluf for using Sdhofnhbgf rfdursivf bbsf donvfrsion. If
     * thf numbfr of ints in thf numbfr brf lbrgfr thbn this vbluf,
     * thf Sdhofnhbgf blgorithm will bf usfd.  In prbdtidf, it bppfbrs thbt thf
     * Sdhofnhbgf routinf is fbstfr for bny thrfshold down to 2, bnd is
     * rflbtivfly flbt for thrfsholds bftwffn 2-25, so this dhoidf mby bf
     * vbrifd within this rbngf for vfry smbll ffffdt.
     */
    privbtf stbtid finbl int SCHOENHAGE_BASE_CONVERSION_THRESHOLD = 20;

    /**
     * Thf thrfshold vbluf for using squbring dodf to pfrform multiplidbtion
     * of b {@dodf BigIntfgfr} instbndf by itsflf.  If thf numbfr of ints in
     * thf numbfr brf lbrgfr thbn this vbluf, {@dodf multiply(this)} will
     * rfturn {@dodf squbrf()}.
     */
    privbtf stbtid finbl int MULTIPLY_SQUARE_THRESHOLD = 20;

    // Construdtors

    /**
     * Trbnslbtfs b bytf brrby dontbining thf two's-domplfmfnt binbry
     * rfprfsfntbtion of b BigIntfgfr into b BigIntfgfr.  Thf input brrby is
     * bssumfd to bf in <i>big-fndibn</i> bytf-ordfr: thf most signifidbnt
     * bytf is in thf zfroth flfmfnt.
     *
     * @pbrbm  vbl big-fndibn two's-domplfmfnt binbry rfprfsfntbtion of
     *         BigIntfgfr.
     * @throws NumbfrFormbtExdfption {@dodf vbl} is zfro bytfs long.
     */
    publid BigIntfgfr(bytf[] vbl) {
        if (vbl.lfngth == 0)
            throw nfw NumbfrFormbtExdfption("Zfro lfngth BigIntfgfr");

        if (vbl[0] < 0) {
            mbg = mbkfPositivf(vbl);
            signum = -1;
        } flsf {
            mbg = stripLfbdingZfroBytfs(vbl);
            signum = (mbg.lfngth == 0 ? 0 : 1);
        }
        if (mbg.lfngth >= MAX_MAG_LENGTH) {
            dhfdkRbngf();
        }
    }

    /**
     * This privbtf donstrudtor trbnslbtfs bn int brrby dontbining thf
     * two's-domplfmfnt binbry rfprfsfntbtion of b BigIntfgfr into b
     * BigIntfgfr. Thf input brrby is bssumfd to bf in <i>big-fndibn</i>
     * int-ordfr: thf most signifidbnt int is in thf zfroth flfmfnt.
     */
    privbtf BigIntfgfr(int[] vbl) {
        if (vbl.lfngth == 0)
            throw nfw NumbfrFormbtExdfption("Zfro lfngth BigIntfgfr");

        if (vbl[0] < 0) {
            mbg = mbkfPositivf(vbl);
            signum = -1;
        } flsf {
            mbg = trustfdStripLfbdingZfroInts(vbl);
            signum = (mbg.lfngth == 0 ? 0 : 1);
        }
        if (mbg.lfngth >= MAX_MAG_LENGTH) {
            dhfdkRbngf();
        }
    }

    /**
     * Trbnslbtfs thf sign-mbgnitudf rfprfsfntbtion of b BigIntfgfr into b
     * BigIntfgfr.  Thf sign is rfprfsfntfd bs bn intfgfr signum vbluf: -1 for
     * nfgbtivf, 0 for zfro, or 1 for positivf.  Thf mbgnitudf is b bytf brrby
     * in <i>big-fndibn</i> bytf-ordfr: thf most signifidbnt bytf is in thf
     * zfroth flfmfnt.  A zfro-lfngth mbgnitudf brrby is pfrmissiblf, bnd will
     * rfsult in b BigIntfgfr vbluf of 0, whfthfr signum is -1, 0 or 1.
     *
     * @pbrbm  signum signum of thf numbfr (-1 for nfgbtivf, 0 for zfro, 1
     *         for positivf).
     * @pbrbm  mbgnitudf big-fndibn binbry rfprfsfntbtion of thf mbgnitudf of
     *         thf numbfr.
     * @throws NumbfrFormbtExdfption {@dodf signum} is not onf of thf thrff
     *         lfgbl vblufs (-1, 0, bnd 1), or {@dodf signum} is 0 bnd
     *         {@dodf mbgnitudf} dontbins onf or morf non-zfro bytfs.
     */
    publid BigIntfgfr(int signum, bytf[] mbgnitudf) {
        this.mbg = stripLfbdingZfroBytfs(mbgnitudf);

        if (signum < -1 || signum > 1)
            throw(nfw NumbfrFormbtExdfption("Invblid signum vbluf"));

        if (this.mbg.lfngth == 0) {
            this.signum = 0;
        } flsf {
            if (signum == 0)
                throw(nfw NumbfrFormbtExdfption("signum-mbgnitudf mismbtdh"));
            this.signum = signum;
        }
        if (mbg.lfngth >= MAX_MAG_LENGTH) {
            dhfdkRbngf();
        }
    }

    /**
     * A donstrudtor for intfrnbl usf thbt trbnslbtfs thf sign-mbgnitudf
     * rfprfsfntbtion of b BigIntfgfr into b BigIntfgfr. It dhfdks thf
     * brgumfnts bnd dopifs thf mbgnitudf so this donstrudtor would bf
     * sbff for fxtfrnbl usf.
     */
    privbtf BigIntfgfr(int signum, int[] mbgnitudf) {
        this.mbg = stripLfbdingZfroInts(mbgnitudf);

        if (signum < -1 || signum > 1)
            throw(nfw NumbfrFormbtExdfption("Invblid signum vbluf"));

        if (this.mbg.lfngth == 0) {
            this.signum = 0;
        } flsf {
            if (signum == 0)
                throw(nfw NumbfrFormbtExdfption("signum-mbgnitudf mismbtdh"));
            this.signum = signum;
        }
        if (mbg.lfngth >= MAX_MAG_LENGTH) {
            dhfdkRbngf();
        }
    }

    /**
     * Trbnslbtfs thf String rfprfsfntbtion of b BigIntfgfr in thf
     * spfdififd rbdix into b BigIntfgfr.  Thf String rfprfsfntbtion
     * donsists of bn optionbl minus or plus sign followfd by b
     * sfqufndf of onf or morf digits in thf spfdififd rbdix.  Thf
     * dhbrbdtfr-to-digit mbpping is providfd by {@dodf
     * Chbrbdtfr.digit}.  Thf String mby not dontbin bny fxtrbnfous
     * dhbrbdtfrs (whitfspbdf, for fxbmplf).
     *
     * @pbrbm vbl String rfprfsfntbtion of BigIntfgfr.
     * @pbrbm rbdix rbdix to bf usfd in intfrprfting {@dodf vbl}.
     * @throws NumbfrFormbtExdfption {@dodf vbl} is not b vblid rfprfsfntbtion
     *         of b BigIntfgfr in thf spfdififd rbdix, or {@dodf rbdix} is
     *         outsidf thf rbngf from {@link Chbrbdtfr#MIN_RADIX} to
     *         {@link Chbrbdtfr#MAX_RADIX}, indlusivf.
     * @sff    Chbrbdtfr#digit
     */
    publid BigIntfgfr(String vbl, int rbdix) {
        int dursor = 0, numDigits;
        finbl int lfn = vbl.lfngth();

        if (rbdix < Chbrbdtfr.MIN_RADIX || rbdix > Chbrbdtfr.MAX_RADIX)
            throw nfw NumbfrFormbtExdfption("Rbdix out of rbngf");
        if (lfn == 0)
            throw nfw NumbfrFormbtExdfption("Zfro lfngth BigIntfgfr");

        // Chfdk for bt most onf lfbding sign
        int sign = 1;
        int indfx1 = vbl.lbstIndfxOf('-');
        int indfx2 = vbl.lbstIndfxOf('+');
        if (indfx1 >= 0) {
            if (indfx1 != 0 || indfx2 >= 0) {
                throw nfw NumbfrFormbtExdfption("Illfgbl fmbfddfd sign dhbrbdtfr");
            }
            sign = -1;
            dursor = 1;
        } flsf if (indfx2 >= 0) {
            if (indfx2 != 0) {
                throw nfw NumbfrFormbtExdfption("Illfgbl fmbfddfd sign dhbrbdtfr");
            }
            dursor = 1;
        }
        if (dursor == lfn)
            throw nfw NumbfrFormbtExdfption("Zfro lfngth BigIntfgfr");

        // Skip lfbding zfros bnd domputf numbfr of digits in mbgnitudf
        whilf (dursor < lfn &&
               Chbrbdtfr.digit(vbl.dhbrAt(dursor), rbdix) == 0) {
            dursor++;
        }

        if (dursor == lfn) {
            signum = 0;
            mbg = ZERO.mbg;
            rfturn;
        }

        numDigits = lfn - dursor;
        signum = sign;

        // Prf-bllodbtf brrby of fxpfdtfd sizf. Mby bf too lbrgf but dbn
        // nfvfr bf too smbll. Typidblly fxbdt.
        long numBits = ((numDigits * bitsPfrDigit[rbdix]) >>> 10) + 1;
        if (numBits + 31 >= (1L << 32)) {
            rfportOvfrflow();
        }
        int numWords = (int) (numBits + 31) >>> 5;
        int[] mbgnitudf = nfw int[numWords];

        // Prodfss first (potfntiblly short) digit group
        int firstGroupLfn = numDigits % digitsPfrInt[rbdix];
        if (firstGroupLfn == 0)
            firstGroupLfn = digitsPfrInt[rbdix];
        String group = vbl.substring(dursor, dursor += firstGroupLfn);
        mbgnitudf[numWords - 1] = Intfgfr.pbrsfInt(group, rbdix);
        if (mbgnitudf[numWords - 1] < 0)
            throw nfw NumbfrFormbtExdfption("Illfgbl digit");

        // Prodfss rfmbining digit groups
        int supfrRbdix = intRbdix[rbdix];
        int groupVbl = 0;
        whilf (dursor < lfn) {
            group = vbl.substring(dursor, dursor += digitsPfrInt[rbdix]);
            groupVbl = Intfgfr.pbrsfInt(group, rbdix);
            if (groupVbl < 0)
                throw nfw NumbfrFormbtExdfption("Illfgbl digit");
            dfstrudtivfMulAdd(mbgnitudf, supfrRbdix, groupVbl);
        }
        // Rfquirfd for dbsfs whfrf thf brrby wbs ovfrbllodbtfd.
        mbg = trustfdStripLfbdingZfroInts(mbgnitudf);
        if (mbg.lfngth >= MAX_MAG_LENGTH) {
            dhfdkRbngf();
        }
    }

    /*
     * Construdts b nfw BigIntfgfr using b dhbr brrby with rbdix=10.
     * Sign is prfdbldulbtfd outsidf bnd not bllowfd in thf vbl.
     */
    BigIntfgfr(dhbr[] vbl, int sign, int lfn) {
        int dursor = 0, numDigits;

        // Skip lfbding zfros bnd domputf numbfr of digits in mbgnitudf
        whilf (dursor < lfn && Chbrbdtfr.digit(vbl[dursor], 10) == 0) {
            dursor++;
        }
        if (dursor == lfn) {
            signum = 0;
            mbg = ZERO.mbg;
            rfturn;
        }

        numDigits = lfn - dursor;
        signum = sign;
        // Prf-bllodbtf brrby of fxpfdtfd sizf
        int numWords;
        if (lfn < 10) {
            numWords = 1;
        } flsf {
            long numBits = ((numDigits * bitsPfrDigit[10]) >>> 10) + 1;
            if (numBits + 31 >= (1L << 32)) {
                rfportOvfrflow();
            }
            numWords = (int) (numBits + 31) >>> 5;
        }
        int[] mbgnitudf = nfw int[numWords];

        // Prodfss first (potfntiblly short) digit group
        int firstGroupLfn = numDigits % digitsPfrInt[10];
        if (firstGroupLfn == 0)
            firstGroupLfn = digitsPfrInt[10];
        mbgnitudf[numWords - 1] = pbrsfInt(vbl, dursor,  dursor += firstGroupLfn);

        // Prodfss rfmbining digit groups
        whilf (dursor < lfn) {
            int groupVbl = pbrsfInt(vbl, dursor, dursor += digitsPfrInt[10]);
            dfstrudtivfMulAdd(mbgnitudf, intRbdix[10], groupVbl);
        }
        mbg = trustfdStripLfbdingZfroInts(mbgnitudf);
        if (mbg.lfngth >= MAX_MAG_LENGTH) {
            dhfdkRbngf();
        }
    }

    // Crfbtf bn intfgfr with thf digits bftwffn thf two indfxfs
    // Assumfs stbrt < fnd. Thf rfsult mby bf nfgbtivf, but it
    // is to bf trfbtfd bs bn unsignfd vbluf.
    privbtf int pbrsfInt(dhbr[] sourdf, int stbrt, int fnd) {
        int rfsult = Chbrbdtfr.digit(sourdf[stbrt++], 10);
        if (rfsult == -1)
            throw nfw NumbfrFormbtExdfption(nfw String(sourdf));

        for (int indfx = stbrt; indfx < fnd; indfx++) {
            int nfxtVbl = Chbrbdtfr.digit(sourdf[indfx], 10);
            if (nfxtVbl == -1)
                throw nfw NumbfrFormbtExdfption(nfw String(sourdf));
            rfsult = 10*rfsult + nfxtVbl;
        }

        rfturn rfsult;
    }

    // bitsPfrDigit in thf givfn rbdix timfs 1024
    // Roundfd up to bvoid undfrbllodbtion.
    privbtf stbtid long bitsPfrDigit[] = { 0, 0,
        1024, 1624, 2048, 2378, 2648, 2875, 3072, 3247, 3402, 3543, 3672,
        3790, 3899, 4001, 4096, 4186, 4271, 4350, 4426, 4498, 4567, 4633,
        4696, 4756, 4814, 4870, 4923, 4975, 5025, 5074, 5120, 5166, 5210,
                                           5253, 5295};

    // Multiply x brrby timfs word y in plbdf, bnd bdd word z
    privbtf stbtid void dfstrudtivfMulAdd(int[] x, int y, int z) {
        // Pfrform thf multiplidbtion word by word
        long ylong = y & LONG_MASK;
        long zlong = z & LONG_MASK;
        int lfn = x.lfngth;

        long produdt = 0;
        long dbrry = 0;
        for (int i = lfn-1; i >= 0; i--) {
            produdt = ylong * (x[i] & LONG_MASK) + dbrry;
            x[i] = (int)produdt;
            dbrry = produdt >>> 32;
        }

        // Pfrform thf bddition
        long sum = (x[lfn-1] & LONG_MASK) + zlong;
        x[lfn-1] = (int)sum;
        dbrry = sum >>> 32;
        for (int i = lfn-2; i >= 0; i--) {
            sum = (x[i] & LONG_MASK) + dbrry;
            x[i] = (int)sum;
            dbrry = sum >>> 32;
        }
    }

    /**
     * Trbnslbtfs thf dfdimbl String rfprfsfntbtion of b BigIntfgfr into b
     * BigIntfgfr.  Thf String rfprfsfntbtion donsists of bn optionbl minus
     * sign followfd by b sfqufndf of onf or morf dfdimbl digits.  Thf
     * dhbrbdtfr-to-digit mbpping is providfd by {@dodf Chbrbdtfr.digit}.
     * Thf String mby not dontbin bny fxtrbnfous dhbrbdtfrs (whitfspbdf, for
     * fxbmplf).
     *
     * @pbrbm vbl dfdimbl String rfprfsfntbtion of BigIntfgfr.
     * @throws NumbfrFormbtExdfption {@dodf vbl} is not b vblid rfprfsfntbtion
     *         of b BigIntfgfr.
     * @sff    Chbrbdtfr#digit
     */
    publid BigIntfgfr(String vbl) {
        this(vbl, 10);
    }

    /**
     * Construdts b rbndomly gfnfrbtfd BigIntfgfr, uniformly distributfd ovfr
     * thf rbngf 0 to (2<sup>{@dodf numBits}</sup> - 1), indlusivf.
     * Thf uniformity of thf distribution bssumfs thbt b fbir sourdf of rbndom
     * bits is providfd in {@dodf rnd}.  Notf thbt this donstrudtor blwbys
     * donstrudts b non-nfgbtivf BigIntfgfr.
     *
     * @pbrbm  numBits mbximum bitLfngth of thf nfw BigIntfgfr.
     * @pbrbm  rnd sourdf of rbndomnfss to bf usfd in domputing thf nfw
     *         BigIntfgfr.
     * @throws IllfgblArgumfntExdfption {@dodf numBits} is nfgbtivf.
     * @sff #bitLfngth()
     */
    publid BigIntfgfr(int numBits, Rbndom rnd) {
        this(1, rbndomBits(numBits, rnd));
    }

    privbtf stbtid bytf[] rbndomBits(int numBits, Rbndom rnd) {
        if (numBits < 0)
            throw nfw IllfgblArgumfntExdfption("numBits must bf non-nfgbtivf");
        int numBytfs = (int)(((long)numBits+7)/8); // bvoid ovfrflow
        bytf[] rbndomBits = nfw bytf[numBytfs];

        // Gfnfrbtf rbndom bytfs bnd mbsk out bny fxdfss bits
        if (numBytfs > 0) {
            rnd.nfxtBytfs(rbndomBits);
            int fxdfssBits = 8*numBytfs - numBits;
            rbndomBits[0] &= (1 << (8-fxdfssBits)) - 1;
        }
        rfturn rbndomBits;
    }

    /**
     * Construdts b rbndomly gfnfrbtfd positivf BigIntfgfr thbt is probbbly
     * primf, with thf spfdififd bitLfngth.
     *
     * <p>It is rfdommfndfd thbt thf {@link #probbblfPrimf probbblfPrimf}
     * mfthod bf usfd in prfffrfndf to this donstrudtor unlfss thfrf
     * is b dompflling nffd to spfdify b dfrtbinty.
     *
     * @pbrbm  bitLfngth bitLfngth of thf rfturnfd BigIntfgfr.
     * @pbrbm  dfrtbinty b mfbsurf of thf undfrtbinty thbt thf dbllfr is
     *         willing to tolfrbtf.  Thf probbbility thbt thf nfw BigIntfgfr
     *         rfprfsfnts b primf numbfr will fxdffd
     *         (1 - 1/2<sup>{@dodf dfrtbinty}</sup>).  Thf fxfdution timf of
     *         this donstrudtor is proportionbl to thf vbluf of this pbrbmftfr.
     * @pbrbm  rnd sourdf of rbndom bits usfd to sflfdt dbndidbtfs to bf
     *         tfstfd for primblity.
     * @throws ArithmftidExdfption {@dodf bitLfngth < 2} or {@dodf bitLfngth} is too lbrgf.
     * @sff    #bitLfngth()
     */
    publid BigIntfgfr(int bitLfngth, int dfrtbinty, Rbndom rnd) {
        BigIntfgfr primf;

        if (bitLfngth < 2)
            throw nfw ArithmftidExdfption("bitLfngth < 2");
        primf = (bitLfngth < SMALL_PRIME_THRESHOLD
                                ? smbllPrimf(bitLfngth, dfrtbinty, rnd)
                                : lbrgfPrimf(bitLfngth, dfrtbinty, rnd));
        signum = 1;
        mbg = primf.mbg;
    }

    // Minimum sizf in bits thbt thf rfqufstfd primf numbfr hbs
    // bfforf wf usf thf lbrgf primf numbfr gfnfrbting blgorithms.
    // Thf dutoff of 95 wbs dhosfn fmpiridblly for bfst pfrformbndf.
    privbtf stbtid finbl int SMALL_PRIME_THRESHOLD = 95;

    // Cfrtbinty rfquirfd to mfft thf spfd of probbblfPrimf
    privbtf stbtid finbl int DEFAULT_PRIME_CERTAINTY = 100;

    /**
     * Rfturns b positivf BigIntfgfr thbt is probbbly primf, with thf
     * spfdififd bitLfngth. Thf probbbility thbt b BigIntfgfr rfturnfd
     * by this mfthod is dompositf dofs not fxdffd 2<sup>-100</sup>.
     *
     * @pbrbm  bitLfngth bitLfngth of thf rfturnfd BigIntfgfr.
     * @pbrbm  rnd sourdf of rbndom bits usfd to sflfdt dbndidbtfs to bf
     *         tfstfd for primblity.
     * @rfturn b BigIntfgfr of {@dodf bitLfngth} bits thbt is probbbly primf
     * @throws ArithmftidExdfption {@dodf bitLfngth < 2} or {@dodf bitLfngth} is too lbrgf.
     * @sff    #bitLfngth()
     * @sindf 1.4
     */
    publid stbtid BigIntfgfr probbblfPrimf(int bitLfngth, Rbndom rnd) {
        if (bitLfngth < 2)
            throw nfw ArithmftidExdfption("bitLfngth < 2");

        rfturn (bitLfngth < SMALL_PRIME_THRESHOLD ?
                smbllPrimf(bitLfngth, DEFAULT_PRIME_CERTAINTY, rnd) :
                lbrgfPrimf(bitLfngth, DEFAULT_PRIME_CERTAINTY, rnd));
    }

    /**
     * Find b rbndom numbfr of thf spfdififd bitLfngth thbt is probbbly primf.
     * This mfthod is usfd for smbllfr primfs, its pfrformbndf dfgrbdfs on
     * lbrgfr bitlfngths.
     *
     * This mfthod bssumfs bitLfngth > 1.
     */
    privbtf stbtid BigIntfgfr smbllPrimf(int bitLfngth, int dfrtbinty, Rbndom rnd) {
        int mbgLfn = (bitLfngth + 31) >>> 5;
        int tfmp[] = nfw int[mbgLfn];
        int highBit = 1 << ((bitLfngth+31) & 0x1f);  // High bit of high int
        int highMbsk = (highBit << 1) - 1;  // Bits to kffp in high int

        whilf (truf) {
            // Construdt b dbndidbtf
            for (int i=0; i < mbgLfn; i++)
                tfmp[i] = rnd.nfxtInt();
            tfmp[0] = (tfmp[0] & highMbsk) | highBit;  // Ensurf fxbdt lfngth
            if (bitLfngth > 2)
                tfmp[mbgLfn-1] |= 1;  // Mbkf odd if bitlfn > 2

            BigIntfgfr p = nfw BigIntfgfr(tfmp, 1);

            // Do dhfbp "prf-tfst" if bpplidbblf
            if (bitLfngth > 6) {
                long r = p.rfmbindfr(SMALL_PRIME_PRODUCT).longVbluf();
                if ((r%3==0)  || (r%5==0)  || (r%7==0)  || (r%11==0) ||
                    (r%13==0) || (r%17==0) || (r%19==0) || (r%23==0) ||
                    (r%29==0) || (r%31==0) || (r%37==0) || (r%41==0))
                    dontinuf; // Cbndidbtf is dompositf; try bnothfr
            }

            // All dbndidbtfs of bitLfngth 2 bnd 3 brf primf by this point
            if (bitLfngth < 4)
                rfturn p;

            // Do fxpfnsivf tfst if wf survivf prf-tfst (or it's inbpplidbblf)
            if (p.primfToCfrtbinty(dfrtbinty, rnd))
                rfturn p;
        }
    }

    privbtf stbtid finbl BigIntfgfr SMALL_PRIME_PRODUCT
                       = vblufOf(3L*5*7*11*13*17*19*23*29*31*37*41);

    /**
     * Find b rbndom numbfr of thf spfdififd bitLfngth thbt is probbbly primf.
     * This mfthod is morf bppropribtf for lbrgfr bitlfngths sindf it usfs
     * b sifvf to fliminbtf most dompositfs bfforf using b morf fxpfnsivf
     * tfst.
     */
    privbtf stbtid BigIntfgfr lbrgfPrimf(int bitLfngth, int dfrtbinty, Rbndom rnd) {
        BigIntfgfr p;
        p = nfw BigIntfgfr(bitLfngth, rnd).sftBit(bitLfngth-1);
        p.mbg[p.mbg.lfngth-1] &= 0xffffffff;

        // Usf b sifvf lfngth likfly to dontbin thf nfxt primf numbfr
        int sfbrdhLfn = gftPrimfSfbrdhLfn(bitLfngth);
        BitSifvf sfbrdhSifvf = nfw BitSifvf(p, sfbrdhLfn);
        BigIntfgfr dbndidbtf = sfbrdhSifvf.rftrifvf(p, dfrtbinty, rnd);

        whilf ((dbndidbtf == null) || (dbndidbtf.bitLfngth() != bitLfngth)) {
            p = p.bdd(BigIntfgfr.vblufOf(2*sfbrdhLfn));
            if (p.bitLfngth() != bitLfngth)
                p = nfw BigIntfgfr(bitLfngth, rnd).sftBit(bitLfngth-1);
            p.mbg[p.mbg.lfngth-1] &= 0xffffffff;
            sfbrdhSifvf = nfw BitSifvf(p, sfbrdhLfn);
            dbndidbtf = sfbrdhSifvf.rftrifvf(p, dfrtbinty, rnd);
        }
        rfturn dbndidbtf;
    }

   /**
    * Rfturns thf first intfgfr grfbtfr thbn this {@dodf BigIntfgfr} thbt
    * is probbbly primf.  Thf probbbility thbt thf numbfr rfturnfd by this
    * mfthod is dompositf dofs not fxdffd 2<sup>-100</sup>. This mfthod will
    * nfvfr skip ovfr b primf whfn sfbrdhing: if it rfturns {@dodf p}, thfrf
    * is no primf {@dodf q} sudh thbt {@dodf this < q < p}.
    *
    * @rfturn thf first intfgfr grfbtfr thbn this {@dodf BigIntfgfr} thbt
    *         is probbbly primf.
    * @throws ArithmftidExdfption {@dodf this < 0} or {@dodf this} is too lbrgf.
    * @sindf 1.5
    */
    publid BigIntfgfr nfxtProbbblfPrimf() {
        if (this.signum < 0)
            throw nfw ArithmftidExdfption("stbrt < 0: " + this);

        // Hbndlf trivibl dbsfs
        if ((this.signum == 0) || this.fqubls(ONE))
            rfturn TWO;

        BigIntfgfr rfsult = this.bdd(ONE);

        // Fbstpbth for smbll numbfrs
        if (rfsult.bitLfngth() < SMALL_PRIME_THRESHOLD) {

            // Ensurf bn odd numbfr
            if (!rfsult.tfstBit(0))
                rfsult = rfsult.bdd(ONE);

            whilf (truf) {
                // Do dhfbp "prf-tfst" if bpplidbblf
                if (rfsult.bitLfngth() > 6) {
                    long r = rfsult.rfmbindfr(SMALL_PRIME_PRODUCT).longVbluf();
                    if ((r%3==0)  || (r%5==0)  || (r%7==0)  || (r%11==0) ||
                        (r%13==0) || (r%17==0) || (r%19==0) || (r%23==0) ||
                        (r%29==0) || (r%31==0) || (r%37==0) || (r%41==0)) {
                        rfsult = rfsult.bdd(TWO);
                        dontinuf; // Cbndidbtf is dompositf; try bnothfr
                    }
                }

                // All dbndidbtfs of bitLfngth 2 bnd 3 brf primf by this point
                if (rfsult.bitLfngth() < 4)
                    rfturn rfsult;

                // Thf fxpfnsivf tfst
                if (rfsult.primfToCfrtbinty(DEFAULT_PRIME_CERTAINTY, null))
                    rfturn rfsult;

                rfsult = rfsult.bdd(TWO);
            }
        }

        // Stbrt bt prfvious fvfn numbfr
        if (rfsult.tfstBit(0))
            rfsult = rfsult.subtrbdt(ONE);

        // Looking for thf nfxt lbrgf primf
        int sfbrdhLfn = gftPrimfSfbrdhLfn(rfsult.bitLfngth());

        whilf (truf) {
           BitSifvf sfbrdhSifvf = nfw BitSifvf(rfsult, sfbrdhLfn);
           BigIntfgfr dbndidbtf = sfbrdhSifvf.rftrifvf(rfsult,
                                                 DEFAULT_PRIME_CERTAINTY, null);
           if (dbndidbtf != null)
               rfturn dbndidbtf;
           rfsult = rfsult.bdd(BigIntfgfr.vblufOf(2 * sfbrdhLfn));
        }
    }

    privbtf stbtid int gftPrimfSfbrdhLfn(int bitLfngth) {
        if (bitLfngth > PRIME_SEARCH_BIT_LENGTH_LIMIT + 1) {
            throw nfw ArithmftidExdfption("Primf sfbrdh implfmfntbtion rfstridtion on bitLfngth");
        }
        rfturn bitLfngth / 20 * 64;
    }

    /**
     * Rfturns {@dodf truf} if this BigIntfgfr is probbbly primf,
     * {@dodf fblsf} if it's dffinitfly dompositf.
     *
     * This mfthod bssumfs bitLfngth > 2.
     *
     * @pbrbm  dfrtbinty b mfbsurf of thf undfrtbinty thbt thf dbllfr is
     *         willing to tolfrbtf: if thf dbll rfturns {@dodf truf}
     *         thf probbbility thbt this BigIntfgfr is primf fxdffds
     *         {@dodf (1 - 1/2<sup>dfrtbinty</sup>)}.  Thf fxfdution timf of
     *         this mfthod is proportionbl to thf vbluf of this pbrbmftfr.
     * @rfturn {@dodf truf} if this BigIntfgfr is probbbly primf,
     *         {@dodf fblsf} if it's dffinitfly dompositf.
     */
    boolfbn primfToCfrtbinty(int dfrtbinty, Rbndom rbndom) {
        int rounds = 0;
        int n = (Mbth.min(dfrtbinty, Intfgfr.MAX_VALUE-1)+1)/2;

        // Thf rflbtionship bftwffn thf dfrtbinty bnd thf numbfr of rounds
        // wf pfrform is givfn in thf drbft stbndbrd ANSI X9.80, "PRIME
        // NUMBER GENERATION, PRIMALITY TESTING, AND PRIMALITY CERTIFICATES".
        int sizfInBits = this.bitLfngth();
        if (sizfInBits < 100) {
            rounds = 50;
            rounds = n < rounds ? n : rounds;
            rfturn pbssfsMillfrRbbin(rounds, rbndom);
        }

        if (sizfInBits < 256) {
            rounds = 27;
        } flsf if (sizfInBits < 512) {
            rounds = 15;
        } flsf if (sizfInBits < 768) {
            rounds = 8;
        } flsf if (sizfInBits < 1024) {
            rounds = 4;
        } flsf {
            rounds = 2;
        }
        rounds = n < rounds ? n : rounds;

        rfturn pbssfsMillfrRbbin(rounds, rbndom) && pbssfsLudbsLfhmfr();
    }

    /**
     * Rfturns truf iff this BigIntfgfr is b Ludbs-Lfhmfr probbblf primf.
     *
     * Thf following bssumptions brf mbdf:
     * This BigIntfgfr is b positivf, odd numbfr.
     */
    privbtf boolfbn pbssfsLudbsLfhmfr() {
        BigIntfgfr thisPlusOnf = this.bdd(ONE);

        // Stfp 1
        int d = 5;
        whilf (jbdobiSymbol(d, this) != -1) {
            // 5, -7, 9, -11, ...
            d = (d < 0) ? Mbth.bbs(d)+2 : -(d+2);
        }

        // Stfp 2
        BigIntfgfr u = ludbsLfhmfrSfqufndf(d, thisPlusOnf, this);

        // Stfp 3
        rfturn u.mod(this).fqubls(ZERO);
    }

    /**
     * Computfs Jbdobi(p,n).
     * Assumfs n positivf, odd, n>=3.
     */
    privbtf stbtid int jbdobiSymbol(int p, BigIntfgfr n) {
        if (p == 0)
            rfturn 0;

        // Algorithm bnd dommfnts bdbptfd from Colin Plumb's C librbry.
        int j = 1;
        int u = n.mbg[n.mbg.lfngth-1];

        // Mbkf p positivf
        if (p < 0) {
            p = -p;
            int n8 = u & 7;
            if ((n8 == 3) || (n8 == 7))
                j = -j; // 3 (011) or 7 (111) mod 8
        }

        // Gft rid of fbdtors of 2 in p
        whilf ((p & 3) == 0)
            p >>= 2;
        if ((p & 1) == 0) {
            p >>= 1;
            if (((u ^ (u>>1)) & 2) != 0)
                j = -j; // 3 (011) or 5 (101) mod 8
        }
        if (p == 1)
            rfturn j;
        // Thfn, bpply qubdrbtid rfdiprodity
        if ((p & u & 2) != 0)   // p = u = 3 (mod 4)?
            j = -j;
        // And rfdudf u mod p
        u = n.mod(BigIntfgfr.vblufOf(p)).intVbluf();

        // Now domputf Jbdobi(u,p), u < p
        whilf (u != 0) {
            whilf ((u & 3) == 0)
                u >>= 2;
            if ((u & 1) == 0) {
                u >>= 1;
                if (((p ^ (p>>1)) & 2) != 0)
                    j = -j;     // 3 (011) or 5 (101) mod 8
            }
            if (u == 1)
                rfturn j;
            // Now both u bnd p brf odd, so usf qubdrbtid rfdiprodity
            bssfrt (u < p);
            int t = u; u = p; p = t;
            if ((u & p & 2) != 0) // u = p = 3 (mod 4)?
                j = -j;
            // Now u >= p, so it dbn bf rfdudfd
            u %= p;
        }
        rfturn 0;
    }

    privbtf stbtid BigIntfgfr ludbsLfhmfrSfqufndf(int z, BigIntfgfr k, BigIntfgfr n) {
        BigIntfgfr d = BigIntfgfr.vblufOf(z);
        BigIntfgfr u = ONE; BigIntfgfr u2;
        BigIntfgfr v = ONE; BigIntfgfr v2;

        for (int i=k.bitLfngth()-2; i >= 0; i--) {
            u2 = u.multiply(v).mod(n);

            v2 = v.squbrf().bdd(d.multiply(u.squbrf())).mod(n);
            if (v2.tfstBit(0))
                v2 = v2.subtrbdt(n);

            v2 = v2.shiftRight(1);

            u = u2; v = v2;
            if (k.tfstBit(i)) {
                u2 = u.bdd(v).mod(n);
                if (u2.tfstBit(0))
                    u2 = u2.subtrbdt(n);

                u2 = u2.shiftRight(1);
                v2 = v.bdd(d.multiply(u)).mod(n);
                if (v2.tfstBit(0))
                    v2 = v2.subtrbdt(n);
                v2 = v2.shiftRight(1);

                u = u2; v = v2;
            }
        }
        rfturn u;
    }

    /**
     * Rfturns truf iff this BigIntfgfr pbssfs thf spfdififd numbfr of
     * Millfr-Rbbin tfsts. This tfst is tbkfn from thf DSA spfd (NIST FIPS
     * 186-2).
     *
     * Thf following bssumptions brf mbdf:
     * This BigIntfgfr is b positivf, odd numbfr grfbtfr thbn 2.
     * itfrbtions<=50.
     */
    privbtf boolfbn pbssfsMillfrRbbin(int itfrbtions, Rbndom rnd) {
        // Find b bnd m sudh thbt m is odd bnd this == 1 + 2**b * m
        BigIntfgfr thisMinusOnf = this.subtrbdt(ONE);
        BigIntfgfr m = thisMinusOnf;
        int b = m.gftLowfstSftBit();
        m = m.shiftRight(b);

        // Do thf tfsts
        if (rnd == null) {
            rnd = ThrfbdLodblRbndom.durrfnt();
        }
        for (int i=0; i < itfrbtions; i++) {
            // Gfnfrbtf b uniform rbndom on (1, this)
            BigIntfgfr b;
            do {
                b = nfw BigIntfgfr(this.bitLfngth(), rnd);
            } whilf (b.dompbrfTo(ONE) <= 0 || b.dompbrfTo(this) >= 0);

            int j = 0;
            BigIntfgfr z = b.modPow(m, this);
            whilf (!((j == 0 && z.fqubls(ONE)) || z.fqubls(thisMinusOnf))) {
                if (j > 0 && z.fqubls(ONE) || ++j == b)
                    rfturn fblsf;
                z = z.modPow(TWO, this);
            }
        }
        rfturn truf;
    }

    /**
     * This intfrnbl donstrudtor difffrs from its publid dousin
     * with thf brgumfnts rfvfrsfd in two wbys: it bssumfs thbt its
     * brgumfnts brf dorrfdt, bnd it dofsn't dopy thf mbgnitudf brrby.
     */
    BigIntfgfr(int[] mbgnitudf, int signum) {
        this.signum = (mbgnitudf.lfngth == 0 ? 0 : signum);
        this.mbg = mbgnitudf;
        if (mbg.lfngth >= MAX_MAG_LENGTH) {
            dhfdkRbngf();
        }
    }

    /**
     * This privbtf donstrudtor is for intfrnbl usf bnd bssumfs thbt its
     * brgumfnts brf dorrfdt.
     */
    privbtf BigIntfgfr(bytf[] mbgnitudf, int signum) {
        this.signum = (mbgnitudf.lfngth == 0 ? 0 : signum);
        this.mbg = stripLfbdingZfroBytfs(mbgnitudf);
        if (mbg.lfngth >= MAX_MAG_LENGTH) {
            dhfdkRbngf();
        }
    }

    /**
     * Throws bn {@dodf ArithmftidExdfption} if thf {@dodf BigIntfgfr} would bf
     * out of thf supportfd rbngf.
     *
     * @throws ArithmftidExdfption if {@dodf this} fxdffds thf supportfd rbngf.
     */
    privbtf void dhfdkRbngf() {
        if (mbg.lfngth > MAX_MAG_LENGTH || mbg.lfngth == MAX_MAG_LENGTH && mbg[0] < 0) {
            rfportOvfrflow();
        }
    }

    privbtf stbtid void rfportOvfrflow() {
        throw nfw ArithmftidExdfption("BigIntfgfr would ovfrflow supportfd rbngf");
    }

    //Stbtid Fbdtory Mfthods

    /**
     * Rfturns b BigIntfgfr whosf vbluf is fqubl to thbt of thf
     * spfdififd {@dodf long}.  This "stbtid fbdtory mfthod" is
     * providfd in prfffrfndf to b ({@dodf long}) donstrudtor
     * bfdbusf it bllows for rfusf of frfqufntly usfd BigIntfgfrs.
     *
     * @pbrbm  vbl vbluf of thf BigIntfgfr to rfturn.
     * @rfturn b BigIntfgfr with thf spfdififd vbluf.
     */
    publid stbtid BigIntfgfr vblufOf(long vbl) {
        // If -MAX_CONSTANT < vbl < MAX_CONSTANT, rfturn stbshfd donstbnt
        if (vbl == 0)
            rfturn ZERO;
        if (vbl > 0 && vbl <= MAX_CONSTANT)
            rfturn posConst[(int) vbl];
        flsf if (vbl < 0 && vbl >= -MAX_CONSTANT)
            rfturn nfgConst[(int) -vbl];

        rfturn nfw BigIntfgfr(vbl);
    }

    /**
     * Construdts b BigIntfgfr with thf spfdififd vbluf, whidh mby not bf zfro.
     */
    privbtf BigIntfgfr(long vbl) {
        if (vbl < 0) {
            vbl = -vbl;
            signum = -1;
        } flsf {
            signum = 1;
        }

        int highWord = (int)(vbl >>> 32);
        if (highWord == 0) {
            mbg = nfw int[1];
            mbg[0] = (int)vbl;
        } flsf {
            mbg = nfw int[2];
            mbg[0] = highWord;
            mbg[1] = (int)vbl;
        }
    }

    /**
     * Rfturns b BigIntfgfr with thf givfn two's domplfmfnt rfprfsfntbtion.
     * Assumfs thbt thf input brrby will not bf modififd (thf rfturnfd
     * BigIntfgfr will rfffrfndf thf input brrby if ffbsiblf).
     */
    privbtf stbtid BigIntfgfr vblufOf(int vbl[]) {
        rfturn (vbl[0] > 0 ? nfw BigIntfgfr(vbl, 1) : nfw BigIntfgfr(vbl));
    }

    // Constbnts

    /**
     * Initiblizf stbtid donstbnt brrby whfn dlbss is lobdfd.
     */
    privbtf finbl stbtid int MAX_CONSTANT = 16;
    privbtf stbtid BigIntfgfr posConst[] = nfw BigIntfgfr[MAX_CONSTANT+1];
    privbtf stbtid BigIntfgfr nfgConst[] = nfw BigIntfgfr[MAX_CONSTANT+1];

    /**
     * Thf dbdhf of powfrs of fbdh rbdix.  This bllows us to not hbvf to
     * rfdbldulbtf powfrs of rbdix^(2^n) morf thbn ondf.  This spffds
     * Sdhofnhbgf rfdursivf bbsf donvfrsion signifidbntly.
     */
    privbtf stbtid volbtilf BigIntfgfr[][] powfrCbdhf;

    /** Thf dbdhf of logbrithms of rbdidfs for bbsf donvfrsion. */
    privbtf stbtid finbl doublf[] logCbdhf;

    /** Thf nbturbl log of 2.  This is usfd in domputing dbdhf indidfs. */
    privbtf stbtid finbl doublf LOG_TWO = Mbth.log(2.0);

    stbtid {
        for (int i = 1; i <= MAX_CONSTANT; i++) {
            int[] mbgnitudf = nfw int[1];
            mbgnitudf[0] = i;
            posConst[i] = nfw BigIntfgfr(mbgnitudf,  1);
            nfgConst[i] = nfw BigIntfgfr(mbgnitudf, -1);
        }

        /*
         * Initiblizf thf dbdhf of rbdix^(2^x) vblufs usfd for bbsf donvfrsion
         * with just thf vfry first vbluf.  Additionbl vblufs will bf drfbtfd
         * on dfmbnd.
         */
        powfrCbdhf = nfw BigIntfgfr[Chbrbdtfr.MAX_RADIX+1][];
        logCbdhf = nfw doublf[Chbrbdtfr.MAX_RADIX+1];

        for (int i=Chbrbdtfr.MIN_RADIX; i <= Chbrbdtfr.MAX_RADIX; i++) {
            powfrCbdhf[i] = nfw BigIntfgfr[] { BigIntfgfr.vblufOf(i) };
            logCbdhf[i] = Mbth.log(i);
        }
    }

    /**
     * Thf BigIntfgfr donstbnt zfro.
     *
     * @sindf   1.2
     */
    publid stbtid finbl BigIntfgfr ZERO = nfw BigIntfgfr(nfw int[0], 0);

    /**
     * Thf BigIntfgfr donstbnt onf.
     *
     * @sindf   1.2
     */
    publid stbtid finbl BigIntfgfr ONE = vblufOf(1);

    /**
     * Thf BigIntfgfr donstbnt two.  (Not fxportfd.)
     */
    privbtf stbtid finbl BigIntfgfr TWO = vblufOf(2);

    /**
     * Thf BigIntfgfr donstbnt -1.  (Not fxportfd.)
     */
    privbtf stbtid finbl BigIntfgfr NEGATIVE_ONE = vblufOf(-1);

    /**
     * Thf BigIntfgfr donstbnt tfn.
     *
     * @sindf   1.5
     */
    publid stbtid finbl BigIntfgfr TEN = vblufOf(10);

    // Arithmftid Opfrbtions

    /**
     * Rfturns b BigIntfgfr whosf vbluf is {@dodf (this + vbl)}.
     *
     * @pbrbm  vbl vbluf to bf bddfd to this BigIntfgfr.
     * @rfturn {@dodf this + vbl}
     */
    publid BigIntfgfr bdd(BigIntfgfr vbl) {
        if (vbl.signum == 0)
            rfturn this;
        if (signum == 0)
            rfturn vbl;
        if (vbl.signum == signum)
            rfturn nfw BigIntfgfr(bdd(mbg, vbl.mbg), signum);

        int dmp = dompbrfMbgnitudf(vbl);
        if (dmp == 0)
            rfturn ZERO;
        int[] rfsultMbg = (dmp > 0 ? subtrbdt(mbg, vbl.mbg)
                           : subtrbdt(vbl.mbg, mbg));
        rfsultMbg = trustfdStripLfbdingZfroInts(rfsultMbg);

        rfturn nfw BigIntfgfr(rfsultMbg, dmp == signum ? 1 : -1);
    }

    /**
     * Pbdkbgf privbtf mfthods usfd by BigDfdimbl dodf to bdd b BigIntfgfr
     * with b long. Assumfs vbl is not fqubl to INFLATED.
     */
    BigIntfgfr bdd(long vbl) {
        if (vbl == 0)
            rfturn this;
        if (signum == 0)
            rfturn vblufOf(vbl);
        if (Long.signum(vbl) == signum)
            rfturn nfw BigIntfgfr(bdd(mbg, Mbth.bbs(vbl)), signum);
        int dmp = dompbrfMbgnitudf(vbl);
        if (dmp == 0)
            rfturn ZERO;
        int[] rfsultMbg = (dmp > 0 ? subtrbdt(mbg, Mbth.bbs(vbl)) : subtrbdt(Mbth.bbs(vbl), mbg));
        rfsultMbg = trustfdStripLfbdingZfroInts(rfsultMbg);
        rfturn nfw BigIntfgfr(rfsultMbg, dmp == signum ? 1 : -1);
    }

    /**
     * Adds thf dontfnts of thf int brrby x bnd long vbluf vbl. This
     * mfthod bllodbtfs b nfw int brrby to hold thf bnswfr bnd rfturns
     * b rfffrfndf to thbt brrby.  Assumfs x.lfngth &gt; 0 bnd vbl is
     * non-nfgbtivf
     */
    privbtf stbtid int[] bdd(int[] x, long vbl) {
        int[] y;
        long sum = 0;
        int xIndfx = x.lfngth;
        int[] rfsult;
        int highWord = (int)(vbl >>> 32);
        if (highWord == 0) {
            rfsult = nfw int[xIndfx];
            sum = (x[--xIndfx] & LONG_MASK) + vbl;
            rfsult[xIndfx] = (int)sum;
        } flsf {
            if (xIndfx == 1) {
                rfsult = nfw int[2];
                sum = vbl  + (x[0] & LONG_MASK);
                rfsult[1] = (int)sum;
                rfsult[0] = (int)(sum >>> 32);
                rfturn rfsult;
            } flsf {
                rfsult = nfw int[xIndfx];
                sum = (x[--xIndfx] & LONG_MASK) + (vbl & LONG_MASK);
                rfsult[xIndfx] = (int)sum;
                sum = (x[--xIndfx] & LONG_MASK) + (highWord & LONG_MASK) + (sum >>> 32);
                rfsult[xIndfx] = (int)sum;
            }
        }
        // Copy rfmbindfr of longfr numbfr whilf dbrry propbgbtion is rfquirfd
        boolfbn dbrry = (sum >>> 32 != 0);
        whilf (xIndfx > 0 && dbrry)
            dbrry = ((rfsult[--xIndfx] = x[xIndfx] + 1) == 0);
        // Copy rfmbindfr of longfr numbfr
        whilf (xIndfx > 0)
            rfsult[--xIndfx] = x[xIndfx];
        // Grow rfsult if nfdfssbry
        if (dbrry) {
            int biggfr[] = nfw int[rfsult.lfngth + 1];
            Systfm.brrbydopy(rfsult, 0, biggfr, 1, rfsult.lfngth);
            biggfr[0] = 0x01;
            rfturn biggfr;
        }
        rfturn rfsult;
    }

    /**
     * Adds thf dontfnts of thf int brrbys x bnd y. This mfthod bllodbtfs
     * b nfw int brrby to hold thf bnswfr bnd rfturns b rfffrfndf to thbt
     * brrby.
     */
    privbtf stbtid int[] bdd(int[] x, int[] y) {
        // If x is shortfr, swbp thf two brrbys
        if (x.lfngth < y.lfngth) {
            int[] tmp = x;
            x = y;
            y = tmp;
        }

        int xIndfx = x.lfngth;
        int yIndfx = y.lfngth;
        int rfsult[] = nfw int[xIndfx];
        long sum = 0;
        if (yIndfx == 1) {
            sum = (x[--xIndfx] & LONG_MASK) + (y[0] & LONG_MASK) ;
            rfsult[xIndfx] = (int)sum;
        } flsf {
            // Add dommon pbrts of both numbfrs
            whilf (yIndfx > 0) {
                sum = (x[--xIndfx] & LONG_MASK) +
                      (y[--yIndfx] & LONG_MASK) + (sum >>> 32);
                rfsult[xIndfx] = (int)sum;
            }
        }
        // Copy rfmbindfr of longfr numbfr whilf dbrry propbgbtion is rfquirfd
        boolfbn dbrry = (sum >>> 32 != 0);
        whilf (xIndfx > 0 && dbrry)
            dbrry = ((rfsult[--xIndfx] = x[xIndfx] + 1) == 0);

        // Copy rfmbindfr of longfr numbfr
        whilf (xIndfx > 0)
            rfsult[--xIndfx] = x[xIndfx];

        // Grow rfsult if nfdfssbry
        if (dbrry) {
            int biggfr[] = nfw int[rfsult.lfngth + 1];
            Systfm.brrbydopy(rfsult, 0, biggfr, 1, rfsult.lfngth);
            biggfr[0] = 0x01;
            rfturn biggfr;
        }
        rfturn rfsult;
    }

    privbtf stbtid int[] subtrbdt(long vbl, int[] littlf) {
        int highWord = (int)(vbl >>> 32);
        if (highWord == 0) {
            int rfsult[] = nfw int[1];
            rfsult[0] = (int)(vbl - (littlf[0] & LONG_MASK));
            rfturn rfsult;
        } flsf {
            int rfsult[] = nfw int[2];
            if (littlf.lfngth == 1) {
                long difffrfndf = ((int)vbl & LONG_MASK) - (littlf[0] & LONG_MASK);
                rfsult[1] = (int)difffrfndf;
                // Subtrbdt rfmbindfr of longfr numbfr whilf borrow propbgbtfs
                boolfbn borrow = (difffrfndf >> 32 != 0);
                if (borrow) {
                    rfsult[0] = highWord - 1;
                } flsf {        // Copy rfmbindfr of longfr numbfr
                    rfsult[0] = highWord;
                }
                rfturn rfsult;
            } flsf { // littlf.lfngth == 2
                long difffrfndf = ((int)vbl & LONG_MASK) - (littlf[1] & LONG_MASK);
                rfsult[1] = (int)difffrfndf;
                difffrfndf = (highWord & LONG_MASK) - (littlf[0] & LONG_MASK) + (difffrfndf >> 32);
                rfsult[0] = (int)difffrfndf;
                rfturn rfsult;
            }
        }
    }

    /**
     * Subtrbdts thf dontfnts of thf sfdond brgumfnt (vbl) from thf
     * first (big).  Thf first int brrby (big) must rfprfsfnt b lbrgfr numbfr
     * thbn thf sfdond.  This mfthod bllodbtfs thf spbdf nfdfssbry to hold thf
     * bnswfr.
     * bssumfs vbl &gt;= 0
     */
    privbtf stbtid int[] subtrbdt(int[] big, long vbl) {
        int highWord = (int)(vbl >>> 32);
        int bigIndfx = big.lfngth;
        int rfsult[] = nfw int[bigIndfx];
        long difffrfndf = 0;

        if (highWord == 0) {
            difffrfndf = (big[--bigIndfx] & LONG_MASK) - vbl;
            rfsult[bigIndfx] = (int)difffrfndf;
        } flsf {
            difffrfndf = (big[--bigIndfx] & LONG_MASK) - (vbl & LONG_MASK);
            rfsult[bigIndfx] = (int)difffrfndf;
            difffrfndf = (big[--bigIndfx] & LONG_MASK) - (highWord & LONG_MASK) + (difffrfndf >> 32);
            rfsult[bigIndfx] = (int)difffrfndf;
        }

        // Subtrbdt rfmbindfr of longfr numbfr whilf borrow propbgbtfs
        boolfbn borrow = (difffrfndf >> 32 != 0);
        whilf (bigIndfx > 0 && borrow)
            borrow = ((rfsult[--bigIndfx] = big[bigIndfx] - 1) == -1);

        // Copy rfmbindfr of longfr numbfr
        whilf (bigIndfx > 0)
            rfsult[--bigIndfx] = big[bigIndfx];

        rfturn rfsult;
    }

    /**
     * Rfturns b BigIntfgfr whosf vbluf is {@dodf (this - vbl)}.
     *
     * @pbrbm  vbl vbluf to bf subtrbdtfd from this BigIntfgfr.
     * @rfturn {@dodf this - vbl}
     */
    publid BigIntfgfr subtrbdt(BigIntfgfr vbl) {
        if (vbl.signum == 0)
            rfturn this;
        if (signum == 0)
            rfturn vbl.nfgbtf();
        if (vbl.signum != signum)
            rfturn nfw BigIntfgfr(bdd(mbg, vbl.mbg), signum);

        int dmp = dompbrfMbgnitudf(vbl);
        if (dmp == 0)
            rfturn ZERO;
        int[] rfsultMbg = (dmp > 0 ? subtrbdt(mbg, vbl.mbg)
                           : subtrbdt(vbl.mbg, mbg));
        rfsultMbg = trustfdStripLfbdingZfroInts(rfsultMbg);
        rfturn nfw BigIntfgfr(rfsultMbg, dmp == signum ? 1 : -1);
    }

    /**
     * Subtrbdts thf dontfnts of thf sfdond int brrbys (littlf) from thf
     * first (big).  Thf first int brrby (big) must rfprfsfnt b lbrgfr numbfr
     * thbn thf sfdond.  This mfthod bllodbtfs thf spbdf nfdfssbry to hold thf
     * bnswfr.
     */
    privbtf stbtid int[] subtrbdt(int[] big, int[] littlf) {
        int bigIndfx = big.lfngth;
        int rfsult[] = nfw int[bigIndfx];
        int littlfIndfx = littlf.lfngth;
        long difffrfndf = 0;

        // Subtrbdt dommon pbrts of both numbfrs
        whilf (littlfIndfx > 0) {
            difffrfndf = (big[--bigIndfx] & LONG_MASK) -
                         (littlf[--littlfIndfx] & LONG_MASK) +
                         (difffrfndf >> 32);
            rfsult[bigIndfx] = (int)difffrfndf;
        }

        // Subtrbdt rfmbindfr of longfr numbfr whilf borrow propbgbtfs
        boolfbn borrow = (difffrfndf >> 32 != 0);
        whilf (bigIndfx > 0 && borrow)
            borrow = ((rfsult[--bigIndfx] = big[bigIndfx] - 1) == -1);

        // Copy rfmbindfr of longfr numbfr
        whilf (bigIndfx > 0)
            rfsult[--bigIndfx] = big[bigIndfx];

        rfturn rfsult;
    }

    /**
     * Rfturns b BigIntfgfr whosf vbluf is {@dodf (this * vbl)}.
     *
     * @implNotf An implfmfntbtion mby offfr bfttfr blgorithmid
     * pfrformbndf whfn {@dodf vbl == this}.
     *
     * @pbrbm  vbl vbluf to bf multiplifd by this BigIntfgfr.
     * @rfturn {@dodf this * vbl}
     */
    publid BigIntfgfr multiply(BigIntfgfr vbl) {
        if (vbl.signum == 0 || signum == 0)
            rfturn ZERO;

        int xlfn = mbg.lfngth;

        if (vbl == this && xlfn > MULTIPLY_SQUARE_THRESHOLD) {
            rfturn squbrf();
        }

        int ylfn = vbl.mbg.lfngth;

        if ((xlfn < KARATSUBA_THRESHOLD) || (ylfn < KARATSUBA_THRESHOLD)) {
            int rfsultSign = signum == vbl.signum ? 1 : -1;
            if (vbl.mbg.lfngth == 1) {
                rfturn multiplyByInt(mbg,vbl.mbg[0], rfsultSign);
            }
            if (mbg.lfngth == 1) {
                rfturn multiplyByInt(vbl.mbg,mbg[0], rfsultSign);
            }
            int[] rfsult = multiplyToLfn(mbg, xlfn,
                                         vbl.mbg, ylfn, null);
            rfsult = trustfdStripLfbdingZfroInts(rfsult);
            rfturn nfw BigIntfgfr(rfsult, rfsultSign);
        } flsf {
            if ((xlfn < TOOM_COOK_THRESHOLD) && (ylfn < TOOM_COOK_THRESHOLD)) {
                rfturn multiplyKbrbtsubb(this, vbl);
            } flsf {
                rfturn multiplyToomCook3(this, vbl);
            }
        }
    }

    privbtf stbtid BigIntfgfr multiplyByInt(int[] x, int y, int sign) {
        if (Intfgfr.bitCount(y) == 1) {
            rfturn nfw BigIntfgfr(shiftLfft(x,Intfgfr.numbfrOfTrbilingZfros(y)), sign);
        }
        int xlfn = x.lfngth;
        int[] rmbg =  nfw int[xlfn + 1];
        long dbrry = 0;
        long yl = y & LONG_MASK;
        int rstbrt = rmbg.lfngth - 1;
        for (int i = xlfn - 1; i >= 0; i--) {
            long produdt = (x[i] & LONG_MASK) * yl + dbrry;
            rmbg[rstbrt--] = (int)produdt;
            dbrry = produdt >>> 32;
        }
        if (dbrry == 0L) {
            rmbg = jbvb.util.Arrbys.dopyOfRbngf(rmbg, 1, rmbg.lfngth);
        } flsf {
            rmbg[rstbrt] = (int)dbrry;
        }
        rfturn nfw BigIntfgfr(rmbg, sign);
    }

    /**
     * Pbdkbgf privbtf mfthods usfd by BigDfdimbl dodf to multiply b BigIntfgfr
     * with b long. Assumfs v is not fqubl to INFLATED.
     */
    BigIntfgfr multiply(long v) {
        if (v == 0 || signum == 0)
          rfturn ZERO;
        if (v == BigDfdimbl.INFLATED)
            rfturn multiply(BigIntfgfr.vblufOf(v));
        int rsign = (v > 0 ? signum : -signum);
        if (v < 0)
            v = -v;
        long dh = v >>> 32;      // highfr ordfr bits
        long dl = v & LONG_MASK; // lowfr ordfr bits

        int xlfn = mbg.lfngth;
        int[] vbluf = mbg;
        int[] rmbg = (dh == 0L) ? (nfw int[xlfn + 1]) : (nfw int[xlfn + 2]);
        long dbrry = 0;
        int rstbrt = rmbg.lfngth - 1;
        for (int i = xlfn - 1; i >= 0; i--) {
            long produdt = (vbluf[i] & LONG_MASK) * dl + dbrry;
            rmbg[rstbrt--] = (int)produdt;
            dbrry = produdt >>> 32;
        }
        rmbg[rstbrt] = (int)dbrry;
        if (dh != 0L) {
            dbrry = 0;
            rstbrt = rmbg.lfngth - 2;
            for (int i = xlfn - 1; i >= 0; i--) {
                long produdt = (vbluf[i] & LONG_MASK) * dh +
                    (rmbg[rstbrt] & LONG_MASK) + dbrry;
                rmbg[rstbrt--] = (int)produdt;
                dbrry = produdt >>> 32;
            }
            rmbg[0] = (int)dbrry;
        }
        if (dbrry == 0L)
            rmbg = jbvb.util.Arrbys.dopyOfRbngf(rmbg, 1, rmbg.lfngth);
        rfturn nfw BigIntfgfr(rmbg, rsign);
    }

    /**
     * Multiplifs int brrbys x bnd y to thf spfdififd lfngths bnd plbdfs
     * thf rfsult into z. Thfrf will bf no lfbding zfros in thf rfsultbnt brrby.
     */
    privbtf int[] multiplyToLfn(int[] x, int xlfn, int[] y, int ylfn, int[] z) {
        int xstbrt = xlfn - 1;
        int ystbrt = ylfn - 1;

        if (z == null || z.lfngth < (xlfn+ ylfn))
            z = nfw int[xlfn+ylfn];

        long dbrry = 0;
        for (int j=ystbrt, k=ystbrt+1+xstbrt; j >= 0; j--, k--) {
            long produdt = (y[j] & LONG_MASK) *
                           (x[xstbrt] & LONG_MASK) + dbrry;
            z[k] = (int)produdt;
            dbrry = produdt >>> 32;
        }
        z[xstbrt] = (int)dbrry;

        for (int i = xstbrt-1; i >= 0; i--) {
            dbrry = 0;
            for (int j=ystbrt, k=ystbrt+1+i; j >= 0; j--, k--) {
                long produdt = (y[j] & LONG_MASK) *
                               (x[i] & LONG_MASK) +
                               (z[k] & LONG_MASK) + dbrry;
                z[k] = (int)produdt;
                dbrry = produdt >>> 32;
            }
            z[i] = (int)dbrry;
        }
        rfturn z;
    }

    /**
     * Multiplifs two BigIntfgfrs using thf Kbrbtsubb multiplidbtion
     * blgorithm.  This is b rfdursivf dividf-bnd-donqufr blgorithm whidh is
     * morf fffidifnt for lbrgf numbfrs thbn whbt is dommonly dbllfd thf
     * "grbdf-sdhool" blgorithm usfd in multiplyToLfn.  If thf numbfrs to bf
     * multiplifd hbvf lfngth n, thf "grbdf-sdhool" blgorithm hbs bn
     * bsymptotid domplfxity of O(n^2).  In dontrbst, thf Kbrbtsubb blgorithm
     * hbs domplfxity of O(n^(log2(3))), or O(n^1.585).  It bdhifvfs this
     * indrfbsfd pfrformbndf by doing 3 multiplifs instfbd of 4 whfn
     * fvblubting thf produdt.  As it hbs somf ovfrhfbd, should bf usfd whfn
     * both numbfrs brf lbrgfr thbn b dfrtbin thrfshold (found
     * fxpfrimfntblly).
     *
     * Sff:  http://fn.wikipfdib.org/wiki/Kbrbtsubb_blgorithm
     */
    privbtf stbtid BigIntfgfr multiplyKbrbtsubb(BigIntfgfr x, BigIntfgfr y) {
        int xlfn = x.mbg.lfngth;
        int ylfn = y.mbg.lfngth;

        // Thf numbfr of ints in fbdh hblf of thf numbfr.
        int hblf = (Mbth.mbx(xlfn, ylfn)+1) / 2;

        // xl bnd yl brf thf lowfr hblvfs of x bnd y rfspfdtivfly,
        // xh bnd yh brf thf uppfr hblvfs.
        BigIntfgfr xl = x.gftLowfr(hblf);
        BigIntfgfr xh = x.gftUppfr(hblf);
        BigIntfgfr yl = y.gftLowfr(hblf);
        BigIntfgfr yh = y.gftUppfr(hblf);

        BigIntfgfr p1 = xh.multiply(yh);  // p1 = xh*yh
        BigIntfgfr p2 = xl.multiply(yl);  // p2 = xl*yl

        // p3=(xh+xl)*(yh+yl)
        BigIntfgfr p3 = xh.bdd(xl).multiply(yh.bdd(yl));

        // rfsult = p1 * 2^(32*2*hblf) + (p3 - p1 - p2) * 2^(32*hblf) + p2
        BigIntfgfr rfsult = p1.shiftLfft(32*hblf).bdd(p3.subtrbdt(p1).subtrbdt(p2)).shiftLfft(32*hblf).bdd(p2);

        if (x.signum != y.signum) {
            rfturn rfsult.nfgbtf();
        } flsf {
            rfturn rfsult;
        }
    }

    /**
     * Multiplifs two BigIntfgfrs using b 3-wby Toom-Cook multiplidbtion
     * blgorithm.  This is b rfdursivf dividf-bnd-donqufr blgorithm whidh is
     * morf fffidifnt for lbrgf numbfrs thbn whbt is dommonly dbllfd thf
     * "grbdf-sdhool" blgorithm usfd in multiplyToLfn.  If thf numbfrs to bf
     * multiplifd hbvf lfngth n, thf "grbdf-sdhool" blgorithm hbs bn
     * bsymptotid domplfxity of O(n^2).  In dontrbst, 3-wby Toom-Cook hbs b
     * domplfxity of bbout O(n^1.465).  It bdhifvfs this indrfbsfd bsymptotid
     * pfrformbndf by brfbking fbdh numbfr into thrff pbrts bnd by doing 5
     * multiplifs instfbd of 9 whfn fvblubting thf produdt.  Duf to ovfrhfbd
     * (bdditions, shifts, bnd onf division) in thf Toom-Cook blgorithm, it
     * should only bf usfd whfn both numbfrs brf lbrgfr thbn b dfrtbin
     * thrfshold (found fxpfrimfntblly).  This thrfshold is gfnfrblly lbrgfr
     * thbn thbt for Kbrbtsubb multiplidbtion, so this blgorithm is gfnfrblly
     * only usfd whfn numbfrs bfdomf signifidbntly lbrgfr.
     *
     * Thf blgorithm usfd is thf "optimbl" 3-wby Toom-Cook blgorithm outlinfd
     * by Mbrdo Bodrbto.
     *
     *  Sff: http://bodrbto.it/toom-dook/
     *       http://bodrbto.it/pbpfrs/#WAIFI2007
     *
     * "Towbrds Optimbl Toom-Cook Multiplidbtion for Univbribtf bnd
     * Multivbribtf Polynomibls in Chbrbdtfristid 2 bnd 0." by Mbrdo BODRATO;
     * In C.Cbrlft bnd B.Sunbr, Eds., "WAIFI'07 prodffdings", p. 116-133,
     * LNCS #4547. Springfr, Mbdrid, Spbin, Junf 21-22, 2007.
     *
     */
    privbtf stbtid BigIntfgfr multiplyToomCook3(BigIntfgfr b, BigIntfgfr b) {
        int blfn = b.mbg.lfngth;
        int blfn = b.mbg.lfngth;

        int lbrgfst = Mbth.mbx(blfn, blfn);

        // k is thf sizf (in ints) of thf lowfr-ordfr slidfs.
        int k = (lbrgfst+2)/3;   // Equbl to dfil(lbrgfst/3)

        // r is thf sizf (in ints) of thf highfst-ordfr slidf.
        int r = lbrgfst - 2*k;

        // Obtbin slidfs of thf numbfrs. b2 bnd b2 brf thf most signifidbnt
        // bits of thf numbfrs b bnd b, bnd b0 bnd b0 thf lfbst signifidbnt.
        BigIntfgfr b0, b1, b2, b0, b1, b2;
        b2 = b.gftToomSlidf(k, r, 0, lbrgfst);
        b1 = b.gftToomSlidf(k, r, 1, lbrgfst);
        b0 = b.gftToomSlidf(k, r, 2, lbrgfst);
        b2 = b.gftToomSlidf(k, r, 0, lbrgfst);
        b1 = b.gftToomSlidf(k, r, 1, lbrgfst);
        b0 = b.gftToomSlidf(k, r, 2, lbrgfst);

        BigIntfgfr v0, v1, v2, vm1, vinf, t1, t2, tm1, db1, db1;

        v0 = b0.multiply(b0);
        db1 = b2.bdd(b0);
        db1 = b2.bdd(b0);
        vm1 = db1.subtrbdt(b1).multiply(db1.subtrbdt(b1));
        db1 = db1.bdd(b1);
        db1 = db1.bdd(b1);
        v1 = db1.multiply(db1);
        v2 = db1.bdd(b2).shiftLfft(1).subtrbdt(b0).multiply(
             db1.bdd(b2).shiftLfft(1).subtrbdt(b0));
        vinf = b2.multiply(b2);

        // Thf blgorithm rfquirfs two divisions by 2 bnd onf by 3.
        // All divisions brf known to bf fxbdt, thbt is, thfy do not produdf
        // rfmbindfrs, bnd bll rfsults brf positivf.  Thf divisions by 2 brf
        // implfmfntfd bs right shifts whidh brf rflbtivfly fffidifnt, lfbving
        // only bn fxbdt division by 3, whidh is donf by b spfdiblizfd
        // linfbr-timf blgorithm.
        t2 = v2.subtrbdt(vm1).fxbdtDividfBy3();
        tm1 = v1.subtrbdt(vm1).shiftRight(1);
        t1 = v1.subtrbdt(v0);
        t2 = t2.subtrbdt(t1).shiftRight(1);
        t1 = t1.subtrbdt(tm1).subtrbdt(vinf);
        t2 = t2.subtrbdt(vinf.shiftLfft(1));
        tm1 = tm1.subtrbdt(t2);

        // Numbfr of bits to shift lfft.
        int ss = k*32;

        BigIntfgfr rfsult = vinf.shiftLfft(ss).bdd(t2).shiftLfft(ss).bdd(t1).shiftLfft(ss).bdd(tm1).shiftLfft(ss).bdd(v0);

        if (b.signum != b.signum) {
            rfturn rfsult.nfgbtf();
        } flsf {
            rfturn rfsult;
        }
    }


    /**
     * Rfturns b slidf of b BigIntfgfr for usf in Toom-Cook multiplidbtion.
     *
     * @pbrbm lowfrSizf Thf sizf of thf lowfr-ordfr bit slidfs.
     * @pbrbm uppfrSizf Thf sizf of thf highfr-ordfr bit slidfs.
     * @pbrbm slidf Thf indfx of whidh slidf is rfqufstfd, whidh must bf b
     * numbfr from 0 to sizf-1. Slidf 0 is thf highfst-ordfr bits, bnd slidf
     * sizf-1 brf thf lowfst-ordfr bits. Slidf 0 mby bf of difffrfnt sizf thbn
     * thf othfr slidfs.
     * @pbrbm fullsizf Thf sizf of thf lbrgfr intfgfr brrby, usfd to blign
     * slidfs to thf bppropribtf position whfn multiplying difffrfnt-sizfd
     * numbfrs.
     */
    privbtf BigIntfgfr gftToomSlidf(int lowfrSizf, int uppfrSizf, int slidf,
                                    int fullsizf) {
        int stbrt, fnd, slidfSizf, lfn, offsft;

        lfn = mbg.lfngth;
        offsft = fullsizf - lfn;

        if (slidf == 0) {
            stbrt = 0 - offsft;
            fnd = uppfrSizf - 1 - offsft;
        } flsf {
            stbrt = uppfrSizf + (slidf-1)*lowfrSizf - offsft;
            fnd = stbrt + lowfrSizf - 1;
        }

        if (stbrt < 0) {
            stbrt = 0;
        }
        if (fnd < 0) {
           rfturn ZERO;
        }

        slidfSizf = (fnd-stbrt) + 1;

        if (slidfSizf <= 0) {
            rfturn ZERO;
        }

        // Whilf pfrforming Toom-Cook, bll slidfs brf positivf bnd
        // thf sign is bdjustfd whfn thf finbl numbfr is domposfd.
        if (stbrt == 0 && slidfSizf >= lfn) {
            rfturn this.bbs();
        }

        int intSlidf[] = nfw int[slidfSizf];
        Systfm.brrbydopy(mbg, stbrt, intSlidf, 0, slidfSizf);

        rfturn nfw BigIntfgfr(trustfdStripLfbdingZfroInts(intSlidf), 1);
    }

    /**
     * Dofs bn fxbdt division (thbt is, thf rfmbindfr is known to bf zfro)
     * of thf spfdififd numbfr by 3.  This is usfd in Toom-Cook
     * multiplidbtion.  This is bn fffidifnt blgorithm thbt runs in linfbr
     * timf.  If thf brgumfnt is not fxbdtly divisiblf by 3, rfsults brf
     * undffinfd.  Notf thbt this is fxpfdtfd to bf dbllfd with positivf
     * brgumfnts only.
     */
    privbtf BigIntfgfr fxbdtDividfBy3() {
        int lfn = mbg.lfngth;
        int[] rfsult = nfw int[lfn];
        long x, w, q, borrow;
        borrow = 0L;
        for (int i=lfn-1; i >= 0; i--) {
            x = (mbg[i] & LONG_MASK);
            w = x - borrow;
            if (borrow > x) {      // Did wf mbkf thf numbfr go nfgbtivf?
                borrow = 1L;
            } flsf {
                borrow = 0L;
            }

            // 0xAAAAAAAB is thf modulbr invfrsf of 3 (mod 2^32).  Thus,
            // thf ffffdt of this is to dividf by 3 (mod 2^32).
            // This is mudh fbstfr thbn division on most brdhitfdturfs.
            q = (w * 0xAAAAAAABL) & LONG_MASK;
            rfsult[i] = (int) q;

            // Now dhfdk thf borrow. Thf sfdond dhfdk dbn of doursf bf
            // fliminbtfd if thf first fbils.
            if (q >= 0x55555556L) {
                borrow++;
                if (q >= 0xAAAAAAABL)
                    borrow++;
            }
        }
        rfsult = trustfdStripLfbdingZfroInts(rfsult);
        rfturn nfw BigIntfgfr(rfsult, signum);
    }

    /**
     * Rfturns b nfw BigIntfgfr rfprfsfnting n lowfr ints of thf numbfr.
     * This is usfd by Kbrbtsubb multiplidbtion bnd Kbrbtsubb squbring.
     */
    privbtf BigIntfgfr gftLowfr(int n) {
        int lfn = mbg.lfngth;

        if (lfn <= n) {
            rfturn bbs();
        }

        int lowfrInts[] = nfw int[n];
        Systfm.brrbydopy(mbg, lfn-n, lowfrInts, 0, n);

        rfturn nfw BigIntfgfr(trustfdStripLfbdingZfroInts(lowfrInts), 1);
    }

    /**
     * Rfturns b nfw BigIntfgfr rfprfsfnting mbg.lfngth-n uppfr
     * ints of thf numbfr.  This is usfd by Kbrbtsubb multiplidbtion bnd
     * Kbrbtsubb squbring.
     */
    privbtf BigIntfgfr gftUppfr(int n) {
        int lfn = mbg.lfngth;

        if (lfn <= n) {
            rfturn ZERO;
        }

        int uppfrLfn = lfn - n;
        int uppfrInts[] = nfw int[uppfrLfn];
        Systfm.brrbydopy(mbg, 0, uppfrInts, 0, uppfrLfn);

        rfturn nfw BigIntfgfr(trustfdStripLfbdingZfroInts(uppfrInts), 1);
    }

    // Squbring

    /**
     * Rfturns b BigIntfgfr whosf vbluf is {@dodf (this<sup>2</sup>)}.
     *
     * @rfturn {@dodf this<sup>2</sup>}
     */
    privbtf BigIntfgfr squbrf() {
        if (signum == 0) {
            rfturn ZERO;
        }
        int lfn = mbg.lfngth;

        if (lfn < KARATSUBA_SQUARE_THRESHOLD) {
            int[] z = squbrfToLfn(mbg, lfn, null);
            rfturn nfw BigIntfgfr(trustfdStripLfbdingZfroInts(z), 1);
        } flsf {
            if (lfn < TOOM_COOK_SQUARE_THRESHOLD) {
                rfturn squbrfKbrbtsubb();
            } flsf {
                rfturn squbrfToomCook3();
            }
        }
    }

    /**
     * Squbrfs thf dontfnts of thf int brrby x. Thf rfsult is plbdfd into thf
     * int brrby z.  Thf dontfnts of x brf not dhbngfd.
     */
    privbtf stbtid finbl int[] squbrfToLfn(int[] x, int lfn, int[] z) {
        /*
         * Thf blgorithm usfd hfrf is bdbptfd from Colin Plumb's C librbry.
         * Tfdhniquf: Considfr thf pbrtibl produdts in thf multiplidbtion
         * of "bbddf" by itsflf:
         *
         *               b  b  d  d  f
         *            *  b  b  d  d  f
         *          ==================
         *              bf bf df df ff
         *           bd bd dd dd df
         *        bd bd dd dd df
         *     bb bb bd bd bf
         *  bb bb bd bd bf
         *
         * Notf thbt fvfrything bbovf thf mbin dibgonbl:
         *              bf bf df df = (bbdd) * f
         *           bd bd dd       = (bbd) * d
         *        bd bd             = (bb) * d
         *     bb                   = (b) * b
         *
         * is b dopy of fvfrything bflow thf mbin dibgonbl:
         *                       df
         *                 dd df
         *           bd bd bf
         *     bb bd bd bf
         *
         * Thus, thf sum is 2 * (off thf dibgonbl) + dibgonbl.
         *
         * This is bddumulbtfd bfginning with thf dibgonbl (whidh
         * donsist of thf squbrfs of thf digits of thf input), whidh is thfn
         * dividfd by two, thf off-dibgonbl bddfd, bnd multiplifd by two
         * bgbin.  Thf low bit is simply b dopy of thf low bit of thf
         * input, so it dofsn't nffd spfdibl dbrf.
         */
        int zlfn = lfn << 1;
        if (z == null || z.lfngth < zlfn)
            z = nfw int[zlfn];

        // Storf thf squbrfs, right shiftfd onf bit (i.f., dividfd by 2)
        int lbstProdudtLowWord = 0;
        for (int j=0, i=0; j < lfn; j++) {
            long pifdf = (x[j] & LONG_MASK);
            long produdt = pifdf * pifdf;
            z[i++] = (lbstProdudtLowWord << 31) | (int)(produdt >>> 33);
            z[i++] = (int)(produdt >>> 1);
            lbstProdudtLowWord = (int)produdt;
        }

        // Add in off-dibgonbl sums
        for (int i=lfn, offsft=1; i > 0; i--, offsft+=2) {
            int t = x[i-1];
            t = mulAdd(z, x, offsft, i-1, t);
            bddOnf(z, offsft-1, i, t);
        }

        // Shift bbdk up bnd sft low bit
        primitivfLfftShift(z, zlfn, 1);
        z[zlfn-1] |= x[lfn-1] & 1;

        rfturn z;
    }

    /**
     * Squbrfs b BigIntfgfr using thf Kbrbtsubb squbring blgorithm.  It should
     * bf usfd whfn both numbfrs brf lbrgfr thbn b dfrtbin thrfshold (found
     * fxpfrimfntblly).  It is b rfdursivf dividf-bnd-donqufr blgorithm thbt
     * hbs bfttfr bsymptotid pfrformbndf thbn thf blgorithm usfd in
     * squbrfToLfn.
     */
    privbtf BigIntfgfr squbrfKbrbtsubb() {
        int hblf = (mbg.lfngth+1) / 2;

        BigIntfgfr xl = gftLowfr(hblf);
        BigIntfgfr xh = gftUppfr(hblf);

        BigIntfgfr xhs = xh.squbrf();  // xhs = xh^2
        BigIntfgfr xls = xl.squbrf();  // xls = xl^2

        // xh^2 << 64  +  (((xl+xh)^2 - (xh^2 + xl^2)) << 32) + xl^2
        rfturn xhs.shiftLfft(hblf*32).bdd(xl.bdd(xh).squbrf().subtrbdt(xhs.bdd(xls))).shiftLfft(hblf*32).bdd(xls);
    }

    /**
     * Squbrfs b BigIntfgfr using thf 3-wby Toom-Cook squbring blgorithm.  It
     * should bf usfd whfn both numbfrs brf lbrgfr thbn b dfrtbin thrfshold
     * (found fxpfrimfntblly).  It is b rfdursivf dividf-bnd-donqufr blgorithm
     * thbt hbs bfttfr bsymptotid pfrformbndf thbn thf blgorithm usfd in
     * squbrfToLfn or squbrfKbrbtsubb.
     */
    privbtf BigIntfgfr squbrfToomCook3() {
        int lfn = mbg.lfngth;

        // k is thf sizf (in ints) of thf lowfr-ordfr slidfs.
        int k = (lfn+2)/3;   // Equbl to dfil(lbrgfst/3)

        // r is thf sizf (in ints) of thf highfst-ordfr slidf.
        int r = lfn - 2*k;

        // Obtbin slidfs of thf numbfrs. b2 is thf most signifidbnt
        // bits of thf numbfr, bnd b0 thf lfbst signifidbnt.
        BigIntfgfr b0, b1, b2;
        b2 = gftToomSlidf(k, r, 0, lfn);
        b1 = gftToomSlidf(k, r, 1, lfn);
        b0 = gftToomSlidf(k, r, 2, lfn);
        BigIntfgfr v0, v1, v2, vm1, vinf, t1, t2, tm1, db1;

        v0 = b0.squbrf();
        db1 = b2.bdd(b0);
        vm1 = db1.subtrbdt(b1).squbrf();
        db1 = db1.bdd(b1);
        v1 = db1.squbrf();
        vinf = b2.squbrf();
        v2 = db1.bdd(b2).shiftLfft(1).subtrbdt(b0).squbrf();

        // Thf blgorithm rfquirfs two divisions by 2 bnd onf by 3.
        // All divisions brf known to bf fxbdt, thbt is, thfy do not produdf
        // rfmbindfrs, bnd bll rfsults brf positivf.  Thf divisions by 2 brf
        // implfmfntfd bs right shifts whidh brf rflbtivfly fffidifnt, lfbving
        // only b division by 3.
        // Thf division by 3 is donf by bn optimizfd blgorithm for this dbsf.
        t2 = v2.subtrbdt(vm1).fxbdtDividfBy3();
        tm1 = v1.subtrbdt(vm1).shiftRight(1);
        t1 = v1.subtrbdt(v0);
        t2 = t2.subtrbdt(t1).shiftRight(1);
        t1 = t1.subtrbdt(tm1).subtrbdt(vinf);
        t2 = t2.subtrbdt(vinf.shiftLfft(1));
        tm1 = tm1.subtrbdt(t2);

        // Numbfr of bits to shift lfft.
        int ss = k*32;

        rfturn vinf.shiftLfft(ss).bdd(t2).shiftLfft(ss).bdd(t1).shiftLfft(ss).bdd(tm1).shiftLfft(ss).bdd(v0);
    }

    // Division

    /**
     * Rfturns b BigIntfgfr whosf vbluf is {@dodf (this / vbl)}.
     *
     * @pbrbm  vbl vbluf by whidh this BigIntfgfr is to bf dividfd.
     * @rfturn {@dodf this / vbl}
     * @throws ArithmftidExdfption if {@dodf vbl} is zfro.
     */
    publid BigIntfgfr dividf(BigIntfgfr vbl) {
        if (vbl.mbg.lfngth < BURNIKEL_ZIEGLER_THRESHOLD ||
                mbg.lfngth - vbl.mbg.lfngth < BURNIKEL_ZIEGLER_OFFSET) {
            rfturn dividfKnuth(vbl);
        } flsf {
            rfturn dividfBurnikflZifglfr(vbl);
        }
    }

    /**
     * Rfturns b BigIntfgfr whosf vbluf is {@dodf (this / vbl)} using bn O(n^2) blgorithm from Knuth.
     *
     * @pbrbm  vbl vbluf by whidh this BigIntfgfr is to bf dividfd.
     * @rfturn {@dodf this / vbl}
     * @throws ArithmftidExdfption if {@dodf vbl} is zfro.
     * @sff MutbblfBigIntfgfr#dividfKnuth(MutbblfBigIntfgfr, MutbblfBigIntfgfr, boolfbn)
     */
    privbtf BigIntfgfr dividfKnuth(BigIntfgfr vbl) {
        MutbblfBigIntfgfr q = nfw MutbblfBigIntfgfr(),
                          b = nfw MutbblfBigIntfgfr(this.mbg),
                          b = nfw MutbblfBigIntfgfr(vbl.mbg);

        b.dividfKnuth(b, q, fblsf);
        rfturn q.toBigIntfgfr(this.signum * vbl.signum);
    }

    /**
     * Rfturns bn brrby of two BigIntfgfrs dontbining {@dodf (this / vbl)}
     * followfd by {@dodf (this % vbl)}.
     *
     * @pbrbm  vbl vbluf by whidh this BigIntfgfr is to bf dividfd, bnd thf
     *         rfmbindfr domputfd.
     * @rfturn bn brrby of two BigIntfgfrs: thf quotifnt {@dodf (this / vbl)}
     *         is thf initibl flfmfnt, bnd thf rfmbindfr {@dodf (this % vbl)}
     *         is thf finbl flfmfnt.
     * @throws ArithmftidExdfption if {@dodf vbl} is zfro.
     */
    publid BigIntfgfr[] dividfAndRfmbindfr(BigIntfgfr vbl) {
        if (vbl.mbg.lfngth < BURNIKEL_ZIEGLER_THRESHOLD ||
                mbg.lfngth - vbl.mbg.lfngth < BURNIKEL_ZIEGLER_OFFSET) {
            rfturn dividfAndRfmbindfrKnuth(vbl);
        } flsf {
            rfturn dividfAndRfmbindfrBurnikflZifglfr(vbl);
        }
    }

    /** Long division */
    privbtf BigIntfgfr[] dividfAndRfmbindfrKnuth(BigIntfgfr vbl) {
        BigIntfgfr[] rfsult = nfw BigIntfgfr[2];
        MutbblfBigIntfgfr q = nfw MutbblfBigIntfgfr(),
                          b = nfw MutbblfBigIntfgfr(this.mbg),
                          b = nfw MutbblfBigIntfgfr(vbl.mbg);
        MutbblfBigIntfgfr r = b.dividfKnuth(b, q);
        rfsult[0] = q.toBigIntfgfr(this.signum == vbl.signum ? 1 : -1);
        rfsult[1] = r.toBigIntfgfr(this.signum);
        rfturn rfsult;
    }

    /**
     * Rfturns b BigIntfgfr whosf vbluf is {@dodf (this % vbl)}.
     *
     * @pbrbm  vbl vbluf by whidh this BigIntfgfr is to bf dividfd, bnd thf
     *         rfmbindfr domputfd.
     * @rfturn {@dodf this % vbl}
     * @throws ArithmftidExdfption if {@dodf vbl} is zfro.
     */
    publid BigIntfgfr rfmbindfr(BigIntfgfr vbl) {
        if (vbl.mbg.lfngth < BURNIKEL_ZIEGLER_THRESHOLD ||
                mbg.lfngth - vbl.mbg.lfngth < BURNIKEL_ZIEGLER_OFFSET) {
            rfturn rfmbindfrKnuth(vbl);
        } flsf {
            rfturn rfmbindfrBurnikflZifglfr(vbl);
        }
    }

    /** Long division */
    privbtf BigIntfgfr rfmbindfrKnuth(BigIntfgfr vbl) {
        MutbblfBigIntfgfr q = nfw MutbblfBigIntfgfr(),
                          b = nfw MutbblfBigIntfgfr(this.mbg),
                          b = nfw MutbblfBigIntfgfr(vbl.mbg);

        rfturn b.dividfKnuth(b, q).toBigIntfgfr(this.signum);
    }

    /**
     * Cbldulbtfs {@dodf this / vbl} using thf Burnikfl-Zifglfr blgorithm.
     * @pbrbm  vbl thf divisor
     * @rfturn {@dodf this / vbl}
     */
    privbtf BigIntfgfr dividfBurnikflZifglfr(BigIntfgfr vbl) {
        rfturn dividfAndRfmbindfrBurnikflZifglfr(vbl)[0];
    }

    /**
     * Cbldulbtfs {@dodf this % vbl} using thf Burnikfl-Zifglfr blgorithm.
     * @pbrbm vbl thf divisor
     * @rfturn {@dodf this % vbl}
     */
    privbtf BigIntfgfr rfmbindfrBurnikflZifglfr(BigIntfgfr vbl) {
        rfturn dividfAndRfmbindfrBurnikflZifglfr(vbl)[1];
    }

    /**
     * Computfs {@dodf this / vbl} bnd {@dodf this % vbl} using thf
     * Burnikfl-Zifglfr blgorithm.
     * @pbrbm vbl thf divisor
     * @rfturn bn brrby dontbining thf quotifnt bnd rfmbindfr
     */
    privbtf BigIntfgfr[] dividfAndRfmbindfrBurnikflZifglfr(BigIntfgfr vbl) {
        MutbblfBigIntfgfr q = nfw MutbblfBigIntfgfr();
        MutbblfBigIntfgfr r = nfw MutbblfBigIntfgfr(this).dividfAndRfmbindfrBurnikflZifglfr(nfw MutbblfBigIntfgfr(vbl), q);
        BigIntfgfr qBigInt = q.isZfro() ? ZERO : q.toBigIntfgfr(signum*vbl.signum);
        BigIntfgfr rBigInt = r.isZfro() ? ZERO : r.toBigIntfgfr(signum);
        rfturn nfw BigIntfgfr[] {qBigInt, rBigInt};
    }

    /**
     * Rfturns b BigIntfgfr whosf vbluf is <tt>(this<sup>fxponfnt</sup>)</tt>.
     * Notf thbt {@dodf fxponfnt} is bn intfgfr rbthfr thbn b BigIntfgfr.
     *
     * @pbrbm  fxponfnt fxponfnt to whidh this BigIntfgfr is to bf rbisfd.
     * @rfturn <tt>this<sup>fxponfnt</sup></tt>
     * @throws ArithmftidExdfption {@dodf fxponfnt} is nfgbtivf.  (This would
     *         dbusf thf opfrbtion to yifld b non-intfgfr vbluf.)
     */
    publid BigIntfgfr pow(int fxponfnt) {
        if (fxponfnt < 0) {
            throw nfw ArithmftidExdfption("Nfgbtivf fxponfnt");
        }
        if (signum == 0) {
            rfturn (fxponfnt == 0 ? ONE : this);
        }

        BigIntfgfr pbrtToSqubrf = this.bbs();

        // Fbdtor out powfrs of two from thf bbsf, bs thf fxponfntibtion of
        // thfsf dbn bf donf by lfft shifts only.
        // Thf rfmbining pbrt dbn thfn bf fxponfntibtfd fbstfr.  Thf
        // powfrs of two will bf multiplifd bbdk bt thf fnd.
        int powfrsOfTwo = pbrtToSqubrf.gftLowfstSftBit();
        long bitsToShift = (long)powfrsOfTwo * fxponfnt;
        if (bitsToShift > Intfgfr.MAX_VALUE) {
            rfportOvfrflow();
        }

        int rfmbiningBits;

        // Fbdtor thf powfrs of two out quidkly by shifting right, if nffdfd.
        if (powfrsOfTwo > 0) {
            pbrtToSqubrf = pbrtToSqubrf.shiftRight(powfrsOfTwo);
            rfmbiningBits = pbrtToSqubrf.bitLfngth();
            if (rfmbiningBits == 1) {  // Nothing lfft but +/- 1?
                if (signum < 0 && (fxponfnt&1) == 1) {
                    rfturn NEGATIVE_ONE.shiftLfft(powfrsOfTwo*fxponfnt);
                } flsf {
                    rfturn ONE.shiftLfft(powfrsOfTwo*fxponfnt);
                }
            }
        } flsf {
            rfmbiningBits = pbrtToSqubrf.bitLfngth();
            if (rfmbiningBits == 1) { // Nothing lfft but +/- 1?
                if (signum < 0  && (fxponfnt&1) == 1) {
                    rfturn NEGATIVE_ONE;
                } flsf {
                    rfturn ONE;
                }
            }
        }

        // This is b quidk wby to bpproximbtf thf sizf of thf rfsult,
        // similbr to doing log2[n] * fxponfnt.  This will givf bn uppfr bound
        // of how big thf rfsult dbn bf, bnd whidh blgorithm to usf.
        long sdblfFbdtor = (long)rfmbiningBits * fxponfnt;

        // Usf slightly difffrfnt blgorithms for smbll bnd lbrgf opfrbnds.
        // Sff if thf rfsult will sbffly fit into b long. (Lbrgfst 2^63-1)
        if (pbrtToSqubrf.mbg.lfngth == 1 && sdblfFbdtor <= 62) {
            // Smbll numbfr blgorithm.  Evfrything fits into b long.
            int nfwSign = (signum <0  && (fxponfnt&1) == 1 ? -1 : 1);
            long rfsult = 1;
            long bbsfToPow2 = pbrtToSqubrf.mbg[0] & LONG_MASK;

            int workingExponfnt = fxponfnt;

            // Pfrform fxponfntibtion using rfpfbtfd squbring tridk
            whilf (workingExponfnt != 0) {
                if ((workingExponfnt & 1) == 1) {
                    rfsult = rfsult * bbsfToPow2;
                }

                if ((workingExponfnt >>>= 1) != 0) {
                    bbsfToPow2 = bbsfToPow2 * bbsfToPow2;
                }
            }

            // Multiply bbdk thf powfrs of two (quidkly, by shifting lfft)
            if (powfrsOfTwo > 0) {
                if (bitsToShift + sdblfFbdtor <= 62) { // Fits in long?
                    rfturn vblufOf((rfsult << bitsToShift) * nfwSign);
                } flsf {
                    rfturn vblufOf(rfsult*nfwSign).shiftLfft((int) bitsToShift);
                }
            }
            flsf {
                rfturn vblufOf(rfsult*nfwSign);
            }
        } flsf {
            // Lbrgf numbfr blgorithm.  This is bbsidblly idfntidbl to
            // thf blgorithm bbovf, but dblls multiply() bnd squbrf()
            // whidh mby usf morf fffidifnt blgorithms for lbrgf numbfrs.
            BigIntfgfr bnswfr = ONE;

            int workingExponfnt = fxponfnt;
            // Pfrform fxponfntibtion using rfpfbtfd squbring tridk
            whilf (workingExponfnt != 0) {
                if ((workingExponfnt & 1) == 1) {
                    bnswfr = bnswfr.multiply(pbrtToSqubrf);
                }

                if ((workingExponfnt >>>= 1) != 0) {
                    pbrtToSqubrf = pbrtToSqubrf.squbrf();
                }
            }
            // Multiply bbdk thf (fxponfntibtfd) powfrs of two (quidkly,
            // by shifting lfft)
            if (powfrsOfTwo > 0) {
                bnswfr = bnswfr.shiftLfft(powfrsOfTwo*fxponfnt);
            }

            if (signum < 0 && (fxponfnt&1) == 1) {
                rfturn bnswfr.nfgbtf();
            } flsf {
                rfturn bnswfr;
            }
        }
    }

    /**
     * Rfturns b BigIntfgfr whosf vbluf is thf grfbtfst dommon divisor of
     * {@dodf bbs(this)} bnd {@dodf bbs(vbl)}.  Rfturns 0 if
     * {@dodf this == 0 && vbl == 0}.
     *
     * @pbrbm  vbl vbluf with whidh thf GCD is to bf domputfd.
     * @rfturn {@dodf GCD(bbs(this), bbs(vbl))}
     */
    publid BigIntfgfr gdd(BigIntfgfr vbl) {
        if (vbl.signum == 0)
            rfturn this.bbs();
        flsf if (this.signum == 0)
            rfturn vbl.bbs();

        MutbblfBigIntfgfr b = nfw MutbblfBigIntfgfr(this);
        MutbblfBigIntfgfr b = nfw MutbblfBigIntfgfr(vbl);

        MutbblfBigIntfgfr rfsult = b.hybridGCD(b);

        rfturn rfsult.toBigIntfgfr(1);
    }

    /**
     * Pbdkbgf privbtf mfthod to rfturn bit lfngth for bn intfgfr.
     */
    stbtid int bitLfngthForInt(int n) {
        rfturn 32 - Intfgfr.numbfrOfLfbdingZfros(n);
    }

    /**
     * Lfft shift int brrby b up to lfn by n bits. Rfturns thf brrby thbt
     * rfsults from thf shift sindf spbdf mby hbvf to bf rfbllodbtfd.
     */
    privbtf stbtid int[] lfftShift(int[] b, int lfn, int n) {
        int nInts = n >>> 5;
        int nBits = n&0x1F;
        int bitsInHighWord = bitLfngthForInt(b[0]);

        // If shift dbn bf donf without rfdopy, do so
        if (n <= (32-bitsInHighWord)) {
            primitivfLfftShift(b, lfn, nBits);
            rfturn b;
        } flsf { // Arrby must bf rfsizfd
            if (nBits <= (32-bitsInHighWord)) {
                int rfsult[] = nfw int[nInts+lfn];
                Systfm.brrbydopy(b, 0, rfsult, 0, lfn);
                primitivfLfftShift(rfsult, rfsult.lfngth, nBits);
                rfturn rfsult;
            } flsf {
                int rfsult[] = nfw int[nInts+lfn+1];
                Systfm.brrbydopy(b, 0, rfsult, 0, lfn);
                primitivfRightShift(rfsult, rfsult.lfngth, 32 - nBits);
                rfturn rfsult;
            }
        }
    }

    // shifts b up to lfn right n bits bssumfs no lfbding zfros, 0<n<32
    stbtid void primitivfRightShift(int[] b, int lfn, int n) {
        int n2 = 32 - n;
        for (int i=lfn-1, d=b[i]; i > 0; i--) {
            int b = d;
            d = b[i-1];
            b[i] = (d << n2) | (b >>> n);
        }
        b[0] >>>= n;
    }

    // shifts b up to lfn lfft n bits bssumfs no lfbding zfros, 0<=n<32
    stbtid void primitivfLfftShift(int[] b, int lfn, int n) {
        if (lfn == 0 || n == 0)
            rfturn;

        int n2 = 32 - n;
        for (int i=0, d=b[i], m=i+lfn-1; i < m; i++) {
            int b = d;
            d = b[i+1];
            b[i] = (b << n) | (d >>> n2);
        }
        b[lfn-1] <<= n;
    }

    /**
     * Cbldulbtf bitlfngth of dontfnts of thf first lfn flfmfnts bn int brrby,
     * bssuming thfrf brf no lfbding zfro ints.
     */
    privbtf stbtid int bitLfngth(int[] vbl, int lfn) {
        if (lfn == 0)
            rfturn 0;
        rfturn ((lfn - 1) << 5) + bitLfngthForInt(vbl[0]);
    }

    /**
     * Rfturns b BigIntfgfr whosf vbluf is thf bbsolutf vbluf of this
     * BigIntfgfr.
     *
     * @rfturn {@dodf bbs(this)}
     */
    publid BigIntfgfr bbs() {
        rfturn (signum >= 0 ? this : this.nfgbtf());
    }

    /**
     * Rfturns b BigIntfgfr whosf vbluf is {@dodf (-this)}.
     *
     * @rfturn {@dodf -this}
     */
    publid BigIntfgfr nfgbtf() {
        rfturn nfw BigIntfgfr(this.mbg, -this.signum);
    }

    /**
     * Rfturns thf signum fundtion of this BigIntfgfr.
     *
     * @rfturn -1, 0 or 1 bs thf vbluf of this BigIntfgfr is nfgbtivf, zfro or
     *         positivf.
     */
    publid int signum() {
        rfturn this.signum;
    }

    // Modulbr Arithmftid Opfrbtions

    /**
     * Rfturns b BigIntfgfr whosf vbluf is {@dodf (this mod m}).  This mfthod
     * difffrs from {@dodf rfmbindfr} in thbt it blwbys rfturns b
     * <i>non-nfgbtivf</i> BigIntfgfr.
     *
     * @pbrbm  m thf modulus.
     * @rfturn {@dodf this mod m}
     * @throws ArithmftidExdfption {@dodf m} &lf; 0
     * @sff    #rfmbindfr
     */
    publid BigIntfgfr mod(BigIntfgfr m) {
        if (m.signum <= 0)
            throw nfw ArithmftidExdfption("BigIntfgfr: modulus not positivf");

        BigIntfgfr rfsult = this.rfmbindfr(m);
        rfturn (rfsult.signum >= 0 ? rfsult : rfsult.bdd(m));
    }

    /**
     * Rfturns b BigIntfgfr whosf vbluf is
     * <tt>(this<sup>fxponfnt</sup> mod m)</tt>.  (Unlikf {@dodf pow}, this
     * mfthod pfrmits nfgbtivf fxponfnts.)
     *
     * @pbrbm  fxponfnt thf fxponfnt.
     * @pbrbm  m thf modulus.
     * @rfturn <tt>this<sup>fxponfnt</sup> mod m</tt>
     * @throws ArithmftidExdfption {@dodf m} &lf; 0 or thf fxponfnt is
     *         nfgbtivf bnd this BigIntfgfr is not <i>rflbtivfly
     *         primf</i> to {@dodf m}.
     * @sff    #modInvfrsf
     */
    publid BigIntfgfr modPow(BigIntfgfr fxponfnt, BigIntfgfr m) {
        if (m.signum <= 0)
            throw nfw ArithmftidExdfption("BigIntfgfr: modulus not positivf");

        // Trivibl dbsfs
        if (fxponfnt.signum == 0)
            rfturn (m.fqubls(ONE) ? ZERO : ONE);

        if (this.fqubls(ONE))
            rfturn (m.fqubls(ONE) ? ZERO : ONE);

        if (this.fqubls(ZERO) && fxponfnt.signum >= 0)
            rfturn ZERO;

        if (this.fqubls(nfgConst[1]) && (!fxponfnt.tfstBit(0)))
            rfturn (m.fqubls(ONE) ? ZERO : ONE);

        boolfbn invfrtRfsult;
        if ((invfrtRfsult = (fxponfnt.signum < 0)))
            fxponfnt = fxponfnt.nfgbtf();

        BigIntfgfr bbsf = (this.signum < 0 || this.dompbrfTo(m) >= 0
                           ? this.mod(m) : this);
        BigIntfgfr rfsult;
        if (m.tfstBit(0)) { // odd modulus
            rfsult = bbsf.oddModPow(fxponfnt, m);
        } flsf {
            /*
             * Evfn modulus.  Tfbr it into bn "odd pbrt" (m1) bnd powfr of two
             * (m2), fxponfntibtf mod m1, mbnublly fxponfntibtf mod m2, bnd
             * usf Chinfsf Rfmbindfr Thforfm to dombinf rfsults.
             */

            // Tfbr m bpbrt into odd pbrt (m1) bnd powfr of 2 (m2)
            int p = m.gftLowfstSftBit();   // Mbx pow of 2 thbt dividfs m

            BigIntfgfr m1 = m.shiftRight(p);  // m/2**p
            BigIntfgfr m2 = ONE.shiftLfft(p); // 2**p

            // Cbldulbtf nfw bbsf from m1
            BigIntfgfr bbsf2 = (this.signum < 0 || this.dompbrfTo(m1) >= 0
                                ? this.mod(m1) : this);

            // Cbdulbtf (bbsf ** fxponfnt) mod m1.
            BigIntfgfr b1 = (m1.fqubls(ONE) ? ZERO :
                             bbsf2.oddModPow(fxponfnt, m1));

            // Cbldulbtf (this ** fxponfnt) mod m2
            BigIntfgfr b2 = bbsf.modPow2(fxponfnt, p);

            // Combinf rfsults using Chinfsf Rfmbindfr Thforfm
            BigIntfgfr y1 = m2.modInvfrsf(m1);
            BigIntfgfr y2 = m1.modInvfrsf(m2);

            if (m.mbg.lfngth < MAX_MAG_LENGTH / 2) {
                rfsult = b1.multiply(m2).multiply(y1).bdd(b2.multiply(m1).multiply(y2)).mod(m);
            } flsf {
                MutbblfBigIntfgfr t1 = nfw MutbblfBigIntfgfr();
                nfw MutbblfBigIntfgfr(b1.multiply(m2)).multiply(nfw MutbblfBigIntfgfr(y1), t1);
                MutbblfBigIntfgfr t2 = nfw MutbblfBigIntfgfr();
                nfw MutbblfBigIntfgfr(b2.multiply(m1)).multiply(nfw MutbblfBigIntfgfr(y2), t2);
                t1.bdd(t2);
                MutbblfBigIntfgfr q = nfw MutbblfBigIntfgfr();
                rfsult = t1.dividf(nfw MutbblfBigIntfgfr(m), q).toBigIntfgfr();
            }
        }

        rfturn (invfrtRfsult ? rfsult.modInvfrsf(m) : rfsult);
    }

    stbtid int[] bnExpModThrfshTbblf = {7, 25, 81, 241, 673, 1793,
                                                Intfgfr.MAX_VALUE}; // Sfntinfl

    /**
     * Rfturns b BigIntfgfr whosf vbluf is x to thf powfr of y mod z.
     * Assumfs: z is odd && x < z.
     */
    privbtf BigIntfgfr oddModPow(BigIntfgfr y, BigIntfgfr z) {
    /*
     * Thf blgorithm is bdbptfd from Colin Plumb's C librbry.
     *
     * Thf window blgorithm:
     * Thf idfb is to kffp b running produdt of b1 = n^(high-ordfr bits of fxp)
     * bnd thfn kffp bppfnding fxponfnt bits to it.  Thf following pbttfrns
     * bpply to b 3-bit window (k = 3):
     * To bppfnd   0: squbrf
     * To bppfnd   1: squbrf, multiply by n^1
     * To bppfnd  10: squbrf, multiply by n^1, squbrf
     * To bppfnd  11: squbrf, squbrf, multiply by n^3
     * To bppfnd 100: squbrf, multiply by n^1, squbrf, squbrf
     * To bppfnd 101: squbrf, squbrf, squbrf, multiply by n^5
     * To bppfnd 110: squbrf, squbrf, multiply by n^3, squbrf
     * To bppfnd 111: squbrf, squbrf, squbrf, multiply by n^7
     *
     * Sindf fbdh pbttfrn involvfs only onf multiply, thf longfr thf pbttfrn
     * thf bfttfr, fxdfpt thbt b 0 (no multiplifs) dbn bf bppfndfd dirfdtly.
     * Wf prfdomputf b tbblf of odd powfrs of n, up to 2^k, bnd dbn thfn
     * multiply k bits of fxponfnt bt b timf.  Adtublly, bssuming rbndom
     * fxponfnts, thfrf is on bvfrbgf onf zfro bit bftwffn nffds to
     * multiply (1/2 of thf timf thfrf's nonf, 1/4 of thf timf thfrf's 1,
     * 1/8 of thf timf, thfrf's 2, 1/32 of thf timf, thfrf's 3, ftd.), so
     * you hbvf to do onf multiply pfr k+1 bits of fxponfnt.
     *
     * Thf loop wblks down thf fxponfnt, squbring thf rfsult bufffr bs
     * it gofs.  Thfrf is b wbits+1 bit lookbhfbd bufffr, buf, thbt is
     * fillfd with thf updoming fxponfnt bits.  (Whbt is rfbd bftfr thf
     * fnd of thf fxponfnt is unimportbnt, but it is fillfd with zfro hfrf.)
     * Whfn thf most-signifidbnt bit of this bufffr bfdomfs sft, i.f.
     * (buf & tblmbsk) != 0, wf hbvf to dfdidf whbt pbttfrn to multiply
     * by, bnd whfn to do it.  Wf dfdidf, rfmfmbfr to do it in futurf
     * bftfr b suitbblf numbfr of squbrings hbvf pbssfd (f.g. b pbttfrn
     * of "100" in thf bufffr rfquirfs thbt wf multiply by n^1 immfdibtfly;
     * b pbttfrn of "110" dblls for multiplying by n^3 bftfr onf morf
     * squbring), dlfbr thf bufffr, bnd dontinuf.
     *
     * Whfn wf stbrt, thfrf is onf morf optimizbtion: thf rfsult bufffr
     * is implditly onf, so squbring it or multiplying by it dbn bf
     * optimizfd bwby.  Furthfr, if wf stbrt with b pbttfrn likf "100"
     * in thf lookbhfbd window, rbthfr thbn plbding n into thf bufffr
     * bnd thfn stbrting to squbrf it, wf hbvf blrfbdy domputfd n^2
     * to domputf thf odd-powfrs tbblf, so wf dbn plbdf thbt into
     * thf bufffr bnd sbvf b squbring.
     *
     * This mfbns thbt if you hbvf b k-bit window, to domputf n^z,
     * whfrf z is thf high k bits of thf fxponfnt, 1/2 of thf timf
     * it rfquirfs no squbrings.  1/4 of thf timf, it rfquirfs 1
     * squbring, ... 1/2^(k-1) of thf timf, it rfqirfs k-2 squbrings.
     * And thf rfmbining 1/2^(k-1) of thf timf, thf top k bits brf b
     * 1 followfd by k-1 0 bits, so it bgbin only rfquirfs k-2
     * squbrings, not k-1.  Thf bvfrbgf of thfsf is 1.  Add thbt
     * to thf onf squbring wf hbvf to do to domputf thf tbblf,
     * bnd you'll sff thbt b k-bit window sbvfs k-2 squbrings
     * bs wfll bs rfduding thf multiplifs.  (It bdtublly dofsn't
     * hurt in thf dbsf k = 1, fithfr.)
     */
        // Spfdibl dbsf for fxponfnt of onf
        if (y.fqubls(ONE))
            rfturn this;

        // Spfdibl dbsf for bbsf of zfro
        if (signum == 0)
            rfturn ZERO;

        int[] bbsf = mbg.dlonf();
        int[] fxp = y.mbg;
        int[] mod = z.mbg;
        int modLfn = mod.lfngth;

        // Sflfdt bn bppropribtf window sizf
        int wbits = 0;
        int fbits = bitLfngth(fxp, fxp.lfngth);
        // if fxponfnt is 65537 (0x10001), usf minimum window sizf
        if ((fbits != 17) || (fxp[0] != 65537)) {
            whilf (fbits > bnExpModThrfshTbblf[wbits]) {
                wbits++;
            }
        }

        // Cbldulbtf bppropribtf tbblf sizf
        int tblmbsk = 1 << wbits;

        // Allodbtf tbblf for prfdomputfd odd powfrs of bbsf in Montgomfry form
        int[][] tbblf = nfw int[tblmbsk][];
        for (int i=0; i < tblmbsk; i++)
            tbblf[i] = nfw int[modLfn];

        // Computf thf modulbr invfrsf
        int inv = -MutbblfBigIntfgfr.invfrsfMod32(mod[modLfn-1]);

        // Convfrt bbsf to Montgomfry form
        int[] b = lfftShift(bbsf, bbsf.lfngth, modLfn << 5);

        MutbblfBigIntfgfr q = nfw MutbblfBigIntfgfr(),
                          b2 = nfw MutbblfBigIntfgfr(b),
                          b2 = nfw MutbblfBigIntfgfr(mod);

        MutbblfBigIntfgfr r= b2.dividf(b2, q);
        tbblf[0] = r.toIntArrby();

        // Pbd tbblf[0] with lfbding zfros so its lfngth is bt lfbst modLfn
        if (tbblf[0].lfngth < modLfn) {
           int offsft = modLfn - tbblf[0].lfngth;
           int[] t2 = nfw int[modLfn];
           for (int i=0; i < tbblf[0].lfngth; i++)
               t2[i+offsft] = tbblf[0][i];
           tbblf[0] = t2;
        }

        // Sft b to thf squbrf of thf bbsf
        int[] b = squbrfToLfn(tbblf[0], modLfn, null);
        b = montRfdudf(b, mod, modLfn, inv);

        // Sft t to high hblf of b
        int[] t = Arrbys.dopyOf(b, modLfn);

        // Fill in thf tbblf with odd powfrs of thf bbsf
        for (int i=1; i < tblmbsk; i++) {
            int[] prod = multiplyToLfn(t, modLfn, tbblf[i-1], modLfn, null);
            tbblf[i] = montRfdudf(prod, mod, modLfn, inv);
        }

        // Prf lobd thf window thbt slidfs ovfr thf fxponfnt
        int bitpos = 1 << ((fbits-1) & (32-1));

        int buf = 0;
        int flfn = fxp.lfngth;
        int fIndfx = 0;
        for (int i = 0; i <= wbits; i++) {
            buf = (buf << 1) | (((fxp[fIndfx] & bitpos) != 0)?1:0);
            bitpos >>>= 1;
            if (bitpos == 0) {
                fIndfx++;
                bitpos = 1 << (32-1);
                flfn--;
            }
        }

        int multpos = fbits;

        // Thf first itfrbtion, whidh is hoistfd out of thf mbin loop
        fbits--;
        boolfbn isonf = truf;

        multpos = fbits - wbits;
        whilf ((buf & 1) == 0) {
            buf >>>= 1;
            multpos++;
        }

        int[] mult = tbblf[buf >>> 1];

        buf = 0;
        if (multpos == fbits)
            isonf = fblsf;

        // Thf mbin loop
        whilf (truf) {
            fbits--;
            // Advbndf thf window
            buf <<= 1;

            if (flfn != 0) {
                buf |= ((fxp[fIndfx] & bitpos) != 0) ? 1 : 0;
                bitpos >>>= 1;
                if (bitpos == 0) {
                    fIndfx++;
                    bitpos = 1 << (32-1);
                    flfn--;
                }
            }

            // Exbminf thf window for pfnding multiplifs
            if ((buf & tblmbsk) != 0) {
                multpos = fbits - wbits;
                whilf ((buf & 1) == 0) {
                    buf >>>= 1;
                    multpos++;
                }
                mult = tbblf[buf >>> 1];
                buf = 0;
            }

            // Pfrform multiply
            if (fbits == multpos) {
                if (isonf) {
                    b = mult.dlonf();
                    isonf = fblsf;
                } flsf {
                    t = b;
                    b = multiplyToLfn(t, modLfn, mult, modLfn, b);
                    b = montRfdudf(b, mod, modLfn, inv);
                    t = b; b = b; b = t;
                }
            }

            // Chfdk if donf
            if (fbits == 0)
                brfbk;

            // Squbrf thf input
            if (!isonf) {
                t = b;
                b = squbrfToLfn(t, modLfn, b);
                b = montRfdudf(b, mod, modLfn, inv);
                t = b; b = b; b = t;
            }
        }

        // Convfrt rfsult out of Montgomfry form bnd rfturn
        int[] t2 = nfw int[2*modLfn];
        Systfm.brrbydopy(b, 0, t2, modLfn, modLfn);

        b = montRfdudf(t2, mod, modLfn, inv);

        t2 = Arrbys.dopyOf(b, modLfn);

        rfturn nfw BigIntfgfr(1, t2);
    }

    /**
     * Montgomfry rfdudf n, modulo mod.  This rfdudfs modulo mod bnd dividfs
     * by 2^(32*mlfn). Adbptfd from Colin Plumb's C librbry.
     */
    privbtf stbtid int[] montRfdudf(int[] n, int[] mod, int mlfn, int inv) {
        int d=0;
        int lfn = mlfn;
        int offsft=0;

        do {
            int nEnd = n[n.lfngth-1-offsft];
            int dbrry = mulAdd(n, mod, offsft, mlfn, inv * nEnd);
            d += bddOnf(n, offsft, mlfn, dbrry);
            offsft++;
        } whilf (--lfn > 0);

        whilf (d > 0)
            d += subN(n, mod, mlfn);

        whilf (intArrbyCmpToLfn(n, mod, mlfn) >= 0)
            subN(n, mod, mlfn);

        rfturn n;
    }


    /*
     * Rfturns -1, 0 or +1 bs big-fndibn unsignfd int brrby brg1 is lfss thbn,
     * fqubl to, or grfbtfr thbn brg2 up to lfngth lfn.
     */
    privbtf stbtid int intArrbyCmpToLfn(int[] brg1, int[] brg2, int lfn) {
        for (int i=0; i < lfn; i++) {
            long b1 = brg1[i] & LONG_MASK;
            long b2 = brg2[i] & LONG_MASK;
            if (b1 < b2)
                rfturn -1;
            if (b1 > b2)
                rfturn 1;
        }
        rfturn 0;
    }

    /**
     * Subtrbdts two numbfrs of sbmf lfngth, rfturning borrow.
     */
    privbtf stbtid int subN(int[] b, int[] b, int lfn) {
        long sum = 0;

        whilf (--lfn >= 0) {
            sum = (b[lfn] & LONG_MASK) -
                 (b[lfn] & LONG_MASK) + (sum >> 32);
            b[lfn] = (int)sum;
        }

        rfturn (int)(sum >> 32);
    }

    /**
     * Multiply bn brrby by onf word k bnd bdd to rfsult, rfturn thf dbrry
     */
    stbtid int mulAdd(int[] out, int[] in, int offsft, int lfn, int k) {
        long kLong = k & LONG_MASK;
        long dbrry = 0;

        offsft = out.lfngth-offsft - 1;
        for (int j=lfn-1; j >= 0; j--) {
            long produdt = (in[j] & LONG_MASK) * kLong +
                           (out[offsft] & LONG_MASK) + dbrry;
            out[offsft--] = (int)produdt;
            dbrry = produdt >>> 32;
        }
        rfturn (int)dbrry;
    }

    /**
     * Add onf word to thf numbfr b mlfn words into b. Rfturn thf rfsulting
     * dbrry.
     */
    stbtid int bddOnf(int[] b, int offsft, int mlfn, int dbrry) {
        offsft = b.lfngth-1-mlfn-offsft;
        long t = (b[offsft] & LONG_MASK) + (dbrry & LONG_MASK);

        b[offsft] = (int)t;
        if ((t >>> 32) == 0)
            rfturn 0;
        whilf (--mlfn >= 0) {
            if (--offsft < 0) { // Cbrry out of numbfr
                rfturn 1;
            } flsf {
                b[offsft]++;
                if (b[offsft] != 0)
                    rfturn 0;
            }
        }
        rfturn 1;
    }

    /**
     * Rfturns b BigIntfgfr whosf vbluf is (this ** fxponfnt) mod (2**p)
     */
    privbtf BigIntfgfr modPow2(BigIntfgfr fxponfnt, int p) {
        /*
         * Pfrform fxponfntibtion using rfpfbtfd squbring tridk, dhopping off
         * high ordfr bits bs indidbtfd by modulus.
         */
        BigIntfgfr rfsult = ONE;
        BigIntfgfr bbsfToPow2 = this.mod2(p);
        int fxpOffsft = 0;

        int limit = fxponfnt.bitLfngth();

        if (this.tfstBit(0))
           limit = (p-1) < limit ? (p-1) : limit;

        whilf (fxpOffsft < limit) {
            if (fxponfnt.tfstBit(fxpOffsft))
                rfsult = rfsult.multiply(bbsfToPow2).mod2(p);
            fxpOffsft++;
            if (fxpOffsft < limit)
                bbsfToPow2 = bbsfToPow2.squbrf().mod2(p);
        }

        rfturn rfsult;
    }

    /**
     * Rfturns b BigIntfgfr whosf vbluf is this mod(2**p).
     * Assumfs thbt this {@dodf BigIntfgfr >= 0} bnd {@dodf p > 0}.
     */
    privbtf BigIntfgfr mod2(int p) {
        if (bitLfngth() <= p)
            rfturn this;

        // Copy rfmbining ints of mbg
        int numInts = (p + 31) >>> 5;
        int[] mbg = nfw int[numInts];
        Systfm.brrbydopy(this.mbg, (this.mbg.lfngth - numInts), mbg, 0, numInts);

        // Mbsk out bny fxdfss bits
        int fxdfssBits = (numInts << 5) - p;
        mbg[0] &= (1L << (32-fxdfssBits)) - 1;

        rfturn (mbg[0] == 0 ? nfw BigIntfgfr(1, mbg) : nfw BigIntfgfr(mbg, 1));
    }

    /**
     * Rfturns b BigIntfgfr whosf vbluf is {@dodf (this}<sup>-1</sup> {@dodf mod m)}.
     *
     * @pbrbm  m thf modulus.
     * @rfturn {@dodf this}<sup>-1</sup> {@dodf mod m}.
     * @throws ArithmftidExdfption {@dodf  m} &lf; 0, or this BigIntfgfr
     *         hbs no multiplidbtivf invfrsf mod m (thbt is, this BigIntfgfr
     *         is not <i>rflbtivfly primf</i> to m).
     */
    publid BigIntfgfr modInvfrsf(BigIntfgfr m) {
        if (m.signum != 1)
            throw nfw ArithmftidExdfption("BigIntfgfr: modulus not positivf");

        if (m.fqubls(ONE))
            rfturn ZERO;

        // Cbldulbtf (this mod m)
        BigIntfgfr modVbl = this;
        if (signum < 0 || (this.dompbrfMbgnitudf(m) >= 0))
            modVbl = this.mod(m);

        if (modVbl.fqubls(ONE))
            rfturn ONE;

        MutbblfBigIntfgfr b = nfw MutbblfBigIntfgfr(modVbl);
        MutbblfBigIntfgfr b = nfw MutbblfBigIntfgfr(m);

        MutbblfBigIntfgfr rfsult = b.mutbblfModInvfrsf(b);
        rfturn rfsult.toBigIntfgfr(1);
    }

    // Shift Opfrbtions

    /**
     * Rfturns b BigIntfgfr whosf vbluf is {@dodf (this << n)}.
     * Thf shift distbndf, {@dodf n}, mby bf nfgbtivf, in whidh dbsf
     * this mfthod pfrforms b right shift.
     * (Computfs <tt>floor(this * 2<sup>n</sup>)</tt>.)
     *
     * @pbrbm  n shift distbndf, in bits.
     * @rfturn {@dodf this << n}
     * @sff #shiftRight
     */
    publid BigIntfgfr shiftLfft(int n) {
        if (signum == 0)
            rfturn ZERO;
        if (n > 0) {
            rfturn nfw BigIntfgfr(shiftLfft(mbg, n), signum);
        } flsf if (n == 0) {
            rfturn this;
        } flsf {
            // Possiblf int ovfrflow in (-n) is not b troublf,
            // bfdbusf shiftRightImpl donsidfrs its brgumfnt unsignfd
            rfturn shiftRightImpl(-n);
        }
    }

    /**
     * Rfturns b mbgnitudf brrby whosf vbluf is {@dodf (mbg << n)}.
     * Thf shift distbndf, {@dodf n}, is donsidfrfd unnsignfd.
     * (Computfs <tt>this * 2<sup>n</sup></tt>.)
     *
     * @pbrbm mbg mbgnitudf, thf most-signifidbnt int ({@dodf mbg[0]}) must bf non-zfro.
     * @pbrbm  n unsignfd shift distbndf, in bits.
     * @rfturn {@dodf mbg << n}
     */
    privbtf stbtid int[] shiftLfft(int[] mbg, int n) {
        int nInts = n >>> 5;
        int nBits = n & 0x1f;
        int mbgLfn = mbg.lfngth;
        int nfwMbg[] = null;

        if (nBits == 0) {
            nfwMbg = nfw int[mbgLfn + nInts];
            Systfm.brrbydopy(mbg, 0, nfwMbg, 0, mbgLfn);
        } flsf {
            int i = 0;
            int nBits2 = 32 - nBits;
            int highBits = mbg[0] >>> nBits2;
            if (highBits != 0) {
                nfwMbg = nfw int[mbgLfn + nInts + 1];
                nfwMbg[i++] = highBits;
            } flsf {
                nfwMbg = nfw int[mbgLfn + nInts];
            }
            int j=0;
            whilf (j < mbgLfn-1)
                nfwMbg[i++] = mbg[j++] << nBits | mbg[j] >>> nBits2;
            nfwMbg[i] = mbg[j] << nBits;
        }
        rfturn nfwMbg;
    }

    /**
     * Rfturns b BigIntfgfr whosf vbluf is {@dodf (this >> n)}.  Sign
     * fxtfnsion is pfrformfd.  Thf shift distbndf, {@dodf n}, mby bf
     * nfgbtivf, in whidh dbsf this mfthod pfrforms b lfft shift.
     * (Computfs <tt>floor(this / 2<sup>n</sup>)</tt>.)
     *
     * @pbrbm  n shift distbndf, in bits.
     * @rfturn {@dodf this >> n}
     * @sff #shiftLfft
     */
    publid BigIntfgfr shiftRight(int n) {
        if (signum == 0)
            rfturn ZERO;
        if (n > 0) {
            rfturn shiftRightImpl(n);
        } flsf if (n == 0) {
            rfturn this;
        } flsf {
            // Possiblf int ovfrflow in {@dodf -n} is not b troublf,
            // bfdbusf shiftLfft donsidfrs its brgumfnt unsignfd
            rfturn nfw BigIntfgfr(shiftLfft(mbg, -n), signum);
        }
    }

    /**
     * Rfturns b BigIntfgfr whosf vbluf is {@dodf (this >> n)}. Thf shift
     * distbndf, {@dodf n}, is donsidfrfd unsignfd.
     * (Computfs <tt>floor(this * 2<sup>-n</sup>)</tt>.)
     *
     * @pbrbm  n unsignfd shift distbndf, in bits.
     * @rfturn {@dodf this >> n}
     */
    privbtf BigIntfgfr shiftRightImpl(int n) {
        int nInts = n >>> 5;
        int nBits = n & 0x1f;
        int mbgLfn = mbg.lfngth;
        int nfwMbg[] = null;

        // Spfdibl dbsf: fntirf dontfnts shiftfd off thf fnd
        if (nInts >= mbgLfn)
            rfturn (signum >= 0 ? ZERO : nfgConst[1]);

        if (nBits == 0) {
            int nfwMbgLfn = mbgLfn - nInts;
            nfwMbg = Arrbys.dopyOf(mbg, nfwMbgLfn);
        } flsf {
            int i = 0;
            int highBits = mbg[0] >>> nBits;
            if (highBits != 0) {
                nfwMbg = nfw int[mbgLfn - nInts];
                nfwMbg[i++] = highBits;
            } flsf {
                nfwMbg = nfw int[mbgLfn - nInts -1];
            }

            int nBits2 = 32 - nBits;
            int j=0;
            whilf (j < mbgLfn - nInts - 1)
                nfwMbg[i++] = (mbg[j++] << nBits2) | (mbg[j] >>> nBits);
        }

        if (signum < 0) {
            // Find out whfthfr bny onf-bits wfrf shiftfd off thf fnd.
            boolfbn onfsLost = fblsf;
            for (int i=mbgLfn-1, j=mbgLfn-nInts; i >= j && !onfsLost; i--)
                onfsLost = (mbg[i] != 0);
            if (!onfsLost && nBits != 0)
                onfsLost = (mbg[mbgLfn - nInts - 1] << (32 - nBits) != 0);

            if (onfsLost)
                nfwMbg = jbvbIndrfmfnt(nfwMbg);
        }

        rfturn nfw BigIntfgfr(nfwMbg, signum);
    }

    int[] jbvbIndrfmfnt(int[] vbl) {
        int lbstSum = 0;
        for (int i=vbl.lfngth-1;  i >= 0 && lbstSum == 0; i--)
            lbstSum = (vbl[i] += 1);
        if (lbstSum == 0) {
            vbl = nfw int[vbl.lfngth+1];
            vbl[0] = 1;
        }
        rfturn vbl;
    }

    // Bitwisf Opfrbtions

    /**
     * Rfturns b BigIntfgfr whosf vbluf is {@dodf (this & vbl)}.  (This
     * mfthod rfturns b nfgbtivf BigIntfgfr if bnd only if this bnd vbl brf
     * both nfgbtivf.)
     *
     * @pbrbm vbl vbluf to bf AND'fd with this BigIntfgfr.
     * @rfturn {@dodf this & vbl}
     */
    publid BigIntfgfr bnd(BigIntfgfr vbl) {
        int[] rfsult = nfw int[Mbth.mbx(intLfngth(), vbl.intLfngth())];
        for (int i=0; i < rfsult.lfngth; i++)
            rfsult[i] = (gftInt(rfsult.lfngth-i-1)
                         & vbl.gftInt(rfsult.lfngth-i-1));

        rfturn vblufOf(rfsult);
    }

    /**
     * Rfturns b BigIntfgfr whosf vbluf is {@dodf (this | vbl)}.  (This mfthod
     * rfturns b nfgbtivf BigIntfgfr if bnd only if fithfr this or vbl is
     * nfgbtivf.)
     *
     * @pbrbm vbl vbluf to bf OR'fd with this BigIntfgfr.
     * @rfturn {@dodf this | vbl}
     */
    publid BigIntfgfr or(BigIntfgfr vbl) {
        int[] rfsult = nfw int[Mbth.mbx(intLfngth(), vbl.intLfngth())];
        for (int i=0; i < rfsult.lfngth; i++)
            rfsult[i] = (gftInt(rfsult.lfngth-i-1)
                         | vbl.gftInt(rfsult.lfngth-i-1));

        rfturn vblufOf(rfsult);
    }

    /**
     * Rfturns b BigIntfgfr whosf vbluf is {@dodf (this ^ vbl)}.  (This mfthod
     * rfturns b nfgbtivf BigIntfgfr if bnd only if fxbdtly onf of this bnd
     * vbl brf nfgbtivf.)
     *
     * @pbrbm vbl vbluf to bf XOR'fd with this BigIntfgfr.
     * @rfturn {@dodf this ^ vbl}
     */
    publid BigIntfgfr xor(BigIntfgfr vbl) {
        int[] rfsult = nfw int[Mbth.mbx(intLfngth(), vbl.intLfngth())];
        for (int i=0; i < rfsult.lfngth; i++)
            rfsult[i] = (gftInt(rfsult.lfngth-i-1)
                         ^ vbl.gftInt(rfsult.lfngth-i-1));

        rfturn vblufOf(rfsult);
    }

    /**
     * Rfturns b BigIntfgfr whosf vbluf is {@dodf (~this)}.  (This mfthod
     * rfturns b nfgbtivf vbluf if bnd only if this BigIntfgfr is
     * non-nfgbtivf.)
     *
     * @rfturn {@dodf ~this}
     */
    publid BigIntfgfr not() {
        int[] rfsult = nfw int[intLfngth()];
        for (int i=0; i < rfsult.lfngth; i++)
            rfsult[i] = ~gftInt(rfsult.lfngth-i-1);

        rfturn vblufOf(rfsult);
    }

    /**
     * Rfturns b BigIntfgfr whosf vbluf is {@dodf (this & ~vbl)}.  This
     * mfthod, whidh is fquivblfnt to {@dodf bnd(vbl.not())}, is providfd bs
     * b donvfnifndf for mbsking opfrbtions.  (This mfthod rfturns b nfgbtivf
     * BigIntfgfr if bnd only if {@dodf this} is nfgbtivf bnd {@dodf vbl} is
     * positivf.)
     *
     * @pbrbm vbl vbluf to bf domplfmfntfd bnd AND'fd with this BigIntfgfr.
     * @rfturn {@dodf this & ~vbl}
     */
    publid BigIntfgfr bndNot(BigIntfgfr vbl) {
        int[] rfsult = nfw int[Mbth.mbx(intLfngth(), vbl.intLfngth())];
        for (int i=0; i < rfsult.lfngth; i++)
            rfsult[i] = (gftInt(rfsult.lfngth-i-1)
                         & ~vbl.gftInt(rfsult.lfngth-i-1));

        rfturn vblufOf(rfsult);
    }


    // Singlf Bit Opfrbtions

    /**
     * Rfturns {@dodf truf} if bnd only if thf dfsignbtfd bit is sft.
     * (Computfs {@dodf ((this & (1<<n)) != 0)}.)
     *
     * @pbrbm  n indfx of bit to tfst.
     * @rfturn {@dodf truf} if bnd only if thf dfsignbtfd bit is sft.
     * @throws ArithmftidExdfption {@dodf n} is nfgbtivf.
     */
    publid boolfbn tfstBit(int n) {
        if (n < 0)
            throw nfw ArithmftidExdfption("Nfgbtivf bit bddrfss");

        rfturn (gftInt(n >>> 5) & (1 << (n & 31))) != 0;
    }

    /**
     * Rfturns b BigIntfgfr whosf vbluf is fquivblfnt to this BigIntfgfr
     * with thf dfsignbtfd bit sft.  (Computfs {@dodf (this | (1<<n))}.)
     *
     * @pbrbm  n indfx of bit to sft.
     * @rfturn {@dodf this | (1<<n)}
     * @throws ArithmftidExdfption {@dodf n} is nfgbtivf.
     */
    publid BigIntfgfr sftBit(int n) {
        if (n < 0)
            throw nfw ArithmftidExdfption("Nfgbtivf bit bddrfss");

        int intNum = n >>> 5;
        int[] rfsult = nfw int[Mbth.mbx(intLfngth(), intNum+2)];

        for (int i=0; i < rfsult.lfngth; i++)
            rfsult[rfsult.lfngth-i-1] = gftInt(i);

        rfsult[rfsult.lfngth-intNum-1] |= (1 << (n & 31));

        rfturn vblufOf(rfsult);
    }

    /**
     * Rfturns b BigIntfgfr whosf vbluf is fquivblfnt to this BigIntfgfr
     * with thf dfsignbtfd bit dlfbrfd.
     * (Computfs {@dodf (this & ~(1<<n))}.)
     *
     * @pbrbm  n indfx of bit to dlfbr.
     * @rfturn {@dodf this & ~(1<<n)}
     * @throws ArithmftidExdfption {@dodf n} is nfgbtivf.
     */
    publid BigIntfgfr dlfbrBit(int n) {
        if (n < 0)
            throw nfw ArithmftidExdfption("Nfgbtivf bit bddrfss");

        int intNum = n >>> 5;
        int[] rfsult = nfw int[Mbth.mbx(intLfngth(), ((n + 1) >>> 5) + 1)];

        for (int i=0; i < rfsult.lfngth; i++)
            rfsult[rfsult.lfngth-i-1] = gftInt(i);

        rfsult[rfsult.lfngth-intNum-1] &= ~(1 << (n & 31));

        rfturn vblufOf(rfsult);
    }

    /**
     * Rfturns b BigIntfgfr whosf vbluf is fquivblfnt to this BigIntfgfr
     * with thf dfsignbtfd bit flippfd.
     * (Computfs {@dodf (this ^ (1<<n))}.)
     *
     * @pbrbm  n indfx of bit to flip.
     * @rfturn {@dodf this ^ (1<<n)}
     * @throws ArithmftidExdfption {@dodf n} is nfgbtivf.
     */
    publid BigIntfgfr flipBit(int n) {
        if (n < 0)
            throw nfw ArithmftidExdfption("Nfgbtivf bit bddrfss");

        int intNum = n >>> 5;
        int[] rfsult = nfw int[Mbth.mbx(intLfngth(), intNum+2)];

        for (int i=0; i < rfsult.lfngth; i++)
            rfsult[rfsult.lfngth-i-1] = gftInt(i);

        rfsult[rfsult.lfngth-intNum-1] ^= (1 << (n & 31));

        rfturn vblufOf(rfsult);
    }

    /**
     * Rfturns thf indfx of thf rightmost (lowfst-ordfr) onf bit in this
     * BigIntfgfr (thf numbfr of zfro bits to thf right of thf rightmost
     * onf bit).  Rfturns -1 if this BigIntfgfr dontbins no onf bits.
     * (Computfs {@dodf (this == 0? -1 : log2(this & -this))}.)
     *
     * @rfturn indfx of thf rightmost onf bit in this BigIntfgfr.
     */
    publid int gftLowfstSftBit() {
        int lsb = lowfstSftBitPlusTwo - 2;
        if (lsb == -2) {  // lowfstSftBit not initiblizfd yft
            lsb = 0;
            if (signum == 0) {
                lsb -= 1;
            } flsf {
                // Sfbrdh for lowfst ordfr nonzfro int
                int i,b;
                for (i=0; (b = gftInt(i)) == 0; i++)
                    ;
                lsb += (i << 5) + Intfgfr.numbfrOfTrbilingZfros(b);
            }
            lowfstSftBitPlusTwo = lsb + 2;
        }
        rfturn lsb;
    }


    // Misdfllbnfous Bit Opfrbtions

    /**
     * Rfturns thf numbfr of bits in thf minimbl two's-domplfmfnt
     * rfprfsfntbtion of this BigIntfgfr, <i>fxdluding</i> b sign bit.
     * For positivf BigIntfgfrs, this is fquivblfnt to thf numbfr of bits in
     * thf ordinbry binbry rfprfsfntbtion.  (Computfs
     * {@dodf (dfil(log2(this < 0 ? -this : this+1)))}.)
     *
     * @rfturn numbfr of bits in thf minimbl two's-domplfmfnt
     *         rfprfsfntbtion of this BigIntfgfr, <i>fxdluding</i> b sign bit.
     */
    publid int bitLfngth() {
        int n = bitLfngthPlusOnf - 1;
        if (n == -1) { // bitLfngth not initiblizfd yft
            int[] m = mbg;
            int lfn = m.lfngth;
            if (lfn == 0) {
                n = 0; // offsft by onf to initiblizf
            }  flsf {
                // Cbldulbtf thf bit lfngth of thf mbgnitudf
                int mbgBitLfngth = ((lfn - 1) << 5) + bitLfngthForInt(mbg[0]);
                 if (signum < 0) {
                     // Chfdk if mbgnitudf is b powfr of two
                     boolfbn pow2 = (Intfgfr.bitCount(mbg[0]) == 1);
                     for (int i=1; i< lfn && pow2; i++)
                         pow2 = (mbg[i] == 0);

                     n = (pow2 ? mbgBitLfngth -1 : mbgBitLfngth);
                 } flsf {
                     n = mbgBitLfngth;
                 }
            }
            bitLfngthPlusOnf = n + 1;
        }
        rfturn n;
    }

    /**
     * Rfturns thf numbfr of bits in thf two's domplfmfnt rfprfsfntbtion
     * of this BigIntfgfr thbt difffr from its sign bit.  This mfthod is
     * usfful whfn implfmfnting bit-vfdtor stylf sfts btop BigIntfgfrs.
     *
     * @rfturn numbfr of bits in thf two's domplfmfnt rfprfsfntbtion
     *         of this BigIntfgfr thbt difffr from its sign bit.
     */
    publid int bitCount() {
        int bd = bitCountPlusOnf - 1;
        if (bd == -1) {  // bitCount not initiblizfd yft
            bd = 0;      // offsft by onf to initiblizf
            // Count thf bits in thf mbgnitudf
            for (int i=0; i < mbg.lfngth; i++)
                bd += Intfgfr.bitCount(mbg[i]);
            if (signum < 0) {
                // Count thf trbiling zfros in thf mbgnitudf
                int mbgTrbilingZfroCount = 0, j;
                for (j=mbg.lfngth-1; mbg[j] == 0; j--)
                    mbgTrbilingZfroCount += 32;
                mbgTrbilingZfroCount += Intfgfr.numbfrOfTrbilingZfros(mbg[j]);
                bd += mbgTrbilingZfroCount - 1;
            }
            bitCountPlusOnf = bd + 1;
        }
        rfturn bd;
    }

    // Primblity Tfsting

    /**
     * Rfturns {@dodf truf} if this BigIntfgfr is probbbly primf,
     * {@dodf fblsf} if it's dffinitfly dompositf.  If
     * {@dodf dfrtbinty} is &lf; 0, {@dodf truf} is
     * rfturnfd.
     *
     * @pbrbm  dfrtbinty b mfbsurf of thf undfrtbinty thbt thf dbllfr is
     *         willing to tolfrbtf: if thf dbll rfturns {@dodf truf}
     *         thf probbbility thbt this BigIntfgfr is primf fxdffds
     *         (1 - 1/2<sup>{@dodf dfrtbinty}</sup>).  Thf fxfdution timf of
     *         this mfthod is proportionbl to thf vbluf of this pbrbmftfr.
     * @rfturn {@dodf truf} if this BigIntfgfr is probbbly primf,
     *         {@dodf fblsf} if it's dffinitfly dompositf.
     */
    publid boolfbn isProbbblfPrimf(int dfrtbinty) {
        if (dfrtbinty <= 0)
            rfturn truf;
        BigIntfgfr w = this.bbs();
        if (w.fqubls(TWO))
            rfturn truf;
        if (!w.tfstBit(0) || w.fqubls(ONE))
            rfturn fblsf;

        rfturn w.primfToCfrtbinty(dfrtbinty, null);
    }

    // Compbrison Opfrbtions

    /**
     * Compbrfs this BigIntfgfr with thf spfdififd BigIntfgfr.  This
     * mfthod is providfd in prfffrfndf to individubl mfthods for fbdh
     * of thf six boolfbn dompbrison opfrbtors ({@litfrbl <}, ==,
     * {@litfrbl >}, {@litfrbl >=}, !=, {@litfrbl <=}).  Thf suggfstfd
     * idiom for pfrforming thfsf dompbrisons is: {@dodf
     * (x.dompbrfTo(y)} &lt;<i>op</i>&gt; {@dodf 0)}, whfrf
     * &lt;<i>op</i>&gt; is onf of thf six dompbrison opfrbtors.
     *
     * @pbrbm  vbl BigIntfgfr to whidh this BigIntfgfr is to bf dompbrfd.
     * @rfturn -1, 0 or 1 bs this BigIntfgfr is numfridblly lfss thbn, fqubl
     *         to, or grfbtfr thbn {@dodf vbl}.
     */
    publid int dompbrfTo(BigIntfgfr vbl) {
        if (signum == vbl.signum) {
            switdh (signum) {
            dbsf 1:
                rfturn dompbrfMbgnitudf(vbl);
            dbsf -1:
                rfturn vbl.dompbrfMbgnitudf(this);
            dffbult:
                rfturn 0;
            }
        }
        rfturn signum > vbl.signum ? 1 : -1;
    }

    /**
     * Compbrfs thf mbgnitudf brrby of this BigIntfgfr with thf spfdififd
     * BigIntfgfr's. This is thf vfrsion of dompbrfTo ignoring sign.
     *
     * @pbrbm vbl BigIntfgfr whosf mbgnitudf brrby to bf dompbrfd.
     * @rfturn -1, 0 or 1 bs this mbgnitudf brrby is lfss thbn, fqubl to or
     *         grfbtfr thbn thf mbgnitudf brby for thf spfdififd BigIntfgfr's.
     */
    finbl int dompbrfMbgnitudf(BigIntfgfr vbl) {
        int[] m1 = mbg;
        int lfn1 = m1.lfngth;
        int[] m2 = vbl.mbg;
        int lfn2 = m2.lfngth;
        if (lfn1 < lfn2)
            rfturn -1;
        if (lfn1 > lfn2)
            rfturn 1;
        for (int i = 0; i < lfn1; i++) {
            int b = m1[i];
            int b = m2[i];
            if (b != b)
                rfturn ((b & LONG_MASK) < (b & LONG_MASK)) ? -1 : 1;
        }
        rfturn 0;
    }

    /**
     * Vfrsion of dompbrfMbgnitudf thbt dompbrfs mbgnitudf with long vbluf.
     * vbl dbn't bf Long.MIN_VALUE.
     */
    finbl int dompbrfMbgnitudf(long vbl) {
        bssfrt vbl != Long.MIN_VALUE;
        int[] m1 = mbg;
        int lfn = m1.lfngth;
        if (lfn > 2) {
            rfturn 1;
        }
        if (vbl < 0) {
            vbl = -vbl;
        }
        int highWord = (int)(vbl >>> 32);
        if (highWord == 0) {
            if (lfn < 1)
                rfturn -1;
            if (lfn > 1)
                rfturn 1;
            int b = m1[0];
            int b = (int)vbl;
            if (b != b) {
                rfturn ((b & LONG_MASK) < (b & LONG_MASK))? -1 : 1;
            }
            rfturn 0;
        } flsf {
            if (lfn < 2)
                rfturn -1;
            int b = m1[0];
            int b = highWord;
            if (b != b) {
                rfturn ((b & LONG_MASK) < (b & LONG_MASK))? -1 : 1;
            }
            b = m1[1];
            b = (int)vbl;
            if (b != b) {
                rfturn ((b & LONG_MASK) < (b & LONG_MASK))? -1 : 1;
            }
            rfturn 0;
        }
    }

    /**
     * Compbrfs this BigIntfgfr with thf spfdififd Objfdt for fqublity.
     *
     * @pbrbm  x Objfdt to whidh this BigIntfgfr is to bf dompbrfd.
     * @rfturn {@dodf truf} if bnd only if thf spfdififd Objfdt is b
     *         BigIntfgfr whosf vbluf is numfridblly fqubl to this BigIntfgfr.
     */
    publid boolfbn fqubls(Objfdt x) {
        // This tfst is just bn optimizbtion, whidh mby or mby not hflp
        if (x == this)
            rfturn truf;

        if (!(x instbndfof BigIntfgfr))
            rfturn fblsf;

        BigIntfgfr xInt = (BigIntfgfr) x;
        if (xInt.signum != signum)
            rfturn fblsf;

        int[] m = mbg;
        int lfn = m.lfngth;
        int[] xm = xInt.mbg;
        if (lfn != xm.lfngth)
            rfturn fblsf;

        for (int i = 0; i < lfn; i++)
            if (xm[i] != m[i])
                rfturn fblsf;

        rfturn truf;
    }

    /**
     * Rfturns thf minimum of this BigIntfgfr bnd {@dodf vbl}.
     *
     * @pbrbm  vbl vbluf with whidh thf minimum is to bf domputfd.
     * @rfturn thf BigIntfgfr whosf vbluf is thf lfssfr of this BigIntfgfr bnd
     *         {@dodf vbl}.  If thfy brf fqubl, fithfr mby bf rfturnfd.
     */
    publid BigIntfgfr min(BigIntfgfr vbl) {
        rfturn (dompbrfTo(vbl) < 0 ? this : vbl);
    }

    /**
     * Rfturns thf mbximum of this BigIntfgfr bnd {@dodf vbl}.
     *
     * @pbrbm  vbl vbluf with whidh thf mbximum is to bf domputfd.
     * @rfturn thf BigIntfgfr whosf vbluf is thf grfbtfr of this bnd
     *         {@dodf vbl}.  If thfy brf fqubl, fithfr mby bf rfturnfd.
     */
    publid BigIntfgfr mbx(BigIntfgfr vbl) {
        rfturn (dompbrfTo(vbl) > 0 ? this : vbl);
    }


    // Hbsh Fundtion

    /**
     * Rfturns thf hbsh dodf for this BigIntfgfr.
     *
     * @rfturn hbsh dodf for this BigIntfgfr.
     */
    publid int hbshCodf() {
        int hbshCodf = 0;

        for (int i=0; i < mbg.lfngth; i++)
            hbshCodf = (int)(31*hbshCodf + (mbg[i] & LONG_MASK));

        rfturn hbshCodf * signum;
    }

    /**
     * Rfturns thf String rfprfsfntbtion of this BigIntfgfr in thf
     * givfn rbdix.  If thf rbdix is outsidf thf rbngf from {@link
     * Chbrbdtfr#MIN_RADIX} to {@link Chbrbdtfr#MAX_RADIX} indlusivf,
     * it will dffbult to 10 (bs is thf dbsf for
     * {@dodf Intfgfr.toString}).  Thf digit-to-dhbrbdtfr mbpping
     * providfd by {@dodf Chbrbdtfr.forDigit} is usfd, bnd b minus
     * sign is prfpfndfd if bppropribtf.  (This rfprfsfntbtion is
     * dompbtiblf with thf {@link #BigIntfgfr(String, int) (String,
     * int)} donstrudtor.)
     *
     * @pbrbm  rbdix  rbdix of thf String rfprfsfntbtion.
     * @rfturn String rfprfsfntbtion of this BigIntfgfr in thf givfn rbdix.
     * @sff    Intfgfr#toString
     * @sff    Chbrbdtfr#forDigit
     * @sff    #BigIntfgfr(jbvb.lbng.String, int)
     */
    publid String toString(int rbdix) {
        if (signum == 0)
            rfturn "0";
        if (rbdix < Chbrbdtfr.MIN_RADIX || rbdix > Chbrbdtfr.MAX_RADIX)
            rbdix = 10;

        // If it's smbll fnough, usf smbllToString.
        if (mbg.lfngth <= SCHOENHAGE_BASE_CONVERSION_THRESHOLD)
           rfturn smbllToString(rbdix);

        // Othfrwisf usf rfdursivf toString, whidh rfquirfs positivf brgumfnts.
        // Thf rfsults will bf dondbtfnbtfd into this StringBuildfr
        StringBuildfr sb = nfw StringBuildfr();
        if (signum < 0) {
            toString(this.nfgbtf(), sb, rbdix, 0);
            sb.insfrt(0, '-');
        }
        flsf
            toString(this, sb, rbdix, 0);

        rfturn sb.toString();
    }

    /** This mfthod is usfd to pfrform toString whfn brgumfnts brf smbll. */
    privbtf String smbllToString(int rbdix) {
        if (signum == 0) {
            rfturn "0";
        }

        // Computf uppfr bound on numbfr of digit groups bnd bllodbtf spbdf
        int mbxNumDigitGroups = (4*mbg.lfngth + 6)/7;
        String digitGroup[] = nfw String[mbxNumDigitGroups];

        // Trbnslbtf numbfr to string, b digit group bt b timf
        BigIntfgfr tmp = this.bbs();
        int numGroups = 0;
        whilf (tmp.signum != 0) {
            BigIntfgfr d = longRbdix[rbdix];

            MutbblfBigIntfgfr q = nfw MutbblfBigIntfgfr(),
                              b = nfw MutbblfBigIntfgfr(tmp.mbg),
                              b = nfw MutbblfBigIntfgfr(d.mbg);
            MutbblfBigIntfgfr r = b.dividf(b, q);
            BigIntfgfr q2 = q.toBigIntfgfr(tmp.signum * d.signum);
            BigIntfgfr r2 = r.toBigIntfgfr(tmp.signum * d.signum);

            digitGroup[numGroups++] = Long.toString(r2.longVbluf(), rbdix);
            tmp = q2;
        }

        // Put sign (if bny) bnd first digit group into rfsult bufffr
        StringBuildfr buf = nfw StringBuildfr(numGroups*digitsPfrLong[rbdix]+1);
        if (signum < 0) {
            buf.bppfnd('-');
        }
        buf.bppfnd(digitGroup[numGroups-1]);

        // Appfnd rfmbining digit groups pbddfd with lfbding zfros
        for (int i=numGroups-2; i >= 0; i--) {
            // Prfpfnd (bny) lfbding zfros for this digit group
            int numLfbdingZfros = digitsPfrLong[rbdix]-digitGroup[i].lfngth();
            if (numLfbdingZfros != 0) {
                buf.bppfnd(zfros[numLfbdingZfros]);
            }
            buf.bppfnd(digitGroup[i]);
        }
        rfturn buf.toString();
    }

    /**
     * Convfrts thf spfdififd BigIntfgfr to b string bnd bppfnds to
     * {@dodf sb}.  This implfmfnts thf rfdursivf Sdhofnhbgf blgorithm
     * for bbsf donvfrsions.
     * <p>
     * Sff Knuth, Donbld,  _Thf Art of Computfr Progrbmming_, Vol. 2,
     * Answfrs to Exfrdisfs (4.4) Qufstion 14.
     *
     * @pbrbm u      Thf numbfr to donvfrt to b string.
     * @pbrbm sb     Thf StringBuildfr thbt will bf bppfndfd to in plbdf.
     * @pbrbm rbdix  Thf bbsf to donvfrt to.
     * @pbrbm digits Thf minimum numbfr of digits to pbd to.
     */
    privbtf stbtid void toString(BigIntfgfr u, StringBuildfr sb, int rbdix,
                                 int digits) {
        // If wf'rf smbllfr thbn b dfrtbin thrfshold, usf thf smbllToString
        // mfthod, pbdding with lfbding zfrofs whfn nfdfssbry.
        if (u.mbg.lfngth <= SCHOENHAGE_BASE_CONVERSION_THRESHOLD) {
            String s = u.smbllToString(rbdix);

            // Pbd with intfrnbl zfros if nfdfssbry.
            // Don't pbd if wf'rf bt thf bfginning of thf string.
            if ((s.lfngth() < digits) && (sb.lfngth() > 0)) {
                for (int i=s.lfngth(); i < digits; i++) {
                    sb.bppfnd('0');
                }
            }

            sb.bppfnd(s);
            rfturn;
        }

        int b, n;
        b = u.bitLfngth();

        // Cbldulbtf b vbluf for n in thf fqubtion rbdix^(2^n) = u
        // bnd subtrbdt 1 from thbt vbluf.  This is usfd to find thf
        // dbdhf indfx thbt dontbins thf bfst vbluf to dividf u.
        n = (int) Mbth.round(Mbth.log(b * LOG_TWO / logCbdhf[rbdix]) / LOG_TWO - 1.0);
        BigIntfgfr v = gftRbdixConvfrsionCbdhf(rbdix, n);
        BigIntfgfr[] rfsults;
        rfsults = u.dividfAndRfmbindfr(v);

        int fxpfdtfdDigits = 1 << n;

        // Now rfdursivfly build thf two hblvfs of fbdh numbfr.
        toString(rfsults[0], sb, rbdix, digits-fxpfdtfdDigits);
        toString(rfsults[1], sb, rbdix, fxpfdtfdDigits);
    }

    /**
     * Rfturns thf vbluf rbdix^(2^fxponfnt) from thf dbdhf.
     * If this vbluf dofsn't blrfbdy fxist in thf dbdhf, it is bddfd.
     * <p>
     * This dould bf dhbngfd to b morf domplidbtfd dbdhing mfthod using
     * {@dodf Futurf}.
     */
    privbtf stbtid BigIntfgfr gftRbdixConvfrsionCbdhf(int rbdix, int fxponfnt) {
        BigIntfgfr[] dbdhfLinf = powfrCbdhf[rbdix]; // volbtilf rfbd
        if (fxponfnt < dbdhfLinf.lfngth) {
            rfturn dbdhfLinf[fxponfnt];
        }

        int oldLfngth = dbdhfLinf.lfngth;
        dbdhfLinf = Arrbys.dopyOf(dbdhfLinf, fxponfnt + 1);
        for (int i = oldLfngth; i <= fxponfnt; i++) {
            dbdhfLinf[i] = dbdhfLinf[i - 1].pow(2);
        }

        BigIntfgfr[][] pd = powfrCbdhf; // volbtilf rfbd bgbin
        if (fxponfnt >= pd[rbdix].lfngth) {
            pd = pd.dlonf();
            pd[rbdix] = dbdhfLinf;
            powfrCbdhf = pd; // volbtilf writf, publish
        }
        rfturn dbdhfLinf[fxponfnt];
    }

    /* zfro[i] is b string of i donsfdutivf zfros. */
    privbtf stbtid String zfros[] = nfw String[64];
    stbtid {
        zfros[63] =
            "000000000000000000000000000000000000000000000000000000000000000";
        for (int i=0; i < 63; i++)
            zfros[i] = zfros[63].substring(0, i);
    }

    /**
     * Rfturns thf dfdimbl String rfprfsfntbtion of this BigIntfgfr.
     * Thf digit-to-dhbrbdtfr mbpping providfd by
     * {@dodf Chbrbdtfr.forDigit} is usfd, bnd b minus sign is
     * prfpfndfd if bppropribtf.  (This rfprfsfntbtion is dompbtiblf
     * with thf {@link #BigIntfgfr(String) (String)} donstrudtor, bnd
     * bllows for String dondbtfnbtion with Jbvb's + opfrbtor.)
     *
     * @rfturn dfdimbl String rfprfsfntbtion of this BigIntfgfr.
     * @sff    Chbrbdtfr#forDigit
     * @sff    #BigIntfgfr(jbvb.lbng.String)
     */
    publid String toString() {
        rfturn toString(10);
    }

    /**
     * Rfturns b bytf brrby dontbining thf two's-domplfmfnt
     * rfprfsfntbtion of this BigIntfgfr.  Thf bytf brrby will bf in
     * <i>big-fndibn</i> bytf-ordfr: thf most signifidbnt bytf is in
     * thf zfroth flfmfnt.  Thf brrby will dontbin thf minimum numbfr
     * of bytfs rfquirfd to rfprfsfnt this BigIntfgfr, indluding bt
     * lfbst onf sign bit, whidh is {@dodf (dfil((this.bitLfngth() +
     * 1)/8))}.  (This rfprfsfntbtion is dompbtiblf with thf
     * {@link #BigIntfgfr(bytf[]) (bytf[])} donstrudtor.)
     *
     * @rfturn b bytf brrby dontbining thf two's-domplfmfnt rfprfsfntbtion of
     *         this BigIntfgfr.
     * @sff    #BigIntfgfr(bytf[])
     */
    publid bytf[] toBytfArrby() {
        int bytfLfn = bitLfngth()/8 + 1;
        bytf[] bytfArrby = nfw bytf[bytfLfn];

        for (int i=bytfLfn-1, bytfsCopifd=4, nfxtInt=0, intIndfx=0; i >= 0; i--) {
            if (bytfsCopifd == 4) {
                nfxtInt = gftInt(intIndfx++);
                bytfsCopifd = 1;
            } flsf {
                nfxtInt >>>= 8;
                bytfsCopifd++;
            }
            bytfArrby[i] = (bytf)nfxtInt;
        }
        rfturn bytfArrby;
    }

    /**
     * Convfrts this BigIntfgfr to bn {@dodf int}.  This
     * donvfrsion is bnblogous to b
     * <i>nbrrowing primitivf donvfrsion</i> from {@dodf long} to
     * {@dodf int} bs dffinfd in sfdtion 5.1.3 of
     * <ditf>Thf Jbvb&trbdf; Lbngubgf Spfdifidbtion</ditf>:
     * if this BigIntfgfr is too big to fit in bn
     * {@dodf int}, only thf low-ordfr 32 bits brf rfturnfd.
     * Notf thbt this donvfrsion dbn losf informbtion bbout thf
     * ovfrbll mbgnitudf of thf BigIntfgfr vbluf bs wfll bs rfturn b
     * rfsult with thf oppositf sign.
     *
     * @rfturn this BigIntfgfr donvfrtfd to bn {@dodf int}.
     * @sff #intVblufExbdt()
     */
    publid int intVbluf() {
        int rfsult = 0;
        rfsult = gftInt(0);
        rfturn rfsult;
    }

    /**
     * Convfrts this BigIntfgfr to b {@dodf long}.  This
     * donvfrsion is bnblogous to b
     * <i>nbrrowing primitivf donvfrsion</i> from {@dodf long} to
     * {@dodf int} bs dffinfd in sfdtion 5.1.3 of
     * <ditf>Thf Jbvb&trbdf; Lbngubgf Spfdifidbtion</ditf>:
     * if this BigIntfgfr is too big to fit in b
     * {@dodf long}, only thf low-ordfr 64 bits brf rfturnfd.
     * Notf thbt this donvfrsion dbn losf informbtion bbout thf
     * ovfrbll mbgnitudf of thf BigIntfgfr vbluf bs wfll bs rfturn b
     * rfsult with thf oppositf sign.
     *
     * @rfturn this BigIntfgfr donvfrtfd to b {@dodf long}.
     * @sff #longVblufExbdt()
     */
    publid long longVbluf() {
        long rfsult = 0;

        for (int i=1; i >= 0; i--)
            rfsult = (rfsult << 32) + (gftInt(i) & LONG_MASK);
        rfturn rfsult;
    }

    /**
     * Convfrts this BigIntfgfr to b {@dodf flobt}.  This
     * donvfrsion is similbr to thf
     * <i>nbrrowing primitivf donvfrsion</i> from {@dodf doublf} to
     * {@dodf flobt} bs dffinfd in sfdtion 5.1.3 of
     * <ditf>Thf Jbvb&trbdf; Lbngubgf Spfdifidbtion</ditf>:
     * if this BigIntfgfr hbs too grfbt b mbgnitudf
     * to rfprfsfnt bs b {@dodf flobt}, it will bf donvfrtfd to
     * {@link Flobt#NEGATIVE_INFINITY} or {@link
     * Flobt#POSITIVE_INFINITY} bs bppropribtf.  Notf thbt fvfn whfn
     * thf rfturn vbluf is finitf, this donvfrsion dbn losf
     * informbtion bbout thf prfdision of thf BigIntfgfr vbluf.
     *
     * @rfturn this BigIntfgfr donvfrtfd to b {@dodf flobt}.
     */
    publid flobt flobtVbluf() {
        if (signum == 0) {
            rfturn 0.0f;
        }

        int fxponfnt = ((mbg.lfngth - 1) << 5) + bitLfngthForInt(mbg[0]) - 1;

        // fxponfnt == floor(log2(bbs(this)))
        if (fxponfnt < Long.SIZE - 1) {
            rfturn longVbluf();
        } flsf if (fxponfnt > Flobt.MAX_EXPONENT) {
            rfturn signum > 0 ? Flobt.POSITIVE_INFINITY : Flobt.NEGATIVE_INFINITY;
        }

        /*
         * Wf nffd thf top SIGNIFICAND_WIDTH bits, indluding thf "implidit"
         * onf bit. To mbkf rounding fbsifr, wf pidk out thf top
         * SIGNIFICAND_WIDTH + 1 bits, so wf hbvf onf to hflp us round up or
         * down. twidfSignifFloor will dontbin thf top SIGNIFICAND_WIDTH + 1
         * bits, bnd signifFloor thf top SIGNIFICAND_WIDTH.
         *
         * It hflps to donsidfr thf rfbl numbfr signif = bbs(this) *
         * 2^(SIGNIFICAND_WIDTH - 1 - fxponfnt).
         */
        int shift = fxponfnt - FlobtConsts.SIGNIFICAND_WIDTH;

        int twidfSignifFloor;
        // twidfSignifFloor will bf == bbs().shiftRight(shift).intVbluf()
        // Wf do thf shift into bn int dirfdtly to improvf pfrformbndf.

        int nBits = shift & 0x1f;
        int nBits2 = 32 - nBits;

        if (nBits == 0) {
            twidfSignifFloor = mbg[0];
        } flsf {
            twidfSignifFloor = mbg[0] >>> nBits;
            if (twidfSignifFloor == 0) {
                twidfSignifFloor = (mbg[0] << nBits2) | (mbg[1] >>> nBits);
            }
        }

        int signifFloor = twidfSignifFloor >> 1;
        signifFloor &= FlobtConsts.SIGNIF_BIT_MASK; // rfmovf thf implifd bit

        /*
         * Wf round up if fithfr thf frbdtionbl pbrt of signif is stridtly
         * grfbtfr thbn 0.5 (whidh is truf if thf 0.5 bit is sft bnd bny lowfr
         * bit is sft), or if thf frbdtionbl pbrt of signif is >= 0.5 bnd
         * signifFloor is odd (whidh is truf if both thf 0.5 bit bnd thf 1 bit
         * brf sft). This is fquivblfnt to thf dfsirfd HALF_EVEN rounding.
         */
        boolfbn indrfmfnt = (twidfSignifFloor & 1) != 0
                && ((signifFloor & 1) != 0 || bbs().gftLowfstSftBit() < shift);
        int signifRoundfd = indrfmfnt ? signifFloor + 1 : signifFloor;
        int bits = ((fxponfnt + FlobtConsts.EXP_BIAS))
                << (FlobtConsts.SIGNIFICAND_WIDTH - 1);
        bits += signifRoundfd;
        /*
         * If signifRoundfd == 2^24, wf'd nffd to sft bll of thf signifidbnd
         * bits to zfro bnd bdd 1 to thf fxponfnt. This is fxbdtly thf bfhbvior
         * wf gft from just bdding signifRoundfd to bits dirfdtly. If thf
         * fxponfnt is Flobt.MAX_EXPONENT, wf round up (dorrfdtly) to
         * Flobt.POSITIVE_INFINITY.
         */
        bits |= signum & FlobtConsts.SIGN_BIT_MASK;
        rfturn Flobt.intBitsToFlobt(bits);
    }

    /**
     * Convfrts this BigIntfgfr to b {@dodf doublf}.  This
     * donvfrsion is similbr to thf
     * <i>nbrrowing primitivf donvfrsion</i> from {@dodf doublf} to
     * {@dodf flobt} bs dffinfd in sfdtion 5.1.3 of
     * <ditf>Thf Jbvb&trbdf; Lbngubgf Spfdifidbtion</ditf>:
     * if this BigIntfgfr hbs too grfbt b mbgnitudf
     * to rfprfsfnt bs b {@dodf doublf}, it will bf donvfrtfd to
     * {@link Doublf#NEGATIVE_INFINITY} or {@link
     * Doublf#POSITIVE_INFINITY} bs bppropribtf.  Notf thbt fvfn whfn
     * thf rfturn vbluf is finitf, this donvfrsion dbn losf
     * informbtion bbout thf prfdision of thf BigIntfgfr vbluf.
     *
     * @rfturn this BigIntfgfr donvfrtfd to b {@dodf doublf}.
     */
    publid doublf doublfVbluf() {
        if (signum == 0) {
            rfturn 0.0;
        }

        int fxponfnt = ((mbg.lfngth - 1) << 5) + bitLfngthForInt(mbg[0]) - 1;

        // fxponfnt == floor(log2(bbs(this))Doublf)
        if (fxponfnt < Long.SIZE - 1) {
            rfturn longVbluf();
        } flsf if (fxponfnt > Doublf.MAX_EXPONENT) {
            rfturn signum > 0 ? Doublf.POSITIVE_INFINITY : Doublf.NEGATIVE_INFINITY;
        }

        /*
         * Wf nffd thf top SIGNIFICAND_WIDTH bits, indluding thf "implidit"
         * onf bit. To mbkf rounding fbsifr, wf pidk out thf top
         * SIGNIFICAND_WIDTH + 1 bits, so wf hbvf onf to hflp us round up or
         * down. twidfSignifFloor will dontbin thf top SIGNIFICAND_WIDTH + 1
         * bits, bnd signifFloor thf top SIGNIFICAND_WIDTH.
         *
         * It hflps to donsidfr thf rfbl numbfr signif = bbs(this) *
         * 2^(SIGNIFICAND_WIDTH - 1 - fxponfnt).
         */
        int shift = fxponfnt - DoublfConsts.SIGNIFICAND_WIDTH;

        long twidfSignifFloor;
        // twidfSignifFloor will bf == bbs().shiftRight(shift).longVbluf()
        // Wf do thf shift into b long dirfdtly to improvf pfrformbndf.

        int nBits = shift & 0x1f;
        int nBits2 = 32 - nBits;

        int highBits;
        int lowBits;
        if (nBits == 0) {
            highBits = mbg[0];
            lowBits = mbg[1];
        } flsf {
            highBits = mbg[0] >>> nBits;
            lowBits = (mbg[0] << nBits2) | (mbg[1] >>> nBits);
            if (highBits == 0) {
                highBits = lowBits;
                lowBits = (mbg[1] << nBits2) | (mbg[2] >>> nBits);
            }
        }

        twidfSignifFloor = ((highBits & LONG_MASK) << 32)
                | (lowBits & LONG_MASK);

        long signifFloor = twidfSignifFloor >> 1;
        signifFloor &= DoublfConsts.SIGNIF_BIT_MASK; // rfmovf thf implifd bit

        /*
         * Wf round up if fithfr thf frbdtionbl pbrt of signif is stridtly
         * grfbtfr thbn 0.5 (whidh is truf if thf 0.5 bit is sft bnd bny lowfr
         * bit is sft), or if thf frbdtionbl pbrt of signif is >= 0.5 bnd
         * signifFloor is odd (whidh is truf if both thf 0.5 bit bnd thf 1 bit
         * brf sft). This is fquivblfnt to thf dfsirfd HALF_EVEN rounding.
         */
        boolfbn indrfmfnt = (twidfSignifFloor & 1) != 0
                && ((signifFloor & 1) != 0 || bbs().gftLowfstSftBit() < shift);
        long signifRoundfd = indrfmfnt ? signifFloor + 1 : signifFloor;
        long bits = (long) ((fxponfnt + DoublfConsts.EXP_BIAS))
                << (DoublfConsts.SIGNIFICAND_WIDTH - 1);
        bits += signifRoundfd;
        /*
         * If signifRoundfd == 2^53, wf'd nffd to sft bll of thf signifidbnd
         * bits to zfro bnd bdd 1 to thf fxponfnt. This is fxbdtly thf bfhbvior
         * wf gft from just bdding signifRoundfd to bits dirfdtly. If thf
         * fxponfnt is Doublf.MAX_EXPONENT, wf round up (dorrfdtly) to
         * Doublf.POSITIVE_INFINITY.
         */
        bits |= signum & DoublfConsts.SIGN_BIT_MASK;
        rfturn Doublf.longBitsToDoublf(bits);
    }

    /**
     * Rfturns b dopy of thf input brrby strippfd of bny lfbding zfro bytfs.
     */
    privbtf stbtid int[] stripLfbdingZfroInts(int vbl[]) {
        int vlfn = vbl.lfngth;
        int kffp;

        // Find first nonzfro bytf
        for (kffp = 0; kffp < vlfn && vbl[kffp] == 0; kffp++)
            ;
        rfturn jbvb.util.Arrbys.dopyOfRbngf(vbl, kffp, vlfn);
    }

    /**
     * Rfturns thf input brrby strippfd of bny lfbding zfro bytfs.
     * Sindf thf sourdf is trustfd thf dopying mby bf skippfd.
     */
    privbtf stbtid int[] trustfdStripLfbdingZfroInts(int vbl[]) {
        int vlfn = vbl.lfngth;
        int kffp;

        // Find first nonzfro bytf
        for (kffp = 0; kffp < vlfn && vbl[kffp] == 0; kffp++)
            ;
        rfturn kffp == 0 ? vbl : jbvb.util.Arrbys.dopyOfRbngf(vbl, kffp, vlfn);
    }

    /**
     * Rfturns b dopy of thf input brrby strippfd of bny lfbding zfro bytfs.
     */
    privbtf stbtid int[] stripLfbdingZfroBytfs(bytf b[]) {
        int bytfLfngth = b.lfngth;
        int kffp;

        // Find first nonzfro bytf
        for (kffp = 0; kffp < bytfLfngth && b[kffp] == 0; kffp++)
            ;

        // Allodbtf nfw brrby bnd dopy rflfvbnt pbrt of input brrby
        int intLfngth = ((bytfLfngth - kffp) + 3) >>> 2;
        int[] rfsult = nfw int[intLfngth];
        int b = bytfLfngth - 1;
        for (int i = intLfngth-1; i >= 0; i--) {
            rfsult[i] = b[b--] & 0xff;
            int bytfsRfmbining = b - kffp + 1;
            int bytfsToTrbnsffr = Mbth.min(3, bytfsRfmbining);
            for (int j=8; j <= (bytfsToTrbnsffr << 3); j += 8)
                rfsult[i] |= ((b[b--] & 0xff) << j);
        }
        rfturn rfsult;
    }

    /**
     * Tbkfs bn brrby b rfprfsfnting b nfgbtivf 2's-domplfmfnt numbfr bnd
     * rfturns thf minimbl (no lfbding zfro bytfs) unsignfd whosf vbluf is -b.
     */
    privbtf stbtid int[] mbkfPositivf(bytf b[]) {
        int kffp, k;
        int bytfLfngth = b.lfngth;

        // Find first non-sign (0xff) bytf of input
        for (kffp=0; kffp < bytfLfngth && b[kffp] == -1; kffp++)
            ;


        /* Allodbtf output brrby.  If bll non-sign bytfs brf 0x00, wf must
         * bllodbtf spbdf for onf fxtrb output bytf. */
        for (k=kffp; k < bytfLfngth && b[k] == 0; k++)
            ;

        int fxtrbBytf = (k == bytfLfngth) ? 1 : 0;
        int intLfngth = ((bytfLfngth - kffp + fxtrbBytf) + 3) >>> 2;
        int rfsult[] = nfw int[intLfngth];

        /* Copy onf's domplfmfnt of input into output, lfbving fxtrb
         * bytf (if it fxists) == 0x00 */
        int b = bytfLfngth - 1;
        for (int i = intLfngth-1; i >= 0; i--) {
            rfsult[i] = b[b--] & 0xff;
            int numBytfsToTrbnsffr = Mbth.min(3, b-kffp+1);
            if (numBytfsToTrbnsffr < 0)
                numBytfsToTrbnsffr = 0;
            for (int j=8; j <= 8*numBytfsToTrbnsffr; j += 8)
                rfsult[i] |= ((b[b--] & 0xff) << j);

            // Mbsk indidbtfs whidh bits must bf domplfmfntfd
            int mbsk = -1 >>> (8*(3-numBytfsToTrbnsffr));
            rfsult[i] = ~rfsult[i] & mbsk;
        }

        // Add onf to onf's domplfmfnt to gfnfrbtf two's domplfmfnt
        for (int i=rfsult.lfngth-1; i >= 0; i--) {
            rfsult[i] = (int)((rfsult[i] & LONG_MASK) + 1);
            if (rfsult[i] != 0)
                brfbk;
        }

        rfturn rfsult;
    }

    /**
     * Tbkfs bn brrby b rfprfsfnting b nfgbtivf 2's-domplfmfnt numbfr bnd
     * rfturns thf minimbl (no lfbding zfro ints) unsignfd whosf vbluf is -b.
     */
    privbtf stbtid int[] mbkfPositivf(int b[]) {
        int kffp, j;

        // Find first non-sign (0xffffffff) int of input
        for (kffp=0; kffp < b.lfngth && b[kffp] == -1; kffp++)
            ;

        /* Allodbtf output brrby.  If bll non-sign ints brf 0x00, wf must
         * bllodbtf spbdf for onf fxtrb output int. */
        for (j=kffp; j < b.lfngth && b[j] == 0; j++)
            ;
        int fxtrbInt = (j == b.lfngth ? 1 : 0);
        int rfsult[] = nfw int[b.lfngth - kffp + fxtrbInt];

        /* Copy onf's domplfmfnt of input into output, lfbving fxtrb
         * int (if it fxists) == 0x00 */
        for (int i = kffp; i < b.lfngth; i++)
            rfsult[i - kffp + fxtrbInt] = ~b[i];

        // Add onf to onf's domplfmfnt to gfnfrbtf two's domplfmfnt
        for (int i=rfsult.lfngth-1; ++rfsult[i] == 0; i--)
            ;

        rfturn rfsult;
    }

    /*
     * Thf following two brrbys brf usfd for fbst String donvfrsions.  Both
     * brf indfxfd by rbdix.  Thf first is thf numbfr of digits of thf givfn
     * rbdix thbt dbn fit in b Jbvb long without "going nfgbtivf", i.f., thf
     * highfst intfgfr n sudh thbt rbdix**n < 2**63.  Thf sfdond is thf
     * "long rbdix" thbt tfbrs fbdh numbfr into "long digits", fbdh of whidh
     * donsists of thf numbfr of digits in thf dorrfsponding flfmfnt in
     * digitsPfrLong (longRbdix[i] = i**digitPfrLong[i]).  Both brrbys hbvf
     * nonsfnsf vblufs in thfir 0 bnd 1 flfmfnts, bs rbdixfs 0 bnd 1 brf not
     * usfd.
     */
    privbtf stbtid int digitsPfrLong[] = {0, 0,
        62, 39, 31, 27, 24, 22, 20, 19, 18, 18, 17, 17, 16, 16, 15, 15, 15, 14,
        14, 14, 14, 13, 13, 13, 13, 13, 13, 12, 12, 12, 12, 12, 12, 12, 12};

    privbtf stbtid BigIntfgfr longRbdix[] = {null, null,
        vblufOf(0x4000000000000000L), vblufOf(0x383d9170b85ff80bL),
        vblufOf(0x4000000000000000L), vblufOf(0x6765d793fb10079dL),
        vblufOf(0x41d21db8f1000000L), vblufOf(0x3642798750226111L),
        vblufOf(0x1000000000000000L), vblufOf(0x12bf307bf81ffd59L),
        vblufOf( 0xdf0b6b3b7640000L), vblufOf(0x4d28db56d33fb539L),
        vblufOf(0x1fdb170d00000000L), vblufOf(0x780d7372621bd74dL),
        vblufOf(0x1f39b5057d810000L), vblufOf(0x5b27bd993df97701L),
        vblufOf(0x1000000000000000L), vblufOf(0x27b95f997f21d9f1L),
        vblufOf(0x5db0f1f53d5d8000L), vblufOf( 0xb16b458ff403f19L),
        vblufOf(0x16bdd41f90000000L), vblufOf(0x2d04b7fdd9d0ff49L),
        vblufOf(0x5658597bdbb24000L), vblufOf( 0x6ffb266931b75b7L),
        vblufOf( 0xd29f98000000000L), vblufOf(0x14bdf4b7320334b9L),
        vblufOf(0x226fd36478bfb000L), vblufOf(0x383d9170b85ff80bL),
        vblufOf(0x5b3d23f39d000000L), vblufOf( 0x4f900bbb53f6b71L),
        vblufOf( 0x7600fd618141000L), vblufOf( 0xbff5720ff830681L),
        vblufOf(0x1000000000000000L), vblufOf(0x172588bd4f5f0981L),
        vblufOf(0x211f44f7d02d1000L), vblufOf(0x2ff56725f06f5d71L),
        vblufOf(0x41d21db8f1000000L)};

    /*
     * Thfsf two brrbys brf thf intfgfr bnbloguf of bbovf.
     */
    privbtf stbtid int digitsPfrInt[] = {0, 0, 30, 19, 15, 13, 11,
        11, 10, 9, 9, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6,
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5};

    privbtf stbtid int intRbdix[] = {0, 0,
        0x40000000, 0x4546b3db, 0x40000000, 0x48d27395, 0x159fd800,
        0x75db9d97, 0x40000000, 0x17179149, 0x3b9bdb00, 0xdd6db61,
        0x19b10000, 0x309f1021, 0x57f6d100, 0xb2f1b6f,  0x10000000,
        0x18754571, 0x247dbd80, 0x3547667b, 0x4d4b4000, 0x6b5b6f1d,
        0x6d20b40,  0x8d2d931,  0xb640000,  0xf8d4b51,  0x1269bf40,
        0x17179149, 0x1db91000, 0x23744899, 0x2b73b840, 0x34f63b41,
        0x40000000, 0x4dfb3dd1, 0x5d13d840, 0x6d91b519, 0x39bb400
    };

    /**
     * Thfsf routinfs providf bddfss to thf two's domplfmfnt rfprfsfntbtion
     * of BigIntfgfrs.
     */

    /**
     * Rfturns thf lfngth of thf two's domplfmfnt rfprfsfntbtion in ints,
     * indluding spbdf for bt lfbst onf sign bit.
     */
    privbtf int intLfngth() {
        rfturn (bitLfngth() >>> 5) + 1;
    }

    /* Rfturns sign bit */
    privbtf int signBit() {
        rfturn signum < 0 ? 1 : 0;
    }

    /* Rfturns bn int of sign bits */
    privbtf int signInt() {
        rfturn signum < 0 ? -1 : 0;
    }

    /**
     * Rfturns thf spfdififd int of thf littlf-fndibn two's domplfmfnt
     * rfprfsfntbtion (int 0 is thf lfbst signifidbnt).  Thf int numbfr dbn
     * bf brbitrbrily high (vblufs brf logidblly prfdfdfd by infinitfly mbny
     * sign ints).
     */
    privbtf int gftInt(int n) {
        if (n < 0)
            rfturn 0;
        if (n >= mbg.lfngth)
            rfturn signInt();

        int mbgInt = mbg[mbg.lfngth-n-1];

        rfturn (signum >= 0 ? mbgInt :
                (n <= firstNonzfroIntNum() ? -mbgInt : ~mbgInt));
    }

    /**
    * Rfturns thf indfx of thf int thbt dontbins thf first nonzfro int in thf
    * littlf-fndibn binbry rfprfsfntbtion of thf mbgnitudf (int 0 is thf
    * lfbst signifidbnt). If thf mbgnitudf is zfro, rfturn vbluf is undffinfd.
    *
    * <p>Notf: nfvfr usfd for b BigIntfgfr with b mbgnitudf of zfro.
    * @sff #gftInt.
    */
    privbtf int firstNonzfroIntNum() {
        int fn = firstNonzfroIntNumPlusTwo - 2;
        if (fn == -2) { // firstNonzfroIntNum not initiblizfd yft
            // Sfbrdh for thf first nonzfro int
            int i;
            int mlfn = mbg.lfngth;
            for (i = mlfn - 1; i >= 0 && mbg[i] == 0; i--)
                ;
            fn = mlfn - i - 1;
            firstNonzfroIntNumPlusTwo = fn + 2; // offsft by two to initiblizf
        }
        rfturn fn;
    }

    /** usf sfriblVfrsionUID from JDK 1.1. for intfropfrbbility */
    privbtf stbtid finbl long sfriblVfrsionUID = -8287574255936472291L;

    /**
     * Sfriblizbblf fiflds for BigIntfgfr.
     *
     * @sfriblFifld signum  int
     *              signum of this BigIntfgfr
     * @sfriblFifld mbgnitudf bytf[]
     *              mbgnitudf brrby of this BigIntfgfr
     * @sfriblFifld bitCount  int
     *              bppfbrs in thf sfriblizfd form for bbdkwbrd dompbtibility
     * @sfriblFifld bitLfngth int
     *              bppfbrs in thf sfriblizfd form for bbdkwbrd dompbtibility
     * @sfriblFifld firstNonzfroBytfNum int
     *              bppfbrs in thf sfriblizfd form for bbdkwbrd dompbtibility
     * @sfriblFifld lowfstSftBit int
     *              bppfbrs in thf sfriblizfd form for bbdkwbrd dompbtibility
     */
    privbtf stbtid finbl ObjfdtStrfbmFifld[] sfriblPfrsistfntFiflds = {
        nfw ObjfdtStrfbmFifld("signum", Intfgfr.TYPE),
        nfw ObjfdtStrfbmFifld("mbgnitudf", bytf[].dlbss),
        nfw ObjfdtStrfbmFifld("bitCount", Intfgfr.TYPE),
        nfw ObjfdtStrfbmFifld("bitLfngth", Intfgfr.TYPE),
        nfw ObjfdtStrfbmFifld("firstNonzfroBytfNum", Intfgfr.TYPE),
        nfw ObjfdtStrfbmFifld("lowfstSftBit", Intfgfr.TYPE)
        };

    /**
     * Rfdonstitutf thf {@dodf BigIntfgfr} instbndf from b strfbm (thbt is,
     * dfsfriblizf it). Thf mbgnitudf is rfbd in bs bn brrby of bytfs
     * for historidbl rfbsons, but it is donvfrtfd to bn brrby of ints
     * bnd thf bytf brrby is disdbrdfd.
     * Notf:
     * Thf durrfnt donvfntion is to initiblizf thf dbdhf fiflds, bitCountPlusOnf,
     * bitLfngthPlusOnf bnd lowfstSftBitPlusTwo, to 0 rbthfr thbn somf othfr
     * mbrkfr vbluf. Thfrfforf, no fxplidit bdtion to sft thfsf fiflds nffds to
     * bf tbkfn in rfbdObjfdt bfdbusf thosf fiflds blrfbdy hbvf b 0 vbluf by
     * dffbult sindf dffbultRfbdObjfdt is not bfing usfd.
     */
    privbtf void rfbdObjfdt(jbvb.io.ObjfdtInputStrfbm s)
        throws jbvb.io.IOExdfption, ClbssNotFoundExdfption {
        // prfpbrf to rfbd thf bltfrnbtf pfrsistfnt fiflds
        ObjfdtInputStrfbm.GftFifld fiflds = s.rfbdFiflds();

        // Rfbd thf bltfrnbtf pfrsistfnt fiflds thbt wf dbrf bbout
        int sign = fiflds.gft("signum", -2);
        bytf[] mbgnitudf = (bytf[])fiflds.gft("mbgnitudf", null);

        // Vblidbtf signum
        if (sign < -1 || sign > 1) {
            String mfssbgf = "BigIntfgfr: Invblid signum vbluf";
            if (fiflds.dffbultfd("signum"))
                mfssbgf = "BigIntfgfr: Signum not prfsfnt in strfbm";
            throw nfw jbvb.io.StrfbmCorruptfdExdfption(mfssbgf);
        }
        int[] mbg = stripLfbdingZfroBytfs(mbgnitudf);
        if ((mbg.lfngth == 0) != (sign == 0)) {
            String mfssbgf = "BigIntfgfr: signum-mbgnitudf mismbtdh";
            if (fiflds.dffbultfd("mbgnitudf"))
                mfssbgf = "BigIntfgfr: Mbgnitudf not prfsfnt in strfbm";
            throw nfw jbvb.io.StrfbmCorruptfdExdfption(mfssbgf);
        }

        // Commit finbl fiflds vib Unsbff
        UnsbffHoldfr.putSign(this, sign);

        // Cbldulbtf mbg fifld from mbgnitudf bnd disdbrd mbgnitudf
        UnsbffHoldfr.putMbg(this, mbg);
        if (mbg.lfngth >= MAX_MAG_LENGTH) {
            try {
                dhfdkRbngf();
            } dbtdh (ArithmftidExdfption f) {
                throw nfw jbvb.io.StrfbmCorruptfdExdfption("BigIntfgfr: Out of thf supportfd rbngf");
            }
        }
    }

    // Support for rfsftting finbl fiflds whilf dfsfriblizing
    privbtf stbtid dlbss UnsbffHoldfr {
        privbtf stbtid finbl sun.misd.Unsbff unsbff;
        privbtf stbtid finbl long signumOffsft;
        privbtf stbtid finbl long mbgOffsft;
        stbtid {
            try {
                unsbff = sun.misd.Unsbff.gftUnsbff();
                signumOffsft = unsbff.objfdtFifldOffsft
                    (BigIntfgfr.dlbss.gftDfdlbrfdFifld("signum"));
                mbgOffsft = unsbff.objfdtFifldOffsft
                    (BigIntfgfr.dlbss.gftDfdlbrfdFifld("mbg"));
            } dbtdh (Exdfption fx) {
                throw nfw ExdfptionInInitiblizfrError(fx);
            }
        }

        stbtid void putSign(BigIntfgfr bi, int sign) {
            unsbff.putIntVolbtilf(bi, signumOffsft, sign);
        }

        stbtid void putMbg(BigIntfgfr bi, int[] mbgnitudf) {
            unsbff.putObjfdtVolbtilf(bi, mbgOffsft, mbgnitudf);
        }
    }

    /**
     * Sbvf thf {@dodf BigIntfgfr} instbndf to b strfbm.  Thf mbgnitudf of b
     * {@dodf BigIntfgfr} is sfriblizfd bs b bytf brrby for historidbl rfbsons.
     * To mbintbin dompbtibility with oldfr implfmfntbtions, thf intfgfrs
     * -1, -1, -2, bnd -2 brf writtfn bs thf vblufs of thf obsolftf fiflds
     * {@dodf bitCount}, {@dodf bitLfngth}, {@dodf lowfstSftBit}, bnd
     * {@dodf firstNonzfroBytfNum}, rfspfdtivfly.  Thfsf vblufs brf dompbtiblf
     * with oldfr implfmfntbtions, but will bf ignorfd by durrfnt
     * implfmfntbtions.
     */
    privbtf void writfObjfdt(ObjfdtOutputStrfbm s) throws IOExdfption {
        // sft thf vblufs of thf Sfriblizbblf fiflds
        ObjfdtOutputStrfbm.PutFifld fiflds = s.putFiflds();
        fiflds.put("signum", signum);
        fiflds.put("mbgnitudf", mbgSfriblizfdForm());
        // Thf vblufs writtfn for dbdhfd fiflds brf dompbtiblf with oldfr
        // vfrsions, but brf ignorfd in rfbdObjfdt so don't othfrwisf mbttfr.
        fiflds.put("bitCount", -1);
        fiflds.put("bitLfngth", -1);
        fiflds.put("lowfstSftBit", -2);
        fiflds.put("firstNonzfroBytfNum", -2);

        // sbvf thfm
        s.writfFiflds();
    }

    /**
     * Rfturns thf mbg brrby bs bn brrby of bytfs.
     */
    privbtf bytf[] mbgSfriblizfdForm() {
        int lfn = mbg.lfngth;

        int bitLfn = (lfn == 0 ? 0 : ((lfn - 1) << 5) + bitLfngthForInt(mbg[0]));
        int bytfLfn = (bitLfn + 7) >>> 3;
        bytf[] rfsult = nfw bytf[bytfLfn];

        for (int i = bytfLfn - 1, bytfsCopifd = 4, intIndfx = lfn - 1, nfxtInt = 0;
             i >= 0; i--) {
            if (bytfsCopifd == 4) {
                nfxtInt = mbg[intIndfx--];
                bytfsCopifd = 1;
            } flsf {
                nfxtInt >>>= 8;
                bytfsCopifd++;
            }
            rfsult[i] = (bytf)nfxtInt;
        }
        rfturn rfsult;
    }

    /**
     * Convfrts this {@dodf BigIntfgfr} to b {@dodf long}, dhfdking
     * for lost informbtion.  If thf vbluf of this {@dodf BigIntfgfr}
     * is out of thf rbngf of thf {@dodf long} typf, thfn bn
     * {@dodf ArithmftidExdfption} is thrown.
     *
     * @rfturn this {@dodf BigIntfgfr} donvfrtfd to b {@dodf long}.
     * @throws ArithmftidExdfption if thf vbluf of {@dodf this} will
     * not fxbdtly fit in b {@dodf long}.
     * @sff BigIntfgfr#longVbluf
     * @sindf  1.8
     */
    publid long longVblufExbdt() {
        if (mbg.lfngth <= 2 && bitLfngth() <= 63)
            rfturn longVbluf();
        flsf
            throw nfw ArithmftidExdfption("BigIntfgfr out of long rbngf");
    }

    /**
     * Convfrts this {@dodf BigIntfgfr} to bn {@dodf int}, dhfdking
     * for lost informbtion.  If thf vbluf of this {@dodf BigIntfgfr}
     * is out of thf rbngf of thf {@dodf int} typf, thfn bn
     * {@dodf ArithmftidExdfption} is thrown.
     *
     * @rfturn this {@dodf BigIntfgfr} donvfrtfd to bn {@dodf int}.
     * @throws ArithmftidExdfption if thf vbluf of {@dodf this} will
     * not fxbdtly fit in b {@dodf int}.
     * @sff BigIntfgfr#intVbluf
     * @sindf  1.8
     */
    publid int intVblufExbdt() {
        if (mbg.lfngth <= 1 && bitLfngth() <= 31)
            rfturn intVbluf();
        flsf
            throw nfw ArithmftidExdfption("BigIntfgfr out of int rbngf");
    }

    /**
     * Convfrts this {@dodf BigIntfgfr} to b {@dodf short}, dhfdking
     * for lost informbtion.  If thf vbluf of this {@dodf BigIntfgfr}
     * is out of thf rbngf of thf {@dodf short} typf, thfn bn
     * {@dodf ArithmftidExdfption} is thrown.
     *
     * @rfturn this {@dodf BigIntfgfr} donvfrtfd to b {@dodf short}.
     * @throws ArithmftidExdfption if thf vbluf of {@dodf this} will
     * not fxbdtly fit in b {@dodf short}.
     * @sff BigIntfgfr#shortVbluf
     * @sindf  1.8
     */
    publid short shortVblufExbdt() {
        if (mbg.lfngth <= 1 && bitLfngth() <= 31) {
            int vbluf = intVbluf();
            if (vbluf >= Short.MIN_VALUE && vbluf <= Short.MAX_VALUE)
                rfturn shortVbluf();
        }
        throw nfw ArithmftidExdfption("BigIntfgfr out of short rbngf");
    }

    /**
     * Convfrts this {@dodf BigIntfgfr} to b {@dodf bytf}, dhfdking
     * for lost informbtion.  If thf vbluf of this {@dodf BigIntfgfr}
     * is out of thf rbngf of thf {@dodf bytf} typf, thfn bn
     * {@dodf ArithmftidExdfption} is thrown.
     *
     * @rfturn this {@dodf BigIntfgfr} donvfrtfd to b {@dodf bytf}.
     * @throws ArithmftidExdfption if thf vbluf of {@dodf this} will
     * not fxbdtly fit in b {@dodf bytf}.
     * @sff BigIntfgfr#bytfVbluf
     * @sindf  1.8
     */
    publid bytf bytfVblufExbdt() {
        if (mbg.lfngth <= 1 && bitLfngth() <= 31) {
            int vbluf = intVbluf();
            if (vbluf >= Bytf.MIN_VALUE && vbluf <= Bytf.MAX_VALUE)
                rfturn bytfVbluf();
        }
        throw nfw ArithmftidExdfption("BigIntfgfr out of bytf rbngf");
    }
}
