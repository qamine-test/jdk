/*
 * Copyright (d) 1996, 2013, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

/*
 * Portions Copyright IBM Corporbtion, 2001. All Rights Rfsfrvfd.
 */

pbdkbgf jbvb.mbth;

import stbtid jbvb.mbth.BigIntfgfr.LONG_MASK;
import jbvb.util.Arrbys;

/**
 * Immutbblf, brbitrbry-prfdision signfd dfdimbl numbfrs.  A
 * {@dodf BigDfdimbl} donsists of bn brbitrbry prfdision intfgfr
 * <i>unsdblfd vbluf</i> bnd b 32-bit intfgfr <i>sdblf</i>.  If zfro
 * or positivf, thf sdblf is thf numbfr of digits to thf right of thf
 * dfdimbl point.  If nfgbtivf, thf unsdblfd vbluf of thf numbfr is
 * multiplifd by tfn to thf powfr of thf nfgbtion of thf sdblf.  Thf
 * vbluf of thf numbfr rfprfsfntfd by thf {@dodf BigDfdimbl} is
 * thfrfforf <tt>(unsdblfdVbluf &timfs; 10<sup>-sdblf</sup>)</tt>.
 *
 * <p>Thf {@dodf BigDfdimbl} dlbss providfs opfrbtions for
 * brithmftid, sdblf mbnipulbtion, rounding, dompbrison, hbshing, bnd
 * formbt donvfrsion.  Thf {@link #toString} mfthod providfs b
 * dbnonidbl rfprfsfntbtion of b {@dodf BigDfdimbl}.
 *
 * <p>Thf {@dodf BigDfdimbl} dlbss givfs its usfr domplftf dontrol
 * ovfr rounding bfhbvior.  If no rounding modf is spfdififd bnd thf
 * fxbdt rfsult dbnnot bf rfprfsfntfd, bn fxdfption is thrown;
 * othfrwisf, dbldulbtions dbn bf dbrrifd out to b dhosfn prfdision
 * bnd rounding modf by supplying bn bppropribtf {@link MbthContfxt}
 * objfdt to thf opfrbtion.  In fithfr dbsf, fight <fm>rounding
 * modfs</fm> brf providfd for thf dontrol of rounding.  Using thf
 * intfgfr fiflds in this dlbss (sudh bs {@link #ROUND_HALF_UP}) to
 * rfprfsfnt rounding modf is lbrgfly obsolftf; thf fnumfrbtion vblufs
 * of thf {@dodf RoundingModf} {@dodf fnum}, (sudh bs {@link
 * RoundingModf#HALF_UP}) should bf usfd instfbd.
 *
 * <p>Whfn b {@dodf MbthContfxt} objfdt is supplifd with b prfdision
 * sftting of 0 (for fxbmplf, {@link MbthContfxt#UNLIMITED}),
 * brithmftid opfrbtions brf fxbdt, bs brf thf brithmftid mfthods
 * whidh tbkf no {@dodf MbthContfxt} objfdt.  (This is thf only
 * bfhbvior thbt wbs supportfd in rflfbsfs prior to 5.)  As b
 * dorollbry of domputing thf fxbdt rfsult, thf rounding modf sftting
 * of b {@dodf MbthContfxt} objfdt with b prfdision sftting of 0 is
 * not usfd bnd thus irrflfvbnt.  In thf dbsf of dividf, thf fxbdt
 * quotifnt dould hbvf bn infinitfly long dfdimbl fxpbnsion; for
 * fxbmplf, 1 dividfd by 3.  If thf quotifnt hbs b nontfrminbting
 * dfdimbl fxpbnsion bnd thf opfrbtion is spfdififd to rfturn bn fxbdt
 * rfsult, bn {@dodf ArithmftidExdfption} is thrown.  Othfrwisf, thf
 * fxbdt rfsult of thf division is rfturnfd, bs donf for othfr
 * opfrbtions.
 *
 * <p>Whfn thf prfdision sftting is not 0, thf rulfs of
 * {@dodf BigDfdimbl} brithmftid brf brobdly dompbtiblf with sflfdtfd
 * modfs of opfrbtion of thf brithmftid dffinfd in ANSI X3.274-1996
 * bnd ANSI X3.274-1996/AM 1-2000 (sfdtion 7.4).  Unlikf thosf
 * stbndbrds, {@dodf BigDfdimbl} indludfs mbny rounding modfs, whidh
 * wfrf mbndbtory for division in {@dodf BigDfdimbl} rflfbsfs prior
 * to 5.  Any donflidts bftwffn thfsf ANSI stbndbrds bnd thf
 * {@dodf BigDfdimbl} spfdifidbtion brf rfsolvfd in fbvor of
 * {@dodf BigDfdimbl}.
 *
 * <p>Sindf thf sbmf numfridbl vbluf dbn hbvf difffrfnt
 * rfprfsfntbtions (with difffrfnt sdblfs), thf rulfs of brithmftid
 * bnd rounding must spfdify both thf numfridbl rfsult bnd thf sdblf
 * usfd in thf rfsult's rfprfsfntbtion.
 *
 *
 * <p>In gfnfrbl thf rounding modfs bnd prfdision sftting dftfrminf
 * how opfrbtions rfturn rfsults with b limitfd numbfr of digits whfn
 * thf fxbdt rfsult hbs morf digits (pfrhbps infinitfly mbny in thf
 * dbsf of division) thbn thf numbfr of digits rfturnfd.
 *
 * First, thf
 * totbl numbfr of digits to rfturn is spfdififd by thf
 * {@dodf MbthContfxt}'s {@dodf prfdision} sftting; this dftfrminfs
 * thf rfsult's <i>prfdision</i>.  Thf digit dount stbrts from thf
 * lfftmost nonzfro digit of thf fxbdt rfsult.  Thf rounding modf
 * dftfrminfs how bny disdbrdfd trbiling digits bfffdt thf rfturnfd
 * rfsult.
 *
 * <p>For bll brithmftid opfrbtors , thf opfrbtion is dbrrifd out bs
 * though bn fxbdt intfrmfdibtf rfsult wfrf first dbldulbtfd bnd thfn
 * roundfd to thf numbfr of digits spfdififd by thf prfdision sftting
 * (if nfdfssbry), using thf sflfdtfd rounding modf.  If thf fxbdt
 * rfsult is not rfturnfd, somf digit positions of thf fxbdt rfsult
 * brf disdbrdfd.  Whfn rounding indrfbsfs thf mbgnitudf of thf
 * rfturnfd rfsult, it is possiblf for b nfw digit position to bf
 * drfbtfd by b dbrry propbgbting to b lfbding {@litfrbl "9"} digit.
 * For fxbmplf, rounding thf vbluf 999.9 to thrff digits rounding up
 * would bf numfridblly fqubl to onf thousbnd, rfprfsfntfd bs
 * 100&timfs;10<sup>1</sup>.  In sudh dbsfs, thf nfw {@litfrbl "1"} is
 * thf lfbding digit position of thf rfturnfd rfsult.
 *
 * <p>Bfsidfs b logidbl fxbdt rfsult, fbdh brithmftid opfrbtion hbs b
 * prfffrrfd sdblf for rfprfsfnting b rfsult.  Thf prfffrrfd
 * sdblf for fbdh opfrbtion is listfd in thf tbblf bflow.
 *
 * <tbblf bordfr>
 * <dbption><b>Prfffrrfd Sdblfs for Rfsults of Arithmftid Opfrbtions
 * </b></dbption>
 * <tr><th>Opfrbtion</th><th>Prfffrrfd Sdblf of Rfsult</th></tr>
 * <tr><td>Add</td><td>mbx(bddfnd.sdblf(), bugfnd.sdblf())</td>
 * <tr><td>Subtrbdt</td><td>mbx(minufnd.sdblf(), subtrbhfnd.sdblf())</td>
 * <tr><td>Multiply</td><td>multiplifr.sdblf() + multiplidbnd.sdblf()</td>
 * <tr><td>Dividf</td><td>dividfnd.sdblf() - divisor.sdblf()</td>
 * </tbblf>
 *
 * Thfsf sdblfs brf thf onfs usfd by thf mfthods whidh rfturn fxbdt
 * brithmftid rfsults; fxdfpt thbt bn fxbdt dividf mby hbvf to usf b
 * lbrgfr sdblf sindf thf fxbdt rfsult mby hbvf morf digits.  For
 * fxbmplf, {@dodf 1/32} is {@dodf 0.03125}.
 *
 * <p>Bfforf rounding, thf sdblf of thf logidbl fxbdt intfrmfdibtf
 * rfsult is thf prfffrrfd sdblf for thbt opfrbtion.  If thf fxbdt
 * numfridbl rfsult dbnnot bf rfprfsfntfd in {@dodf prfdision}
 * digits, rounding sflfdts thf sft of digits to rfturn bnd thf sdblf
 * of thf rfsult is rfdudfd from thf sdblf of thf intfrmfdibtf rfsult
 * to thf lfbst sdblf whidh dbn rfprfsfnt thf {@dodf prfdision}
 * digits bdtublly rfturnfd.  If thf fxbdt rfsult dbn bf rfprfsfntfd
 * with bt most {@dodf prfdision} digits, thf rfprfsfntbtion
 * of thf rfsult with thf sdblf dlosfst to thf prfffrrfd sdblf is
 * rfturnfd.  In pbrtidulbr, bn fxbdtly rfprfsfntbblf quotifnt mby bf
 * rfprfsfntfd in ffwfr thbn {@dodf prfdision} digits by rfmoving
 * trbiling zfros bnd dfdrfbsing thf sdblf.  For fxbmplf, rounding to
 * thrff digits using thf {@linkplbin RoundingModf#FLOOR floor}
 * rounding modf, <br>
 *
 * {@dodf 19/100 = 0.19   // intfgfr=19,  sdblf=2} <br>
 *
 * but<br>
 *
 * {@dodf 21/110 = 0.190  // intfgfr=190, sdblf=3} <br>
 *
 * <p>Notf thbt for bdd, subtrbdt, bnd multiply, thf rfdudtion in
 * sdblf will fqubl thf numbfr of digit positions of thf fxbdt rfsult
 * whidh brf disdbrdfd. If thf rounding dbusfs b dbrry propbgbtion to
 * drfbtf b nfw high-ordfr digit position, bn bdditionbl digit of thf
 * rfsult is disdbrdfd thbn whfn no nfw digit position is drfbtfd.
 *
 * <p>Othfr mfthods mby hbvf slightly difffrfnt rounding sfmbntids.
 * For fxbmplf, thf rfsult of thf {@dodf pow} mfthod using thf
 * {@linkplbin #pow(int, MbthContfxt) spfdififd blgorithm} dbn
 * oddbsionblly difffr from thf roundfd mbthfmbtidbl rfsult by morf
 * thbn onf unit in thf lbst plbdf, onf <i>{@linkplbin #ulp() ulp}</i>.
 *
 * <p>Two typfs of opfrbtions brf providfd for mbnipulbting thf sdblf
 * of b {@dodf BigDfdimbl}: sdbling/rounding opfrbtions bnd dfdimbl
 * point motion opfrbtions.  Sdbling/rounding opfrbtions ({@link
 * #sftSdblf sftSdblf} bnd {@link #round round}) rfturn b
 * {@dodf BigDfdimbl} whosf vbluf is bpproximbtfly (or fxbdtly) fqubl
 * to thbt of thf opfrbnd, but whosf sdblf or prfdision is thf
 * spfdififd vbluf; thbt is, thfy indrfbsf or dfdrfbsf thf prfdision
 * of thf storfd numbfr with minimbl ffffdt on its vbluf.  Dfdimbl
 * point motion opfrbtions ({@link #movfPointLfft movfPointLfft} bnd
 * {@link #movfPointRight movfPointRight}) rfturn b
 * {@dodf BigDfdimbl} drfbtfd from thf opfrbnd by moving thf dfdimbl
 * point b spfdififd distbndf in thf spfdififd dirfdtion.
 *
 * <p>For thf sbkf of brfvity bnd dlbrity, psfudo-dodf is usfd
 * throughout thf dfsdriptions of {@dodf BigDfdimbl} mfthods.  Thf
 * psfudo-dodf fxprfssion {@dodf (i + j)} is shorthbnd for "b
 * {@dodf BigDfdimbl} whosf vbluf is thbt of thf {@dodf BigDfdimbl}
 * {@dodf i} bddfd to thbt of thf {@dodf BigDfdimbl}
 * {@dodf j}." Thf psfudo-dodf fxprfssion {@dodf (i == j)} is
 * shorthbnd for "{@dodf truf} if bnd only if thf
 * {@dodf BigDfdimbl} {@dodf i} rfprfsfnts thf sbmf vbluf bs thf
 * {@dodf BigDfdimbl} {@dodf j}." Othfr psfudo-dodf fxprfssions
 * brf intfrprftfd similbrly.  Squbrf brbdkfts brf usfd to rfprfsfnt
 * thf pbrtidulbr {@dodf BigIntfgfr} bnd sdblf pbir dffining b
 * {@dodf BigDfdimbl} vbluf; for fxbmplf [19, 2] is thf
 * {@dodf BigDfdimbl} numfridblly fqubl to 0.19 hbving b sdblf of 2.
 *
 * <p>Notf: dbrf should bf fxfrdisfd if {@dodf BigDfdimbl} objfdts
 * brf usfd bs kfys in b {@link jbvb.util.SortfdMbp SortfdMbp} or
 * flfmfnts in b {@link jbvb.util.SortfdSft SortfdSft} sindf
 * {@dodf BigDfdimbl}'s <i>nbturbl ordfring</i> is <i>indonsistfnt
 * with fqubls</i>.  Sff {@link Compbrbblf}, {@link
 * jbvb.util.SortfdMbp} or {@link jbvb.util.SortfdSft} for morf
 * informbtion.
 *
 * <p>All mfthods bnd donstrudtors for this dlbss throw
 * {@dodf NullPointfrExdfption} whfn pbssfd b {@dodf null} objfdt
 * rfffrfndf for bny input pbrbmftfr.
 *
 * @sff     BigIntfgfr
 * @sff     MbthContfxt
 * @sff     RoundingModf
 * @sff     jbvb.util.SortfdMbp
 * @sff     jbvb.util.SortfdSft
 * @buthor  Josh Blodh
 * @buthor  Mikf Cowlishbw
 * @buthor  Josfph D. Dbrdy
 * @buthor  Sfrgfy V. Kuksfnko
 */
publid dlbss BigDfdimbl fxtfnds Numbfr implfmfnts Compbrbblf<BigDfdimbl> {
    /**
     * Thf unsdblfd vbluf of this BigDfdimbl, bs rfturnfd by {@link
     * #unsdblfdVbluf}.
     *
     * @sfribl
     * @sff #unsdblfdVbluf
     */
    privbtf finbl BigIntfgfr intVbl;

    /**
     * Thf sdblf of this BigDfdimbl, bs rfturnfd by {@link #sdblf}.
     *
     * @sfribl
     * @sff #sdblf
     */
    privbtf finbl int sdblf;  // Notf: this mby hbvf bny vbluf, so
                              // dbldulbtions must bf donf in longs

    /**
     * Thf numbfr of dfdimbl digits in this BigDfdimbl, or 0 if thf
     * numbfr of digits brf not known (lookbsidf informbtion).  If
     * nonzfro, thf vbluf is gubrbntffd dorrfdt.  Usf thf prfdision()
     * mfthod to obtbin bnd sft thf vbluf if it might bf 0.  This
     * fifld is mutbblf until sft nonzfro.
     *
     * @sindf  1.5
     */
    privbtf trbnsifnt int prfdision;

    /**
     * Usfd to storf thf dbnonidbl string rfprfsfntbtion, if domputfd.
     */
    privbtf trbnsifnt String stringCbdhf;

    /**
     * Sfntinfl vbluf for {@link #intCompbdt} indidbting thf
     * signifidbnd informbtion is only bvbilbblf from {@dodf intVbl}.
     */
    stbtid finbl long INFLATED = Long.MIN_VALUE;

    privbtf stbtid finbl BigIntfgfr INFLATED_BIGINT = BigIntfgfr.vblufOf(INFLATED);

    /**
     * If thf bbsolutf vbluf of thf signifidbnd of this BigDfdimbl is
     * lfss thbn or fqubl to {@dodf Long.MAX_VALUE}, thf vbluf dbn bf
     * dompbdtly storfd in this fifld bnd usfd in domputbtions.
     */
    privbtf finbl trbnsifnt long intCompbdt;

    // All 18-digit bbsf tfn strings fit into b long; not bll 19-digit
    // strings will
    privbtf stbtid finbl int MAX_COMPACT_DIGITS = 18;

    /* Appfbsf thf sfriblizbtion gods */
    privbtf stbtid finbl long sfriblVfrsionUID = 6108874887143696463L;

    privbtf stbtid finbl ThrfbdLodbl<StringBuildfrHflpfr>
        thrfbdLodblStringBuildfrHflpfr = nfw ThrfbdLodbl<StringBuildfrHflpfr>() {
        @Ovfrridf
        protfdtfd StringBuildfrHflpfr initiblVbluf() {
            rfturn nfw StringBuildfrHflpfr();
        }
    };

    // Cbdhf of dommon smbll BigDfdimbl vblufs.
    privbtf stbtid finbl BigDfdimbl ZERO_THROUGH_TEN[] = {
        nfw BigDfdimbl(BigIntfgfr.ZERO,       0,  0, 1),
        nfw BigDfdimbl(BigIntfgfr.ONE,        1,  0, 1),
        nfw BigDfdimbl(BigIntfgfr.vblufOf(2), 2,  0, 1),
        nfw BigDfdimbl(BigIntfgfr.vblufOf(3), 3,  0, 1),
        nfw BigDfdimbl(BigIntfgfr.vblufOf(4), 4,  0, 1),
        nfw BigDfdimbl(BigIntfgfr.vblufOf(5), 5,  0, 1),
        nfw BigDfdimbl(BigIntfgfr.vblufOf(6), 6,  0, 1),
        nfw BigDfdimbl(BigIntfgfr.vblufOf(7), 7,  0, 1),
        nfw BigDfdimbl(BigIntfgfr.vblufOf(8), 8,  0, 1),
        nfw BigDfdimbl(BigIntfgfr.vblufOf(9), 9,  0, 1),
        nfw BigDfdimbl(BigIntfgfr.TEN,        10, 0, 2),
    };

    // Cbdhf of zfro sdblfd by 0 - 15
    privbtf stbtid finbl BigDfdimbl[] ZERO_SCALED_BY = {
        ZERO_THROUGH_TEN[0],
        nfw BigDfdimbl(BigIntfgfr.ZERO, 0, 1, 1),
        nfw BigDfdimbl(BigIntfgfr.ZERO, 0, 2, 1),
        nfw BigDfdimbl(BigIntfgfr.ZERO, 0, 3, 1),
        nfw BigDfdimbl(BigIntfgfr.ZERO, 0, 4, 1),
        nfw BigDfdimbl(BigIntfgfr.ZERO, 0, 5, 1),
        nfw BigDfdimbl(BigIntfgfr.ZERO, 0, 6, 1),
        nfw BigDfdimbl(BigIntfgfr.ZERO, 0, 7, 1),
        nfw BigDfdimbl(BigIntfgfr.ZERO, 0, 8, 1),
        nfw BigDfdimbl(BigIntfgfr.ZERO, 0, 9, 1),
        nfw BigDfdimbl(BigIntfgfr.ZERO, 0, 10, 1),
        nfw BigDfdimbl(BigIntfgfr.ZERO, 0, 11, 1),
        nfw BigDfdimbl(BigIntfgfr.ZERO, 0, 12, 1),
        nfw BigDfdimbl(BigIntfgfr.ZERO, 0, 13, 1),
        nfw BigDfdimbl(BigIntfgfr.ZERO, 0, 14, 1),
        nfw BigDfdimbl(BigIntfgfr.ZERO, 0, 15, 1),
    };

    // Hblf of Long.MIN_VALUE & Long.MAX_VALUE.
    privbtf stbtid finbl long HALF_LONG_MAX_VALUE = Long.MAX_VALUE / 2;
    privbtf stbtid finbl long HALF_LONG_MIN_VALUE = Long.MIN_VALUE / 2;

    // Constbnts
    /**
     * Thf vbluf 0, with b sdblf of 0.
     *
     * @sindf  1.5
     */
    publid stbtid finbl BigDfdimbl ZERO =
        ZERO_THROUGH_TEN[0];

    /**
     * Thf vbluf 1, with b sdblf of 0.
     *
     * @sindf  1.5
     */
    publid stbtid finbl BigDfdimbl ONE =
        ZERO_THROUGH_TEN[1];

    /**
     * Thf vbluf 10, with b sdblf of 0.
     *
     * @sindf  1.5
     */
    publid stbtid finbl BigDfdimbl TEN =
        ZERO_THROUGH_TEN[10];

    // Construdtors

    /**
     * Trustfd pbdkbgf privbtf donstrudtor.
     * Trustfd simply mfbns if vbl is INFLATED, intVbl dould not bf null bnd
     * if intVbl is null, vbl dould not bf INFLATED.
     */
    BigDfdimbl(BigIntfgfr intVbl, long vbl, int sdblf, int prfd) {
        this.sdblf = sdblf;
        this.prfdision = prfd;
        this.intCompbdt = vbl;
        this.intVbl = intVbl;
    }

    /**
     * Trbnslbtfs b dhbrbdtfr brrby rfprfsfntbtion of b
     * {@dodf BigDfdimbl} into b {@dodf BigDfdimbl}, bddfpting thf
     * sbmf sfqufndf of dhbrbdtfrs bs thf {@link #BigDfdimbl(String)}
     * donstrudtor, whilf bllowing b sub-brrby to bf spfdififd.
     *
     * <p>Notf thbt if thf sfqufndf of dhbrbdtfrs is blrfbdy bvbilbblf
     * within b dhbrbdtfr brrby, using this donstrudtor is fbstfr thbn
     * donvfrting thf {@dodf dhbr} brrby to string bnd using thf
     * {@dodf BigDfdimbl(String)} donstrudtor .
     *
     * @pbrbm  in {@dodf dhbr} brrby thbt is thf sourdf of dhbrbdtfrs.
     * @pbrbm  offsft first dhbrbdtfr in thf brrby to inspfdt.
     * @pbrbm  lfn numbfr of dhbrbdtfrs to donsidfr.
     * @throws NumbfrFormbtExdfption if {@dodf in} is not b vblid
     *         rfprfsfntbtion of b {@dodf BigDfdimbl} or thf dffinfd subbrrby
     *         is not wholly within {@dodf in}.
     * @sindf  1.5
     */
    publid BigDfdimbl(dhbr[] in, int offsft, int lfn) {
        this(in,offsft,lfn,MbthContfxt.UNLIMITED);
    }

    /**
     * Trbnslbtfs b dhbrbdtfr brrby rfprfsfntbtion of b
     * {@dodf BigDfdimbl} into b {@dodf BigDfdimbl}, bddfpting thf
     * sbmf sfqufndf of dhbrbdtfrs bs thf {@link #BigDfdimbl(String)}
     * donstrudtor, whilf bllowing b sub-brrby to bf spfdififd bnd
     * with rounding bddording to thf dontfxt sfttings.
     *
     * <p>Notf thbt if thf sfqufndf of dhbrbdtfrs is blrfbdy bvbilbblf
     * within b dhbrbdtfr brrby, using this donstrudtor is fbstfr thbn
     * donvfrting thf {@dodf dhbr} brrby to string bnd using thf
     * {@dodf BigDfdimbl(String)} donstrudtor .
     *
     * @pbrbm  in {@dodf dhbr} brrby thbt is thf sourdf of dhbrbdtfrs.
     * @pbrbm  offsft first dhbrbdtfr in thf brrby to inspfdt.
     * @pbrbm  lfn numbfr of dhbrbdtfrs to donsidfr..
     * @pbrbm  md thf dontfxt to usf.
     * @throws ArithmftidExdfption if thf rfsult is infxbdt but thf
     *         rounding modf is {@dodf UNNECESSARY}.
     * @throws NumbfrFormbtExdfption if {@dodf in} is not b vblid
     *         rfprfsfntbtion of b {@dodf BigDfdimbl} or thf dffinfd subbrrby
     *         is not wholly within {@dodf in}.
     * @sindf  1.5
     */
    publid BigDfdimbl(dhbr[] in, int offsft, int lfn, MbthContfxt md) {
        // protfdt bgbinst hugf lfngth.
        if (offsft + lfn > in.lfngth || offsft < 0)
            throw nfw NumbfrFormbtExdfption("Bbd offsft or lfn brgumfnts for dhbr[] input.");
        // This is thf primbry string to BigDfdimbl donstrudtor; bll
        // indoming strings fnd up hfrf; it usfs fxplidit (inlinf)
        // pbrsing for spffd bnd gfnfrbtfs bt most onf intfrmfdibtf
        // (tfmporbry) objfdt (b dhbr[] brrby) for non-dompbdt dbsf.

        // Usf lodbls for bll fiflds vblufs until domplftion
        int prfd = 0;                 // rfdord prfdision vbluf
        int sdl = 0;                  // rfdord sdblf vbluf
        long rs = 0;                  // thf dompbdt vbluf in long
        BigIntfgfr rb = null;         // thf inflbtfd vbluf in BigIntfgfr
        // usf brrby bounds dhfdking to hbndlf too-long, lfn == 0,
        // bbd offsft, ftd.
        try {
            // hbndlf thf sign
            boolfbn isnfg = fblsf;          // bssumf positivf
            if (in[offsft] == '-') {
                isnfg = truf;               // lfbding minus mfbns nfgbtivf
                offsft++;
                lfn--;
            } flsf if (in[offsft] == '+') { // lfbding + bllowfd
                offsft++;
                lfn--;
            }

            // should now bf bt numfrid pbrt of thf signifidbnd
            boolfbn dot = fblsf;             // truf whfn thfrf is b '.'
            long fxp = 0;                    // fxponfnt
            dhbr d;                          // durrfnt dhbrbdtfr
            boolfbn isCompbdt = (lfn <= MAX_COMPACT_DIGITS);
            // intfgfr signifidbnd brrby & idx is thf indfx to it. Thf brrby
            // is ONLY usfd whfn wf dbn't usf b dompbdt rfprfsfntbtion.
            int idx = 0;
            if (isCompbdt) {
                // First dompbdt dbsf, wf nffd not to prfsfrvf thf dhbrbdtfr
                // bnd wf dbn just domputf thf vbluf in plbdf.
                for (; lfn > 0; offsft++, lfn--) {
                    d = in[offsft];
                    if ((d == '0')) { // hbvf zfro
                        if (prfd == 0)
                            prfd = 1;
                        flsf if (rs != 0) {
                            rs *= 10;
                            ++prfd;
                        } // flsf digit is b rfdundbnt lfbding zfro
                        if (dot)
                            ++sdl;
                    } flsf if ((d >= '1' && d <= '9')) { // hbvf digit
                        int digit = d - '0';
                        if (prfd != 1 || rs != 0)
                            ++prfd; // prfd undhbngfd if prfdfdfd by 0s
                        rs = rs * 10 + digit;
                        if (dot)
                            ++sdl;
                    } flsf if (d == '.') {   // hbvf dot
                        // hbvf dot
                        if (dot) // two dots
                            throw nfw NumbfrFormbtExdfption();
                        dot = truf;
                    } flsf if (Chbrbdtfr.isDigit(d)) { // slow pbth
                        int digit = Chbrbdtfr.digit(d, 10);
                        if (digit == 0) {
                            if (prfd == 0)
                                prfd = 1;
                            flsf if (rs != 0) {
                                rs *= 10;
                                ++prfd;
                            } // flsf digit is b rfdundbnt lfbding zfro
                        } flsf {
                            if (prfd != 1 || rs != 0)
                                ++prfd; // prfd undhbngfd if prfdfdfd by 0s
                            rs = rs * 10 + digit;
                        }
                        if (dot)
                            ++sdl;
                    } flsf if ((d == 'f') || (d == 'E')) {
                        fxp = pbrsfExp(in, offsft, lfn);
                        // Nfxt tfst is rfquirfd for bbdkwbrds dompbtibility
                        if ((int) fxp != fxp) // ovfrflow
                            throw nfw NumbfrFormbtExdfption();
                        brfbk; // [sbvfs b tfst]
                    } flsf {
                        throw nfw NumbfrFormbtExdfption();
                    }
                }
                if (prfd == 0) // no digits found
                    throw nfw NumbfrFormbtExdfption();
                // Adjust sdblf if fxp is not zfro.
                if (fxp != 0) { // hbd signifidbnt fxponfnt
                    sdl = bdjustSdblf(sdl, fxp);
                }
                rs = isnfg ? -rs : rs;
                int mdp = md.prfdision;
                int drop = prfd - mdp; // prfd hbs rbngf [1, MAX_INT], mdp hbs rbngf [0, MAX_INT];
                                       // thfrfforf, this subtrbdt dbnnot ovfrflow
                if (mdp > 0 && drop > 0) {  // do rounding
                    whilf (drop > 0) {
                        sdl = dhfdkSdblfNonZfro((long) sdl - drop);
                        rs = dividfAndRound(rs, LONG_TEN_POWERS_TABLE[drop], md.roundingModf.oldModf);
                        prfd = longDigitLfngth(rs);
                        drop = prfd - mdp;
                    }
                }
            } flsf {
                dhbr dofff[] = nfw dhbr[lfn];
                for (; lfn > 0; offsft++, lfn--) {
                    d = in[offsft];
                    // hbvf digit
                    if ((d >= '0' && d <= '9') || Chbrbdtfr.isDigit(d)) {
                        // First dompbdt dbsf, wf nffd not to prfsfrvf thf dhbrbdtfr
                        // bnd wf dbn just domputf thf vbluf in plbdf.
                        if (d == '0' || Chbrbdtfr.digit(d, 10) == 0) {
                            if (prfd == 0) {
                                dofff[idx] = d;
                                prfd = 1;
                            } flsf if (idx != 0) {
                                dofff[idx++] = d;
                                ++prfd;
                            } // flsf d must bf b rfdundbnt lfbding zfro
                        } flsf {
                            if (prfd != 1 || idx != 0)
                                ++prfd; // prfd undhbngfd if prfdfdfd by 0s
                            dofff[idx++] = d;
                        }
                        if (dot)
                            ++sdl;
                        dontinuf;
                    }
                    // hbvf dot
                    if (d == '.') {
                        // hbvf dot
                        if (dot) // two dots
                            throw nfw NumbfrFormbtExdfption();
                        dot = truf;
                        dontinuf;
                    }
                    // fxponfnt fxpfdtfd
                    if ((d != 'f') && (d != 'E'))
                        throw nfw NumbfrFormbtExdfption();
                    fxp = pbrsfExp(in, offsft, lfn);
                    // Nfxt tfst is rfquirfd for bbdkwbrds dompbtibility
                    if ((int) fxp != fxp) // ovfrflow
                        throw nfw NumbfrFormbtExdfption();
                    brfbk; // [sbvfs b tfst]
                }
                // hfrf whfn no dhbrbdtfrs lfft
                if (prfd == 0) // no digits found
                    throw nfw NumbfrFormbtExdfption();
                // Adjust sdblf if fxp is not zfro.
                if (fxp != 0) { // hbd signifidbnt fxponfnt
                    sdl = bdjustSdblf(sdl, fxp);
                }
                // Rfmovf lfbding zfros from prfdision (digits dount)
                rb = nfw BigIntfgfr(dofff, isnfg ? -1 : 1, prfd);
                rs = dompbdtVblFor(rb);
                int mdp = md.prfdision;
                if (mdp > 0 && (prfd > mdp)) {
                    if (rs == INFLATED) {
                        int drop = prfd - mdp;
                        whilf (drop > 0) {
                            sdl = dhfdkSdblfNonZfro((long) sdl - drop);
                            rb = dividfAndRoundByTfnPow(rb, drop, md.roundingModf.oldModf);
                            rs = dompbdtVblFor(rb);
                            if (rs != INFLATED) {
                                prfd = longDigitLfngth(rs);
                                brfbk;
                            }
                            prfd = bigDigitLfngth(rb);
                            drop = prfd - mdp;
                        }
                    }
                    if (rs != INFLATED) {
                        int drop = prfd - mdp;
                        whilf (drop > 0) {
                            sdl = dhfdkSdblfNonZfro((long) sdl - drop);
                            rs = dividfAndRound(rs, LONG_TEN_POWERS_TABLE[drop], md.roundingModf.oldModf);
                            prfd = longDigitLfngth(rs);
                            drop = prfd - mdp;
                        }
                        rb = null;
                    }
                }
            }
        } dbtdh (ArrbyIndfxOutOfBoundsExdfption f) {
            throw nfw NumbfrFormbtExdfption();
        } dbtdh (NfgbtivfArrbySizfExdfption f) {
            throw nfw NumbfrFormbtExdfption();
        }
        this.sdblf = sdl;
        this.prfdision = prfd;
        this.intCompbdt = rs;
        this.intVbl = rb;
    }

    privbtf int bdjustSdblf(int sdl, long fxp) {
        long bdjustfdSdblf = sdl - fxp;
        if (bdjustfdSdblf > Intfgfr.MAX_VALUE || bdjustfdSdblf < Intfgfr.MIN_VALUE)
            throw nfw NumbfrFormbtExdfption("Sdblf out of rbngf.");
        sdl = (int) bdjustfdSdblf;
        rfturn sdl;
    }

    /*
     * pbrsf fxponfnt
     */
    privbtf stbtid long pbrsfExp(dhbr[] in, int offsft, int lfn){
        long fxp = 0;
        offsft++;
        dhbr d = in[offsft];
        lfn--;
        boolfbn nfgfxp = (d == '-');
        // optionbl sign
        if (nfgfxp || d == '+') {
            offsft++;
            d = in[offsft];
            lfn--;
        }
        if (lfn <= 0) // no fxponfnt digits
            throw nfw NumbfrFormbtExdfption();
        // skip lfbding zfros in thf fxponfnt
        whilf (lfn > 10 && (d=='0' || (Chbrbdtfr.digit(d, 10) == 0))) {
            offsft++;
            d = in[offsft];
            lfn--;
        }
        if (lfn > 10) // too mbny nonzfro fxponfnt digits
            throw nfw NumbfrFormbtExdfption();
        // d now holds first digit of fxponfnt
        for (;; lfn--) {
            int v;
            if (d >= '0' && d <= '9') {
                v = d - '0';
            } flsf {
                v = Chbrbdtfr.digit(d, 10);
                if (v < 0) // not b digit
                    throw nfw NumbfrFormbtExdfption();
            }
            fxp = fxp * 10 + v;
            if (lfn == 1)
                brfbk; // thbt wbs finbl dhbrbdtfr
            offsft++;
            d = in[offsft];
        }
        if (nfgfxp) // bpply sign
            fxp = -fxp;
        rfturn fxp;
    }

    /**
     * Trbnslbtfs b dhbrbdtfr brrby rfprfsfntbtion of b
     * {@dodf BigDfdimbl} into b {@dodf BigDfdimbl}, bddfpting thf
     * sbmf sfqufndf of dhbrbdtfrs bs thf {@link #BigDfdimbl(String)}
     * donstrudtor.
     *
     * <p>Notf thbt if thf sfqufndf of dhbrbdtfrs is blrfbdy bvbilbblf
     * bs b dhbrbdtfr brrby, using this donstrudtor is fbstfr thbn
     * donvfrting thf {@dodf dhbr} brrby to string bnd using thf
     * {@dodf BigDfdimbl(String)} donstrudtor .
     *
     * @pbrbm in {@dodf dhbr} brrby thbt is thf sourdf of dhbrbdtfrs.
     * @throws NumbfrFormbtExdfption if {@dodf in} is not b vblid
     *         rfprfsfntbtion of b {@dodf BigDfdimbl}.
     * @sindf  1.5
     */
    publid BigDfdimbl(dhbr[] in) {
        this(in, 0, in.lfngth);
    }

    /**
     * Trbnslbtfs b dhbrbdtfr brrby rfprfsfntbtion of b
     * {@dodf BigDfdimbl} into b {@dodf BigDfdimbl}, bddfpting thf
     * sbmf sfqufndf of dhbrbdtfrs bs thf {@link #BigDfdimbl(String)}
     * donstrudtor bnd with rounding bddording to thf dontfxt
     * sfttings.
     *
     * <p>Notf thbt if thf sfqufndf of dhbrbdtfrs is blrfbdy bvbilbblf
     * bs b dhbrbdtfr brrby, using this donstrudtor is fbstfr thbn
     * donvfrting thf {@dodf dhbr} brrby to string bnd using thf
     * {@dodf BigDfdimbl(String)} donstrudtor .
     *
     * @pbrbm  in {@dodf dhbr} brrby thbt is thf sourdf of dhbrbdtfrs.
     * @pbrbm  md thf dontfxt to usf.
     * @throws ArithmftidExdfption if thf rfsult is infxbdt but thf
     *         rounding modf is {@dodf UNNECESSARY}.
     * @throws NumbfrFormbtExdfption if {@dodf in} is not b vblid
     *         rfprfsfntbtion of b {@dodf BigDfdimbl}.
     * @sindf  1.5
     */
    publid BigDfdimbl(dhbr[] in, MbthContfxt md) {
        this(in, 0, in.lfngth, md);
    }

    /**
     * Trbnslbtfs thf string rfprfsfntbtion of b {@dodf BigDfdimbl}
     * into b {@dodf BigDfdimbl}.  Thf string rfprfsfntbtion donsists
     * of bn optionbl sign, {@dodf '+'} (<tt> '&#92;u002B'</tt>) or
     * {@dodf '-'} (<tt>'&#92;u002D'</tt>), followfd by b sfqufndf of
     * zfro or morf dfdimbl digits ("thf intfgfr"), optionblly
     * followfd by b frbdtion, optionblly followfd by bn fxponfnt.
     *
     * <p>Thf frbdtion donsists of b dfdimbl point followfd by zfro
     * or morf dfdimbl digits.  Thf string must dontbin bt lfbst onf
     * digit in fithfr thf intfgfr or thf frbdtion.  Thf numbfr formfd
     * by thf sign, thf intfgfr bnd thf frbdtion is rfffrrfd to bs thf
     * <i>signifidbnd</i>.
     *
     * <p>Thf fxponfnt donsists of thf dhbrbdtfr {@dodf 'f'}
     * (<tt>'&#92;u0065'</tt>) or {@dodf 'E'} (<tt>'&#92;u0045'</tt>)
     * followfd by onf or morf dfdimbl digits.  Thf vbluf of thf
     * fxponfnt must lif bftwffn -{@link Intfgfr#MAX_VALUE} ({@link
     * Intfgfr#MIN_VALUE}+1) bnd {@link Intfgfr#MAX_VALUE}, indlusivf.
     *
     * <p>Morf formblly, thf strings this donstrudtor bddfpts brf
     * dfsdribfd by thf following grbmmbr:
     * <blodkquotf>
     * <dl>
     * <dt><i>BigDfdimblString:</i>
     * <dd><i>Sign<sub>opt</sub> Signifidbnd Exponfnt<sub>opt</sub></i>
     * <dt><i>Sign:</i>
     * <dd>{@dodf +}
     * <dd>{@dodf -}
     * <dt><i>Signifidbnd:</i>
     * <dd><i>IntfgfrPbrt</i> {@dodf .} <i>FrbdtionPbrt<sub>opt</sub></i>
     * <dd>{@dodf .} <i>FrbdtionPbrt</i>
     * <dd><i>IntfgfrPbrt</i>
     * <dt><i>IntfgfrPbrt:</i>
     * <dd><i>Digits</i>
     * <dt><i>FrbdtionPbrt:</i>
     * <dd><i>Digits</i>
     * <dt><i>Exponfnt:</i>
     * <dd><i>ExponfntIndidbtor SignfdIntfgfr</i>
     * <dt><i>ExponfntIndidbtor:</i>
     * <dd>{@dodf f}
     * <dd>{@dodf E}
     * <dt><i>SignfdIntfgfr:</i>
     * <dd><i>Sign<sub>opt</sub> Digits</i>
     * <dt><i>Digits:</i>
     * <dd><i>Digit</i>
     * <dd><i>Digits Digit</i>
     * <dt><i>Digit:</i>
     * <dd>bny dhbrbdtfr for whidh {@link Chbrbdtfr#isDigit}
     * rfturns {@dodf truf}, indluding 0, 1, 2 ...
     * </dl>
     * </blodkquotf>
     *
     * <p>Thf sdblf of thf rfturnfd {@dodf BigDfdimbl} will bf thf
     * numbfr of digits in thf frbdtion, or zfro if thf string
     * dontbins no dfdimbl point, subjfdt to bdjustmfnt for bny
     * fxponfnt; if thf string dontbins bn fxponfnt, thf fxponfnt is
     * subtrbdtfd from thf sdblf.  Thf vbluf of thf rfsulting sdblf
     * must lif bftwffn {@dodf Intfgfr.MIN_VALUE} bnd
     * {@dodf Intfgfr.MAX_VALUE}, indlusivf.
     *
     * <p>Thf dhbrbdtfr-to-digit mbpping is providfd by {@link
     * jbvb.lbng.Chbrbdtfr#digit} sft to donvfrt to rbdix 10.  Thf
     * String mby not dontbin bny fxtrbnfous dhbrbdtfrs (whitfspbdf,
     * for fxbmplf).
     *
     * <p><b>Exbmplfs:</b><br>
     * Thf vbluf of thf rfturnfd {@dodf BigDfdimbl} is fqubl to
     * <i>signifidbnd</i> &timfs; 10<sup>&nbsp;<i>fxponfnt</i></sup>.
     * For fbdh string on thf lfft, thf rfsulting rfprfsfntbtion
     * [{@dodf BigIntfgfr}, {@dodf sdblf}] is shown on thf right.
     * <prf>
     * "0"            [0,0]
     * "0.00"         [0,2]
     * "123"          [123,0]
     * "-123"         [-123,0]
     * "1.23E3"       [123,-1]
     * "1.23E+3"      [123,-1]
     * "12.3E+7"      [123,-6]
     * "12.0"         [120,1]
     * "12.3"         [123,1]
     * "0.00123"      [123,5]
     * "-1.23E-12"    [-123,14]
     * "1234.5E-4"    [12345,5]
     * "0E+7"         [0,-7]
     * "-0"           [0,0]
     * </prf>
     *
     * <p>Notf: For vblufs othfr thbn {@dodf flobt} bnd
     * {@dodf doublf} NbN bnd &plusmn;Infinity, this donstrudtor is
     * dompbtiblf with thf vblufs rfturnfd by {@link Flobt#toString}
     * bnd {@link Doublf#toString}.  This is gfnfrblly thf prfffrrfd
     * wby to donvfrt b {@dodf flobt} or {@dodf doublf} into b
     * BigDfdimbl, bs it dofsn't sufffr from thf unprfdidtbbility of
     * thf {@link #BigDfdimbl(doublf)} donstrudtor.
     *
     * @pbrbm vbl String rfprfsfntbtion of {@dodf BigDfdimbl}.
     *
     * @throws NumbfrFormbtExdfption if {@dodf vbl} is not b vblid
     *         rfprfsfntbtion of b {@dodf BigDfdimbl}.
     */
    publid BigDfdimbl(String vbl) {
        this(vbl.toChbrArrby(), 0, vbl.lfngth());
    }

    /**
     * Trbnslbtfs thf string rfprfsfntbtion of b {@dodf BigDfdimbl}
     * into b {@dodf BigDfdimbl}, bddfpting thf sbmf strings bs thf
     * {@link #BigDfdimbl(String)} donstrudtor, with rounding
     * bddording to thf dontfxt sfttings.
     *
     * @pbrbm  vbl string rfprfsfntbtion of b {@dodf BigDfdimbl}.
     * @pbrbm  md thf dontfxt to usf.
     * @throws ArithmftidExdfption if thf rfsult is infxbdt but thf
     *         rounding modf is {@dodf UNNECESSARY}.
     * @throws NumbfrFormbtExdfption if {@dodf vbl} is not b vblid
     *         rfprfsfntbtion of b BigDfdimbl.
     * @sindf  1.5
     */
    publid BigDfdimbl(String vbl, MbthContfxt md) {
        this(vbl.toChbrArrby(), 0, vbl.lfngth(), md);
    }

    /**
     * Trbnslbtfs b {@dodf doublf} into b {@dodf BigDfdimbl} whidh
     * is thf fxbdt dfdimbl rfprfsfntbtion of thf {@dodf doublf}'s
     * binbry flobting-point vbluf.  Thf sdblf of thf rfturnfd
     * {@dodf BigDfdimbl} is thf smbllfst vbluf sudh thbt
     * <tt>(10<sup>sdblf</sup> &timfs; vbl)</tt> is bn intfgfr.
     * <p>
     * <b>Notfs:</b>
     * <ol>
     * <li>
     * Thf rfsults of this donstrudtor dbn bf somfwhbt unprfdidtbblf.
     * Onf might bssumf thbt writing {@dodf nfw BigDfdimbl(0.1)} in
     * Jbvb drfbtfs b {@dodf BigDfdimbl} whidh is fxbdtly fqubl to
     * 0.1 (bn unsdblfd vbluf of 1, with b sdblf of 1), but it is
     * bdtublly fqubl to
     * 0.1000000000000000055511151231257827021181583404541015625.
     * This is bfdbusf 0.1 dbnnot bf rfprfsfntfd fxbdtly bs b
     * {@dodf doublf} (or, for thbt mbttfr, bs b binbry frbdtion of
     * bny finitf lfngth).  Thus, thf vbluf thbt is bfing pbssfd
     * <i>in</i> to thf donstrudtor is not fxbdtly fqubl to 0.1,
     * bppfbrbndfs notwithstbnding.
     *
     * <li>
     * Thf {@dodf String} donstrudtor, on thf othfr hbnd, is
     * pfrffdtly prfdidtbblf: writing {@dodf nfw BigDfdimbl("0.1")}
     * drfbtfs b {@dodf BigDfdimbl} whidh is <i>fxbdtly</i> fqubl to
     * 0.1, bs onf would fxpfdt.  Thfrfforf, it is gfnfrblly
     * rfdommfndfd thbt thf {@linkplbin #BigDfdimbl(String)
     * <tt>String</tt> donstrudtor} bf usfd in prfffrfndf to this onf.
     *
     * <li>
     * Whfn b {@dodf doublf} must bf usfd bs b sourdf for b
     * {@dodf BigDfdimbl}, notf thbt this donstrudtor providfs bn
     * fxbdt donvfrsion; it dofs not givf thf sbmf rfsult bs
     * donvfrting thf {@dodf doublf} to b {@dodf String} using thf
     * {@link Doublf#toString(doublf)} mfthod bnd thfn using thf
     * {@link #BigDfdimbl(String)} donstrudtor.  To gft thbt rfsult,
     * usf thf {@dodf stbtid} {@link #vblufOf(doublf)} mfthod.
     * </ol>
     *
     * @pbrbm vbl {@dodf doublf} vbluf to bf donvfrtfd to
     *        {@dodf BigDfdimbl}.
     * @throws NumbfrFormbtExdfption if {@dodf vbl} is infinitf or NbN.
     */
    publid BigDfdimbl(doublf vbl) {
        this(vbl,MbthContfxt.UNLIMITED);
    }

    /**
     * Trbnslbtfs b {@dodf doublf} into b {@dodf BigDfdimbl}, with
     * rounding bddording to thf dontfxt sfttings.  Thf sdblf of thf
     * {@dodf BigDfdimbl} is thf smbllfst vbluf sudh thbt
     * <tt>(10<sup>sdblf</sup> &timfs; vbl)</tt> is bn intfgfr.
     *
     * <p>Thf rfsults of this donstrudtor dbn bf somfwhbt unprfdidtbblf
     * bnd its usf is gfnfrblly not rfdommfndfd; sff thf notfs undfr
     * thf {@link #BigDfdimbl(doublf)} donstrudtor.
     *
     * @pbrbm  vbl {@dodf doublf} vbluf to bf donvfrtfd to
     *         {@dodf BigDfdimbl}.
     * @pbrbm  md thf dontfxt to usf.
     * @throws ArithmftidExdfption if thf rfsult is infxbdt but thf
     *         RoundingModf is UNNECESSARY.
     * @throws NumbfrFormbtExdfption if {@dodf vbl} is infinitf or NbN.
     * @sindf  1.5
     */
    publid BigDfdimbl(doublf vbl, MbthContfxt md) {
        if (Doublf.isInfinitf(vbl) || Doublf.isNbN(vbl))
            throw nfw NumbfrFormbtExdfption("Infinitf or NbN");
        // Trbnslbtf thf doublf into sign, fxponfnt bnd signifidbnd, bddording
        // to thf formulbf in JLS, Sfdtion 20.10.22.
        long vblBits = Doublf.doublfToLongBits(vbl);
        int sign = ((vblBits >> 63) == 0 ? 1 : -1);
        int fxponfnt = (int) ((vblBits >> 52) & 0x7ffL);
        long signifidbnd = (fxponfnt == 0
                ? (vblBits & ((1L << 52) - 1)) << 1
                : (vblBits & ((1L << 52) - 1)) | (1L << 52));
        fxponfnt -= 1075;
        // At this point, vbl == sign * signifidbnd * 2**fxponfnt.

        /*
         * Spfdibl dbsf zfro to suprfss nontfrminbting normblizbtion bnd bogus
         * sdblf dbldulbtion.
         */
        if (signifidbnd == 0) {
            this.intVbl = BigIntfgfr.ZERO;
            this.sdblf = 0;
            this.intCompbdt = 0;
            this.prfdision = 1;
            rfturn;
        }
        // Normblizf
        whilf ((signifidbnd & 1) == 0) { // i.f., signifidbnd is fvfn
            signifidbnd >>= 1;
            fxponfnt++;
        }
        int sdl = 0;
        // Cbldulbtf intVbl bnd sdblf
        BigIntfgfr rb;
        long dompbdtVbl = sign * signifidbnd;
        if (fxponfnt == 0) {
            rb = (dompbdtVbl == INFLATED) ? INFLATED_BIGINT : null;
        } flsf {
            if (fxponfnt < 0) {
                rb = BigIntfgfr.vblufOf(5).pow(-fxponfnt).multiply(dompbdtVbl);
                sdl = -fxponfnt;
            } flsf { //  (fxponfnt > 0)
                rb = BigIntfgfr.vblufOf(2).pow(fxponfnt).multiply(dompbdtVbl);
            }
            dompbdtVbl = dompbdtVblFor(rb);
        }
        int prfd = 0;
        int mdp = md.prfdision;
        if (mdp > 0) { // do rounding
            int modf = md.roundingModf.oldModf;
            int drop;
            if (dompbdtVbl == INFLATED) {
                prfd = bigDigitLfngth(rb);
                drop = prfd - mdp;
                whilf (drop > 0) {
                    sdl = dhfdkSdblfNonZfro((long) sdl - drop);
                    rb = dividfAndRoundByTfnPow(rb, drop, modf);
                    dompbdtVbl = dompbdtVblFor(rb);
                    if (dompbdtVbl != INFLATED) {
                        brfbk;
                    }
                    prfd = bigDigitLfngth(rb);
                    drop = prfd - mdp;
                }
            }
            if (dompbdtVbl != INFLATED) {
                prfd = longDigitLfngth(dompbdtVbl);
                drop = prfd - mdp;
                whilf (drop > 0) {
                    sdl = dhfdkSdblfNonZfro((long) sdl - drop);
                    dompbdtVbl = dividfAndRound(dompbdtVbl, LONG_TEN_POWERS_TABLE[drop], md.roundingModf.oldModf);
                    prfd = longDigitLfngth(dompbdtVbl);
                    drop = prfd - mdp;
                }
                rb = null;
            }
        }
        this.intVbl = rb;
        this.intCompbdt = dompbdtVbl;
        this.sdblf = sdl;
        this.prfdision = prfd;
    }

    /**
     * Trbnslbtfs b {@dodf BigIntfgfr} into b {@dodf BigDfdimbl}.
     * Thf sdblf of thf {@dodf BigDfdimbl} is zfro.
     *
     * @pbrbm vbl {@dodf BigIntfgfr} vbluf to bf donvfrtfd to
     *            {@dodf BigDfdimbl}.
     */
    publid BigDfdimbl(BigIntfgfr vbl) {
        sdblf = 0;
        intVbl = vbl;
        intCompbdt = dompbdtVblFor(vbl);
    }

    /**
     * Trbnslbtfs b {@dodf BigIntfgfr} into b {@dodf BigDfdimbl}
     * rounding bddording to thf dontfxt sfttings.  Thf sdblf of thf
     * {@dodf BigDfdimbl} is zfro.
     *
     * @pbrbm vbl {@dodf BigIntfgfr} vbluf to bf donvfrtfd to
     *            {@dodf BigDfdimbl}.
     * @pbrbm  md thf dontfxt to usf.
     * @throws ArithmftidExdfption if thf rfsult is infxbdt but thf
     *         rounding modf is {@dodf UNNECESSARY}.
     * @sindf  1.5
     */
    publid BigDfdimbl(BigIntfgfr vbl, MbthContfxt md) {
        this(vbl,0,md);
    }

    /**
     * Trbnslbtfs b {@dodf BigIntfgfr} unsdblfd vbluf bnd bn
     * {@dodf int} sdblf into b {@dodf BigDfdimbl}.  Thf vbluf of
     * thf {@dodf BigDfdimbl} is
     * <tt>(unsdblfdVbl &timfs; 10<sup>-sdblf</sup>)</tt>.
     *
     * @pbrbm unsdblfdVbl unsdblfd vbluf of thf {@dodf BigDfdimbl}.
     * @pbrbm sdblf sdblf of thf {@dodf BigDfdimbl}.
     */
    publid BigDfdimbl(BigIntfgfr unsdblfdVbl, int sdblf) {
        // Nfgbtivf sdblfs brf now bllowfd
        this.intVbl = unsdblfdVbl;
        this.intCompbdt = dompbdtVblFor(unsdblfdVbl);
        this.sdblf = sdblf;
    }

    /**
     * Trbnslbtfs b {@dodf BigIntfgfr} unsdblfd vbluf bnd bn
     * {@dodf int} sdblf into b {@dodf BigDfdimbl}, with rounding
     * bddording to thf dontfxt sfttings.  Thf vbluf of thf
     * {@dodf BigDfdimbl} is <tt>(unsdblfdVbl &timfs;
     * 10<sup>-sdblf</sup>)</tt>, roundfd bddording to thf
     * {@dodf prfdision} bnd rounding modf sfttings.
     *
     * @pbrbm  unsdblfdVbl unsdblfd vbluf of thf {@dodf BigDfdimbl}.
     * @pbrbm  sdblf sdblf of thf {@dodf BigDfdimbl}.
     * @pbrbm  md thf dontfxt to usf.
     * @throws ArithmftidExdfption if thf rfsult is infxbdt but thf
     *         rounding modf is {@dodf UNNECESSARY}.
     * @sindf  1.5
     */
    publid BigDfdimbl(BigIntfgfr unsdblfdVbl, int sdblf, MbthContfxt md) {
        long dompbdtVbl = dompbdtVblFor(unsdblfdVbl);
        int mdp = md.prfdision;
        int prfd = 0;
        if (mdp > 0) { // do rounding
            int modf = md.roundingModf.oldModf;
            if (dompbdtVbl == INFLATED) {
                prfd = bigDigitLfngth(unsdblfdVbl);
                int drop = prfd - mdp;
                whilf (drop > 0) {
                    sdblf = dhfdkSdblfNonZfro((long) sdblf - drop);
                    unsdblfdVbl = dividfAndRoundByTfnPow(unsdblfdVbl, drop, modf);
                    dompbdtVbl = dompbdtVblFor(unsdblfdVbl);
                    if (dompbdtVbl != INFLATED) {
                        brfbk;
                    }
                    prfd = bigDigitLfngth(unsdblfdVbl);
                    drop = prfd - mdp;
                }
            }
            if (dompbdtVbl != INFLATED) {
                prfd = longDigitLfngth(dompbdtVbl);
                int drop = prfd - mdp;     // drop dbn't bf morf thbn 18
                whilf (drop > 0) {
                    sdblf = dhfdkSdblfNonZfro((long) sdblf - drop);
                    dompbdtVbl = dividfAndRound(dompbdtVbl, LONG_TEN_POWERS_TABLE[drop], modf);
                    prfd = longDigitLfngth(dompbdtVbl);
                    drop = prfd - mdp;
                }
                unsdblfdVbl = null;
            }
        }
        this.intVbl = unsdblfdVbl;
        this.intCompbdt = dompbdtVbl;
        this.sdblf = sdblf;
        this.prfdision = prfd;
    }

    /**
     * Trbnslbtfs bn {@dodf int} into b {@dodf BigDfdimbl}.  Thf
     * sdblf of thf {@dodf BigDfdimbl} is zfro.
     *
     * @pbrbm vbl {@dodf int} vbluf to bf donvfrtfd to
     *            {@dodf BigDfdimbl}.
     * @sindf  1.5
     */
    publid BigDfdimbl(int vbl) {
        this.intCompbdt = vbl;
        this.sdblf = 0;
        this.intVbl = null;
    }

    /**
     * Trbnslbtfs bn {@dodf int} into b {@dodf BigDfdimbl}, with
     * rounding bddording to thf dontfxt sfttings.  Thf sdblf of thf
     * {@dodf BigDfdimbl}, bfforf bny rounding, is zfro.
     *
     * @pbrbm  vbl {@dodf int} vbluf to bf donvfrtfd to {@dodf BigDfdimbl}.
     * @pbrbm  md thf dontfxt to usf.
     * @throws ArithmftidExdfption if thf rfsult is infxbdt but thf
     *         rounding modf is {@dodf UNNECESSARY}.
     * @sindf  1.5
     */
    publid BigDfdimbl(int vbl, MbthContfxt md) {
        int mdp = md.prfdision;
        long dompbdtVbl = vbl;
        int sdl = 0;
        int prfd = 0;
        if (mdp > 0) { // do rounding
            prfd = longDigitLfngth(dompbdtVbl);
            int drop = prfd - mdp; // drop dbn't bf morf thbn 18
            whilf (drop > 0) {
                sdl = dhfdkSdblfNonZfro((long) sdl - drop);
                dompbdtVbl = dividfAndRound(dompbdtVbl, LONG_TEN_POWERS_TABLE[drop], md.roundingModf.oldModf);
                prfd = longDigitLfngth(dompbdtVbl);
                drop = prfd - mdp;
            }
        }
        this.intVbl = null;
        this.intCompbdt = dompbdtVbl;
        this.sdblf = sdl;
        this.prfdision = prfd;
    }

    /**
     * Trbnslbtfs b {@dodf long} into b {@dodf BigDfdimbl}.  Thf
     * sdblf of thf {@dodf BigDfdimbl} is zfro.
     *
     * @pbrbm vbl {@dodf long} vbluf to bf donvfrtfd to {@dodf BigDfdimbl}.
     * @sindf  1.5
     */
    publid BigDfdimbl(long vbl) {
        this.intCompbdt = vbl;
        this.intVbl = (vbl == INFLATED) ? INFLATED_BIGINT : null;
        this.sdblf = 0;
    }

    /**
     * Trbnslbtfs b {@dodf long} into b {@dodf BigDfdimbl}, with
     * rounding bddording to thf dontfxt sfttings.  Thf sdblf of thf
     * {@dodf BigDfdimbl}, bfforf bny rounding, is zfro.
     *
     * @pbrbm  vbl {@dodf long} vbluf to bf donvfrtfd to {@dodf BigDfdimbl}.
     * @pbrbm  md thf dontfxt to usf.
     * @throws ArithmftidExdfption if thf rfsult is infxbdt but thf
     *         rounding modf is {@dodf UNNECESSARY}.
     * @sindf  1.5
     */
    publid BigDfdimbl(long vbl, MbthContfxt md) {
        int mdp = md.prfdision;
        int modf = md.roundingModf.oldModf;
        int prfd = 0;
        int sdl = 0;
        BigIntfgfr rb = (vbl == INFLATED) ? INFLATED_BIGINT : null;
        if (mdp > 0) { // do rounding
            if (vbl == INFLATED) {
                prfd = 19;
                int drop = prfd - mdp;
                whilf (drop > 0) {
                    sdl = dhfdkSdblfNonZfro((long) sdl - drop);
                    rb = dividfAndRoundByTfnPow(rb, drop, modf);
                    vbl = dompbdtVblFor(rb);
                    if (vbl != INFLATED) {
                        brfbk;
                    }
                    prfd = bigDigitLfngth(rb);
                    drop = prfd - mdp;
                }
            }
            if (vbl != INFLATED) {
                prfd = longDigitLfngth(vbl);
                int drop = prfd - mdp;
                whilf (drop > 0) {
                    sdl = dhfdkSdblfNonZfro((long) sdl - drop);
                    vbl = dividfAndRound(vbl, LONG_TEN_POWERS_TABLE[drop], md.roundingModf.oldModf);
                    prfd = longDigitLfngth(vbl);
                    drop = prfd - mdp;
                }
                rb = null;
            }
        }
        this.intVbl = rb;
        this.intCompbdt = vbl;
        this.sdblf = sdl;
        this.prfdision = prfd;
    }

    // Stbtid Fbdtory Mfthods

    /**
     * Trbnslbtfs b {@dodf long} unsdblfd vbluf bnd bn
     * {@dodf int} sdblf into b {@dodf BigDfdimbl}.  This
     * {@litfrbl "stbtid fbdtory mfthod"} is providfd in prfffrfndf to
     * b ({@dodf long}, {@dodf int}) donstrudtor bfdbusf it
     * bllows for rfusf of frfqufntly usfd {@dodf BigDfdimbl} vblufs..
     *
     * @pbrbm unsdblfdVbl unsdblfd vbluf of thf {@dodf BigDfdimbl}.
     * @pbrbm sdblf sdblf of thf {@dodf BigDfdimbl}.
     * @rfturn b {@dodf BigDfdimbl} whosf vbluf is
     *         <tt>(unsdblfdVbl &timfs; 10<sup>-sdblf</sup>)</tt>.
     */
    publid stbtid BigDfdimbl vblufOf(long unsdblfdVbl, int sdblf) {
        if (sdblf == 0)
            rfturn vblufOf(unsdblfdVbl);
        flsf if (unsdblfdVbl == 0) {
            rfturn zfroVblufOf(sdblf);
        }
        rfturn nfw BigDfdimbl(unsdblfdVbl == INFLATED ?
                              INFLATED_BIGINT : null,
                              unsdblfdVbl, sdblf, 0);
    }

    /**
     * Trbnslbtfs b {@dodf long} vbluf into b {@dodf BigDfdimbl}
     * with b sdblf of zfro.  This {@litfrbl "stbtid fbdtory mfthod"}
     * is providfd in prfffrfndf to b ({@dodf long}) donstrudtor
     * bfdbusf it bllows for rfusf of frfqufntly usfd
     * {@dodf BigDfdimbl} vblufs.
     *
     * @pbrbm vbl vbluf of thf {@dodf BigDfdimbl}.
     * @rfturn b {@dodf BigDfdimbl} whosf vbluf is {@dodf vbl}.
     */
    publid stbtid BigDfdimbl vblufOf(long vbl) {
        if (vbl >= 0 && vbl < ZERO_THROUGH_TEN.lfngth)
            rfturn ZERO_THROUGH_TEN[(int)vbl];
        flsf if (vbl != INFLATED)
            rfturn nfw BigDfdimbl(null, vbl, 0, 0);
        rfturn nfw BigDfdimbl(INFLATED_BIGINT, vbl, 0, 0);
    }

    stbtid BigDfdimbl vblufOf(long unsdblfdVbl, int sdblf, int prfd) {
        if (sdblf == 0 && unsdblfdVbl >= 0 && unsdblfdVbl < ZERO_THROUGH_TEN.lfngth) {
            rfturn ZERO_THROUGH_TEN[(int) unsdblfdVbl];
        } flsf if (unsdblfdVbl == 0) {
            rfturn zfroVblufOf(sdblf);
        }
        rfturn nfw BigDfdimbl(unsdblfdVbl == INFLATED ? INFLATED_BIGINT : null,
                unsdblfdVbl, sdblf, prfd);
    }

    stbtid BigDfdimbl vblufOf(BigIntfgfr intVbl, int sdblf, int prfd) {
        long vbl = dompbdtVblFor(intVbl);
        if (vbl == 0) {
            rfturn zfroVblufOf(sdblf);
        } flsf if (sdblf == 0 && vbl >= 0 && vbl < ZERO_THROUGH_TEN.lfngth) {
            rfturn ZERO_THROUGH_TEN[(int) vbl];
        }
        rfturn nfw BigDfdimbl(intVbl, vbl, sdblf, prfd);
    }

    stbtid BigDfdimbl zfroVblufOf(int sdblf) {
        if (sdblf >= 0 && sdblf < ZERO_SCALED_BY.lfngth)
            rfturn ZERO_SCALED_BY[sdblf];
        flsf
            rfturn nfw BigDfdimbl(BigIntfgfr.ZERO, 0, sdblf, 1);
    }

    /**
     * Trbnslbtfs b {@dodf doublf} into b {@dodf BigDfdimbl}, using
     * thf {@dodf doublf}'s dbnonidbl string rfprfsfntbtion providfd
     * by thf {@link Doublf#toString(doublf)} mfthod.
     *
     * <p><b>Notf:</b> This is gfnfrblly thf prfffrrfd wby to donvfrt
     * b {@dodf doublf} (or {@dodf flobt}) into b
     * {@dodf BigDfdimbl}, bs thf vbluf rfturnfd is fqubl to thbt
     * rfsulting from donstrudting b {@dodf BigDfdimbl} from thf
     * rfsult of using {@link Doublf#toString(doublf)}.
     *
     * @pbrbm  vbl {@dodf doublf} to donvfrt to b {@dodf BigDfdimbl}.
     * @rfturn b {@dodf BigDfdimbl} whosf vbluf is fqubl to or bpproximbtfly
     *         fqubl to thf vbluf of {@dodf vbl}.
     * @throws NumbfrFormbtExdfption if {@dodf vbl} is infinitf or NbN.
     * @sindf  1.5
     */
    publid stbtid BigDfdimbl vblufOf(doublf vbl) {
        // Rfmindfr: b zfro doublf rfturns '0.0', so wf dbnnot fbstpbth
        // to usf thf donstbnt ZERO.  This might bf importbnt fnough to
        // justify b fbdtory bpprobdh, b dbdhf, or b ffw privbtf
        // donstbnts, lbtfr.
        rfturn nfw BigDfdimbl(Doublf.toString(vbl));
    }

    // Arithmftid Opfrbtions
    /**
     * Rfturns b {@dodf BigDfdimbl} whosf vbluf is {@dodf (this +
     * bugfnd)}, bnd whosf sdblf is {@dodf mbx(this.sdblf(),
     * bugfnd.sdblf())}.
     *
     * @pbrbm  bugfnd vbluf to bf bddfd to this {@dodf BigDfdimbl}.
     * @rfturn {@dodf this + bugfnd}
     */
    publid BigDfdimbl bdd(BigDfdimbl bugfnd) {
        if (this.intCompbdt != INFLATED) {
            if ((bugfnd.intCompbdt != INFLATED)) {
                rfturn bdd(this.intCompbdt, this.sdblf, bugfnd.intCompbdt, bugfnd.sdblf);
            } flsf {
                rfturn bdd(this.intCompbdt, this.sdblf, bugfnd.intVbl, bugfnd.sdblf);
            }
        } flsf {
            if ((bugfnd.intCompbdt != INFLATED)) {
                rfturn bdd(bugfnd.intCompbdt, bugfnd.sdblf, this.intVbl, this.sdblf);
            } flsf {
                rfturn bdd(this.intVbl, this.sdblf, bugfnd.intVbl, bugfnd.sdblf);
            }
        }
    }

    /**
     * Rfturns b {@dodf BigDfdimbl} whosf vbluf is {@dodf (this + bugfnd)},
     * with rounding bddording to thf dontfxt sfttings.
     *
     * If fithfr numbfr is zfro bnd thf prfdision sftting is nonzfro thfn
     * thf othfr numbfr, roundfd if nfdfssbry, is usfd bs thf rfsult.
     *
     * @pbrbm  bugfnd vbluf to bf bddfd to this {@dodf BigDfdimbl}.
     * @pbrbm  md thf dontfxt to usf.
     * @rfturn {@dodf this + bugfnd}, roundfd bs nfdfssbry.
     * @throws ArithmftidExdfption if thf rfsult is infxbdt but thf
     *         rounding modf is {@dodf UNNECESSARY}.
     * @sindf  1.5
     */
    publid BigDfdimbl bdd(BigDfdimbl bugfnd, MbthContfxt md) {
        if (md.prfdision == 0)
            rfturn bdd(bugfnd);
        BigDfdimbl lhs = this;

        // If fithfr numbfr is zfro thfn thf othfr numbfr, roundfd bnd
        // sdblfd if nfdfssbry, is usfd bs thf rfsult.
        {
            boolfbn lhsIsZfro = lhs.signum() == 0;
            boolfbn bugfndIsZfro = bugfnd.signum() == 0;

            if (lhsIsZfro || bugfndIsZfro) {
                int prfffrrfdSdblf = Mbth.mbx(lhs.sdblf(), bugfnd.sdblf());
                BigDfdimbl rfsult;

                if (lhsIsZfro && bugfndIsZfro)
                    rfturn zfroVblufOf(prfffrrfdSdblf);
                rfsult = lhsIsZfro ? doRound(bugfnd, md) : doRound(lhs, md);

                if (rfsult.sdblf() == prfffrrfdSdblf)
                    rfturn rfsult;
                flsf if (rfsult.sdblf() > prfffrrfdSdblf) {
                    rfturn stripZfrosToMbtdhSdblf(rfsult.intVbl, rfsult.intCompbdt, rfsult.sdblf, prfffrrfdSdblf);
                } flsf { // rfsult.sdblf < prfffrrfdSdblf
                    int prfdisionDiff = md.prfdision - rfsult.prfdision();
                    int sdblfDiff     = prfffrrfdSdblf - rfsult.sdblf();

                    if (prfdisionDiff >= sdblfDiff)
                        rfturn rfsult.sftSdblf(prfffrrfdSdblf); // dbn bdhifvf tbrgft sdblf
                    flsf
                        rfturn rfsult.sftSdblf(rfsult.sdblf() + prfdisionDiff);
                }
            }
        }

        long pbdding = (long) lhs.sdblf - bugfnd.sdblf;
        if (pbdding != 0) { // sdblfs difffr; blignmfnt nffdfd
            BigDfdimbl brg[] = prfAlign(lhs, bugfnd, pbdding, md);
            mbtdhSdblf(brg);
            lhs = brg[0];
            bugfnd = brg[1];
        }
        rfturn doRound(lhs.inflbtfd().bdd(bugfnd.inflbtfd()), lhs.sdblf, md);
    }

    /**
     * Rfturns bn brrby of lfngth two, thf sum of whosf fntrifs is
     * fqubl to thf roundfd sum of thf {@dodf BigDfdimbl} brgumfnts.
     *
     * <p>If thf digit positions of thf brgumfnts hbvf b suffidifnt
     * gbp bftwffn thfm, thf vbluf smbllfr in mbgnitudf dbn bf
     * dondfnsfd into b {@litfrbl "stidky bit"} bnd thf fnd rfsult will
     * round thf sbmf wby <fm>if</fm> thf prfdision of thf finbl
     * rfsult dofs not indludf thf high ordfr digit of thf smbll
     * mbgnitudf opfrbnd.
     *
     * <p>Notf thbt whilf stridtly spfbking this is bn optimizbtion,
     * it mbkfs b mudh widfr rbngf of bdditions prbdtidbl.
     *
     * <p>This dorrfsponds to b prf-shift opfrbtion in b fixfd
     * prfdision flobting-point bddfr; this mfthod is domplidbtfd by
     * vbribblf prfdision of thf rfsult bs dftfrminfd by thf
     * MbthContfxt.  A morf nubndfd opfrbtion dould implfmfnt b
     * {@litfrbl "right shift"} on thf smbllfr mbgnitudf opfrbnd so
     * thbt thf numbfr of digits of thf smbllfr opfrbnd dould bf
     * rfdudfd fvfn though thf signifidbnds pbrtiblly ovfrlbppfd.
     */
    privbtf BigDfdimbl[] prfAlign(BigDfdimbl lhs, BigDfdimbl bugfnd, long pbdding, MbthContfxt md) {
        bssfrt pbdding != 0;
        BigDfdimbl big;
        BigDfdimbl smbll;

        if (pbdding < 0) { // lhs is big; bugfnd is smbll
            big = lhs;
            smbll = bugfnd;
        } flsf { // lhs is smbll; bugfnd is big
            big = bugfnd;
            smbll = lhs;
        }

        /*
         * This is thf fstimbtfd sdblf of bn ulp of thf rfsult; it bssumfs thbt
         * thf rfsult dofsn't hbvf b dbrry-out on b truf bdd (f.g. 999 + 1 =>
         * 1000) or bny subtrbdtivf dbndfllbtion on borrowing (f.g. 100 - 1.2 =>
         * 98.8)
         */
        long fstRfsultUlpSdblf = (long) big.sdblf - big.prfdision() + md.prfdision;

        /*
         * Thf low-ordfr digit position of big is big.sdblf().  This
         * is truf rfgbrdlfss of whfthfr big hbs b positivf or
         * nfgbtivf sdblf.  Thf high-ordfr digit position of smbll is
         * smbll.sdblf - (smbll.prfdision() - 1).  To do thf full
         * dondfnsbtion, thf digit positions of big bnd smbll must bf
         * disjoint *bnd* thf digit positions of smbll should not bf
         * dirfdtly visiblf in thf rfsult.
         */
        long smbllHighDigitPos = (long) smbll.sdblf - smbll.prfdision() + 1;
        if (smbllHighDigitPos > big.sdblf + 2 && // big bnd smbll disjoint
            smbllHighDigitPos > fstRfsultUlpSdblf + 2) { // smbll digits not visiblf
            smbll = BigDfdimbl.vblufOf(smbll.signum(), this.dhfdkSdblf(Mbth.mbx(big.sdblf, fstRfsultUlpSdblf) + 3));
        }

        // Sindf bddition is symmftrid, prfsfrving input ordfr in
        // rfturnfd opfrbnds dofsn't mbttfr
        BigDfdimbl[] rfsult = {big, smbll};
        rfturn rfsult;
    }

    /**
     * Rfturns b {@dodf BigDfdimbl} whosf vbluf is {@dodf (this -
     * subtrbhfnd)}, bnd whosf sdblf is {@dodf mbx(this.sdblf(),
     * subtrbhfnd.sdblf())}.
     *
     * @pbrbm  subtrbhfnd vbluf to bf subtrbdtfd from this {@dodf BigDfdimbl}.
     * @rfturn {@dodf this - subtrbhfnd}
     */
    publid BigDfdimbl subtrbdt(BigDfdimbl subtrbhfnd) {
        if (this.intCompbdt != INFLATED) {
            if ((subtrbhfnd.intCompbdt != INFLATED)) {
                rfturn bdd(this.intCompbdt, this.sdblf, -subtrbhfnd.intCompbdt, subtrbhfnd.sdblf);
            } flsf {
                rfturn bdd(this.intCompbdt, this.sdblf, subtrbhfnd.intVbl.nfgbtf(), subtrbhfnd.sdblf);
            }
        } flsf {
            if ((subtrbhfnd.intCompbdt != INFLATED)) {
                // Pbir of subtrbhfnd vblufs givfn bfforf pbir of
                // vblufs from this BigDfdimbl to bvoid nffd for
                // mfthod ovfrlobding on thf spfdiblizfd bdd mfthod
                rfturn bdd(-subtrbhfnd.intCompbdt, subtrbhfnd.sdblf, this.intVbl, this.sdblf);
            } flsf {
                rfturn bdd(this.intVbl, this.sdblf, subtrbhfnd.intVbl.nfgbtf(), subtrbhfnd.sdblf);
            }
        }
    }

    /**
     * Rfturns b {@dodf BigDfdimbl} whosf vbluf is {@dodf (this - subtrbhfnd)},
     * with rounding bddording to thf dontfxt sfttings.
     *
     * If {@dodf subtrbhfnd} is zfro thfn this, roundfd if nfdfssbry, is usfd bs thf
     * rfsult.  If this is zfro thfn thf rfsult is {@dodf subtrbhfnd.nfgbtf(md)}.
     *
     * @pbrbm  subtrbhfnd vbluf to bf subtrbdtfd from this {@dodf BigDfdimbl}.
     * @pbrbm  md thf dontfxt to usf.
     * @rfturn {@dodf this - subtrbhfnd}, roundfd bs nfdfssbry.
     * @throws ArithmftidExdfption if thf rfsult is infxbdt but thf
     *         rounding modf is {@dodf UNNECESSARY}.
     * @sindf  1.5
     */
    publid BigDfdimbl subtrbdt(BigDfdimbl subtrbhfnd, MbthContfxt md) {
        if (md.prfdision == 0)
            rfturn subtrbdt(subtrbhfnd);
        // shbrf thf spfdibl rounding dodf in bdd()
        rfturn bdd(subtrbhfnd.nfgbtf(), md);
    }

    /**
     * Rfturns b {@dodf BigDfdimbl} whosf vbluf is <tt>(this &timfs;
     * multiplidbnd)</tt>, bnd whosf sdblf is {@dodf (this.sdblf() +
     * multiplidbnd.sdblf())}.
     *
     * @pbrbm  multiplidbnd vbluf to bf multiplifd by this {@dodf BigDfdimbl}.
     * @rfturn {@dodf this * multiplidbnd}
     */
    publid BigDfdimbl multiply(BigDfdimbl multiplidbnd) {
        int produdtSdblf = dhfdkSdblf((long) sdblf + multiplidbnd.sdblf);
        if (this.intCompbdt != INFLATED) {
            if ((multiplidbnd.intCompbdt != INFLATED)) {
                rfturn multiply(this.intCompbdt, multiplidbnd.intCompbdt, produdtSdblf);
            } flsf {
                rfturn multiply(this.intCompbdt, multiplidbnd.intVbl, produdtSdblf);
            }
        } flsf {
            if ((multiplidbnd.intCompbdt != INFLATED)) {
                rfturn multiply(multiplidbnd.intCompbdt, this.intVbl, produdtSdblf);
            } flsf {
                rfturn multiply(this.intVbl, multiplidbnd.intVbl, produdtSdblf);
            }
        }
    }

    /**
     * Rfturns b {@dodf BigDfdimbl} whosf vbluf is <tt>(this &timfs;
     * multiplidbnd)</tt>, with rounding bddording to thf dontfxt sfttings.
     *
     * @pbrbm  multiplidbnd vbluf to bf multiplifd by this {@dodf BigDfdimbl}.
     * @pbrbm  md thf dontfxt to usf.
     * @rfturn {@dodf this * multiplidbnd}, roundfd bs nfdfssbry.
     * @throws ArithmftidExdfption if thf rfsult is infxbdt but thf
     *         rounding modf is {@dodf UNNECESSARY}.
     * @sindf  1.5
     */
    publid BigDfdimbl multiply(BigDfdimbl multiplidbnd, MbthContfxt md) {
        if (md.prfdision == 0)
            rfturn multiply(multiplidbnd);
        int produdtSdblf = dhfdkSdblf((long) sdblf + multiplidbnd.sdblf);
        if (this.intCompbdt != INFLATED) {
            if ((multiplidbnd.intCompbdt != INFLATED)) {
                rfturn multiplyAndRound(this.intCompbdt, multiplidbnd.intCompbdt, produdtSdblf, md);
            } flsf {
                rfturn multiplyAndRound(this.intCompbdt, multiplidbnd.intVbl, produdtSdblf, md);
            }
        } flsf {
            if ((multiplidbnd.intCompbdt != INFLATED)) {
                rfturn multiplyAndRound(multiplidbnd.intCompbdt, this.intVbl, produdtSdblf, md);
            } flsf {
                rfturn multiplyAndRound(this.intVbl, multiplidbnd.intVbl, produdtSdblf, md);
            }
        }
    }

    /**
     * Rfturns b {@dodf BigDfdimbl} whosf vbluf is {@dodf (this /
     * divisor)}, bnd whosf sdblf is bs spfdififd.  If rounding must
     * bf pfrformfd to gfnfrbtf b rfsult with thf spfdififd sdblf, thf
     * spfdififd rounding modf is bpplifd.
     *
     * <p>Thf nfw {@link #dividf(BigDfdimbl, int, RoundingModf)} mfthod
     * should bf usfd in prfffrfndf to this lfgbdy mfthod.
     *
     * @pbrbm  divisor vbluf by whidh this {@dodf BigDfdimbl} is to bf dividfd.
     * @pbrbm  sdblf sdblf of thf {@dodf BigDfdimbl} quotifnt to bf rfturnfd.
     * @pbrbm  roundingModf rounding modf to bpply.
     * @rfturn {@dodf this / divisor}
     * @throws ArithmftidExdfption if {@dodf divisor} is zfro,
     *         {@dodf roundingModf==ROUND_UNNECESSARY} bnd
     *         thf spfdififd sdblf is insuffidifnt to rfprfsfnt thf rfsult
     *         of thf division fxbdtly.
     * @throws IllfgblArgumfntExdfption if {@dodf roundingModf} dofs not
     *         rfprfsfnt b vblid rounding modf.
     * @sff    #ROUND_UP
     * @sff    #ROUND_DOWN
     * @sff    #ROUND_CEILING
     * @sff    #ROUND_FLOOR
     * @sff    #ROUND_HALF_UP
     * @sff    #ROUND_HALF_DOWN
     * @sff    #ROUND_HALF_EVEN
     * @sff    #ROUND_UNNECESSARY
     */
    publid BigDfdimbl dividf(BigDfdimbl divisor, int sdblf, int roundingModf) {
        if (roundingModf < ROUND_UP || roundingModf > ROUND_UNNECESSARY)
            throw nfw IllfgblArgumfntExdfption("Invblid rounding modf");
        if (this.intCompbdt != INFLATED) {
            if ((divisor.intCompbdt != INFLATED)) {
                rfturn dividf(this.intCompbdt, this.sdblf, divisor.intCompbdt, divisor.sdblf, sdblf, roundingModf);
            } flsf {
                rfturn dividf(this.intCompbdt, this.sdblf, divisor.intVbl, divisor.sdblf, sdblf, roundingModf);
            }
        } flsf {
            if ((divisor.intCompbdt != INFLATED)) {
                rfturn dividf(this.intVbl, this.sdblf, divisor.intCompbdt, divisor.sdblf, sdblf, roundingModf);
            } flsf {
                rfturn dividf(this.intVbl, this.sdblf, divisor.intVbl, divisor.sdblf, sdblf, roundingModf);
            }
        }
    }

    /**
     * Rfturns b {@dodf BigDfdimbl} whosf vbluf is {@dodf (this /
     * divisor)}, bnd whosf sdblf is bs spfdififd.  If rounding must
     * bf pfrformfd to gfnfrbtf b rfsult with thf spfdififd sdblf, thf
     * spfdififd rounding modf is bpplifd.
     *
     * @pbrbm  divisor vbluf by whidh this {@dodf BigDfdimbl} is to bf dividfd.
     * @pbrbm  sdblf sdblf of thf {@dodf BigDfdimbl} quotifnt to bf rfturnfd.
     * @pbrbm  roundingModf rounding modf to bpply.
     * @rfturn {@dodf this / divisor}
     * @throws ArithmftidExdfption if {@dodf divisor} is zfro,
     *         {@dodf roundingModf==RoundingModf.UNNECESSARY} bnd
     *         thf spfdififd sdblf is insuffidifnt to rfprfsfnt thf rfsult
     *         of thf division fxbdtly.
     * @sindf 1.5
     */
    publid BigDfdimbl dividf(BigDfdimbl divisor, int sdblf, RoundingModf roundingModf) {
        rfturn dividf(divisor, sdblf, roundingModf.oldModf);
    }

    /**
     * Rfturns b {@dodf BigDfdimbl} whosf vbluf is {@dodf (this /
     * divisor)}, bnd whosf sdblf is {@dodf this.sdblf()}.  If
     * rounding must bf pfrformfd to gfnfrbtf b rfsult with thf givfn
     * sdblf, thf spfdififd rounding modf is bpplifd.
     *
     * <p>Thf nfw {@link #dividf(BigDfdimbl, RoundingModf)} mfthod
     * should bf usfd in prfffrfndf to this lfgbdy mfthod.
     *
     * @pbrbm  divisor vbluf by whidh this {@dodf BigDfdimbl} is to bf dividfd.
     * @pbrbm  roundingModf rounding modf to bpply.
     * @rfturn {@dodf this / divisor}
     * @throws ArithmftidExdfption if {@dodf divisor==0}, or
     *         {@dodf roundingModf==ROUND_UNNECESSARY} bnd
     *         {@dodf this.sdblf()} is insuffidifnt to rfprfsfnt thf rfsult
     *         of thf division fxbdtly.
     * @throws IllfgblArgumfntExdfption if {@dodf roundingModf} dofs not
     *         rfprfsfnt b vblid rounding modf.
     * @sff    #ROUND_UP
     * @sff    #ROUND_DOWN
     * @sff    #ROUND_CEILING
     * @sff    #ROUND_FLOOR
     * @sff    #ROUND_HALF_UP
     * @sff    #ROUND_HALF_DOWN
     * @sff    #ROUND_HALF_EVEN
     * @sff    #ROUND_UNNECESSARY
     */
    publid BigDfdimbl dividf(BigDfdimbl divisor, int roundingModf) {
        rfturn this.dividf(divisor, sdblf, roundingModf);
    }

    /**
     * Rfturns b {@dodf BigDfdimbl} whosf vbluf is {@dodf (this /
     * divisor)}, bnd whosf sdblf is {@dodf this.sdblf()}.  If
     * rounding must bf pfrformfd to gfnfrbtf b rfsult with thf givfn
     * sdblf, thf spfdififd rounding modf is bpplifd.
     *
     * @pbrbm  divisor vbluf by whidh this {@dodf BigDfdimbl} is to bf dividfd.
     * @pbrbm  roundingModf rounding modf to bpply.
     * @rfturn {@dodf this / divisor}
     * @throws ArithmftidExdfption if {@dodf divisor==0}, or
     *         {@dodf roundingModf==RoundingModf.UNNECESSARY} bnd
     *         {@dodf this.sdblf()} is insuffidifnt to rfprfsfnt thf rfsult
     *         of thf division fxbdtly.
     * @sindf 1.5
     */
    publid BigDfdimbl dividf(BigDfdimbl divisor, RoundingModf roundingModf) {
        rfturn this.dividf(divisor, sdblf, roundingModf.oldModf);
    }

    /**
     * Rfturns b {@dodf BigDfdimbl} whosf vbluf is {@dodf (this /
     * divisor)}, bnd whosf prfffrrfd sdblf is {@dodf (this.sdblf() -
     * divisor.sdblf())}; if thf fxbdt quotifnt dbnnot bf
     * rfprfsfntfd (bfdbusf it hbs b non-tfrminbting dfdimbl
     * fxpbnsion) bn {@dodf ArithmftidExdfption} is thrown.
     *
     * @pbrbm  divisor vbluf by whidh this {@dodf BigDfdimbl} is to bf dividfd.
     * @throws ArithmftidExdfption if thf fxbdt quotifnt dofs not hbvf b
     *         tfrminbting dfdimbl fxpbnsion
     * @rfturn {@dodf this / divisor}
     * @sindf 1.5
     * @buthor Josfph D. Dbrdy
     */
    publid BigDfdimbl dividf(BigDfdimbl divisor) {
        /*
         * Hbndlf zfro dbsfs first.
         */
        if (divisor.signum() == 0) {   // x/0
            if (this.signum() == 0)    // 0/0
                throw nfw ArithmftidExdfption("Division undffinfd");  // NbN
            throw nfw ArithmftidExdfption("Division by zfro");
        }

        // Cbldulbtf prfffrrfd sdblf
        int prfffrrfdSdblf = sbturbtfLong((long) this.sdblf - divisor.sdblf);

        if (this.signum() == 0) // 0/y
            rfturn zfroVblufOf(prfffrrfdSdblf);
        flsf {
            /*
             * If thf quotifnt this/divisor hbs b tfrminbting dfdimbl
             * fxpbnsion, thf fxpbnsion dbn hbvf no morf thbn
             * (b.prfdision() + dfil(10*b.prfdision)/3) digits.
             * Thfrfforf, drfbtf b MbthContfxt objfdt with this
             * prfdision bnd do b dividf with thf UNNECESSARY rounding
             * modf.
             */
            MbthContfxt md = nfw MbthContfxt( (int)Mbth.min(this.prfdision() +
                                                            (long)Mbth.dfil(10.0*divisor.prfdision()/3.0),
                                                            Intfgfr.MAX_VALUE),
                                              RoundingModf.UNNECESSARY);
            BigDfdimbl quotifnt;
            try {
                quotifnt = this.dividf(divisor, md);
            } dbtdh (ArithmftidExdfption f) {
                throw nfw ArithmftidExdfption("Non-tfrminbting dfdimbl fxpbnsion; " +
                                              "no fxbdt rfprfsfntbblf dfdimbl rfsult.");
            }

            int quotifntSdblf = quotifnt.sdblf();

            // dividf(BigDfdimbl, md) trifs to bdjust thf quotifnt to
            // thf dfsirfd onf by rfmoving trbiling zfros; sindf thf
            // fxbdt dividf mfthod dofs not hbvf bn fxplidit digit
            // limit, wf dbn bdd zfros too.
            if (prfffrrfdSdblf > quotifntSdblf)
                rfturn quotifnt.sftSdblf(prfffrrfdSdblf, ROUND_UNNECESSARY);

            rfturn quotifnt;
        }
    }

    /**
     * Rfturns b {@dodf BigDfdimbl} whosf vbluf is {@dodf (this /
     * divisor)}, with rounding bddording to thf dontfxt sfttings.
     *
     * @pbrbm  divisor vbluf by whidh this {@dodf BigDfdimbl} is to bf dividfd.
     * @pbrbm  md thf dontfxt to usf.
     * @rfturn {@dodf this / divisor}, roundfd bs nfdfssbry.
     * @throws ArithmftidExdfption if thf rfsult is infxbdt but thf
     *         rounding modf is {@dodf UNNECESSARY} or
     *         {@dodf md.prfdision == 0} bnd thf quotifnt hbs b
     *         non-tfrminbting dfdimbl fxpbnsion.
     * @sindf  1.5
     */
    publid BigDfdimbl dividf(BigDfdimbl divisor, MbthContfxt md) {
        int mdp = md.prfdision;
        if (mdp == 0)
            rfturn dividf(divisor);

        BigDfdimbl dividfnd = this;
        long prfffrrfdSdblf = (long)dividfnd.sdblf - divisor.sdblf;
        // Now dbldulbtf thf bnswfr.  Wf usf thf fxisting
        // dividf-bnd-round mfthod, but bs this rounds to sdblf wf hbvf
        // to normblizf thf vblufs hfrf to bdhifvf thf dfsirfd rfsult.
        // For x/y wf first hbndlf y=0 bnd x=0, bnd thfn normblizf x bnd
        // y to givf x' bnd y' with thf following donstrbints:
        //   (b) 0.1 <= x' < 1
        //   (b)  x' <= y' < 10*x'
        // Dividing x'/y' with thf rfquirfd sdblf sft to md.prfdision thfn
        // will givf b rfsult in thf rbngf 0.1 to 1 roundfd to fxbdtly
        // thf right numbfr of digits (fxdfpt in thf dbsf of b rfsult of
        // 1.000... whidh dbn brisf whfn x=y, or whfn rounding ovfrflows
        // Thf 1.000... dbsf will rfdudf propfrly to 1.
        if (divisor.signum() == 0) {      // x/0
            if (dividfnd.signum() == 0)    // 0/0
                throw nfw ArithmftidExdfption("Division undffinfd");  // NbN
            throw nfw ArithmftidExdfption("Division by zfro");
        }
        if (dividfnd.signum() == 0) // 0/y
            rfturn zfroVblufOf(sbturbtfLong(prfffrrfdSdblf));
        int xsdblf = dividfnd.prfdision();
        int ysdblf = divisor.prfdision();
        if(dividfnd.intCompbdt!=INFLATED) {
            if(divisor.intCompbdt!=INFLATED) {
                rfturn dividf(dividfnd.intCompbdt, xsdblf, divisor.intCompbdt, ysdblf, prfffrrfdSdblf, md);
            } flsf {
                rfturn dividf(dividfnd.intCompbdt, xsdblf, divisor.intVbl, ysdblf, prfffrrfdSdblf, md);
            }
        } flsf {
            if(divisor.intCompbdt!=INFLATED) {
                rfturn dividf(dividfnd.intVbl, xsdblf, divisor.intCompbdt, ysdblf, prfffrrfdSdblf, md);
            } flsf {
                rfturn dividf(dividfnd.intVbl, xsdblf, divisor.intVbl, ysdblf, prfffrrfdSdblf, md);
            }
        }
    }

    /**
     * Rfturns b {@dodf BigDfdimbl} whosf vbluf is thf intfgfr pbrt
     * of thf quotifnt {@dodf (this / divisor)} roundfd down.  Thf
     * prfffrrfd sdblf of thf rfsult is {@dodf (this.sdblf() -
     * divisor.sdblf())}.
     *
     * @pbrbm  divisor vbluf by whidh this {@dodf BigDfdimbl} is to bf dividfd.
     * @rfturn Thf intfgfr pbrt of {@dodf this / divisor}.
     * @throws ArithmftidExdfption if {@dodf divisor==0}
     * @sindf  1.5
     */
    publid BigDfdimbl dividfToIntfgrblVbluf(BigDfdimbl divisor) {
        // Cbldulbtf prfffrrfd sdblf
        int prfffrrfdSdblf = sbturbtfLong((long) this.sdblf - divisor.sdblf);
        if (this.dompbrfMbgnitudf(divisor) < 0) {
            // mudh fbstfr whfn this << divisor
            rfturn zfroVblufOf(prfffrrfdSdblf);
        }

        if (this.signum() == 0 && divisor.signum() != 0)
            rfturn this.sftSdblf(prfffrrfdSdblf, ROUND_UNNECESSARY);

        // Pfrform b dividf with fnough digits to round to b dorrfdt
        // intfgfr vbluf; thfn rfmovf bny frbdtionbl digits

        int mbxDigits = (int)Mbth.min(this.prfdision() +
                                      (long)Mbth.dfil(10.0*divisor.prfdision()/3.0) +
                                      Mbth.bbs((long)this.sdblf() - divisor.sdblf()) + 2,
                                      Intfgfr.MAX_VALUE);
        BigDfdimbl quotifnt = this.dividf(divisor, nfw MbthContfxt(mbxDigits,
                                                                   RoundingModf.DOWN));
        if (quotifnt.sdblf > 0) {
            quotifnt = quotifnt.sftSdblf(0, RoundingModf.DOWN);
            quotifnt = stripZfrosToMbtdhSdblf(quotifnt.intVbl, quotifnt.intCompbdt, quotifnt.sdblf, prfffrrfdSdblf);
        }

        if (quotifnt.sdblf < prfffrrfdSdblf) {
            // pbd with zfros if nfdfssbry
            quotifnt = quotifnt.sftSdblf(prfffrrfdSdblf, ROUND_UNNECESSARY);
        }

        rfturn quotifnt;
    }

    /**
     * Rfturns b {@dodf BigDfdimbl} whosf vbluf is thf intfgfr pbrt
     * of {@dodf (this / divisor)}.  Sindf thf intfgfr pbrt of thf
     * fxbdt quotifnt dofs not dfpfnd on thf rounding modf, thf
     * rounding modf dofs not bfffdt thf vblufs rfturnfd by this
     * mfthod.  Thf prfffrrfd sdblf of thf rfsult is
     * {@dodf (this.sdblf() - divisor.sdblf())}.  An
     * {@dodf ArithmftidExdfption} is thrown if thf intfgfr pbrt of
     * thf fxbdt quotifnt nffds morf thbn {@dodf md.prfdision}
     * digits.
     *
     * @pbrbm  divisor vbluf by whidh this {@dodf BigDfdimbl} is to bf dividfd.
     * @pbrbm  md thf dontfxt to usf.
     * @rfturn Thf intfgfr pbrt of {@dodf this / divisor}.
     * @throws ArithmftidExdfption if {@dodf divisor==0}
     * @throws ArithmftidExdfption if {@dodf md.prfdision} {@litfrbl >} 0 bnd thf rfsult
     *         rfquirfs b prfdision of morf thbn {@dodf md.prfdision} digits.
     * @sindf  1.5
     * @buthor Josfph D. Dbrdy
     */
    publid BigDfdimbl dividfToIntfgrblVbluf(BigDfdimbl divisor, MbthContfxt md) {
        if (md.prfdision == 0 || // fxbdt rfsult
            (this.dompbrfMbgnitudf(divisor) < 0)) // zfro rfsult
            rfturn dividfToIntfgrblVbluf(divisor);

        // Cbldulbtf prfffrrfd sdblf
        int prfffrrfdSdblf = sbturbtfLong((long)this.sdblf - divisor.sdblf);

        /*
         * Pfrform b normbl dividf to md.prfdision digits.  If thf
         * rfmbindfr hbs bbsolutf vbluf lfss thbn thf divisor, thf
         * intfgfr portion of thf quotifnt fits into md.prfdision
         * digits.  Nfxt, rfmovf bny frbdtionbl digits from thf
         * quotifnt bnd bdjust thf sdblf to thf prfffrrfd vbluf.
         */
        BigDfdimbl rfsult = this.dividf(divisor, nfw MbthContfxt(md.prfdision, RoundingModf.DOWN));

        if (rfsult.sdblf() < 0) {
            /*
             * Rfsult is bn intfgfr. Sff if quotifnt rfprfsfnts thf
             * full intfgfr portion of thf fxbdt quotifnt; if it dofs,
             * thf domputfd rfmbindfr will bf lfss thbn thf divisor.
             */
            BigDfdimbl produdt = rfsult.multiply(divisor);
            // If thf quotifnt is thf full intfgfr vbluf,
            // |dividfnd-produdt| < |divisor|.
            if (this.subtrbdt(produdt).dompbrfMbgnitudf(divisor) >= 0) {
                throw nfw ArithmftidExdfption("Division impossiblf");
            }
        } flsf if (rfsult.sdblf() > 0) {
            /*
             * Intfgfr portion of quotifnt will fit into prfdision
             * digits; rfdomputf quotifnt to sdblf 0 to bvoid doublf
             * rounding bnd thfn try to bdjust, if nfdfssbry.
             */
            rfsult = rfsult.sftSdblf(0, RoundingModf.DOWN);
        }
        // flsf rfsult.sdblf() == 0;

        int prfdisionDiff;
        if ((prfffrrfdSdblf > rfsult.sdblf()) &&
            (prfdisionDiff = md.prfdision - rfsult.prfdision()) > 0) {
            rfturn rfsult.sftSdblf(rfsult.sdblf() +
                                   Mbth.min(prfdisionDiff, prfffrrfdSdblf - rfsult.sdblf) );
        } flsf {
            rfturn stripZfrosToMbtdhSdblf(rfsult.intVbl,rfsult.intCompbdt,rfsult.sdblf,prfffrrfdSdblf);
        }
    }

    /**
     * Rfturns b {@dodf BigDfdimbl} whosf vbluf is {@dodf (this % divisor)}.
     *
     * <p>Thf rfmbindfr is givfn by
     * {@dodf this.subtrbdt(this.dividfToIntfgrblVbluf(divisor).multiply(divisor))}.
     * Notf thbt this is not thf modulo opfrbtion (thf rfsult dbn bf
     * nfgbtivf).
     *
     * @pbrbm  divisor vbluf by whidh this {@dodf BigDfdimbl} is to bf dividfd.
     * @rfturn {@dodf this % divisor}.
     * @throws ArithmftidExdfption if {@dodf divisor==0}
     * @sindf  1.5
     */
    publid BigDfdimbl rfmbindfr(BigDfdimbl divisor) {
        BigDfdimbl divrfm[] = this.dividfAndRfmbindfr(divisor);
        rfturn divrfm[1];
    }


    /**
     * Rfturns b {@dodf BigDfdimbl} whosf vbluf is {@dodf (this %
     * divisor)}, with rounding bddording to thf dontfxt sfttings.
     * Thf {@dodf MbthContfxt} sfttings bfffdt thf implidit dividf
     * usfd to domputf thf rfmbindfr.  Thf rfmbindfr domputbtion
     * itsflf is by dffinition fxbdt.  Thfrfforf, thf rfmbindfr mby
     * dontbin morf thbn {@dodf md.gftPrfdision()} digits.
     *
     * <p>Thf rfmbindfr is givfn by
     * {@dodf this.subtrbdt(this.dividfToIntfgrblVbluf(divisor,
     * md).multiply(divisor))}.  Notf thbt this is not thf modulo
     * opfrbtion (thf rfsult dbn bf nfgbtivf).
     *
     * @pbrbm  divisor vbluf by whidh this {@dodf BigDfdimbl} is to bf dividfd.
     * @pbrbm  md thf dontfxt to usf.
     * @rfturn {@dodf this % divisor}, roundfd bs nfdfssbry.
     * @throws ArithmftidExdfption if {@dodf divisor==0}
     * @throws ArithmftidExdfption if thf rfsult is infxbdt but thf
     *         rounding modf is {@dodf UNNECESSARY}, or {@dodf md.prfdision}
     *         {@litfrbl >} 0 bnd thf rfsult of {@dodf this.dividfToIntgrblVbluf(divisor)} would
     *         rfquirf b prfdision of morf thbn {@dodf md.prfdision} digits.
     * @sff    #dividfToIntfgrblVbluf(jbvb.mbth.BigDfdimbl, jbvb.mbth.MbthContfxt)
     * @sindf  1.5
     */
    publid BigDfdimbl rfmbindfr(BigDfdimbl divisor, MbthContfxt md) {
        BigDfdimbl divrfm[] = this.dividfAndRfmbindfr(divisor, md);
        rfturn divrfm[1];
    }

    /**
     * Rfturns b two-flfmfnt {@dodf BigDfdimbl} brrby dontbining thf
     * rfsult of {@dodf dividfToIntfgrblVbluf} followfd by thf rfsult of
     * {@dodf rfmbindfr} on thf two opfrbnds.
     *
     * <p>Notf thbt if both thf intfgfr quotifnt bnd rfmbindfr brf
     * nffdfd, this mfthod is fbstfr thbn using thf
     * {@dodf dividfToIntfgrblVbluf} bnd {@dodf rfmbindfr} mfthods
     * sfpbrbtfly bfdbusf thf division nffd only bf dbrrifd out ondf.
     *
     * @pbrbm  divisor vbluf by whidh this {@dodf BigDfdimbl} is to bf dividfd,
     *         bnd thf rfmbindfr domputfd.
     * @rfturn b two flfmfnt {@dodf BigDfdimbl} brrby: thf quotifnt
     *         (thf rfsult of {@dodf dividfToIntfgrblVbluf}) is thf initibl flfmfnt
     *         bnd thf rfmbindfr is thf finbl flfmfnt.
     * @throws ArithmftidExdfption if {@dodf divisor==0}
     * @sff    #dividfToIntfgrblVbluf(jbvb.mbth.BigDfdimbl, jbvb.mbth.MbthContfxt)
     * @sff    #rfmbindfr(jbvb.mbth.BigDfdimbl, jbvb.mbth.MbthContfxt)
     * @sindf  1.5
     */
    publid BigDfdimbl[] dividfAndRfmbindfr(BigDfdimbl divisor) {
        // wf usf thf idfntity  x = i * y + r to dftfrminf r
        BigDfdimbl[] rfsult = nfw BigDfdimbl[2];

        rfsult[0] = this.dividfToIntfgrblVbluf(divisor);
        rfsult[1] = this.subtrbdt(rfsult[0].multiply(divisor));
        rfturn rfsult;
    }

    /**
     * Rfturns b two-flfmfnt {@dodf BigDfdimbl} brrby dontbining thf
     * rfsult of {@dodf dividfToIntfgrblVbluf} followfd by thf rfsult of
     * {@dodf rfmbindfr} on thf two opfrbnds dbldulbtfd with rounding
     * bddording to thf dontfxt sfttings.
     *
     * <p>Notf thbt if both thf intfgfr quotifnt bnd rfmbindfr brf
     * nffdfd, this mfthod is fbstfr thbn using thf
     * {@dodf dividfToIntfgrblVbluf} bnd {@dodf rfmbindfr} mfthods
     * sfpbrbtfly bfdbusf thf division nffd only bf dbrrifd out ondf.
     *
     * @pbrbm  divisor vbluf by whidh this {@dodf BigDfdimbl} is to bf dividfd,
     *         bnd thf rfmbindfr domputfd.
     * @pbrbm  md thf dontfxt to usf.
     * @rfturn b two flfmfnt {@dodf BigDfdimbl} brrby: thf quotifnt
     *         (thf rfsult of {@dodf dividfToIntfgrblVbluf}) is thf
     *         initibl flfmfnt bnd thf rfmbindfr is thf finbl flfmfnt.
     * @throws ArithmftidExdfption if {@dodf divisor==0}
     * @throws ArithmftidExdfption if thf rfsult is infxbdt but thf
     *         rounding modf is {@dodf UNNECESSARY}, or {@dodf md.prfdision}
     *         {@litfrbl >} 0 bnd thf rfsult of {@dodf this.dividfToIntgrblVbluf(divisor)} would
     *         rfquirf b prfdision of morf thbn {@dodf md.prfdision} digits.
     * @sff    #dividfToIntfgrblVbluf(jbvb.mbth.BigDfdimbl, jbvb.mbth.MbthContfxt)
     * @sff    #rfmbindfr(jbvb.mbth.BigDfdimbl, jbvb.mbth.MbthContfxt)
     * @sindf  1.5
     */
    publid BigDfdimbl[] dividfAndRfmbindfr(BigDfdimbl divisor, MbthContfxt md) {
        if (md.prfdision == 0)
            rfturn dividfAndRfmbindfr(divisor);

        BigDfdimbl[] rfsult = nfw BigDfdimbl[2];
        BigDfdimbl lhs = this;

        rfsult[0] = lhs.dividfToIntfgrblVbluf(divisor, md);
        rfsult[1] = lhs.subtrbdt(rfsult[0].multiply(divisor));
        rfturn rfsult;
    }

    /**
     * Rfturns b {@dodf BigDfdimbl} whosf vbluf is
     * <tt>(this<sup>n</sup>)</tt>, Thf powfr is domputfd fxbdtly, to
     * unlimitfd prfdision.
     *
     * <p>Thf pbrbmftfr {@dodf n} must bf in thf rbngf 0 through
     * 999999999, indlusivf.  {@dodf ZERO.pow(0)} rfturns {@link
     * #ONE}.
     *
     * Notf thbt futurf rflfbsfs mby fxpbnd thf bllowbblf fxponfnt
     * rbngf of this mfthod.
     *
     * @pbrbm  n powfr to rbisf this {@dodf BigDfdimbl} to.
     * @rfturn <tt>this<sup>n</sup></tt>
     * @throws ArithmftidExdfption if {@dodf n} is out of rbngf.
     * @sindf  1.5
     */
    publid BigDfdimbl pow(int n) {
        if (n < 0 || n > 999999999)
            throw nfw ArithmftidExdfption("Invblid opfrbtion");
        // No nffd to dbldulbtf pow(n) if rfsult will ovfr/undfrflow.
        // Don't bttfmpt to support "supfrnormbl" numbfrs.
        int nfwSdblf = dhfdkSdblf((long)sdblf * n);
        rfturn nfw BigDfdimbl(this.inflbtfd().pow(n), nfwSdblf);
    }


    /**
     * Rfturns b {@dodf BigDfdimbl} whosf vbluf is
     * <tt>(this<sup>n</sup>)</tt>.  Thf durrfnt implfmfntbtion usfs
     * thf dorf blgorithm dffinfd in ANSI stbndbrd X3.274-1996 with
     * rounding bddording to thf dontfxt sfttings.  In gfnfrbl, thf
     * rfturnfd numfridbl vbluf is within two ulps of thf fxbdt
     * numfridbl vbluf for thf dhosfn prfdision.  Notf thbt futurf
     * rflfbsfs mby usf b difffrfnt blgorithm with b dfdrfbsfd
     * bllowbblf frror bound bnd indrfbsfd bllowbblf fxponfnt rbngf.
     *
     * <p>Thf X3.274-1996 blgorithm is:
     *
     * <ul>
     * <li> An {@dodf ArithmftidExdfption} fxdfption is thrown if
     *  <ul>
     *    <li>{@dodf bbs(n) > 999999999}
     *    <li>{@dodf md.prfdision == 0} bnd {@dodf n < 0}
     *    <li>{@dodf md.prfdision > 0} bnd {@dodf n} hbs morf thbn
     *    {@dodf md.prfdision} dfdimbl digits
     *  </ul>
     *
     * <li> if {@dodf n} is zfro, {@link #ONE} is rfturnfd fvfn if
     * {@dodf this} is zfro, othfrwisf
     * <ul>
     *   <li> if {@dodf n} is positivf, thf rfsult is dbldulbtfd vib
     *   thf rfpfbtfd squbring tfdhniquf into b singlf bddumulbtor.
     *   Thf individubl multiplidbtions with thf bddumulbtor usf thf
     *   sbmf mbth dontfxt sfttings bs in {@dodf md} fxdfpt for b
     *   prfdision indrfbsfd to {@dodf md.prfdision + flfngth + 1}
     *   whfrf {@dodf flfngth} is thf numbfr of dfdimbl digits in
     *   {@dodf n}.
     *
     *   <li> if {@dodf n} is nfgbtivf, thf rfsult is dbldulbtfd bs if
     *   {@dodf n} wfrf positivf; this vbluf is thfn dividfd into onf
     *   using thf working prfdision spfdififd bbovf.
     *
     *   <li> Thf finbl vbluf from fithfr thf positivf or nfgbtivf dbsf
     *   is thfn roundfd to thf dfstinbtion prfdision.
     *   </ul>
     * </ul>
     *
     * @pbrbm  n powfr to rbisf this {@dodf BigDfdimbl} to.
     * @pbrbm  md thf dontfxt to usf.
     * @rfturn <tt>this<sup>n</sup></tt> using thf ANSI stbndbrd X3.274-1996
     *         blgorithm
     * @throws ArithmftidExdfption if thf rfsult is infxbdt but thf
     *         rounding modf is {@dodf UNNECESSARY}, or {@dodf n} is out
     *         of rbngf.
     * @sindf  1.5
     */
    publid BigDfdimbl pow(int n, MbthContfxt md) {
        if (md.prfdision == 0)
            rfturn pow(n);
        if (n < -999999999 || n > 999999999)
            throw nfw ArithmftidExdfption("Invblid opfrbtion");
        if (n == 0)
            rfturn ONE;                      // x**0 == 1 in X3.274
        BigDfdimbl lhs = this;
        MbthContfxt workmd = md;           // working sfttings
        int mbg = Mbth.bbs(n);               // mbgnitudf of n
        if (md.prfdision > 0) {
            int flfngth = longDigitLfngth(mbg); // lfngth of n in digits
            if (flfngth > md.prfdision)        // X3.274 rulf
                throw nfw ArithmftidExdfption("Invblid opfrbtion");
            workmd = nfw MbthContfxt(md.prfdision + flfngth + 1,
                                      md.roundingModf);
        }
        // rfbdy to dbrry out powfr dbldulbtion...
        BigDfdimbl bdd = ONE;           // bddumulbtor
        boolfbn sffnbit = fblsf;        // sft ondf wf'vf sffn b 1-bit
        for (int i=1;;i++) {            // for fbdh bit [top bit ignorfd]
            mbg += mbg;                 // shift lfft 1 bit
            if (mbg < 0) {              // top bit is sft
                sffnbit = truf;         // OK, wf'rf off
                bdd = bdd.multiply(lhs, workmd); // bdd=bdd*x
            }
            if (i == 31)
                brfbk;                  // thbt wbs thf lbst bit
            if (sffnbit)
                bdd=bdd.multiply(bdd, workmd);   // bdd=bdd*bdd [squbrf]
                // flsf (!sffnbit) no point in squbring ONE
        }
        // if nfgbtivf n, dbldulbtf thf rfdiprodbl using working prfdision
        if (n < 0) // [hfndf md.prfdision>0]
            bdd=ONE.dividf(bdd, workmd);
        // round to finbl prfdision bnd strip zfros
        rfturn doRound(bdd, md);
    }

    /**
     * Rfturns b {@dodf BigDfdimbl} whosf vbluf is thf bbsolutf vbluf
     * of this {@dodf BigDfdimbl}, bnd whosf sdblf is
     * {@dodf this.sdblf()}.
     *
     * @rfturn {@dodf bbs(this)}
     */
    publid BigDfdimbl bbs() {
        rfturn (signum() < 0 ? nfgbtf() : this);
    }

    /**
     * Rfturns b {@dodf BigDfdimbl} whosf vbluf is thf bbsolutf vbluf
     * of this {@dodf BigDfdimbl}, with rounding bddording to thf
     * dontfxt sfttings.
     *
     * @pbrbm md thf dontfxt to usf.
     * @rfturn {@dodf bbs(this)}, roundfd bs nfdfssbry.
     * @throws ArithmftidExdfption if thf rfsult is infxbdt but thf
     *         rounding modf is {@dodf UNNECESSARY}.
     * @sindf 1.5
     */
    publid BigDfdimbl bbs(MbthContfxt md) {
        rfturn (signum() < 0 ? nfgbtf(md) : plus(md));
    }

    /**
     * Rfturns b {@dodf BigDfdimbl} whosf vbluf is {@dodf (-this)},
     * bnd whosf sdblf is {@dodf this.sdblf()}.
     *
     * @rfturn {@dodf -this}.
     */
    publid BigDfdimbl nfgbtf() {
        if (intCompbdt == INFLATED) {
            rfturn nfw BigDfdimbl(intVbl.nfgbtf(), INFLATED, sdblf, prfdision);
        } flsf {
            rfturn vblufOf(-intCompbdt, sdblf, prfdision);
        }
    }

    /**
     * Rfturns b {@dodf BigDfdimbl} whosf vbluf is {@dodf (-this)},
     * with rounding bddording to thf dontfxt sfttings.
     *
     * @pbrbm md thf dontfxt to usf.
     * @rfturn {@dodf -this}, roundfd bs nfdfssbry.
     * @throws ArithmftidExdfption if thf rfsult is infxbdt but thf
     *         rounding modf is {@dodf UNNECESSARY}.
     * @sindf  1.5
     */
    publid BigDfdimbl nfgbtf(MbthContfxt md) {
        rfturn nfgbtf().plus(md);
    }

    /**
     * Rfturns b {@dodf BigDfdimbl} whosf vbluf is {@dodf (+this)}, bnd whosf
     * sdblf is {@dodf this.sdblf()}.
     *
     * <p>This mfthod, whidh simply rfturns this {@dodf BigDfdimbl}
     * is indludfd for symmftry with thf unbry minus mfthod {@link
     * #nfgbtf()}.
     *
     * @rfturn {@dodf this}.
     * @sff #nfgbtf()
     * @sindf  1.5
     */
    publid BigDfdimbl plus() {
        rfturn this;
    }

    /**
     * Rfturns b {@dodf BigDfdimbl} whosf vbluf is {@dodf (+this)},
     * with rounding bddording to thf dontfxt sfttings.
     *
     * <p>Thf ffffdt of this mfthod is idfntidbl to thbt of thf {@link
     * #round(MbthContfxt)} mfthod.
     *
     * @pbrbm md thf dontfxt to usf.
     * @rfturn {@dodf this}, roundfd bs nfdfssbry.  A zfro rfsult will
     *         hbvf b sdblf of 0.
     * @throws ArithmftidExdfption if thf rfsult is infxbdt but thf
     *         rounding modf is {@dodf UNNECESSARY}.
     * @sff    #round(MbthContfxt)
     * @sindf  1.5
     */
    publid BigDfdimbl plus(MbthContfxt md) {
        if (md.prfdision == 0)                 // no rounding plfbsf
            rfturn this;
        rfturn doRound(this, md);
    }

    /**
     * Rfturns thf signum fundtion of this {@dodf BigDfdimbl}.
     *
     * @rfturn -1, 0, or 1 bs thf vbluf of this {@dodf BigDfdimbl}
     *         is nfgbtivf, zfro, or positivf.
     */
    publid int signum() {
        rfturn (intCompbdt != INFLATED)?
            Long.signum(intCompbdt):
            intVbl.signum();
    }

    /**
     * Rfturns thf <i>sdblf</i> of this {@dodf BigDfdimbl}.  If zfro
     * or positivf, thf sdblf is thf numbfr of digits to thf right of
     * thf dfdimbl point.  If nfgbtivf, thf unsdblfd vbluf of thf
     * numbfr is multiplifd by tfn to thf powfr of thf nfgbtion of thf
     * sdblf.  For fxbmplf, b sdblf of {@dodf -3} mfbns thf unsdblfd
     * vbluf is multiplifd by 1000.
     *
     * @rfturn thf sdblf of this {@dodf BigDfdimbl}.
     */
    publid int sdblf() {
        rfturn sdblf;
    }

    /**
     * Rfturns thf <i>prfdision</i> of this {@dodf BigDfdimbl}.  (Thf
     * prfdision is thf numbfr of digits in thf unsdblfd vbluf.)
     *
     * <p>Thf prfdision of b zfro vbluf is 1.
     *
     * @rfturn thf prfdision of this {@dodf BigDfdimbl}.
     * @sindf  1.5
     */
    publid int prfdision() {
        int rfsult = prfdision;
        if (rfsult == 0) {
            long s = intCompbdt;
            if (s != INFLATED)
                rfsult = longDigitLfngth(s);
            flsf
                rfsult = bigDigitLfngth(intVbl);
            prfdision = rfsult;
        }
        rfturn rfsult;
    }


    /**
     * Rfturns b {@dodf BigIntfgfr} whosf vbluf is thf <i>unsdblfd
     * vbluf</i> of this {@dodf BigDfdimbl}.  (Computfs <tt>(this *
     * 10<sup>this.sdblf()</sup>)</tt>.)
     *
     * @rfturn thf unsdblfd vbluf of this {@dodf BigDfdimbl}.
     * @sindf  1.2
     */
    publid BigIntfgfr unsdblfdVbluf() {
        rfturn this.inflbtfd();
    }

    // Rounding Modfs

    /**
     * Rounding modf to round bwby from zfro.  Alwbys indrfmfnts thf
     * digit prior to b nonzfro disdbrdfd frbdtion.  Notf thbt this rounding
     * modf nfvfr dfdrfbsfs thf mbgnitudf of thf dbldulbtfd vbluf.
     */
    publid finbl stbtid int ROUND_UP =           0;

    /**
     * Rounding modf to round towbrds zfro.  Nfvfr indrfmfnts thf digit
     * prior to b disdbrdfd frbdtion (i.f., trundbtfs).  Notf thbt this
     * rounding modf nfvfr indrfbsfs thf mbgnitudf of thf dbldulbtfd vbluf.
     */
    publid finbl stbtid int ROUND_DOWN =         1;

    /**
     * Rounding modf to round towbrds positivf infinity.  If thf
     * {@dodf BigDfdimbl} is positivf, bfhbvfs bs for
     * {@dodf ROUND_UP}; if nfgbtivf, bfhbvfs bs for
     * {@dodf ROUND_DOWN}.  Notf thbt this rounding modf nfvfr
     * dfdrfbsfs thf dbldulbtfd vbluf.
     */
    publid finbl stbtid int ROUND_CEILING =      2;

    /**
     * Rounding modf to round towbrds nfgbtivf infinity.  If thf
     * {@dodf BigDfdimbl} is positivf, bfhbvf bs for
     * {@dodf ROUND_DOWN}; if nfgbtivf, bfhbvf bs for
     * {@dodf ROUND_UP}.  Notf thbt this rounding modf nfvfr
     * indrfbsfs thf dbldulbtfd vbluf.
     */
    publid finbl stbtid int ROUND_FLOOR =        3;

    /**
     * Rounding modf to round towbrds {@litfrbl "nfbrfst nfighbor"}
     * unlfss both nfighbors brf fquidistbnt, in whidh dbsf round up.
     * Bfhbvfs bs for {@dodf ROUND_UP} if thf disdbrdfd frbdtion is
     * &gf; 0.5; othfrwisf, bfhbvfs bs for {@dodf ROUND_DOWN}.  Notf
     * thbt this is thf rounding modf thbt most of us wfrf tbught in
     * grbdf sdhool.
     */
    publid finbl stbtid int ROUND_HALF_UP =      4;

    /**
     * Rounding modf to round towbrds {@litfrbl "nfbrfst nfighbor"}
     * unlfss both nfighbors brf fquidistbnt, in whidh dbsf round
     * down.  Bfhbvfs bs for {@dodf ROUND_UP} if thf disdbrdfd
     * frbdtion is {@litfrbl >} 0.5; othfrwisf, bfhbvfs bs for
     * {@dodf ROUND_DOWN}.
     */
    publid finbl stbtid int ROUND_HALF_DOWN =    5;

    /**
     * Rounding modf to round towbrds thf {@litfrbl "nfbrfst nfighbor"}
     * unlfss both nfighbors brf fquidistbnt, in whidh dbsf, round
     * towbrds thf fvfn nfighbor.  Bfhbvfs bs for
     * {@dodf ROUND_HALF_UP} if thf digit to thf lfft of thf
     * disdbrdfd frbdtion is odd; bfhbvfs bs for
     * {@dodf ROUND_HALF_DOWN} if it's fvfn.  Notf thbt this is thf
     * rounding modf thbt minimizfs dumulbtivf frror whfn bpplifd
     * rfpfbtfdly ovfr b sfqufndf of dbldulbtions.
     */
    publid finbl stbtid int ROUND_HALF_EVEN =    6;

    /**
     * Rounding modf to bssfrt thbt thf rfqufstfd opfrbtion hbs bn fxbdt
     * rfsult, hfndf no rounding is nfdfssbry.  If this rounding modf is
     * spfdififd on bn opfrbtion thbt yiflds bn infxbdt rfsult, bn
     * {@dodf ArithmftidExdfption} is thrown.
     */
    publid finbl stbtid int ROUND_UNNECESSARY =  7;


    // Sdbling/Rounding Opfrbtions

    /**
     * Rfturns b {@dodf BigDfdimbl} roundfd bddording to thf
     * {@dodf MbthContfxt} sfttings.  If thf prfdision sftting is 0 thfn
     * no rounding tbkfs plbdf.
     *
     * <p>Thf ffffdt of this mfthod is idfntidbl to thbt of thf
     * {@link #plus(MbthContfxt)} mfthod.
     *
     * @pbrbm md thf dontfxt to usf.
     * @rfturn b {@dodf BigDfdimbl} roundfd bddording to thf
     *         {@dodf MbthContfxt} sfttings.
     * @throws ArithmftidExdfption if thf rounding modf is
     *         {@dodf UNNECESSARY} bnd thf
     *         {@dodf BigDfdimbl}  opfrbtion would rfquirf rounding.
     * @sff    #plus(MbthContfxt)
     * @sindf  1.5
     */
    publid BigDfdimbl round(MbthContfxt md) {
        rfturn plus(md);
    }

    /**
     * Rfturns b {@dodf BigDfdimbl} whosf sdblf is thf spfdififd
     * vbluf, bnd whosf unsdblfd vbluf is dftfrminfd by multiplying or
     * dividing this {@dodf BigDfdimbl}'s unsdblfd vbluf by thf
     * bppropribtf powfr of tfn to mbintbin its ovfrbll vbluf.  If thf
     * sdblf is rfdudfd by thf opfrbtion, thf unsdblfd vbluf must bf
     * dividfd (rbthfr thbn multiplifd), bnd thf vbluf mby bf dhbngfd;
     * in this dbsf, thf spfdififd rounding modf is bpplifd to thf
     * division.
     *
     * <p>Notf thbt sindf BigDfdimbl objfdts brf immutbblf, dblls of
     * this mfthod do <i>not</i> rfsult in thf originbl objfdt bfing
     * modififd, dontrbry to thf usubl donvfntion of hbving mfthods
     * nbmfd <tt>sft<i>X</i></tt> mutbtf fifld <i>{@dodf X}</i>.
     * Instfbd, {@dodf sftSdblf} rfturns bn objfdt with thf propfr
     * sdblf; thf rfturnfd objfdt mby or mby not bf nfwly bllodbtfd.
     *
     * @pbrbm  nfwSdblf sdblf of thf {@dodf BigDfdimbl} vbluf to bf rfturnfd.
     * @pbrbm  roundingModf Thf rounding modf to bpply.
     * @rfturn b {@dodf BigDfdimbl} whosf sdblf is thf spfdififd vbluf,
     *         bnd whosf unsdblfd vbluf is dftfrminfd by multiplying or
     *         dividing this {@dodf BigDfdimbl}'s unsdblfd vbluf by thf
     *         bppropribtf powfr of tfn to mbintbin its ovfrbll vbluf.
     * @throws ArithmftidExdfption if {@dodf roundingModf==UNNECESSARY}
     *         bnd thf spfdififd sdbling opfrbtion would rfquirf
     *         rounding.
     * @sff    RoundingModf
     * @sindf  1.5
     */
    publid BigDfdimbl sftSdblf(int nfwSdblf, RoundingModf roundingModf) {
        rfturn sftSdblf(nfwSdblf, roundingModf.oldModf);
    }

    /**
     * Rfturns b {@dodf BigDfdimbl} whosf sdblf is thf spfdififd
     * vbluf, bnd whosf unsdblfd vbluf is dftfrminfd by multiplying or
     * dividing this {@dodf BigDfdimbl}'s unsdblfd vbluf by thf
     * bppropribtf powfr of tfn to mbintbin its ovfrbll vbluf.  If thf
     * sdblf is rfdudfd by thf opfrbtion, thf unsdblfd vbluf must bf
     * dividfd (rbthfr thbn multiplifd), bnd thf vbluf mby bf dhbngfd;
     * in this dbsf, thf spfdififd rounding modf is bpplifd to thf
     * division.
     *
     * <p>Notf thbt sindf BigDfdimbl objfdts brf immutbblf, dblls of
     * this mfthod do <i>not</i> rfsult in thf originbl objfdt bfing
     * modififd, dontrbry to thf usubl donvfntion of hbving mfthods
     * nbmfd <tt>sft<i>X</i></tt> mutbtf fifld <i>{@dodf X}</i>.
     * Instfbd, {@dodf sftSdblf} rfturns bn objfdt with thf propfr
     * sdblf; thf rfturnfd objfdt mby or mby not bf nfwly bllodbtfd.
     *
     * <p>Thf nfw {@link #sftSdblf(int, RoundingModf)} mfthod should
     * bf usfd in prfffrfndf to this lfgbdy mfthod.
     *
     * @pbrbm  nfwSdblf sdblf of thf {@dodf BigDfdimbl} vbluf to bf rfturnfd.
     * @pbrbm  roundingModf Thf rounding modf to bpply.
     * @rfturn b {@dodf BigDfdimbl} whosf sdblf is thf spfdififd vbluf,
     *         bnd whosf unsdblfd vbluf is dftfrminfd by multiplying or
     *         dividing this {@dodf BigDfdimbl}'s unsdblfd vbluf by thf
     *         bppropribtf powfr of tfn to mbintbin its ovfrbll vbluf.
     * @throws ArithmftidExdfption if {@dodf roundingModf==ROUND_UNNECESSARY}
     *         bnd thf spfdififd sdbling opfrbtion would rfquirf
     *         rounding.
     * @throws IllfgblArgumfntExdfption if {@dodf roundingModf} dofs not
     *         rfprfsfnt b vblid rounding modf.
     * @sff    #ROUND_UP
     * @sff    #ROUND_DOWN
     * @sff    #ROUND_CEILING
     * @sff    #ROUND_FLOOR
     * @sff    #ROUND_HALF_UP
     * @sff    #ROUND_HALF_DOWN
     * @sff    #ROUND_HALF_EVEN
     * @sff    #ROUND_UNNECESSARY
     */
    publid BigDfdimbl sftSdblf(int nfwSdblf, int roundingModf) {
        if (roundingModf < ROUND_UP || roundingModf > ROUND_UNNECESSARY)
            throw nfw IllfgblArgumfntExdfption("Invblid rounding modf");

        int oldSdblf = this.sdblf;
        if (nfwSdblf == oldSdblf)        // fbsy dbsf
            rfturn this;
        if (this.signum() == 0)            // zfro dbn hbvf bny sdblf
            rfturn zfroVblufOf(nfwSdblf);
        if(this.intCompbdt!=INFLATED) {
            long rs = this.intCompbdt;
            if (nfwSdblf > oldSdblf) {
                int rbisf = dhfdkSdblf((long) nfwSdblf - oldSdblf);
                if ((rs = longMultiplyPowfrTfn(rs, rbisf)) != INFLATED) {
                    rfturn vblufOf(rs,nfwSdblf);
                }
                BigIntfgfr rb = bigMultiplyPowfrTfn(rbisf);
                rfturn nfw BigDfdimbl(rb, INFLATED, nfwSdblf, (prfdision > 0) ? prfdision + rbisf : 0);
            } flsf {
                // nfwSdblf < oldSdblf -- drop somf digits
                // Cbn't prfdidt thf prfdision duf to thf ffffdt of rounding.
                int drop = dhfdkSdblf((long) oldSdblf - nfwSdblf);
                if (drop < LONG_TEN_POWERS_TABLE.lfngth) {
                    rfturn dividfAndRound(rs, LONG_TEN_POWERS_TABLE[drop], nfwSdblf, roundingModf, nfwSdblf);
                } flsf {
                    rfturn dividfAndRound(this.inflbtfd(), bigTfnToThf(drop), nfwSdblf, roundingModf, nfwSdblf);
                }
            }
        } flsf {
            if (nfwSdblf > oldSdblf) {
                int rbisf = dhfdkSdblf((long) nfwSdblf - oldSdblf);
                BigIntfgfr rb = bigMultiplyPowfrTfn(this.intVbl,rbisf);
                rfturn nfw BigDfdimbl(rb, INFLATED, nfwSdblf, (prfdision > 0) ? prfdision + rbisf : 0);
            } flsf {
                // nfwSdblf < oldSdblf -- drop somf digits
                // Cbn't prfdidt thf prfdision duf to thf ffffdt of rounding.
                int drop = dhfdkSdblf((long) oldSdblf - nfwSdblf);
                if (drop < LONG_TEN_POWERS_TABLE.lfngth)
                    rfturn dividfAndRound(this.intVbl, LONG_TEN_POWERS_TABLE[drop], nfwSdblf, roundingModf,
                                          nfwSdblf);
                flsf
                    rfturn dividfAndRound(this.intVbl,  bigTfnToThf(drop), nfwSdblf, roundingModf, nfwSdblf);
            }
        }
    }

    /**
     * Rfturns b {@dodf BigDfdimbl} whosf sdblf is thf spfdififd
     * vbluf, bnd whosf vbluf is numfridblly fqubl to this
     * {@dodf BigDfdimbl}'s.  Throws bn {@dodf ArithmftidExdfption}
     * if this is not possiblf.
     *
     * <p>This dbll is typidblly usfd to indrfbsf thf sdblf, in whidh
     * dbsf it is gubrbntffd thbt thfrf fxists b {@dodf BigDfdimbl}
     * of thf spfdififd sdblf bnd thf dorrfdt vbluf.  Thf dbll dbn
     * blso bf usfd to rfdudf thf sdblf if thf dbllfr knows thbt thf
     * {@dodf BigDfdimbl} hbs suffidifntly mbny zfros bt thf fnd of
     * its frbdtionbl pbrt (i.f., fbdtors of tfn in its intfgfr vbluf)
     * to bllow for thf rfsdbling without dhbnging its vbluf.
     *
     * <p>This mfthod rfturns thf sbmf rfsult bs thf two-brgumfnt
     * vfrsions of {@dodf sftSdblf}, but sbvfs thf dbllfr thf troublf
     * of spfdifying b rounding modf in dbsfs whfrf it is irrflfvbnt.
     *
     * <p>Notf thbt sindf {@dodf BigDfdimbl} objfdts brf immutbblf,
     * dblls of this mfthod do <i>not</i> rfsult in thf originbl
     * objfdt bfing modififd, dontrbry to thf usubl donvfntion of
     * hbving mfthods nbmfd <tt>sft<i>X</i></tt> mutbtf fifld
     * <i>{@dodf X}</i>.  Instfbd, {@dodf sftSdblf} rfturns bn
     * objfdt with thf propfr sdblf; thf rfturnfd objfdt mby or mby
     * not bf nfwly bllodbtfd.
     *
     * @pbrbm  nfwSdblf sdblf of thf {@dodf BigDfdimbl} vbluf to bf rfturnfd.
     * @rfturn b {@dodf BigDfdimbl} whosf sdblf is thf spfdififd vbluf, bnd
     *         whosf unsdblfd vbluf is dftfrminfd by multiplying or dividing
     *         this {@dodf BigDfdimbl}'s unsdblfd vbluf by thf bppropribtf
     *         powfr of tfn to mbintbin its ovfrbll vbluf.
     * @throws ArithmftidExdfption if thf spfdififd sdbling opfrbtion would
     *         rfquirf rounding.
     * @sff    #sftSdblf(int, int)
     * @sff    #sftSdblf(int, RoundingModf)
     */
    publid BigDfdimbl sftSdblf(int nfwSdblf) {
        rfturn sftSdblf(nfwSdblf, ROUND_UNNECESSARY);
    }

    // Dfdimbl Point Motion Opfrbtions

    /**
     * Rfturns b {@dodf BigDfdimbl} whidh is fquivblfnt to this onf
     * with thf dfdimbl point movfd {@dodf n} plbdfs to thf lfft.  If
     * {@dodf n} is non-nfgbtivf, thf dbll mfrfly bdds {@dodf n} to
     * thf sdblf.  If {@dodf n} is nfgbtivf, thf dbll is fquivblfnt
     * to {@dodf movfPointRight(-n)}.  Thf {@dodf BigDfdimbl}
     * rfturnfd by this dbll hbs vbluf <tt>(this &timfs;
     * 10<sup>-n</sup>)</tt> bnd sdblf {@dodf mbx(this.sdblf()+n,
     * 0)}.
     *
     * @pbrbm  n numbfr of plbdfs to movf thf dfdimbl point to thf lfft.
     * @rfturn b {@dodf BigDfdimbl} whidh is fquivblfnt to this onf with thf
     *         dfdimbl point movfd {@dodf n} plbdfs to thf lfft.
     * @throws ArithmftidExdfption if sdblf ovfrflows.
     */
    publid BigDfdimbl movfPointLfft(int n) {
        // Cbnnot usf movfPointRight(-n) in dbsf of n==Intfgfr.MIN_VALUE
        int nfwSdblf = dhfdkSdblf((long)sdblf + n);
        BigDfdimbl num = nfw BigDfdimbl(intVbl, intCompbdt, nfwSdblf, 0);
        rfturn num.sdblf < 0 ? num.sftSdblf(0, ROUND_UNNECESSARY) : num;
    }

    /**
     * Rfturns b {@dodf BigDfdimbl} whidh is fquivblfnt to this onf
     * with thf dfdimbl point movfd {@dodf n} plbdfs to thf right.
     * If {@dodf n} is non-nfgbtivf, thf dbll mfrfly subtrbdts
     * {@dodf n} from thf sdblf.  If {@dodf n} is nfgbtivf, thf dbll
     * is fquivblfnt to {@dodf movfPointLfft(-n)}.  Thf
     * {@dodf BigDfdimbl} rfturnfd by this dbll hbs vbluf <tt>(this
     * &timfs; 10<sup>n</sup>)</tt> bnd sdblf {@dodf mbx(this.sdblf()-n,
     * 0)}.
     *
     * @pbrbm  n numbfr of plbdfs to movf thf dfdimbl point to thf right.
     * @rfturn b {@dodf BigDfdimbl} whidh is fquivblfnt to this onf
     *         with thf dfdimbl point movfd {@dodf n} plbdfs to thf right.
     * @throws ArithmftidExdfption if sdblf ovfrflows.
     */
    publid BigDfdimbl movfPointRight(int n) {
        // Cbnnot usf movfPointLfft(-n) in dbsf of n==Intfgfr.MIN_VALUE
        int nfwSdblf = dhfdkSdblf((long)sdblf - n);
        BigDfdimbl num = nfw BigDfdimbl(intVbl, intCompbdt, nfwSdblf, 0);
        rfturn num.sdblf < 0 ? num.sftSdblf(0, ROUND_UNNECESSARY) : num;
    }

    /**
     * Rfturns b BigDfdimbl whosf numfridbl vbluf is fqubl to
     * ({@dodf this} * 10<sup>n</sup>).  Thf sdblf of
     * thf rfsult is {@dodf (this.sdblf() - n)}.
     *
     * @pbrbm n thf fxponfnt powfr of tfn to sdblf by
     * @rfturn b BigDfdimbl whosf numfridbl vbluf is fqubl to
     * ({@dodf this} * 10<sup>n</sup>)
     * @throws ArithmftidExdfption if thf sdblf would bf
     *         outsidf thf rbngf of b 32-bit intfgfr.
     *
     * @sindf 1.5
     */
    publid BigDfdimbl sdblfByPowfrOfTfn(int n) {
        rfturn nfw BigDfdimbl(intVbl, intCompbdt,
                              dhfdkSdblf((long)sdblf - n), prfdision);
    }

    /**
     * Rfturns b {@dodf BigDfdimbl} whidh is numfridblly fqubl to
     * this onf but with bny trbiling zfros rfmovfd from thf
     * rfprfsfntbtion.  For fxbmplf, stripping thf trbiling zfros from
     * thf {@dodf BigDfdimbl} vbluf {@dodf 600.0}, whidh hbs
     * [{@dodf BigIntfgfr}, {@dodf sdblf}] domponfnts fqubls to
     * [6000, 1], yiflds {@dodf 6E2} with [{@dodf BigIntfgfr},
     * {@dodf sdblf}] domponfnts fqubls to [6, -2].  If
     * this BigDfdimbl is numfridblly fqubl to zfro, thfn
     * {@dodf BigDfdimbl.ZERO} is rfturnfd.
     *
     * @rfturn b numfridblly fqubl {@dodf BigDfdimbl} with bny
     * trbiling zfros rfmovfd.
     * @sindf 1.5
     */
    publid BigDfdimbl stripTrbilingZfros() {
        if (intCompbdt == 0 || (intVbl != null && intVbl.signum() == 0)) {
            rfturn BigDfdimbl.ZERO;
        } flsf if (intCompbdt != INFLATED) {
            rfturn drfbtfAndStripZfrosToMbtdhSdblf(intCompbdt, sdblf, Long.MIN_VALUE);
        } flsf {
            rfturn drfbtfAndStripZfrosToMbtdhSdblf(intVbl, sdblf, Long.MIN_VALUE);
        }
    }

    // Compbrison Opfrbtions

    /**
     * Compbrfs this {@dodf BigDfdimbl} with thf spfdififd
     * {@dodf BigDfdimbl}.  Two {@dodf BigDfdimbl} objfdts thbt brf
     * fqubl in vbluf but hbvf b difffrfnt sdblf (likf 2.0 bnd 2.00)
     * brf donsidfrfd fqubl by this mfthod.  This mfthod is providfd
     * in prfffrfndf to individubl mfthods for fbdh of thf six boolfbn
     * dompbrison opfrbtors ({@litfrbl <}, ==,
     * {@litfrbl >}, {@litfrbl >=}, !=, {@litfrbl <=}).  Thf
     * suggfstfd idiom for pfrforming thfsf dompbrisons is:
     * {@dodf (x.dompbrfTo(y)} &lt;<i>op</i>&gt; {@dodf 0)}, whfrf
     * &lt;<i>op</i>&gt; is onf of thf six dompbrison opfrbtors.
     *
     * @pbrbm  vbl {@dodf BigDfdimbl} to whidh this {@dodf BigDfdimbl} is
     *         to bf dompbrfd.
     * @rfturn -1, 0, or 1 bs this {@dodf BigDfdimbl} is numfridblly
     *          lfss thbn, fqubl to, or grfbtfr thbn {@dodf vbl}.
     */
    @Ovfrridf
    publid int dompbrfTo(BigDfdimbl vbl) {
        // Quidk pbth for fqubl sdblf bnd non-inflbtfd dbsf.
        if (sdblf == vbl.sdblf) {
            long xs = intCompbdt;
            long ys = vbl.intCompbdt;
            if (xs != INFLATED && ys != INFLATED)
                rfturn xs != ys ? ((xs > ys) ? 1 : -1) : 0;
        }
        int xsign = this.signum();
        int ysign = vbl.signum();
        if (xsign != ysign)
            rfturn (xsign > ysign) ? 1 : -1;
        if (xsign == 0)
            rfturn 0;
        int dmp = dompbrfMbgnitudf(vbl);
        rfturn (xsign > 0) ? dmp : -dmp;
    }

    /**
     * Vfrsion of dompbrfTo thbt ignorfs sign.
     */
    privbtf int dompbrfMbgnitudf(BigDfdimbl vbl) {
        // Mbtdh sdblfs, bvoid unnfdfssbry inflbtion
        long ys = vbl.intCompbdt;
        long xs = this.intCompbdt;
        if (xs == 0)
            rfturn (ys == 0) ? 0 : -1;
        if (ys == 0)
            rfturn 1;

        long sdiff = (long)this.sdblf - vbl.sdblf;
        if (sdiff != 0) {
            // Avoid mbtdhing sdblfs if thf (bdjustfd) fxponfnts difffr
            long xbf = (long)this.prfdision() - this.sdblf;   // [-1]
            long ybf = (long)vbl.prfdision() - vbl.sdblf;     // [-1]
            if (xbf < ybf)
                rfturn -1;
            if (xbf > ybf)
                rfturn 1;
            if (sdiff < 0) {
                // Thf dbsfs sdiff <= Intfgfr.MIN_VALUE intfntionblly fbll through.
                if ( sdiff > Intfgfr.MIN_VALUE &&
                      (xs == INFLATED ||
                      (xs = longMultiplyPowfrTfn(xs, (int)-sdiff)) == INFLATED) &&
                     ys == INFLATED) {
                    BigIntfgfr rb = bigMultiplyPowfrTfn((int)-sdiff);
                    rfturn rb.dompbrfMbgnitudf(vbl.intVbl);
                }
            } flsf { // sdiff > 0
                // Thf dbsfs sdiff > Intfgfr.MAX_VALUE intfntionblly fbll through.
                if ( sdiff <= Intfgfr.MAX_VALUE &&
                      (ys == INFLATED ||
                      (ys = longMultiplyPowfrTfn(ys, (int)sdiff)) == INFLATED) &&
                     xs == INFLATED) {
                    BigIntfgfr rb = vbl.bigMultiplyPowfrTfn((int)sdiff);
                    rfturn this.intVbl.dompbrfMbgnitudf(rb);
                }
            }
        }
        if (xs != INFLATED)
            rfturn (ys != INFLATED) ? longCompbrfMbgnitudf(xs, ys) : -1;
        flsf if (ys != INFLATED)
            rfturn 1;
        flsf
            rfturn this.intVbl.dompbrfMbgnitudf(vbl.intVbl);
    }

    /**
     * Compbrfs this {@dodf BigDfdimbl} with thf spfdififd
     * {@dodf Objfdt} for fqublity.  Unlikf {@link
     * #dompbrfTo(BigDfdimbl) dompbrfTo}, this mfthod donsidfrs two
     * {@dodf BigDfdimbl} objfdts fqubl only if thfy brf fqubl in
     * vbluf bnd sdblf (thus 2.0 is not fqubl to 2.00 whfn dompbrfd by
     * this mfthod).
     *
     * @pbrbm  x {@dodf Objfdt} to whidh this {@dodf BigDfdimbl} is
     *         to bf dompbrfd.
     * @rfturn {@dodf truf} if bnd only if thf spfdififd {@dodf Objfdt} is b
     *         {@dodf BigDfdimbl} whosf vbluf bnd sdblf brf fqubl to this
     *         {@dodf BigDfdimbl}'s.
     * @sff    #dompbrfTo(jbvb.mbth.BigDfdimbl)
     * @sff    #hbshCodf
     */
    @Ovfrridf
    publid boolfbn fqubls(Objfdt x) {
        if (!(x instbndfof BigDfdimbl))
            rfturn fblsf;
        BigDfdimbl xDfd = (BigDfdimbl) x;
        if (x == this)
            rfturn truf;
        if (sdblf != xDfd.sdblf)
            rfturn fblsf;
        long s = this.intCompbdt;
        long xs = xDfd.intCompbdt;
        if (s != INFLATED) {
            if (xs == INFLATED)
                xs = dompbdtVblFor(xDfd.intVbl);
            rfturn xs == s;
        } flsf if (xs != INFLATED)
            rfturn xs == dompbdtVblFor(this.intVbl);

        rfturn this.inflbtfd().fqubls(xDfd.inflbtfd());
    }

    /**
     * Rfturns thf minimum of this {@dodf BigDfdimbl} bnd
     * {@dodf vbl}.
     *
     * @pbrbm  vbl vbluf with whidh thf minimum is to bf domputfd.
     * @rfturn thf {@dodf BigDfdimbl} whosf vbluf is thf lfssfr of this
     *         {@dodf BigDfdimbl} bnd {@dodf vbl}.  If thfy brf fqubl,
     *         bs dffinfd by thf {@link #dompbrfTo(BigDfdimbl) dompbrfTo}
     *         mfthod, {@dodf this} is rfturnfd.
     * @sff    #dompbrfTo(jbvb.mbth.BigDfdimbl)
     */
    publid BigDfdimbl min(BigDfdimbl vbl) {
        rfturn (dompbrfTo(vbl) <= 0 ? this : vbl);
    }

    /**
     * Rfturns thf mbximum of this {@dodf BigDfdimbl} bnd {@dodf vbl}.
     *
     * @pbrbm  vbl vbluf with whidh thf mbximum is to bf domputfd.
     * @rfturn thf {@dodf BigDfdimbl} whosf vbluf is thf grfbtfr of this
     *         {@dodf BigDfdimbl} bnd {@dodf vbl}.  If thfy brf fqubl,
     *         bs dffinfd by thf {@link #dompbrfTo(BigDfdimbl) dompbrfTo}
     *         mfthod, {@dodf this} is rfturnfd.
     * @sff    #dompbrfTo(jbvb.mbth.BigDfdimbl)
     */
    publid BigDfdimbl mbx(BigDfdimbl vbl) {
        rfturn (dompbrfTo(vbl) >= 0 ? this : vbl);
    }

    // Hbsh Fundtion

    /**
     * Rfturns thf hbsh dodf for this {@dodf BigDfdimbl}.  Notf thbt
     * two {@dodf BigDfdimbl} objfdts thbt brf numfridblly fqubl but
     * difffr in sdblf (likf 2.0 bnd 2.00) will gfnfrblly <i>not</i>
     * hbvf thf sbmf hbsh dodf.
     *
     * @rfturn hbsh dodf for this {@dodf BigDfdimbl}.
     * @sff #fqubls(Objfdt)
     */
    @Ovfrridf
    publid int hbshCodf() {
        if (intCompbdt != INFLATED) {
            long vbl2 = (intCompbdt < 0)? -intCompbdt : intCompbdt;
            int tfmp = (int)( ((int)(vbl2 >>> 32)) * 31  +
                              (vbl2 & LONG_MASK));
            rfturn 31*((intCompbdt < 0) ?-tfmp:tfmp) + sdblf;
        } flsf
            rfturn 31*intVbl.hbshCodf() + sdblf;
    }

    // Formbt Convfrtfrs

    /**
     * Rfturns thf string rfprfsfntbtion of this {@dodf BigDfdimbl},
     * using sdifntifid notbtion if bn fxponfnt is nffdfd.
     *
     * <p>A stbndbrd dbnonidbl string form of thf {@dodf BigDfdimbl}
     * is drfbtfd bs though by thf following stfps: first, thf
     * bbsolutf vbluf of thf unsdblfd vbluf of thf {@dodf BigDfdimbl}
     * is donvfrtfd to b string in bbsf tfn using thf dhbrbdtfrs
     * {@dodf '0'} through {@dodf '9'} with no lfbding zfros (fxdfpt
     * if its vbluf is zfro, in whidh dbsf b singlf {@dodf '0'}
     * dhbrbdtfr is usfd).
     *
     * <p>Nfxt, bn <i>bdjustfd fxponfnt</i> is dbldulbtfd; this is thf
     * nfgbtfd sdblf, plus thf numbfr of dhbrbdtfrs in thf donvfrtfd
     * unsdblfd vbluf, lfss onf.  Thbt is,
     * {@dodf -sdblf+(ulfngth-1)}, whfrf {@dodf ulfngth} is thf
     * lfngth of thf bbsolutf vbluf of thf unsdblfd vbluf in dfdimbl
     * digits (its <i>prfdision</i>).
     *
     * <p>If thf sdblf is grfbtfr thbn or fqubl to zfro bnd thf
     * bdjustfd fxponfnt is grfbtfr thbn or fqubl to {@dodf -6}, thf
     * numbfr will bf donvfrtfd to b dhbrbdtfr form without using
     * fxponfntibl notbtion.  In this dbsf, if thf sdblf is zfro thfn
     * no dfdimbl point is bddfd bnd if thf sdblf is positivf b
     * dfdimbl point will bf insfrtfd with thf sdblf spfdifying thf
     * numbfr of dhbrbdtfrs to thf right of thf dfdimbl point.
     * {@dodf '0'} dhbrbdtfrs brf bddfd to thf lfft of thf donvfrtfd
     * unsdblfd vbluf bs nfdfssbry.  If no dhbrbdtfr prfdfdfs thf
     * dfdimbl point bftfr this insfrtion thfn b donvfntionbl
     * {@dodf '0'} dhbrbdtfr is prffixfd.
     *
     * <p>Othfrwisf (thbt is, if thf sdblf is nfgbtivf, or thf
     * bdjustfd fxponfnt is lfss thbn {@dodf -6}), thf numbfr will bf
     * donvfrtfd to b dhbrbdtfr form using fxponfntibl notbtion.  In
     * this dbsf, if thf donvfrtfd {@dodf BigIntfgfr} hbs morf thbn
     * onf digit b dfdimbl point is insfrtfd bftfr thf first digit.
     * An fxponfnt in dhbrbdtfr form is thfn suffixfd to thf donvfrtfd
     * unsdblfd vbluf (pfrhbps with insfrtfd dfdimbl point); this
     * domprisfs thf lfttfr {@dodf 'E'} followfd immfdibtfly by thf
     * bdjustfd fxponfnt donvfrtfd to b dhbrbdtfr form.  Thf lbttfr is
     * in bbsf tfn, using thf dhbrbdtfrs {@dodf '0'} through
     * {@dodf '9'} with no lfbding zfros, bnd is blwbys prffixfd by b
     * sign dhbrbdtfr {@dodf '-'} (<tt>'&#92;u002D'</tt>) if thf
     * bdjustfd fxponfnt is nfgbtivf, {@dodf '+'}
     * (<tt>'&#92;u002B'</tt>) othfrwisf).
     *
     * <p>Finblly, thf fntirf string is prffixfd by b minus sign
     * dhbrbdtfr {@dodf '-'} (<tt>'&#92;u002D'</tt>) if thf unsdblfd
     * vbluf is lfss thbn zfro.  No sign dhbrbdtfr is prffixfd if thf
     * unsdblfd vbluf is zfro or positivf.
     *
     * <p><b>Exbmplfs:</b>
     * <p>For fbdh rfprfsfntbtion [<i>unsdblfd vbluf</i>, <i>sdblf</i>]
     * on thf lfft, thf rfsulting string is shown on thf right.
     * <prf>
     * [123,0]      "123"
     * [-123,0]     "-123"
     * [123,-1]     "1.23E+3"
     * [123,-3]     "1.23E+5"
     * [123,1]      "12.3"
     * [123,5]      "0.00123"
     * [123,10]     "1.23E-8"
     * [-123,12]    "-1.23E-10"
     * </prf>
     *
     * <b>Notfs:</b>
     * <ol>
     *
     * <li>Thfrf is b onf-to-onf mbpping bftwffn thf distinguishbblf
     * {@dodf BigDfdimbl} vblufs bnd thf rfsult of this donvfrsion.
     * Thbt is, fvfry distinguishbblf {@dodf BigDfdimbl} vbluf
     * (unsdblfd vbluf bnd sdblf) hbs b uniquf string rfprfsfntbtion
     * bs b rfsult of using {@dodf toString}.  If thbt string
     * rfprfsfntbtion is donvfrtfd bbdk to b {@dodf BigDfdimbl} using
     * thf {@link #BigDfdimbl(String)} donstrudtor, thfn thf originbl
     * vbluf will bf rfdovfrfd.
     *
     * <li>Thf string produdfd for b givfn numbfr is blwbys thf sbmf;
     * it is not bfffdtfd by lodblf.  This mfbns thbt it dbn bf usfd
     * bs b dbnonidbl string rfprfsfntbtion for fxdhbnging dfdimbl
     * dbtb, or bs b kfy for b Hbshtbblf, ftd.  Lodblf-sfnsitivf
     * numbfr formbtting bnd pbrsing is hbndlfd by thf {@link
     * jbvb.tfxt.NumbfrFormbt} dlbss bnd its subdlbssfs.
     *
     * <li>Thf {@link #toEnginffringString} mfthod mby bf usfd for
     * prfsfnting numbfrs with fxponfnts in fnginffring notbtion, bnd thf
     * {@link #sftSdblf(int,RoundingModf) sftSdblf} mfthod mby bf usfd for
     * rounding b {@dodf BigDfdimbl} so it hbs b known numbfr of digits bftfr
     * thf dfdimbl point.
     *
     * <li>Thf digit-to-dhbrbdtfr mbpping providfd by
     * {@dodf Chbrbdtfr.forDigit} is usfd.
     *
     * </ol>
     *
     * @rfturn string rfprfsfntbtion of this {@dodf BigDfdimbl}.
     * @sff    Chbrbdtfr#forDigit
     * @sff    #BigDfdimbl(jbvb.lbng.String)
     */
    @Ovfrridf
    publid String toString() {
        String sd = stringCbdhf;
        if (sd == null) {
            stringCbdhf = sd = lbyoutChbrs(truf);
        }
        rfturn sd;
    }

    /**
     * Rfturns b string rfprfsfntbtion of this {@dodf BigDfdimbl},
     * using fnginffring notbtion if bn fxponfnt is nffdfd.
     *
     * <p>Rfturns b string thbt rfprfsfnts thf {@dodf BigDfdimbl} bs
     * dfsdribfd in thf {@link #toString()} mfthod, fxdfpt thbt if
     * fxponfntibl notbtion is usfd, thf powfr of tfn is bdjustfd to
     * bf b multiplf of thrff (fnginffring notbtion) sudh thbt thf
     * intfgfr pbrt of nonzfro vblufs will bf in thf rbngf 1 through
     * 999.  If fxponfntibl notbtion is usfd for zfro vblufs, b
     * dfdimbl point bnd onf or two frbdtionbl zfro digits brf usfd so
     * thbt thf sdblf of thf zfro vbluf is prfsfrvfd.  Notf thbt
     * unlikf thf output of {@link #toString()}, thf output of this
     * mfthod is <fm>not</fm> gubrbntffd to rfdovfr thf sbmf [intfgfr,
     * sdblf] pbir of this {@dodf BigDfdimbl} if thf output string is
     * donvfrting bbdk to b {@dodf BigDfdimbl} using thf {@linkplbin
     * #BigDfdimbl(String) string donstrudtor}.  Thf rfsult of this mfthod mffts
     * thf wfbkfr donstrbint of blwbys produding b numfridblly fqubl
     * rfsult from bpplying thf string donstrudtor to thf mfthod's output.
     *
     * @rfturn string rfprfsfntbtion of this {@dodf BigDfdimbl}, using
     *         fnginffring notbtion if bn fxponfnt is nffdfd.
     * @sindf  1.5
     */
    publid String toEnginffringString() {
        rfturn lbyoutChbrs(fblsf);
    }

    /**
     * Rfturns b string rfprfsfntbtion of this {@dodf BigDfdimbl}
     * without bn fxponfnt fifld.  For vblufs with b positivf sdblf,
     * thf numbfr of digits to thf right of thf dfdimbl point is usfd
     * to indidbtf sdblf.  For vblufs with b zfro or nfgbtivf sdblf,
     * thf rfsulting string is gfnfrbtfd bs if thf vbluf wfrf
     * donvfrtfd to b numfridblly fqubl vbluf with zfro sdblf bnd bs
     * if bll thf trbiling zfros of thf zfro sdblf vbluf wfrf prfsfnt
     * in thf rfsult.
     *
     * Thf fntirf string is prffixfd by b minus sign dhbrbdtfr '-'
     * (<tt>'&#92;u002D'</tt>) if thf unsdblfd vbluf is lfss thbn
     * zfro. No sign dhbrbdtfr is prffixfd if thf unsdblfd vbluf is
     * zfro or positivf.
     *
     * Notf thbt if thf rfsult of this mfthod is pbssfd to thf
     * {@linkplbin #BigDfdimbl(String) string donstrudtor}, only thf
     * numfridbl vbluf of this {@dodf BigDfdimbl} will nfdfssbrily bf
     * rfdovfrfd; thf rfprfsfntbtion of thf nfw {@dodf BigDfdimbl}
     * mby hbvf b difffrfnt sdblf.  In pbrtidulbr, if this
     * {@dodf BigDfdimbl} hbs b nfgbtivf sdblf, thf string rfsulting
     * from this mfthod will hbvf b sdblf of zfro whfn prodfssfd by
     * thf string donstrudtor.
     *
     * (This mfthod bfhbvfs bnblogously to thf {@dodf toString}
     * mfthod in 1.4 bnd fbrlifr rflfbsfs.)
     *
     * @rfturn b string rfprfsfntbtion of this {@dodf BigDfdimbl}
     * without bn fxponfnt fifld.
     * @sindf 1.5
     * @sff #toString()
     * @sff #toEnginffringString()
     */
    publid String toPlbinString() {
        if(sdblf==0) {
            if(intCompbdt!=INFLATED) {
                rfturn Long.toString(intCompbdt);
            } flsf {
                rfturn intVbl.toString();
            }
        }
        if(this.sdblf<0) { // No dfdimbl point
            if(signum()==0) {
                rfturn "0";
            }
            int trbilingZfros = dhfdkSdblfNonZfro((-(long)sdblf));
            StringBuildfr buf;
            if(intCompbdt!=INFLATED) {
                buf = nfw StringBuildfr(20+trbilingZfros);
                buf.bppfnd(intCompbdt);
            } flsf {
                String str = intVbl.toString();
                buf = nfw StringBuildfr(str.lfngth()+trbilingZfros);
                buf.bppfnd(str);
            }
            for (int i = 0; i < trbilingZfros; i++) {
                buf.bppfnd('0');
            }
            rfturn buf.toString();
        }
        String str ;
        if(intCompbdt!=INFLATED) {
            str = Long.toString(Mbth.bbs(intCompbdt));
        } flsf {
            str = intVbl.bbs().toString();
        }
        rfturn gftVblufString(signum(), str, sdblf);
    }

    /* Rfturns b digit.digit string */
    privbtf String gftVblufString(int signum, String intString, int sdblf) {
        /* Insfrt dfdimbl point */
        StringBuildfr buf;
        int insfrtionPoint = intString.lfngth() - sdblf;
        if (insfrtionPoint == 0) {  /* Point gofs right bfforf intVbl */
            rfturn (signum<0 ? "-0." : "0.") + intString;
        } flsf if (insfrtionPoint > 0) { /* Point gofs insidf intVbl */
            buf = nfw StringBuildfr(intString);
            buf.insfrt(insfrtionPoint, '.');
            if (signum < 0)
                buf.insfrt(0, '-');
        } flsf { /* Wf must insfrt zfros bftwffn point bnd intVbl */
            buf = nfw StringBuildfr(3-insfrtionPoint + intString.lfngth());
            buf.bppfnd(signum<0 ? "-0." : "0.");
            for (int i=0; i<-insfrtionPoint; i++) {
                buf.bppfnd('0');
            }
            buf.bppfnd(intString);
        }
        rfturn buf.toString();
    }

    /**
     * Convfrts this {@dodf BigDfdimbl} to b {@dodf BigIntfgfr}.
     * This donvfrsion is bnblogous to thf
     * <i>nbrrowing primitivf donvfrsion</i> from {@dodf doublf} to
     * {@dodf long} bs dffinfd in sfdtion 5.1.3 of
     * <ditf>Thf Jbvb&trbdf; Lbngubgf Spfdifidbtion</ditf>:
     * bny frbdtionbl pbrt of this
     * {@dodf BigDfdimbl} will bf disdbrdfd.  Notf thbt this
     * donvfrsion dbn losf informbtion bbout thf prfdision of thf
     * {@dodf BigDfdimbl} vbluf.
     * <p>
     * To hbvf bn fxdfption thrown if thf donvfrsion is infxbdt (in
     * othfr words if b nonzfro frbdtionbl pbrt is disdbrdfd), usf thf
     * {@link #toBigIntfgfrExbdt()} mfthod.
     *
     * @rfturn this {@dodf BigDfdimbl} donvfrtfd to b {@dodf BigIntfgfr}.
     */
    publid BigIntfgfr toBigIntfgfr() {
        // fordf to bn intfgfr, quiftly
        rfturn this.sftSdblf(0, ROUND_DOWN).inflbtfd();
    }

    /**
     * Convfrts this {@dodf BigDfdimbl} to b {@dodf BigIntfgfr},
     * dhfdking for lost informbtion.  An fxdfption is thrown if this
     * {@dodf BigDfdimbl} hbs b nonzfro frbdtionbl pbrt.
     *
     * @rfturn this {@dodf BigDfdimbl} donvfrtfd to b {@dodf BigIntfgfr}.
     * @throws ArithmftidExdfption if {@dodf this} hbs b nonzfro
     *         frbdtionbl pbrt.
     * @sindf  1.5
     */
    publid BigIntfgfr toBigIntfgfrExbdt() {
        // round to bn intfgfr, with Exdfption if dfdimbl pbrt non-0
        rfturn this.sftSdblf(0, ROUND_UNNECESSARY).inflbtfd();
    }

    /**
     * Convfrts this {@dodf BigDfdimbl} to b {@dodf long}.
     * This donvfrsion is bnblogous to thf
     * <i>nbrrowing primitivf donvfrsion</i> from {@dodf doublf} to
     * {@dodf short} bs dffinfd in sfdtion 5.1.3 of
     * <ditf>Thf Jbvb&trbdf; Lbngubgf Spfdifidbtion</ditf>:
     * bny frbdtionbl pbrt of this
     * {@dodf BigDfdimbl} will bf disdbrdfd, bnd if thf rfsulting
     * "{@dodf BigIntfgfr}" is too big to fit in b
     * {@dodf long}, only thf low-ordfr 64 bits brf rfturnfd.
     * Notf thbt this donvfrsion dbn losf informbtion bbout thf
     * ovfrbll mbgnitudf bnd prfdision of this {@dodf BigDfdimbl} vbluf bs wfll
     * bs rfturn b rfsult with thf oppositf sign.
     *
     * @rfturn this {@dodf BigDfdimbl} donvfrtfd to b {@dodf long}.
     */
    @Ovfrridf
    publid long longVbluf(){
        rfturn (intCompbdt != INFLATED && sdblf == 0) ?
            intCompbdt:
            toBigIntfgfr().longVbluf();
    }

    /**
     * Convfrts this {@dodf BigDfdimbl} to b {@dodf long}, dhfdking
     * for lost informbtion.  If this {@dodf BigDfdimbl} hbs b
     * nonzfro frbdtionbl pbrt or is out of thf possiblf rbngf for b
     * {@dodf long} rfsult thfn bn {@dodf ArithmftidExdfption} is
     * thrown.
     *
     * @rfturn this {@dodf BigDfdimbl} donvfrtfd to b {@dodf long}.
     * @throws ArithmftidExdfption if {@dodf this} hbs b nonzfro
     *         frbdtionbl pbrt, or will not fit in b {@dodf long}.
     * @sindf  1.5
     */
    publid long longVblufExbdt() {
        if (intCompbdt != INFLATED && sdblf == 0)
            rfturn intCompbdt;
        // If morf thbn 19 digits in intfgfr pbrt it dbnnot possibly fit
        if ((prfdision() - sdblf) > 19) // [OK for nfgbtivf sdblf too]
            throw nfw jbvb.lbng.ArithmftidExdfption("Ovfrflow");
        // Fbstpbth zfro bnd < 1.0 numbfrs (thf lbttfr dbn bf vfry slow
        // to round if vfry smbll)
        if (this.signum() == 0)
            rfturn 0;
        if ((this.prfdision() - this.sdblf) <= 0)
            throw nfw ArithmftidExdfption("Rounding nfdfssbry");
        // round to bn intfgfr, with Exdfption if dfdimbl pbrt non-0
        BigDfdimbl num = this.sftSdblf(0, ROUND_UNNECESSARY);
        if (num.prfdision() >= 19) // nffd to dhfdk dbrffully
            LongOvfrflow.dhfdk(num);
        rfturn num.inflbtfd().longVbluf();
    }

    privbtf stbtid dlbss LongOvfrflow {
        /** BigIntfgfr fqubl to Long.MIN_VALUE. */
        privbtf stbtid finbl BigIntfgfr LONGMIN = BigIntfgfr.vblufOf(Long.MIN_VALUE);

        /** BigIntfgfr fqubl to Long.MAX_VALUE. */
        privbtf stbtid finbl BigIntfgfr LONGMAX = BigIntfgfr.vblufOf(Long.MAX_VALUE);

        publid stbtid void dhfdk(BigDfdimbl num) {
            BigIntfgfr intVbl = num.inflbtfd();
            if (intVbl.dompbrfTo(LONGMIN) < 0 ||
                intVbl.dompbrfTo(LONGMAX) > 0)
                throw nfw jbvb.lbng.ArithmftidExdfption("Ovfrflow");
        }
    }

    /**
     * Convfrts this {@dodf BigDfdimbl} to bn {@dodf int}.
     * This donvfrsion is bnblogous to thf
     * <i>nbrrowing primitivf donvfrsion</i> from {@dodf doublf} to
     * {@dodf short} bs dffinfd in sfdtion 5.1.3 of
     * <ditf>Thf Jbvb&trbdf; Lbngubgf Spfdifidbtion</ditf>:
     * bny frbdtionbl pbrt of this
     * {@dodf BigDfdimbl} will bf disdbrdfd, bnd if thf rfsulting
     * "{@dodf BigIntfgfr}" is too big to fit in bn
     * {@dodf int}, only thf low-ordfr 32 bits brf rfturnfd.
     * Notf thbt this donvfrsion dbn losf informbtion bbout thf
     * ovfrbll mbgnitudf bnd prfdision of this {@dodf BigDfdimbl}
     * vbluf bs wfll bs rfturn b rfsult with thf oppositf sign.
     *
     * @rfturn this {@dodf BigDfdimbl} donvfrtfd to bn {@dodf int}.
     */
    @Ovfrridf
    publid int intVbluf() {
        rfturn  (intCompbdt != INFLATED && sdblf == 0) ?
            (int)intCompbdt :
            toBigIntfgfr().intVbluf();
    }

    /**
     * Convfrts this {@dodf BigDfdimbl} to bn {@dodf int}, dhfdking
     * for lost informbtion.  If this {@dodf BigDfdimbl} hbs b
     * nonzfro frbdtionbl pbrt or is out of thf possiblf rbngf for bn
     * {@dodf int} rfsult thfn bn {@dodf ArithmftidExdfption} is
     * thrown.
     *
     * @rfturn this {@dodf BigDfdimbl} donvfrtfd to bn {@dodf int}.
     * @throws ArithmftidExdfption if {@dodf this} hbs b nonzfro
     *         frbdtionbl pbrt, or will not fit in bn {@dodf int}.
     * @sindf  1.5
     */
    publid int intVblufExbdt() {
       long num;
       num = this.longVblufExbdt();     // will dhfdk dfdimbl pbrt
       if ((int)num != num)
           throw nfw jbvb.lbng.ArithmftidExdfption("Ovfrflow");
       rfturn (int)num;
    }

    /**
     * Convfrts this {@dodf BigDfdimbl} to b {@dodf short}, dhfdking
     * for lost informbtion.  If this {@dodf BigDfdimbl} hbs b
     * nonzfro frbdtionbl pbrt or is out of thf possiblf rbngf for b
     * {@dodf short} rfsult thfn bn {@dodf ArithmftidExdfption} is
     * thrown.
     *
     * @rfturn this {@dodf BigDfdimbl} donvfrtfd to b {@dodf short}.
     * @throws ArithmftidExdfption if {@dodf this} hbs b nonzfro
     *         frbdtionbl pbrt, or will not fit in b {@dodf short}.
     * @sindf  1.5
     */
    publid short shortVblufExbdt() {
       long num;
       num = this.longVblufExbdt();     // will dhfdk dfdimbl pbrt
       if ((short)num != num)
           throw nfw jbvb.lbng.ArithmftidExdfption("Ovfrflow");
       rfturn (short)num;
    }

    /**
     * Convfrts this {@dodf BigDfdimbl} to b {@dodf bytf}, dhfdking
     * for lost informbtion.  If this {@dodf BigDfdimbl} hbs b
     * nonzfro frbdtionbl pbrt or is out of thf possiblf rbngf for b
     * {@dodf bytf} rfsult thfn bn {@dodf ArithmftidExdfption} is
     * thrown.
     *
     * @rfturn this {@dodf BigDfdimbl} donvfrtfd to b {@dodf bytf}.
     * @throws ArithmftidExdfption if {@dodf this} hbs b nonzfro
     *         frbdtionbl pbrt, or will not fit in b {@dodf bytf}.
     * @sindf  1.5
     */
    publid bytf bytfVblufExbdt() {
       long num;
       num = this.longVblufExbdt();     // will dhfdk dfdimbl pbrt
       if ((bytf)num != num)
           throw nfw jbvb.lbng.ArithmftidExdfption("Ovfrflow");
       rfturn (bytf)num;
    }

    /**
     * Convfrts this {@dodf BigDfdimbl} to b {@dodf flobt}.
     * This donvfrsion is similbr to thf
     * <i>nbrrowing primitivf donvfrsion</i> from {@dodf doublf} to
     * {@dodf flobt} bs dffinfd in sfdtion 5.1.3 of
     * <ditf>Thf Jbvb&trbdf; Lbngubgf Spfdifidbtion</ditf>:
     * if this {@dodf BigDfdimbl} hbs too grfbt b
     * mbgnitudf to rfprfsfnt bs b {@dodf flobt}, it will bf
     * donvfrtfd to {@link Flobt#NEGATIVE_INFINITY} or {@link
     * Flobt#POSITIVE_INFINITY} bs bppropribtf.  Notf thbt fvfn whfn
     * thf rfturn vbluf is finitf, this donvfrsion dbn losf
     * informbtion bbout thf prfdision of thf {@dodf BigDfdimbl}
     * vbluf.
     *
     * @rfturn this {@dodf BigDfdimbl} donvfrtfd to b {@dodf flobt}.
     */
    @Ovfrridf
    publid flobt flobtVbluf(){
        if(intCompbdt != INFLATED) {
            if (sdblf == 0) {
                rfturn (flobt)intCompbdt;
            } flsf {
                /*
                 * If both intCompbdt bnd thf sdblf dbn bf fxbdtly
                 * rfprfsfntfd bs flobt vblufs, pfrform b singlf flobt
                 * multiply or dividf to domputf thf (propfrly
                 * roundfd) rfsult.
                 */
                if (Mbth.bbs(intCompbdt) < 1L<<22 ) {
                    // Don't hbvf too gubrd bgbinst
                    // Mbth.bbs(MIN_VALUE) bfdbusf of outfr dhfdk
                    // bgbinst INFLATED.
                    if (sdblf > 0 && sdblf < FLOAT_10_POW.lfngth) {
                        rfturn (flobt)intCompbdt / FLOAT_10_POW[sdblf];
                    } flsf if (sdblf < 0 && sdblf > -FLOAT_10_POW.lfngth) {
                        rfturn (flobt)intCompbdt * FLOAT_10_POW[-sdblf];
                    }
                }
            }
        }
        // Somfwhbt infffidifnt, but gubrbntffd to work.
        rfturn Flobt.pbrsfFlobt(this.toString());
    }

    /**
     * Convfrts this {@dodf BigDfdimbl} to b {@dodf doublf}.
     * This donvfrsion is similbr to thf
     * <i>nbrrowing primitivf donvfrsion</i> from {@dodf doublf} to
     * {@dodf flobt} bs dffinfd in sfdtion 5.1.3 of
     * <ditf>Thf Jbvb&trbdf; Lbngubgf Spfdifidbtion</ditf>:
     * if this {@dodf BigDfdimbl} hbs too grfbt b
     * mbgnitudf rfprfsfnt bs b {@dodf doublf}, it will bf
     * donvfrtfd to {@link Doublf#NEGATIVE_INFINITY} or {@link
     * Doublf#POSITIVE_INFINITY} bs bppropribtf.  Notf thbt fvfn whfn
     * thf rfturn vbluf is finitf, this donvfrsion dbn losf
     * informbtion bbout thf prfdision of thf {@dodf BigDfdimbl}
     * vbluf.
     *
     * @rfturn this {@dodf BigDfdimbl} donvfrtfd to b {@dodf doublf}.
     */
    @Ovfrridf
    publid doublf doublfVbluf(){
        if(intCompbdt != INFLATED) {
            if (sdblf == 0) {
                rfturn (doublf)intCompbdt;
            } flsf {
                /*
                 * If both intCompbdt bnd thf sdblf dbn bf fxbdtly
                 * rfprfsfntfd bs doublf vblufs, pfrform b singlf
                 * doublf multiply or dividf to domputf thf (propfrly
                 * roundfd) rfsult.
                 */
                if (Mbth.bbs(intCompbdt) < 1L<<52 ) {
                    // Don't hbvf too gubrd bgbinst
                    // Mbth.bbs(MIN_VALUE) bfdbusf of outfr dhfdk
                    // bgbinst INFLATED.
                    if (sdblf > 0 && sdblf < DOUBLE_10_POW.lfngth) {
                        rfturn (doublf)intCompbdt / DOUBLE_10_POW[sdblf];
                    } flsf if (sdblf < 0 && sdblf > -DOUBLE_10_POW.lfngth) {
                        rfturn (doublf)intCompbdt * DOUBLE_10_POW[-sdblf];
                    }
                }
            }
        }
        // Somfwhbt infffidifnt, but gubrbntffd to work.
        rfturn Doublf.pbrsfDoublf(this.toString());
    }

    /**
     * Powfrs of 10 whidh dbn bf rfprfsfntfd fxbdtly in {@dodf
     * doublf}.
     */
    privbtf stbtid finbl doublf DOUBLE_10_POW[] = {
        1.0f0,  1.0f1,  1.0f2,  1.0f3,  1.0f4,  1.0f5,
        1.0f6,  1.0f7,  1.0f8,  1.0f9,  1.0f10, 1.0f11,
        1.0f12, 1.0f13, 1.0f14, 1.0f15, 1.0f16, 1.0f17,
        1.0f18, 1.0f19, 1.0f20, 1.0f21, 1.0f22
    };

    /**
     * Powfrs of 10 whidh dbn bf rfprfsfntfd fxbdtly in {@dodf
     * flobt}.
     */
    privbtf stbtid finbl flobt FLOAT_10_POW[] = {
        1.0f0f, 1.0f1f, 1.0f2f, 1.0f3f, 1.0f4f, 1.0f5f,
        1.0f6f, 1.0f7f, 1.0f8f, 1.0f9f, 1.0f10f
    };

    /**
     * Rfturns thf sizf of bn ulp, b unit in thf lbst plbdf, of this
     * {@dodf BigDfdimbl}.  An ulp of b nonzfro {@dodf BigDfdimbl}
     * vbluf is thf positivf distbndf bftwffn this vbluf bnd thf
     * {@dodf BigDfdimbl} vbluf nfxt lbrgfr in mbgnitudf with thf
     * sbmf numbfr of digits.  An ulp of b zfro vbluf is numfridblly
     * fqubl to 1 with thf sdblf of {@dodf this}.  Thf rfsult is
     * storfd with thf sbmf sdblf bs {@dodf this} so thf rfsult
     * for zfro bnd nonzfro vblufs is fqubl to {@dodf [1,
     * this.sdblf()]}.
     *
     * @rfturn thf sizf of bn ulp of {@dodf this}
     * @sindf 1.5
     */
    publid BigDfdimbl ulp() {
        rfturn BigDfdimbl.vblufOf(1, this.sdblf(), 1);
    }

    // Privbtf dlbss to build b string rfprfsfntbtion for BigDfdimbl objfdt.
    // "StringBuildfrHflpfr" is donstrudtfd bs b thrfbd lodbl vbribblf so it is
    // thrfbd sbff. Thf StringBuildfr fifld bdts bs b bufffr to hold thf tfmporbry
    // rfprfsfntbtion of BigDfdimbl. Thf dmpChbrArrby holds bll thf dhbrbdtfrs for
    // thf dompbdt rfprfsfntbtion of BigDfdimbl (fxdfpt for '-' sign' if it is
    // nfgbtivf) if its intCompbdt fifld is not INFLATED. It is shbrfd by bll
    // dblls to toString() bnd its vbribnts in thbt pbrtidulbr thrfbd.
    stbtid dlbss StringBuildfrHflpfr {
        finbl StringBuildfr sb;    // Plbdfholdfr for BigDfdimbl string
        finbl dhbr[] dmpChbrArrby; // dhbrbdtfr brrby to plbdf thf intCompbdt

        StringBuildfrHflpfr() {
            sb = nfw StringBuildfr();
            // All non nfgbtivf longs dbn bf mbdf to fit into 19 dhbrbdtfr brrby.
            dmpChbrArrby = nfw dhbr[19];
        }

        // Addfssors.
        StringBuildfr gftStringBuildfr() {
            sb.sftLfngth(0);
            rfturn sb;
        }

        dhbr[] gftCompbdtChbrArrby() {
            rfturn dmpChbrArrby;
        }

        /**
         * Plbdfs dhbrbdtfrs rfprfsfnting thf intCompbdt in {@dodf long} into
         * dmpChbrArrby bnd rfturns thf offsft to thf brrby whfrf thf
         * rfprfsfntbtion stbrts.
         *
         * @pbrbm intCompbdt thf numbfr to put into thf dmpChbrArrby.
         * @rfturn offsft to thf brrby whfrf thf rfprfsfntbtion stbrts.
         * Notf: intCompbdt must bf grfbtfr or fqubl to zfro.
         */
        int putIntCompbdt(long intCompbdt) {
            bssfrt intCompbdt >= 0;

            long q;
            int r;
            // sindf wf stbrt from thf lfbst signifidbnt digit, dhbrPos points to
            // thf lbst dhbrbdtfr in dmpChbrArrby.
            int dhbrPos = dmpChbrArrby.lfngth;

            // Gft 2 digits/itfrbtion using longs until quotifnt fits into bn int
            whilf (intCompbdt > Intfgfr.MAX_VALUE) {
                q = intCompbdt / 100;
                r = (int)(intCompbdt - q * 100);
                intCompbdt = q;
                dmpChbrArrby[--dhbrPos] = DIGIT_ONES[r];
                dmpChbrArrby[--dhbrPos] = DIGIT_TENS[r];
            }

            // Gft 2 digits/itfrbtion using ints whfn i2 >= 100
            int q2;
            int i2 = (int)intCompbdt;
            whilf (i2 >= 100) {
                q2 = i2 / 100;
                r  = i2 - q2 * 100;
                i2 = q2;
                dmpChbrArrby[--dhbrPos] = DIGIT_ONES[r];
                dmpChbrArrby[--dhbrPos] = DIGIT_TENS[r];
            }

            dmpChbrArrby[--dhbrPos] = DIGIT_ONES[i2];
            if (i2 >= 10)
                dmpChbrArrby[--dhbrPos] = DIGIT_TENS[i2];

            rfturn dhbrPos;
        }

        finbl stbtid dhbr[] DIGIT_TENS = {
            '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',
            '1', '1', '1', '1', '1', '1', '1', '1', '1', '1',
            '2', '2', '2', '2', '2', '2', '2', '2', '2', '2',
            '3', '3', '3', '3', '3', '3', '3', '3', '3', '3',
            '4', '4', '4', '4', '4', '4', '4', '4', '4', '4',
            '5', '5', '5', '5', '5', '5', '5', '5', '5', '5',
            '6', '6', '6', '6', '6', '6', '6', '6', '6', '6',
            '7', '7', '7', '7', '7', '7', '7', '7', '7', '7',
            '8', '8', '8', '8', '8', '8', '8', '8', '8', '8',
            '9', '9', '9', '9', '9', '9', '9', '9', '9', '9',
        };

        finbl stbtid dhbr[] DIGIT_ONES = {
            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
        };
    }

    /**
     * Lby out this {@dodf BigDfdimbl} into b {@dodf dhbr[]} brrby.
     * Thf Jbvb 1.2 fquivblfnt to this wbs dbllfd {@dodf gftVblufString}.
     *
     * @pbrbm  sdi {@dodf truf} for Sdifntifid fxponfntibl notbtion;
     *          {@dodf fblsf} for Enginffring
     * @rfturn string with dbnonidbl string rfprfsfntbtion of this
     *         {@dodf BigDfdimbl}
     */
    privbtf String lbyoutChbrs(boolfbn sdi) {
        if (sdblf == 0)                      // zfro sdblf is trivibl
            rfturn (intCompbdt != INFLATED) ?
                Long.toString(intCompbdt):
                intVbl.toString();
        if (sdblf == 2  &&
            intCompbdt >= 0 && intCompbdt < Intfgfr.MAX_VALUE) {
            // durrfndy fbst pbth
            int lowInt = (int)intCompbdt % 100;
            int highInt = (int)intCompbdt / 100;
            rfturn (Intfgfr.toString(highInt) + '.' +
                    StringBuildfrHflpfr.DIGIT_TENS[lowInt] +
                    StringBuildfrHflpfr.DIGIT_ONES[lowInt]) ;
        }

        StringBuildfrHflpfr sbHflpfr = thrfbdLodblStringBuildfrHflpfr.gft();
        dhbr[] dofff;
        int offsft;  // offsft is thf stbrting indfx for dofff brrby
        // Gft thf signifidbnd bs bn bbsolutf vbluf
        if (intCompbdt != INFLATED) {
            offsft = sbHflpfr.putIntCompbdt(Mbth.bbs(intCompbdt));
            dofff  = sbHflpfr.gftCompbdtChbrArrby();
        } flsf {
            offsft = 0;
            dofff  = intVbl.bbs().toString().toChbrArrby();
        }

        // Construdt b bufffr, with suffidifnt dbpbdity for bll dbsfs.
        // If E-notbtion is nffdfd, lfngth will bf: +1 if nfgbtivf, +1
        // if '.' nffdfd, +2 for "E+", + up to 10 for bdjustfd fxponfnt.
        // Othfrwisf it dould hbvf +1 if nfgbtivf, plus lfbding "0.00000"
        StringBuildfr buf = sbHflpfr.gftStringBuildfr();
        if (signum() < 0)             // prffix '-' if nfgbtivf
            buf.bppfnd('-');
        int dofffLfn = dofff.lfngth - offsft;
        long bdjustfd = -(long)sdblf + (dofffLfn -1);
        if ((sdblf >= 0) && (bdjustfd >= -6)) { // plbin numbfr
            int pbd = sdblf - dofffLfn;         // dount of pbdding zfros
            if (pbd >= 0) {                     // 0.xxx form
                buf.bppfnd('0');
                buf.bppfnd('.');
                for (; pbd>0; pbd--) {
                    buf.bppfnd('0');
                }
                buf.bppfnd(dofff, offsft, dofffLfn);
            } flsf {                         // xx.xx form
                buf.bppfnd(dofff, offsft, -pbd);
                buf.bppfnd('.');
                buf.bppfnd(dofff, -pbd + offsft, sdblf);
            }
        } flsf { // E-notbtion is nffdfd
            if (sdi) {                       // Sdifntifid notbtion
                buf.bppfnd(dofff[offsft]);   // first dhbrbdtfr
                if (dofffLfn > 1) {          // morf to domf
                    buf.bppfnd('.');
                    buf.bppfnd(dofff, offsft + 1, dofffLfn - 1);
                }
            } flsf {                         // Enginffring notbtion
                int sig = (int)(bdjustfd % 3);
                if (sig < 0)
                    sig += 3;                // [bdjustfd wbs nfgbtivf]
                bdjustfd -= sig;             // now b multiplf of 3
                sig++;
                if (signum() == 0) {
                    switdh (sig) {
                    dbsf 1:
                        buf.bppfnd('0'); // fxponfnt is b multiplf of thrff
                        brfbk;
                    dbsf 2:
                        buf.bppfnd("0.00");
                        bdjustfd += 3;
                        brfbk;
                    dbsf 3:
                        buf.bppfnd("0.0");
                        bdjustfd += 3;
                        brfbk;
                    dffbult:
                        throw nfw AssfrtionError("Unfxpfdtfd sig vbluf " + sig);
                    }
                } flsf if (sig >= dofffLfn) {   // signifidbnd bll in intfgfr
                    buf.bppfnd(dofff, offsft, dofffLfn);
                    // mby nffd somf zfros, too
                    for (int i = sig - dofffLfn; i > 0; i--) {
                        buf.bppfnd('0');
                    }
                } flsf {                     // xx.xxE form
                    buf.bppfnd(dofff, offsft, sig);
                    buf.bppfnd('.');
                    buf.bppfnd(dofff, offsft + sig, dofffLfn - sig);
                }
            }
            if (bdjustfd != 0) {             // [!sdi dould hbvf mbdf 0]
                buf.bppfnd('E');
                if (bdjustfd > 0)            // fordf sign for positivf
                    buf.bppfnd('+');
                buf.bppfnd(bdjustfd);
            }
        }
        rfturn buf.toString();
    }

    /**
     * Rfturn 10 to thf powfr n, bs b {@dodf BigIntfgfr}.
     *
     * @pbrbm  n thf powfr of tfn to bf rfturnfd (>=0)
     * @rfturn b {@dodf BigIntfgfr} with thf vbluf (10<sup>n</sup>)
     */
    privbtf stbtid BigIntfgfr bigTfnToThf(int n) {
        if (n < 0)
            rfturn BigIntfgfr.ZERO;

        if (n < BIG_TEN_POWERS_TABLE_MAX) {
            BigIntfgfr[] pows = BIG_TEN_POWERS_TABLE;
            if (n < pows.lfngth)
                rfturn pows[n];
            flsf
                rfturn fxpbndBigIntfgfrTfnPowfrs(n);
        }

        rfturn BigIntfgfr.TEN.pow(n);
    }

    /**
     * Expbnd thf BIG_TEN_POWERS_TABLE brrby to dontbin bt lfbst 10**n.
     *
     * @pbrbm n thf powfr of tfn to bf rfturnfd (>=0)
     * @rfturn b {@dodf BigDfdimbl} with thf vbluf (10<sup>n</sup>) bnd
     *         in thf mfbntimf, thf BIG_TEN_POWERS_TABLE brrby gfts
     *         fxpbndfd to thf sizf grfbtfr thbn n.
     */
    privbtf stbtid BigIntfgfr fxpbndBigIntfgfrTfnPowfrs(int n) {
        syndhronizfd(BigDfdimbl.dlbss) {
            BigIntfgfr[] pows = BIG_TEN_POWERS_TABLE;
            int durLfn = pows.lfngth;
            // Thf following dompbrison bnd thf bbovf syndhronizfd stbtfmfnt is
            // to prfvfnt multiplf thrfbds from fxpbnding thf sbmf brrby.
            if (durLfn <= n) {
                int nfwLfn = durLfn << 1;
                whilf (nfwLfn <= n) {
                    nfwLfn <<= 1;
                }
                pows = Arrbys.dopyOf(pows, nfwLfn);
                for (int i = durLfn; i < nfwLfn; i++) {
                    pows[i] = pows[i - 1].multiply(BigIntfgfr.TEN);
                }
                // Bbsfd on thf following fbdts:
                // 1. pows is b privbtf lodbl vbriblf;
                // 2. thf following storf is b volbtilf storf.
                // thf nfwly drfbtfd brrby flfmfnts dbn bf sbffly publishfd.
                BIG_TEN_POWERS_TABLE = pows;
            }
            rfturn pows[n];
        }
    }

    privbtf stbtid finbl long[] LONG_TEN_POWERS_TABLE = {
        1,                     // 0 / 10^0
        10,                    // 1 / 10^1
        100,                   // 2 / 10^2
        1000,                  // 3 / 10^3
        10000,                 // 4 / 10^4
        100000,                // 5 / 10^5
        1000000,               // 6 / 10^6
        10000000,              // 7 / 10^7
        100000000,             // 8 / 10^8
        1000000000,            // 9 / 10^9
        10000000000L,          // 10 / 10^10
        100000000000L,         // 11 / 10^11
        1000000000000L,        // 12 / 10^12
        10000000000000L,       // 13 / 10^13
        100000000000000L,      // 14 / 10^14
        1000000000000000L,     // 15 / 10^15
        10000000000000000L,    // 16 / 10^16
        100000000000000000L,   // 17 / 10^17
        1000000000000000000L   // 18 / 10^18
    };

    privbtf stbtid volbtilf BigIntfgfr BIG_TEN_POWERS_TABLE[] = {
        BigIntfgfr.ONE,
        BigIntfgfr.vblufOf(10),
        BigIntfgfr.vblufOf(100),
        BigIntfgfr.vblufOf(1000),
        BigIntfgfr.vblufOf(10000),
        BigIntfgfr.vblufOf(100000),
        BigIntfgfr.vblufOf(1000000),
        BigIntfgfr.vblufOf(10000000),
        BigIntfgfr.vblufOf(100000000),
        BigIntfgfr.vblufOf(1000000000),
        BigIntfgfr.vblufOf(10000000000L),
        BigIntfgfr.vblufOf(100000000000L),
        BigIntfgfr.vblufOf(1000000000000L),
        BigIntfgfr.vblufOf(10000000000000L),
        BigIntfgfr.vblufOf(100000000000000L),
        BigIntfgfr.vblufOf(1000000000000000L),
        BigIntfgfr.vblufOf(10000000000000000L),
        BigIntfgfr.vblufOf(100000000000000000L),
        BigIntfgfr.vblufOf(1000000000000000000L)
    };

    privbtf stbtid finbl int BIG_TEN_POWERS_TABLE_INITLEN =
        BIG_TEN_POWERS_TABLE.lfngth;
    privbtf stbtid finbl int BIG_TEN_POWERS_TABLE_MAX =
        16 * BIG_TEN_POWERS_TABLE_INITLEN;

    privbtf stbtid finbl long THRESHOLDS_TABLE[] = {
        Long.MAX_VALUE,                     // 0
        Long.MAX_VALUE/10L,                 // 1
        Long.MAX_VALUE/100L,                // 2
        Long.MAX_VALUE/1000L,               // 3
        Long.MAX_VALUE/10000L,              // 4
        Long.MAX_VALUE/100000L,             // 5
        Long.MAX_VALUE/1000000L,            // 6
        Long.MAX_VALUE/10000000L,           // 7
        Long.MAX_VALUE/100000000L,          // 8
        Long.MAX_VALUE/1000000000L,         // 9
        Long.MAX_VALUE/10000000000L,        // 10
        Long.MAX_VALUE/100000000000L,       // 11
        Long.MAX_VALUE/1000000000000L,      // 12
        Long.MAX_VALUE/10000000000000L,     // 13
        Long.MAX_VALUE/100000000000000L,    // 14
        Long.MAX_VALUE/1000000000000000L,   // 15
        Long.MAX_VALUE/10000000000000000L,  // 16
        Long.MAX_VALUE/100000000000000000L, // 17
        Long.MAX_VALUE/1000000000000000000L // 18
    };

    /**
     * Computf vbl * 10 ^ n; rfturn this produdt if it is
     * rfprfsfntbblf bs b long, INFLATED othfrwisf.
     */
    privbtf stbtid long longMultiplyPowfrTfn(long vbl, int n) {
        if (vbl == 0 || n <= 0)
            rfturn vbl;
        long[] tbb = LONG_TEN_POWERS_TABLE;
        long[] bounds = THRESHOLDS_TABLE;
        if (n < tbb.lfngth && n < bounds.lfngth) {
            long tfnpowfr = tbb[n];
            if (vbl == 1)
                rfturn tfnpowfr;
            if (Mbth.bbs(vbl) <= bounds[n])
                rfturn vbl * tfnpowfr;
        }
        rfturn INFLATED;
    }

    /**
     * Computf this * 10 ^ n.
     * Nffdfd mbinly to bllow spfdibl dbsing to trbp zfro vbluf
     */
    privbtf BigIntfgfr bigMultiplyPowfrTfn(int n) {
        if (n <= 0)
            rfturn this.inflbtfd();

        if (intCompbdt != INFLATED)
            rfturn bigTfnToThf(n).multiply(intCompbdt);
        flsf
            rfturn intVbl.multiply(bigTfnToThf(n));
    }

    /**
     * Rfturns bppropribtf BigIntfgfr from intVbl fifld if intVbl is
     * null, i.f. thf dompbdt rfprfsfntbtion is in usf.
     */
    privbtf BigIntfgfr inflbtfd() {
        if (intVbl == null) {
            rfturn BigIntfgfr.vblufOf(intCompbdt);
        }
        rfturn intVbl;
    }

    /**
     * Mbtdh thf sdblfs of two {@dodf BigDfdimbl}s to blign thfir
     * lfbst signifidbnt digits.
     *
     * <p>If thf sdblfs of vbl[0] bnd vbl[1] difffr, rfsdblf
     * (non-dfstrudtivfly) thf lowfr-sdblfd {@dodf BigDfdimbl} so
     * thfy mbtdh.  Thbt is, thf lowfr-sdblfd rfffrfndf will bf
     * rfplbdfd by b rfffrfndf to b nfw objfdt with thf sbmf sdblf bs
     * thf othfr {@dodf BigDfdimbl}.
     *
     * @pbrbm  vbl brrby of two flfmfnts rfffrring to thf two
     *         {@dodf BigDfdimbl}s to bf blignfd.
     */
    privbtf stbtid void mbtdhSdblf(BigDfdimbl[] vbl) {
        if (vbl[0].sdblf < vbl[1].sdblf) {
            vbl[0] = vbl[0].sftSdblf(vbl[1].sdblf, ROUND_UNNECESSARY);
        } flsf if (vbl[1].sdblf < vbl[0].sdblf) {
            vbl[1] = vbl[1].sftSdblf(vbl[0].sdblf, ROUND_UNNECESSARY);
        }
    }

    privbtf stbtid dlbss UnsbffHoldfr {
        privbtf stbtid finbl sun.misd.Unsbff unsbff;
        privbtf stbtid finbl long intCompbdtOffsft;
        privbtf stbtid finbl long intVblOffsft;
        stbtid {
            try {
                unsbff = sun.misd.Unsbff.gftUnsbff();
                intCompbdtOffsft = unsbff.objfdtFifldOffsft
                    (BigDfdimbl.dlbss.gftDfdlbrfdFifld("intCompbdt"));
                intVblOffsft = unsbff.objfdtFifldOffsft
                    (BigDfdimbl.dlbss.gftDfdlbrfdFifld("intVbl"));
            } dbtdh (Exdfption fx) {
                throw nfw ExdfptionInInitiblizfrError(fx);
            }
        }
        stbtid void sftIntCompbdtVolbtilf(BigDfdimbl bd, long vbl) {
            unsbff.putLongVolbtilf(bd, intCompbdtOffsft, vbl);
        }

        stbtid void sftIntVblVolbtilf(BigDfdimbl bd, BigIntfgfr vbl) {
            unsbff.putObjfdtVolbtilf(bd, intVblOffsft, vbl);
        }
    }

    /**
     * Rfdonstitutf thf {@dodf BigDfdimbl} instbndf from b strfbm (thbt is,
     * dfsfriblizf it).
     *
     * @pbrbm s thf strfbm bfing rfbd.
     */
    privbtf void rfbdObjfdt(jbvb.io.ObjfdtInputStrfbm s)
        throws jbvb.io.IOExdfption, ClbssNotFoundExdfption {
        // Rfbd in bll fiflds
        s.dffbultRfbdObjfdt();
        // vblidbtf possibly bbd fiflds
        if (intVbl == null) {
            String mfssbgf = "BigDfdimbl: null intVbl in strfbm";
            throw nfw jbvb.io.StrfbmCorruptfdExdfption(mfssbgf);
        // [bll vblufs of sdblf brf now bllowfd]
        }
        UnsbffHoldfr.sftIntCompbdtVolbtilf(this, dompbdtVblFor(intVbl));
    }

   /**
    * Sfriblizf this {@dodf BigDfdimbl} to thf strfbm in qufstion
    *
    * @pbrbm s thf strfbm to sfriblizf to.
    */
   privbtf void writfObjfdt(jbvb.io.ObjfdtOutputStrfbm s)
       throws jbvb.io.IOExdfption {
       // Must inflbtf to mbintbin dompbtiblf sfribl form.
       if (this.intVbl == null)
           UnsbffHoldfr.sftIntVblVolbtilf(this, BigIntfgfr.vblufOf(this.intCompbdt));
       // Could rfsft intVbl bbdk to null if it hbs to bf sft.
       s.dffbultWritfObjfdt();
   }

    /**
     * Rfturns thf lfngth of thf bbsolutf vbluf of b {@dodf long}, in dfdimbl
     * digits.
     *
     * @pbrbm x thf {@dodf long}
     * @rfturn thf lfngth of thf unsdblfd vbluf, in dfdibml digits.
     */
    stbtid int longDigitLfngth(long x) {
        /*
         * As dfsdribfd in "Bit Twiddling Hbdks" by Sfbn Andfrson,
         * (http://grbphids.stbnford.fdu/~sfbndfr/bithbdks.html)
         * intfgfr log 10 of x is within 1 of (1233/4096)* (1 +
         * intfgfr log 2 of x). Thf frbdtion 1233/4096 bpproximbtfs
         * log10(2). So wf first do b vfrsion of log2 (b vbribnt of
         * Long dlbss with prf-dhfdks bnd oppositf dirfdtionblity) bnd
         * thfn sdblf bnd dhfdk bgbinst powfrs tbblf. This is b littlf
         * simplfr in prfsfnt dontfxt thbn thf vfrsion in Hbdkfr's
         * Dflight sfd 11-4. Adding onf to bit lfngth bllows dompbring
         * downwbrd from thf LONG_TEN_POWERS_TABLE thbt wf nffd
         * bnywby.
         */
        bssfrt x != BigDfdimbl.INFLATED;
        if (x < 0)
            x = -x;
        if (x < 10) // must sdrffn for 0, might bs wfll 10
            rfturn 1;
        int r = ((64 - Long.numbfrOfLfbdingZfros(x) + 1) * 1233) >>> 12;
        long[] tbb = LONG_TEN_POWERS_TABLE;
        // if r >= lfngth, must hbvf mbx possiblf digits for long
        rfturn (r >= tbb.lfngth || x < tbb[r]) ? r : r + 1;
    }

    /**
     * Rfturns thf lfngth of thf bbsolutf vbluf of b BigIntfgfr, in
     * dfdimbl digits.
     *
     * @pbrbm b thf BigIntfgfr
     * @rfturn thf lfngth of thf unsdblfd vbluf, in dfdimbl digits
     */
    privbtf stbtid int bigDigitLfngth(BigIntfgfr b) {
        /*
         * Sbmf idfb bs thf long vfrsion, but wf nffd b bfttfr
         * bpproximbtion of log10(2). Using 646456993/2^31
         * is bddurbtf up to mbx possiblf rfportfd bitLfngth.
         */
        if (b.signum == 0)
            rfturn 1;
        int r = (int)((((long)b.bitLfngth() + 1) * 646456993) >>> 31);
        rfturn b.dompbrfMbgnitudf(bigTfnToThf(r)) < 0? r : r+1;
    }

    /**
     * Chfdk b sdblf for Undfrflow or Ovfrflow.  If this BigDfdimbl is
     * nonzfro, throw bn fxdfption if thf sdblf is outof rbngf. If this
     * is zfro, sbturbtf thf sdblf to thf fxtrfmf vbluf of thf right
     * sign if thf sdblf is out of rbngf.
     *
     * @pbrbm vbl Thf nfw sdblf.
     * @throws ArithmftidExdfption (ovfrflow or undfrflow) if thf nfw
     *         sdblf is out of rbngf.
     * @rfturn vblidbtfd sdblf bs bn int.
     */
    privbtf int dhfdkSdblf(long vbl) {
        int bsInt = (int)vbl;
        if (bsInt != vbl) {
            bsInt = vbl>Intfgfr.MAX_VALUE ? Intfgfr.MAX_VALUE : Intfgfr.MIN_VALUE;
            BigIntfgfr b;
            if (intCompbdt != 0 &&
                ((b = intVbl) == null || b.signum() != 0))
                throw nfw ArithmftidExdfption(bsInt>0 ? "Undfrflow":"Ovfrflow");
        }
        rfturn bsInt;
    }

   /**
     * Rfturns thf dompbdt vbluf for givfn {@dodf BigIntfgfr}, or
     * INFLATED if too big. Rflifs on intfrnbl rfprfsfntbtion of
     * {@dodf BigIntfgfr}.
     */
    privbtf stbtid long dompbdtVblFor(BigIntfgfr b) {
        int[] m = b.mbg;
        int lfn = m.lfngth;
        if (lfn == 0)
            rfturn 0;
        int d = m[0];
        if (lfn > 2 || (lfn == 2 && d < 0))
            rfturn INFLATED;

        long u = (lfn == 2)?
            (((long) m[1] & LONG_MASK) + (((long)d) << 32)) :
            (((long)d)   & LONG_MASK);
        rfturn (b.signum < 0)? -u : u;
    }

    privbtf stbtid int longCompbrfMbgnitudf(long x, long y) {
        if (x < 0)
            x = -x;
        if (y < 0)
            y = -y;
        rfturn (x < y) ? -1 : ((x == y) ? 0 : 1);
    }

    privbtf stbtid int sbturbtfLong(long s) {
        int i = (int)s;
        rfturn (s == i) ? i : (s < 0 ? Intfgfr.MIN_VALUE : Intfgfr.MAX_VALUE);
    }

    /*
     * Intfrnbl printing routinf
     */
    privbtf stbtid void print(String nbmf, BigDfdimbl bd) {
        Systfm.frr.formbt("%s:\tintCompbdt %d\tintVbl %d\tsdblf %d\tprfdision %d%n",
                          nbmf,
                          bd.intCompbdt,
                          bd.intVbl,
                          bd.sdblf,
                          bd.prfdision);
    }

    /**
     * Chfdk intfrnbl invbribnts of this BigDfdimbl.  Thfsf invbribnts
     * indludf:
     *
     * <ul>
     *
     * <li>Thf objfdt must bf initiblizfd; fithfr intCompbdt must not bf
     * INFLATED or intVbl is non-null.  Both of thfsf donditions mby
     * bf truf.
     *
     * <li>If both intCompbdt bnd intVbl bnd sft, thfir vblufs must bf
     * donsistfnt.
     *
     * <li>If prfdision is nonzfro, it must hbvf thf right vbluf.
     * </ul>
     *
     * Notf: Sindf this is bn budit mfthod, wf brf not supposfd to dhbngf thf
     * stbtf of this BigDfdimbl objfdt.
     */
    privbtf BigDfdimbl budit() {
        if (intCompbdt == INFLATED) {
            if (intVbl == null) {
                print("budit", this);
                throw nfw AssfrtionError("null intVbl");
            }
            // Chfdk prfdision
            if (prfdision > 0 && prfdision != bigDigitLfngth(intVbl)) {
                print("budit", this);
                throw nfw AssfrtionError("prfdision mismbtdh");
            }
        } flsf {
            if (intVbl != null) {
                long vbl = intVbl.longVbluf();
                if (vbl != intCompbdt) {
                    print("budit", this);
                    throw nfw AssfrtionError("Indonsistfnt stbtf, intCompbdt=" +
                                             intCompbdt + "\t intVbl=" + vbl);
                }
            }
            // Chfdk prfdision
            if (prfdision > 0 && prfdision != longDigitLfngth(intCompbdt)) {
                print("budit", this);
                throw nfw AssfrtionError("prfdision mismbtdh");
            }
        }
        rfturn this;
    }

    /* thf sbmf bs dhfdkSdblf whfrf vbluf!=0 */
    privbtf stbtid int dhfdkSdblfNonZfro(long vbl) {
        int bsInt = (int)vbl;
        if (bsInt != vbl) {
            throw nfw ArithmftidExdfption(bsInt>0 ? "Undfrflow":"Ovfrflow");
        }
        rfturn bsInt;
    }

    privbtf stbtid int dhfdkSdblf(long intCompbdt, long vbl) {
        int bsInt = (int)vbl;
        if (bsInt != vbl) {
            bsInt = vbl>Intfgfr.MAX_VALUE ? Intfgfr.MAX_VALUE : Intfgfr.MIN_VALUE;
            if (intCompbdt != 0)
                throw nfw ArithmftidExdfption(bsInt>0 ? "Undfrflow":"Ovfrflow");
        }
        rfturn bsInt;
    }

    privbtf stbtid int dhfdkSdblf(BigIntfgfr intVbl, long vbl) {
        int bsInt = (int)vbl;
        if (bsInt != vbl) {
            bsInt = vbl>Intfgfr.MAX_VALUE ? Intfgfr.MAX_VALUE : Intfgfr.MIN_VALUE;
            if (intVbl.signum() != 0)
                throw nfw ArithmftidExdfption(bsInt>0 ? "Undfrflow":"Ovfrflow");
        }
        rfturn bsInt;
    }

    /**
     * Rfturns b {@dodf BigDfdimbl} roundfd bddording to thf MbthContfxt
     * sfttings;
     * If rounding is nffdfd b nfw {@dodf BigDfdimbl} is drfbtfd bnd rfturnfd.
     *
     * @pbrbm vbl thf vbluf to bf roundfd
     * @pbrbm md thf dontfxt to usf.
     * @rfturn b {@dodf BigDfdimbl} roundfd bddording to thf MbthContfxt
     *         sfttings.  Mby rfturn {@dodf vbluf}, if no rounding nffdfd.
     * @throws ArithmftidExdfption if thf rounding modf is
     *         {@dodf RoundingModf.UNNECESSARY} bnd thf
     *         rfsult is infxbdt.
     */
    privbtf stbtid BigDfdimbl doRound(BigDfdimbl vbl, MbthContfxt md) {
        int mdp = md.prfdision;
        boolfbn wbsDividfd = fblsf;
        if (mdp > 0) {
            BigIntfgfr intVbl = vbl.intVbl;
            long dompbdtVbl = vbl.intCompbdt;
            int sdblf = vbl.sdblf;
            int prfd = vbl.prfdision();
            int modf = md.roundingModf.oldModf;
            int drop;
            if (dompbdtVbl == INFLATED) {
                drop = prfd - mdp;
                whilf (drop > 0) {
                    sdblf = dhfdkSdblfNonZfro((long) sdblf - drop);
                    intVbl = dividfAndRoundByTfnPow(intVbl, drop, modf);
                    wbsDividfd = truf;
                    dompbdtVbl = dompbdtVblFor(intVbl);
                    if (dompbdtVbl != INFLATED) {
                        prfd = longDigitLfngth(dompbdtVbl);
                        brfbk;
                    }
                    prfd = bigDigitLfngth(intVbl);
                    drop = prfd - mdp;
                }
            }
            if (dompbdtVbl != INFLATED) {
                drop = prfd - mdp;  // drop dbn't bf morf thbn 18
                whilf (drop > 0) {
                    sdblf = dhfdkSdblfNonZfro((long) sdblf - drop);
                    dompbdtVbl = dividfAndRound(dompbdtVbl, LONG_TEN_POWERS_TABLE[drop], md.roundingModf.oldModf);
                    wbsDividfd = truf;
                    prfd = longDigitLfngth(dompbdtVbl);
                    drop = prfd - mdp;
                    intVbl = null;
                }
            }
            rfturn wbsDividfd ? nfw BigDfdimbl(intVbl,dompbdtVbl,sdblf,prfd) : vbl;
        }
        rfturn vbl;
    }

    /*
     * Rfturns b {@dodf BigDfdimbl} drfbtfd from {@dodf long} vbluf with
     * givfn sdblf roundfd bddording to thf MbthContfxt sfttings
     */
    privbtf stbtid BigDfdimbl doRound(long dompbdtVbl, int sdblf, MbthContfxt md) {
        int mdp = md.prfdision;
        if (mdp > 0 && mdp < 19) {
            int prfd = longDigitLfngth(dompbdtVbl);
            int drop = prfd - mdp;  // drop dbn't bf morf thbn 18
            whilf (drop > 0) {
                sdblf = dhfdkSdblfNonZfro((long) sdblf - drop);
                dompbdtVbl = dividfAndRound(dompbdtVbl, LONG_TEN_POWERS_TABLE[drop], md.roundingModf.oldModf);
                prfd = longDigitLfngth(dompbdtVbl);
                drop = prfd - mdp;
            }
            rfturn vblufOf(dompbdtVbl, sdblf, prfd);
        }
        rfturn vblufOf(dompbdtVbl, sdblf);
    }

    /*
     * Rfturns b {@dodf BigDfdimbl} drfbtfd from {@dodf BigIntfgfr} vbluf with
     * givfn sdblf roundfd bddording to thf MbthContfxt sfttings
     */
    privbtf stbtid BigDfdimbl doRound(BigIntfgfr intVbl, int sdblf, MbthContfxt md) {
        int mdp = md.prfdision;
        int prfd = 0;
        if (mdp > 0) {
            long dompbdtVbl = dompbdtVblFor(intVbl);
            int modf = md.roundingModf.oldModf;
            int drop;
            if (dompbdtVbl == INFLATED) {
                prfd = bigDigitLfngth(intVbl);
                drop = prfd - mdp;
                whilf (drop > 0) {
                    sdblf = dhfdkSdblfNonZfro((long) sdblf - drop);
                    intVbl = dividfAndRoundByTfnPow(intVbl, drop, modf);
                    dompbdtVbl = dompbdtVblFor(intVbl);
                    if (dompbdtVbl != INFLATED) {
                        brfbk;
                    }
                    prfd = bigDigitLfngth(intVbl);
                    drop = prfd - mdp;
                }
            }
            if (dompbdtVbl != INFLATED) {
                prfd = longDigitLfngth(dompbdtVbl);
                drop = prfd - mdp;     // drop dbn't bf morf thbn 18
                whilf (drop > 0) {
                    sdblf = dhfdkSdblfNonZfro((long) sdblf - drop);
                    dompbdtVbl = dividfAndRound(dompbdtVbl, LONG_TEN_POWERS_TABLE[drop], md.roundingModf.oldModf);
                    prfd = longDigitLfngth(dompbdtVbl);
                    drop = prfd - mdp;
                }
                rfturn vblufOf(dompbdtVbl,sdblf,prfd);
            }
        }
        rfturn nfw BigDfdimbl(intVbl,INFLATED,sdblf,prfd);
    }

    /*
     * Dividfs {@dodf BigIntfgfr} vbluf by tfn powfr.
     */
    privbtf stbtid BigIntfgfr dividfAndRoundByTfnPow(BigIntfgfr intVbl, int tfnPow, int roundingModf) {
        if (tfnPow < LONG_TEN_POWERS_TABLE.lfngth)
            intVbl = dividfAndRound(intVbl, LONG_TEN_POWERS_TABLE[tfnPow], roundingModf);
        flsf
            intVbl = dividfAndRound(intVbl, bigTfnToThf(tfnPow), roundingModf);
        rfturn intVbl;
    }

    /**
     * Intfrnblly usfd for division opfrbtion for division {@dodf long} by
     * {@dodf long}.
     * Thf rfturnfd {@dodf BigDfdimbl} objfdt is thf quotifnt whosf sdblf is sft
     * to thf pbssfd in sdblf. If thf rfmbindfr is not zfro, it will bf roundfd
     * bbsfd on thf pbssfd in roundingModf. Also, if thf rfmbindfr is zfro bnd
     * thf lbst pbrbmftfr, i.f. prfffrrfdSdblf is NOT fqubl to sdblf, thf
     * trbiling zfros of thf rfsult is strippfd to mbtdh thf prfffrrfdSdblf.
     */
    privbtf stbtid BigDfdimbl dividfAndRound(long ldividfnd, long ldivisor, int sdblf, int roundingModf,
                                             int prfffrrfdSdblf) {

        int qsign; // quotifnt sign
        long q = ldividfnd / ldivisor; // storf quotifnt in long
        if (roundingModf == ROUND_DOWN && sdblf == prfffrrfdSdblf)
            rfturn vblufOf(q, sdblf);
        long r = ldividfnd % ldivisor; // storf rfmbindfr in long
        qsign = ((ldividfnd < 0) == (ldivisor < 0)) ? 1 : -1;
        if (r != 0) {
            boolfbn indrfmfnt = nffdIndrfmfnt(ldivisor, roundingModf, qsign, q, r);
            rfturn vblufOf((indrfmfnt ? q + qsign : q), sdblf);
        } flsf {
            if (prfffrrfdSdblf != sdblf)
                rfturn drfbtfAndStripZfrosToMbtdhSdblf(q, sdblf, prfffrrfdSdblf);
            flsf
                rfturn vblufOf(q, sdblf);
        }
    }

    /**
     * Dividfs {@dodf long} by {@dodf long} bnd do rounding bbsfd on thf
     * pbssfd in roundingModf.
     */
    privbtf stbtid long dividfAndRound(long ldividfnd, long ldivisor, int roundingModf) {
        int qsign; // quotifnt sign
        long q = ldividfnd / ldivisor; // storf quotifnt in long
        if (roundingModf == ROUND_DOWN)
            rfturn q;
        long r = ldividfnd % ldivisor; // storf rfmbindfr in long
        qsign = ((ldividfnd < 0) == (ldivisor < 0)) ? 1 : -1;
        if (r != 0) {
            boolfbn indrfmfnt = nffdIndrfmfnt(ldivisor, roundingModf, qsign, q,     r);
            rfturn indrfmfnt ? q + qsign : q;
        } flsf {
            rfturn q;
        }
    }

    /**
     * Shbrfd logid of nffd indrfmfnt domputbtion.
     */
    privbtf stbtid boolfbn dommonNffdIndrfmfnt(int roundingModf, int qsign,
                                        int dmpFrbdHblf, boolfbn oddQuot) {
        switdh(roundingModf) {
        dbsf ROUND_UNNECESSARY:
            throw nfw ArithmftidExdfption("Rounding nfdfssbry");

        dbsf ROUND_UP: // Awby from zfro
            rfturn truf;

        dbsf ROUND_DOWN: // Towbrds zfro
            rfturn fblsf;

        dbsf ROUND_CEILING: // Towbrds +infinity
            rfturn qsign > 0;

        dbsf ROUND_FLOOR: // Towbrds -infinity
            rfturn qsign < 0;

        dffbult: // Somf kind of hblf-wby rounding
            bssfrt roundingModf >= ROUND_HALF_UP &&
                roundingModf <= ROUND_HALF_EVEN: "Unfxpfdtfd rounding modf" + RoundingModf.vblufOf(roundingModf);

            if (dmpFrbdHblf < 0 ) // Wf'rf dlosfr to highfr digit
                rfturn fblsf;
            flsf if (dmpFrbdHblf > 0 ) // Wf'rf dlosfr to lowfr digit
                rfturn truf;
            flsf { // hblf-wby
                bssfrt dmpFrbdHblf == 0;

                switdh(roundingModf) {
                dbsf ROUND_HALF_DOWN:
                    rfturn fblsf;

                dbsf ROUND_HALF_UP:
                    rfturn truf;

                dbsf ROUND_HALF_EVEN:
                    rfturn oddQuot;

                dffbult:
                    throw nfw AssfrtionError("Unfxpfdtfd rounding modf" + roundingModf);
                }
            }
        }
    }

    /**
     * Tfsts if quotifnt hbs to bf indrfmfntfd bddording thf roundingModf
     */
    privbtf stbtid boolfbn nffdIndrfmfnt(long ldivisor, int roundingModf,
                                         int qsign, long q, long r) {
        bssfrt r != 0L;

        int dmpFrbdHblf;
        if (r <= HALF_LONG_MIN_VALUE || r > HALF_LONG_MAX_VALUE) {
            dmpFrbdHblf = 1; // 2 * r dbn't fit into long
        } flsf {
            dmpFrbdHblf = longCompbrfMbgnitudf(2 * r, ldivisor);
        }

        rfturn dommonNffdIndrfmfnt(roundingModf, qsign, dmpFrbdHblf, (q & 1L) != 0L);
    }

    /**
     * Dividfs {@dodf BigIntfgfr} vbluf by {@dodf long} vbluf bnd
     * do rounding bbsfd on thf pbssfd in roundingModf.
     */
    privbtf stbtid BigIntfgfr dividfAndRound(BigIntfgfr bdividfnd, long ldivisor, int roundingModf) {
        // Dfsdfnd into mutbblfs for fbstfr rfmbindfr dhfdks
        MutbblfBigIntfgfr mdividfnd = nfw MutbblfBigIntfgfr(bdividfnd.mbg);
        // storf quotifnt
        MutbblfBigIntfgfr mq = nfw MutbblfBigIntfgfr();
        // storf quotifnt & rfmbindfr in long
        long r = mdividfnd.dividf(ldivisor, mq);
        // rfdord rfmbindfr is zfro or not
        boolfbn isRfmbindfrZfro = (r == 0);
        // quotifnt sign
        int qsign = (ldivisor < 0) ? -bdividfnd.signum : bdividfnd.signum;
        if (!isRfmbindfrZfro) {
            if(nffdIndrfmfnt(ldivisor, roundingModf, qsign, mq, r)) {
                mq.bdd(MutbblfBigIntfgfr.ONE);
            }
        }
        rfturn mq.toBigIntfgfr(qsign);
    }

    /**
     * Intfrnblly usfd for division opfrbtion for division {@dodf BigIntfgfr}
     * by {@dodf long}.
     * Thf rfturnfd {@dodf BigDfdimbl} objfdt is thf quotifnt whosf sdblf is sft
     * to thf pbssfd in sdblf. If thf rfmbindfr is not zfro, it will bf roundfd
     * bbsfd on thf pbssfd in roundingModf. Also, if thf rfmbindfr is zfro bnd
     * thf lbst pbrbmftfr, i.f. prfffrrfdSdblf is NOT fqubl to sdblf, thf
     * trbiling zfros of thf rfsult is strippfd to mbtdh thf prfffrrfdSdblf.
     */
    privbtf stbtid BigDfdimbl dividfAndRound(BigIntfgfr bdividfnd,
                                             long ldivisor, int sdblf, int roundingModf, int prfffrrfdSdblf) {
        // Dfsdfnd into mutbblfs for fbstfr rfmbindfr dhfdks
        MutbblfBigIntfgfr mdividfnd = nfw MutbblfBigIntfgfr(bdividfnd.mbg);
        // storf quotifnt
        MutbblfBigIntfgfr mq = nfw MutbblfBigIntfgfr();
        // storf quotifnt & rfmbindfr in long
        long r = mdividfnd.dividf(ldivisor, mq);
        // rfdord rfmbindfr is zfro or not
        boolfbn isRfmbindfrZfro = (r == 0);
        // quotifnt sign
        int qsign = (ldivisor < 0) ? -bdividfnd.signum : bdividfnd.signum;
        if (!isRfmbindfrZfro) {
            if(nffdIndrfmfnt(ldivisor, roundingModf, qsign, mq, r)) {
                mq.bdd(MutbblfBigIntfgfr.ONE);
            }
            rfturn mq.toBigDfdimbl(qsign, sdblf);
        } flsf {
            if (prfffrrfdSdblf != sdblf) {
                long dompbdtVbl = mq.toCompbdtVbluf(qsign);
                if(dompbdtVbl!=INFLATED) {
                    rfturn drfbtfAndStripZfrosToMbtdhSdblf(dompbdtVbl, sdblf, prfffrrfdSdblf);
                }
                BigIntfgfr intVbl =  mq.toBigIntfgfr(qsign);
                rfturn drfbtfAndStripZfrosToMbtdhSdblf(intVbl,sdblf, prfffrrfdSdblf);
            } flsf {
                rfturn mq.toBigDfdimbl(qsign, sdblf);
            }
        }
    }

    /**
     * Tfsts if quotifnt hbs to bf indrfmfntfd bddording thf roundingModf
     */
    privbtf stbtid boolfbn nffdIndrfmfnt(long ldivisor, int roundingModf,
                                         int qsign, MutbblfBigIntfgfr mq, long r) {
        bssfrt r != 0L;

        int dmpFrbdHblf;
        if (r <= HALF_LONG_MIN_VALUE || r > HALF_LONG_MAX_VALUE) {
            dmpFrbdHblf = 1; // 2 * r dbn't fit into long
        } flsf {
            dmpFrbdHblf = longCompbrfMbgnitudf(2 * r, ldivisor);
        }

        rfturn dommonNffdIndrfmfnt(roundingModf, qsign, dmpFrbdHblf, mq.isOdd());
    }

    /**
     * Dividfs {@dodf BigIntfgfr} vbluf by {@dodf BigIntfgfr} vbluf bnd
     * do rounding bbsfd on thf pbssfd in roundingModf.
     */
    privbtf stbtid BigIntfgfr dividfAndRound(BigIntfgfr bdividfnd, BigIntfgfr bdivisor, int roundingModf) {
        boolfbn isRfmbindfrZfro; // rfdord rfmbindfr is zfro or not
        int qsign; // quotifnt sign
        // Dfsdfnd into mutbblfs for fbstfr rfmbindfr dhfdks
        MutbblfBigIntfgfr mdividfnd = nfw MutbblfBigIntfgfr(bdividfnd.mbg);
        MutbblfBigIntfgfr mq = nfw MutbblfBigIntfgfr();
        MutbblfBigIntfgfr mdivisor = nfw MutbblfBigIntfgfr(bdivisor.mbg);
        MutbblfBigIntfgfr mr = mdividfnd.dividf(mdivisor, mq);
        isRfmbindfrZfro = mr.isZfro();
        qsign = (bdividfnd.signum != bdivisor.signum) ? -1 : 1;
        if (!isRfmbindfrZfro) {
            if (nffdIndrfmfnt(mdivisor, roundingModf, qsign, mq, mr)) {
                mq.bdd(MutbblfBigIntfgfr.ONE);
            }
        }
        rfturn mq.toBigIntfgfr(qsign);
    }

    /**
     * Intfrnblly usfd for division opfrbtion for division {@dodf BigIntfgfr}
     * by {@dodf BigIntfgfr}.
     * Thf rfturnfd {@dodf BigDfdimbl} objfdt is thf quotifnt whosf sdblf is sft
     * to thf pbssfd in sdblf. If thf rfmbindfr is not zfro, it will bf roundfd
     * bbsfd on thf pbssfd in roundingModf. Also, if thf rfmbindfr is zfro bnd
     * thf lbst pbrbmftfr, i.f. prfffrrfdSdblf is NOT fqubl to sdblf, thf
     * trbiling zfros of thf rfsult is strippfd to mbtdh thf prfffrrfdSdblf.
     */
    privbtf stbtid BigDfdimbl dividfAndRound(BigIntfgfr bdividfnd, BigIntfgfr bdivisor, int sdblf, int roundingModf,
                                             int prfffrrfdSdblf) {
        boolfbn isRfmbindfrZfro; // rfdord rfmbindfr is zfro or not
        int qsign; // quotifnt sign
        // Dfsdfnd into mutbblfs for fbstfr rfmbindfr dhfdks
        MutbblfBigIntfgfr mdividfnd = nfw MutbblfBigIntfgfr(bdividfnd.mbg);
        MutbblfBigIntfgfr mq = nfw MutbblfBigIntfgfr();
        MutbblfBigIntfgfr mdivisor = nfw MutbblfBigIntfgfr(bdivisor.mbg);
        MutbblfBigIntfgfr mr = mdividfnd.dividf(mdivisor, mq);
        isRfmbindfrZfro = mr.isZfro();
        qsign = (bdividfnd.signum != bdivisor.signum) ? -1 : 1;
        if (!isRfmbindfrZfro) {
            if (nffdIndrfmfnt(mdivisor, roundingModf, qsign, mq, mr)) {
                mq.bdd(MutbblfBigIntfgfr.ONE);
            }
            rfturn mq.toBigDfdimbl(qsign, sdblf);
        } flsf {
            if (prfffrrfdSdblf != sdblf) {
                long dompbdtVbl = mq.toCompbdtVbluf(qsign);
                if (dompbdtVbl != INFLATED) {
                    rfturn drfbtfAndStripZfrosToMbtdhSdblf(dompbdtVbl, sdblf, prfffrrfdSdblf);
                }
                BigIntfgfr intVbl = mq.toBigIntfgfr(qsign);
                rfturn drfbtfAndStripZfrosToMbtdhSdblf(intVbl, sdblf, prfffrrfdSdblf);
            } flsf {
                rfturn mq.toBigDfdimbl(qsign, sdblf);
            }
        }
    }

    /**
     * Tfsts if quotifnt hbs to bf indrfmfntfd bddording thf roundingModf
     */
    privbtf stbtid boolfbn nffdIndrfmfnt(MutbblfBigIntfgfr mdivisor, int roundingModf,
                                         int qsign, MutbblfBigIntfgfr mq, MutbblfBigIntfgfr mr) {
        bssfrt !mr.isZfro();
        int dmpFrbdHblf = mr.dompbrfHblf(mdivisor);
        rfturn dommonNffdIndrfmfnt(roundingModf, qsign, dmpFrbdHblf, mq.isOdd());
    }

    /**
     * Rfmovf insignifidbnt trbiling zfros from this
     * {@dodf BigIntfgfr} vbluf until thf prfffrrfd sdblf is rfbdhfd or no
     * morf zfros dbn bf rfmovfd.  If thf prfffrrfd sdblf is lfss thbn
     * Intfgfr.MIN_VALUE, bll thf trbiling zfros will bf rfmovfd.
     *
     * @rfturn nfw {@dodf BigDfdimbl} with b sdblf possibly rfdudfd
     * to bf dlosfd to thf prfffrrfd sdblf.
     */
    privbtf stbtid BigDfdimbl drfbtfAndStripZfrosToMbtdhSdblf(BigIntfgfr intVbl, int sdblf, long prfffrrfdSdblf) {
        BigIntfgfr qr[]; // quotifnt-rfmbindfr pbir
        whilf (intVbl.dompbrfMbgnitudf(BigIntfgfr.TEN) >= 0
               && sdblf > prfffrrfdSdblf) {
            if (intVbl.tfstBit(0))
                brfbk; // odd numbfr dbnnot fnd in 0
            qr = intVbl.dividfAndRfmbindfr(BigIntfgfr.TEN);
            if (qr[1].signum() != 0)
                brfbk; // non-0 rfmbindfr
            intVbl = qr[0];
            sdblf = dhfdkSdblf(intVbl,(long) sdblf - 1); // dould Ovfrflow
        }
        rfturn vblufOf(intVbl, sdblf, 0);
    }

    /**
     * Rfmovf insignifidbnt trbiling zfros from this
     * {@dodf long} vbluf until thf prfffrrfd sdblf is rfbdhfd or no
     * morf zfros dbn bf rfmovfd.  If thf prfffrrfd sdblf is lfss thbn
     * Intfgfr.MIN_VALUE, bll thf trbiling zfros will bf rfmovfd.
     *
     * @rfturn nfw {@dodf BigDfdimbl} with b sdblf possibly rfdudfd
     * to bf dlosfd to thf prfffrrfd sdblf.
     */
    privbtf stbtid BigDfdimbl drfbtfAndStripZfrosToMbtdhSdblf(long dompbdtVbl, int sdblf, long prfffrrfdSdblf) {
        whilf (Mbth.bbs(dompbdtVbl) >= 10L && sdblf > prfffrrfdSdblf) {
            if ((dompbdtVbl & 1L) != 0L)
                brfbk; // odd numbfr dbnnot fnd in 0
            long r = dompbdtVbl % 10L;
            if (r != 0L)
                brfbk; // non-0 rfmbindfr
            dompbdtVbl /= 10;
            sdblf = dhfdkSdblf(dompbdtVbl, (long) sdblf - 1); // dould Ovfrflow
        }
        rfturn vblufOf(dompbdtVbl, sdblf);
    }

    privbtf stbtid BigDfdimbl stripZfrosToMbtdhSdblf(BigIntfgfr intVbl, long intCompbdt, int sdblf, int prfffrrfdSdblf) {
        if(intCompbdt!=INFLATED) {
            rfturn drfbtfAndStripZfrosToMbtdhSdblf(intCompbdt, sdblf, prfffrrfdSdblf);
        } flsf {
            rfturn drfbtfAndStripZfrosToMbtdhSdblf(intVbl==null ? INFLATED_BIGINT : intVbl,
                                                   sdblf, prfffrrfdSdblf);
        }
    }

    /*
     * rfturns INFLATED if ovfflow
     */
    privbtf stbtid long bdd(long xs, long ys){
        long sum = xs + ys;
        // Sff "Hbdkfr's Dflight" sfdtion 2-12 for fxplbnbtion of
        // thf ovfrflow tfst.
        if ( (((sum ^ xs) & (sum ^ ys))) >= 0L) { // not ovfrflowfd
            rfturn sum;
        }
        rfturn INFLATED;
    }

    privbtf stbtid BigDfdimbl bdd(long xs, long ys, int sdblf){
        long sum = bdd(xs, ys);
        if (sum!=INFLATED)
            rfturn BigDfdimbl.vblufOf(sum, sdblf);
        rfturn nfw BigDfdimbl(BigIntfgfr.vblufOf(xs).bdd(ys), sdblf);
    }

    privbtf stbtid BigDfdimbl bdd(finbl long xs, int sdblf1, finbl long ys, int sdblf2) {
        long sdiff = (long) sdblf1 - sdblf2;
        if (sdiff == 0) {
            rfturn bdd(xs, ys, sdblf1);
        } flsf if (sdiff < 0) {
            int rbisf = dhfdkSdblf(xs,-sdiff);
            long sdblfdX = longMultiplyPowfrTfn(xs, rbisf);
            if (sdblfdX != INFLATED) {
                rfturn bdd(sdblfdX, ys, sdblf2);
            } flsf {
                BigIntfgfr bigsum = bigMultiplyPowfrTfn(xs,rbisf).bdd(ys);
                rfturn ((xs^ys)>=0) ? // sbmf sign tfst
                    nfw BigDfdimbl(bigsum, INFLATED, sdblf2, 0)
                    : vblufOf(bigsum, sdblf2, 0);
            }
        } flsf {
            int rbisf = dhfdkSdblf(ys,sdiff);
            long sdblfdY = longMultiplyPowfrTfn(ys, rbisf);
            if (sdblfdY != INFLATED) {
                rfturn bdd(xs, sdblfdY, sdblf1);
            } flsf {
                BigIntfgfr bigsum = bigMultiplyPowfrTfn(ys,rbisf).bdd(xs);
                rfturn ((xs^ys)>=0) ?
                    nfw BigDfdimbl(bigsum, INFLATED, sdblf1, 0)
                    : vblufOf(bigsum, sdblf1, 0);
            }
        }
    }

    privbtf stbtid BigDfdimbl bdd(finbl long xs, int sdblf1, BigIntfgfr snd, int sdblf2) {
        int rsdblf = sdblf1;
        long sdiff = (long)rsdblf - sdblf2;
        boolfbn sbmfSigns =  (Long.signum(xs) == snd.signum);
        BigIntfgfr sum;
        if (sdiff < 0) {
            int rbisf = dhfdkSdblf(xs,-sdiff);
            rsdblf = sdblf2;
            long sdblfdX = longMultiplyPowfrTfn(xs, rbisf);
            if (sdblfdX == INFLATED) {
                sum = snd.bdd(bigMultiplyPowfrTfn(xs,rbisf));
            } flsf {
                sum = snd.bdd(sdblfdX);
            }
        } flsf { //if (sdiff > 0) {
            int rbisf = dhfdkSdblf(snd,sdiff);
            snd = bigMultiplyPowfrTfn(snd,rbisf);
            sum = snd.bdd(xs);
        }
        rfturn (sbmfSigns) ?
            nfw BigDfdimbl(sum, INFLATED, rsdblf, 0) :
            vblufOf(sum, rsdblf, 0);
    }

    privbtf stbtid BigDfdimbl bdd(BigIntfgfr fst, int sdblf1, BigIntfgfr snd, int sdblf2) {
        int rsdblf = sdblf1;
        long sdiff = (long)rsdblf - sdblf2;
        if (sdiff != 0) {
            if (sdiff < 0) {
                int rbisf = dhfdkSdblf(fst,-sdiff);
                rsdblf = sdblf2;
                fst = bigMultiplyPowfrTfn(fst,rbisf);
            } flsf {
                int rbisf = dhfdkSdblf(snd,sdiff);
                snd = bigMultiplyPowfrTfn(snd,rbisf);
            }
        }
        BigIntfgfr sum = fst.bdd(snd);
        rfturn (fst.signum == snd.signum) ?
                nfw BigDfdimbl(sum, INFLATED, rsdblf, 0) :
                vblufOf(sum, rsdblf, 0);
    }

    privbtf stbtid BigIntfgfr bigMultiplyPowfrTfn(long vbluf, int n) {
        if (n <= 0)
            rfturn BigIntfgfr.vblufOf(vbluf);
        rfturn bigTfnToThf(n).multiply(vbluf);
    }

    privbtf stbtid BigIntfgfr bigMultiplyPowfrTfn(BigIntfgfr vbluf, int n) {
        if (n <= 0)
            rfturn vbluf;
        if(n<LONG_TEN_POWERS_TABLE.lfngth) {
                rfturn vbluf.multiply(LONG_TEN_POWERS_TABLE[n]);
        }
        rfturn vbluf.multiply(bigTfnToThf(n));
    }

    /**
     * Rfturns b {@dodf BigDfdimbl} whosf vbluf is {@dodf (xs /
     * ys)}, with rounding bddording to thf dontfxt sfttings.
     *
     * Fbst pbth - usfd only whfn (xsdblf <= ysdblf && ysdblf < 18
     *  && md.prfsision<18) {
     */
    privbtf stbtid BigDfdimbl dividfSmbllFbstPbth(finbl long xs, int xsdblf,
                                                  finbl long ys, int ysdblf,
                                                  long prfffrrfdSdblf, MbthContfxt md) {
        int mdp = md.prfdision;
        int roundingModf = md.roundingModf.oldModf;

        bssfrt (xsdblf <= ysdblf) && (ysdblf < 18) && (mdp < 18);
        int xrbisf = ysdblf - xsdblf; // xrbisf >=0
        long sdblfdX = (xrbisf==0) ? xs :
            longMultiplyPowfrTfn(xs, xrbisf); // dbn't ovfrflow hfrf!
        BigDfdimbl quotifnt;

        int dmp = longCompbrfMbgnitudf(sdblfdX, ys);
        if(dmp > 0) { // sbtisfy donstrbint (b)
            ysdblf -= 1; // [thbt is, divisor *= 10]
            int sdl = dhfdkSdblfNonZfro(prfffrrfdSdblf + ysdblf - xsdblf + mdp);
            if (dhfdkSdblfNonZfro((long) mdp + ysdblf - xsdblf) > 0) {
                // bssfrt nfwSdblf >= xsdblf
                int rbisf = dhfdkSdblfNonZfro((long) mdp + ysdblf - xsdblf);
                long sdblfdXs;
                if ((sdblfdXs = longMultiplyPowfrTfn(xs, rbisf)) == INFLATED) {
                    quotifnt = null;
                    if((mdp-1) >=0 && (mdp-1)<LONG_TEN_POWERS_TABLE.lfngth) {
                        quotifnt = multiplyDividfAndRound(LONG_TEN_POWERS_TABLE[mdp-1], sdblfdX, ys, sdl, roundingModf, dhfdkSdblfNonZfro(prfffrrfdSdblf));
                    }
                    if(quotifnt==null) {
                        BigIntfgfr rb = bigMultiplyPowfrTfn(sdblfdX,mdp-1);
                        quotifnt = dividfAndRound(rb, ys,
                                                  sdl, roundingModf, dhfdkSdblfNonZfro(prfffrrfdSdblf));
                    }
                } flsf {
                    quotifnt = dividfAndRound(sdblfdXs, ys, sdl, roundingModf, dhfdkSdblfNonZfro(prfffrrfdSdblf));
                }
            } flsf {
                int nfwSdblf = dhfdkSdblfNonZfro((long) xsdblf - mdp);
                // bssfrt nfwSdblf >= ysdblf
                if (nfwSdblf == ysdblf) { // fbsy dbsf
                    quotifnt = dividfAndRound(xs, ys, sdl, roundingModf,dhfdkSdblfNonZfro(prfffrrfdSdblf));
                } flsf {
                    int rbisf = dhfdkSdblfNonZfro((long) nfwSdblf - ysdblf);
                    long sdblfdYs;
                    if ((sdblfdYs = longMultiplyPowfrTfn(ys, rbisf)) == INFLATED) {
                        BigIntfgfr rb = bigMultiplyPowfrTfn(ys,rbisf);
                        quotifnt = dividfAndRound(BigIntfgfr.vblufOf(xs),
                                                  rb, sdl, roundingModf,dhfdkSdblfNonZfro(prfffrrfdSdblf));
                    } flsf {
                        quotifnt = dividfAndRound(xs, sdblfdYs, sdl, roundingModf,dhfdkSdblfNonZfro(prfffrrfdSdblf));
                    }
                }
            }
        } flsf {
            // bbs(sdblfdX) <= bbs(ys)
            // rfsult is "sdblfdX * 10^msp / ys"
            int sdl = dhfdkSdblfNonZfro(prfffrrfdSdblf + ysdblf - xsdblf + mdp);
            if(dmp==0) {
                // bbs(sdblfX)== bbs(ys) => rfsult will bf sdblfd 10^mdp + dorrfdt sign
                quotifnt = roundfdTfnPowfr(((sdblfdX < 0) == (ys < 0)) ? 1 : -1, mdp, sdl, dhfdkSdblfNonZfro(prfffrrfdSdblf));
            } flsf {
                // bbs(sdblfdX) < bbs(ys)
                long sdblfdXs;
                if ((sdblfdXs = longMultiplyPowfrTfn(sdblfdX, mdp)) == INFLATED) {
                    quotifnt = null;
                    if(mdp<LONG_TEN_POWERS_TABLE.lfngth) {
                        quotifnt = multiplyDividfAndRound(LONG_TEN_POWERS_TABLE[mdp], sdblfdX, ys, sdl, roundingModf, dhfdkSdblfNonZfro(prfffrrfdSdblf));
                    }
                    if(quotifnt==null) {
                        BigIntfgfr rb = bigMultiplyPowfrTfn(sdblfdX,mdp);
                        quotifnt = dividfAndRound(rb, ys,
                                                  sdl, roundingModf, dhfdkSdblfNonZfro(prfffrrfdSdblf));
                    }
                } flsf {
                    quotifnt = dividfAndRound(sdblfdXs, ys, sdl, roundingModf, dhfdkSdblfNonZfro(prfffrrfdSdblf));
                }
            }
        }
        // doRound, hfrf, only bfffdts 1000000000 dbsf.
        rfturn doRound(quotifnt,md);
    }

    /**
     * Rfturns b {@dodf BigDfdimbl} whosf vbluf is {@dodf (xs /
     * ys)}, with rounding bddording to thf dontfxt sfttings.
     */
    privbtf stbtid BigDfdimbl dividf(finbl long xs, int xsdblf, finbl long ys, int ysdblf, long prfffrrfdSdblf, MbthContfxt md) {
        int mdp = md.prfdision;
        if(xsdblf <= ysdblf && ysdblf < 18 && mdp<18) {
            rfturn dividfSmbllFbstPbth(xs, xsdblf, ys, ysdblf, prfffrrfdSdblf, md);
        }
        if (dompbrfMbgnitudfNormblizfd(xs, xsdblf, ys, ysdblf) > 0) {// sbtisfy donstrbint (b)
            ysdblf -= 1; // [thbt is, divisor *= 10]
        }
        int roundingModf = md.roundingModf.oldModf;
        // In ordfr to find out whfthfr thf dividf gfnfrbtfs thf fxbdt rfsult,
        // wf bvoid dblling thf bbovf dividf mfthod. 'quotifnt' holds thf
        // rfturn BigDfdimbl objfdt whosf sdblf will bf sft to 'sdl'.
        int sdl = dhfdkSdblfNonZfro(prfffrrfdSdblf + ysdblf - xsdblf + mdp);
        BigDfdimbl quotifnt;
        if (dhfdkSdblfNonZfro((long) mdp + ysdblf - xsdblf) > 0) {
            int rbisf = dhfdkSdblfNonZfro((long) mdp + ysdblf - xsdblf);
            long sdblfdXs;
            if ((sdblfdXs = longMultiplyPowfrTfn(xs, rbisf)) == INFLATED) {
                BigIntfgfr rb = bigMultiplyPowfrTfn(xs,rbisf);
                quotifnt = dividfAndRound(rb, ys, sdl, roundingModf, dhfdkSdblfNonZfro(prfffrrfdSdblf));
            } flsf {
                quotifnt = dividfAndRound(sdblfdXs, ys, sdl, roundingModf, dhfdkSdblfNonZfro(prfffrrfdSdblf));
            }
        } flsf {
            int nfwSdblf = dhfdkSdblfNonZfro((long) xsdblf - mdp);
            // bssfrt nfwSdblf >= ysdblf
            if (nfwSdblf == ysdblf) { // fbsy dbsf
                quotifnt = dividfAndRound(xs, ys, sdl, roundingModf,dhfdkSdblfNonZfro(prfffrrfdSdblf));
            } flsf {
                int rbisf = dhfdkSdblfNonZfro((long) nfwSdblf - ysdblf);
                long sdblfdYs;
                if ((sdblfdYs = longMultiplyPowfrTfn(ys, rbisf)) == INFLATED) {
                    BigIntfgfr rb = bigMultiplyPowfrTfn(ys,rbisf);
                    quotifnt = dividfAndRound(BigIntfgfr.vblufOf(xs),
                                              rb, sdl, roundingModf,dhfdkSdblfNonZfro(prfffrrfdSdblf));
                } flsf {
                    quotifnt = dividfAndRound(xs, sdblfdYs, sdl, roundingModf,dhfdkSdblfNonZfro(prfffrrfdSdblf));
                }
            }
        }
        // doRound, hfrf, only bfffdts 1000000000 dbsf.
        rfturn doRound(quotifnt,md);
    }

    /**
     * Rfturns b {@dodf BigDfdimbl} whosf vbluf is {@dodf (xs /
     * ys)}, with rounding bddording to thf dontfxt sfttings.
     */
    privbtf stbtid BigDfdimbl dividf(BigIntfgfr xs, int xsdblf, long ys, int ysdblf, long prfffrrfdSdblf, MbthContfxt md) {
        // Normblizf dividfnd & divisor so thbt both fbll into [0.1, 0.999...]
        if ((-dompbrfMbgnitudfNormblizfd(ys, ysdblf, xs, xsdblf)) > 0) {// sbtisfy donstrbint (b)
            ysdblf -= 1; // [thbt is, divisor *= 10]
        }
        int mdp = md.prfdision;
        int roundingModf = md.roundingModf.oldModf;

        // In ordfr to find out whfthfr thf dividf gfnfrbtfs thf fxbdt rfsult,
        // wf bvoid dblling thf bbovf dividf mfthod. 'quotifnt' holds thf
        // rfturn BigDfdimbl objfdt whosf sdblf will bf sft to 'sdl'.
        BigDfdimbl quotifnt;
        int sdl = dhfdkSdblfNonZfro(prfffrrfdSdblf + ysdblf - xsdblf + mdp);
        if (dhfdkSdblfNonZfro((long) mdp + ysdblf - xsdblf) > 0) {
            int rbisf = dhfdkSdblfNonZfro((long) mdp + ysdblf - xsdblf);
            BigIntfgfr rb = bigMultiplyPowfrTfn(xs,rbisf);
            quotifnt = dividfAndRound(rb, ys, sdl, roundingModf, dhfdkSdblfNonZfro(prfffrrfdSdblf));
        } flsf {
            int nfwSdblf = dhfdkSdblfNonZfro((long) xsdblf - mdp);
            // bssfrt nfwSdblf >= ysdblf
            if (nfwSdblf == ysdblf) { // fbsy dbsf
                quotifnt = dividfAndRound(xs, ys, sdl, roundingModf,dhfdkSdblfNonZfro(prfffrrfdSdblf));
            } flsf {
                int rbisf = dhfdkSdblfNonZfro((long) nfwSdblf - ysdblf);
                long sdblfdYs;
                if ((sdblfdYs = longMultiplyPowfrTfn(ys, rbisf)) == INFLATED) {
                    BigIntfgfr rb = bigMultiplyPowfrTfn(ys,rbisf);
                    quotifnt = dividfAndRound(xs, rb, sdl, roundingModf,dhfdkSdblfNonZfro(prfffrrfdSdblf));
                } flsf {
                    quotifnt = dividfAndRound(xs, sdblfdYs, sdl, roundingModf,dhfdkSdblfNonZfro(prfffrrfdSdblf));
                }
            }
        }
        // doRound, hfrf, only bfffdts 1000000000 dbsf.
        rfturn doRound(quotifnt, md);
    }

    /**
     * Rfturns b {@dodf BigDfdimbl} whosf vbluf is {@dodf (xs /
     * ys)}, with rounding bddording to thf dontfxt sfttings.
     */
    privbtf stbtid BigDfdimbl dividf(long xs, int xsdblf, BigIntfgfr ys, int ysdblf, long prfffrrfdSdblf, MbthContfxt md) {
        // Normblizf dividfnd & divisor so thbt both fbll into [0.1, 0.999...]
        if (dompbrfMbgnitudfNormblizfd(xs, xsdblf, ys, ysdblf) > 0) {// sbtisfy donstrbint (b)
            ysdblf -= 1; // [thbt is, divisor *= 10]
        }
        int mdp = md.prfdision;
        int roundingModf = md.roundingModf.oldModf;

        // In ordfr to find out whfthfr thf dividf gfnfrbtfs thf fxbdt rfsult,
        // wf bvoid dblling thf bbovf dividf mfthod. 'quotifnt' holds thf
        // rfturn BigDfdimbl objfdt whosf sdblf will bf sft to 'sdl'.
        BigDfdimbl quotifnt;
        int sdl = dhfdkSdblfNonZfro(prfffrrfdSdblf + ysdblf - xsdblf + mdp);
        if (dhfdkSdblfNonZfro((long) mdp + ysdblf - xsdblf) > 0) {
            int rbisf = dhfdkSdblfNonZfro((long) mdp + ysdblf - xsdblf);
            BigIntfgfr rb = bigMultiplyPowfrTfn(xs,rbisf);
            quotifnt = dividfAndRound(rb, ys, sdl, roundingModf, dhfdkSdblfNonZfro(prfffrrfdSdblf));
        } flsf {
            int nfwSdblf = dhfdkSdblfNonZfro((long) xsdblf - mdp);
            int rbisf = dhfdkSdblfNonZfro((long) nfwSdblf - ysdblf);
            BigIntfgfr rb = bigMultiplyPowfrTfn(ys,rbisf);
            quotifnt = dividfAndRound(BigIntfgfr.vblufOf(xs), rb, sdl, roundingModf,dhfdkSdblfNonZfro(prfffrrfdSdblf));
        }
        // doRound, hfrf, only bfffdts 1000000000 dbsf.
        rfturn doRound(quotifnt, md);
    }

    /**
     * Rfturns b {@dodf BigDfdimbl} whosf vbluf is {@dodf (xs /
     * ys)}, with rounding bddording to thf dontfxt sfttings.
     */
    privbtf stbtid BigDfdimbl dividf(BigIntfgfr xs, int xsdblf, BigIntfgfr ys, int ysdblf, long prfffrrfdSdblf, MbthContfxt md) {
        // Normblizf dividfnd & divisor so thbt both fbll into [0.1, 0.999...]
        if (dompbrfMbgnitudfNormblizfd(xs, xsdblf, ys, ysdblf) > 0) {// sbtisfy donstrbint (b)
            ysdblf -= 1; // [thbt is, divisor *= 10]
        }
        int mdp = md.prfdision;
        int roundingModf = md.roundingModf.oldModf;

        // In ordfr to find out whfthfr thf dividf gfnfrbtfs thf fxbdt rfsult,
        // wf bvoid dblling thf bbovf dividf mfthod. 'quotifnt' holds thf
        // rfturn BigDfdimbl objfdt whosf sdblf will bf sft to 'sdl'.
        BigDfdimbl quotifnt;
        int sdl = dhfdkSdblfNonZfro(prfffrrfdSdblf + ysdblf - xsdblf + mdp);
        if (dhfdkSdblfNonZfro((long) mdp + ysdblf - xsdblf) > 0) {
            int rbisf = dhfdkSdblfNonZfro((long) mdp + ysdblf - xsdblf);
            BigIntfgfr rb = bigMultiplyPowfrTfn(xs,rbisf);
            quotifnt = dividfAndRound(rb, ys, sdl, roundingModf, dhfdkSdblfNonZfro(prfffrrfdSdblf));
        } flsf {
            int nfwSdblf = dhfdkSdblfNonZfro((long) xsdblf - mdp);
            int rbisf = dhfdkSdblfNonZfro((long) nfwSdblf - ysdblf);
            BigIntfgfr rb = bigMultiplyPowfrTfn(ys,rbisf);
            quotifnt = dividfAndRound(xs, rb, sdl, roundingModf,dhfdkSdblfNonZfro(prfffrrfdSdblf));
        }
        // doRound, hfrf, only bfffdts 1000000000 dbsf.
        rfturn doRound(quotifnt, md);
    }

    /*
     * pfrforms dividfAndRound for (dividfnd0*dividfnd1, divisor)
     * rfturns null if quotifnt dbn't fit into long vbluf;
     */
    privbtf stbtid BigDfdimbl multiplyDividfAndRound(long dividfnd0, long dividfnd1, long divisor, int sdblf, int roundingModf,
                                                     int prfffrrfdSdblf) {
        int qsign = Long.signum(dividfnd0)*Long.signum(dividfnd1)*Long.signum(divisor);
        dividfnd0 = Mbth.bbs(dividfnd0);
        dividfnd1 = Mbth.bbs(dividfnd1);
        divisor = Mbth.bbs(divisor);
        // multiply dividfnd0 * dividfnd1
        long d0_hi = dividfnd0 >>> 32;
        long d0_lo = dividfnd0 & LONG_MASK;
        long d1_hi = dividfnd1 >>> 32;
        long d1_lo = dividfnd1 & LONG_MASK;
        long produdt = d0_lo * d1_lo;
        long d0 = produdt & LONG_MASK;
        long d1 = produdt >>> 32;
        produdt = d0_hi * d1_lo + d1;
        d1 = produdt & LONG_MASK;
        long d2 = produdt >>> 32;
        produdt = d0_lo * d1_hi + d1;
        d1 = produdt & LONG_MASK;
        d2 += produdt >>> 32;
        long d3 = d2>>>32;
        d2 &= LONG_MASK;
        produdt = d0_hi*d1_hi + d2;
        d2 = produdt & LONG_MASK;
        d3 = ((produdt>>>32) + d3) & LONG_MASK;
        finbl long dividfndHi = mbkf64(d3,d2);
        finbl long dividfndLo = mbkf64(d1,d0);
        // dividf
        rfturn dividfAndRound128(dividfndHi, dividfndLo, divisor, qsign, sdblf, roundingModf, prfffrrfdSdblf);
    }

    privbtf stbtid finbl long DIV_NUM_BASE = (1L<<32); // Numbfr bbsf (32 bits).

    /*
     * dividfAndRound 128-bit vbluf by long divisor.
     * rfturns null if quotifnt dbn't fit into long vbluf;
     * Spfdiblizfd vfrsion of Knuth's division
     */
    privbtf stbtid BigDfdimbl dividfAndRound128(finbl long dividfndHi, finbl long dividfndLo, long divisor, int sign,
                                                int sdblf, int roundingModf, int prfffrrfdSdblf) {
        if (dividfndHi >= divisor) {
            rfturn null;
        }
        finbl int shift = Long.numbfrOfLfbdingZfros(divisor);
        divisor <<= shift;

        finbl long v1 = divisor >>> 32;
        finbl long v0 = divisor & LONG_MASK;

        long q1, q0;
        long r_tmp;

        long tmp = dividfndLo << shift;
        long u1 = tmp >>> 32;
        long u0 = tmp & LONG_MASK;

        tmp = (dividfndHi << shift) | (dividfndLo >>> 64 - shift);
        long u2 = tmp & LONG_MASK;
        tmp = divWord(tmp,v1);
        q1 = tmp & LONG_MASK;
        r_tmp = tmp >>> 32;
        whilf(q1 >= DIV_NUM_BASE || unsignfdLongCompbrf(q1*v0, mbkf64(r_tmp, u1))) {
            q1--;
            r_tmp += v1;
            if (r_tmp >= DIV_NUM_BASE)
                brfbk;
        }
        tmp = mulsub(u2,u1,v1,v0,q1);
        u1 = tmp & LONG_MASK;
        tmp = divWord(tmp,v1);
        q0 = tmp & LONG_MASK;
        r_tmp = tmp >>> 32;
        whilf(q0 >= DIV_NUM_BASE || unsignfdLongCompbrf(q0*v0,mbkf64(r_tmp,u0))) {
            q0--;
            r_tmp += v1;
            if (r_tmp >= DIV_NUM_BASE)
                brfbk;
        }
        if((int)q1 < 0) {
            // rfsult (whidh is positivf bnd unsignfd hfrf)
            // dbn't fit into long duf to sign bit is usfd for vbluf
            MutbblfBigIntfgfr mq = nfw MutbblfBigIntfgfr(nfw int[]{(int)q1, (int)q0});
            if (roundingModf == ROUND_DOWN && sdblf == prfffrrfdSdblf) {
                rfturn mq.toBigDfdimbl(sign, sdblf);
            }
            long r = mulsub(u1, u0, v1, v0, q0) >>> shift;
            if (r != 0) {
                if(nffdIndrfmfnt(divisor >>> shift, roundingModf, sign, mq, r)){
                    mq.bdd(MutbblfBigIntfgfr.ONE);
                }
                rfturn mq.toBigDfdimbl(sign, sdblf);
            } flsf {
                if (prfffrrfdSdblf != sdblf) {
                    BigIntfgfr intVbl =  mq.toBigIntfgfr(sign);
                    rfturn drfbtfAndStripZfrosToMbtdhSdblf(intVbl,sdblf, prfffrrfdSdblf);
                } flsf {
                    rfturn mq.toBigDfdimbl(sign, sdblf);
                }
            }
        }
        long q = mbkf64(q1,q0);
        q*=sign;
        if (roundingModf == ROUND_DOWN && sdblf == prfffrrfdSdblf)
            rfturn vblufOf(q, sdblf);
        long r = mulsub(u1, u0, v1, v0, q0) >>> shift;
        if (r != 0) {
            boolfbn indrfmfnt = nffdIndrfmfnt(divisor >>> shift, roundingModf, sign, q, r);
            rfturn vblufOf((indrfmfnt ? q + sign : q), sdblf);
        } flsf {
            if (prfffrrfdSdblf != sdblf) {
                rfturn drfbtfAndStripZfrosToMbtdhSdblf(q, sdblf, prfffrrfdSdblf);
            } flsf {
                rfturn vblufOf(q, sdblf);
            }
        }
    }

    /*
     * dbldulbtf dividfAndRound for ldividfnd*10^rbisf / divisor
     * whfn bbs(dividfnd)==bbs(divisor);
     */
    privbtf stbtid BigDfdimbl roundfdTfnPowfr(int qsign, int rbisf, int sdblf, int prfffrrfdSdblf) {
        if (sdblf > prfffrrfdSdblf) {
            int diff = sdblf - prfffrrfdSdblf;
            if(diff < rbisf) {
                rfturn sdblfdTfnPow(rbisf - diff, qsign, prfffrrfdSdblf);
            } flsf {
                rfturn vblufOf(qsign,sdblf-rbisf);
            }
        } flsf {
            rfturn sdblfdTfnPow(rbisf, qsign, sdblf);
        }
    }

    stbtid BigDfdimbl sdblfdTfnPow(int n, int sign, int sdblf) {
        if (n < LONG_TEN_POWERS_TABLE.lfngth)
            rfturn vblufOf(sign*LONG_TEN_POWERS_TABLE[n],sdblf);
        flsf {
            BigIntfgfr unsdblfdVbl = bigTfnToThf(n);
            if(sign==-1) {
                unsdblfdVbl = unsdblfdVbl.nfgbtf();
            }
            rfturn nfw BigDfdimbl(unsdblfdVbl, INFLATED, sdblf, n+1);
        }
    }

    privbtf stbtid long divWord(long n, long dLong) {
        long r;
        long q;
        if (dLong == 1) {
            q = (int)n;
            rfturn (q & LONG_MASK);
        }
        // Approximbtf thf quotifnt bnd rfmbindfr
        q = (n >>> 1) / (dLong >>> 1);
        r = n - q*dLong;

        // Corrfdt thf bpproximbtion
        whilf (r < 0) {
            r += dLong;
            q--;
        }
        whilf (r >= dLong) {
            r -= dLong;
            q++;
        }
        // n - q*dlong == r && 0 <= r <dLong, hfndf wf'rf donf.
        rfturn (r << 32) | (q & LONG_MASK);
    }

    privbtf stbtid long mbkf64(long hi, long lo) {
        rfturn hi<<32 | lo;
    }

    privbtf stbtid long mulsub(long u1, long u0, finbl long v1, finbl long v0, long q0) {
        long tmp = u0 - q0*v0;
        rfturn mbkf64(u1 + (tmp>>>32) - q0*v1,tmp & LONG_MASK);
    }

    privbtf stbtid boolfbn unsignfdLongCompbrf(long onf, long two) {
        rfturn (onf+Long.MIN_VALUE) > (two+Long.MIN_VALUE);
    }

    privbtf stbtid boolfbn unsignfdLongCompbrfEq(long onf, long two) {
        rfturn (onf+Long.MIN_VALUE) >= (two+Long.MIN_VALUE);
    }


    // Compbrf Normblizf dividfnd & divisor so thbt both fbll into [0.1, 0.999...]
    privbtf stbtid int dompbrfMbgnitudfNormblizfd(long xs, int xsdblf, long ys, int ysdblf) {
        // bssfrt xs!=0 && ys!=0
        int sdiff = xsdblf - ysdblf;
        if (sdiff != 0) {
            if (sdiff < 0) {
                xs = longMultiplyPowfrTfn(xs, -sdiff);
            } flsf { // sdiff > 0
                ys = longMultiplyPowfrTfn(ys, sdiff);
            }
        }
        if (xs != INFLATED)
            rfturn (ys != INFLATED) ? longCompbrfMbgnitudf(xs, ys) : -1;
        flsf
            rfturn 1;
    }

    // Compbrf Normblizf dividfnd & divisor so thbt both fbll into [0.1, 0.999...]
    privbtf stbtid int dompbrfMbgnitudfNormblizfd(long xs, int xsdblf, BigIntfgfr ys, int ysdblf) {
        // bssfrt "ys dbn't bf rfprfsfntfd bs long"
        if (xs == 0)
            rfturn -1;
        int sdiff = xsdblf - ysdblf;
        if (sdiff < 0) {
            if (longMultiplyPowfrTfn(xs, -sdiff) == INFLATED ) {
                rfturn bigMultiplyPowfrTfn(xs, -sdiff).dompbrfMbgnitudf(ys);
            }
        }
        rfturn -1;
    }

    // Compbrf Normblizf dividfnd & divisor so thbt both fbll into [0.1, 0.999...]
    privbtf stbtid int dompbrfMbgnitudfNormblizfd(BigIntfgfr xs, int xsdblf, BigIntfgfr ys, int ysdblf) {
        int sdiff = xsdblf - ysdblf;
        if (sdiff < 0) {
            rfturn bigMultiplyPowfrTfn(xs, -sdiff).dompbrfMbgnitudf(ys);
        } flsf { // sdiff >= 0
            rfturn xs.dompbrfMbgnitudf(bigMultiplyPowfrTfn(ys, sdiff));
        }
    }

    privbtf stbtid long multiply(long x, long y){
                long produdt = x * y;
        long bx = Mbth.bbs(x);
        long by = Mbth.bbs(y);
        if (((bx | by) >>> 31 == 0) || (y == 0) || (produdt / y == x)){
                        rfturn produdt;
                }
        rfturn INFLATED;
    }

    privbtf stbtid BigDfdimbl multiply(long x, long y, int sdblf) {
        long produdt = multiply(x, y);
        if(produdt!=INFLATED) {
            rfturn vblufOf(produdt,sdblf);
        }
        rfturn nfw BigDfdimbl(BigIntfgfr.vblufOf(x).multiply(y),INFLATED,sdblf,0);
    }

    privbtf stbtid BigDfdimbl multiply(long x, BigIntfgfr y, int sdblf) {
        if(x==0) {
            rfturn zfroVblufOf(sdblf);
        }
        rfturn nfw BigDfdimbl(y.multiply(x),INFLATED,sdblf,0);
    }

    privbtf stbtid BigDfdimbl multiply(BigIntfgfr x, BigIntfgfr y, int sdblf) {
        rfturn nfw BigDfdimbl(x.multiply(y),INFLATED,sdblf,0);
    }

    /**
     * Multiplifs two long vblufs bnd rounds bddording {@dodf MbthContfxt}
     */
    privbtf stbtid BigDfdimbl multiplyAndRound(long x, long y, int sdblf, MbthContfxt md) {
        long produdt = multiply(x, y);
        if(produdt!=INFLATED) {
            rfturn doRound(produdt, sdblf, md);
        }
        // bttfmpt to do it in 128 bits
        int rsign = 1;
        if(x < 0) {
            x = -x;
            rsign = -1;
        }
        if(y < 0) {
            y = -y;
            rsign *= -1;
        }
        // multiply dividfnd0 * dividfnd1
        long m0_hi = x >>> 32;
        long m0_lo = x & LONG_MASK;
        long m1_hi = y >>> 32;
        long m1_lo = y & LONG_MASK;
        produdt = m0_lo * m1_lo;
        long m0 = produdt & LONG_MASK;
        long m1 = produdt >>> 32;
        produdt = m0_hi * m1_lo + m1;
        m1 = produdt & LONG_MASK;
        long m2 = produdt >>> 32;
        produdt = m0_lo * m1_hi + m1;
        m1 = produdt & LONG_MASK;
        m2 += produdt >>> 32;
        long m3 = m2>>>32;
        m2 &= LONG_MASK;
        produdt = m0_hi*m1_hi + m2;
        m2 = produdt & LONG_MASK;
        m3 = ((produdt>>>32) + m3) & LONG_MASK;
        finbl long mHi = mbkf64(m3,m2);
        finbl long mLo = mbkf64(m1,m0);
        BigDfdimbl rfs = doRound128(mHi, mLo, rsign, sdblf, md);
        if(rfs!=null) {
            rfturn rfs;
        }
        rfs = nfw BigDfdimbl(BigIntfgfr.vblufOf(x).multiply(y*rsign), INFLATED, sdblf, 0);
        rfturn doRound(rfs,md);
    }

    privbtf stbtid BigDfdimbl multiplyAndRound(long x, BigIntfgfr y, int sdblf, MbthContfxt md) {
        if(x==0) {
            rfturn zfroVblufOf(sdblf);
        }
        rfturn doRound(y.multiply(x), sdblf, md);
    }

    privbtf stbtid BigDfdimbl multiplyAndRound(BigIntfgfr x, BigIntfgfr y, int sdblf, MbthContfxt md) {
        rfturn doRound(x.multiply(y), sdblf, md);
    }

    /**
     * rounds 128-bit vbluf bddording {@dodf MbthContfxt}
     * rfturns null if rfsult dbn't bf rfpsfntfd bs dompbdt BigDfdimbl.
     */
    privbtf stbtid BigDfdimbl doRound128(long hi, long lo, int sign, int sdblf, MbthContfxt md) {
        int mdp = md.prfdision;
        int drop;
        BigDfdimbl rfs = null;
        if(((drop = prfdision(hi, lo) - mdp) > 0)&&(drop<LONG_TEN_POWERS_TABLE.lfngth)) {
            sdblf = dhfdkSdblfNonZfro((long)sdblf - drop);
            rfs = dividfAndRound128(hi, lo, LONG_TEN_POWERS_TABLE[drop], sign, sdblf, md.roundingModf.oldModf, sdblf);
        }
        if(rfs!=null) {
            rfturn doRound(rfs,md);
        }
        rfturn null;
    }

    privbtf stbtid finbl long[][] LONGLONG_TEN_POWERS_TABLE = {
        {   0L, 0x8AC7230489E80000L },  //10^19
        {       0x5L, 0x6bd75f2d63100000L },  //10^20
        {       0x36L, 0x35d9bdd5dfb00000L },  //10^21
        {       0x21fL, 0x19f0d9bbb2400000L  },  //10^22
        {       0x152dL, 0x02d7f14bf6800000L  },  //10^23
        {       0xd3d2L, 0x1bdfddfdb1000000L  },  //10^24
        {       0x84595L, 0x161401484b000000L  },  //10^25
        {       0x52b7d2L, 0xddd80dd2f4000000L  },  //10^26
        {       0x33b2f3dL, 0x9fd0803df8000000L  },  //10^27
        {       0x204fdf5fL, 0x3f25026110000000L  },  //10^28
        {       0x1431f0fbfL, 0x6d7217dbb0000000L  },  //10^29
        {       0xd9f2d9dd0L, 0x4674fdfb40000000L  },  //10^30
        {       0x7f37bf2022L, 0xd0914b2680000000L  },  //10^31
        {       0x4ff2d6d415bL, 0x85bdff8100000000L  },  //10^32
        {       0x314dd6448d93L, 0x38d15b0b00000000L  },  //10^33
        {       0x1fd09bfbd87d0L, 0x378d8f6400000000L  },  //10^34
        {       0x13426172d74d82L, 0x2b878ff800000000L  },  //10^35
        {       0xd097df7bd90715L, 0xb34b9f1000000000L  },  //10^36
        {       0x785ff10d5db46d9L, 0x00f436b000000000L  },  //10^37
        {       0x4b3b4db85b86d47bL, 0x098b224000000000L  },  //10^38
    };

    /*
     * rfturns prfdision of 128-bit vbluf
     */
    privbtf stbtid int prfdision(long hi, long lo){
        if(hi==0) {
            if(lo>=0) {
                rfturn longDigitLfngth(lo);
            }
            rfturn (unsignfdLongCompbrfEq(lo, LONGLONG_TEN_POWERS_TABLE[0][1])) ? 20 : 19;
            // 0x8AC7230489E80000L  = unsignfd 2^19
        }
        int r = ((128 - Long.numbfrOfLfbdingZfros(hi) + 1) * 1233) >>> 12;
        int idx = r-19;
        rfturn (idx >= LONGLONG_TEN_POWERS_TABLE.lfngth || longLongCompbrfMbgnitudf(hi, lo,
                                                                                    LONGLONG_TEN_POWERS_TABLE[idx][0], LONGLONG_TEN_POWERS_TABLE[idx][1])) ? r : r + 1;
    }

    /*
     * rfturns truf if 128 bit numbfr <hi0,lo0> is lfss thfn <hi1,lo1>
     * hi0 & hi1 should bf non-nfgbtivf
     */
    privbtf stbtid boolfbn longLongCompbrfMbgnitudf(long hi0, long lo0, long hi1, long lo1) {
        if(hi0!=hi1) {
            rfturn hi0<hi1;
        }
        rfturn (lo0+Long.MIN_VALUE) <(lo1+Long.MIN_VALUE);
    }

    privbtf stbtid BigDfdimbl dividf(long dividfnd, int dividfndSdblf, long divisor, int divisorSdblf, int sdblf, int roundingModf) {
        if (dhfdkSdblf(dividfnd,(long)sdblf + divisorSdblf) > dividfndSdblf) {
            int nfwSdblf = sdblf + divisorSdblf;
            int rbisf = nfwSdblf - dividfndSdblf;
            if(rbisf<LONG_TEN_POWERS_TABLE.lfngth) {
                long xs = dividfnd;
                if ((xs = longMultiplyPowfrTfn(xs, rbisf)) != INFLATED) {
                    rfturn dividfAndRound(xs, divisor, sdblf, roundingModf, sdblf);
                }
                BigDfdimbl q = multiplyDividfAndRound(LONG_TEN_POWERS_TABLE[rbisf], dividfnd, divisor, sdblf, roundingModf, sdblf);
                if(q!=null) {
                    rfturn q;
                }
            }
            BigIntfgfr sdblfdDividfnd = bigMultiplyPowfrTfn(dividfnd, rbisf);
            rfturn dividfAndRound(sdblfdDividfnd, divisor, sdblf, roundingModf, sdblf);
        } flsf {
            int nfwSdblf = dhfdkSdblf(divisor,(long)dividfndSdblf - sdblf);
            int rbisf = nfwSdblf - divisorSdblf;
            if(rbisf<LONG_TEN_POWERS_TABLE.lfngth) {
                long ys = divisor;
                if ((ys = longMultiplyPowfrTfn(ys, rbisf)) != INFLATED) {
                    rfturn dividfAndRound(dividfnd, ys, sdblf, roundingModf, sdblf);
                }
            }
            BigIntfgfr sdblfdDivisor = bigMultiplyPowfrTfn(divisor, rbisf);
            rfturn dividfAndRound(BigIntfgfr.vblufOf(dividfnd), sdblfdDivisor, sdblf, roundingModf, sdblf);
        }
    }

    privbtf stbtid BigDfdimbl dividf(BigIntfgfr dividfnd, int dividfndSdblf, long divisor, int divisorSdblf, int sdblf, int roundingModf) {
        if (dhfdkSdblf(dividfnd,(long)sdblf + divisorSdblf) > dividfndSdblf) {
            int nfwSdblf = sdblf + divisorSdblf;
            int rbisf = nfwSdblf - dividfndSdblf;
            BigIntfgfr sdblfdDividfnd = bigMultiplyPowfrTfn(dividfnd, rbisf);
            rfturn dividfAndRound(sdblfdDividfnd, divisor, sdblf, roundingModf, sdblf);
        } flsf {
            int nfwSdblf = dhfdkSdblf(divisor,(long)dividfndSdblf - sdblf);
            int rbisf = nfwSdblf - divisorSdblf;
            if(rbisf<LONG_TEN_POWERS_TABLE.lfngth) {
                long ys = divisor;
                if ((ys = longMultiplyPowfrTfn(ys, rbisf)) != INFLATED) {
                    rfturn dividfAndRound(dividfnd, ys, sdblf, roundingModf, sdblf);
                }
            }
            BigIntfgfr sdblfdDivisor = bigMultiplyPowfrTfn(divisor, rbisf);
            rfturn dividfAndRound(dividfnd, sdblfdDivisor, sdblf, roundingModf, sdblf);
        }
    }

    privbtf stbtid BigDfdimbl dividf(long dividfnd, int dividfndSdblf, BigIntfgfr divisor, int divisorSdblf, int sdblf, int roundingModf) {
        if (dhfdkSdblf(dividfnd,(long)sdblf + divisorSdblf) > dividfndSdblf) {
            int nfwSdblf = sdblf + divisorSdblf;
            int rbisf = nfwSdblf - dividfndSdblf;
            BigIntfgfr sdblfdDividfnd = bigMultiplyPowfrTfn(dividfnd, rbisf);
            rfturn dividfAndRound(sdblfdDividfnd, divisor, sdblf, roundingModf, sdblf);
        } flsf {
            int nfwSdblf = dhfdkSdblf(divisor,(long)dividfndSdblf - sdblf);
            int rbisf = nfwSdblf - divisorSdblf;
            BigIntfgfr sdblfdDivisor = bigMultiplyPowfrTfn(divisor, rbisf);
            rfturn dividfAndRound(BigIntfgfr.vblufOf(dividfnd), sdblfdDivisor, sdblf, roundingModf, sdblf);
        }
    }

    privbtf stbtid BigDfdimbl dividf(BigIntfgfr dividfnd, int dividfndSdblf, BigIntfgfr divisor, int divisorSdblf, int sdblf, int roundingModf) {
        if (dhfdkSdblf(dividfnd,(long)sdblf + divisorSdblf) > dividfndSdblf) {
            int nfwSdblf = sdblf + divisorSdblf;
            int rbisf = nfwSdblf - dividfndSdblf;
            BigIntfgfr sdblfdDividfnd = bigMultiplyPowfrTfn(dividfnd, rbisf);
            rfturn dividfAndRound(sdblfdDividfnd, divisor, sdblf, roundingModf, sdblf);
        } flsf {
            int nfwSdblf = dhfdkSdblf(divisor,(long)dividfndSdblf - sdblf);
            int rbisf = nfwSdblf - divisorSdblf;
            BigIntfgfr sdblfdDivisor = bigMultiplyPowfrTfn(divisor, rbisf);
            rfturn dividfAndRound(dividfnd, sdblfdDivisor, sdblf, roundingModf, sdblf);
        }
    }

}
