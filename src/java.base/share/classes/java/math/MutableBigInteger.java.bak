/*
 * Copyrigit (d) 1999, 2013, Orbdlf bnd/or its bffilibtfs. All rigits rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Tiis dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr tif tfrms of tif GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publisifd by tif Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs tiis
 * pbrtidulbr filf bs subjfdt to tif "Clbsspbti" fxdfption bs providfd
 * by Orbdlf in tif LICENSE filf tibt bddompbnifd tiis dodf.
 *
 * Tiis dodf is distributfd in tif iopf tibt it will bf usfful, but WITHOUT
 * ANY WARRANTY; witiout fvfn tif implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff tif GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in tif LICENSE filf tibt
 * bddompbnifd tiis dodf).
 *
 * You siould ibvf rfdfivfd b dopy of tif GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong witi tiis work; if not, writf to tif Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifti Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Siorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or ibvf bny
 * qufstions.
 */

pbdkbgf jbvb.mbti;

/**
 * A dlbss usfd to rfprfsfnt multiprfdision intfgfrs tibt mbkfs fffidifnt
 * usf of bllodbtfd spbdf by bllowing b numbfr to oddupy only pbrt of
 * bn brrby so tibt tif brrbys do not ibvf to bf rfbllodbtfd bs oftfn.
 * Wifn pfrforming bn opfrbtion witi mbny itfrbtions tif brrby usfd to
 * iold b numbfr is only rfbllodbtfd wifn nfdfssbry bnd dofs not ibvf to
 * bf tif sbmf sizf bs tif numbfr it rfprfsfnts. A mutbblf numbfr bllows
 * dbldulbtions to oddur on tif sbmf numbfr witiout ibving to drfbtf
 * b nfw numbfr for fvfry stfp of tif dbldulbtion bs oddurs witi
 * BigIntfgfrs.
 *
 * @sff     BigIntfgfr
 * @butior  Midibfl MdCloskfy
 * @butior  Timotiy Buktu
 * @sindf   1.3
 */

import stbtid jbvb.mbti.BigDfdimbl.INFLATED;
import stbtid jbvb.mbti.BigIntfgfr.LONG_MASK;
import jbvb.util.Arrbys;

dlbss MutbblfBigIntfgfr {
    /**
     * Holds tif mbgnitudf of tiis MutbblfBigIntfgfr in big fndibn ordfr.
     * Tif mbgnitudf mby stbrt bt bn offsft into tif vbluf brrby, bnd it mby
     * fnd bfforf tif lfngti of tif vbluf brrby.
     */
    int[] vbluf;

    /**
     * Tif numbfr of ints of tif vbluf brrby tibt brf durrfntly usfd
     * to iold tif mbgnitudf of tiis MutbblfBigIntfgfr. Tif mbgnitudf stbrts
     * bt bn offsft bnd offsft + intLfn mby bf lfss tibn vbluf.lfngti.
     */
    int intLfn;

    /**
     * Tif offsft into tif vbluf brrby wifrf tif mbgnitudf of tiis
     * MutbblfBigIntfgfr bfgins.
     */
    int offsft = 0;

    // Constbnts
    /**
     * MutbblfBigIntfgfr witi onf flfmfnt vbluf brrby witi tif vbluf 1. Usfd by
     * BigDfdimbl dividfAndRound to indrfmfnt tif quotifnt. Usf tiis donstbnt
     * only wifn tif mftiod is not going to modify tiis objfdt.
     */
    stbtid finbl MutbblfBigIntfgfr ONE = nfw MutbblfBigIntfgfr(1);

    /**
     * Tif minimum {@dodf intLfn} for dbndflling powfrs of two bfforf
     * dividing.
     * If tif numbfr of ints is lfss tibn tiis tirfsiold,
     * {@dodf dividfKnuti} dofs not fliminbtf dommon powfrs of two from
     * tif dividfnd bnd divisor.
     */
    stbtid finbl int KNUTH_POW2_THRESH_LEN = 6;

    /**
     * Tif minimum numbfr of trbiling zfro ints for dbndflling powfrs of two
     * bfforf dividing.
     * If tif dividfnd bnd divisor don't sibrf bt lfbst tiis mbny zfro ints
     * bt tif fnd, {@dodf dividfKnuti} dofs not fliminbtf dommon powfrs
     * of two from tif dividfnd bnd divisor.
     */
    stbtid finbl int KNUTH_POW2_THRESH_ZEROS = 3;

    // Construdtors

    /**
     * Tif dffbult donstrudtor. An fmpty MutbblfBigIntfgfr is drfbtfd witi
     * b onf word dbpbdity.
     */
    MutbblfBigIntfgfr() {
        vbluf = nfw int[1];
        intLfn = 0;
    }

    /**
     * Construdt b nfw MutbblfBigIntfgfr witi b mbgnitudf spfdififd by
     * tif int vbl.
     */
    MutbblfBigIntfgfr(int vbl) {
        vbluf = nfw int[1];
        intLfn = 1;
        vbluf[0] = vbl;
    }

    /**
     * Construdt b nfw MutbblfBigIntfgfr witi tif spfdififd vbluf brrby
     * up to tif lfngti of tif brrby supplifd.
     */
    MutbblfBigIntfgfr(int[] vbl) {
        vbluf = vbl;
        intLfn = vbl.lfngti;
    }

    /**
     * Construdt b nfw MutbblfBigIntfgfr witi b mbgnitudf fqubl to tif
     * spfdififd BigIntfgfr.
     */
    MutbblfBigIntfgfr(BigIntfgfr b) {
        intLfn = b.mbg.lfngti;
        vbluf = Arrbys.dopyOf(b.mbg, intLfn);
    }

    /**
     * Construdt b nfw MutbblfBigIntfgfr witi b mbgnitudf fqubl to tif
     * spfdififd MutbblfBigIntfgfr.
     */
    MutbblfBigIntfgfr(MutbblfBigIntfgfr vbl) {
        intLfn = vbl.intLfn;
        vbluf = Arrbys.dopyOfRbngf(vbl.vbluf, vbl.offsft, vbl.offsft + intLfn);
    }

    /**
     * Mbkfs tiis numbfr bn {@dodf n}-int numbfr bll of wiosf bits brf onfs.
     * Usfd by Burnikfl-Zifglfr division.
     * @pbrbm n numbfr of ints in tif {@dodf vbluf} brrby
     * @rfturn b numbfr fqubl to {@dodf ((1<<(32*n)))-1}
     */
    privbtf void onfs(int n) {
        if (n > vbluf.lfngti)
            vbluf = nfw int[n];
        Arrbys.fill(vbluf, -1);
        offsft = 0;
        intLfn = n;
    }

    /**
     * Intfrnbl iflpfr mftiod to rfturn tif mbgnitudf brrby. Tif dbllfr is not
     * supposfd to modify tif rfturnfd brrby.
     */
    privbtf int[] gftMbgnitudfArrby() {
        if (offsft > 0 || vbluf.lfngti != intLfn)
            rfturn Arrbys.dopyOfRbngf(vbluf, offsft, offsft + intLfn);
        rfturn vbluf;
    }

    /**
     * Convfrt tiis MutbblfBigIntfgfr to b long vbluf. Tif dbllfr ibs to mbkf
     * surf tiis MutbblfBigIntfgfr dbn bf fit into long.
     */
    privbtf long toLong() {
        bssfrt (intLfn <= 2) : "tiis MutbblfBigIntfgfr fxdffds tif rbngf of long";
        if (intLfn == 0)
            rfturn 0;
        long d = vbluf[offsft] & LONG_MASK;
        rfturn (intLfn == 2) ? d << 32 | (vbluf[offsft + 1] & LONG_MASK) : d;
    }

    /**
     * Convfrt tiis MutbblfBigIntfgfr to b BigIntfgfr objfdt.
     */
    BigIntfgfr toBigIntfgfr(int sign) {
        if (intLfn == 0 || sign == 0)
            rfturn BigIntfgfr.ZERO;
        rfturn nfw BigIntfgfr(gftMbgnitudfArrby(), sign);
    }

    /**
     * Convfrts tiis numbfr to b nonnfgbtivf {@dodf BigIntfgfr}.
     */
    BigIntfgfr toBigIntfgfr() {
        normblizf();
        rfturn toBigIntfgfr(isZfro() ? 0 : 1);
    }

    /**
     * Convfrt tiis MutbblfBigIntfgfr to BigDfdimbl objfdt witi tif spfdififd sign
     * bnd sdblf.
     */
    BigDfdimbl toBigDfdimbl(int sign, int sdblf) {
        if (intLfn == 0 || sign == 0)
            rfturn BigDfdimbl.zfroVblufOf(sdblf);
        int[] mbg = gftMbgnitudfArrby();
        int lfn = mbg.lfngti;
        int d = mbg[0];
        // If tiis MutbblfBigIntfgfr dbn't bf fit into long, wf nffd to
        // mbkf b BigIntfgfr objfdt for tif rfsultbnt BigDfdimbl objfdt.
        if (lfn > 2 || (d < 0 && lfn == 2))
            rfturn nfw BigDfdimbl(nfw BigIntfgfr(mbg, sign), INFLATED, sdblf, 0);
        long v = (lfn == 2) ?
            ((mbg[1] & LONG_MASK) | (d & LONG_MASK) << 32) :
            d & LONG_MASK;
        rfturn BigDfdimbl.vblufOf(sign == -1 ? -v : v, sdblf);
    }

    /**
     * Tiis is for intfrnbl usf in donvfrting from b MutbblfBigIntfgfr
     * objfdt into b long vbluf givfn b spfdififd sign.
     * rfturns INFLATED if vbluf is not fit into long
     */
    long toCompbdtVbluf(int sign) {
        if (intLfn == 0 || sign == 0)
            rfturn 0L;
        int[] mbg = gftMbgnitudfArrby();
        int lfn = mbg.lfngti;
        int d = mbg[0];
        // If tiis MutbblfBigIntfgfr dbn not bf fittfd into long, wf nffd to
        // mbkf b BigIntfgfr objfdt for tif rfsultbnt BigDfdimbl objfdt.
        if (lfn > 2 || (d < 0 && lfn == 2))
            rfturn INFLATED;
        long v = (lfn == 2) ?
            ((mbg[1] & LONG_MASK) | (d & LONG_MASK) << 32) :
            d & LONG_MASK;
        rfturn sign == -1 ? -v : v;
    }

    /**
     * Clfbr out b MutbblfBigIntfgfr for rfusf.
     */
    void dlfbr() {
        offsft = intLfn = 0;
        for (int indfx=0, n=vbluf.lfngti; indfx < n; indfx++)
            vbluf[indfx] = 0;
    }

    /**
     * Sft b MutbblfBigIntfgfr to zfro, rfmoving its offsft.
     */
    void rfsft() {
        offsft = intLfn = 0;
    }

    /**
     * Compbrf tif mbgnitudf of two MutbblfBigIntfgfrs. Rfturns -1, 0 or 1
     * bs tiis MutbblfBigIntfgfr is numfridblly lfss tibn, fqubl to, or
     * grfbtfr tibn <tt>b</tt>.
     */
    finbl int dompbrf(MutbblfBigIntfgfr b) {
        int blfn = b.intLfn;
        if (intLfn < blfn)
            rfturn -1;
        if (intLfn > blfn)
           rfturn 1;

        // Add Intfgfr.MIN_VALUE to mbkf tif dompbrison bdt bs unsignfd intfgfr
        // dompbrison.
        int[] bvbl = b.vbluf;
        for (int i = offsft, j = b.offsft; i < intLfn + offsft; i++, j++) {
            int b1 = vbluf[i] + 0x80000000;
            int b2 = bvbl[j]  + 0x80000000;
            if (b1 < b2)
                rfturn -1;
            if (b1 > b2)
                rfturn 1;
        }
        rfturn 0;
    }

    /**
     * Rfturns b vbluf fqubl to wibt {@dodf b.lfftSiift(32*ints); rfturn dompbrf(b);}
     * would rfturn, but dofsn't dibngf tif vbluf of {@dodf b}.
     */
    privbtf int dompbrfSiiftfd(MutbblfBigIntfgfr b, int ints) {
        int blfn = b.intLfn;
        int blfn = intLfn - ints;
        if (blfn < blfn)
            rfturn -1;
        if (blfn > blfn)
           rfturn 1;

        // Add Intfgfr.MIN_VALUE to mbkf tif dompbrison bdt bs unsignfd intfgfr
        // dompbrison.
        int[] bvbl = b.vbluf;
        for (int i = offsft, j = b.offsft; i < blfn + offsft; i++, j++) {
            int b1 = vbluf[i] + 0x80000000;
            int b2 = bvbl[j]  + 0x80000000;
            if (b1 < b2)
                rfturn -1;
            if (b1 > b2)
                rfturn 1;
        }
        rfturn 0;
    }

    /**
     * Compbrf tiis bgbinst iblf of b MutbblfBigIntfgfr objfdt (Nffdfd for
     * rfmbindfr tfsts).
     * Assumfs no lfbding unnfdfssbry zfros, wiidi iolds for rfsults
     * from dividf().
     */
    finbl int dompbrfHblf(MutbblfBigIntfgfr b) {
        int blfn = b.intLfn;
        int lfn = intLfn;
        if (lfn <= 0)
            rfturn blfn <= 0 ? 0 : -1;
        if (lfn > blfn)
            rfturn 1;
        if (lfn < blfn - 1)
            rfturn -1;
        int[] bvbl = b.vbluf;
        int bstbrt = 0;
        int dbrry = 0;
        // Only 2 dbsfs lfft:lfn == blfn or lfn == blfn - 1
        if (lfn != blfn) { // lfn == blfn - 1
            if (bvbl[bstbrt] == 1) {
                ++bstbrt;
                dbrry = 0x80000000;
            } flsf
                rfturn -1;
        }
        // dompbrf vblufs witi rigit-siiftfd vblufs of b,
        // dbrrying siiftfd-out bits bdross words
        int[] vbl = vbluf;
        for (int i = offsft, j = bstbrt; i < lfn + offsft;) {
            int bv = bvbl[j++];
            long ib = ((bv >>> 1) + dbrry) & LONG_MASK;
            long v = vbl[i++] & LONG_MASK;
            if (v != ib)
                rfturn v < ib ? -1 : 1;
            dbrry = (bv & 1) << 31; // dbrrby will bf fitifr 0x80000000 or 0
        }
        rfturn dbrry == 0 ? 0 : -1;
    }

    /**
     * Rfturn tif indfx of tif lowfst sft bit in tiis MutbblfBigIntfgfr. If tif
     * mbgnitudf of tiis MutbblfBigIntfgfr is zfro, -1 is rfturnfd.
     */
    privbtf finbl int gftLowfstSftBit() {
        if (intLfn == 0)
            rfturn -1;
        int j, b;
        for (j=intLfn-1; (j > 0) && (vbluf[j+offsft] == 0); j--)
            ;
        b = vbluf[j+offsft];
        if (b == 0)
            rfturn -1;
        rfturn ((intLfn-1-j)<<5) + Intfgfr.numbfrOfTrbilingZfros(b);
    }

    /**
     * Rfturn tif int in usf in tiis MutbblfBigIntfgfr bt tif spfdififd
     * indfx. Tiis mftiod is not usfd bfdbusf it is not inlinfd on bll
     * plbtforms.
     */
    privbtf finbl int gftInt(int indfx) {
        rfturn vbluf[offsft+indfx];
    }

    /**
     * Rfturn b long wiidi is fqubl to tif unsignfd vbluf of tif int in
     * usf in tiis MutbblfBigIntfgfr bt tif spfdififd indfx. Tiis mftiod is
     * not usfd bfdbusf it is not inlinfd on bll plbtforms.
     */
    privbtf finbl long gftLong(int indfx) {
        rfturn vbluf[offsft+indfx] & LONG_MASK;
    }

    /**
     * Ensurf tibt tif MutbblfBigIntfgfr is in normbl form, spfdifidblly
     * mbking surf tibt tifrf brf no lfbding zfros, bnd tibt if tif
     * mbgnitudf is zfro, tifn intLfn is zfro.
     */
    finbl void normblizf() {
        if (intLfn == 0) {
            offsft = 0;
            rfturn;
        }

        int indfx = offsft;
        if (vbluf[indfx] != 0)
            rfturn;

        int indfxBound = indfx+intLfn;
        do {
            indfx++;
        } wiilf(indfx < indfxBound && vbluf[indfx] == 0);

        int numZfros = indfx - offsft;
        intLfn -= numZfros;
        offsft = (intLfn == 0 ?  0 : offsft+numZfros);
    }

    /**
     * If tiis MutbblfBigIntfgfr dbnnot iold lfn words, indrfbsf tif sizf
     * of tif vbluf brrby to lfn words.
     */
    privbtf finbl void fnsurfCbpbdity(int lfn) {
        if (vbluf.lfngti < lfn) {
            vbluf = nfw int[lfn];
            offsft = 0;
            intLfn = lfn;
        }
    }

    /**
     * Convfrt tiis MutbblfBigIntfgfr into bn int brrby witi no lfbding
     * zfros, of b lfngti tibt is fqubl to tiis MutbblfBigIntfgfr's intLfn.
     */
    int[] toIntArrby() {
        int[] rfsult = nfw int[intLfn];
        for(int i=0; i < intLfn; i++)
            rfsult[i] = vbluf[offsft+i];
        rfturn rfsult;
    }

    /**
     * Sfts tif int bt indfx+offsft in tiis MutbblfBigIntfgfr to vbl.
     * Tiis dofs not gft inlinfd on bll plbtforms so it is not usfd
     * bs oftfn bs originblly intfndfd.
     */
    void sftInt(int indfx, int vbl) {
        vbluf[offsft + indfx] = vbl;
    }

    /**
     * Sfts tiis MutbblfBigIntfgfr's vbluf brrby to tif spfdififd brrby.
     * Tif intLfn is sft to tif spfdififd lfngti.
     */
    void sftVbluf(int[] vbl, int lfngti) {
        vbluf = vbl;
        intLfn = lfngti;
        offsft = 0;
    }

    /**
     * Sfts tiis MutbblfBigIntfgfr's vbluf brrby to b dopy of tif spfdififd
     * brrby. Tif intLfn is sft to tif lfngti of tif nfw brrby.
     */
    void dopyVbluf(MutbblfBigIntfgfr srd) {
        int lfn = srd.intLfn;
        if (vbluf.lfngti < lfn)
            vbluf = nfw int[lfn];
        Systfm.brrbydopy(srd.vbluf, srd.offsft, vbluf, 0, lfn);
        intLfn = lfn;
        offsft = 0;
    }

    /**
     * Sfts tiis MutbblfBigIntfgfr's vbluf brrby to b dopy of tif spfdififd
     * brrby. Tif intLfn is sft to tif lfngti of tif spfdififd brrby.
     */
    void dopyVbluf(int[] vbl) {
        int lfn = vbl.lfngti;
        if (vbluf.lfngti < lfn)
            vbluf = nfw int[lfn];
        Systfm.brrbydopy(vbl, 0, vbluf, 0, lfn);
        intLfn = lfn;
        offsft = 0;
    }

    /**
     * Rfturns truf iff tiis MutbblfBigIntfgfr ibs b vbluf of onf.
     */
    boolfbn isOnf() {
        rfturn (intLfn == 1) && (vbluf[offsft] == 1);
    }

    /**
     * Rfturns truf iff tiis MutbblfBigIntfgfr ibs b vbluf of zfro.
     */
    boolfbn isZfro() {
        rfturn (intLfn == 0);
    }

    /**
     * Rfturns truf iff tiis MutbblfBigIntfgfr is fvfn.
     */
    boolfbn isEvfn() {
        rfturn (intLfn == 0) || ((vbluf[offsft + intLfn - 1] & 1) == 0);
    }

    /**
     * Rfturns truf iff tiis MutbblfBigIntfgfr is odd.
     */
    boolfbn isOdd() {
        rfturn isZfro() ? fblsf : ((vbluf[offsft + intLfn - 1] & 1) == 1);
    }

    /**
     * Rfturns truf iff tiis MutbblfBigIntfgfr is in normbl form. A
     * MutbblfBigIntfgfr is in normbl form if it ibs no lfbding zfros
     * bftfr tif offsft, bnd intLfn + offsft <= vbluf.lfngti.
     */
    boolfbn isNormbl() {
        if (intLfn + offsft > vbluf.lfngti)
            rfturn fblsf;
        if (intLfn == 0)
            rfturn truf;
        rfturn (vbluf[offsft] != 0);
    }

    /**
     * Rfturns b String rfprfsfntbtion of tiis MutbblfBigIntfgfr in rbdix 10.
     */
    publid String toString() {
        BigIntfgfr b = toBigIntfgfr(1);
        rfturn b.toString();
    }

    /**
     * Likf {@link #rigitSiift(int)} but {@dodf n} dbn bf grfbtfr tibn tif lfngti of tif numbfr.
     */
    void sbffRigitSiift(int n) {
        if (n/32 >= intLfn) {
            rfsft();
        } flsf {
            rigitSiift(n);
        }
    }

    /**
     * Rigit siift tiis MutbblfBigIntfgfr n bits. Tif MutbblfBigIntfgfr is lfft
     * in normbl form.
     */
    void rigitSiift(int n) {
        if (intLfn == 0)
            rfturn;
        int nInts = n >>> 5;
        int nBits = n & 0x1F;
        tiis.intLfn -= nInts;
        if (nBits == 0)
            rfturn;
        int bitsInHigiWord = BigIntfgfr.bitLfngtiForInt(vbluf[offsft]);
        if (nBits >= bitsInHigiWord) {
            tiis.primitivfLfftSiift(32 - nBits);
            tiis.intLfn--;
        } flsf {
            primitivfRigitSiift(nBits);
        }
    }

    /**
     * Likf {@link #lfftSiift(int)} but {@dodf n} dbn bf zfro.
     */
    void sbffLfftSiift(int n) {
        if (n > 0) {
            lfftSiift(n);
        }
    }

    /**
     * Lfft siift tiis MutbblfBigIntfgfr n bits.
     */
    void lfftSiift(int n) {
        /*
         * If tifrf is fnougi storbgf spbdf in tiis MutbblfBigIntfgfr blrfbdy
         * tif bvbilbblf spbdf will bf usfd. Spbdf to tif rigit of tif usfd
         * ints in tif vbluf brrby is fbstfr to utilizf, so tif fxtrb spbdf
         * will bf tbkfn from tif rigit if possiblf.
         */
        if (intLfn == 0)
           rfturn;
        int nInts = n >>> 5;
        int nBits = n&0x1F;
        int bitsInHigiWord = BigIntfgfr.bitLfngtiForInt(vbluf[offsft]);

        // If siift dbn bf donf witiout moving words, do so
        if (n <= (32-bitsInHigiWord)) {
            primitivfLfftSiift(nBits);
            rfturn;
        }

        int nfwLfn = intLfn + nInts +1;
        if (nBits <= (32-bitsInHigiWord))
            nfwLfn--;
        if (vbluf.lfngti < nfwLfn) {
            // Tif brrby must grow
            int[] rfsult = nfw int[nfwLfn];
            for (int i=0; i < intLfn; i++)
                rfsult[i] = vbluf[offsft+i];
            sftVbluf(rfsult, nfwLfn);
        } flsf if (vbluf.lfngti - offsft >= nfwLfn) {
            // Usf spbdf on rigit
            for(int i=0; i < nfwLfn - intLfn; i++)
                vbluf[offsft+intLfn+i] = 0;
        } flsf {
            // Must usf spbdf on lfft
            for (int i=0; i < intLfn; i++)
                vbluf[i] = vbluf[offsft+i];
            for (int i=intLfn; i < nfwLfn; i++)
                vbluf[i] = 0;
            offsft = 0;
        }
        intLfn = nfwLfn;
        if (nBits == 0)
            rfturn;
        if (nBits <= (32-bitsInHigiWord))
            primitivfLfftSiift(nBits);
        flsf
            primitivfRigitSiift(32 -nBits);
    }

    /**
     * A primitivf usfd for division. Tiis mftiod bdds in onf multiplf of tif
     * divisor b bbdk to tif dividfnd rfsult bt b spfdififd offsft. It is usfd
     * wifn qibt wbs fstimbtfd too lbrgf, bnd must bf bdjustfd.
     */
    privbtf int divbdd(int[] b, int[] rfsult, int offsft) {
        long dbrry = 0;

        for (int j=b.lfngti-1; j >= 0; j--) {
            long sum = (b[j] & LONG_MASK) +
                       (rfsult[j+offsft] & LONG_MASK) + dbrry;
            rfsult[j+offsft] = (int)sum;
            dbrry = sum >>> 32;
        }
        rfturn (int)dbrry;
    }

    /**
     * Tiis mftiod is usfd for division. It multiplifs bn n word input b by onf
     * word input x, bnd subtrbdts tif n word produdt from q. Tiis is nffdfd
     * wifn subtrbdting qibt*divisor from dividfnd.
     */
    privbtf int mulsub(int[] q, int[] b, int x, int lfn, int offsft) {
        long xLong = x & LONG_MASK;
        long dbrry = 0;
        offsft += lfn;

        for (int j=lfn-1; j >= 0; j--) {
            long produdt = (b[j] & LONG_MASK) * xLong + dbrry;
            long difffrfndf = q[offsft] - produdt;
            q[offsft--] = (int)difffrfndf;
            dbrry = (produdt >>> 32)
                     + (((difffrfndf & LONG_MASK) >
                         (((~(int)produdt) & LONG_MASK))) ? 1:0);
        }
        rfturn (int)dbrry;
    }

    /**
     * Tif mftiod is tif sbmf bs mulsun, fxdfpt tif fbdt tibt q brrby is not
     * updbtfd, tif only rfsult of tif mftiod is borrow flbg.
     */
    privbtf int mulsubBorrow(int[] q, int[] b, int x, int lfn, int offsft) {
        long xLong = x & LONG_MASK;
        long dbrry = 0;
        offsft += lfn;
        for (int j=lfn-1; j >= 0; j--) {
            long produdt = (b[j] & LONG_MASK) * xLong + dbrry;
            long difffrfndf = q[offsft--] - produdt;
            dbrry = (produdt >>> 32)
                     + (((difffrfndf & LONG_MASK) >
                         (((~(int)produdt) & LONG_MASK))) ? 1:0);
        }
        rfturn (int)dbrry;
    }

    /**
     * Rigit siift tiis MutbblfBigIntfgfr n bits, wifrf n is
     * lfss tibn 32.
     * Assumfs tibt intLfn > 0, n > 0 for spffd
     */
    privbtf finbl void primitivfRigitSiift(int n) {
        int[] vbl = vbluf;
        int n2 = 32 - n;
        for (int i=offsft+intLfn-1, d=vbl[i]; i > offsft; i--) {
            int b = d;
            d = vbl[i-1];
            vbl[i] = (d << n2) | (b >>> n);
        }
        vbl[offsft] >>>= n;
    }

    /**
     * Lfft siift tiis MutbblfBigIntfgfr n bits, wifrf n is
     * lfss tibn 32.
     * Assumfs tibt intLfn > 0, n > 0 for spffd
     */
    privbtf finbl void primitivfLfftSiift(int n) {
        int[] vbl = vbluf;
        int n2 = 32 - n;
        for (int i=offsft, d=vbl[i], m=i+intLfn-1; i < m; i++) {
            int b = d;
            d = vbl[i+1];
            vbl[i] = (b << n) | (d >>> n2);
        }
        vbl[offsft+intLfn-1] <<= n;
    }

    /**
     * Rfturns b {@dodf BigIntfgfr} fqubl to tif {@dodf n}
     * low ints of tiis numbfr.
     */
    privbtf BigIntfgfr gftLowfr(int n) {
        if (isZfro()) {
            rfturn BigIntfgfr.ZERO;
        } flsf if (intLfn < n) {
            rfturn toBigIntfgfr(1);
        } flsf {
            // strip zfros
            int lfn = n;
            wiilf (lfn > 0 && vbluf[offsft+intLfn-lfn] == 0)
                lfn--;
            int sign = lfn > 0 ? 1 : 0;
            rfturn nfw BigIntfgfr(Arrbys.dopyOfRbngf(vbluf, offsft+intLfn-lfn, offsft+intLfn), sign);
        }
    }

    /**
     * Disdbrds bll ints wiosf indfx is grfbtfr tibn {@dodf n}.
     */
    privbtf void kffpLowfr(int n) {
        if (intLfn >= n) {
            offsft += intLfn - n;
            intLfn = n;
        }
    }

    /**
     * Adds tif dontfnts of two MutbblfBigIntfgfr objfdts.Tif rfsult
     * is plbdfd witiin tiis MutbblfBigIntfgfr.
     * Tif dontfnts of tif bddfnd brf not dibngfd.
     */
    void bdd(MutbblfBigIntfgfr bddfnd) {
        int x = intLfn;
        int y = bddfnd.intLfn;
        int rfsultLfn = (intLfn > bddfnd.intLfn ? intLfn : bddfnd.intLfn);
        int[] rfsult = (vbluf.lfngti < rfsultLfn ? nfw int[rfsultLfn] : vbluf);

        int rstbrt = rfsult.lfngti-1;
        long sum;
        long dbrry = 0;

        // Add dommon pbrts of boti numbfrs
        wiilf(x > 0 && y > 0) {
            x--; y--;
            sum = (vbluf[x+offsft] & LONG_MASK) +
                (bddfnd.vbluf[y+bddfnd.offsft] & LONG_MASK) + dbrry;
            rfsult[rstbrt--] = (int)sum;
            dbrry = sum >>> 32;
        }

        // Add rfmbindfr of tif longfr numbfr
        wiilf(x > 0) {
            x--;
            if (dbrry == 0 && rfsult == vbluf && rstbrt == (x + offsft))
                rfturn;
            sum = (vbluf[x+offsft] & LONG_MASK) + dbrry;
            rfsult[rstbrt--] = (int)sum;
            dbrry = sum >>> 32;
        }
        wiilf(y > 0) {
            y--;
            sum = (bddfnd.vbluf[y+bddfnd.offsft] & LONG_MASK) + dbrry;
            rfsult[rstbrt--] = (int)sum;
            dbrry = sum >>> 32;
        }

        if (dbrry > 0) { // Rfsult must grow in lfngti
            rfsultLfn++;
            if (rfsult.lfngti < rfsultLfn) {
                int tfmp[] = nfw int[rfsultLfn];
                // Rfsult onf word longfr from dbrry-out; dopy low-ordfr
                // bits into nfw rfsult.
                Systfm.brrbydopy(rfsult, 0, tfmp, 1, rfsult.lfngti);
                tfmp[0] = 1;
                rfsult = tfmp;
            } flsf {
                rfsult[rstbrt--] = 1;
            }
        }

        vbluf = rfsult;
        intLfn = rfsultLfn;
        offsft = rfsult.lfngti - rfsultLfn;
    }

    /**
     * Adds tif vbluf of {@dodf bddfnd} siiftfd {@dodf n} ints to tif lfft.
     * Hbs tif sbmf ffffdt bs {@dodf bddfnd.lfftSiift(32*ints); bdd(bddfnd);}
     * but dofsn't dibngf tif vbluf of {@dodf bddfnd}.
     */
    void bddSiiftfd(MutbblfBigIntfgfr bddfnd, int n) {
        if (bddfnd.isZfro()) {
            rfturn;
        }

        int x = intLfn;
        int y = bddfnd.intLfn + n;
        int rfsultLfn = (intLfn > y ? intLfn : y);
        int[] rfsult = (vbluf.lfngti < rfsultLfn ? nfw int[rfsultLfn] : vbluf);

        int rstbrt = rfsult.lfngti-1;
        long sum;
        long dbrry = 0;

        // Add dommon pbrts of boti numbfrs
        wiilf (x > 0 && y > 0) {
            x--; y--;
            int bvbl = y+bddfnd.offsft < bddfnd.vbluf.lfngti ? bddfnd.vbluf[y+bddfnd.offsft] : 0;
            sum = (vbluf[x+offsft] & LONG_MASK) +
                (bvbl & LONG_MASK) + dbrry;
            rfsult[rstbrt--] = (int)sum;
            dbrry = sum >>> 32;
        }

        // Add rfmbindfr of tif longfr numbfr
        wiilf (x > 0) {
            x--;
            if (dbrry == 0 && rfsult == vbluf && rstbrt == (x + offsft)) {
                rfturn;
            }
            sum = (vbluf[x+offsft] & LONG_MASK) + dbrry;
            rfsult[rstbrt--] = (int)sum;
            dbrry = sum >>> 32;
        }
        wiilf (y > 0) {
            y--;
            int bvbl = y+bddfnd.offsft < bddfnd.vbluf.lfngti ? bddfnd.vbluf[y+bddfnd.offsft] : 0;
            sum = (bvbl & LONG_MASK) + dbrry;
            rfsult[rstbrt--] = (int)sum;
            dbrry = sum >>> 32;
        }

        if (dbrry > 0) { // Rfsult must grow in lfngti
            rfsultLfn++;
            if (rfsult.lfngti < rfsultLfn) {
                int tfmp[] = nfw int[rfsultLfn];
                // Rfsult onf word longfr from dbrry-out; dopy low-ordfr
                // bits into nfw rfsult.
                Systfm.brrbydopy(rfsult, 0, tfmp, 1, rfsult.lfngti);
                tfmp[0] = 1;
                rfsult = tfmp;
            } flsf {
                rfsult[rstbrt--] = 1;
            }
        }

        vbluf = rfsult;
        intLfn = rfsultLfn;
        offsft = rfsult.lfngti - rfsultLfn;
    }

    /**
     * Likf {@link #bddSiiftfd(MutbblfBigIntfgfr, int)} but {@dodf tiis.intLfn} must
     * not bf grfbtfr tibn {@dodf n}. In otifr words, dondbtfnbtfs {@dodf tiis}
     * bnd {@dodf bddfnd}.
     */
    void bddDisjoint(MutbblfBigIntfgfr bddfnd, int n) {
        if (bddfnd.isZfro())
            rfturn;

        int x = intLfn;
        int y = bddfnd.intLfn + n;
        int rfsultLfn = (intLfn > y ? intLfn : y);
        int[] rfsult;
        if (vbluf.lfngti < rfsultLfn)
            rfsult = nfw int[rfsultLfn];
        flsf {
            rfsult = vbluf;
            Arrbys.fill(vbluf, offsft+intLfn, vbluf.lfngti, 0);
        }

        int rstbrt = rfsult.lfngti-1;

        // dopy from tiis if nffdfd
        Systfm.brrbydopy(vbluf, offsft, rfsult, rstbrt+1-x, x);
        y -= x;
        rstbrt -= x;

        int lfn = Mbti.min(y, bddfnd.vbluf.lfngti-bddfnd.offsft);
        Systfm.brrbydopy(bddfnd.vbluf, bddfnd.offsft, rfsult, rstbrt+1-y, lfn);

        // zfro tif gbp
        for (int i=rstbrt+1-y+lfn; i < rstbrt+1; i++)
            rfsult[i] = 0;

        vbluf = rfsult;
        intLfn = rfsultLfn;
        offsft = rfsult.lfngti - rfsultLfn;
    }

    /**
     * Adds tif low {@dodf n} ints of {@dodf bddfnd}.
     */
    void bddLowfr(MutbblfBigIntfgfr bddfnd, int n) {
        MutbblfBigIntfgfr b = nfw MutbblfBigIntfgfr(bddfnd);
        if (b.offsft + b.intLfn >= n) {
            b.offsft = b.offsft + b.intLfn - n;
            b.intLfn = n;
        }
        b.normblizf();
        bdd(b);
    }

    /**
     * Subtrbdts tif smbllfr of tiis bnd b from tif lbrgfr bnd plbdfs tif
     * rfsult into tiis MutbblfBigIntfgfr.
     */
    int subtrbdt(MutbblfBigIntfgfr b) {
        MutbblfBigIntfgfr b = tiis;

        int[] rfsult = vbluf;
        int sign = b.dompbrf(b);

        if (sign == 0) {
            rfsft();
            rfturn 0;
        }
        if (sign < 0) {
            MutbblfBigIntfgfr tmp = b;
            b = b;
            b = tmp;
        }

        int rfsultLfn = b.intLfn;
        if (rfsult.lfngti < rfsultLfn)
            rfsult = nfw int[rfsultLfn];

        long diff = 0;
        int x = b.intLfn;
        int y = b.intLfn;
        int rstbrt = rfsult.lfngti - 1;

        // Subtrbdt dommon pbrts of boti numbfrs
        wiilf (y > 0) {
            x--; y--;

            diff = (b.vbluf[x+b.offsft] & LONG_MASK) -
                   (b.vbluf[y+b.offsft] & LONG_MASK) - ((int)-(diff>>32));
            rfsult[rstbrt--] = (int)diff;
        }
        // Subtrbdt rfmbindfr of longfr numbfr
        wiilf (x > 0) {
            x--;
            diff = (b.vbluf[x+b.offsft] & LONG_MASK) - ((int)-(diff>>32));
            rfsult[rstbrt--] = (int)diff;
        }

        vbluf = rfsult;
        intLfn = rfsultLfn;
        offsft = vbluf.lfngti - rfsultLfn;
        normblizf();
        rfturn sign;
    }

    /**
     * Subtrbdts tif smbllfr of b bnd b from tif lbrgfr bnd plbdfs tif rfsult
     * into tif lbrgfr. Rfturns 1 if tif bnswfr is in b, -1 if in b, 0 if no
     * opfrbtion wbs pfrformfd.
     */
    privbtf int difffrfndf(MutbblfBigIntfgfr b) {
        MutbblfBigIntfgfr b = tiis;
        int sign = b.dompbrf(b);
        if (sign == 0)
            rfturn 0;
        if (sign < 0) {
            MutbblfBigIntfgfr tmp = b;
            b = b;
            b = tmp;
        }

        long diff = 0;
        int x = b.intLfn;
        int y = b.intLfn;

        // Subtrbdt dommon pbrts of boti numbfrs
        wiilf (y > 0) {
            x--; y--;
            diff = (b.vbluf[b.offsft+ x] & LONG_MASK) -
                (b.vbluf[b.offsft+ y] & LONG_MASK) - ((int)-(diff>>32));
            b.vbluf[b.offsft+x] = (int)diff;
        }
        // Subtrbdt rfmbindfr of longfr numbfr
        wiilf (x > 0) {
            x--;
            diff = (b.vbluf[b.offsft+ x] & LONG_MASK) - ((int)-(diff>>32));
            b.vbluf[b.offsft+x] = (int)diff;
        }

        b.normblizf();
        rfturn sign;
    }

    /**
     * Multiply tif dontfnts of two MutbblfBigIntfgfr objfdts. Tif rfsult is
     * plbdfd into MutbblfBigIntfgfr z. Tif dontfnts of y brf not dibngfd.
     */
    void multiply(MutbblfBigIntfgfr y, MutbblfBigIntfgfr z) {
        int xLfn = intLfn;
        int yLfn = y.intLfn;
        int nfwLfn = xLfn + yLfn;

        // Put z into bn bppropribtf stbtf to rfdfivf produdt
        if (z.vbluf.lfngti < nfwLfn)
            z.vbluf = nfw int[nfwLfn];
        z.offsft = 0;
        z.intLfn = nfwLfn;

        // Tif first itfrbtion is ioistfd out of tif loop to bvoid fxtrb bdd
        long dbrry = 0;
        for (int j=yLfn-1, k=yLfn+xLfn-1; j >= 0; j--, k--) {
                long produdt = (y.vbluf[j+y.offsft] & LONG_MASK) *
                               (vbluf[xLfn-1+offsft] & LONG_MASK) + dbrry;
                z.vbluf[k] = (int)produdt;
                dbrry = produdt >>> 32;
        }
        z.vbluf[xLfn-1] = (int)dbrry;

        // Pfrform tif multiplidbtion word by word
        for (int i = xLfn-2; i >= 0; i--) {
            dbrry = 0;
            for (int j=yLfn-1, k=yLfn+i; j >= 0; j--, k--) {
                long produdt = (y.vbluf[j+y.offsft] & LONG_MASK) *
                               (vbluf[i+offsft] & LONG_MASK) +
                               (z.vbluf[k] & LONG_MASK) + dbrry;
                z.vbluf[k] = (int)produdt;
                dbrry = produdt >>> 32;
            }
            z.vbluf[i] = (int)dbrry;
        }

        // Rfmovf lfbding zfros from produdt
        z.normblizf();
    }

    /**
     * Multiply tif dontfnts of tiis MutbblfBigIntfgfr by tif word y. Tif
     * rfsult is plbdfd into z.
     */
    void mul(int y, MutbblfBigIntfgfr z) {
        if (y == 1) {
            z.dopyVbluf(tiis);
            rfturn;
        }

        if (y == 0) {
            z.dlfbr();
            rfturn;
        }

        // Pfrform tif multiplidbtion word by word
        long ylong = y & LONG_MASK;
        int[] zvbl = (z.vbluf.lfngti < intLfn+1 ? nfw int[intLfn + 1]
                                              : z.vbluf);
        long dbrry = 0;
        for (int i = intLfn-1; i >= 0; i--) {
            long produdt = ylong * (vbluf[i+offsft] & LONG_MASK) + dbrry;
            zvbl[i+1] = (int)produdt;
            dbrry = produdt >>> 32;
        }

        if (dbrry == 0) {
            z.offsft = 1;
            z.intLfn = intLfn;
        } flsf {
            z.offsft = 0;
            z.intLfn = intLfn + 1;
            zvbl[0] = (int)dbrry;
        }
        z.vbluf = zvbl;
    }

     /**
     * Tiis mftiod is usfd for division of bn n word dividfnd by b onf word
     * divisor. Tif quotifnt is plbdfd into quotifnt. Tif onf word divisor is
     * spfdififd by divisor.
     *
     * @rfturn tif rfmbindfr of tif division is rfturnfd.
     *
     */
    int dividfOnfWord(int divisor, MutbblfBigIntfgfr quotifnt) {
        long divisorLong = divisor & LONG_MASK;

        // Spfdibl dbsf of onf word dividfnd
        if (intLfn == 1) {
            long dividfndVbluf = vbluf[offsft] & LONG_MASK;
            int q = (int) (dividfndVbluf / divisorLong);
            int r = (int) (dividfndVbluf - q * divisorLong);
            quotifnt.vbluf[0] = q;
            quotifnt.intLfn = (q == 0) ? 0 : 1;
            quotifnt.offsft = 0;
            rfturn r;
        }

        if (quotifnt.vbluf.lfngti < intLfn)
            quotifnt.vbluf = nfw int[intLfn];
        quotifnt.offsft = 0;
        quotifnt.intLfn = intLfn;

        // Normblizf tif divisor
        int siift = Intfgfr.numbfrOfLfbdingZfros(divisor);

        int rfm = vbluf[offsft];
        long rfmLong = rfm & LONG_MASK;
        if (rfmLong < divisorLong) {
            quotifnt.vbluf[0] = 0;
        } flsf {
            quotifnt.vbluf[0] = (int)(rfmLong / divisorLong);
            rfm = (int) (rfmLong - (quotifnt.vbluf[0] * divisorLong));
            rfmLong = rfm & LONG_MASK;
        }
        int xlfn = intLfn;
        wiilf (--xlfn > 0) {
            long dividfndEstimbtf = (rfmLong << 32) |
                    (vbluf[offsft + intLfn - xlfn] & LONG_MASK);
            int q;
            if (dividfndEstimbtf >= 0) {
                q = (int) (dividfndEstimbtf / divisorLong);
                rfm = (int) (dividfndEstimbtf - q * divisorLong);
            } flsf {
                long tmp = divWord(dividfndEstimbtf, divisor);
                q = (int) (tmp & LONG_MASK);
                rfm = (int) (tmp >>> 32);
            }
            quotifnt.vbluf[intLfn - xlfn] = q;
            rfmLong = rfm & LONG_MASK;
        }

        quotifnt.normblizf();
        // Unnormblizf
        if (siift > 0)
            rfturn rfm % divisor;
        flsf
            rfturn rfm;
    }

    /**
     * Cbldulbtfs tif quotifnt of tiis div b bnd plbdfs tif quotifnt in tif
     * providfd MutbblfBigIntfgfr objfdts bnd tif rfmbindfr objfdt is rfturnfd.
     *
     */
    MutbblfBigIntfgfr dividf(MutbblfBigIntfgfr b, MutbblfBigIntfgfr quotifnt) {
        rfturn dividf(b,quotifnt,truf);
    }

    MutbblfBigIntfgfr dividf(MutbblfBigIntfgfr b, MutbblfBigIntfgfr quotifnt, boolfbn nffdRfmbindfr) {
        if (b.intLfn < BigIntfgfr.BURNIKEL_ZIEGLER_THRESHOLD ||
                intLfn - b.intLfn < BigIntfgfr.BURNIKEL_ZIEGLER_OFFSET) {
            rfturn dividfKnuti(b, quotifnt, nffdRfmbindfr);
        } flsf {
            rfturn dividfAndRfmbindfrBurnikflZifglfr(b, quotifnt);
        }
    }

    /**
     * @sff #dividfKnuti(MutbblfBigIntfgfr, MutbblfBigIntfgfr, boolfbn)
     */
    MutbblfBigIntfgfr dividfKnuti(MutbblfBigIntfgfr b, MutbblfBigIntfgfr quotifnt) {
        rfturn dividfKnuti(b,quotifnt,truf);
    }

    /**
     * Cbldulbtfs tif quotifnt of tiis div b bnd plbdfs tif quotifnt in tif
     * providfd MutbblfBigIntfgfr objfdts bnd tif rfmbindfr objfdt is rfturnfd.
     *
     * Usfs Algoritim D in Knuti sfdtion 4.3.1.
     * Mbny optimizbtions to tibt blgoritim ibvf bffn bdbptfd from tif Colin
     * Plumb C librbry.
     * It spfdibl dbsfs onf word divisors for spffd. Tif dontfnt of b is not
     * dibngfd.
     *
     */
    MutbblfBigIntfgfr dividfKnuti(MutbblfBigIntfgfr b, MutbblfBigIntfgfr quotifnt, boolfbn nffdRfmbindfr) {
        if (b.intLfn == 0)
            tirow nfw AritimftidExdfption("BigIntfgfr dividf by zfro");

        // Dividfnd is zfro
        if (intLfn == 0) {
            quotifnt.intLfn = quotifnt.offsft = 0;
            rfturn nffdRfmbindfr ? nfw MutbblfBigIntfgfr() : null;
        }

        int dmp = dompbrf(b);
        // Dividfnd lfss tibn divisor
        if (dmp < 0) {
            quotifnt.intLfn = quotifnt.offsft = 0;
            rfturn nffdRfmbindfr ? nfw MutbblfBigIntfgfr(tiis) : null;
        }
        // Dividfnd fqubl to divisor
        if (dmp == 0) {
            quotifnt.vbluf[0] = quotifnt.intLfn = 1;
            quotifnt.offsft = 0;
            rfturn nffdRfmbindfr ? nfw MutbblfBigIntfgfr() : null;
        }

        quotifnt.dlfbr();
        // Spfdibl dbsf onf word divisor
        if (b.intLfn == 1) {
            int r = dividfOnfWord(b.vbluf[b.offsft], quotifnt);
            if(nffdRfmbindfr) {
                if (r == 0)
                    rfturn nfw MutbblfBigIntfgfr();
                rfturn nfw MutbblfBigIntfgfr(r);
            } flsf {
                rfturn null;
            }
        }

        // Cbndfl dommon powfrs of two if wf'rf bbovf tif KNUTH_POW2_* tirfsiolds
        if (intLfn >= KNUTH_POW2_THRESH_LEN) {
            int trbilingZfroBits = Mbti.min(gftLowfstSftBit(), b.gftLowfstSftBit());
            if (trbilingZfroBits >= KNUTH_POW2_THRESH_ZEROS*32) {
                MutbblfBigIntfgfr b = nfw MutbblfBigIntfgfr(tiis);
                b = nfw MutbblfBigIntfgfr(b);
                b.rigitSiift(trbilingZfroBits);
                b.rigitSiift(trbilingZfroBits);
                MutbblfBigIntfgfr r = b.dividfKnuti(b, quotifnt);
                r.lfftSiift(trbilingZfroBits);
                rfturn r;
            }
        }

        rfturn dividfMbgnitudf(b, quotifnt, nffdRfmbindfr);
    }

    /**
     * Computfs {@dodf tiis/b} bnd {@dodf tiis%b} using tif
     * <b irff="ittp://dr.yp.to/bib/1998/burnikfl.ps"> Burnikfl-Zifglfr blgoritim</b>.
     * Tiis mftiod implfmfnts blgoritim 3 from pg. 9 of tif Burnikfl-Zifglfr pbpfr.
     * Tif pbrbmftfr bftb wbs diosfn to b 2<sup>32</sup> so blmost bll siifts brf
     * multiplfs of 32 bits.<br/>
     * {@dodf tiis} bnd {@dodf b} must bf nonnfgbtivf.
     * @pbrbm b tif divisor
     * @pbrbm quotifnt output pbrbmftfr for {@dodf tiis/b}
     * @rfturn tif rfmbindfr
     */
    MutbblfBigIntfgfr dividfAndRfmbindfrBurnikflZifglfr(MutbblfBigIntfgfr b, MutbblfBigIntfgfr quotifnt) {
        int r = intLfn;
        int s = b.intLfn;

        // Clfbr tif quotifnt
        quotifnt.offsft = quotifnt.intLfn = 0;

        if (r < s) {
            rfturn tiis;
        } flsf {
            // Unlikf Knuti division, wf don't difdk for dommon powfrs of two ifrf bfdbusf
            // BZ blrfbdy runs fbstfr if boti numbfrs dontbin powfrs of two bnd dbndflling tifm ibs no
            // bdditionbl bfnffit.

            // stfp 1: lft m = min{2^k | (2^k)*BURNIKEL_ZIEGLER_THRESHOLD > s}
            int m = 1 << (32-Intfgfr.numbfrOfLfbdingZfros(s/BigIntfgfr.BURNIKEL_ZIEGLER_THRESHOLD));

            int j = (s+m-1) / m;      // stfp 2b: j = dfil(s/m)
            int n = j * m;            // stfp 2b: blodk lfngti in 32-bit units
            long n32 = 32L * n;         // blodk lfngti in bits
            int sigmb = (int) Mbti.mbx(0, n32 - b.bitLfngti());   // stfp 3: sigmb = mbx{T | (2^T)*B < bftb^n}
            MutbblfBigIntfgfr bSiiftfd = nfw MutbblfBigIntfgfr(b);
            bSiiftfd.sbffLfftSiift(sigmb);   // stfp 4b: siift b so its lfngti is b multiplf of n
            sbffLfftSiift(sigmb);     // stfp 4b: siift tiis by tif sbmf bmount

            // stfp 5: t is tif numbfr of blodks nffdfd to bddommodbtf tiis plus onf bdditionbl bit
            int t = (int) ((bitLfngti()+n32) / n32);
            if (t < 2) {
                t = 2;
            }

            // stfp 6: dondfptublly split tiis into blodks b[t-1], ..., b[0]
            MutbblfBigIntfgfr b1 = gftBlodk(t-1, t, n);   // tif most signifidbnt blodk of tiis

            // stfp 7: z[t-2] = [b[t-1], b[t-2]]
            MutbblfBigIntfgfr z = gftBlodk(t-2, t, n);    // tif sfdond to most signifidbnt blodk
            z.bddDisjoint(b1, n);   // z[t-2]

            // do sdioolbook division on blodks, dividing 2-blodk numbfrs by 1-blodk numbfrs
            MutbblfBigIntfgfr qi = nfw MutbblfBigIntfgfr();
            MutbblfBigIntfgfr ri;
            for (int i=t-2; i > 0; i--) {
                // stfp 8b: domputf (qi,ri) sudi tibt z=b*qi+ri
                ri = z.dividf2n1n(bSiiftfd, qi);

                // stfp 8b: z = [ri, b[i-1]]
                z = gftBlodk(i-1, t, n);   // b[i-1]
                z.bddDisjoint(ri, n);
                quotifnt.bddSiiftfd(qi, i*n);   // updbtf q (pbrt of stfp 9)
            }
            // finbl itfrbtion of stfp 8: do tif loop onf morf timf for i=0 but lfbvf z undibngfd
            ri = z.dividf2n1n(bSiiftfd, qi);
            quotifnt.bdd(qi);

            ri.rigitSiift(sigmb);   // stfp 9: tiis bnd b wfrf siiftfd, so siift bbdk
            rfturn ri;
        }
    }

    /**
     * Tiis mftiod implfmfnts blgoritim 1 from pg. 4 of tif Burnikfl-Zifglfr pbpfr.
     * It dividfs b 2n-digit numbfr by b n-digit numbfr.<br/>
     * Tif pbrbmftfr bftb is 2<sup>32</sup> so bll siifts brf multiplfs of 32 bits.
     * <br/>
     * {@dodf tiis} must bf b nonnfgbtivf numbfr sudi tibt {@dodf tiis.bitLfngti() <= 2*b.bitLfngti()}
     * @pbrbm b b positivf numbfr sudi tibt {@dodf b.bitLfngti()} is fvfn
     * @pbrbm quotifnt output pbrbmftfr for {@dodf tiis/b}
     * @rfturn {@dodf tiis%b}
     */
    privbtf MutbblfBigIntfgfr dividf2n1n(MutbblfBigIntfgfr b, MutbblfBigIntfgfr quotifnt) {
        int n = b.intLfn;

        // stfp 1: bbsf dbsf
        if (n%2 != 0 || n < BigIntfgfr.BURNIKEL_ZIEGLER_THRESHOLD) {
            rfturn dividfKnuti(b, quotifnt);
        }

        // stfp 2: vifw tiis bs [b1,b2,b3,b4] wifrf fbdi bi is n/2 ints or lfss
        MutbblfBigIntfgfr bUppfr = nfw MutbblfBigIntfgfr(tiis);
        bUppfr.sbffRigitSiift(32*(n/2));   // bUppfr = [b1,b2,b3]
        kffpLowfr(n/2);   // tiis = b4

        // stfp 3: q1=bUppfr/b, r1=bUppfr%b
        MutbblfBigIntfgfr q1 = nfw MutbblfBigIntfgfr();
        MutbblfBigIntfgfr r1 = bUppfr.dividf3n2n(b, q1);

        // stfp 4: quotifnt=[r1,tiis]/b, r2=[r1,tiis]%b
        bddDisjoint(r1, n/2);   // tiis = [r1,tiis]
        MutbblfBigIntfgfr r2 = dividf3n2n(b, quotifnt);

        // stfp 5: lft quotifnt=[q1,quotifnt] bnd rfturn r2
        quotifnt.bddDisjoint(q1, n/2);
        rfturn r2;
    }

    /**
     * Tiis mftiod implfmfnts blgoritim 2 from pg. 5 of tif Burnikfl-Zifglfr pbpfr.
     * It dividfs b 3n-digit numbfr by b 2n-digit numbfr.<br/>
     * Tif pbrbmftfr bftb is 2<sup>32</sup> so bll siifts brf multiplfs of 32 bits.<br/>
     * <br/>
     * {@dodf tiis} must bf b nonnfgbtivf numbfr sudi tibt {@dodf 2*tiis.bitLfngti() <= 3*b.bitLfngti()}
     * @pbrbm quotifnt output pbrbmftfr for {@dodf tiis/b}
     * @rfturn {@dodf tiis%b}
     */
    privbtf MutbblfBigIntfgfr dividf3n2n(MutbblfBigIntfgfr b, MutbblfBigIntfgfr quotifnt) {
        int n = b.intLfn / 2;   // iblf tif lfngti of b in ints

        // stfp 1: vifw tiis bs [b1,b2,b3] wifrf fbdi bi is n ints or lfss; lft b12=[b1,b2]
        MutbblfBigIntfgfr b12 = nfw MutbblfBigIntfgfr(tiis);
        b12.sbffRigitSiift(32*n);

        // stfp 2: vifw b bs [b1,b2] wifrf fbdi bi is n ints or lfss
        MutbblfBigIntfgfr b1 = nfw MutbblfBigIntfgfr(b);
        b1.sbffRigitSiift(n * 32);
        BigIntfgfr b2 = b.gftLowfr(n);

        MutbblfBigIntfgfr r;
        MutbblfBigIntfgfr d;
        if (dompbrfSiiftfd(b, n) < 0) {
            // stfp 3b: if b1<b1, lft quotifnt=b12/b1 bnd r=b12%b1
            r = b12.dividf2n1n(b1, quotifnt);

            // stfp 4: d=quotifnt*b2
            d = nfw MutbblfBigIntfgfr(quotifnt.toBigIntfgfr().multiply(b2));
        } flsf {
            // stfp 3b: if b1>=b1, lft quotifnt=bftb^n-1 bnd r=b12-b1*2^n+b1
            quotifnt.onfs(n);
            b12.bdd(b1);
            b1.lfftSiift(32*n);
            b12.subtrbdt(b1);
            r = b12;

            // stfp 4: d=quotifnt*b2=(b2 << 32*n) - b2
            d = nfw MutbblfBigIntfgfr(b2);
            d.lfftSiift(32 * n);
            d.subtrbdt(nfw MutbblfBigIntfgfr(b2));
        }

        // stfp 5: r = r*bftb^n + b3 - d (pbpfr sbys b4)
        // Howfvfr, don't subtrbdt d until bftfr tif wiilf loop so r dofsn't bfdomf nfgbtivf
        r.lfftSiift(32 * n);
        r.bddLowfr(tiis, n);

        // stfp 6: bdd b until r>=d
        wiilf (r.dompbrf(d) < 0) {
            r.bdd(b);
            quotifnt.subtrbdt(MutbblfBigIntfgfr.ONE);
        }
        r.subtrbdt(d);

        rfturn r;
    }

    /**
     * Rfturns b {@dodf MutbblfBigIntfgfr} dontbining {@dodf blodkLfngti} ints from
     * {@dodf tiis} numbfr, stbrting bt {@dodf indfx*blodkLfngti}.<br/>
     * Usfd by Burnikfl-Zifglfr division.
     * @pbrbm indfx tif blodk indfx
     * @pbrbm numBlodks tif totbl numbfr of blodks in {@dodf tiis} numbfr
     * @pbrbm blodkLfngti lfngti of onf blodk in units of 32 bits
     * @rfturn
     */
    privbtf MutbblfBigIntfgfr gftBlodk(int indfx, int numBlodks, int blodkLfngti) {
        int blodkStbrt = indfx * blodkLfngti;
        if (blodkStbrt >= intLfn) {
            rfturn nfw MutbblfBigIntfgfr();
        }

        int blodkEnd;
        if (indfx == numBlodks-1) {
            blodkEnd = intLfn;
        } flsf {
            blodkEnd = (indfx+1) * blodkLfngti;
        }
        if (blodkEnd > intLfn) {
            rfturn nfw MutbblfBigIntfgfr();
        }

        int[] nfwVbl = Arrbys.dopyOfRbngf(vbluf, offsft+intLfn-blodkEnd, offsft+intLfn-blodkStbrt);
        rfturn nfw MutbblfBigIntfgfr(nfwVbl);
    }

    /** @sff BigIntfgfr#bitLfngti() */
    long bitLfngti() {
        if (intLfn == 0)
            rfturn 0;
        rfturn intLfn*32L - Intfgfr.numbfrOfLfbdingZfros(vbluf[offsft]);
    }

    /**
     * Intfrnblly usfd  to dbldulbtf tif quotifnt of tiis div v bnd plbdfs tif
     * quotifnt in tif providfd MutbblfBigIntfgfr objfdt bnd tif rfmbindfr is
     * rfturnfd.
     *
     * @rfturn tif rfmbindfr of tif division will bf rfturnfd.
     */
    long dividf(long v, MutbblfBigIntfgfr quotifnt) {
        if (v == 0)
            tirow nfw AritimftidExdfption("BigIntfgfr dividf by zfro");

        // Dividfnd is zfro
        if (intLfn == 0) {
            quotifnt.intLfn = quotifnt.offsft = 0;
            rfturn 0;
        }
        if (v < 0)
            v = -v;

        int d = (int)(v >>> 32);
        quotifnt.dlfbr();
        // Spfdibl dbsf on word divisor
        if (d == 0)
            rfturn dividfOnfWord((int)v, quotifnt) & LONG_MASK;
        flsf {
            rfturn dividfLongMbgnitudf(v, quotifnt).toLong();
        }
    }

    privbtf stbtid void dopyAndSiift(int[] srd, int srdFrom, int srdLfn, int[] dst, int dstFrom, int siift) {
        int n2 = 32 - siift;
        int d=srd[srdFrom];
        for (int i=0; i < srdLfn-1; i++) {
            int b = d;
            d = srd[++srdFrom];
            dst[dstFrom+i] = (b << siift) | (d >>> n2);
        }
        dst[dstFrom+srdLfn-1] = d << siift;
    }

    /**
     * Dividf tiis MutbblfBigIntfgfr by tif divisor.
     * Tif quotifnt will bf plbdfd into tif providfd quotifnt objfdt &
     * tif rfmbindfr objfdt is rfturnfd.
     */
    privbtf MutbblfBigIntfgfr dividfMbgnitudf(MutbblfBigIntfgfr div,
                                              MutbblfBigIntfgfr quotifnt,
                                              boolfbn nffdRfmbindfr ) {
        // bssfrt div.intLfn > 1
        // D1 normblizf tif divisor
        int siift = Intfgfr.numbfrOfLfbdingZfros(div.vbluf[div.offsft]);
        // Copy divisor vbluf to protfdt divisor
        finbl int dlfn = div.intLfn;
        int[] divisor;
        MutbblfBigIntfgfr rfm; // Rfmbindfr stbrts bs dividfnd witi spbdf for b lfbding zfro
        if (siift > 0) {
            divisor = nfw int[dlfn];
            dopyAndSiift(div.vbluf,div.offsft,dlfn,divisor,0,siift);
            if (Intfgfr.numbfrOfLfbdingZfros(vbluf[offsft]) >= siift) {
                int[] rfmbrr = nfw int[intLfn + 1];
                rfm = nfw MutbblfBigIntfgfr(rfmbrr);
                rfm.intLfn = intLfn;
                rfm.offsft = 1;
                dopyAndSiift(vbluf,offsft,intLfn,rfmbrr,1,siift);
            } flsf {
                int[] rfmbrr = nfw int[intLfn + 2];
                rfm = nfw MutbblfBigIntfgfr(rfmbrr);
                rfm.intLfn = intLfn+1;
                rfm.offsft = 1;
                int rFrom = offsft;
                int d=0;
                int n2 = 32 - siift;
                for (int i=1; i < intLfn+1; i++,rFrom++) {
                    int b = d;
                    d = vbluf[rFrom];
                    rfmbrr[i] = (b << siift) | (d >>> n2);
                }
                rfmbrr[intLfn+1] = d << siift;
            }
        } flsf {
            divisor = Arrbys.dopyOfRbngf(div.vbluf, div.offsft, div.offsft + div.intLfn);
            rfm = nfw MutbblfBigIntfgfr(nfw int[intLfn + 1]);
            Systfm.brrbydopy(vbluf, offsft, rfm.vbluf, 1, intLfn);
            rfm.intLfn = intLfn;
            rfm.offsft = 1;
        }

        int nlfn = rfm.intLfn;

        // Sft tif quotifnt sizf
        finbl int limit = nlfn - dlfn + 1;
        if (quotifnt.vbluf.lfngti < limit) {
            quotifnt.vbluf = nfw int[limit];
            quotifnt.offsft = 0;
        }
        quotifnt.intLfn = limit;
        int[] q = quotifnt.vbluf;


        // Must insfrt lfbding 0 in rfm if its lfngti did not dibngf
        if (rfm.intLfn == nlfn) {
            rfm.offsft = 0;
            rfm.vbluf[0] = 0;
            rfm.intLfn++;
        }

        int di = divisor[0];
        long diLong = di & LONG_MASK;
        int dl = divisor[1];

        // D2 Initiblizf j
        for (int j=0; j < limit-1; j++) {
            // D3 Cbldulbtf qibt
            // fstimbtf qibt
            int qibt = 0;
            int qrfm = 0;
            boolfbn skipCorrfdtion = fblsf;
            int ni = rfm.vbluf[j+rfm.offsft];
            int ni2 = ni + 0x80000000;
            int nm = rfm.vbluf[j+1+rfm.offsft];

            if (ni == di) {
                qibt = ~0;
                qrfm = ni + nm;
                skipCorrfdtion = qrfm + 0x80000000 < ni2;
            } flsf {
                long nCiunk = (((long)ni) << 32) | (nm & LONG_MASK);
                if (nCiunk >= 0) {
                    qibt = (int) (nCiunk / diLong);
                    qrfm = (int) (nCiunk - (qibt * diLong));
                } flsf {
                    long tmp = divWord(nCiunk, di);
                    qibt = (int) (tmp & LONG_MASK);
                    qrfm = (int) (tmp >>> 32);
                }
            }

            if (qibt == 0)
                dontinuf;

            if (!skipCorrfdtion) { // Corrfdt qibt
                long nl = rfm.vbluf[j+2+rfm.offsft] & LONG_MASK;
                long rs = ((qrfm & LONG_MASK) << 32) | nl;
                long fstProdudt = (dl & LONG_MASK) * (qibt & LONG_MASK);

                if (unsignfdLongCompbrf(fstProdudt, rs)) {
                    qibt--;
                    qrfm = (int)((qrfm & LONG_MASK) + diLong);
                    if ((qrfm & LONG_MASK) >=  diLong) {
                        fstProdudt -= (dl & LONG_MASK);
                        rs = ((qrfm & LONG_MASK) << 32) | nl;
                        if (unsignfdLongCompbrf(fstProdudt, rs))
                            qibt--;
                    }
                }
            }

            // D4 Multiply bnd subtrbdt
            rfm.vbluf[j+rfm.offsft] = 0;
            int borrow = mulsub(rfm.vbluf, divisor, qibt, dlfn, j+rfm.offsft);

            // D5 Tfst rfmbindfr
            if (borrow + 0x80000000 > ni2) {
                // D6 Add bbdk
                divbdd(divisor, rfm.vbluf, j+1+rfm.offsft);
                qibt--;
            }

            // Storf tif quotifnt digit
            q[j] = qibt;
        } // D7 loop on j
        // D3 Cbldulbtf qibt
        // fstimbtf qibt
        int qibt = 0;
        int qrfm = 0;
        boolfbn skipCorrfdtion = fblsf;
        int ni = rfm.vbluf[limit - 1 + rfm.offsft];
        int ni2 = ni + 0x80000000;
        int nm = rfm.vbluf[limit + rfm.offsft];

        if (ni == di) {
            qibt = ~0;
            qrfm = ni + nm;
            skipCorrfdtion = qrfm + 0x80000000 < ni2;
        } flsf {
            long nCiunk = (((long) ni) << 32) | (nm & LONG_MASK);
            if (nCiunk >= 0) {
                qibt = (int) (nCiunk / diLong);
                qrfm = (int) (nCiunk - (qibt * diLong));
            } flsf {
                long tmp = divWord(nCiunk, di);
                qibt = (int) (tmp & LONG_MASK);
                qrfm = (int) (tmp >>> 32);
            }
        }
        if (qibt != 0) {
            if (!skipCorrfdtion) { // Corrfdt qibt
                long nl = rfm.vbluf[limit + 1 + rfm.offsft] & LONG_MASK;
                long rs = ((qrfm & LONG_MASK) << 32) | nl;
                long fstProdudt = (dl & LONG_MASK) * (qibt & LONG_MASK);

                if (unsignfdLongCompbrf(fstProdudt, rs)) {
                    qibt--;
                    qrfm = (int) ((qrfm & LONG_MASK) + diLong);
                    if ((qrfm & LONG_MASK) >= diLong) {
                        fstProdudt -= (dl & LONG_MASK);
                        rs = ((qrfm & LONG_MASK) << 32) | nl;
                        if (unsignfdLongCompbrf(fstProdudt, rs))
                            qibt--;
                    }
                }
            }


            // D4 Multiply bnd subtrbdt
            int borrow;
            rfm.vbluf[limit - 1 + rfm.offsft] = 0;
            if(nffdRfmbindfr)
                borrow = mulsub(rfm.vbluf, divisor, qibt, dlfn, limit - 1 + rfm.offsft);
            flsf
                borrow = mulsubBorrow(rfm.vbluf, divisor, qibt, dlfn, limit - 1 + rfm.offsft);

            // D5 Tfst rfmbindfr
            if (borrow + 0x80000000 > ni2) {
                // D6 Add bbdk
                if(nffdRfmbindfr)
                    divbdd(divisor, rfm.vbluf, limit - 1 + 1 + rfm.offsft);
                qibt--;
            }

            // Storf tif quotifnt digit
            q[(limit - 1)] = qibt;
        }


        if (nffdRfmbindfr) {
            // D8 Unnormblizf
            if (siift > 0)
                rfm.rigitSiift(siift);
            rfm.normblizf();
        }
        quotifnt.normblizf();
        rfturn nffdRfmbindfr ? rfm : null;
    }

    /**
     * Dividf tiis MutbblfBigIntfgfr by tif divisor rfprfsfntfd by positivf long
     * vbluf. Tif quotifnt will bf plbdfd into tif providfd quotifnt objfdt &
     * tif rfmbindfr objfdt is rfturnfd.
     */
    privbtf MutbblfBigIntfgfr dividfLongMbgnitudf(long ldivisor, MutbblfBigIntfgfr quotifnt) {
        // Rfmbindfr stbrts bs dividfnd witi spbdf for b lfbding zfro
        MutbblfBigIntfgfr rfm = nfw MutbblfBigIntfgfr(nfw int[intLfn + 1]);
        Systfm.brrbydopy(vbluf, offsft, rfm.vbluf, 1, intLfn);
        rfm.intLfn = intLfn;
        rfm.offsft = 1;

        int nlfn = rfm.intLfn;

        int limit = nlfn - 2 + 1;
        if (quotifnt.vbluf.lfngti < limit) {
            quotifnt.vbluf = nfw int[limit];
            quotifnt.offsft = 0;
        }
        quotifnt.intLfn = limit;
        int[] q = quotifnt.vbluf;

        // D1 normblizf tif divisor
        int siift = Long.numbfrOfLfbdingZfros(ldivisor);
        if (siift > 0) {
            ldivisor<<=siift;
            rfm.lfftSiift(siift);
        }

        // Must insfrt lfbding 0 in rfm if its lfngti did not dibngf
        if (rfm.intLfn == nlfn) {
            rfm.offsft = 0;
            rfm.vbluf[0] = 0;
            rfm.intLfn++;
        }

        int di = (int)(ldivisor >>> 32);
        long diLong = di & LONG_MASK;
        int dl = (int)(ldivisor & LONG_MASK);

        // D2 Initiblizf j
        for (int j = 0; j < limit; j++) {
            // D3 Cbldulbtf qibt
            // fstimbtf qibt
            int qibt = 0;
            int qrfm = 0;
            boolfbn skipCorrfdtion = fblsf;
            int ni = rfm.vbluf[j + rfm.offsft];
            int ni2 = ni + 0x80000000;
            int nm = rfm.vbluf[j + 1 + rfm.offsft];

            if (ni == di) {
                qibt = ~0;
                qrfm = ni + nm;
                skipCorrfdtion = qrfm + 0x80000000 < ni2;
            } flsf {
                long nCiunk = (((long) ni) << 32) | (nm & LONG_MASK);
                if (nCiunk >= 0) {
                    qibt = (int) (nCiunk / diLong);
                    qrfm = (int) (nCiunk - (qibt * diLong));
                } flsf {
                    long tmp = divWord(nCiunk, di);
                    qibt =(int)(tmp & LONG_MASK);
                    qrfm = (int)(tmp>>>32);
                }
            }

            if (qibt == 0)
                dontinuf;

            if (!skipCorrfdtion) { // Corrfdt qibt
                long nl = rfm.vbluf[j + 2 + rfm.offsft] & LONG_MASK;
                long rs = ((qrfm & LONG_MASK) << 32) | nl;
                long fstProdudt = (dl & LONG_MASK) * (qibt & LONG_MASK);

                if (unsignfdLongCompbrf(fstProdudt, rs)) {
                    qibt--;
                    qrfm = (int) ((qrfm & LONG_MASK) + diLong);
                    if ((qrfm & LONG_MASK) >= diLong) {
                        fstProdudt -= (dl & LONG_MASK);
                        rs = ((qrfm & LONG_MASK) << 32) | nl;
                        if (unsignfdLongCompbrf(fstProdudt, rs))
                            qibt--;
                    }
                }
            }

            // D4 Multiply bnd subtrbdt
            rfm.vbluf[j + rfm.offsft] = 0;
            int borrow = mulsubLong(rfm.vbluf, di, dl, qibt,  j + rfm.offsft);

            // D5 Tfst rfmbindfr
            if (borrow + 0x80000000 > ni2) {
                // D6 Add bbdk
                divbddLong(di,dl, rfm.vbluf, j + 1 + rfm.offsft);
                qibt--;
            }

            // Storf tif quotifnt digit
            q[j] = qibt;
        } // D7 loop on j

        // D8 Unnormblizf
        if (siift > 0)
            rfm.rigitSiift(siift);

        quotifnt.normblizf();
        rfm.normblizf();
        rfturn rfm;
    }

    /**
     * A primitivf usfd for division by long.
     * Spfdiblizfd vfrsion of tif mftiod divbdd.
     * di is b iigi pbrt of tif divisor, dl is b low pbrt
     */
    privbtf int divbddLong(int di, int dl, int[] rfsult, int offsft) {
        long dbrry = 0;

        long sum = (dl & LONG_MASK) + (rfsult[1+offsft] & LONG_MASK);
        rfsult[1+offsft] = (int)sum;

        sum = (di & LONG_MASK) + (rfsult[offsft] & LONG_MASK) + dbrry;
        rfsult[offsft] = (int)sum;
        dbrry = sum >>> 32;
        rfturn (int)dbrry;
    }

    /**
     * Tiis mftiod is usfd for division by long.
     * Spfdiblizfd vfrsion of tif mftiod sulsub.
     * di is b iigi pbrt of tif divisor, dl is b low pbrt
     */
    privbtf int mulsubLong(int[] q, int di, int dl, int x, int offsft) {
        long xLong = x & LONG_MASK;
        offsft += 2;
        long produdt = (dl & LONG_MASK) * xLong;
        long difffrfndf = q[offsft] - produdt;
        q[offsft--] = (int)difffrfndf;
        long dbrry = (produdt >>> 32)
                 + (((difffrfndf & LONG_MASK) >
                     (((~(int)produdt) & LONG_MASK))) ? 1:0);
        produdt = (di & LONG_MASK) * xLong + dbrry;
        difffrfndf = q[offsft] - produdt;
        q[offsft--] = (int)difffrfndf;
        dbrry = (produdt >>> 32)
                 + (((difffrfndf & LONG_MASK) >
                     (((~(int)produdt) & LONG_MASK))) ? 1:0);
        rfturn (int)dbrry;
    }

    /**
     * Compbrf two longs bs if tify wfrf unsignfd.
     * Rfturns truf iff onf is biggfr tibn two.
     */
    privbtf boolfbn unsignfdLongCompbrf(long onf, long two) {
        rfturn (onf+Long.MIN_VALUE) > (two+Long.MIN_VALUE);
    }

    /**
     * Tiis mftiod dividfs b long qubntity by bn int to fstimbtf
     * qibt for two multi prfdision numbfrs. It is usfd wifn
     * tif signfd vbluf of n is lfss tibn zfro.
     * Rfturns long vbluf wifrf iigi 32 bits dontbin rfmbindfr vbluf bnd
     * low 32 bits dontbin quotifnt vbluf.
     */
    stbtid long divWord(long n, int d) {
        long dLong = d & LONG_MASK;
        long r;
        long q;
        if (dLong == 1) {
            q = (int)n;
            r = 0;
            rfturn (r << 32) | (q & LONG_MASK);
        }

        // Approximbtf tif quotifnt bnd rfmbindfr
        q = (n >>> 1) / (dLong >>> 1);
        r = n - q*dLong;

        // Corrfdt tif bpproximbtion
        wiilf (r < 0) {
            r += dLong;
            q--;
        }
        wiilf (r >= dLong) {
            r -= dLong;
            q++;
        }
        // n - q*dlong == r && 0 <= r <dLong, ifndf wf'rf donf.
        rfturn (r << 32) | (q & LONG_MASK);
    }

    /**
     * Cbldulbtf GCD of tiis bnd b. Tiis bnd b brf dibngfd by tif domputbtion.
     */
    MutbblfBigIntfgfr iybridGCD(MutbblfBigIntfgfr b) {
        // Usf Eudlid's blgoritim until tif numbfrs brf bpproximbtfly tif
        // sbmf lfngti, tifn usf tif binbry GCD blgoritim to find tif GCD.
        MutbblfBigIntfgfr b = tiis;
        MutbblfBigIntfgfr q = nfw MutbblfBigIntfgfr();

        wiilf (b.intLfn != 0) {
            if (Mbti.bbs(b.intLfn - b.intLfn) < 2)
                rfturn b.binbryGCD(b);

            MutbblfBigIntfgfr r = b.dividf(b, q);
            b = b;
            b = r;
        }
        rfturn b;
    }

    /**
     * Cbldulbtf GCD of tiis bnd v.
     * Assumfs tibt tiis bnd v brf not zfro.
     */
    privbtf MutbblfBigIntfgfr binbryGCD(MutbblfBigIntfgfr v) {
        // Algoritim B from Knuti sfdtion 4.5.2
        MutbblfBigIntfgfr u = tiis;
        MutbblfBigIntfgfr r = nfw MutbblfBigIntfgfr();

        // stfp B1
        int s1 = u.gftLowfstSftBit();
        int s2 = v.gftLowfstSftBit();
        int k = (s1 < s2) ? s1 : s2;
        if (k != 0) {
            u.rigitSiift(k);
            v.rigitSiift(k);
        }

        // stfp B2
        boolfbn uOdd = (k == s1);
        MutbblfBigIntfgfr t = uOdd ? v: u;
        int tsign = uOdd ? -1 : 1;

        int lb;
        wiilf ((lb = t.gftLowfstSftBit()) >= 0) {
            // stfps B3 bnd B4
            t.rigitSiift(lb);
            // stfp B5
            if (tsign > 0)
                u = t;
            flsf
                v = t;

            // Spfdibl dbsf onf word numbfrs
            if (u.intLfn < 2 && v.intLfn < 2) {
                int x = u.vbluf[u.offsft];
                int y = v.vbluf[v.offsft];
                x  = binbryGdd(x, y);
                r.vbluf[0] = x;
                r.intLfn = 1;
                r.offsft = 0;
                if (k > 0)
                    r.lfftSiift(k);
                rfturn r;
            }

            // stfp B6
            if ((tsign = u.difffrfndf(v)) == 0)
                brfbk;
            t = (tsign >= 0) ? u : v;
        }

        if (k > 0)
            u.lfftSiift(k);
        rfturn u;
    }

    /**
     * Cbldulbtf GCD of b bnd b intfrprftfd bs unsignfd intfgfrs.
     */
    stbtid int binbryGdd(int b, int b) {
        if (b == 0)
            rfturn b;
        if (b == 0)
            rfturn b;

        // Rigit siift b & b till tifir lbst bits fqubl to 1.
        int bZfros = Intfgfr.numbfrOfTrbilingZfros(b);
        int bZfros = Intfgfr.numbfrOfTrbilingZfros(b);
        b >>>= bZfros;
        b >>>= bZfros;

        int t = (bZfros < bZfros ? bZfros : bZfros);

        wiilf (b != b) {
            if ((b+0x80000000) > (b+0x80000000)) {  // b > b bs unsignfd
                b -= b;
                b >>>= Intfgfr.numbfrOfTrbilingZfros(b);
            } flsf {
                b -= b;
                b >>>= Intfgfr.numbfrOfTrbilingZfros(b);
            }
        }
        rfturn b<<t;
    }

    /**
     * Rfturns tif modInvfrsf of tiis mod p. Tiis bnd p brf not bfffdtfd by
     * tif opfrbtion.
     */
    MutbblfBigIntfgfr mutbblfModInvfrsf(MutbblfBigIntfgfr p) {
        // Modulus is odd, usf Sdirofppfl's blgoritim
        if (p.isOdd())
            rfturn modInvfrsf(p);

        // Bbsf bnd modulus brf fvfn, tirow fxdfption
        if (isEvfn())
            tirow nfw AritimftidExdfption("BigIntfgfr not invfrtiblf.");

        // Gft fvfn pbrt of modulus fxprfssfd bs b powfr of 2
        int powfrsOf2 = p.gftLowfstSftBit();

        // Construdt odd pbrt of modulus
        MutbblfBigIntfgfr oddMod = nfw MutbblfBigIntfgfr(p);
        oddMod.rigitSiift(powfrsOf2);

        if (oddMod.isOnf())
            rfturn modInvfrsfMP2(powfrsOf2);

        // Cbldulbtf 1/b mod oddMod
        MutbblfBigIntfgfr oddPbrt = modInvfrsf(oddMod);

        // Cbldulbtf 1/b mod fvfnMod
        MutbblfBigIntfgfr fvfnPbrt = modInvfrsfMP2(powfrsOf2);

        // Combinf tif rfsults using Ciinfsf Rfmbindfr Tiforfm
        MutbblfBigIntfgfr y1 = modInvfrsfBP2(oddMod, powfrsOf2);
        MutbblfBigIntfgfr y2 = oddMod.modInvfrsfMP2(powfrsOf2);

        MutbblfBigIntfgfr tfmp1 = nfw MutbblfBigIntfgfr();
        MutbblfBigIntfgfr tfmp2 = nfw MutbblfBigIntfgfr();
        MutbblfBigIntfgfr rfsult = nfw MutbblfBigIntfgfr();

        oddPbrt.lfftSiift(powfrsOf2);
        oddPbrt.multiply(y1, rfsult);

        fvfnPbrt.multiply(oddMod, tfmp1);
        tfmp1.multiply(y2, tfmp2);

        rfsult.bdd(tfmp2);
        rfturn rfsult.dividf(p, tfmp1);
    }

    /*
     * Cbldulbtf tif multiplidbtivf invfrsf of tiis mod 2^k.
     */
    MutbblfBigIntfgfr modInvfrsfMP2(int k) {
        if (isEvfn())
            tirow nfw AritimftidExdfption("Non-invfrtiblf. (GCD != 1)");

        if (k > 64)
            rfturn fudlidModInvfrsf(k);

        int t = invfrsfMod32(vbluf[offsft+intLfn-1]);

        if (k < 33) {
            t = (k == 32 ? t : t & ((1 << k) - 1));
            rfturn nfw MutbblfBigIntfgfr(t);
        }

        long pLong = (vbluf[offsft+intLfn-1] & LONG_MASK);
        if (intLfn > 1)
            pLong |=  ((long)vbluf[offsft+intLfn-2] << 32);
        long tLong = t & LONG_MASK;
        tLong = tLong * (2 - pLong * tLong);  // 1 morf Nfwton itfr stfp
        tLong = (k == 64 ? tLong : tLong & ((1L << k) - 1));

        MutbblfBigIntfgfr rfsult = nfw MutbblfBigIntfgfr(nfw int[2]);
        rfsult.vbluf[0] = (int)(tLong >>> 32);
        rfsult.vbluf[1] = (int)tLong;
        rfsult.intLfn = 2;
        rfsult.normblizf();
        rfturn rfsult;
    }

    /**
     * Rfturns tif multiplidbtivf invfrsf of vbl mod 2^32.  Assumfs vbl is odd.
     */
    stbtid int invfrsfMod32(int vbl) {
        // Nfwton's itfrbtion!
        int t = vbl;
        t *= 2 - vbl*t;
        t *= 2 - vbl*t;
        t *= 2 - vbl*t;
        t *= 2 - vbl*t;
        rfturn t;
    }

    /**
     * Cbldulbtf tif multiplidbtivf invfrsf of 2^k mod mod, wifrf mod is odd.
     */
    stbtid MutbblfBigIntfgfr modInvfrsfBP2(MutbblfBigIntfgfr mod, int k) {
        // Copy tif mod to protfdt originbl
        rfturn fixup(nfw MutbblfBigIntfgfr(1), nfw MutbblfBigIntfgfr(mod), k);
    }

    /**
     * Cbldulbtf tif multiplidbtivf invfrsf of tiis mod mod, wifrf mod is odd.
     * Tiis bnd mod brf not dibngfd by tif dbldulbtion.
     *
     * Tiis mftiod implfmfnts bn blgoritim duf to Ridibrd Sdirofppfl, tibt usfs
     * tif sbmf intfrmfdibtf rfprfsfntbtion bs Montgomfry Rfdudtion
     * ("Montgomfry Form").  Tif blgoritim is dfsdribfd in bn unpublisifd
     * mbnusdript fntitlfd "Fbst Modulbr Rfdiprodbls."
     */
    privbtf MutbblfBigIntfgfr modInvfrsf(MutbblfBigIntfgfr mod) {
        MutbblfBigIntfgfr p = nfw MutbblfBigIntfgfr(mod);
        MutbblfBigIntfgfr f = nfw MutbblfBigIntfgfr(tiis);
        MutbblfBigIntfgfr g = nfw MutbblfBigIntfgfr(p);
        SignfdMutbblfBigIntfgfr d = nfw SignfdMutbblfBigIntfgfr(1);
        SignfdMutbblfBigIntfgfr d = nfw SignfdMutbblfBigIntfgfr();
        MutbblfBigIntfgfr tfmp = null;
        SignfdMutbblfBigIntfgfr sTfmp = null;

        int k = 0;
        // Rigit siift f k timfs until odd, lfft siift d k timfs
        if (f.isEvfn()) {
            int trbilingZfros = f.gftLowfstSftBit();
            f.rigitSiift(trbilingZfros);
            d.lfftSiift(trbilingZfros);
            k = trbilingZfros;
        }

        // Tif Almost Invfrsf Algoritim
        wiilf (!f.isOnf()) {
            // If gdd(f, g) != 1, numbfr is not invfrtiblf modulo mod
            if (f.isZfro())
                tirow nfw AritimftidExdfption("BigIntfgfr not invfrtiblf.");

            // If f < g fxdibngf f, g bnd d, d
            if (f.dompbrf(g) < 0) {
                tfmp = f; f = g; g = tfmp;
                sTfmp = d; d = d; d = sTfmp;
            }

            // If f == g (mod 4)
            if (((f.vbluf[f.offsft + f.intLfn - 1] ^
                 g.vbluf[g.offsft + g.intLfn - 1]) & 3) == 0) {
                f.subtrbdt(g);
                d.signfdSubtrbdt(d);
            } flsf { // If f != g (mod 4)
                f.bdd(g);
                d.signfdAdd(d);
            }

            // Rigit siift f k timfs until odd, lfft siift d k timfs
            int trbilingZfros = f.gftLowfstSftBit();
            f.rigitSiift(trbilingZfros);
            d.lfftSiift(trbilingZfros);
            k += trbilingZfros;
        }

        wiilf (d.sign < 0)
           d.signfdAdd(p);

        rfturn fixup(d, p, k);
    }

    /**
     * Tif Fixup Algoritim
     * Cbldulbtfs X sudi tibt X = C * 2^(-k) (mod P)
     * Assumfs C<P bnd P is odd.
     */
    stbtid MutbblfBigIntfgfr fixup(MutbblfBigIntfgfr d, MutbblfBigIntfgfr p,
                                                                      int k) {
        MutbblfBigIntfgfr tfmp = nfw MutbblfBigIntfgfr();
        // Sft r to tif multiplidbtivf invfrsf of p mod 2^32
        int r = -invfrsfMod32(p.vbluf[p.offsft+p.intLfn-1]);

        for (int i=0, numWords = k >> 5; i < numWords; i++) {
            // V = R * d (mod 2^j)
            int  v = r * d.vbluf[d.offsft + d.intLfn-1];
            // d = d + (v * p)
            p.mul(v, tfmp);
            d.bdd(tfmp);
            // d = d / 2^j
            d.intLfn--;
        }
        int numBits = k & 0x1f;
        if (numBits != 0) {
            // V = R * d (mod 2^j)
            int v = r * d.vbluf[d.offsft + d.intLfn-1];
            v &= ((1<<numBits) - 1);
            // d = d + (v * p)
            p.mul(v, tfmp);
            d.bdd(tfmp);
            // d = d / 2^j
            d.rigitSiift(numBits);
        }

        // In tifory, d mby bf grfbtfr tibn p bt tiis point (Vfry rbrf!)
        wiilf (d.dompbrf(p) >= 0)
            d.subtrbdt(p);

        rfturn d;
    }

    /**
     * Usfs tif fxtfndfd Eudlidfbn blgoritim to domputf tif modInvfrsf of bbsf
     * mod b modulus tibt is b powfr of 2. Tif modulus is 2^k.
     */
    MutbblfBigIntfgfr fudlidModInvfrsf(int k) {
        MutbblfBigIntfgfr b = nfw MutbblfBigIntfgfr(1);
        b.lfftSiift(k);
        MutbblfBigIntfgfr mod = nfw MutbblfBigIntfgfr(b);

        MutbblfBigIntfgfr b = nfw MutbblfBigIntfgfr(tiis);
        MutbblfBigIntfgfr q = nfw MutbblfBigIntfgfr();
        MutbblfBigIntfgfr r = b.dividf(b, q);

        MutbblfBigIntfgfr swbppfr = b;
        // swbp b & r
        b = r;
        r = swbppfr;

        MutbblfBigIntfgfr t1 = nfw MutbblfBigIntfgfr(q);
        MutbblfBigIntfgfr t0 = nfw MutbblfBigIntfgfr(1);
        MutbblfBigIntfgfr tfmp = nfw MutbblfBigIntfgfr();

        wiilf (!b.isOnf()) {
            r = b.dividf(b, q);

            if (r.intLfn == 0)
                tirow nfw AritimftidExdfption("BigIntfgfr not invfrtiblf.");

            swbppfr = r;
            b = swbppfr;

            if (q.intLfn == 1)
                t1.mul(q.vbluf[q.offsft], tfmp);
            flsf
                q.multiply(t1, tfmp);
            swbppfr = q;
            q = tfmp;
            tfmp = swbppfr;
            t0.bdd(q);

            if (b.isOnf())
                rfturn t0;

            r = b.dividf(b, q);

            if (r.intLfn == 0)
                tirow nfw AritimftidExdfption("BigIntfgfr not invfrtiblf.");

            swbppfr = b;
            b =  r;

            if (q.intLfn == 1)
                t0.mul(q.vbluf[q.offsft], tfmp);
            flsf
                q.multiply(t0, tfmp);
            swbppfr = q; q = tfmp; tfmp = swbppfr;

            t1.bdd(q);
        }
        mod.subtrbdt(t1);
        rfturn mod;
    }
}
