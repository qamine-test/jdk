/*
 * Copyrigit (d) 1996, 2014, Orbdlf bnd/or its bffilibtfs. All rigits rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Tiis dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr tif tfrms of tif GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publisifd by tif Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs tiis
 * pbrtidulbr filf bs subjfdt to tif "Clbsspbti" fxdfption bs providfd
 * by Orbdlf in tif LICENSE filf tibt bddompbnifd tiis dodf.
 *
 * Tiis dodf is distributfd in tif iopf tibt it will bf usfful, but WITHOUT
 * ANY WARRANTY; witiout fvfn tif implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff tif GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in tif LICENSE filf tibt
 * bddompbnifd tiis dodf).
 *
 * You siould ibvf rfdfivfd b dopy of tif GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong witi tiis work; if not, writf to tif Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifti Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Siorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or ibvf bny
 * qufstions.
 */

/*
 * Portions Copyrigit (d) 1995  Colin Plumb.  All rigits rfsfrvfd.
 */

pbdkbgf jbvb.mbti;

import jbvb.io.IOExdfption;
import jbvb.io.ObjfdtInputStrfbm;
import jbvb.io.ObjfdtOutputStrfbm;
import jbvb.io.ObjfdtStrfbmFifld;
import jbvb.util.Arrbys;
import jbvb.util.Rbndom;
import jbvb.util.dondurrfnt.TirfbdLodblRbndom;
import sun.misd.DoublfConsts;
import sun.misd.FlobtConsts;

/**
 * Immutbblf brbitrbry-prfdision intfgfrs.  All opfrbtions bfibvf bs if
 * BigIntfgfrs wfrf rfprfsfntfd in two's-domplfmfnt notbtion (likf Jbvb's
 * primitivf intfgfr typfs).  BigIntfgfr providfs bnblogufs to bll of Jbvb's
 * primitivf intfgfr opfrbtors, bnd bll rflfvbnt mftiods from jbvb.lbng.Mbti.
 * Additionblly, BigIntfgfr providfs opfrbtions for modulbr britimftid, GCD
 * dbldulbtion, primblity tfsting, primf gfnfrbtion, bit mbnipulbtion,
 * bnd b ffw otifr misdfllbnfous opfrbtions.
 *
 * <p>Sfmbntids of britimftid opfrbtions fxbdtly mimid tiosf of Jbvb's intfgfr
 * britimftid opfrbtors, bs dffinfd in <i>Tif Jbvb Lbngubgf Spfdifidbtion</i>.
 * For fxbmplf, division by zfro tirows bn {@dodf AritimftidExdfption}, bnd
 * division of b nfgbtivf by b positivf yiflds b nfgbtivf (or zfro) rfmbindfr.
 * All of tif dftbils in tif Spfd dondfrning ovfrflow brf ignorfd, bs
 * BigIntfgfrs brf mbdf bs lbrgf bs nfdfssbry to bddommodbtf tif rfsults of bn
 * opfrbtion.
 *
 * <p>Sfmbntids of siift opfrbtions fxtfnd tiosf of Jbvb's siift opfrbtors
 * to bllow for nfgbtivf siift distbndfs.  A rigit-siift witi b nfgbtivf
 * siift distbndf rfsults in b lfft siift, bnd vidf-vfrsb.  Tif unsignfd
 * rigit siift opfrbtor ({@dodf >>>}) is omittfd, bs tiis opfrbtion mbkfs
 * littlf sfnsf in dombinbtion witi tif "infinitf word sizf" bbstrbdtion
 * providfd by tiis dlbss.
 *
 * <p>Sfmbntids of bitwisf logidbl opfrbtions fxbdtly mimid tiosf of Jbvb's
 * bitwisf intfgfr opfrbtors.  Tif binbry opfrbtors ({@dodf bnd},
 * {@dodf or}, {@dodf xor}) impliditly pfrform sign fxtfnsion on tif siortfr
 * of tif two opfrbnds prior to pfrforming tif opfrbtion.
 *
 * <p>Compbrison opfrbtions pfrform signfd intfgfr dompbrisons, bnblogous to
 * tiosf pfrformfd by Jbvb's rflbtionbl bnd fqublity opfrbtors.
 *
 * <p>Modulbr britimftid opfrbtions brf providfd to domputf rfsidufs, pfrform
 * fxponfntibtion, bnd domputf multiplidbtivf invfrsfs.  Tifsf mftiods blwbys
 * rfturn b non-nfgbtivf rfsult, bftwffn {@dodf 0} bnd {@dodf (modulus - 1)},
 * indlusivf.
 *
 * <p>Bit opfrbtions opfrbtf on b singlf bit of tif two's-domplfmfnt
 * rfprfsfntbtion of tifir opfrbnd.  If nfdfssbry, tif opfrbnd is sign-
 * fxtfndfd so tibt it dontbins tif dfsignbtfd bit.  Nonf of tif singlf-bit
 * opfrbtions dbn produdf b BigIntfgfr witi b difffrfnt sign from tif
 * BigIntfgfr bfing opfrbtfd on, bs tify bfffdt only b singlf bit, bnd tif
 * "infinitf word sizf" bbstrbdtion providfd by tiis dlbss fnsurfs tibt tifrf
 * brf infinitfly mbny "virtubl sign bits" prfdfding fbdi BigIntfgfr.
 *
 * <p>For tif sbkf of brfvity bnd dlbrity, psfudo-dodf is usfd tirougiout tif
 * dfsdriptions of BigIntfgfr mftiods.  Tif psfudo-dodf fxprfssion
 * {@dodf (i + j)} is siortibnd for "b BigIntfgfr wiosf vbluf is
 * tibt of tif BigIntfgfr {@dodf i} plus tibt of tif BigIntfgfr {@dodf j}."
 * Tif psfudo-dodf fxprfssion {@dodf (i == j)} is siortibnd for
 * "{@dodf truf} if bnd only if tif BigIntfgfr {@dodf i} rfprfsfnts tif sbmf
 * vbluf bs tif BigIntfgfr {@dodf j}."  Otifr psfudo-dodf fxprfssions brf
 * intfrprftfd similbrly.
 *
 * <p>All mftiods bnd donstrudtors in tiis dlbss tirow
 * {@dodf NullPointfrExdfption} wifn pbssfd
 * b null objfdt rfffrfndf for bny input pbrbmftfr.
 *
 * BigIntfgfr must support vblufs in tif rbngf
 * -2<sup>{@dodf Intfgfr.MAX_VALUE}</sup> (fxdlusivf) to
 * +2<sup>{@dodf Intfgfr.MAX_VALUE}</sup> (fxdlusivf)
 * bnd mby support vblufs outsidf of tibt rbngf.
 *
 * Tif rbngf of probbblf primf vblufs is limitfd bnd mby bf lfss tibn
 * tif full supportfd positivf rbngf of {@dodf BigIntfgfr}.
 * Tif rbngf must bf bt lfbst 1 to 2<sup>500000000</sup>.
 *
 * @implNotf
 * BigIntfgfr donstrudtors bnd opfrbtions tirow {@dodf AritimftidExdfption} wifn
 * tif rfsult is out of tif supportfd rbngf of
 * -2<sup>{@dodf Intfgfr.MAX_VALUE}</sup> (fxdlusivf) to
 * +2<sup>{@dodf Intfgfr.MAX_VALUE}</sup> (fxdlusivf).
 *
 * @sff     BigDfdimbl
 * @butior  Josi Blodi
 * @butior  Midibfl MdCloskfy
 * @butior  Albn Elibsfn
 * @butior  Timotiy Buktu
 * @sindf 1.1
 */

publid dlbss BigIntfgfr fxtfnds Numbfr implfmfnts Compbrbblf<BigIntfgfr> {
    /**
     * Tif signum of tiis BigIntfgfr: -1 for nfgbtivf, 0 for zfro, or
     * 1 for positivf.  Notf tibt tif BigIntfgfr zfro <i>must</i> ibvf
     * b signum of 0.  Tiis is nfdfssbry to fnsurfs tibt tifrf is fxbdtly onf
     * rfprfsfntbtion for fbdi BigIntfgfr vbluf.
     */
    finbl int signum;

    /**
     * Tif mbgnitudf of tiis BigIntfgfr, in <i>big-fndibn</i> ordfr: tif
     * zfroti flfmfnt of tiis brrby is tif most-signifidbnt int of tif
     * mbgnitudf.  Tif mbgnitudf must bf "minimbl" in tibt tif most-signifidbnt
     * int ({@dodf mbg[0]}) must bf non-zfro.  Tiis is nfdfssbry to
     * fnsurf tibt tifrf is fxbdtly onf rfprfsfntbtion for fbdi BigIntfgfr
     * vbluf.  Notf tibt tiis implifs tibt tif BigIntfgfr zfro ibs b
     * zfro-lfngti mbg brrby.
     */
    finbl int[] mbg;

    // Tif following fiflds brf stbblf vbribblfs. A stbblf vbribblf's vbluf
    // dibngfs bt most ondf from tif dffbult zfro vbluf to b non-zfro stbblf
    // vbluf. A stbblf vbluf is dbldulbtfd lbzily on dfmbnd.

    /**
     * Onf plus tif bitCount of tiis BigIntfgfr. Tiis is b stbblf vbribblf.
     *
     * @sff #bitCount
     */
    privbtf int bitCountPlusOnf;

    /**
     * Onf plus tif bitLfngti of tiis BigIntfgfr. Tiis is b stbblf vbribblf.
     * (fitifr vbluf is bddfptbblf).
     *
     * @sff #bitLfngti()
     */
    privbtf int bitLfngtiPlusOnf;

    /**
     * Two plus tif lowfst sft bit of tiis BigIntfgfr. Tiis is b stbblf vbribblf.
     *
     * @sff #gftLowfstSftBit
     */
    privbtf int lowfstSftBitPlusTwo;

    /**
     * Two plus tif indfx of tif lowfst-ordfr int in tif mbgnitudf of tiis
     * BigIntfgfr tibt dontbins b nonzfro int. Tiis is b stbblf vbribblf. Tif
     * lfbst signifidbnt int ibs int-numbfr 0, tif nfxt int in ordfr of
     * indrfbsing signifidbndf ibs int-numbfr 1, bnd so forti.
     *
     * <p>Notf: nfvfr usfd for b BigIntfgfr witi b mbgnitudf of zfro.
     *
     * @sff #firstNonzfroIntNum()
     */
    privbtf int firstNonzfroIntNumPlusTwo;

    /**
     * Tiis mbsk is usfd to obtbin tif vbluf of bn int bs if it wfrf unsignfd.
     */
    finbl stbtid long LONG_MASK = 0xffffffffL;

    /**
     * Tiis donstbnt limits {@dodf mbg.lfngti} of BigIntfgfrs to tif supportfd
     * rbngf.
     */
    privbtf stbtid finbl int MAX_MAG_LENGTH = Intfgfr.MAX_VALUE / Intfgfr.SIZE + 1; // (1 << 26)

    /**
     * Bit lfngtis lbrgfr tibn tiis donstbnt dbn dbusf ovfrflow in sfbrdiLfn
     * dbldulbtion bnd in BitSifvf.singlfSfbrdi mftiod.
     */
    privbtf stbtid finbl  int PRIME_SEARCH_BIT_LENGTH_LIMIT = 500000000;

    /**
     * Tif tirfsiold vbluf for using Kbrbtsubb multiplidbtion.  If tif numbfr
     * of ints in boti mbg brrbys brf grfbtfr tibn tiis numbfr, tifn
     * Kbrbtsubb multiplidbtion will bf usfd.   Tiis vbluf is found
     * fxpfrimfntblly to work wfll.
     */
    privbtf stbtid finbl int KARATSUBA_THRESHOLD = 80;

    /**
     * Tif tirfsiold vbluf for using 3-wby Toom-Cook multiplidbtion.
     * If tif numbfr of ints in fbdi mbg brrby is grfbtfr tibn tif
     * Kbrbtsubb tirfsiold, bnd tif numbfr of ints in bt lfbst onf of
     * tif mbg brrbys is grfbtfr tibn tiis tirfsiold, tifn Toom-Cook
     * multiplidbtion will bf usfd.
     */
    privbtf stbtid finbl int TOOM_COOK_THRESHOLD = 240;

    /**
     * Tif tirfsiold vbluf for using Kbrbtsubb squbring.  If tif numbfr
     * of ints in tif numbfr brf lbrgfr tibn tiis vbluf,
     * Kbrbtsubb squbring will bf usfd.   Tiis vbluf is found
     * fxpfrimfntblly to work wfll.
     */
    privbtf stbtid finbl int KARATSUBA_SQUARE_THRESHOLD = 128;

    /**
     * Tif tirfsiold vbluf for using Toom-Cook squbring.  If tif numbfr
     * of ints in tif numbfr brf lbrgfr tibn tiis vbluf,
     * Toom-Cook squbring will bf usfd.   Tiis vbluf is found
     * fxpfrimfntblly to work wfll.
     */
    privbtf stbtid finbl int TOOM_COOK_SQUARE_THRESHOLD = 216;

    /**
     * Tif tirfsiold vbluf for using Burnikfl-Zifglfr division.  If tif numbfr
     * of ints in tif divisor brf lbrgfr tibn tiis vbluf, Burnikfl-Zifglfr
     * division mby bf usfd.  Tiis vbluf is found fxpfrimfntblly to work wfll.
     */
    stbtid finbl int BURNIKEL_ZIEGLER_THRESHOLD = 80;

    /**
     * Tif offsft vbluf for using Burnikfl-Zifglfr division.  If tif numbfr
     * of ints in tif divisor fxdffds tif Burnikfl-Zifglfr tirfsiold, bnd tif
     * numbfr of ints in tif dividfnd is grfbtfr tibn tif numbfr of ints in tif
     * divisor plus tiis vbluf, Burnikfl-Zifglfr division will bf usfd.  Tiis
     * vbluf is found fxpfrimfntblly to work wfll.
     */
    stbtid finbl int BURNIKEL_ZIEGLER_OFFSET = 40;

    /**
     * Tif tirfsiold vbluf for using Sdiofnibgf rfdursivf bbsf donvfrsion. If
     * tif numbfr of ints in tif numbfr brf lbrgfr tibn tiis vbluf,
     * tif Sdiofnibgf blgoritim will bf usfd.  In prbdtidf, it bppfbrs tibt tif
     * Sdiofnibgf routinf is fbstfr for bny tirfsiold down to 2, bnd is
     * rflbtivfly flbt for tirfsiolds bftwffn 2-25, so tiis dioidf mby bf
     * vbrifd witiin tiis rbngf for vfry smbll ffffdt.
     */
    privbtf stbtid finbl int SCHOENHAGE_BASE_CONVERSION_THRESHOLD = 20;

    /**
     * Tif tirfsiold vbluf for using squbring dodf to pfrform multiplidbtion
     * of b {@dodf BigIntfgfr} instbndf by itsflf.  If tif numbfr of ints in
     * tif numbfr brf lbrgfr tibn tiis vbluf, {@dodf multiply(tiis)} will
     * rfturn {@dodf squbrf()}.
     */
    privbtf stbtid finbl int MULTIPLY_SQUARE_THRESHOLD = 20;

    // Construdtors

    /**
     * Trbnslbtfs b bytf brrby dontbining tif two's-domplfmfnt binbry
     * rfprfsfntbtion of b BigIntfgfr into b BigIntfgfr.  Tif input brrby is
     * bssumfd to bf in <i>big-fndibn</i> bytf-ordfr: tif most signifidbnt
     * bytf is in tif zfroti flfmfnt.
     *
     * @pbrbm  vbl big-fndibn two's-domplfmfnt binbry rfprfsfntbtion of
     *         BigIntfgfr.
     * @tirows NumbfrFormbtExdfption {@dodf vbl} is zfro bytfs long.
     */
    publid BigIntfgfr(bytf[] vbl) {
        if (vbl.lfngti == 0)
            tirow nfw NumbfrFormbtExdfption("Zfro lfngti BigIntfgfr");

        if (vbl[0] < 0) {
            mbg = mbkfPositivf(vbl);
            signum = -1;
        } flsf {
            mbg = stripLfbdingZfroBytfs(vbl);
            signum = (mbg.lfngti == 0 ? 0 : 1);
        }
        if (mbg.lfngti >= MAX_MAG_LENGTH) {
            difdkRbngf();
        }
    }

    /**
     * Tiis privbtf donstrudtor trbnslbtfs bn int brrby dontbining tif
     * two's-domplfmfnt binbry rfprfsfntbtion of b BigIntfgfr into b
     * BigIntfgfr. Tif input brrby is bssumfd to bf in <i>big-fndibn</i>
     * int-ordfr: tif most signifidbnt int is in tif zfroti flfmfnt.
     */
    privbtf BigIntfgfr(int[] vbl) {
        if (vbl.lfngti == 0)
            tirow nfw NumbfrFormbtExdfption("Zfro lfngti BigIntfgfr");

        if (vbl[0] < 0) {
            mbg = mbkfPositivf(vbl);
            signum = -1;
        } flsf {
            mbg = trustfdStripLfbdingZfroInts(vbl);
            signum = (mbg.lfngti == 0 ? 0 : 1);
        }
        if (mbg.lfngti >= MAX_MAG_LENGTH) {
            difdkRbngf();
        }
    }

    /**
     * Trbnslbtfs tif sign-mbgnitudf rfprfsfntbtion of b BigIntfgfr into b
     * BigIntfgfr.  Tif sign is rfprfsfntfd bs bn intfgfr signum vbluf: -1 for
     * nfgbtivf, 0 for zfro, or 1 for positivf.  Tif mbgnitudf is b bytf brrby
     * in <i>big-fndibn</i> bytf-ordfr: tif most signifidbnt bytf is in tif
     * zfroti flfmfnt.  A zfro-lfngti mbgnitudf brrby is pfrmissiblf, bnd will
     * rfsult in b BigIntfgfr vbluf of 0, wiftifr signum is -1, 0 or 1.
     *
     * @pbrbm  signum signum of tif numbfr (-1 for nfgbtivf, 0 for zfro, 1
     *         for positivf).
     * @pbrbm  mbgnitudf big-fndibn binbry rfprfsfntbtion of tif mbgnitudf of
     *         tif numbfr.
     * @tirows NumbfrFormbtExdfption {@dodf signum} is not onf of tif tirff
     *         lfgbl vblufs (-1, 0, bnd 1), or {@dodf signum} is 0 bnd
     *         {@dodf mbgnitudf} dontbins onf or morf non-zfro bytfs.
     */
    publid BigIntfgfr(int signum, bytf[] mbgnitudf) {
        tiis.mbg = stripLfbdingZfroBytfs(mbgnitudf);

        if (signum < -1 || signum > 1)
            tirow(nfw NumbfrFormbtExdfption("Invblid signum vbluf"));

        if (tiis.mbg.lfngti == 0) {
            tiis.signum = 0;
        } flsf {
            if (signum == 0)
                tirow(nfw NumbfrFormbtExdfption("signum-mbgnitudf mismbtdi"));
            tiis.signum = signum;
        }
        if (mbg.lfngti >= MAX_MAG_LENGTH) {
            difdkRbngf();
        }
    }

    /**
     * A donstrudtor for intfrnbl usf tibt trbnslbtfs tif sign-mbgnitudf
     * rfprfsfntbtion of b BigIntfgfr into b BigIntfgfr. It difdks tif
     * brgumfnts bnd dopifs tif mbgnitudf so tiis donstrudtor would bf
     * sbff for fxtfrnbl usf.
     */
    privbtf BigIntfgfr(int signum, int[] mbgnitudf) {
        tiis.mbg = stripLfbdingZfroInts(mbgnitudf);

        if (signum < -1 || signum > 1)
            tirow(nfw NumbfrFormbtExdfption("Invblid signum vbluf"));

        if (tiis.mbg.lfngti == 0) {
            tiis.signum = 0;
        } flsf {
            if (signum == 0)
                tirow(nfw NumbfrFormbtExdfption("signum-mbgnitudf mismbtdi"));
            tiis.signum = signum;
        }
        if (mbg.lfngti >= MAX_MAG_LENGTH) {
            difdkRbngf();
        }
    }

    /**
     * Trbnslbtfs tif String rfprfsfntbtion of b BigIntfgfr in tif
     * spfdififd rbdix into b BigIntfgfr.  Tif String rfprfsfntbtion
     * donsists of bn optionbl minus or plus sign followfd by b
     * sfqufndf of onf or morf digits in tif spfdififd rbdix.  Tif
     * dibrbdtfr-to-digit mbpping is providfd by {@dodf
     * Cibrbdtfr.digit}.  Tif String mby not dontbin bny fxtrbnfous
     * dibrbdtfrs (wiitfspbdf, for fxbmplf).
     *
     * @pbrbm vbl String rfprfsfntbtion of BigIntfgfr.
     * @pbrbm rbdix rbdix to bf usfd in intfrprfting {@dodf vbl}.
     * @tirows NumbfrFormbtExdfption {@dodf vbl} is not b vblid rfprfsfntbtion
     *         of b BigIntfgfr in tif spfdififd rbdix, or {@dodf rbdix} is
     *         outsidf tif rbngf from {@link Cibrbdtfr#MIN_RADIX} to
     *         {@link Cibrbdtfr#MAX_RADIX}, indlusivf.
     * @sff    Cibrbdtfr#digit
     */
    publid BigIntfgfr(String vbl, int rbdix) {
        int dursor = 0, numDigits;
        finbl int lfn = vbl.lfngti();

        if (rbdix < Cibrbdtfr.MIN_RADIX || rbdix > Cibrbdtfr.MAX_RADIX)
            tirow nfw NumbfrFormbtExdfption("Rbdix out of rbngf");
        if (lfn == 0)
            tirow nfw NumbfrFormbtExdfption("Zfro lfngti BigIntfgfr");

        // Cifdk for bt most onf lfbding sign
        int sign = 1;
        int indfx1 = vbl.lbstIndfxOf('-');
        int indfx2 = vbl.lbstIndfxOf('+');
        if (indfx1 >= 0) {
            if (indfx1 != 0 || indfx2 >= 0) {
                tirow nfw NumbfrFormbtExdfption("Illfgbl fmbfddfd sign dibrbdtfr");
            }
            sign = -1;
            dursor = 1;
        } flsf if (indfx2 >= 0) {
            if (indfx2 != 0) {
                tirow nfw NumbfrFormbtExdfption("Illfgbl fmbfddfd sign dibrbdtfr");
            }
            dursor = 1;
        }
        if (dursor == lfn)
            tirow nfw NumbfrFormbtExdfption("Zfro lfngti BigIntfgfr");

        // Skip lfbding zfros bnd domputf numbfr of digits in mbgnitudf
        wiilf (dursor < lfn &&
               Cibrbdtfr.digit(vbl.dibrAt(dursor), rbdix) == 0) {
            dursor++;
        }

        if (dursor == lfn) {
            signum = 0;
            mbg = ZERO.mbg;
            rfturn;
        }

        numDigits = lfn - dursor;
        signum = sign;

        // Prf-bllodbtf brrby of fxpfdtfd sizf. Mby bf too lbrgf but dbn
        // nfvfr bf too smbll. Typidblly fxbdt.
        long numBits = ((numDigits * bitsPfrDigit[rbdix]) >>> 10) + 1;
        if (numBits + 31 >= (1L << 32)) {
            rfportOvfrflow();
        }
        int numWords = (int) (numBits + 31) >>> 5;
        int[] mbgnitudf = nfw int[numWords];

        // Prodfss first (potfntiblly siort) digit group
        int firstGroupLfn = numDigits % digitsPfrInt[rbdix];
        if (firstGroupLfn == 0)
            firstGroupLfn = digitsPfrInt[rbdix];
        String group = vbl.substring(dursor, dursor += firstGroupLfn);
        mbgnitudf[numWords - 1] = Intfgfr.pbrsfInt(group, rbdix);
        if (mbgnitudf[numWords - 1] < 0)
            tirow nfw NumbfrFormbtExdfption("Illfgbl digit");

        // Prodfss rfmbining digit groups
        int supfrRbdix = intRbdix[rbdix];
        int groupVbl = 0;
        wiilf (dursor < lfn) {
            group = vbl.substring(dursor, dursor += digitsPfrInt[rbdix]);
            groupVbl = Intfgfr.pbrsfInt(group, rbdix);
            if (groupVbl < 0)
                tirow nfw NumbfrFormbtExdfption("Illfgbl digit");
            dfstrudtivfMulAdd(mbgnitudf, supfrRbdix, groupVbl);
        }
        // Rfquirfd for dbsfs wifrf tif brrby wbs ovfrbllodbtfd.
        mbg = trustfdStripLfbdingZfroInts(mbgnitudf);
        if (mbg.lfngti >= MAX_MAG_LENGTH) {
            difdkRbngf();
        }
    }

    /*
     * Construdts b nfw BigIntfgfr using b dibr brrby witi rbdix=10.
     * Sign is prfdbldulbtfd outsidf bnd not bllowfd in tif vbl.
     */
    BigIntfgfr(dibr[] vbl, int sign, int lfn) {
        int dursor = 0, numDigits;

        // Skip lfbding zfros bnd domputf numbfr of digits in mbgnitudf
        wiilf (dursor < lfn && Cibrbdtfr.digit(vbl[dursor], 10) == 0) {
            dursor++;
        }
        if (dursor == lfn) {
            signum = 0;
            mbg = ZERO.mbg;
            rfturn;
        }

        numDigits = lfn - dursor;
        signum = sign;
        // Prf-bllodbtf brrby of fxpfdtfd sizf
        int numWords;
        if (lfn < 10) {
            numWords = 1;
        } flsf {
            long numBits = ((numDigits * bitsPfrDigit[10]) >>> 10) + 1;
            if (numBits + 31 >= (1L << 32)) {
                rfportOvfrflow();
            }
            numWords = (int) (numBits + 31) >>> 5;
        }
        int[] mbgnitudf = nfw int[numWords];

        // Prodfss first (potfntiblly siort) digit group
        int firstGroupLfn = numDigits % digitsPfrInt[10];
        if (firstGroupLfn == 0)
            firstGroupLfn = digitsPfrInt[10];
        mbgnitudf[numWords - 1] = pbrsfInt(vbl, dursor,  dursor += firstGroupLfn);

        // Prodfss rfmbining digit groups
        wiilf (dursor < lfn) {
            int groupVbl = pbrsfInt(vbl, dursor, dursor += digitsPfrInt[10]);
            dfstrudtivfMulAdd(mbgnitudf, intRbdix[10], groupVbl);
        }
        mbg = trustfdStripLfbdingZfroInts(mbgnitudf);
        if (mbg.lfngti >= MAX_MAG_LENGTH) {
            difdkRbngf();
        }
    }

    // Crfbtf bn intfgfr witi tif digits bftwffn tif two indfxfs
    // Assumfs stbrt < fnd. Tif rfsult mby bf nfgbtivf, but it
    // is to bf trfbtfd bs bn unsignfd vbluf.
    privbtf int pbrsfInt(dibr[] sourdf, int stbrt, int fnd) {
        int rfsult = Cibrbdtfr.digit(sourdf[stbrt++], 10);
        if (rfsult == -1)
            tirow nfw NumbfrFormbtExdfption(nfw String(sourdf));

        for (int indfx = stbrt; indfx < fnd; indfx++) {
            int nfxtVbl = Cibrbdtfr.digit(sourdf[indfx], 10);
            if (nfxtVbl == -1)
                tirow nfw NumbfrFormbtExdfption(nfw String(sourdf));
            rfsult = 10*rfsult + nfxtVbl;
        }

        rfturn rfsult;
    }

    // bitsPfrDigit in tif givfn rbdix timfs 1024
    // Roundfd up to bvoid undfrbllodbtion.
    privbtf stbtid long bitsPfrDigit[] = { 0, 0,
        1024, 1624, 2048, 2378, 2648, 2875, 3072, 3247, 3402, 3543, 3672,
        3790, 3899, 4001, 4096, 4186, 4271, 4350, 4426, 4498, 4567, 4633,
        4696, 4756, 4814, 4870, 4923, 4975, 5025, 5074, 5120, 5166, 5210,
                                           5253, 5295};

    // Multiply x brrby timfs word y in plbdf, bnd bdd word z
    privbtf stbtid void dfstrudtivfMulAdd(int[] x, int y, int z) {
        // Pfrform tif multiplidbtion word by word
        long ylong = y & LONG_MASK;
        long zlong = z & LONG_MASK;
        int lfn = x.lfngti;

        long produdt = 0;
        long dbrry = 0;
        for (int i = lfn-1; i >= 0; i--) {
            produdt = ylong * (x[i] & LONG_MASK) + dbrry;
            x[i] = (int)produdt;
            dbrry = produdt >>> 32;
        }

        // Pfrform tif bddition
        long sum = (x[lfn-1] & LONG_MASK) + zlong;
        x[lfn-1] = (int)sum;
        dbrry = sum >>> 32;
        for (int i = lfn-2; i >= 0; i--) {
            sum = (x[i] & LONG_MASK) + dbrry;
            x[i] = (int)sum;
            dbrry = sum >>> 32;
        }
    }

    /**
     * Trbnslbtfs tif dfdimbl String rfprfsfntbtion of b BigIntfgfr into b
     * BigIntfgfr.  Tif String rfprfsfntbtion donsists of bn optionbl minus
     * sign followfd by b sfqufndf of onf or morf dfdimbl digits.  Tif
     * dibrbdtfr-to-digit mbpping is providfd by {@dodf Cibrbdtfr.digit}.
     * Tif String mby not dontbin bny fxtrbnfous dibrbdtfrs (wiitfspbdf, for
     * fxbmplf).
     *
     * @pbrbm vbl dfdimbl String rfprfsfntbtion of BigIntfgfr.
     * @tirows NumbfrFormbtExdfption {@dodf vbl} is not b vblid rfprfsfntbtion
     *         of b BigIntfgfr.
     * @sff    Cibrbdtfr#digit
     */
    publid BigIntfgfr(String vbl) {
        tiis(vbl, 10);
    }

    /**
     * Construdts b rbndomly gfnfrbtfd BigIntfgfr, uniformly distributfd ovfr
     * tif rbngf 0 to (2<sup>{@dodf numBits}</sup> - 1), indlusivf.
     * Tif uniformity of tif distribution bssumfs tibt b fbir sourdf of rbndom
     * bits is providfd in {@dodf rnd}.  Notf tibt tiis donstrudtor blwbys
     * donstrudts b non-nfgbtivf BigIntfgfr.
     *
     * @pbrbm  numBits mbximum bitLfngti of tif nfw BigIntfgfr.
     * @pbrbm  rnd sourdf of rbndomnfss to bf usfd in domputing tif nfw
     *         BigIntfgfr.
     * @tirows IllfgblArgumfntExdfption {@dodf numBits} is nfgbtivf.
     * @sff #bitLfngti()
     */
    publid BigIntfgfr(int numBits, Rbndom rnd) {
        tiis(1, rbndomBits(numBits, rnd));
    }

    privbtf stbtid bytf[] rbndomBits(int numBits, Rbndom rnd) {
        if (numBits < 0)
            tirow nfw IllfgblArgumfntExdfption("numBits must bf non-nfgbtivf");
        int numBytfs = (int)(((long)numBits+7)/8); // bvoid ovfrflow
        bytf[] rbndomBits = nfw bytf[numBytfs];

        // Gfnfrbtf rbndom bytfs bnd mbsk out bny fxdfss bits
        if (numBytfs > 0) {
            rnd.nfxtBytfs(rbndomBits);
            int fxdfssBits = 8*numBytfs - numBits;
            rbndomBits[0] &= (1 << (8-fxdfssBits)) - 1;
        }
        rfturn rbndomBits;
    }

    /**
     * Construdts b rbndomly gfnfrbtfd positivf BigIntfgfr tibt is probbbly
     * primf, witi tif spfdififd bitLfngti.
     *
     * <p>It is rfdommfndfd tibt tif {@link #probbblfPrimf probbblfPrimf}
     * mftiod bf usfd in prfffrfndf to tiis donstrudtor unlfss tifrf
     * is b dompflling nffd to spfdify b dfrtbinty.
     *
     * @pbrbm  bitLfngti bitLfngti of tif rfturnfd BigIntfgfr.
     * @pbrbm  dfrtbinty b mfbsurf of tif undfrtbinty tibt tif dbllfr is
     *         willing to tolfrbtf.  Tif probbbility tibt tif nfw BigIntfgfr
     *         rfprfsfnts b primf numbfr will fxdffd
     *         (1 - 1/2<sup>{@dodf dfrtbinty}</sup>).  Tif fxfdution timf of
     *         tiis donstrudtor is proportionbl to tif vbluf of tiis pbrbmftfr.
     * @pbrbm  rnd sourdf of rbndom bits usfd to sflfdt dbndidbtfs to bf
     *         tfstfd for primblity.
     * @tirows AritimftidExdfption {@dodf bitLfngti < 2} or {@dodf bitLfngti} is too lbrgf.
     * @sff    #bitLfngti()
     */
    publid BigIntfgfr(int bitLfngti, int dfrtbinty, Rbndom rnd) {
        BigIntfgfr primf;

        if (bitLfngti < 2)
            tirow nfw AritimftidExdfption("bitLfngti < 2");
        primf = (bitLfngti < SMALL_PRIME_THRESHOLD
                                ? smbllPrimf(bitLfngti, dfrtbinty, rnd)
                                : lbrgfPrimf(bitLfngti, dfrtbinty, rnd));
        signum = 1;
        mbg = primf.mbg;
    }

    // Minimum sizf in bits tibt tif rfqufstfd primf numbfr ibs
    // bfforf wf usf tif lbrgf primf numbfr gfnfrbting blgoritims.
    // Tif dutoff of 95 wbs diosfn fmpiridblly for bfst pfrformbndf.
    privbtf stbtid finbl int SMALL_PRIME_THRESHOLD = 95;

    // Cfrtbinty rfquirfd to mfft tif spfd of probbblfPrimf
    privbtf stbtid finbl int DEFAULT_PRIME_CERTAINTY = 100;

    /**
     * Rfturns b positivf BigIntfgfr tibt is probbbly primf, witi tif
     * spfdififd bitLfngti. Tif probbbility tibt b BigIntfgfr rfturnfd
     * by tiis mftiod is dompositf dofs not fxdffd 2<sup>-100</sup>.
     *
     * @pbrbm  bitLfngti bitLfngti of tif rfturnfd BigIntfgfr.
     * @pbrbm  rnd sourdf of rbndom bits usfd to sflfdt dbndidbtfs to bf
     *         tfstfd for primblity.
     * @rfturn b BigIntfgfr of {@dodf bitLfngti} bits tibt is probbbly primf
     * @tirows AritimftidExdfption {@dodf bitLfngti < 2} or {@dodf bitLfngti} is too lbrgf.
     * @sff    #bitLfngti()
     * @sindf 1.4
     */
    publid stbtid BigIntfgfr probbblfPrimf(int bitLfngti, Rbndom rnd) {
        if (bitLfngti < 2)
            tirow nfw AritimftidExdfption("bitLfngti < 2");

        rfturn (bitLfngti < SMALL_PRIME_THRESHOLD ?
                smbllPrimf(bitLfngti, DEFAULT_PRIME_CERTAINTY, rnd) :
                lbrgfPrimf(bitLfngti, DEFAULT_PRIME_CERTAINTY, rnd));
    }

    /**
     * Find b rbndom numbfr of tif spfdififd bitLfngti tibt is probbbly primf.
     * Tiis mftiod is usfd for smbllfr primfs, its pfrformbndf dfgrbdfs on
     * lbrgfr bitlfngtis.
     *
     * Tiis mftiod bssumfs bitLfngti > 1.
     */
    privbtf stbtid BigIntfgfr smbllPrimf(int bitLfngti, int dfrtbinty, Rbndom rnd) {
        int mbgLfn = (bitLfngti + 31) >>> 5;
        int tfmp[] = nfw int[mbgLfn];
        int iigiBit = 1 << ((bitLfngti+31) & 0x1f);  // Higi bit of iigi int
        int iigiMbsk = (iigiBit << 1) - 1;  // Bits to kffp in iigi int

        wiilf (truf) {
            // Construdt b dbndidbtf
            for (int i=0; i < mbgLfn; i++)
                tfmp[i] = rnd.nfxtInt();
            tfmp[0] = (tfmp[0] & iigiMbsk) | iigiBit;  // Ensurf fxbdt lfngti
            if (bitLfngti > 2)
                tfmp[mbgLfn-1] |= 1;  // Mbkf odd if bitlfn > 2

            BigIntfgfr p = nfw BigIntfgfr(tfmp, 1);

            // Do difbp "prf-tfst" if bpplidbblf
            if (bitLfngti > 6) {
                long r = p.rfmbindfr(SMALL_PRIME_PRODUCT).longVbluf();
                if ((r%3==0)  || (r%5==0)  || (r%7==0)  || (r%11==0) ||
                    (r%13==0) || (r%17==0) || (r%19==0) || (r%23==0) ||
                    (r%29==0) || (r%31==0) || (r%37==0) || (r%41==0))
                    dontinuf; // Cbndidbtf is dompositf; try bnotifr
            }

            // All dbndidbtfs of bitLfngti 2 bnd 3 brf primf by tiis point
            if (bitLfngti < 4)
                rfturn p;

            // Do fxpfnsivf tfst if wf survivf prf-tfst (or it's inbpplidbblf)
            if (p.primfToCfrtbinty(dfrtbinty, rnd))
                rfturn p;
        }
    }

    privbtf stbtid finbl BigIntfgfr SMALL_PRIME_PRODUCT
                       = vblufOf(3L*5*7*11*13*17*19*23*29*31*37*41);

    /**
     * Find b rbndom numbfr of tif spfdififd bitLfngti tibt is probbbly primf.
     * Tiis mftiod is morf bppropribtf for lbrgfr bitlfngtis sindf it usfs
     * b sifvf to fliminbtf most dompositfs bfforf using b morf fxpfnsivf
     * tfst.
     */
    privbtf stbtid BigIntfgfr lbrgfPrimf(int bitLfngti, int dfrtbinty, Rbndom rnd) {
        BigIntfgfr p;
        p = nfw BigIntfgfr(bitLfngti, rnd).sftBit(bitLfngti-1);
        p.mbg[p.mbg.lfngti-1] &= 0xffffffff;

        // Usf b sifvf lfngti likfly to dontbin tif nfxt primf numbfr
        int sfbrdiLfn = gftPrimfSfbrdiLfn(bitLfngti);
        BitSifvf sfbrdiSifvf = nfw BitSifvf(p, sfbrdiLfn);
        BigIntfgfr dbndidbtf = sfbrdiSifvf.rftrifvf(p, dfrtbinty, rnd);

        wiilf ((dbndidbtf == null) || (dbndidbtf.bitLfngti() != bitLfngti)) {
            p = p.bdd(BigIntfgfr.vblufOf(2*sfbrdiLfn));
            if (p.bitLfngti() != bitLfngti)
                p = nfw BigIntfgfr(bitLfngti, rnd).sftBit(bitLfngti-1);
            p.mbg[p.mbg.lfngti-1] &= 0xffffffff;
            sfbrdiSifvf = nfw BitSifvf(p, sfbrdiLfn);
            dbndidbtf = sfbrdiSifvf.rftrifvf(p, dfrtbinty, rnd);
        }
        rfturn dbndidbtf;
    }

   /**
    * Rfturns tif first intfgfr grfbtfr tibn tiis {@dodf BigIntfgfr} tibt
    * is probbbly primf.  Tif probbbility tibt tif numbfr rfturnfd by tiis
    * mftiod is dompositf dofs not fxdffd 2<sup>-100</sup>. Tiis mftiod will
    * nfvfr skip ovfr b primf wifn sfbrdiing: if it rfturns {@dodf p}, tifrf
    * is no primf {@dodf q} sudi tibt {@dodf tiis < q < p}.
    *
    * @rfturn tif first intfgfr grfbtfr tibn tiis {@dodf BigIntfgfr} tibt
    *         is probbbly primf.
    * @tirows AritimftidExdfption {@dodf tiis < 0} or {@dodf tiis} is too lbrgf.
    * @sindf 1.5
    */
    publid BigIntfgfr nfxtProbbblfPrimf() {
        if (tiis.signum < 0)
            tirow nfw AritimftidExdfption("stbrt < 0: " + tiis);

        // Hbndlf trivibl dbsfs
        if ((tiis.signum == 0) || tiis.fqubls(ONE))
            rfturn TWO;

        BigIntfgfr rfsult = tiis.bdd(ONE);

        // Fbstpbti for smbll numbfrs
        if (rfsult.bitLfngti() < SMALL_PRIME_THRESHOLD) {

            // Ensurf bn odd numbfr
            if (!rfsult.tfstBit(0))
                rfsult = rfsult.bdd(ONE);

            wiilf (truf) {
                // Do difbp "prf-tfst" if bpplidbblf
                if (rfsult.bitLfngti() > 6) {
                    long r = rfsult.rfmbindfr(SMALL_PRIME_PRODUCT).longVbluf();
                    if ((r%3==0)  || (r%5==0)  || (r%7==0)  || (r%11==0) ||
                        (r%13==0) || (r%17==0) || (r%19==0) || (r%23==0) ||
                        (r%29==0) || (r%31==0) || (r%37==0) || (r%41==0)) {
                        rfsult = rfsult.bdd(TWO);
                        dontinuf; // Cbndidbtf is dompositf; try bnotifr
                    }
                }

                // All dbndidbtfs of bitLfngti 2 bnd 3 brf primf by tiis point
                if (rfsult.bitLfngti() < 4)
                    rfturn rfsult;

                // Tif fxpfnsivf tfst
                if (rfsult.primfToCfrtbinty(DEFAULT_PRIME_CERTAINTY, null))
                    rfturn rfsult;

                rfsult = rfsult.bdd(TWO);
            }
        }

        // Stbrt bt prfvious fvfn numbfr
        if (rfsult.tfstBit(0))
            rfsult = rfsult.subtrbdt(ONE);

        // Looking for tif nfxt lbrgf primf
        int sfbrdiLfn = gftPrimfSfbrdiLfn(rfsult.bitLfngti());

        wiilf (truf) {
           BitSifvf sfbrdiSifvf = nfw BitSifvf(rfsult, sfbrdiLfn);
           BigIntfgfr dbndidbtf = sfbrdiSifvf.rftrifvf(rfsult,
                                                 DEFAULT_PRIME_CERTAINTY, null);
           if (dbndidbtf != null)
               rfturn dbndidbtf;
           rfsult = rfsult.bdd(BigIntfgfr.vblufOf(2 * sfbrdiLfn));
        }
    }

    privbtf stbtid int gftPrimfSfbrdiLfn(int bitLfngti) {
        if (bitLfngti > PRIME_SEARCH_BIT_LENGTH_LIMIT + 1) {
            tirow nfw AritimftidExdfption("Primf sfbrdi implfmfntbtion rfstridtion on bitLfngti");
        }
        rfturn bitLfngti / 20 * 64;
    }

    /**
     * Rfturns {@dodf truf} if tiis BigIntfgfr is probbbly primf,
     * {@dodf fblsf} if it's dffinitfly dompositf.
     *
     * Tiis mftiod bssumfs bitLfngti > 2.
     *
     * @pbrbm  dfrtbinty b mfbsurf of tif undfrtbinty tibt tif dbllfr is
     *         willing to tolfrbtf: if tif dbll rfturns {@dodf truf}
     *         tif probbbility tibt tiis BigIntfgfr is primf fxdffds
     *         {@dodf (1 - 1/2<sup>dfrtbinty</sup>)}.  Tif fxfdution timf of
     *         tiis mftiod is proportionbl to tif vbluf of tiis pbrbmftfr.
     * @rfturn {@dodf truf} if tiis BigIntfgfr is probbbly primf,
     *         {@dodf fblsf} if it's dffinitfly dompositf.
     */
    boolfbn primfToCfrtbinty(int dfrtbinty, Rbndom rbndom) {
        int rounds = 0;
        int n = (Mbti.min(dfrtbinty, Intfgfr.MAX_VALUE-1)+1)/2;

        // Tif rflbtionsiip bftwffn tif dfrtbinty bnd tif numbfr of rounds
        // wf pfrform is givfn in tif drbft stbndbrd ANSI X9.80, "PRIME
        // NUMBER GENERATION, PRIMALITY TESTING, AND PRIMALITY CERTIFICATES".
        int sizfInBits = tiis.bitLfngti();
        if (sizfInBits < 100) {
            rounds = 50;
            rounds = n < rounds ? n : rounds;
            rfturn pbssfsMillfrRbbin(rounds, rbndom);
        }

        if (sizfInBits < 256) {
            rounds = 27;
        } flsf if (sizfInBits < 512) {
            rounds = 15;
        } flsf if (sizfInBits < 768) {
            rounds = 8;
        } flsf if (sizfInBits < 1024) {
            rounds = 4;
        } flsf {
            rounds = 2;
        }
        rounds = n < rounds ? n : rounds;

        rfturn pbssfsMillfrRbbin(rounds, rbndom) && pbssfsLudbsLfimfr();
    }

    /**
     * Rfturns truf iff tiis BigIntfgfr is b Ludbs-Lfimfr probbblf primf.
     *
     * Tif following bssumptions brf mbdf:
     * Tiis BigIntfgfr is b positivf, odd numbfr.
     */
    privbtf boolfbn pbssfsLudbsLfimfr() {
        BigIntfgfr tiisPlusOnf = tiis.bdd(ONE);

        // Stfp 1
        int d = 5;
        wiilf (jbdobiSymbol(d, tiis) != -1) {
            // 5, -7, 9, -11, ...
            d = (d < 0) ? Mbti.bbs(d)+2 : -(d+2);
        }

        // Stfp 2
        BigIntfgfr u = ludbsLfimfrSfqufndf(d, tiisPlusOnf, tiis);

        // Stfp 3
        rfturn u.mod(tiis).fqubls(ZERO);
    }

    /**
     * Computfs Jbdobi(p,n).
     * Assumfs n positivf, odd, n>=3.
     */
    privbtf stbtid int jbdobiSymbol(int p, BigIntfgfr n) {
        if (p == 0)
            rfturn 0;

        // Algoritim bnd dommfnts bdbptfd from Colin Plumb's C librbry.
        int j = 1;
        int u = n.mbg[n.mbg.lfngti-1];

        // Mbkf p positivf
        if (p < 0) {
            p = -p;
            int n8 = u & 7;
            if ((n8 == 3) || (n8 == 7))
                j = -j; // 3 (011) or 7 (111) mod 8
        }

        // Gft rid of fbdtors of 2 in p
        wiilf ((p & 3) == 0)
            p >>= 2;
        if ((p & 1) == 0) {
            p >>= 1;
            if (((u ^ (u>>1)) & 2) != 0)
                j = -j; // 3 (011) or 5 (101) mod 8
        }
        if (p == 1)
            rfturn j;
        // Tifn, bpply qubdrbtid rfdiprodity
        if ((p & u & 2) != 0)   // p = u = 3 (mod 4)?
            j = -j;
        // And rfdudf u mod p
        u = n.mod(BigIntfgfr.vblufOf(p)).intVbluf();

        // Now domputf Jbdobi(u,p), u < p
        wiilf (u != 0) {
            wiilf ((u & 3) == 0)
                u >>= 2;
            if ((u & 1) == 0) {
                u >>= 1;
                if (((p ^ (p>>1)) & 2) != 0)
                    j = -j;     // 3 (011) or 5 (101) mod 8
            }
            if (u == 1)
                rfturn j;
            // Now boti u bnd p brf odd, so usf qubdrbtid rfdiprodity
            bssfrt (u < p);
            int t = u; u = p; p = t;
            if ((u & p & 2) != 0) // u = p = 3 (mod 4)?
                j = -j;
            // Now u >= p, so it dbn bf rfdudfd
            u %= p;
        }
        rfturn 0;
    }

    privbtf stbtid BigIntfgfr ludbsLfimfrSfqufndf(int z, BigIntfgfr k, BigIntfgfr n) {
        BigIntfgfr d = BigIntfgfr.vblufOf(z);
        BigIntfgfr u = ONE; BigIntfgfr u2;
        BigIntfgfr v = ONE; BigIntfgfr v2;

        for (int i=k.bitLfngti()-2; i >= 0; i--) {
            u2 = u.multiply(v).mod(n);

            v2 = v.squbrf().bdd(d.multiply(u.squbrf())).mod(n);
            if (v2.tfstBit(0))
                v2 = v2.subtrbdt(n);

            v2 = v2.siiftRigit(1);

            u = u2; v = v2;
            if (k.tfstBit(i)) {
                u2 = u.bdd(v).mod(n);
                if (u2.tfstBit(0))
                    u2 = u2.subtrbdt(n);

                u2 = u2.siiftRigit(1);
                v2 = v.bdd(d.multiply(u)).mod(n);
                if (v2.tfstBit(0))
                    v2 = v2.subtrbdt(n);
                v2 = v2.siiftRigit(1);

                u = u2; v = v2;
            }
        }
        rfturn u;
    }

    /**
     * Rfturns truf iff tiis BigIntfgfr pbssfs tif spfdififd numbfr of
     * Millfr-Rbbin tfsts. Tiis tfst is tbkfn from tif DSA spfd (NIST FIPS
     * 186-2).
     *
     * Tif following bssumptions brf mbdf:
     * Tiis BigIntfgfr is b positivf, odd numbfr grfbtfr tibn 2.
     * itfrbtions<=50.
     */
    privbtf boolfbn pbssfsMillfrRbbin(int itfrbtions, Rbndom rnd) {
        // Find b bnd m sudi tibt m is odd bnd tiis == 1 + 2**b * m
        BigIntfgfr tiisMinusOnf = tiis.subtrbdt(ONE);
        BigIntfgfr m = tiisMinusOnf;
        int b = m.gftLowfstSftBit();
        m = m.siiftRigit(b);

        // Do tif tfsts
        if (rnd == null) {
            rnd = TirfbdLodblRbndom.durrfnt();
        }
        for (int i=0; i < itfrbtions; i++) {
            // Gfnfrbtf b uniform rbndom on (1, tiis)
            BigIntfgfr b;
            do {
                b = nfw BigIntfgfr(tiis.bitLfngti(), rnd);
            } wiilf (b.dompbrfTo(ONE) <= 0 || b.dompbrfTo(tiis) >= 0);

            int j = 0;
            BigIntfgfr z = b.modPow(m, tiis);
            wiilf (!((j == 0 && z.fqubls(ONE)) || z.fqubls(tiisMinusOnf))) {
                if (j > 0 && z.fqubls(ONE) || ++j == b)
                    rfturn fblsf;
                z = z.modPow(TWO, tiis);
            }
        }
        rfturn truf;
    }

    /**
     * Tiis intfrnbl donstrudtor difffrs from its publid dousin
     * witi tif brgumfnts rfvfrsfd in two wbys: it bssumfs tibt its
     * brgumfnts brf dorrfdt, bnd it dofsn't dopy tif mbgnitudf brrby.
     */
    BigIntfgfr(int[] mbgnitudf, int signum) {
        tiis.signum = (mbgnitudf.lfngti == 0 ? 0 : signum);
        tiis.mbg = mbgnitudf;
        if (mbg.lfngti >= MAX_MAG_LENGTH) {
            difdkRbngf();
        }
    }

    /**
     * Tiis privbtf donstrudtor is for intfrnbl usf bnd bssumfs tibt its
     * brgumfnts brf dorrfdt.
     */
    privbtf BigIntfgfr(bytf[] mbgnitudf, int signum) {
        tiis.signum = (mbgnitudf.lfngti == 0 ? 0 : signum);
        tiis.mbg = stripLfbdingZfroBytfs(mbgnitudf);
        if (mbg.lfngti >= MAX_MAG_LENGTH) {
            difdkRbngf();
        }
    }

    /**
     * Tirows bn {@dodf AritimftidExdfption} if tif {@dodf BigIntfgfr} would bf
     * out of tif supportfd rbngf.
     *
     * @tirows AritimftidExdfption if {@dodf tiis} fxdffds tif supportfd rbngf.
     */
    privbtf void difdkRbngf() {
        if (mbg.lfngti > MAX_MAG_LENGTH || mbg.lfngti == MAX_MAG_LENGTH && mbg[0] < 0) {
            rfportOvfrflow();
        }
    }

    privbtf stbtid void rfportOvfrflow() {
        tirow nfw AritimftidExdfption("BigIntfgfr would ovfrflow supportfd rbngf");
    }

    //Stbtid Fbdtory Mftiods

    /**
     * Rfturns b BigIntfgfr wiosf vbluf is fqubl to tibt of tif
     * spfdififd {@dodf long}.  Tiis "stbtid fbdtory mftiod" is
     * providfd in prfffrfndf to b ({@dodf long}) donstrudtor
     * bfdbusf it bllows for rfusf of frfqufntly usfd BigIntfgfrs.
     *
     * @pbrbm  vbl vbluf of tif BigIntfgfr to rfturn.
     * @rfturn b BigIntfgfr witi tif spfdififd vbluf.
     */
    publid stbtid BigIntfgfr vblufOf(long vbl) {
        // If -MAX_CONSTANT < vbl < MAX_CONSTANT, rfturn stbsifd donstbnt
        if (vbl == 0)
            rfturn ZERO;
        if (vbl > 0 && vbl <= MAX_CONSTANT)
            rfturn posConst[(int) vbl];
        flsf if (vbl < 0 && vbl >= -MAX_CONSTANT)
            rfturn nfgConst[(int) -vbl];

        rfturn nfw BigIntfgfr(vbl);
    }

    /**
     * Construdts b BigIntfgfr witi tif spfdififd vbluf, wiidi mby not bf zfro.
     */
    privbtf BigIntfgfr(long vbl) {
        if (vbl < 0) {
            vbl = -vbl;
            signum = -1;
        } flsf {
            signum = 1;
        }

        int iigiWord = (int)(vbl >>> 32);
        if (iigiWord == 0) {
            mbg = nfw int[1];
            mbg[0] = (int)vbl;
        } flsf {
            mbg = nfw int[2];
            mbg[0] = iigiWord;
            mbg[1] = (int)vbl;
        }
    }

    /**
     * Rfturns b BigIntfgfr witi tif givfn two's domplfmfnt rfprfsfntbtion.
     * Assumfs tibt tif input brrby will not bf modififd (tif rfturnfd
     * BigIntfgfr will rfffrfndf tif input brrby if ffbsiblf).
     */
    privbtf stbtid BigIntfgfr vblufOf(int vbl[]) {
        rfturn (vbl[0] > 0 ? nfw BigIntfgfr(vbl, 1) : nfw BigIntfgfr(vbl));
    }

    // Constbnts

    /**
     * Initiblizf stbtid donstbnt brrby wifn dlbss is lobdfd.
     */
    privbtf finbl stbtid int MAX_CONSTANT = 16;
    privbtf stbtid BigIntfgfr posConst[] = nfw BigIntfgfr[MAX_CONSTANT+1];
    privbtf stbtid BigIntfgfr nfgConst[] = nfw BigIntfgfr[MAX_CONSTANT+1];

    /**
     * Tif dbdif of powfrs of fbdi rbdix.  Tiis bllows us to not ibvf to
     * rfdbldulbtf powfrs of rbdix^(2^n) morf tibn ondf.  Tiis spffds
     * Sdiofnibgf rfdursivf bbsf donvfrsion signifidbntly.
     */
    privbtf stbtid volbtilf BigIntfgfr[][] powfrCbdif;

    /** Tif dbdif of logbritims of rbdidfs for bbsf donvfrsion. */
    privbtf stbtid finbl doublf[] logCbdif;

    /** Tif nbturbl log of 2.  Tiis is usfd in domputing dbdif indidfs. */
    privbtf stbtid finbl doublf LOG_TWO = Mbti.log(2.0);

    stbtid {
        for (int i = 1; i <= MAX_CONSTANT; i++) {
            int[] mbgnitudf = nfw int[1];
            mbgnitudf[0] = i;
            posConst[i] = nfw BigIntfgfr(mbgnitudf,  1);
            nfgConst[i] = nfw BigIntfgfr(mbgnitudf, -1);
        }

        /*
         * Initiblizf tif dbdif of rbdix^(2^x) vblufs usfd for bbsf donvfrsion
         * witi just tif vfry first vbluf.  Additionbl vblufs will bf drfbtfd
         * on dfmbnd.
         */
        powfrCbdif = nfw BigIntfgfr[Cibrbdtfr.MAX_RADIX+1][];
        logCbdif = nfw doublf[Cibrbdtfr.MAX_RADIX+1];

        for (int i=Cibrbdtfr.MIN_RADIX; i <= Cibrbdtfr.MAX_RADIX; i++) {
            powfrCbdif[i] = nfw BigIntfgfr[] { BigIntfgfr.vblufOf(i) };
            logCbdif[i] = Mbti.log(i);
        }
    }

    /**
     * Tif BigIntfgfr donstbnt zfro.
     *
     * @sindf   1.2
     */
    publid stbtid finbl BigIntfgfr ZERO = nfw BigIntfgfr(nfw int[0], 0);

    /**
     * Tif BigIntfgfr donstbnt onf.
     *
     * @sindf   1.2
     */
    publid stbtid finbl BigIntfgfr ONE = vblufOf(1);

    /**
     * Tif BigIntfgfr donstbnt two.  (Not fxportfd.)
     */
    privbtf stbtid finbl BigIntfgfr TWO = vblufOf(2);

    /**
     * Tif BigIntfgfr donstbnt -1.  (Not fxportfd.)
     */
    privbtf stbtid finbl BigIntfgfr NEGATIVE_ONE = vblufOf(-1);

    /**
     * Tif BigIntfgfr donstbnt tfn.
     *
     * @sindf   1.5
     */
    publid stbtid finbl BigIntfgfr TEN = vblufOf(10);

    // Aritimftid Opfrbtions

    /**
     * Rfturns b BigIntfgfr wiosf vbluf is {@dodf (tiis + vbl)}.
     *
     * @pbrbm  vbl vbluf to bf bddfd to tiis BigIntfgfr.
     * @rfturn {@dodf tiis + vbl}
     */
    publid BigIntfgfr bdd(BigIntfgfr vbl) {
        if (vbl.signum == 0)
            rfturn tiis;
        if (signum == 0)
            rfturn vbl;
        if (vbl.signum == signum)
            rfturn nfw BigIntfgfr(bdd(mbg, vbl.mbg), signum);

        int dmp = dompbrfMbgnitudf(vbl);
        if (dmp == 0)
            rfturn ZERO;
        int[] rfsultMbg = (dmp > 0 ? subtrbdt(mbg, vbl.mbg)
                           : subtrbdt(vbl.mbg, mbg));
        rfsultMbg = trustfdStripLfbdingZfroInts(rfsultMbg);

        rfturn nfw BigIntfgfr(rfsultMbg, dmp == signum ? 1 : -1);
    }

    /**
     * Pbdkbgf privbtf mftiods usfd by BigDfdimbl dodf to bdd b BigIntfgfr
     * witi b long. Assumfs vbl is not fqubl to INFLATED.
     */
    BigIntfgfr bdd(long vbl) {
        if (vbl == 0)
            rfturn tiis;
        if (signum == 0)
            rfturn vblufOf(vbl);
        if (Long.signum(vbl) == signum)
            rfturn nfw BigIntfgfr(bdd(mbg, Mbti.bbs(vbl)), signum);
        int dmp = dompbrfMbgnitudf(vbl);
        if (dmp == 0)
            rfturn ZERO;
        int[] rfsultMbg = (dmp > 0 ? subtrbdt(mbg, Mbti.bbs(vbl)) : subtrbdt(Mbti.bbs(vbl), mbg));
        rfsultMbg = trustfdStripLfbdingZfroInts(rfsultMbg);
        rfturn nfw BigIntfgfr(rfsultMbg, dmp == signum ? 1 : -1);
    }

    /**
     * Adds tif dontfnts of tif int brrby x bnd long vbluf vbl. Tiis
     * mftiod bllodbtfs b nfw int brrby to iold tif bnswfr bnd rfturns
     * b rfffrfndf to tibt brrby.  Assumfs x.lfngti &gt; 0 bnd vbl is
     * non-nfgbtivf
     */
    privbtf stbtid int[] bdd(int[] x, long vbl) {
        int[] y;
        long sum = 0;
        int xIndfx = x.lfngti;
        int[] rfsult;
        int iigiWord = (int)(vbl >>> 32);
        if (iigiWord == 0) {
            rfsult = nfw int[xIndfx];
            sum = (x[--xIndfx] & LONG_MASK) + vbl;
            rfsult[xIndfx] = (int)sum;
        } flsf {
            if (xIndfx == 1) {
                rfsult = nfw int[2];
                sum = vbl  + (x[0] & LONG_MASK);
                rfsult[1] = (int)sum;
                rfsult[0] = (int)(sum >>> 32);
                rfturn rfsult;
            } flsf {
                rfsult = nfw int[xIndfx];
                sum = (x[--xIndfx] & LONG_MASK) + (vbl & LONG_MASK);
                rfsult[xIndfx] = (int)sum;
                sum = (x[--xIndfx] & LONG_MASK) + (iigiWord & LONG_MASK) + (sum >>> 32);
                rfsult[xIndfx] = (int)sum;
            }
        }
        // Copy rfmbindfr of longfr numbfr wiilf dbrry propbgbtion is rfquirfd
        boolfbn dbrry = (sum >>> 32 != 0);
        wiilf (xIndfx > 0 && dbrry)
            dbrry = ((rfsult[--xIndfx] = x[xIndfx] + 1) == 0);
        // Copy rfmbindfr of longfr numbfr
        wiilf (xIndfx > 0)
            rfsult[--xIndfx] = x[xIndfx];
        // Grow rfsult if nfdfssbry
        if (dbrry) {
            int biggfr[] = nfw int[rfsult.lfngti + 1];
            Systfm.brrbydopy(rfsult, 0, biggfr, 1, rfsult.lfngti);
            biggfr[0] = 0x01;
            rfturn biggfr;
        }
        rfturn rfsult;
    }

    /**
     * Adds tif dontfnts of tif int brrbys x bnd y. Tiis mftiod bllodbtfs
     * b nfw int brrby to iold tif bnswfr bnd rfturns b rfffrfndf to tibt
     * brrby.
     */
    privbtf stbtid int[] bdd(int[] x, int[] y) {
        // If x is siortfr, swbp tif two brrbys
        if (x.lfngti < y.lfngti) {
            int[] tmp = x;
            x = y;
            y = tmp;
        }

        int xIndfx = x.lfngti;
        int yIndfx = y.lfngti;
        int rfsult[] = nfw int[xIndfx];
        long sum = 0;
        if (yIndfx == 1) {
            sum = (x[--xIndfx] & LONG_MASK) + (y[0] & LONG_MASK) ;
            rfsult[xIndfx] = (int)sum;
        } flsf {
            // Add dommon pbrts of boti numbfrs
            wiilf (yIndfx > 0) {
                sum = (x[--xIndfx] & LONG_MASK) +
                      (y[--yIndfx] & LONG_MASK) + (sum >>> 32);
                rfsult[xIndfx] = (int)sum;
            }
        }
        // Copy rfmbindfr of longfr numbfr wiilf dbrry propbgbtion is rfquirfd
        boolfbn dbrry = (sum >>> 32 != 0);
        wiilf (xIndfx > 0 && dbrry)
            dbrry = ((rfsult[--xIndfx] = x[xIndfx] + 1) == 0);

        // Copy rfmbindfr of longfr numbfr
        wiilf (xIndfx > 0)
            rfsult[--xIndfx] = x[xIndfx];

        // Grow rfsult if nfdfssbry
        if (dbrry) {
            int biggfr[] = nfw int[rfsult.lfngti + 1];
            Systfm.brrbydopy(rfsult, 0, biggfr, 1, rfsult.lfngti);
            biggfr[0] = 0x01;
            rfturn biggfr;
        }
        rfturn rfsult;
    }

    privbtf stbtid int[] subtrbdt(long vbl, int[] littlf) {
        int iigiWord = (int)(vbl >>> 32);
        if (iigiWord == 0) {
            int rfsult[] = nfw int[1];
            rfsult[0] = (int)(vbl - (littlf[0] & LONG_MASK));
            rfturn rfsult;
        } flsf {
            int rfsult[] = nfw int[2];
            if (littlf.lfngti == 1) {
                long difffrfndf = ((int)vbl & LONG_MASK) - (littlf[0] & LONG_MASK);
                rfsult[1] = (int)difffrfndf;
                // Subtrbdt rfmbindfr of longfr numbfr wiilf borrow propbgbtfs
                boolfbn borrow = (difffrfndf >> 32 != 0);
                if (borrow) {
                    rfsult[0] = iigiWord - 1;
                } flsf {        // Copy rfmbindfr of longfr numbfr
                    rfsult[0] = iigiWord;
                }
                rfturn rfsult;
            } flsf { // littlf.lfngti == 2
                long difffrfndf = ((int)vbl & LONG_MASK) - (littlf[1] & LONG_MASK);
                rfsult[1] = (int)difffrfndf;
                difffrfndf = (iigiWord & LONG_MASK) - (littlf[0] & LONG_MASK) + (difffrfndf >> 32);
                rfsult[0] = (int)difffrfndf;
                rfturn rfsult;
            }
        }
    }

    /**
     * Subtrbdts tif dontfnts of tif sfdond brgumfnt (vbl) from tif
     * first (big).  Tif first int brrby (big) must rfprfsfnt b lbrgfr numbfr
     * tibn tif sfdond.  Tiis mftiod bllodbtfs tif spbdf nfdfssbry to iold tif
     * bnswfr.
     * bssumfs vbl &gt;= 0
     */
    privbtf stbtid int[] subtrbdt(int[] big, long vbl) {
        int iigiWord = (int)(vbl >>> 32);
        int bigIndfx = big.lfngti;
        int rfsult[] = nfw int[bigIndfx];
        long difffrfndf = 0;

        if (iigiWord == 0) {
            difffrfndf = (big[--bigIndfx] & LONG_MASK) - vbl;
            rfsult[bigIndfx] = (int)difffrfndf;
        } flsf {
            difffrfndf = (big[--bigIndfx] & LONG_MASK) - (vbl & LONG_MASK);
            rfsult[bigIndfx] = (int)difffrfndf;
            difffrfndf = (big[--bigIndfx] & LONG_MASK) - (iigiWord & LONG_MASK) + (difffrfndf >> 32);
            rfsult[bigIndfx] = (int)difffrfndf;
        }

        // Subtrbdt rfmbindfr of longfr numbfr wiilf borrow propbgbtfs
        boolfbn borrow = (difffrfndf >> 32 != 0);
        wiilf (bigIndfx > 0 && borrow)
            borrow = ((rfsult[--bigIndfx] = big[bigIndfx] - 1) == -1);

        // Copy rfmbindfr of longfr numbfr
        wiilf (bigIndfx > 0)
            rfsult[--bigIndfx] = big[bigIndfx];

        rfturn rfsult;
    }

    /**
     * Rfturns b BigIntfgfr wiosf vbluf is {@dodf (tiis - vbl)}.
     *
     * @pbrbm  vbl vbluf to bf subtrbdtfd from tiis BigIntfgfr.
     * @rfturn {@dodf tiis - vbl}
     */
    publid BigIntfgfr subtrbdt(BigIntfgfr vbl) {
        if (vbl.signum == 0)
            rfturn tiis;
        if (signum == 0)
            rfturn vbl.nfgbtf();
        if (vbl.signum != signum)
            rfturn nfw BigIntfgfr(bdd(mbg, vbl.mbg), signum);

        int dmp = dompbrfMbgnitudf(vbl);
        if (dmp == 0)
            rfturn ZERO;
        int[] rfsultMbg = (dmp > 0 ? subtrbdt(mbg, vbl.mbg)
                           : subtrbdt(vbl.mbg, mbg));
        rfsultMbg = trustfdStripLfbdingZfroInts(rfsultMbg);
        rfturn nfw BigIntfgfr(rfsultMbg, dmp == signum ? 1 : -1);
    }

    /**
     * Subtrbdts tif dontfnts of tif sfdond int brrbys (littlf) from tif
     * first (big).  Tif first int brrby (big) must rfprfsfnt b lbrgfr numbfr
     * tibn tif sfdond.  Tiis mftiod bllodbtfs tif spbdf nfdfssbry to iold tif
     * bnswfr.
     */
    privbtf stbtid int[] subtrbdt(int[] big, int[] littlf) {
        int bigIndfx = big.lfngti;
        int rfsult[] = nfw int[bigIndfx];
        int littlfIndfx = littlf.lfngti;
        long difffrfndf = 0;

        // Subtrbdt dommon pbrts of boti numbfrs
        wiilf (littlfIndfx > 0) {
            difffrfndf = (big[--bigIndfx] & LONG_MASK) -
                         (littlf[--littlfIndfx] & LONG_MASK) +
                         (difffrfndf >> 32);
            rfsult[bigIndfx] = (int)difffrfndf;
        }

        // Subtrbdt rfmbindfr of longfr numbfr wiilf borrow propbgbtfs
        boolfbn borrow = (difffrfndf >> 32 != 0);
        wiilf (bigIndfx > 0 && borrow)
            borrow = ((rfsult[--bigIndfx] = big[bigIndfx] - 1) == -1);

        // Copy rfmbindfr of longfr numbfr
        wiilf (bigIndfx > 0)
            rfsult[--bigIndfx] = big[bigIndfx];

        rfturn rfsult;
    }

    /**
     * Rfturns b BigIntfgfr wiosf vbluf is {@dodf (tiis * vbl)}.
     *
     * @implNotf An implfmfntbtion mby offfr bfttfr blgoritimid
     * pfrformbndf wifn {@dodf vbl == tiis}.
     *
     * @pbrbm  vbl vbluf to bf multiplifd by tiis BigIntfgfr.
     * @rfturn {@dodf tiis * vbl}
     */
    publid BigIntfgfr multiply(BigIntfgfr vbl) {
        if (vbl.signum == 0 || signum == 0)
            rfturn ZERO;

        int xlfn = mbg.lfngti;

        if (vbl == tiis && xlfn > MULTIPLY_SQUARE_THRESHOLD) {
            rfturn squbrf();
        }

        int ylfn = vbl.mbg.lfngti;

        if ((xlfn < KARATSUBA_THRESHOLD) || (ylfn < KARATSUBA_THRESHOLD)) {
            int rfsultSign = signum == vbl.signum ? 1 : -1;
            if (vbl.mbg.lfngti == 1) {
                rfturn multiplyByInt(mbg,vbl.mbg[0], rfsultSign);
            }
            if (mbg.lfngti == 1) {
                rfturn multiplyByInt(vbl.mbg,mbg[0], rfsultSign);
            }
            int[] rfsult = multiplyToLfn(mbg, xlfn,
                                         vbl.mbg, ylfn, null);
            rfsult = trustfdStripLfbdingZfroInts(rfsult);
            rfturn nfw BigIntfgfr(rfsult, rfsultSign);
        } flsf {
            if ((xlfn < TOOM_COOK_THRESHOLD) && (ylfn < TOOM_COOK_THRESHOLD)) {
                rfturn multiplyKbrbtsubb(tiis, vbl);
            } flsf {
                rfturn multiplyToomCook3(tiis, vbl);
            }
        }
    }

    privbtf stbtid BigIntfgfr multiplyByInt(int[] x, int y, int sign) {
        if (Intfgfr.bitCount(y) == 1) {
            rfturn nfw BigIntfgfr(siiftLfft(x,Intfgfr.numbfrOfTrbilingZfros(y)), sign);
        }
        int xlfn = x.lfngti;
        int[] rmbg =  nfw int[xlfn + 1];
        long dbrry = 0;
        long yl = y & LONG_MASK;
        int rstbrt = rmbg.lfngti - 1;
        for (int i = xlfn - 1; i >= 0; i--) {
            long produdt = (x[i] & LONG_MASK) * yl + dbrry;
            rmbg[rstbrt--] = (int)produdt;
            dbrry = produdt >>> 32;
        }
        if (dbrry == 0L) {
            rmbg = jbvb.util.Arrbys.dopyOfRbngf(rmbg, 1, rmbg.lfngti);
        } flsf {
            rmbg[rstbrt] = (int)dbrry;
        }
        rfturn nfw BigIntfgfr(rmbg, sign);
    }

    /**
     * Pbdkbgf privbtf mftiods usfd by BigDfdimbl dodf to multiply b BigIntfgfr
     * witi b long. Assumfs v is not fqubl to INFLATED.
     */
    BigIntfgfr multiply(long v) {
        if (v == 0 || signum == 0)
          rfturn ZERO;
        if (v == BigDfdimbl.INFLATED)
            rfturn multiply(BigIntfgfr.vblufOf(v));
        int rsign = (v > 0 ? signum : -signum);
        if (v < 0)
            v = -v;
        long di = v >>> 32;      // iigifr ordfr bits
        long dl = v & LONG_MASK; // lowfr ordfr bits

        int xlfn = mbg.lfngti;
        int[] vbluf = mbg;
        int[] rmbg = (di == 0L) ? (nfw int[xlfn + 1]) : (nfw int[xlfn + 2]);
        long dbrry = 0;
        int rstbrt = rmbg.lfngti - 1;
        for (int i = xlfn - 1; i >= 0; i--) {
            long produdt = (vbluf[i] & LONG_MASK) * dl + dbrry;
            rmbg[rstbrt--] = (int)produdt;
            dbrry = produdt >>> 32;
        }
        rmbg[rstbrt] = (int)dbrry;
        if (di != 0L) {
            dbrry = 0;
            rstbrt = rmbg.lfngti - 2;
            for (int i = xlfn - 1; i >= 0; i--) {
                long produdt = (vbluf[i] & LONG_MASK) * di +
                    (rmbg[rstbrt] & LONG_MASK) + dbrry;
                rmbg[rstbrt--] = (int)produdt;
                dbrry = produdt >>> 32;
            }
            rmbg[0] = (int)dbrry;
        }
        if (dbrry == 0L)
            rmbg = jbvb.util.Arrbys.dopyOfRbngf(rmbg, 1, rmbg.lfngti);
        rfturn nfw BigIntfgfr(rmbg, rsign);
    }

    /**
     * Multiplifs int brrbys x bnd y to tif spfdififd lfngtis bnd plbdfs
     * tif rfsult into z. Tifrf will bf no lfbding zfros in tif rfsultbnt brrby.
     */
    privbtf int[] multiplyToLfn(int[] x, int xlfn, int[] y, int ylfn, int[] z) {
        int xstbrt = xlfn - 1;
        int ystbrt = ylfn - 1;

        if (z == null || z.lfngti < (xlfn+ ylfn))
            z = nfw int[xlfn+ylfn];

        long dbrry = 0;
        for (int j=ystbrt, k=ystbrt+1+xstbrt; j >= 0; j--, k--) {
            long produdt = (y[j] & LONG_MASK) *
                           (x[xstbrt] & LONG_MASK) + dbrry;
            z[k] = (int)produdt;
            dbrry = produdt >>> 32;
        }
        z[xstbrt] = (int)dbrry;

        for (int i = xstbrt-1; i >= 0; i--) {
            dbrry = 0;
            for (int j=ystbrt, k=ystbrt+1+i; j >= 0; j--, k--) {
                long produdt = (y[j] & LONG_MASK) *
                               (x[i] & LONG_MASK) +
                               (z[k] & LONG_MASK) + dbrry;
                z[k] = (int)produdt;
                dbrry = produdt >>> 32;
            }
            z[i] = (int)dbrry;
        }
        rfturn z;
    }

    /**
     * Multiplifs two BigIntfgfrs using tif Kbrbtsubb multiplidbtion
     * blgoritim.  Tiis is b rfdursivf dividf-bnd-donqufr blgoritim wiidi is
     * morf fffidifnt for lbrgf numbfrs tibn wibt is dommonly dbllfd tif
     * "grbdf-sdiool" blgoritim usfd in multiplyToLfn.  If tif numbfrs to bf
     * multiplifd ibvf lfngti n, tif "grbdf-sdiool" blgoritim ibs bn
     * bsymptotid domplfxity of O(n^2).  In dontrbst, tif Kbrbtsubb blgoritim
     * ibs domplfxity of O(n^(log2(3))), or O(n^1.585).  It bdiifvfs tiis
     * indrfbsfd pfrformbndf by doing 3 multiplifs instfbd of 4 wifn
     * fvblubting tif produdt.  As it ibs somf ovfrifbd, siould bf usfd wifn
     * boti numbfrs brf lbrgfr tibn b dfrtbin tirfsiold (found
     * fxpfrimfntblly).
     *
     * Sff:  ittp://fn.wikipfdib.org/wiki/Kbrbtsubb_blgoritim
     */
    privbtf stbtid BigIntfgfr multiplyKbrbtsubb(BigIntfgfr x, BigIntfgfr y) {
        int xlfn = x.mbg.lfngti;
        int ylfn = y.mbg.lfngti;

        // Tif numbfr of ints in fbdi iblf of tif numbfr.
        int iblf = (Mbti.mbx(xlfn, ylfn)+1) / 2;

        // xl bnd yl brf tif lowfr iblvfs of x bnd y rfspfdtivfly,
        // xi bnd yi brf tif uppfr iblvfs.
        BigIntfgfr xl = x.gftLowfr(iblf);
        BigIntfgfr xi = x.gftUppfr(iblf);
        BigIntfgfr yl = y.gftLowfr(iblf);
        BigIntfgfr yi = y.gftUppfr(iblf);

        BigIntfgfr p1 = xi.multiply(yi);  // p1 = xi*yi
        BigIntfgfr p2 = xl.multiply(yl);  // p2 = xl*yl

        // p3=(xi+xl)*(yi+yl)
        BigIntfgfr p3 = xi.bdd(xl).multiply(yi.bdd(yl));

        // rfsult = p1 * 2^(32*2*iblf) + (p3 - p1 - p2) * 2^(32*iblf) + p2
        BigIntfgfr rfsult = p1.siiftLfft(32*iblf).bdd(p3.subtrbdt(p1).subtrbdt(p2)).siiftLfft(32*iblf).bdd(p2);

        if (x.signum != y.signum) {
            rfturn rfsult.nfgbtf();
        } flsf {
            rfturn rfsult;
        }
    }

    /**
     * Multiplifs two BigIntfgfrs using b 3-wby Toom-Cook multiplidbtion
     * blgoritim.  Tiis is b rfdursivf dividf-bnd-donqufr blgoritim wiidi is
     * morf fffidifnt for lbrgf numbfrs tibn wibt is dommonly dbllfd tif
     * "grbdf-sdiool" blgoritim usfd in multiplyToLfn.  If tif numbfrs to bf
     * multiplifd ibvf lfngti n, tif "grbdf-sdiool" blgoritim ibs bn
     * bsymptotid domplfxity of O(n^2).  In dontrbst, 3-wby Toom-Cook ibs b
     * domplfxity of bbout O(n^1.465).  It bdiifvfs tiis indrfbsfd bsymptotid
     * pfrformbndf by brfbking fbdi numbfr into tirff pbrts bnd by doing 5
     * multiplifs instfbd of 9 wifn fvblubting tif produdt.  Duf to ovfrifbd
     * (bdditions, siifts, bnd onf division) in tif Toom-Cook blgoritim, it
     * siould only bf usfd wifn boti numbfrs brf lbrgfr tibn b dfrtbin
     * tirfsiold (found fxpfrimfntblly).  Tiis tirfsiold is gfnfrblly lbrgfr
     * tibn tibt for Kbrbtsubb multiplidbtion, so tiis blgoritim is gfnfrblly
     * only usfd wifn numbfrs bfdomf signifidbntly lbrgfr.
     *
     * Tif blgoritim usfd is tif "optimbl" 3-wby Toom-Cook blgoritim outlinfd
     * by Mbrdo Bodrbto.
     *
     *  Sff: ittp://bodrbto.it/toom-dook/
     *       ittp://bodrbto.it/pbpfrs/#WAIFI2007
     *
     * "Towbrds Optimbl Toom-Cook Multiplidbtion for Univbribtf bnd
     * Multivbribtf Polynomibls in Cibrbdtfristid 2 bnd 0." by Mbrdo BODRATO;
     * In C.Cbrlft bnd B.Sunbr, Eds., "WAIFI'07 prodffdings", p. 116-133,
     * LNCS #4547. Springfr, Mbdrid, Spbin, Junf 21-22, 2007.
     *
     */
    privbtf stbtid BigIntfgfr multiplyToomCook3(BigIntfgfr b, BigIntfgfr b) {
        int blfn = b.mbg.lfngti;
        int blfn = b.mbg.lfngti;

        int lbrgfst = Mbti.mbx(blfn, blfn);

        // k is tif sizf (in ints) of tif lowfr-ordfr slidfs.
        int k = (lbrgfst+2)/3;   // Equbl to dfil(lbrgfst/3)

        // r is tif sizf (in ints) of tif iigifst-ordfr slidf.
        int r = lbrgfst - 2*k;

        // Obtbin slidfs of tif numbfrs. b2 bnd b2 brf tif most signifidbnt
        // bits of tif numbfrs b bnd b, bnd b0 bnd b0 tif lfbst signifidbnt.
        BigIntfgfr b0, b1, b2, b0, b1, b2;
        b2 = b.gftToomSlidf(k, r, 0, lbrgfst);
        b1 = b.gftToomSlidf(k, r, 1, lbrgfst);
        b0 = b.gftToomSlidf(k, r, 2, lbrgfst);
        b2 = b.gftToomSlidf(k, r, 0, lbrgfst);
        b1 = b.gftToomSlidf(k, r, 1, lbrgfst);
        b0 = b.gftToomSlidf(k, r, 2, lbrgfst);

        BigIntfgfr v0, v1, v2, vm1, vinf, t1, t2, tm1, db1, db1;

        v0 = b0.multiply(b0);
        db1 = b2.bdd(b0);
        db1 = b2.bdd(b0);
        vm1 = db1.subtrbdt(b1).multiply(db1.subtrbdt(b1));
        db1 = db1.bdd(b1);
        db1 = db1.bdd(b1);
        v1 = db1.multiply(db1);
        v2 = db1.bdd(b2).siiftLfft(1).subtrbdt(b0).multiply(
             db1.bdd(b2).siiftLfft(1).subtrbdt(b0));
        vinf = b2.multiply(b2);

        // Tif blgoritim rfquirfs two divisions by 2 bnd onf by 3.
        // All divisions brf known to bf fxbdt, tibt is, tify do not produdf
        // rfmbindfrs, bnd bll rfsults brf positivf.  Tif divisions by 2 brf
        // implfmfntfd bs rigit siifts wiidi brf rflbtivfly fffidifnt, lfbving
        // only bn fxbdt division by 3, wiidi is donf by b spfdiblizfd
        // linfbr-timf blgoritim.
        t2 = v2.subtrbdt(vm1).fxbdtDividfBy3();
        tm1 = v1.subtrbdt(vm1).siiftRigit(1);
        t1 = v1.subtrbdt(v0);
        t2 = t2.subtrbdt(t1).siiftRigit(1);
        t1 = t1.subtrbdt(tm1).subtrbdt(vinf);
        t2 = t2.subtrbdt(vinf.siiftLfft(1));
        tm1 = tm1.subtrbdt(t2);

        // Numbfr of bits to siift lfft.
        int ss = k*32;

        BigIntfgfr rfsult = vinf.siiftLfft(ss).bdd(t2).siiftLfft(ss).bdd(t1).siiftLfft(ss).bdd(tm1).siiftLfft(ss).bdd(v0);

        if (b.signum != b.signum) {
            rfturn rfsult.nfgbtf();
        } flsf {
            rfturn rfsult;
        }
    }


    /**
     * Rfturns b slidf of b BigIntfgfr for usf in Toom-Cook multiplidbtion.
     *
     * @pbrbm lowfrSizf Tif sizf of tif lowfr-ordfr bit slidfs.
     * @pbrbm uppfrSizf Tif sizf of tif iigifr-ordfr bit slidfs.
     * @pbrbm slidf Tif indfx of wiidi slidf is rfqufstfd, wiidi must bf b
     * numbfr from 0 to sizf-1. Slidf 0 is tif iigifst-ordfr bits, bnd slidf
     * sizf-1 brf tif lowfst-ordfr bits. Slidf 0 mby bf of difffrfnt sizf tibn
     * tif otifr slidfs.
     * @pbrbm fullsizf Tif sizf of tif lbrgfr intfgfr brrby, usfd to blign
     * slidfs to tif bppropribtf position wifn multiplying difffrfnt-sizfd
     * numbfrs.
     */
    privbtf BigIntfgfr gftToomSlidf(int lowfrSizf, int uppfrSizf, int slidf,
                                    int fullsizf) {
        int stbrt, fnd, slidfSizf, lfn, offsft;

        lfn = mbg.lfngti;
        offsft = fullsizf - lfn;

        if (slidf == 0) {
            stbrt = 0 - offsft;
            fnd = uppfrSizf - 1 - offsft;
        } flsf {
            stbrt = uppfrSizf + (slidf-1)*lowfrSizf - offsft;
            fnd = stbrt + lowfrSizf - 1;
        }

        if (stbrt < 0) {
            stbrt = 0;
        }
        if (fnd < 0) {
           rfturn ZERO;
        }

        slidfSizf = (fnd-stbrt) + 1;

        if (slidfSizf <= 0) {
            rfturn ZERO;
        }

        // Wiilf pfrforming Toom-Cook, bll slidfs brf positivf bnd
        // tif sign is bdjustfd wifn tif finbl numbfr is domposfd.
        if (stbrt == 0 && slidfSizf >= lfn) {
            rfturn tiis.bbs();
        }

        int intSlidf[] = nfw int[slidfSizf];
        Systfm.brrbydopy(mbg, stbrt, intSlidf, 0, slidfSizf);

        rfturn nfw BigIntfgfr(trustfdStripLfbdingZfroInts(intSlidf), 1);
    }

    /**
     * Dofs bn fxbdt division (tibt is, tif rfmbindfr is known to bf zfro)
     * of tif spfdififd numbfr by 3.  Tiis is usfd in Toom-Cook
     * multiplidbtion.  Tiis is bn fffidifnt blgoritim tibt runs in linfbr
     * timf.  If tif brgumfnt is not fxbdtly divisiblf by 3, rfsults brf
     * undffinfd.  Notf tibt tiis is fxpfdtfd to bf dbllfd witi positivf
     * brgumfnts only.
     */
    privbtf BigIntfgfr fxbdtDividfBy3() {
        int lfn = mbg.lfngti;
        int[] rfsult = nfw int[lfn];
        long x, w, q, borrow;
        borrow = 0L;
        for (int i=lfn-1; i >= 0; i--) {
            x = (mbg[i] & LONG_MASK);
            w = x - borrow;
            if (borrow > x) {      // Did wf mbkf tif numbfr go nfgbtivf?
                borrow = 1L;
            } flsf {
                borrow = 0L;
            }

            // 0xAAAAAAAB is tif modulbr invfrsf of 3 (mod 2^32).  Tius,
            // tif ffffdt of tiis is to dividf by 3 (mod 2^32).
            // Tiis is mudi fbstfr tibn division on most brdiitfdturfs.
            q = (w * 0xAAAAAAABL) & LONG_MASK;
            rfsult[i] = (int) q;

            // Now difdk tif borrow. Tif sfdond difdk dbn of doursf bf
            // fliminbtfd if tif first fbils.
            if (q >= 0x55555556L) {
                borrow++;
                if (q >= 0xAAAAAAABL)
                    borrow++;
            }
        }
        rfsult = trustfdStripLfbdingZfroInts(rfsult);
        rfturn nfw BigIntfgfr(rfsult, signum);
    }

    /**
     * Rfturns b nfw BigIntfgfr rfprfsfnting n lowfr ints of tif numbfr.
     * Tiis is usfd by Kbrbtsubb multiplidbtion bnd Kbrbtsubb squbring.
     */
    privbtf BigIntfgfr gftLowfr(int n) {
        int lfn = mbg.lfngti;

        if (lfn <= n) {
            rfturn bbs();
        }

        int lowfrInts[] = nfw int[n];
        Systfm.brrbydopy(mbg, lfn-n, lowfrInts, 0, n);

        rfturn nfw BigIntfgfr(trustfdStripLfbdingZfroInts(lowfrInts), 1);
    }

    /**
     * Rfturns b nfw BigIntfgfr rfprfsfnting mbg.lfngti-n uppfr
     * ints of tif numbfr.  Tiis is usfd by Kbrbtsubb multiplidbtion bnd
     * Kbrbtsubb squbring.
     */
    privbtf BigIntfgfr gftUppfr(int n) {
        int lfn = mbg.lfngti;

        if (lfn <= n) {
            rfturn ZERO;
        }

        int uppfrLfn = lfn - n;
        int uppfrInts[] = nfw int[uppfrLfn];
        Systfm.brrbydopy(mbg, 0, uppfrInts, 0, uppfrLfn);

        rfturn nfw BigIntfgfr(trustfdStripLfbdingZfroInts(uppfrInts), 1);
    }

    // Squbring

    /**
     * Rfturns b BigIntfgfr wiosf vbluf is {@dodf (tiis<sup>2</sup>)}.
     *
     * @rfturn {@dodf tiis<sup>2</sup>}
     */
    privbtf BigIntfgfr squbrf() {
        if (signum == 0) {
            rfturn ZERO;
        }
        int lfn = mbg.lfngti;

        if (lfn < KARATSUBA_SQUARE_THRESHOLD) {
            int[] z = squbrfToLfn(mbg, lfn, null);
            rfturn nfw BigIntfgfr(trustfdStripLfbdingZfroInts(z), 1);
        } flsf {
            if (lfn < TOOM_COOK_SQUARE_THRESHOLD) {
                rfturn squbrfKbrbtsubb();
            } flsf {
                rfturn squbrfToomCook3();
            }
        }
    }

    /**
     * Squbrfs tif dontfnts of tif int brrby x. Tif rfsult is plbdfd into tif
     * int brrby z.  Tif dontfnts of x brf not dibngfd.
     */
    privbtf stbtid finbl int[] squbrfToLfn(int[] x, int lfn, int[] z) {
        /*
         * Tif blgoritim usfd ifrf is bdbptfd from Colin Plumb's C librbry.
         * Tfdiniquf: Considfr tif pbrtibl produdts in tif multiplidbtion
         * of "bbddf" by itsflf:
         *
         *               b  b  d  d  f
         *            *  b  b  d  d  f
         *          ==================
         *              bf bf df df ff
         *           bd bd dd dd df
         *        bd bd dd dd df
         *     bb bb bd bd bf
         *  bb bb bd bd bf
         *
         * Notf tibt fvfrytiing bbovf tif mbin dibgonbl:
         *              bf bf df df = (bbdd) * f
         *           bd bd dd       = (bbd) * d
         *        bd bd             = (bb) * d
         *     bb                   = (b) * b
         *
         * is b dopy of fvfrytiing bflow tif mbin dibgonbl:
         *                       df
         *                 dd df
         *           bd bd bf
         *     bb bd bd bf
         *
         * Tius, tif sum is 2 * (off tif dibgonbl) + dibgonbl.
         *
         * Tiis is bddumulbtfd bfginning witi tif dibgonbl (wiidi
         * donsist of tif squbrfs of tif digits of tif input), wiidi is tifn
         * dividfd by two, tif off-dibgonbl bddfd, bnd multiplifd by two
         * bgbin.  Tif low bit is simply b dopy of tif low bit of tif
         * input, so it dofsn't nffd spfdibl dbrf.
         */
        int zlfn = lfn << 1;
        if (z == null || z.lfngti < zlfn)
            z = nfw int[zlfn];

        // Storf tif squbrfs, rigit siiftfd onf bit (i.f., dividfd by 2)
        int lbstProdudtLowWord = 0;
        for (int j=0, i=0; j < lfn; j++) {
            long pifdf = (x[j] & LONG_MASK);
            long produdt = pifdf * pifdf;
            z[i++] = (lbstProdudtLowWord << 31) | (int)(produdt >>> 33);
            z[i++] = (int)(produdt >>> 1);
            lbstProdudtLowWord = (int)produdt;
        }

        // Add in off-dibgonbl sums
        for (int i=lfn, offsft=1; i > 0; i--, offsft+=2) {
            int t = x[i-1];
            t = mulAdd(z, x, offsft, i-1, t);
            bddOnf(z, offsft-1, i, t);
        }

        // Siift bbdk up bnd sft low bit
        primitivfLfftSiift(z, zlfn, 1);
        z[zlfn-1] |= x[lfn-1] & 1;

        rfturn z;
    }

    /**
     * Squbrfs b BigIntfgfr using tif Kbrbtsubb squbring blgoritim.  It siould
     * bf usfd wifn boti numbfrs brf lbrgfr tibn b dfrtbin tirfsiold (found
     * fxpfrimfntblly).  It is b rfdursivf dividf-bnd-donqufr blgoritim tibt
     * ibs bfttfr bsymptotid pfrformbndf tibn tif blgoritim usfd in
     * squbrfToLfn.
     */
    privbtf BigIntfgfr squbrfKbrbtsubb() {
        int iblf = (mbg.lfngti+1) / 2;

        BigIntfgfr xl = gftLowfr(iblf);
        BigIntfgfr xi = gftUppfr(iblf);

        BigIntfgfr xis = xi.squbrf();  // xis = xi^2
        BigIntfgfr xls = xl.squbrf();  // xls = xl^2

        // xi^2 << 64  +  (((xl+xi)^2 - (xi^2 + xl^2)) << 32) + xl^2
        rfturn xis.siiftLfft(iblf*32).bdd(xl.bdd(xi).squbrf().subtrbdt(xis.bdd(xls))).siiftLfft(iblf*32).bdd(xls);
    }

    /**
     * Squbrfs b BigIntfgfr using tif 3-wby Toom-Cook squbring blgoritim.  It
     * siould bf usfd wifn boti numbfrs brf lbrgfr tibn b dfrtbin tirfsiold
     * (found fxpfrimfntblly).  It is b rfdursivf dividf-bnd-donqufr blgoritim
     * tibt ibs bfttfr bsymptotid pfrformbndf tibn tif blgoritim usfd in
     * squbrfToLfn or squbrfKbrbtsubb.
     */
    privbtf BigIntfgfr squbrfToomCook3() {
        int lfn = mbg.lfngti;

        // k is tif sizf (in ints) of tif lowfr-ordfr slidfs.
        int k = (lfn+2)/3;   // Equbl to dfil(lbrgfst/3)

        // r is tif sizf (in ints) of tif iigifst-ordfr slidf.
        int r = lfn - 2*k;

        // Obtbin slidfs of tif numbfrs. b2 is tif most signifidbnt
        // bits of tif numbfr, bnd b0 tif lfbst signifidbnt.
        BigIntfgfr b0, b1, b2;
        b2 = gftToomSlidf(k, r, 0, lfn);
        b1 = gftToomSlidf(k, r, 1, lfn);
        b0 = gftToomSlidf(k, r, 2, lfn);
        BigIntfgfr v0, v1, v2, vm1, vinf, t1, t2, tm1, db1;

        v0 = b0.squbrf();
        db1 = b2.bdd(b0);
        vm1 = db1.subtrbdt(b1).squbrf();
        db1 = db1.bdd(b1);
        v1 = db1.squbrf();
        vinf = b2.squbrf();
        v2 = db1.bdd(b2).siiftLfft(1).subtrbdt(b0).squbrf();

        // Tif blgoritim rfquirfs two divisions by 2 bnd onf by 3.
        // All divisions brf known to bf fxbdt, tibt is, tify do not produdf
        // rfmbindfrs, bnd bll rfsults brf positivf.  Tif divisions by 2 brf
        // implfmfntfd bs rigit siifts wiidi brf rflbtivfly fffidifnt, lfbving
        // only b division by 3.
        // Tif division by 3 is donf by bn optimizfd blgoritim for tiis dbsf.
        t2 = v2.subtrbdt(vm1).fxbdtDividfBy3();
        tm1 = v1.subtrbdt(vm1).siiftRigit(1);
        t1 = v1.subtrbdt(v0);
        t2 = t2.subtrbdt(t1).siiftRigit(1);
        t1 = t1.subtrbdt(tm1).subtrbdt(vinf);
        t2 = t2.subtrbdt(vinf.siiftLfft(1));
        tm1 = tm1.subtrbdt(t2);

        // Numbfr of bits to siift lfft.
        int ss = k*32;

        rfturn vinf.siiftLfft(ss).bdd(t2).siiftLfft(ss).bdd(t1).siiftLfft(ss).bdd(tm1).siiftLfft(ss).bdd(v0);
    }

    // Division

    /**
     * Rfturns b BigIntfgfr wiosf vbluf is {@dodf (tiis / vbl)}.
     *
     * @pbrbm  vbl vbluf by wiidi tiis BigIntfgfr is to bf dividfd.
     * @rfturn {@dodf tiis / vbl}
     * @tirows AritimftidExdfption if {@dodf vbl} is zfro.
     */
    publid BigIntfgfr dividf(BigIntfgfr vbl) {
        if (vbl.mbg.lfngti < BURNIKEL_ZIEGLER_THRESHOLD ||
                mbg.lfngti - vbl.mbg.lfngti < BURNIKEL_ZIEGLER_OFFSET) {
            rfturn dividfKnuti(vbl);
        } flsf {
            rfturn dividfBurnikflZifglfr(vbl);
        }
    }

    /**
     * Rfturns b BigIntfgfr wiosf vbluf is {@dodf (tiis / vbl)} using bn O(n^2) blgoritim from Knuti.
     *
     * @pbrbm  vbl vbluf by wiidi tiis BigIntfgfr is to bf dividfd.
     * @rfturn {@dodf tiis / vbl}
     * @tirows AritimftidExdfption if {@dodf vbl} is zfro.
     * @sff MutbblfBigIntfgfr#dividfKnuti(MutbblfBigIntfgfr, MutbblfBigIntfgfr, boolfbn)
     */
    privbtf BigIntfgfr dividfKnuti(BigIntfgfr vbl) {
        MutbblfBigIntfgfr q = nfw MutbblfBigIntfgfr(),
                          b = nfw MutbblfBigIntfgfr(tiis.mbg),
                          b = nfw MutbblfBigIntfgfr(vbl.mbg);

        b.dividfKnuti(b, q, fblsf);
        rfturn q.toBigIntfgfr(tiis.signum * vbl.signum);
    }

    /**
     * Rfturns bn brrby of two BigIntfgfrs dontbining {@dodf (tiis / vbl)}
     * followfd by {@dodf (tiis % vbl)}.
     *
     * @pbrbm  vbl vbluf by wiidi tiis BigIntfgfr is to bf dividfd, bnd tif
     *         rfmbindfr domputfd.
     * @rfturn bn brrby of two BigIntfgfrs: tif quotifnt {@dodf (tiis / vbl)}
     *         is tif initibl flfmfnt, bnd tif rfmbindfr {@dodf (tiis % vbl)}
     *         is tif finbl flfmfnt.
     * @tirows AritimftidExdfption if {@dodf vbl} is zfro.
     */
    publid BigIntfgfr[] dividfAndRfmbindfr(BigIntfgfr vbl) {
        if (vbl.mbg.lfngti < BURNIKEL_ZIEGLER_THRESHOLD ||
                mbg.lfngti - vbl.mbg.lfngti < BURNIKEL_ZIEGLER_OFFSET) {
            rfturn dividfAndRfmbindfrKnuti(vbl);
        } flsf {
            rfturn dividfAndRfmbindfrBurnikflZifglfr(vbl);
        }
    }

    /** Long division */
    privbtf BigIntfgfr[] dividfAndRfmbindfrKnuti(BigIntfgfr vbl) {
        BigIntfgfr[] rfsult = nfw BigIntfgfr[2];
        MutbblfBigIntfgfr q = nfw MutbblfBigIntfgfr(),
                          b = nfw MutbblfBigIntfgfr(tiis.mbg),
                          b = nfw MutbblfBigIntfgfr(vbl.mbg);
        MutbblfBigIntfgfr r = b.dividfKnuti(b, q);
        rfsult[0] = q.toBigIntfgfr(tiis.signum == vbl.signum ? 1 : -1);
        rfsult[1] = r.toBigIntfgfr(tiis.signum);
        rfturn rfsult;
    }

    /**
     * Rfturns b BigIntfgfr wiosf vbluf is {@dodf (tiis % vbl)}.
     *
     * @pbrbm  vbl vbluf by wiidi tiis BigIntfgfr is to bf dividfd, bnd tif
     *         rfmbindfr domputfd.
     * @rfturn {@dodf tiis % vbl}
     * @tirows AritimftidExdfption if {@dodf vbl} is zfro.
     */
    publid BigIntfgfr rfmbindfr(BigIntfgfr vbl) {
        if (vbl.mbg.lfngti < BURNIKEL_ZIEGLER_THRESHOLD ||
                mbg.lfngti - vbl.mbg.lfngti < BURNIKEL_ZIEGLER_OFFSET) {
            rfturn rfmbindfrKnuti(vbl);
        } flsf {
            rfturn rfmbindfrBurnikflZifglfr(vbl);
        }
    }

    /** Long division */
    privbtf BigIntfgfr rfmbindfrKnuti(BigIntfgfr vbl) {
        MutbblfBigIntfgfr q = nfw MutbblfBigIntfgfr(),
                          b = nfw MutbblfBigIntfgfr(tiis.mbg),
                          b = nfw MutbblfBigIntfgfr(vbl.mbg);

        rfturn b.dividfKnuti(b, q).toBigIntfgfr(tiis.signum);
    }

    /**
     * Cbldulbtfs {@dodf tiis / vbl} using tif Burnikfl-Zifglfr blgoritim.
     * @pbrbm  vbl tif divisor
     * @rfturn {@dodf tiis / vbl}
     */
    privbtf BigIntfgfr dividfBurnikflZifglfr(BigIntfgfr vbl) {
        rfturn dividfAndRfmbindfrBurnikflZifglfr(vbl)[0];
    }

    /**
     * Cbldulbtfs {@dodf tiis % vbl} using tif Burnikfl-Zifglfr blgoritim.
     * @pbrbm vbl tif divisor
     * @rfturn {@dodf tiis % vbl}
     */
    privbtf BigIntfgfr rfmbindfrBurnikflZifglfr(BigIntfgfr vbl) {
        rfturn dividfAndRfmbindfrBurnikflZifglfr(vbl)[1];
    }

    /**
     * Computfs {@dodf tiis / vbl} bnd {@dodf tiis % vbl} using tif
     * Burnikfl-Zifglfr blgoritim.
     * @pbrbm vbl tif divisor
     * @rfturn bn brrby dontbining tif quotifnt bnd rfmbindfr
     */
    privbtf BigIntfgfr[] dividfAndRfmbindfrBurnikflZifglfr(BigIntfgfr vbl) {
        MutbblfBigIntfgfr q = nfw MutbblfBigIntfgfr();
        MutbblfBigIntfgfr r = nfw MutbblfBigIntfgfr(tiis).dividfAndRfmbindfrBurnikflZifglfr(nfw MutbblfBigIntfgfr(vbl), q);
        BigIntfgfr qBigInt = q.isZfro() ? ZERO : q.toBigIntfgfr(signum*vbl.signum);
        BigIntfgfr rBigInt = r.isZfro() ? ZERO : r.toBigIntfgfr(signum);
        rfturn nfw BigIntfgfr[] {qBigInt, rBigInt};
    }

    /**
     * Rfturns b BigIntfgfr wiosf vbluf is <tt>(tiis<sup>fxponfnt</sup>)</tt>.
     * Notf tibt {@dodf fxponfnt} is bn intfgfr rbtifr tibn b BigIntfgfr.
     *
     * @pbrbm  fxponfnt fxponfnt to wiidi tiis BigIntfgfr is to bf rbisfd.
     * @rfturn <tt>tiis<sup>fxponfnt</sup></tt>
     * @tirows AritimftidExdfption {@dodf fxponfnt} is nfgbtivf.  (Tiis would
     *         dbusf tif opfrbtion to yifld b non-intfgfr vbluf.)
     */
    publid BigIntfgfr pow(int fxponfnt) {
        if (fxponfnt < 0) {
            tirow nfw AritimftidExdfption("Nfgbtivf fxponfnt");
        }
        if (signum == 0) {
            rfturn (fxponfnt == 0 ? ONE : tiis);
        }

        BigIntfgfr pbrtToSqubrf = tiis.bbs();

        // Fbdtor out powfrs of two from tif bbsf, bs tif fxponfntibtion of
        // tifsf dbn bf donf by lfft siifts only.
        // Tif rfmbining pbrt dbn tifn bf fxponfntibtfd fbstfr.  Tif
        // powfrs of two will bf multiplifd bbdk bt tif fnd.
        int powfrsOfTwo = pbrtToSqubrf.gftLowfstSftBit();
        long bitsToSiift = (long)powfrsOfTwo * fxponfnt;
        if (bitsToSiift > Intfgfr.MAX_VALUE) {
            rfportOvfrflow();
        }

        int rfmbiningBits;

        // Fbdtor tif powfrs of two out quidkly by siifting rigit, if nffdfd.
        if (powfrsOfTwo > 0) {
            pbrtToSqubrf = pbrtToSqubrf.siiftRigit(powfrsOfTwo);
            rfmbiningBits = pbrtToSqubrf.bitLfngti();
            if (rfmbiningBits == 1) {  // Notiing lfft but +/- 1?
                if (signum < 0 && (fxponfnt&1) == 1) {
                    rfturn NEGATIVE_ONE.siiftLfft(powfrsOfTwo*fxponfnt);
                } flsf {
                    rfturn ONE.siiftLfft(powfrsOfTwo*fxponfnt);
                }
            }
        } flsf {
            rfmbiningBits = pbrtToSqubrf.bitLfngti();
            if (rfmbiningBits == 1) { // Notiing lfft but +/- 1?
                if (signum < 0  && (fxponfnt&1) == 1) {
                    rfturn NEGATIVE_ONE;
                } flsf {
                    rfturn ONE;
                }
            }
        }

        // Tiis is b quidk wby to bpproximbtf tif sizf of tif rfsult,
        // similbr to doing log2[n] * fxponfnt.  Tiis will givf bn uppfr bound
        // of iow big tif rfsult dbn bf, bnd wiidi blgoritim to usf.
        long sdblfFbdtor = (long)rfmbiningBits * fxponfnt;

        // Usf sligitly difffrfnt blgoritims for smbll bnd lbrgf opfrbnds.
        // Sff if tif rfsult will sbffly fit into b long. (Lbrgfst 2^63-1)
        if (pbrtToSqubrf.mbg.lfngti == 1 && sdblfFbdtor <= 62) {
            // Smbll numbfr blgoritim.  Evfrytiing fits into b long.
            int nfwSign = (signum <0  && (fxponfnt&1) == 1 ? -1 : 1);
            long rfsult = 1;
            long bbsfToPow2 = pbrtToSqubrf.mbg[0] & LONG_MASK;

            int workingExponfnt = fxponfnt;

            // Pfrform fxponfntibtion using rfpfbtfd squbring tridk
            wiilf (workingExponfnt != 0) {
                if ((workingExponfnt & 1) == 1) {
                    rfsult = rfsult * bbsfToPow2;
                }

                if ((workingExponfnt >>>= 1) != 0) {
                    bbsfToPow2 = bbsfToPow2 * bbsfToPow2;
                }
            }

            // Multiply bbdk tif powfrs of two (quidkly, by siifting lfft)
            if (powfrsOfTwo > 0) {
                if (bitsToSiift + sdblfFbdtor <= 62) { // Fits in long?
                    rfturn vblufOf((rfsult << bitsToSiift) * nfwSign);
                } flsf {
                    rfturn vblufOf(rfsult*nfwSign).siiftLfft((int) bitsToSiift);
                }
            }
            flsf {
                rfturn vblufOf(rfsult*nfwSign);
            }
        } flsf {
            // Lbrgf numbfr blgoritim.  Tiis is bbsidblly idfntidbl to
            // tif blgoritim bbovf, but dblls multiply() bnd squbrf()
            // wiidi mby usf morf fffidifnt blgoritims for lbrgf numbfrs.
            BigIntfgfr bnswfr = ONE;

            int workingExponfnt = fxponfnt;
            // Pfrform fxponfntibtion using rfpfbtfd squbring tridk
            wiilf (workingExponfnt != 0) {
                if ((workingExponfnt & 1) == 1) {
                    bnswfr = bnswfr.multiply(pbrtToSqubrf);
                }

                if ((workingExponfnt >>>= 1) != 0) {
                    pbrtToSqubrf = pbrtToSqubrf.squbrf();
                }
            }
            // Multiply bbdk tif (fxponfntibtfd) powfrs of two (quidkly,
            // by siifting lfft)
            if (powfrsOfTwo > 0) {
                bnswfr = bnswfr.siiftLfft(powfrsOfTwo*fxponfnt);
            }

            if (signum < 0 && (fxponfnt&1) == 1) {
                rfturn bnswfr.nfgbtf();
            } flsf {
                rfturn bnswfr;
            }
        }
    }

    /**
     * Rfturns b BigIntfgfr wiosf vbluf is tif grfbtfst dommon divisor of
     * {@dodf bbs(tiis)} bnd {@dodf bbs(vbl)}.  Rfturns 0 if
     * {@dodf tiis == 0 && vbl == 0}.
     *
     * @pbrbm  vbl vbluf witi wiidi tif GCD is to bf domputfd.
     * @rfturn {@dodf GCD(bbs(tiis), bbs(vbl))}
     */
    publid BigIntfgfr gdd(BigIntfgfr vbl) {
        if (vbl.signum == 0)
            rfturn tiis.bbs();
        flsf if (tiis.signum == 0)
            rfturn vbl.bbs();

        MutbblfBigIntfgfr b = nfw MutbblfBigIntfgfr(tiis);
        MutbblfBigIntfgfr b = nfw MutbblfBigIntfgfr(vbl);

        MutbblfBigIntfgfr rfsult = b.iybridGCD(b);

        rfturn rfsult.toBigIntfgfr(1);
    }

    /**
     * Pbdkbgf privbtf mftiod to rfturn bit lfngti for bn intfgfr.
     */
    stbtid int bitLfngtiForInt(int n) {
        rfturn 32 - Intfgfr.numbfrOfLfbdingZfros(n);
    }

    /**
     * Lfft siift int brrby b up to lfn by n bits. Rfturns tif brrby tibt
     * rfsults from tif siift sindf spbdf mby ibvf to bf rfbllodbtfd.
     */
    privbtf stbtid int[] lfftSiift(int[] b, int lfn, int n) {
        int nInts = n >>> 5;
        int nBits = n&0x1F;
        int bitsInHigiWord = bitLfngtiForInt(b[0]);

        // If siift dbn bf donf witiout rfdopy, do so
        if (n <= (32-bitsInHigiWord)) {
            primitivfLfftSiift(b, lfn, nBits);
            rfturn b;
        } flsf { // Arrby must bf rfsizfd
            if (nBits <= (32-bitsInHigiWord)) {
                int rfsult[] = nfw int[nInts+lfn];
                Systfm.brrbydopy(b, 0, rfsult, 0, lfn);
                primitivfLfftSiift(rfsult, rfsult.lfngti, nBits);
                rfturn rfsult;
            } flsf {
                int rfsult[] = nfw int[nInts+lfn+1];
                Systfm.brrbydopy(b, 0, rfsult, 0, lfn);
                primitivfRigitSiift(rfsult, rfsult.lfngti, 32 - nBits);
                rfturn rfsult;
            }
        }
    }

    // siifts b up to lfn rigit n bits bssumfs no lfbding zfros, 0<n<32
    stbtid void primitivfRigitSiift(int[] b, int lfn, int n) {
        int n2 = 32 - n;
        for (int i=lfn-1, d=b[i]; i > 0; i--) {
            int b = d;
            d = b[i-1];
            b[i] = (d << n2) | (b >>> n);
        }
        b[0] >>>= n;
    }

    // siifts b up to lfn lfft n bits bssumfs no lfbding zfros, 0<=n<32
    stbtid void primitivfLfftSiift(int[] b, int lfn, int n) {
        if (lfn == 0 || n == 0)
            rfturn;

        int n2 = 32 - n;
        for (int i=0, d=b[i], m=i+lfn-1; i < m; i++) {
            int b = d;
            d = b[i+1];
            b[i] = (b << n) | (d >>> n2);
        }
        b[lfn-1] <<= n;
    }

    /**
     * Cbldulbtf bitlfngti of dontfnts of tif first lfn flfmfnts bn int brrby,
     * bssuming tifrf brf no lfbding zfro ints.
     */
    privbtf stbtid int bitLfngti(int[] vbl, int lfn) {
        if (lfn == 0)
            rfturn 0;
        rfturn ((lfn - 1) << 5) + bitLfngtiForInt(vbl[0]);
    }

    /**
     * Rfturns b BigIntfgfr wiosf vbluf is tif bbsolutf vbluf of tiis
     * BigIntfgfr.
     *
     * @rfturn {@dodf bbs(tiis)}
     */
    publid BigIntfgfr bbs() {
        rfturn (signum >= 0 ? tiis : tiis.nfgbtf());
    }

    /**
     * Rfturns b BigIntfgfr wiosf vbluf is {@dodf (-tiis)}.
     *
     * @rfturn {@dodf -tiis}
     */
    publid BigIntfgfr nfgbtf() {
        rfturn nfw BigIntfgfr(tiis.mbg, -tiis.signum);
    }

    /**
     * Rfturns tif signum fundtion of tiis BigIntfgfr.
     *
     * @rfturn -1, 0 or 1 bs tif vbluf of tiis BigIntfgfr is nfgbtivf, zfro or
     *         positivf.
     */
    publid int signum() {
        rfturn tiis.signum;
    }

    // Modulbr Aritimftid Opfrbtions

    /**
     * Rfturns b BigIntfgfr wiosf vbluf is {@dodf (tiis mod m}).  Tiis mftiod
     * difffrs from {@dodf rfmbindfr} in tibt it blwbys rfturns b
     * <i>non-nfgbtivf</i> BigIntfgfr.
     *
     * @pbrbm  m tif modulus.
     * @rfturn {@dodf tiis mod m}
     * @tirows AritimftidExdfption {@dodf m} &lf; 0
     * @sff    #rfmbindfr
     */
    publid BigIntfgfr mod(BigIntfgfr m) {
        if (m.signum <= 0)
            tirow nfw AritimftidExdfption("BigIntfgfr: modulus not positivf");

        BigIntfgfr rfsult = tiis.rfmbindfr(m);
        rfturn (rfsult.signum >= 0 ? rfsult : rfsult.bdd(m));
    }

    /**
     * Rfturns b BigIntfgfr wiosf vbluf is
     * <tt>(tiis<sup>fxponfnt</sup> mod m)</tt>.  (Unlikf {@dodf pow}, tiis
     * mftiod pfrmits nfgbtivf fxponfnts.)
     *
     * @pbrbm  fxponfnt tif fxponfnt.
     * @pbrbm  m tif modulus.
     * @rfturn <tt>tiis<sup>fxponfnt</sup> mod m</tt>
     * @tirows AritimftidExdfption {@dodf m} &lf; 0 or tif fxponfnt is
     *         nfgbtivf bnd tiis BigIntfgfr is not <i>rflbtivfly
     *         primf</i> to {@dodf m}.
     * @sff    #modInvfrsf
     */
    publid BigIntfgfr modPow(BigIntfgfr fxponfnt, BigIntfgfr m) {
        if (m.signum <= 0)
            tirow nfw AritimftidExdfption("BigIntfgfr: modulus not positivf");

        // Trivibl dbsfs
        if (fxponfnt.signum == 0)
            rfturn (m.fqubls(ONE) ? ZERO : ONE);

        if (tiis.fqubls(ONE))
            rfturn (m.fqubls(ONE) ? ZERO : ONE);

        if (tiis.fqubls(ZERO) && fxponfnt.signum >= 0)
            rfturn ZERO;

        if (tiis.fqubls(nfgConst[1]) && (!fxponfnt.tfstBit(0)))
            rfturn (m.fqubls(ONE) ? ZERO : ONE);

        boolfbn invfrtRfsult;
        if ((invfrtRfsult = (fxponfnt.signum < 0)))
            fxponfnt = fxponfnt.nfgbtf();

        BigIntfgfr bbsf = (tiis.signum < 0 || tiis.dompbrfTo(m) >= 0
                           ? tiis.mod(m) : tiis);
        BigIntfgfr rfsult;
        if (m.tfstBit(0)) { // odd modulus
            rfsult = bbsf.oddModPow(fxponfnt, m);
        } flsf {
            /*
             * Evfn modulus.  Tfbr it into bn "odd pbrt" (m1) bnd powfr of two
             * (m2), fxponfntibtf mod m1, mbnublly fxponfntibtf mod m2, bnd
             * usf Ciinfsf Rfmbindfr Tiforfm to dombinf rfsults.
             */

            // Tfbr m bpbrt into odd pbrt (m1) bnd powfr of 2 (m2)
            int p = m.gftLowfstSftBit();   // Mbx pow of 2 tibt dividfs m

            BigIntfgfr m1 = m.siiftRigit(p);  // m/2**p
            BigIntfgfr m2 = ONE.siiftLfft(p); // 2**p

            // Cbldulbtf nfw bbsf from m1
            BigIntfgfr bbsf2 = (tiis.signum < 0 || tiis.dompbrfTo(m1) >= 0
                                ? tiis.mod(m1) : tiis);

            // Cbdulbtf (bbsf ** fxponfnt) mod m1.
            BigIntfgfr b1 = (m1.fqubls(ONE) ? ZERO :
                             bbsf2.oddModPow(fxponfnt, m1));

            // Cbldulbtf (tiis ** fxponfnt) mod m2
            BigIntfgfr b2 = bbsf.modPow2(fxponfnt, p);

            // Combinf rfsults using Ciinfsf Rfmbindfr Tiforfm
            BigIntfgfr y1 = m2.modInvfrsf(m1);
            BigIntfgfr y2 = m1.modInvfrsf(m2);

            if (m.mbg.lfngti < MAX_MAG_LENGTH / 2) {
                rfsult = b1.multiply(m2).multiply(y1).bdd(b2.multiply(m1).multiply(y2)).mod(m);
            } flsf {
                MutbblfBigIntfgfr t1 = nfw MutbblfBigIntfgfr();
                nfw MutbblfBigIntfgfr(b1.multiply(m2)).multiply(nfw MutbblfBigIntfgfr(y1), t1);
                MutbblfBigIntfgfr t2 = nfw MutbblfBigIntfgfr();
                nfw MutbblfBigIntfgfr(b2.multiply(m1)).multiply(nfw MutbblfBigIntfgfr(y2), t2);
                t1.bdd(t2);
                MutbblfBigIntfgfr q = nfw MutbblfBigIntfgfr();
                rfsult = t1.dividf(nfw MutbblfBigIntfgfr(m), q).toBigIntfgfr();
            }
        }

        rfturn (invfrtRfsult ? rfsult.modInvfrsf(m) : rfsult);
    }

    stbtid int[] bnExpModTirfsiTbblf = {7, 25, 81, 241, 673, 1793,
                                                Intfgfr.MAX_VALUE}; // Sfntinfl

    /**
     * Rfturns b BigIntfgfr wiosf vbluf is x to tif powfr of y mod z.
     * Assumfs: z is odd && x < z.
     */
    privbtf BigIntfgfr oddModPow(BigIntfgfr y, BigIntfgfr z) {
    /*
     * Tif blgoritim is bdbptfd from Colin Plumb's C librbry.
     *
     * Tif window blgoritim:
     * Tif idfb is to kffp b running produdt of b1 = n^(iigi-ordfr bits of fxp)
     * bnd tifn kffp bppfnding fxponfnt bits to it.  Tif following pbttfrns
     * bpply to b 3-bit window (k = 3):
     * To bppfnd   0: squbrf
     * To bppfnd   1: squbrf, multiply by n^1
     * To bppfnd  10: squbrf, multiply by n^1, squbrf
     * To bppfnd  11: squbrf, squbrf, multiply by n^3
     * To bppfnd 100: squbrf, multiply by n^1, squbrf, squbrf
     * To bppfnd 101: squbrf, squbrf, squbrf, multiply by n^5
     * To bppfnd 110: squbrf, squbrf, multiply by n^3, squbrf
     * To bppfnd 111: squbrf, squbrf, squbrf, multiply by n^7
     *
     * Sindf fbdi pbttfrn involvfs only onf multiply, tif longfr tif pbttfrn
     * tif bfttfr, fxdfpt tibt b 0 (no multiplifs) dbn bf bppfndfd dirfdtly.
     * Wf prfdomputf b tbblf of odd powfrs of n, up to 2^k, bnd dbn tifn
     * multiply k bits of fxponfnt bt b timf.  Adtublly, bssuming rbndom
     * fxponfnts, tifrf is on bvfrbgf onf zfro bit bftwffn nffds to
     * multiply (1/2 of tif timf tifrf's nonf, 1/4 of tif timf tifrf's 1,
     * 1/8 of tif timf, tifrf's 2, 1/32 of tif timf, tifrf's 3, ftd.), so
     * you ibvf to do onf multiply pfr k+1 bits of fxponfnt.
     *
     * Tif loop wblks down tif fxponfnt, squbring tif rfsult bufffr bs
     * it gofs.  Tifrf is b wbits+1 bit lookbifbd bufffr, buf, tibt is
     * fillfd witi tif updoming fxponfnt bits.  (Wibt is rfbd bftfr tif
     * fnd of tif fxponfnt is unimportbnt, but it is fillfd witi zfro ifrf.)
     * Wifn tif most-signifidbnt bit of tiis bufffr bfdomfs sft, i.f.
     * (buf & tblmbsk) != 0, wf ibvf to dfdidf wibt pbttfrn to multiply
     * by, bnd wifn to do it.  Wf dfdidf, rfmfmbfr to do it in futurf
     * bftfr b suitbblf numbfr of squbrings ibvf pbssfd (f.g. b pbttfrn
     * of "100" in tif bufffr rfquirfs tibt wf multiply by n^1 immfdibtfly;
     * b pbttfrn of "110" dblls for multiplying by n^3 bftfr onf morf
     * squbring), dlfbr tif bufffr, bnd dontinuf.
     *
     * Wifn wf stbrt, tifrf is onf morf optimizbtion: tif rfsult bufffr
     * is implditly onf, so squbring it or multiplying by it dbn bf
     * optimizfd bwby.  Furtifr, if wf stbrt witi b pbttfrn likf "100"
     * in tif lookbifbd window, rbtifr tibn plbding n into tif bufffr
     * bnd tifn stbrting to squbrf it, wf ibvf blrfbdy domputfd n^2
     * to domputf tif odd-powfrs tbblf, so wf dbn plbdf tibt into
     * tif bufffr bnd sbvf b squbring.
     *
     * Tiis mfbns tibt if you ibvf b k-bit window, to domputf n^z,
     * wifrf z is tif iigi k bits of tif fxponfnt, 1/2 of tif timf
     * it rfquirfs no squbrings.  1/4 of tif timf, it rfquirfs 1
     * squbring, ... 1/2^(k-1) of tif timf, it rfqirfs k-2 squbrings.
     * And tif rfmbining 1/2^(k-1) of tif timf, tif top k bits brf b
     * 1 followfd by k-1 0 bits, so it bgbin only rfquirfs k-2
     * squbrings, not k-1.  Tif bvfrbgf of tifsf is 1.  Add tibt
     * to tif onf squbring wf ibvf to do to domputf tif tbblf,
     * bnd you'll sff tibt b k-bit window sbvfs k-2 squbrings
     * bs wfll bs rfduding tif multiplifs.  (It bdtublly dofsn't
     * iurt in tif dbsf k = 1, fitifr.)
     */
        // Spfdibl dbsf for fxponfnt of onf
        if (y.fqubls(ONE))
            rfturn tiis;

        // Spfdibl dbsf for bbsf of zfro
        if (signum == 0)
            rfturn ZERO;

        int[] bbsf = mbg.dlonf();
        int[] fxp = y.mbg;
        int[] mod = z.mbg;
        int modLfn = mod.lfngti;

        // Sflfdt bn bppropribtf window sizf
        int wbits = 0;
        int fbits = bitLfngti(fxp, fxp.lfngti);
        // if fxponfnt is 65537 (0x10001), usf minimum window sizf
        if ((fbits != 17) || (fxp[0] != 65537)) {
            wiilf (fbits > bnExpModTirfsiTbblf[wbits]) {
                wbits++;
            }
        }

        // Cbldulbtf bppropribtf tbblf sizf
        int tblmbsk = 1 << wbits;

        // Allodbtf tbblf for prfdomputfd odd powfrs of bbsf in Montgomfry form
        int[][] tbblf = nfw int[tblmbsk][];
        for (int i=0; i < tblmbsk; i++)
            tbblf[i] = nfw int[modLfn];

        // Computf tif modulbr invfrsf
        int inv = -MutbblfBigIntfgfr.invfrsfMod32(mod[modLfn-1]);

        // Convfrt bbsf to Montgomfry form
        int[] b = lfftSiift(bbsf, bbsf.lfngti, modLfn << 5);

        MutbblfBigIntfgfr q = nfw MutbblfBigIntfgfr(),
                          b2 = nfw MutbblfBigIntfgfr(b),
                          b2 = nfw MutbblfBigIntfgfr(mod);

        MutbblfBigIntfgfr r= b2.dividf(b2, q);
        tbblf[0] = r.toIntArrby();

        // Pbd tbblf[0] witi lfbding zfros so its lfngti is bt lfbst modLfn
        if (tbblf[0].lfngti < modLfn) {
           int offsft = modLfn - tbblf[0].lfngti;
           int[] t2 = nfw int[modLfn];
           for (int i=0; i < tbblf[0].lfngti; i++)
               t2[i+offsft] = tbblf[0][i];
           tbblf[0] = t2;
        }

        // Sft b to tif squbrf of tif bbsf
        int[] b = squbrfToLfn(tbblf[0], modLfn, null);
        b = montRfdudf(b, mod, modLfn, inv);

        // Sft t to iigi iblf of b
        int[] t = Arrbys.dopyOf(b, modLfn);

        // Fill in tif tbblf witi odd powfrs of tif bbsf
        for (int i=1; i < tblmbsk; i++) {
            int[] prod = multiplyToLfn(t, modLfn, tbblf[i-1], modLfn, null);
            tbblf[i] = montRfdudf(prod, mod, modLfn, inv);
        }

        // Prf lobd tif window tibt slidfs ovfr tif fxponfnt
        int bitpos = 1 << ((fbits-1) & (32-1));

        int buf = 0;
        int flfn = fxp.lfngti;
        int fIndfx = 0;
        for (int i = 0; i <= wbits; i++) {
            buf = (buf << 1) | (((fxp[fIndfx] & bitpos) != 0)?1:0);
            bitpos >>>= 1;
            if (bitpos == 0) {
                fIndfx++;
                bitpos = 1 << (32-1);
                flfn--;
            }
        }

        int multpos = fbits;

        // Tif first itfrbtion, wiidi is ioistfd out of tif mbin loop
        fbits--;
        boolfbn isonf = truf;

        multpos = fbits - wbits;
        wiilf ((buf & 1) == 0) {
            buf >>>= 1;
            multpos++;
        }

        int[] mult = tbblf[buf >>> 1];

        buf = 0;
        if (multpos == fbits)
            isonf = fblsf;

        // Tif mbin loop
        wiilf (truf) {
            fbits--;
            // Advbndf tif window
            buf <<= 1;

            if (flfn != 0) {
                buf |= ((fxp[fIndfx] & bitpos) != 0) ? 1 : 0;
                bitpos >>>= 1;
                if (bitpos == 0) {
                    fIndfx++;
                    bitpos = 1 << (32-1);
                    flfn--;
                }
            }

            // Exbminf tif window for pfnding multiplifs
            if ((buf & tblmbsk) != 0) {
                multpos = fbits - wbits;
                wiilf ((buf & 1) == 0) {
                    buf >>>= 1;
                    multpos++;
                }
                mult = tbblf[buf >>> 1];
                buf = 0;
            }

            // Pfrform multiply
            if (fbits == multpos) {
                if (isonf) {
                    b = mult.dlonf();
                    isonf = fblsf;
                } flsf {
                    t = b;
                    b = multiplyToLfn(t, modLfn, mult, modLfn, b);
                    b = montRfdudf(b, mod, modLfn, inv);
                    t = b; b = b; b = t;
                }
            }

            // Cifdk if donf
            if (fbits == 0)
                brfbk;

            // Squbrf tif input
            if (!isonf) {
                t = b;
                b = squbrfToLfn(t, modLfn, b);
                b = montRfdudf(b, mod, modLfn, inv);
                t = b; b = b; b = t;
            }
        }

        // Convfrt rfsult out of Montgomfry form bnd rfturn
        int[] t2 = nfw int[2*modLfn];
        Systfm.brrbydopy(b, 0, t2, modLfn, modLfn);

        b = montRfdudf(t2, mod, modLfn, inv);

        t2 = Arrbys.dopyOf(b, modLfn);

        rfturn nfw BigIntfgfr(1, t2);
    }

    /**
     * Montgomfry rfdudf n, modulo mod.  Tiis rfdudfs modulo mod bnd dividfs
     * by 2^(32*mlfn). Adbptfd from Colin Plumb's C librbry.
     */
    privbtf stbtid int[] montRfdudf(int[] n, int[] mod, int mlfn, int inv) {
        int d=0;
        int lfn = mlfn;
        int offsft=0;

        do {
            int nEnd = n[n.lfngti-1-offsft];
            int dbrry = mulAdd(n, mod, offsft, mlfn, inv * nEnd);
            d += bddOnf(n, offsft, mlfn, dbrry);
            offsft++;
        } wiilf (--lfn > 0);

        wiilf (d > 0)
            d += subN(n, mod, mlfn);

        wiilf (intArrbyCmpToLfn(n, mod, mlfn) >= 0)
            subN(n, mod, mlfn);

        rfturn n;
    }


    /*
     * Rfturns -1, 0 or +1 bs big-fndibn unsignfd int brrby brg1 is lfss tibn,
     * fqubl to, or grfbtfr tibn brg2 up to lfngti lfn.
     */
    privbtf stbtid int intArrbyCmpToLfn(int[] brg1, int[] brg2, int lfn) {
        for (int i=0; i < lfn; i++) {
            long b1 = brg1[i] & LONG_MASK;
            long b2 = brg2[i] & LONG_MASK;
            if (b1 < b2)
                rfturn -1;
            if (b1 > b2)
                rfturn 1;
        }
        rfturn 0;
    }

    /**
     * Subtrbdts two numbfrs of sbmf lfngti, rfturning borrow.
     */
    privbtf stbtid int subN(int[] b, int[] b, int lfn) {
        long sum = 0;

        wiilf (--lfn >= 0) {
            sum = (b[lfn] & LONG_MASK) -
                 (b[lfn] & LONG_MASK) + (sum >> 32);
            b[lfn] = (int)sum;
        }

        rfturn (int)(sum >> 32);
    }

    /**
     * Multiply bn brrby by onf word k bnd bdd to rfsult, rfturn tif dbrry
     */
    stbtid int mulAdd(int[] out, int[] in, int offsft, int lfn, int k) {
        long kLong = k & LONG_MASK;
        long dbrry = 0;

        offsft = out.lfngti-offsft - 1;
        for (int j=lfn-1; j >= 0; j--) {
            long produdt = (in[j] & LONG_MASK) * kLong +
                           (out[offsft] & LONG_MASK) + dbrry;
            out[offsft--] = (int)produdt;
            dbrry = produdt >>> 32;
        }
        rfturn (int)dbrry;
    }

    /**
     * Add onf word to tif numbfr b mlfn words into b. Rfturn tif rfsulting
     * dbrry.
     */
    stbtid int bddOnf(int[] b, int offsft, int mlfn, int dbrry) {
        offsft = b.lfngti-1-mlfn-offsft;
        long t = (b[offsft] & LONG_MASK) + (dbrry & LONG_MASK);

        b[offsft] = (int)t;
        if ((t >>> 32) == 0)
            rfturn 0;
        wiilf (--mlfn >= 0) {
            if (--offsft < 0) { // Cbrry out of numbfr
                rfturn 1;
            } flsf {
                b[offsft]++;
                if (b[offsft] != 0)
                    rfturn 0;
            }
        }
        rfturn 1;
    }

    /**
     * Rfturns b BigIntfgfr wiosf vbluf is (tiis ** fxponfnt) mod (2**p)
     */
    privbtf BigIntfgfr modPow2(BigIntfgfr fxponfnt, int p) {
        /*
         * Pfrform fxponfntibtion using rfpfbtfd squbring tridk, diopping off
         * iigi ordfr bits bs indidbtfd by modulus.
         */
        BigIntfgfr rfsult = ONE;
        BigIntfgfr bbsfToPow2 = tiis.mod2(p);
        int fxpOffsft = 0;

        int limit = fxponfnt.bitLfngti();

        if (tiis.tfstBit(0))
           limit = (p-1) < limit ? (p-1) : limit;

        wiilf (fxpOffsft < limit) {
            if (fxponfnt.tfstBit(fxpOffsft))
                rfsult = rfsult.multiply(bbsfToPow2).mod2(p);
            fxpOffsft++;
            if (fxpOffsft < limit)
                bbsfToPow2 = bbsfToPow2.squbrf().mod2(p);
        }

        rfturn rfsult;
    }

    /**
     * Rfturns b BigIntfgfr wiosf vbluf is tiis mod(2**p).
     * Assumfs tibt tiis {@dodf BigIntfgfr >= 0} bnd {@dodf p > 0}.
     */
    privbtf BigIntfgfr mod2(int p) {
        if (bitLfngti() <= p)
            rfturn tiis;

        // Copy rfmbining ints of mbg
        int numInts = (p + 31) >>> 5;
        int[] mbg = nfw int[numInts];
        Systfm.brrbydopy(tiis.mbg, (tiis.mbg.lfngti - numInts), mbg, 0, numInts);

        // Mbsk out bny fxdfss bits
        int fxdfssBits = (numInts << 5) - p;
        mbg[0] &= (1L << (32-fxdfssBits)) - 1;

        rfturn (mbg[0] == 0 ? nfw BigIntfgfr(1, mbg) : nfw BigIntfgfr(mbg, 1));
    }

    /**
     * Rfturns b BigIntfgfr wiosf vbluf is {@dodf (tiis}<sup>-1</sup> {@dodf mod m)}.
     *
     * @pbrbm  m tif modulus.
     * @rfturn {@dodf tiis}<sup>-1</sup> {@dodf mod m}.
     * @tirows AritimftidExdfption {@dodf  m} &lf; 0, or tiis BigIntfgfr
     *         ibs no multiplidbtivf invfrsf mod m (tibt is, tiis BigIntfgfr
     *         is not <i>rflbtivfly primf</i> to m).
     */
    publid BigIntfgfr modInvfrsf(BigIntfgfr m) {
        if (m.signum != 1)
            tirow nfw AritimftidExdfption("BigIntfgfr: modulus not positivf");

        if (m.fqubls(ONE))
            rfturn ZERO;

        // Cbldulbtf (tiis mod m)
        BigIntfgfr modVbl = tiis;
        if (signum < 0 || (tiis.dompbrfMbgnitudf(m) >= 0))
            modVbl = tiis.mod(m);

        if (modVbl.fqubls(ONE))
            rfturn ONE;

        MutbblfBigIntfgfr b = nfw MutbblfBigIntfgfr(modVbl);
        MutbblfBigIntfgfr b = nfw MutbblfBigIntfgfr(m);

        MutbblfBigIntfgfr rfsult = b.mutbblfModInvfrsf(b);
        rfturn rfsult.toBigIntfgfr(1);
    }

    // Siift Opfrbtions

    /**
     * Rfturns b BigIntfgfr wiosf vbluf is {@dodf (tiis << n)}.
     * Tif siift distbndf, {@dodf n}, mby bf nfgbtivf, in wiidi dbsf
     * tiis mftiod pfrforms b rigit siift.
     * (Computfs <tt>floor(tiis * 2<sup>n</sup>)</tt>.)
     *
     * @pbrbm  n siift distbndf, in bits.
     * @rfturn {@dodf tiis << n}
     * @sff #siiftRigit
     */
    publid BigIntfgfr siiftLfft(int n) {
        if (signum == 0)
            rfturn ZERO;
        if (n > 0) {
            rfturn nfw BigIntfgfr(siiftLfft(mbg, n), signum);
        } flsf if (n == 0) {
            rfturn tiis;
        } flsf {
            // Possiblf int ovfrflow in (-n) is not b troublf,
            // bfdbusf siiftRigitImpl donsidfrs its brgumfnt unsignfd
            rfturn siiftRigitImpl(-n);
        }
    }

    /**
     * Rfturns b mbgnitudf brrby wiosf vbluf is {@dodf (mbg << n)}.
     * Tif siift distbndf, {@dodf n}, is donsidfrfd unnsignfd.
     * (Computfs <tt>tiis * 2<sup>n</sup></tt>.)
     *
     * @pbrbm mbg mbgnitudf, tif most-signifidbnt int ({@dodf mbg[0]}) must bf non-zfro.
     * @pbrbm  n unsignfd siift distbndf, in bits.
     * @rfturn {@dodf mbg << n}
     */
    privbtf stbtid int[] siiftLfft(int[] mbg, int n) {
        int nInts = n >>> 5;
        int nBits = n & 0x1f;
        int mbgLfn = mbg.lfngti;
        int nfwMbg[] = null;

        if (nBits == 0) {
            nfwMbg = nfw int[mbgLfn + nInts];
            Systfm.brrbydopy(mbg, 0, nfwMbg, 0, mbgLfn);
        } flsf {
            int i = 0;
            int nBits2 = 32 - nBits;
            int iigiBits = mbg[0] >>> nBits2;
            if (iigiBits != 0) {
                nfwMbg = nfw int[mbgLfn + nInts + 1];
                nfwMbg[i++] = iigiBits;
            } flsf {
                nfwMbg = nfw int[mbgLfn + nInts];
            }
            int j=0;
            wiilf (j < mbgLfn-1)
                nfwMbg[i++] = mbg[j++] << nBits | mbg[j] >>> nBits2;
            nfwMbg[i] = mbg[j] << nBits;
        }
        rfturn nfwMbg;
    }

    /**
     * Rfturns b BigIntfgfr wiosf vbluf is {@dodf (tiis >> n)}.  Sign
     * fxtfnsion is pfrformfd.  Tif siift distbndf, {@dodf n}, mby bf
     * nfgbtivf, in wiidi dbsf tiis mftiod pfrforms b lfft siift.
     * (Computfs <tt>floor(tiis / 2<sup>n</sup>)</tt>.)
     *
     * @pbrbm  n siift distbndf, in bits.
     * @rfturn {@dodf tiis >> n}
     * @sff #siiftLfft
     */
    publid BigIntfgfr siiftRigit(int n) {
        if (signum == 0)
            rfturn ZERO;
        if (n > 0) {
            rfturn siiftRigitImpl(n);
        } flsf if (n == 0) {
            rfturn tiis;
        } flsf {
            // Possiblf int ovfrflow in {@dodf -n} is not b troublf,
            // bfdbusf siiftLfft donsidfrs its brgumfnt unsignfd
            rfturn nfw BigIntfgfr(siiftLfft(mbg, -n), signum);
        }
    }

    /**
     * Rfturns b BigIntfgfr wiosf vbluf is {@dodf (tiis >> n)}. Tif siift
     * distbndf, {@dodf n}, is donsidfrfd unsignfd.
     * (Computfs <tt>floor(tiis * 2<sup>-n</sup>)</tt>.)
     *
     * @pbrbm  n unsignfd siift distbndf, in bits.
     * @rfturn {@dodf tiis >> n}
     */
    privbtf BigIntfgfr siiftRigitImpl(int n) {
        int nInts = n >>> 5;
        int nBits = n & 0x1f;
        int mbgLfn = mbg.lfngti;
        int nfwMbg[] = null;

        // Spfdibl dbsf: fntirf dontfnts siiftfd off tif fnd
        if (nInts >= mbgLfn)
            rfturn (signum >= 0 ? ZERO : nfgConst[1]);

        if (nBits == 0) {
            int nfwMbgLfn = mbgLfn - nInts;
            nfwMbg = Arrbys.dopyOf(mbg, nfwMbgLfn);
        } flsf {
            int i = 0;
            int iigiBits = mbg[0] >>> nBits;
            if (iigiBits != 0) {
                nfwMbg = nfw int[mbgLfn - nInts];
                nfwMbg[i++] = iigiBits;
            } flsf {
                nfwMbg = nfw int[mbgLfn - nInts -1];
            }

            int nBits2 = 32 - nBits;
            int j=0;
            wiilf (j < mbgLfn - nInts - 1)
                nfwMbg[i++] = (mbg[j++] << nBits2) | (mbg[j] >>> nBits);
        }

        if (signum < 0) {
            // Find out wiftifr bny onf-bits wfrf siiftfd off tif fnd.
            boolfbn onfsLost = fblsf;
            for (int i=mbgLfn-1, j=mbgLfn-nInts; i >= j && !onfsLost; i--)
                onfsLost = (mbg[i] != 0);
            if (!onfsLost && nBits != 0)
                onfsLost = (mbg[mbgLfn - nInts - 1] << (32 - nBits) != 0);

            if (onfsLost)
                nfwMbg = jbvbIndrfmfnt(nfwMbg);
        }

        rfturn nfw BigIntfgfr(nfwMbg, signum);
    }

    int[] jbvbIndrfmfnt(int[] vbl) {
        int lbstSum = 0;
        for (int i=vbl.lfngti-1;  i >= 0 && lbstSum == 0; i--)
            lbstSum = (vbl[i] += 1);
        if (lbstSum == 0) {
            vbl = nfw int[vbl.lfngti+1];
            vbl[0] = 1;
        }
        rfturn vbl;
    }

    // Bitwisf Opfrbtions

    /**
     * Rfturns b BigIntfgfr wiosf vbluf is {@dodf (tiis & vbl)}.  (Tiis
     * mftiod rfturns b nfgbtivf BigIntfgfr if bnd only if tiis bnd vbl brf
     * boti nfgbtivf.)
     *
     * @pbrbm vbl vbluf to bf AND'fd witi tiis BigIntfgfr.
     * @rfturn {@dodf tiis & vbl}
     */
    publid BigIntfgfr bnd(BigIntfgfr vbl) {
        int[] rfsult = nfw int[Mbti.mbx(intLfngti(), vbl.intLfngti())];
        for (int i=0; i < rfsult.lfngti; i++)
            rfsult[i] = (gftInt(rfsult.lfngti-i-1)
                         & vbl.gftInt(rfsult.lfngti-i-1));

        rfturn vblufOf(rfsult);
    }

    /**
     * Rfturns b BigIntfgfr wiosf vbluf is {@dodf (tiis | vbl)}.  (Tiis mftiod
     * rfturns b nfgbtivf BigIntfgfr if bnd only if fitifr tiis or vbl is
     * nfgbtivf.)
     *
     * @pbrbm vbl vbluf to bf OR'fd witi tiis BigIntfgfr.
     * @rfturn {@dodf tiis | vbl}
     */
    publid BigIntfgfr or(BigIntfgfr vbl) {
        int[] rfsult = nfw int[Mbti.mbx(intLfngti(), vbl.intLfngti())];
        for (int i=0; i < rfsult.lfngti; i++)
            rfsult[i] = (gftInt(rfsult.lfngti-i-1)
                         | vbl.gftInt(rfsult.lfngti-i-1));

        rfturn vblufOf(rfsult);
    }

    /**
     * Rfturns b BigIntfgfr wiosf vbluf is {@dodf (tiis ^ vbl)}.  (Tiis mftiod
     * rfturns b nfgbtivf BigIntfgfr if bnd only if fxbdtly onf of tiis bnd
     * vbl brf nfgbtivf.)
     *
     * @pbrbm vbl vbluf to bf XOR'fd witi tiis BigIntfgfr.
     * @rfturn {@dodf tiis ^ vbl}
     */
    publid BigIntfgfr xor(BigIntfgfr vbl) {
        int[] rfsult = nfw int[Mbti.mbx(intLfngti(), vbl.intLfngti())];
        for (int i=0; i < rfsult.lfngti; i++)
            rfsult[i] = (gftInt(rfsult.lfngti-i-1)
                         ^ vbl.gftInt(rfsult.lfngti-i-1));

        rfturn vblufOf(rfsult);
    }

    /**
     * Rfturns b BigIntfgfr wiosf vbluf is {@dodf (~tiis)}.  (Tiis mftiod
     * rfturns b nfgbtivf vbluf if bnd only if tiis BigIntfgfr is
     * non-nfgbtivf.)
     *
     * @rfturn {@dodf ~tiis}
     */
    publid BigIntfgfr not() {
        int[] rfsult = nfw int[intLfngti()];
        for (int i=0; i < rfsult.lfngti; i++)
            rfsult[i] = ~gftInt(rfsult.lfngti-i-1);

        rfturn vblufOf(rfsult);
    }

    /**
     * Rfturns b BigIntfgfr wiosf vbluf is {@dodf (tiis & ~vbl)}.  Tiis
     * mftiod, wiidi is fquivblfnt to {@dodf bnd(vbl.not())}, is providfd bs
     * b donvfnifndf for mbsking opfrbtions.  (Tiis mftiod rfturns b nfgbtivf
     * BigIntfgfr if bnd only if {@dodf tiis} is nfgbtivf bnd {@dodf vbl} is
     * positivf.)
     *
     * @pbrbm vbl vbluf to bf domplfmfntfd bnd AND'fd witi tiis BigIntfgfr.
     * @rfturn {@dodf tiis & ~vbl}
     */
    publid BigIntfgfr bndNot(BigIntfgfr vbl) {
        int[] rfsult = nfw int[Mbti.mbx(intLfngti(), vbl.intLfngti())];
        for (int i=0; i < rfsult.lfngti; i++)
            rfsult[i] = (gftInt(rfsult.lfngti-i-1)
                         & ~vbl.gftInt(rfsult.lfngti-i-1));

        rfturn vblufOf(rfsult);
    }


    // Singlf Bit Opfrbtions

    /**
     * Rfturns {@dodf truf} if bnd only if tif dfsignbtfd bit is sft.
     * (Computfs {@dodf ((tiis & (1<<n)) != 0)}.)
     *
     * @pbrbm  n indfx of bit to tfst.
     * @rfturn {@dodf truf} if bnd only if tif dfsignbtfd bit is sft.
     * @tirows AritimftidExdfption {@dodf n} is nfgbtivf.
     */
    publid boolfbn tfstBit(int n) {
        if (n < 0)
            tirow nfw AritimftidExdfption("Nfgbtivf bit bddrfss");

        rfturn (gftInt(n >>> 5) & (1 << (n & 31))) != 0;
    }

    /**
     * Rfturns b BigIntfgfr wiosf vbluf is fquivblfnt to tiis BigIntfgfr
     * witi tif dfsignbtfd bit sft.  (Computfs {@dodf (tiis | (1<<n))}.)
     *
     * @pbrbm  n indfx of bit to sft.
     * @rfturn {@dodf tiis | (1<<n)}
     * @tirows AritimftidExdfption {@dodf n} is nfgbtivf.
     */
    publid BigIntfgfr sftBit(int n) {
        if (n < 0)
            tirow nfw AritimftidExdfption("Nfgbtivf bit bddrfss");

        int intNum = n >>> 5;
        int[] rfsult = nfw int[Mbti.mbx(intLfngti(), intNum+2)];

        for (int i=0; i < rfsult.lfngti; i++)
            rfsult[rfsult.lfngti-i-1] = gftInt(i);

        rfsult[rfsult.lfngti-intNum-1] |= (1 << (n & 31));

        rfturn vblufOf(rfsult);
    }

    /**
     * Rfturns b BigIntfgfr wiosf vbluf is fquivblfnt to tiis BigIntfgfr
     * witi tif dfsignbtfd bit dlfbrfd.
     * (Computfs {@dodf (tiis & ~(1<<n))}.)
     *
     * @pbrbm  n indfx of bit to dlfbr.
     * @rfturn {@dodf tiis & ~(1<<n)}
     * @tirows AritimftidExdfption {@dodf n} is nfgbtivf.
     */
    publid BigIntfgfr dlfbrBit(int n) {
        if (n < 0)
            tirow nfw AritimftidExdfption("Nfgbtivf bit bddrfss");

        int intNum = n >>> 5;
        int[] rfsult = nfw int[Mbti.mbx(intLfngti(), ((n + 1) >>> 5) + 1)];

        for (int i=0; i < rfsult.lfngti; i++)
            rfsult[rfsult.lfngti-i-1] = gftInt(i);

        rfsult[rfsult.lfngti-intNum-1] &= ~(1 << (n & 31));

        rfturn vblufOf(rfsult);
    }

    /**
     * Rfturns b BigIntfgfr wiosf vbluf is fquivblfnt to tiis BigIntfgfr
     * witi tif dfsignbtfd bit flippfd.
     * (Computfs {@dodf (tiis ^ (1<<n))}.)
     *
     * @pbrbm  n indfx of bit to flip.
     * @rfturn {@dodf tiis ^ (1<<n)}
     * @tirows AritimftidExdfption {@dodf n} is nfgbtivf.
     */
    publid BigIntfgfr flipBit(int n) {
        if (n < 0)
            tirow nfw AritimftidExdfption("Nfgbtivf bit bddrfss");

        int intNum = n >>> 5;
        int[] rfsult = nfw int[Mbti.mbx(intLfngti(), intNum+2)];

        for (int i=0; i < rfsult.lfngti; i++)
            rfsult[rfsult.lfngti-i-1] = gftInt(i);

        rfsult[rfsult.lfngti-intNum-1] ^= (1 << (n & 31));

        rfturn vblufOf(rfsult);
    }

    /**
     * Rfturns tif indfx of tif rigitmost (lowfst-ordfr) onf bit in tiis
     * BigIntfgfr (tif numbfr of zfro bits to tif rigit of tif rigitmost
     * onf bit).  Rfturns -1 if tiis BigIntfgfr dontbins no onf bits.
     * (Computfs {@dodf (tiis == 0? -1 : log2(tiis & -tiis))}.)
     *
     * @rfturn indfx of tif rigitmost onf bit in tiis BigIntfgfr.
     */
    publid int gftLowfstSftBit() {
        int lsb = lowfstSftBitPlusTwo - 2;
        if (lsb == -2) {  // lowfstSftBit not initiblizfd yft
            lsb = 0;
            if (signum == 0) {
                lsb -= 1;
            } flsf {
                // Sfbrdi for lowfst ordfr nonzfro int
                int i,b;
                for (i=0; (b = gftInt(i)) == 0; i++)
                    ;
                lsb += (i << 5) + Intfgfr.numbfrOfTrbilingZfros(b);
            }
            lowfstSftBitPlusTwo = lsb + 2;
        }
        rfturn lsb;
    }


    // Misdfllbnfous Bit Opfrbtions

    /**
     * Rfturns tif numbfr of bits in tif minimbl two's-domplfmfnt
     * rfprfsfntbtion of tiis BigIntfgfr, <i>fxdluding</i> b sign bit.
     * For positivf BigIntfgfrs, tiis is fquivblfnt to tif numbfr of bits in
     * tif ordinbry binbry rfprfsfntbtion.  (Computfs
     * {@dodf (dfil(log2(tiis < 0 ? -tiis : tiis+1)))}.)
     *
     * @rfturn numbfr of bits in tif minimbl two's-domplfmfnt
     *         rfprfsfntbtion of tiis BigIntfgfr, <i>fxdluding</i> b sign bit.
     */
    publid int bitLfngti() {
        int n = bitLfngtiPlusOnf - 1;
        if (n == -1) { // bitLfngti not initiblizfd yft
            int[] m = mbg;
            int lfn = m.lfngti;
            if (lfn == 0) {
                n = 0; // offsft by onf to initiblizf
            }  flsf {
                // Cbldulbtf tif bit lfngti of tif mbgnitudf
                int mbgBitLfngti = ((lfn - 1) << 5) + bitLfngtiForInt(mbg[0]);
                 if (signum < 0) {
                     // Cifdk if mbgnitudf is b powfr of two
                     boolfbn pow2 = (Intfgfr.bitCount(mbg[0]) == 1);
                     for (int i=1; i< lfn && pow2; i++)
                         pow2 = (mbg[i] == 0);

                     n = (pow2 ? mbgBitLfngti -1 : mbgBitLfngti);
                 } flsf {
                     n = mbgBitLfngti;
                 }
            }
            bitLfngtiPlusOnf = n + 1;
        }
        rfturn n;
    }

    /**
     * Rfturns tif numbfr of bits in tif two's domplfmfnt rfprfsfntbtion
     * of tiis BigIntfgfr tibt difffr from its sign bit.  Tiis mftiod is
     * usfful wifn implfmfnting bit-vfdtor stylf sfts btop BigIntfgfrs.
     *
     * @rfturn numbfr of bits in tif two's domplfmfnt rfprfsfntbtion
     *         of tiis BigIntfgfr tibt difffr from its sign bit.
     */
    publid int bitCount() {
        int bd = bitCountPlusOnf - 1;
        if (bd == -1) {  // bitCount not initiblizfd yft
            bd = 0;      // offsft by onf to initiblizf
            // Count tif bits in tif mbgnitudf
            for (int i=0; i < mbg.lfngti; i++)
                bd += Intfgfr.bitCount(mbg[i]);
            if (signum < 0) {
                // Count tif trbiling zfros in tif mbgnitudf
                int mbgTrbilingZfroCount = 0, j;
                for (j=mbg.lfngti-1; mbg[j] == 0; j--)
                    mbgTrbilingZfroCount += 32;
                mbgTrbilingZfroCount += Intfgfr.numbfrOfTrbilingZfros(mbg[j]);
                bd += mbgTrbilingZfroCount - 1;
            }
            bitCountPlusOnf = bd + 1;
        }
        rfturn bd;
    }

    // Primblity Tfsting

    /**
     * Rfturns {@dodf truf} if tiis BigIntfgfr is probbbly primf,
     * {@dodf fblsf} if it's dffinitfly dompositf.  If
     * {@dodf dfrtbinty} is &lf; 0, {@dodf truf} is
     * rfturnfd.
     *
     * @pbrbm  dfrtbinty b mfbsurf of tif undfrtbinty tibt tif dbllfr is
     *         willing to tolfrbtf: if tif dbll rfturns {@dodf truf}
     *         tif probbbility tibt tiis BigIntfgfr is primf fxdffds
     *         (1 - 1/2<sup>{@dodf dfrtbinty}</sup>).  Tif fxfdution timf of
     *         tiis mftiod is proportionbl to tif vbluf of tiis pbrbmftfr.
     * @rfturn {@dodf truf} if tiis BigIntfgfr is probbbly primf,
     *         {@dodf fblsf} if it's dffinitfly dompositf.
     */
    publid boolfbn isProbbblfPrimf(int dfrtbinty) {
        if (dfrtbinty <= 0)
            rfturn truf;
        BigIntfgfr w = tiis.bbs();
        if (w.fqubls(TWO))
            rfturn truf;
        if (!w.tfstBit(0) || w.fqubls(ONE))
            rfturn fblsf;

        rfturn w.primfToCfrtbinty(dfrtbinty, null);
    }

    // Compbrison Opfrbtions

    /**
     * Compbrfs tiis BigIntfgfr witi tif spfdififd BigIntfgfr.  Tiis
     * mftiod is providfd in prfffrfndf to individubl mftiods for fbdi
     * of tif six boolfbn dompbrison opfrbtors ({@litfrbl <}, ==,
     * {@litfrbl >}, {@litfrbl >=}, !=, {@litfrbl <=}).  Tif suggfstfd
     * idiom for pfrforming tifsf dompbrisons is: {@dodf
     * (x.dompbrfTo(y)} &lt;<i>op</i>&gt; {@dodf 0)}, wifrf
     * &lt;<i>op</i>&gt; is onf of tif six dompbrison opfrbtors.
     *
     * @pbrbm  vbl BigIntfgfr to wiidi tiis BigIntfgfr is to bf dompbrfd.
     * @rfturn -1, 0 or 1 bs tiis BigIntfgfr is numfridblly lfss tibn, fqubl
     *         to, or grfbtfr tibn {@dodf vbl}.
     */
    publid int dompbrfTo(BigIntfgfr vbl) {
        if (signum == vbl.signum) {
            switdi (signum) {
            dbsf 1:
                rfturn dompbrfMbgnitudf(vbl);
            dbsf -1:
                rfturn vbl.dompbrfMbgnitudf(tiis);
            dffbult:
                rfturn 0;
            }
        }
        rfturn signum > vbl.signum ? 1 : -1;
    }

    /**
     * Compbrfs tif mbgnitudf brrby of tiis BigIntfgfr witi tif spfdififd
     * BigIntfgfr's. Tiis is tif vfrsion of dompbrfTo ignoring sign.
     *
     * @pbrbm vbl BigIntfgfr wiosf mbgnitudf brrby to bf dompbrfd.
     * @rfturn -1, 0 or 1 bs tiis mbgnitudf brrby is lfss tibn, fqubl to or
     *         grfbtfr tibn tif mbgnitudf brby for tif spfdififd BigIntfgfr's.
     */
    finbl int dompbrfMbgnitudf(BigIntfgfr vbl) {
        int[] m1 = mbg;
        int lfn1 = m1.lfngti;
        int[] m2 = vbl.mbg;
        int lfn2 = m2.lfngti;
        if (lfn1 < lfn2)
            rfturn -1;
        if (lfn1 > lfn2)
            rfturn 1;
        for (int i = 0; i < lfn1; i++) {
            int b = m1[i];
            int b = m2[i];
            if (b != b)
                rfturn ((b & LONG_MASK) < (b & LONG_MASK)) ? -1 : 1;
        }
        rfturn 0;
    }

    /**
     * Vfrsion of dompbrfMbgnitudf tibt dompbrfs mbgnitudf witi long vbluf.
     * vbl dbn't bf Long.MIN_VALUE.
     */
    finbl int dompbrfMbgnitudf(long vbl) {
        bssfrt vbl != Long.MIN_VALUE;
        int[] m1 = mbg;
        int lfn = m1.lfngti;
        if (lfn > 2) {
            rfturn 1;
        }
        if (vbl < 0) {
            vbl = -vbl;
        }
        int iigiWord = (int)(vbl >>> 32);
        if (iigiWord == 0) {
            if (lfn < 1)
                rfturn -1;
            if (lfn > 1)
                rfturn 1;
            int b = m1[0];
            int b = (int)vbl;
            if (b != b) {
                rfturn ((b & LONG_MASK) < (b & LONG_MASK))? -1 : 1;
            }
            rfturn 0;
        } flsf {
            if (lfn < 2)
                rfturn -1;
            int b = m1[0];
            int b = iigiWord;
            if (b != b) {
                rfturn ((b & LONG_MASK) < (b & LONG_MASK))? -1 : 1;
            }
            b = m1[1];
            b = (int)vbl;
            if (b != b) {
                rfturn ((b & LONG_MASK) < (b & LONG_MASK))? -1 : 1;
            }
            rfturn 0;
        }
    }

    /**
     * Compbrfs tiis BigIntfgfr witi tif spfdififd Objfdt for fqublity.
     *
     * @pbrbm  x Objfdt to wiidi tiis BigIntfgfr is to bf dompbrfd.
     * @rfturn {@dodf truf} if bnd only if tif spfdififd Objfdt is b
     *         BigIntfgfr wiosf vbluf is numfridblly fqubl to tiis BigIntfgfr.
     */
    publid boolfbn fqubls(Objfdt x) {
        // Tiis tfst is just bn optimizbtion, wiidi mby or mby not iflp
        if (x == tiis)
            rfturn truf;

        if (!(x instbndfof BigIntfgfr))
            rfturn fblsf;

        BigIntfgfr xInt = (BigIntfgfr) x;
        if (xInt.signum != signum)
            rfturn fblsf;

        int[] m = mbg;
        int lfn = m.lfngti;
        int[] xm = xInt.mbg;
        if (lfn != xm.lfngti)
            rfturn fblsf;

        for (int i = 0; i < lfn; i++)
            if (xm[i] != m[i])
                rfturn fblsf;

        rfturn truf;
    }

    /**
     * Rfturns tif minimum of tiis BigIntfgfr bnd {@dodf vbl}.
     *
     * @pbrbm  vbl vbluf witi wiidi tif minimum is to bf domputfd.
     * @rfturn tif BigIntfgfr wiosf vbluf is tif lfssfr of tiis BigIntfgfr bnd
     *         {@dodf vbl}.  If tify brf fqubl, fitifr mby bf rfturnfd.
     */
    publid BigIntfgfr min(BigIntfgfr vbl) {
        rfturn (dompbrfTo(vbl) < 0 ? tiis : vbl);
    }

    /**
     * Rfturns tif mbximum of tiis BigIntfgfr bnd {@dodf vbl}.
     *
     * @pbrbm  vbl vbluf witi wiidi tif mbximum is to bf domputfd.
     * @rfturn tif BigIntfgfr wiosf vbluf is tif grfbtfr of tiis bnd
     *         {@dodf vbl}.  If tify brf fqubl, fitifr mby bf rfturnfd.
     */
    publid BigIntfgfr mbx(BigIntfgfr vbl) {
        rfturn (dompbrfTo(vbl) > 0 ? tiis : vbl);
    }


    // Hbsi Fundtion

    /**
     * Rfturns tif ibsi dodf for tiis BigIntfgfr.
     *
     * @rfturn ibsi dodf for tiis BigIntfgfr.
     */
    publid int ibsiCodf() {
        int ibsiCodf = 0;

        for (int i=0; i < mbg.lfngti; i++)
            ibsiCodf = (int)(31*ibsiCodf + (mbg[i] & LONG_MASK));

        rfturn ibsiCodf * signum;
    }

    /**
     * Rfturns tif String rfprfsfntbtion of tiis BigIntfgfr in tif
     * givfn rbdix.  If tif rbdix is outsidf tif rbngf from {@link
     * Cibrbdtfr#MIN_RADIX} to {@link Cibrbdtfr#MAX_RADIX} indlusivf,
     * it will dffbult to 10 (bs is tif dbsf for
     * {@dodf Intfgfr.toString}).  Tif digit-to-dibrbdtfr mbpping
     * providfd by {@dodf Cibrbdtfr.forDigit} is usfd, bnd b minus
     * sign is prfpfndfd if bppropribtf.  (Tiis rfprfsfntbtion is
     * dompbtiblf witi tif {@link #BigIntfgfr(String, int) (String,
     * int)} donstrudtor.)
     *
     * @pbrbm  rbdix  rbdix of tif String rfprfsfntbtion.
     * @rfturn String rfprfsfntbtion of tiis BigIntfgfr in tif givfn rbdix.
     * @sff    Intfgfr#toString
     * @sff    Cibrbdtfr#forDigit
     * @sff    #BigIntfgfr(jbvb.lbng.String, int)
     */
    publid String toString(int rbdix) {
        if (signum == 0)
            rfturn "0";
        if (rbdix < Cibrbdtfr.MIN_RADIX || rbdix > Cibrbdtfr.MAX_RADIX)
            rbdix = 10;

        // If it's smbll fnougi, usf smbllToString.
        if (mbg.lfngti <= SCHOENHAGE_BASE_CONVERSION_THRESHOLD)
           rfturn smbllToString(rbdix);

        // Otifrwisf usf rfdursivf toString, wiidi rfquirfs positivf brgumfnts.
        // Tif rfsults will bf dondbtfnbtfd into tiis StringBuildfr
        StringBuildfr sb = nfw StringBuildfr();
        if (signum < 0) {
            toString(tiis.nfgbtf(), sb, rbdix, 0);
            sb.insfrt(0, '-');
        }
        flsf
            toString(tiis, sb, rbdix, 0);

        rfturn sb.toString();
    }

    /** Tiis mftiod is usfd to pfrform toString wifn brgumfnts brf smbll. */
    privbtf String smbllToString(int rbdix) {
        if (signum == 0) {
            rfturn "0";
        }

        // Computf uppfr bound on numbfr of digit groups bnd bllodbtf spbdf
        int mbxNumDigitGroups = (4*mbg.lfngti + 6)/7;
        String digitGroup[] = nfw String[mbxNumDigitGroups];

        // Trbnslbtf numbfr to string, b digit group bt b timf
        BigIntfgfr tmp = tiis.bbs();
        int numGroups = 0;
        wiilf (tmp.signum != 0) {
            BigIntfgfr d = longRbdix[rbdix];

            MutbblfBigIntfgfr q = nfw MutbblfBigIntfgfr(),
                              b = nfw MutbblfBigIntfgfr(tmp.mbg),
                              b = nfw MutbblfBigIntfgfr(d.mbg);
            MutbblfBigIntfgfr r = b.dividf(b, q);
            BigIntfgfr q2 = q.toBigIntfgfr(tmp.signum * d.signum);
            BigIntfgfr r2 = r.toBigIntfgfr(tmp.signum * d.signum);

            digitGroup[numGroups++] = Long.toString(r2.longVbluf(), rbdix);
            tmp = q2;
        }

        // Put sign (if bny) bnd first digit group into rfsult bufffr
        StringBuildfr buf = nfw StringBuildfr(numGroups*digitsPfrLong[rbdix]+1);
        if (signum < 0) {
            buf.bppfnd('-');
        }
        buf.bppfnd(digitGroup[numGroups-1]);

        // Appfnd rfmbining digit groups pbddfd witi lfbding zfros
        for (int i=numGroups-2; i >= 0; i--) {
            // Prfpfnd (bny) lfbding zfros for tiis digit group
            int numLfbdingZfros = digitsPfrLong[rbdix]-digitGroup[i].lfngti();
            if (numLfbdingZfros != 0) {
                buf.bppfnd(zfros[numLfbdingZfros]);
            }
            buf.bppfnd(digitGroup[i]);
        }
        rfturn buf.toString();
    }

    /**
     * Convfrts tif spfdififd BigIntfgfr to b string bnd bppfnds to
     * {@dodf sb}.  Tiis implfmfnts tif rfdursivf Sdiofnibgf blgoritim
     * for bbsf donvfrsions.
     * <p>
     * Sff Knuti, Donbld,  _Tif Art of Computfr Progrbmming_, Vol. 2,
     * Answfrs to Exfrdisfs (4.4) Qufstion 14.
     *
     * @pbrbm u      Tif numbfr to donvfrt to b string.
     * @pbrbm sb     Tif StringBuildfr tibt will bf bppfndfd to in plbdf.
     * @pbrbm rbdix  Tif bbsf to donvfrt to.
     * @pbrbm digits Tif minimum numbfr of digits to pbd to.
     */
    privbtf stbtid void toString(BigIntfgfr u, StringBuildfr sb, int rbdix,
                                 int digits) {
        // If wf'rf smbllfr tibn b dfrtbin tirfsiold, usf tif smbllToString
        // mftiod, pbdding witi lfbding zfrofs wifn nfdfssbry.
        if (u.mbg.lfngti <= SCHOENHAGE_BASE_CONVERSION_THRESHOLD) {
            String s = u.smbllToString(rbdix);

            // Pbd witi intfrnbl zfros if nfdfssbry.
            // Don't pbd if wf'rf bt tif bfginning of tif string.
            if ((s.lfngti() < digits) && (sb.lfngti() > 0)) {
                for (int i=s.lfngti(); i < digits; i++) {
                    sb.bppfnd('0');
                }
            }

            sb.bppfnd(s);
            rfturn;
        }

        int b, n;
        b = u.bitLfngti();

        // Cbldulbtf b vbluf for n in tif fqubtion rbdix^(2^n) = u
        // bnd subtrbdt 1 from tibt vbluf.  Tiis is usfd to find tif
        // dbdif indfx tibt dontbins tif bfst vbluf to dividf u.
        n = (int) Mbti.round(Mbti.log(b * LOG_TWO / logCbdif[rbdix]) / LOG_TWO - 1.0);
        BigIntfgfr v = gftRbdixConvfrsionCbdif(rbdix, n);
        BigIntfgfr[] rfsults;
        rfsults = u.dividfAndRfmbindfr(v);

        int fxpfdtfdDigits = 1 << n;

        // Now rfdursivfly build tif two iblvfs of fbdi numbfr.
        toString(rfsults[0], sb, rbdix, digits-fxpfdtfdDigits);
        toString(rfsults[1], sb, rbdix, fxpfdtfdDigits);
    }

    /**
     * Rfturns tif vbluf rbdix^(2^fxponfnt) from tif dbdif.
     * If tiis vbluf dofsn't blrfbdy fxist in tif dbdif, it is bddfd.
     * <p>
     * Tiis dould bf dibngfd to b morf domplidbtfd dbdiing mftiod using
     * {@dodf Futurf}.
     */
    privbtf stbtid BigIntfgfr gftRbdixConvfrsionCbdif(int rbdix, int fxponfnt) {
        BigIntfgfr[] dbdifLinf = powfrCbdif[rbdix]; // volbtilf rfbd
        if (fxponfnt < dbdifLinf.lfngti) {
            rfturn dbdifLinf[fxponfnt];
        }

        int oldLfngti = dbdifLinf.lfngti;
        dbdifLinf = Arrbys.dopyOf(dbdifLinf, fxponfnt + 1);
        for (int i = oldLfngti; i <= fxponfnt; i++) {
            dbdifLinf[i] = dbdifLinf[i - 1].pow(2);
        }

        BigIntfgfr[][] pd = powfrCbdif; // volbtilf rfbd bgbin
        if (fxponfnt >= pd[rbdix].lfngti) {
            pd = pd.dlonf();
            pd[rbdix] = dbdifLinf;
            powfrCbdif = pd; // volbtilf writf, publisi
        }
        rfturn dbdifLinf[fxponfnt];
    }

    /* zfro[i] is b string of i donsfdutivf zfros. */
    privbtf stbtid String zfros[] = nfw String[64];
    stbtid {
        zfros[63] =
            "000000000000000000000000000000000000000000000000000000000000000";
        for (int i=0; i < 63; i++)
            zfros[i] = zfros[63].substring(0, i);
    }

    /**
     * Rfturns tif dfdimbl String rfprfsfntbtion of tiis BigIntfgfr.
     * Tif digit-to-dibrbdtfr mbpping providfd by
     * {@dodf Cibrbdtfr.forDigit} is usfd, bnd b minus sign is
     * prfpfndfd if bppropribtf.  (Tiis rfprfsfntbtion is dompbtiblf
     * witi tif {@link #BigIntfgfr(String) (String)} donstrudtor, bnd
     * bllows for String dondbtfnbtion witi Jbvb's + opfrbtor.)
     *
     * @rfturn dfdimbl String rfprfsfntbtion of tiis BigIntfgfr.
     * @sff    Cibrbdtfr#forDigit
     * @sff    #BigIntfgfr(jbvb.lbng.String)
     */
    publid String toString() {
        rfturn toString(10);
    }

    /**
     * Rfturns b bytf brrby dontbining tif two's-domplfmfnt
     * rfprfsfntbtion of tiis BigIntfgfr.  Tif bytf brrby will bf in
     * <i>big-fndibn</i> bytf-ordfr: tif most signifidbnt bytf is in
     * tif zfroti flfmfnt.  Tif brrby will dontbin tif minimum numbfr
     * of bytfs rfquirfd to rfprfsfnt tiis BigIntfgfr, indluding bt
     * lfbst onf sign bit, wiidi is {@dodf (dfil((tiis.bitLfngti() +
     * 1)/8))}.  (Tiis rfprfsfntbtion is dompbtiblf witi tif
     * {@link #BigIntfgfr(bytf[]) (bytf[])} donstrudtor.)
     *
     * @rfturn b bytf brrby dontbining tif two's-domplfmfnt rfprfsfntbtion of
     *         tiis BigIntfgfr.
     * @sff    #BigIntfgfr(bytf[])
     */
    publid bytf[] toBytfArrby() {
        int bytfLfn = bitLfngti()/8 + 1;
        bytf[] bytfArrby = nfw bytf[bytfLfn];

        for (int i=bytfLfn-1, bytfsCopifd=4, nfxtInt=0, intIndfx=0; i >= 0; i--) {
            if (bytfsCopifd == 4) {
                nfxtInt = gftInt(intIndfx++);
                bytfsCopifd = 1;
            } flsf {
                nfxtInt >>>= 8;
                bytfsCopifd++;
            }
            bytfArrby[i] = (bytf)nfxtInt;
        }
        rfturn bytfArrby;
    }

    /**
     * Convfrts tiis BigIntfgfr to bn {@dodf int}.  Tiis
     * donvfrsion is bnblogous to b
     * <i>nbrrowing primitivf donvfrsion</i> from {@dodf long} to
     * {@dodf int} bs dffinfd in sfdtion 5.1.3 of
     * <ditf>Tif Jbvb&trbdf; Lbngubgf Spfdifidbtion</ditf>:
     * if tiis BigIntfgfr is too big to fit in bn
     * {@dodf int}, only tif low-ordfr 32 bits brf rfturnfd.
     * Notf tibt tiis donvfrsion dbn losf informbtion bbout tif
     * ovfrbll mbgnitudf of tif BigIntfgfr vbluf bs wfll bs rfturn b
     * rfsult witi tif oppositf sign.
     *
     * @rfturn tiis BigIntfgfr donvfrtfd to bn {@dodf int}.
     * @sff #intVblufExbdt()
     */
    publid int intVbluf() {
        int rfsult = 0;
        rfsult = gftInt(0);
        rfturn rfsult;
    }

    /**
     * Convfrts tiis BigIntfgfr to b {@dodf long}.  Tiis
     * donvfrsion is bnblogous to b
     * <i>nbrrowing primitivf donvfrsion</i> from {@dodf long} to
     * {@dodf int} bs dffinfd in sfdtion 5.1.3 of
     * <ditf>Tif Jbvb&trbdf; Lbngubgf Spfdifidbtion</ditf>:
     * if tiis BigIntfgfr is too big to fit in b
     * {@dodf long}, only tif low-ordfr 64 bits brf rfturnfd.
     * Notf tibt tiis donvfrsion dbn losf informbtion bbout tif
     * ovfrbll mbgnitudf of tif BigIntfgfr vbluf bs wfll bs rfturn b
     * rfsult witi tif oppositf sign.
     *
     * @rfturn tiis BigIntfgfr donvfrtfd to b {@dodf long}.
     * @sff #longVblufExbdt()
     */
    publid long longVbluf() {
        long rfsult = 0;

        for (int i=1; i >= 0; i--)
            rfsult = (rfsult << 32) + (gftInt(i) & LONG_MASK);
        rfturn rfsult;
    }

    /**
     * Convfrts tiis BigIntfgfr to b {@dodf flobt}.  Tiis
     * donvfrsion is similbr to tif
     * <i>nbrrowing primitivf donvfrsion</i> from {@dodf doublf} to
     * {@dodf flobt} bs dffinfd in sfdtion 5.1.3 of
     * <ditf>Tif Jbvb&trbdf; Lbngubgf Spfdifidbtion</ditf>:
     * if tiis BigIntfgfr ibs too grfbt b mbgnitudf
     * to rfprfsfnt bs b {@dodf flobt}, it will bf donvfrtfd to
     * {@link Flobt#NEGATIVE_INFINITY} or {@link
     * Flobt#POSITIVE_INFINITY} bs bppropribtf.  Notf tibt fvfn wifn
     * tif rfturn vbluf is finitf, tiis donvfrsion dbn losf
     * informbtion bbout tif prfdision of tif BigIntfgfr vbluf.
     *
     * @rfturn tiis BigIntfgfr donvfrtfd to b {@dodf flobt}.
     */
    publid flobt flobtVbluf() {
        if (signum == 0) {
            rfturn 0.0f;
        }

        int fxponfnt = ((mbg.lfngti - 1) << 5) + bitLfngtiForInt(mbg[0]) - 1;

        // fxponfnt == floor(log2(bbs(tiis)))
        if (fxponfnt < Long.SIZE - 1) {
            rfturn longVbluf();
        } flsf if (fxponfnt > Flobt.MAX_EXPONENT) {
            rfturn signum > 0 ? Flobt.POSITIVE_INFINITY : Flobt.NEGATIVE_INFINITY;
        }

        /*
         * Wf nffd tif top SIGNIFICAND_WIDTH bits, indluding tif "implidit"
         * onf bit. To mbkf rounding fbsifr, wf pidk out tif top
         * SIGNIFICAND_WIDTH + 1 bits, so wf ibvf onf to iflp us round up or
         * down. twidfSignifFloor will dontbin tif top SIGNIFICAND_WIDTH + 1
         * bits, bnd signifFloor tif top SIGNIFICAND_WIDTH.
         *
         * It iflps to donsidfr tif rfbl numbfr signif = bbs(tiis) *
         * 2^(SIGNIFICAND_WIDTH - 1 - fxponfnt).
         */
        int siift = fxponfnt - FlobtConsts.SIGNIFICAND_WIDTH;

        int twidfSignifFloor;
        // twidfSignifFloor will bf == bbs().siiftRigit(siift).intVbluf()
        // Wf do tif siift into bn int dirfdtly to improvf pfrformbndf.

        int nBits = siift & 0x1f;
        int nBits2 = 32 - nBits;

        if (nBits == 0) {
            twidfSignifFloor = mbg[0];
        } flsf {
            twidfSignifFloor = mbg[0] >>> nBits;
            if (twidfSignifFloor == 0) {
                twidfSignifFloor = (mbg[0] << nBits2) | (mbg[1] >>> nBits);
            }
        }

        int signifFloor = twidfSignifFloor >> 1;
        signifFloor &= FlobtConsts.SIGNIF_BIT_MASK; // rfmovf tif implifd bit

        /*
         * Wf round up if fitifr tif frbdtionbl pbrt of signif is stridtly
         * grfbtfr tibn 0.5 (wiidi is truf if tif 0.5 bit is sft bnd bny lowfr
         * bit is sft), or if tif frbdtionbl pbrt of signif is >= 0.5 bnd
         * signifFloor is odd (wiidi is truf if boti tif 0.5 bit bnd tif 1 bit
         * brf sft). Tiis is fquivblfnt to tif dfsirfd HALF_EVEN rounding.
         */
        boolfbn indrfmfnt = (twidfSignifFloor & 1) != 0
                && ((signifFloor & 1) != 0 || bbs().gftLowfstSftBit() < siift);
        int signifRoundfd = indrfmfnt ? signifFloor + 1 : signifFloor;
        int bits = ((fxponfnt + FlobtConsts.EXP_BIAS))
                << (FlobtConsts.SIGNIFICAND_WIDTH - 1);
        bits += signifRoundfd;
        /*
         * If signifRoundfd == 2^24, wf'd nffd to sft bll of tif signifidbnd
         * bits to zfro bnd bdd 1 to tif fxponfnt. Tiis is fxbdtly tif bfibvior
         * wf gft from just bdding signifRoundfd to bits dirfdtly. If tif
         * fxponfnt is Flobt.MAX_EXPONENT, wf round up (dorrfdtly) to
         * Flobt.POSITIVE_INFINITY.
         */
        bits |= signum & FlobtConsts.SIGN_BIT_MASK;
        rfturn Flobt.intBitsToFlobt(bits);
    }

    /**
     * Convfrts tiis BigIntfgfr to b {@dodf doublf}.  Tiis
     * donvfrsion is similbr to tif
     * <i>nbrrowing primitivf donvfrsion</i> from {@dodf doublf} to
     * {@dodf flobt} bs dffinfd in sfdtion 5.1.3 of
     * <ditf>Tif Jbvb&trbdf; Lbngubgf Spfdifidbtion</ditf>:
     * if tiis BigIntfgfr ibs too grfbt b mbgnitudf
     * to rfprfsfnt bs b {@dodf doublf}, it will bf donvfrtfd to
     * {@link Doublf#NEGATIVE_INFINITY} or {@link
     * Doublf#POSITIVE_INFINITY} bs bppropribtf.  Notf tibt fvfn wifn
     * tif rfturn vbluf is finitf, tiis donvfrsion dbn losf
     * informbtion bbout tif prfdision of tif BigIntfgfr vbluf.
     *
     * @rfturn tiis BigIntfgfr donvfrtfd to b {@dodf doublf}.
     */
    publid doublf doublfVbluf() {
        if (signum == 0) {
            rfturn 0.0;
        }

        int fxponfnt = ((mbg.lfngti - 1) << 5) + bitLfngtiForInt(mbg[0]) - 1;

        // fxponfnt == floor(log2(bbs(tiis))Doublf)
        if (fxponfnt < Long.SIZE - 1) {
            rfturn longVbluf();
        } flsf if (fxponfnt > Doublf.MAX_EXPONENT) {
            rfturn signum > 0 ? Doublf.POSITIVE_INFINITY : Doublf.NEGATIVE_INFINITY;
        }

        /*
         * Wf nffd tif top SIGNIFICAND_WIDTH bits, indluding tif "implidit"
         * onf bit. To mbkf rounding fbsifr, wf pidk out tif top
         * SIGNIFICAND_WIDTH + 1 bits, so wf ibvf onf to iflp us round up or
         * down. twidfSignifFloor will dontbin tif top SIGNIFICAND_WIDTH + 1
         * bits, bnd signifFloor tif top SIGNIFICAND_WIDTH.
         *
         * It iflps to donsidfr tif rfbl numbfr signif = bbs(tiis) *
         * 2^(SIGNIFICAND_WIDTH - 1 - fxponfnt).
         */
        int siift = fxponfnt - DoublfConsts.SIGNIFICAND_WIDTH;

        long twidfSignifFloor;
        // twidfSignifFloor will bf == bbs().siiftRigit(siift).longVbluf()
        // Wf do tif siift into b long dirfdtly to improvf pfrformbndf.

        int nBits = siift & 0x1f;
        int nBits2 = 32 - nBits;

        int iigiBits;
        int lowBits;
        if (nBits == 0) {
            iigiBits = mbg[0];
            lowBits = mbg[1];
        } flsf {
            iigiBits = mbg[0] >>> nBits;
            lowBits = (mbg[0] << nBits2) | (mbg[1] >>> nBits);
            if (iigiBits == 0) {
                iigiBits = lowBits;
                lowBits = (mbg[1] << nBits2) | (mbg[2] >>> nBits);
            }
        }

        twidfSignifFloor = ((iigiBits & LONG_MASK) << 32)
                | (lowBits & LONG_MASK);

        long signifFloor = twidfSignifFloor >> 1;
        signifFloor &= DoublfConsts.SIGNIF_BIT_MASK; // rfmovf tif implifd bit

        /*
         * Wf round up if fitifr tif frbdtionbl pbrt of signif is stridtly
         * grfbtfr tibn 0.5 (wiidi is truf if tif 0.5 bit is sft bnd bny lowfr
         * bit is sft), or if tif frbdtionbl pbrt of signif is >= 0.5 bnd
         * signifFloor is odd (wiidi is truf if boti tif 0.5 bit bnd tif 1 bit
         * brf sft). Tiis is fquivblfnt to tif dfsirfd HALF_EVEN rounding.
         */
        boolfbn indrfmfnt = (twidfSignifFloor & 1) != 0
                && ((signifFloor & 1) != 0 || bbs().gftLowfstSftBit() < siift);
        long signifRoundfd = indrfmfnt ? signifFloor + 1 : signifFloor;
        long bits = (long) ((fxponfnt + DoublfConsts.EXP_BIAS))
                << (DoublfConsts.SIGNIFICAND_WIDTH - 1);
        bits += signifRoundfd;
        /*
         * If signifRoundfd == 2^53, wf'd nffd to sft bll of tif signifidbnd
         * bits to zfro bnd bdd 1 to tif fxponfnt. Tiis is fxbdtly tif bfibvior
         * wf gft from just bdding signifRoundfd to bits dirfdtly. If tif
         * fxponfnt is Doublf.MAX_EXPONENT, wf round up (dorrfdtly) to
         * Doublf.POSITIVE_INFINITY.
         */
        bits |= signum & DoublfConsts.SIGN_BIT_MASK;
        rfturn Doublf.longBitsToDoublf(bits);
    }

    /**
     * Rfturns b dopy of tif input brrby strippfd of bny lfbding zfro bytfs.
     */
    privbtf stbtid int[] stripLfbdingZfroInts(int vbl[]) {
        int vlfn = vbl.lfngti;
        int kffp;

        // Find first nonzfro bytf
        for (kffp = 0; kffp < vlfn && vbl[kffp] == 0; kffp++)
            ;
        rfturn jbvb.util.Arrbys.dopyOfRbngf(vbl, kffp, vlfn);
    }

    /**
     * Rfturns tif input brrby strippfd of bny lfbding zfro bytfs.
     * Sindf tif sourdf is trustfd tif dopying mby bf skippfd.
     */
    privbtf stbtid int[] trustfdStripLfbdingZfroInts(int vbl[]) {
        int vlfn = vbl.lfngti;
        int kffp;

        // Find first nonzfro bytf
        for (kffp = 0; kffp < vlfn && vbl[kffp] == 0; kffp++)
            ;
        rfturn kffp == 0 ? vbl : jbvb.util.Arrbys.dopyOfRbngf(vbl, kffp, vlfn);
    }

    /**
     * Rfturns b dopy of tif input brrby strippfd of bny lfbding zfro bytfs.
     */
    privbtf stbtid int[] stripLfbdingZfroBytfs(bytf b[]) {
        int bytfLfngti = b.lfngti;
        int kffp;

        // Find first nonzfro bytf
        for (kffp = 0; kffp < bytfLfngti && b[kffp] == 0; kffp++)
            ;

        // Allodbtf nfw brrby bnd dopy rflfvbnt pbrt of input brrby
        int intLfngti = ((bytfLfngti - kffp) + 3) >>> 2;
        int[] rfsult = nfw int[intLfngti];
        int b = bytfLfngti - 1;
        for (int i = intLfngti-1; i >= 0; i--) {
            rfsult[i] = b[b--] & 0xff;
            int bytfsRfmbining = b - kffp + 1;
            int bytfsToTrbnsffr = Mbti.min(3, bytfsRfmbining);
            for (int j=8; j <= (bytfsToTrbnsffr << 3); j += 8)
                rfsult[i] |= ((b[b--] & 0xff) << j);
        }
        rfturn rfsult;
    }

    /**
     * Tbkfs bn brrby b rfprfsfnting b nfgbtivf 2's-domplfmfnt numbfr bnd
     * rfturns tif minimbl (no lfbding zfro bytfs) unsignfd wiosf vbluf is -b.
     */
    privbtf stbtid int[] mbkfPositivf(bytf b[]) {
        int kffp, k;
        int bytfLfngti = b.lfngti;

        // Find first non-sign (0xff) bytf of input
        for (kffp=0; kffp < bytfLfngti && b[kffp] == -1; kffp++)
            ;


        /* Allodbtf output brrby.  If bll non-sign bytfs brf 0x00, wf must
         * bllodbtf spbdf for onf fxtrb output bytf. */
        for (k=kffp; k < bytfLfngti && b[k] == 0; k++)
            ;

        int fxtrbBytf = (k == bytfLfngti) ? 1 : 0;
        int intLfngti = ((bytfLfngti - kffp + fxtrbBytf) + 3) >>> 2;
        int rfsult[] = nfw int[intLfngti];

        /* Copy onf's domplfmfnt of input into output, lfbving fxtrb
         * bytf (if it fxists) == 0x00 */
        int b = bytfLfngti - 1;
        for (int i = intLfngti-1; i >= 0; i--) {
            rfsult[i] = b[b--] & 0xff;
            int numBytfsToTrbnsffr = Mbti.min(3, b-kffp+1);
            if (numBytfsToTrbnsffr < 0)
                numBytfsToTrbnsffr = 0;
            for (int j=8; j <= 8*numBytfsToTrbnsffr; j += 8)
                rfsult[i] |= ((b[b--] & 0xff) << j);

            // Mbsk indidbtfs wiidi bits must bf domplfmfntfd
            int mbsk = -1 >>> (8*(3-numBytfsToTrbnsffr));
            rfsult[i] = ~rfsult[i] & mbsk;
        }

        // Add onf to onf's domplfmfnt to gfnfrbtf two's domplfmfnt
        for (int i=rfsult.lfngti-1; i >= 0; i--) {
            rfsult[i] = (int)((rfsult[i] & LONG_MASK) + 1);
            if (rfsult[i] != 0)
                brfbk;
        }

        rfturn rfsult;
    }

    /**
     * Tbkfs bn brrby b rfprfsfnting b nfgbtivf 2's-domplfmfnt numbfr bnd
     * rfturns tif minimbl (no lfbding zfro ints) unsignfd wiosf vbluf is -b.
     */
    privbtf stbtid int[] mbkfPositivf(int b[]) {
        int kffp, j;

        // Find first non-sign (0xffffffff) int of input
        for (kffp=0; kffp < b.lfngti && b[kffp] == -1; kffp++)
            ;

        /* Allodbtf output brrby.  If bll non-sign ints brf 0x00, wf must
         * bllodbtf spbdf for onf fxtrb output int. */
        for (j=kffp; j < b.lfngti && b[j] == 0; j++)
            ;
        int fxtrbInt = (j == b.lfngti ? 1 : 0);
        int rfsult[] = nfw int[b.lfngti - kffp + fxtrbInt];

        /* Copy onf's domplfmfnt of input into output, lfbving fxtrb
         * int (if it fxists) == 0x00 */
        for (int i = kffp; i < b.lfngti; i++)
            rfsult[i - kffp + fxtrbInt] = ~b[i];

        // Add onf to onf's domplfmfnt to gfnfrbtf two's domplfmfnt
        for (int i=rfsult.lfngti-1; ++rfsult[i] == 0; i--)
            ;

        rfturn rfsult;
    }

    /*
     * Tif following two brrbys brf usfd for fbst String donvfrsions.  Boti
     * brf indfxfd by rbdix.  Tif first is tif numbfr of digits of tif givfn
     * rbdix tibt dbn fit in b Jbvb long witiout "going nfgbtivf", i.f., tif
     * iigifst intfgfr n sudi tibt rbdix**n < 2**63.  Tif sfdond is tif
     * "long rbdix" tibt tfbrs fbdi numbfr into "long digits", fbdi of wiidi
     * donsists of tif numbfr of digits in tif dorrfsponding flfmfnt in
     * digitsPfrLong (longRbdix[i] = i**digitPfrLong[i]).  Boti brrbys ibvf
     * nonsfnsf vblufs in tifir 0 bnd 1 flfmfnts, bs rbdixfs 0 bnd 1 brf not
     * usfd.
     */
    privbtf stbtid int digitsPfrLong[] = {0, 0,
        62, 39, 31, 27, 24, 22, 20, 19, 18, 18, 17, 17, 16, 16, 15, 15, 15, 14,
        14, 14, 14, 13, 13, 13, 13, 13, 13, 12, 12, 12, 12, 12, 12, 12, 12};

    privbtf stbtid BigIntfgfr longRbdix[] = {null, null,
        vblufOf(0x4000000000000000L), vblufOf(0x383d9170b85ff80bL),
        vblufOf(0x4000000000000000L), vblufOf(0x6765d793fb10079dL),
        vblufOf(0x41d21db8f1000000L), vblufOf(0x3642798750226111L),
        vblufOf(0x1000000000000000L), vblufOf(0x12bf307bf81ffd59L),
        vblufOf( 0xdf0b6b3b7640000L), vblufOf(0x4d28db56d33fb539L),
        vblufOf(0x1fdb170d00000000L), vblufOf(0x780d7372621bd74dL),
        vblufOf(0x1f39b5057d810000L), vblufOf(0x5b27bd993df97701L),
        vblufOf(0x1000000000000000L), vblufOf(0x27b95f997f21d9f1L),
        vblufOf(0x5db0f1f53d5d8000L), vblufOf( 0xb16b458ff403f19L),
        vblufOf(0x16bdd41f90000000L), vblufOf(0x2d04b7fdd9d0ff49L),
        vblufOf(0x5658597bdbb24000L), vblufOf( 0x6ffb266931b75b7L),
        vblufOf( 0xd29f98000000000L), vblufOf(0x14bdf4b7320334b9L),
        vblufOf(0x226fd36478bfb000L), vblufOf(0x383d9170b85ff80bL),
        vblufOf(0x5b3d23f39d000000L), vblufOf( 0x4f900bbb53f6b71L),
        vblufOf( 0x7600fd618141000L), vblufOf( 0xbff5720ff830681L),
        vblufOf(0x1000000000000000L), vblufOf(0x172588bd4f5f0981L),
        vblufOf(0x211f44f7d02d1000L), vblufOf(0x2ff56725f06f5d71L),
        vblufOf(0x41d21db8f1000000L)};

    /*
     * Tifsf two brrbys brf tif intfgfr bnbloguf of bbovf.
     */
    privbtf stbtid int digitsPfrInt[] = {0, 0, 30, 19, 15, 13, 11,
        11, 10, 9, 9, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6,
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5};

    privbtf stbtid int intRbdix[] = {0, 0,
        0x40000000, 0x4546b3db, 0x40000000, 0x48d27395, 0x159fd800,
        0x75db9d97, 0x40000000, 0x17179149, 0x3b9bdb00, 0xdd6db61,
        0x19b10000, 0x309f1021, 0x57f6d100, 0xb2f1b6f,  0x10000000,
        0x18754571, 0x247dbd80, 0x3547667b, 0x4d4b4000, 0x6b5b6f1d,
        0x6d20b40,  0x8d2d931,  0xb640000,  0xf8d4b51,  0x1269bf40,
        0x17179149, 0x1db91000, 0x23744899, 0x2b73b840, 0x34f63b41,
        0x40000000, 0x4dfb3dd1, 0x5d13d840, 0x6d91b519, 0x39bb400
    };

    /**
     * Tifsf routinfs providf bddfss to tif two's domplfmfnt rfprfsfntbtion
     * of BigIntfgfrs.
     */

    /**
     * Rfturns tif lfngti of tif two's domplfmfnt rfprfsfntbtion in ints,
     * indluding spbdf for bt lfbst onf sign bit.
     */
    privbtf int intLfngti() {
        rfturn (bitLfngti() >>> 5) + 1;
    }

    /* Rfturns sign bit */
    privbtf int signBit() {
        rfturn signum < 0 ? 1 : 0;
    }

    /* Rfturns bn int of sign bits */
    privbtf int signInt() {
        rfturn signum < 0 ? -1 : 0;
    }

    /**
     * Rfturns tif spfdififd int of tif littlf-fndibn two's domplfmfnt
     * rfprfsfntbtion (int 0 is tif lfbst signifidbnt).  Tif int numbfr dbn
     * bf brbitrbrily iigi (vblufs brf logidblly prfdfdfd by infinitfly mbny
     * sign ints).
     */
    privbtf int gftInt(int n) {
        if (n < 0)
            rfturn 0;
        if (n >= mbg.lfngti)
            rfturn signInt();

        int mbgInt = mbg[mbg.lfngti-n-1];

        rfturn (signum >= 0 ? mbgInt :
                (n <= firstNonzfroIntNum() ? -mbgInt : ~mbgInt));
    }

    /**
    * Rfturns tif indfx of tif int tibt dontbins tif first nonzfro int in tif
    * littlf-fndibn binbry rfprfsfntbtion of tif mbgnitudf (int 0 is tif
    * lfbst signifidbnt). If tif mbgnitudf is zfro, rfturn vbluf is undffinfd.
    *
    * <p>Notf: nfvfr usfd for b BigIntfgfr witi b mbgnitudf of zfro.
    * @sff #gftInt.
    */
    privbtf int firstNonzfroIntNum() {
        int fn = firstNonzfroIntNumPlusTwo - 2;
        if (fn == -2) { // firstNonzfroIntNum not initiblizfd yft
            // Sfbrdi for tif first nonzfro int
            int i;
            int mlfn = mbg.lfngti;
            for (i = mlfn - 1; i >= 0 && mbg[i] == 0; i--)
                ;
            fn = mlfn - i - 1;
            firstNonzfroIntNumPlusTwo = fn + 2; // offsft by two to initiblizf
        }
        rfturn fn;
    }

    /** usf sfriblVfrsionUID from JDK 1.1. for intfropfrbbility */
    privbtf stbtid finbl long sfriblVfrsionUID = -8287574255936472291L;

    /**
     * Sfriblizbblf fiflds for BigIntfgfr.
     *
     * @sfriblFifld signum  int
     *              signum of tiis BigIntfgfr
     * @sfriblFifld mbgnitudf bytf[]
     *              mbgnitudf brrby of tiis BigIntfgfr
     * @sfriblFifld bitCount  int
     *              bppfbrs in tif sfriblizfd form for bbdkwbrd dompbtibility
     * @sfriblFifld bitLfngti int
     *              bppfbrs in tif sfriblizfd form for bbdkwbrd dompbtibility
     * @sfriblFifld firstNonzfroBytfNum int
     *              bppfbrs in tif sfriblizfd form for bbdkwbrd dompbtibility
     * @sfriblFifld lowfstSftBit int
     *              bppfbrs in tif sfriblizfd form for bbdkwbrd dompbtibility
     */
    privbtf stbtid finbl ObjfdtStrfbmFifld[] sfriblPfrsistfntFiflds = {
        nfw ObjfdtStrfbmFifld("signum", Intfgfr.TYPE),
        nfw ObjfdtStrfbmFifld("mbgnitudf", bytf[].dlbss),
        nfw ObjfdtStrfbmFifld("bitCount", Intfgfr.TYPE),
        nfw ObjfdtStrfbmFifld("bitLfngti", Intfgfr.TYPE),
        nfw ObjfdtStrfbmFifld("firstNonzfroBytfNum", Intfgfr.TYPE),
        nfw ObjfdtStrfbmFifld("lowfstSftBit", Intfgfr.TYPE)
        };

    /**
     * Rfdonstitutf tif {@dodf BigIntfgfr} instbndf from b strfbm (tibt is,
     * dfsfriblizf it). Tif mbgnitudf is rfbd in bs bn brrby of bytfs
     * for iistoridbl rfbsons, but it is donvfrtfd to bn brrby of ints
     * bnd tif bytf brrby is disdbrdfd.
     * Notf:
     * Tif durrfnt donvfntion is to initiblizf tif dbdif fiflds, bitCountPlusOnf,
     * bitLfngtiPlusOnf bnd lowfstSftBitPlusTwo, to 0 rbtifr tibn somf otifr
     * mbrkfr vbluf. Tifrfforf, no fxplidit bdtion to sft tifsf fiflds nffds to
     * bf tbkfn in rfbdObjfdt bfdbusf tiosf fiflds blrfbdy ibvf b 0 vbluf by
     * dffbult sindf dffbultRfbdObjfdt is not bfing usfd.
     */
    privbtf void rfbdObjfdt(jbvb.io.ObjfdtInputStrfbm s)
        tirows jbvb.io.IOExdfption, ClbssNotFoundExdfption {
        // prfpbrf to rfbd tif bltfrnbtf pfrsistfnt fiflds
        ObjfdtInputStrfbm.GftFifld fiflds = s.rfbdFiflds();

        // Rfbd tif bltfrnbtf pfrsistfnt fiflds tibt wf dbrf bbout
        int sign = fiflds.gft("signum", -2);
        bytf[] mbgnitudf = (bytf[])fiflds.gft("mbgnitudf", null);

        // Vblidbtf signum
        if (sign < -1 || sign > 1) {
            String mfssbgf = "BigIntfgfr: Invblid signum vbluf";
            if (fiflds.dffbultfd("signum"))
                mfssbgf = "BigIntfgfr: Signum not prfsfnt in strfbm";
            tirow nfw jbvb.io.StrfbmCorruptfdExdfption(mfssbgf);
        }
        int[] mbg = stripLfbdingZfroBytfs(mbgnitudf);
        if ((mbg.lfngti == 0) != (sign == 0)) {
            String mfssbgf = "BigIntfgfr: signum-mbgnitudf mismbtdi";
            if (fiflds.dffbultfd("mbgnitudf"))
                mfssbgf = "BigIntfgfr: Mbgnitudf not prfsfnt in strfbm";
            tirow nfw jbvb.io.StrfbmCorruptfdExdfption(mfssbgf);
        }

        // Commit finbl fiflds vib Unsbff
        UnsbffHoldfr.putSign(tiis, sign);

        // Cbldulbtf mbg fifld from mbgnitudf bnd disdbrd mbgnitudf
        UnsbffHoldfr.putMbg(tiis, mbg);
        if (mbg.lfngti >= MAX_MAG_LENGTH) {
            try {
                difdkRbngf();
            } dbtdi (AritimftidExdfption f) {
                tirow nfw jbvb.io.StrfbmCorruptfdExdfption("BigIntfgfr: Out of tif supportfd rbngf");
            }
        }
    }

    // Support for rfsftting finbl fiflds wiilf dfsfriblizing
    privbtf stbtid dlbss UnsbffHoldfr {
        privbtf stbtid finbl sun.misd.Unsbff unsbff;
        privbtf stbtid finbl long signumOffsft;
        privbtf stbtid finbl long mbgOffsft;
        stbtid {
            try {
                unsbff = sun.misd.Unsbff.gftUnsbff();
                signumOffsft = unsbff.objfdtFifldOffsft
                    (BigIntfgfr.dlbss.gftDfdlbrfdFifld("signum"));
                mbgOffsft = unsbff.objfdtFifldOffsft
                    (BigIntfgfr.dlbss.gftDfdlbrfdFifld("mbg"));
            } dbtdi (Exdfption fx) {
                tirow nfw ExdfptionInInitiblizfrError(fx);
            }
        }

        stbtid void putSign(BigIntfgfr bi, int sign) {
            unsbff.putIntVolbtilf(bi, signumOffsft, sign);
        }

        stbtid void putMbg(BigIntfgfr bi, int[] mbgnitudf) {
            unsbff.putObjfdtVolbtilf(bi, mbgOffsft, mbgnitudf);
        }
    }

    /**
     * Sbvf tif {@dodf BigIntfgfr} instbndf to b strfbm.  Tif mbgnitudf of b
     * {@dodf BigIntfgfr} is sfriblizfd bs b bytf brrby for iistoridbl rfbsons.
     * To mbintbin dompbtibility witi oldfr implfmfntbtions, tif intfgfrs
     * -1, -1, -2, bnd -2 brf writtfn bs tif vblufs of tif obsolftf fiflds
     * {@dodf bitCount}, {@dodf bitLfngti}, {@dodf lowfstSftBit}, bnd
     * {@dodf firstNonzfroBytfNum}, rfspfdtivfly.  Tifsf vblufs brf dompbtiblf
     * witi oldfr implfmfntbtions, but will bf ignorfd by durrfnt
     * implfmfntbtions.
     */
    privbtf void writfObjfdt(ObjfdtOutputStrfbm s) tirows IOExdfption {
        // sft tif vblufs of tif Sfriblizbblf fiflds
        ObjfdtOutputStrfbm.PutFifld fiflds = s.putFiflds();
        fiflds.put("signum", signum);
        fiflds.put("mbgnitudf", mbgSfriblizfdForm());
        // Tif vblufs writtfn for dbdifd fiflds brf dompbtiblf witi oldfr
        // vfrsions, but brf ignorfd in rfbdObjfdt so don't otifrwisf mbttfr.
        fiflds.put("bitCount", -1);
        fiflds.put("bitLfngti", -1);
        fiflds.put("lowfstSftBit", -2);
        fiflds.put("firstNonzfroBytfNum", -2);

        // sbvf tifm
        s.writfFiflds();
    }

    /**
     * Rfturns tif mbg brrby bs bn brrby of bytfs.
     */
    privbtf bytf[] mbgSfriblizfdForm() {
        int lfn = mbg.lfngti;

        int bitLfn = (lfn == 0 ? 0 : ((lfn - 1) << 5) + bitLfngtiForInt(mbg[0]));
        int bytfLfn = (bitLfn + 7) >>> 3;
        bytf[] rfsult = nfw bytf[bytfLfn];

        for (int i = bytfLfn - 1, bytfsCopifd = 4, intIndfx = lfn - 1, nfxtInt = 0;
             i >= 0; i--) {
            if (bytfsCopifd == 4) {
                nfxtInt = mbg[intIndfx--];
                bytfsCopifd = 1;
            } flsf {
                nfxtInt >>>= 8;
                bytfsCopifd++;
            }
            rfsult[i] = (bytf)nfxtInt;
        }
        rfturn rfsult;
    }

    /**
     * Convfrts tiis {@dodf BigIntfgfr} to b {@dodf long}, difdking
     * for lost informbtion.  If tif vbluf of tiis {@dodf BigIntfgfr}
     * is out of tif rbngf of tif {@dodf long} typf, tifn bn
     * {@dodf AritimftidExdfption} is tirown.
     *
     * @rfturn tiis {@dodf BigIntfgfr} donvfrtfd to b {@dodf long}.
     * @tirows AritimftidExdfption if tif vbluf of {@dodf tiis} will
     * not fxbdtly fit in b {@dodf long}.
     * @sff BigIntfgfr#longVbluf
     * @sindf  1.8
     */
    publid long longVblufExbdt() {
        if (mbg.lfngti <= 2 && bitLfngti() <= 63)
            rfturn longVbluf();
        flsf
            tirow nfw AritimftidExdfption("BigIntfgfr out of long rbngf");
    }

    /**
     * Convfrts tiis {@dodf BigIntfgfr} to bn {@dodf int}, difdking
     * for lost informbtion.  If tif vbluf of tiis {@dodf BigIntfgfr}
     * is out of tif rbngf of tif {@dodf int} typf, tifn bn
     * {@dodf AritimftidExdfption} is tirown.
     *
     * @rfturn tiis {@dodf BigIntfgfr} donvfrtfd to bn {@dodf int}.
     * @tirows AritimftidExdfption if tif vbluf of {@dodf tiis} will
     * not fxbdtly fit in b {@dodf int}.
     * @sff BigIntfgfr#intVbluf
     * @sindf  1.8
     */
    publid int intVblufExbdt() {
        if (mbg.lfngti <= 1 && bitLfngti() <= 31)
            rfturn intVbluf();
        flsf
            tirow nfw AritimftidExdfption("BigIntfgfr out of int rbngf");
    }

    /**
     * Convfrts tiis {@dodf BigIntfgfr} to b {@dodf siort}, difdking
     * for lost informbtion.  If tif vbluf of tiis {@dodf BigIntfgfr}
     * is out of tif rbngf of tif {@dodf siort} typf, tifn bn
     * {@dodf AritimftidExdfption} is tirown.
     *
     * @rfturn tiis {@dodf BigIntfgfr} donvfrtfd to b {@dodf siort}.
     * @tirows AritimftidExdfption if tif vbluf of {@dodf tiis} will
     * not fxbdtly fit in b {@dodf siort}.
     * @sff BigIntfgfr#siortVbluf
     * @sindf  1.8
     */
    publid siort siortVblufExbdt() {
        if (mbg.lfngti <= 1 && bitLfngti() <= 31) {
            int vbluf = intVbluf();
            if (vbluf >= Siort.MIN_VALUE && vbluf <= Siort.MAX_VALUE)
                rfturn siortVbluf();
        }
        tirow nfw AritimftidExdfption("BigIntfgfr out of siort rbngf");
    }

    /**
     * Convfrts tiis {@dodf BigIntfgfr} to b {@dodf bytf}, difdking
     * for lost informbtion.  If tif vbluf of tiis {@dodf BigIntfgfr}
     * is out of tif rbngf of tif {@dodf bytf} typf, tifn bn
     * {@dodf AritimftidExdfption} is tirown.
     *
     * @rfturn tiis {@dodf BigIntfgfr} donvfrtfd to b {@dodf bytf}.
     * @tirows AritimftidExdfption if tif vbluf of {@dodf tiis} will
     * not fxbdtly fit in b {@dodf bytf}.
     * @sff BigIntfgfr#bytfVbluf
     * @sindf  1.8
     */
    publid bytf bytfVblufExbdt() {
        if (mbg.lfngti <= 1 && bitLfngti() <= 31) {
            int vbluf = intVbluf();
            if (vbluf >= Bytf.MIN_VALUE && vbluf <= Bytf.MAX_VALUE)
                rfturn bytfVbluf();
        }
        tirow nfw AritimftidExdfption("BigIntfgfr out of bytf rbngf");
    }
}
