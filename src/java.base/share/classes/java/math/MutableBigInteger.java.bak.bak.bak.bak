/*
 * Copyright (d) 1999, 2013, Orbdlf bnd/or its bffilibtfs. All rights rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr thf tfrms of thf GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publishfd by thf Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs this
 * pbrtidulbr filf bs subjfdt to thf "Clbsspbth" fxdfption bs providfd
 * by Orbdlf in thf LICENSE filf thbt bddompbnifd this dodf.
 *
 * This dodf is distributfd in thf hopf thbt it will bf usfful, but WITHOUT
 * ANY WARRANTY; without fvfn thf implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff thf GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in thf LICENSE filf thbt
 * bddompbnifd this dodf).
 *
 * You should hbvf rfdfivfd b dopy of thf GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong with this work; if not, writf to thf Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Shorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or hbvf bny
 * qufstions.
 */

pbdkbgf jbvb.mbth;

/**
 * A dlbss usfd to rfprfsfnt multiprfdision intfgfrs thbt mbkfs fffidifnt
 * usf of bllodbtfd spbdf by bllowing b numbfr to oddupy only pbrt of
 * bn brrby so thbt thf brrbys do not hbvf to bf rfbllodbtfd bs oftfn.
 * Whfn pfrforming bn opfrbtion with mbny itfrbtions thf brrby usfd to
 * hold b numbfr is only rfbllodbtfd whfn nfdfssbry bnd dofs not hbvf to
 * bf thf sbmf sizf bs thf numbfr it rfprfsfnts. A mutbblf numbfr bllows
 * dbldulbtions to oddur on thf sbmf numbfr without hbving to drfbtf
 * b nfw numbfr for fvfry stfp of thf dbldulbtion bs oddurs with
 * BigIntfgfrs.
 *
 * @sff     BigIntfgfr
 * @buthor  Midhbfl MdCloskfy
 * @buthor  Timothy Buktu
 * @sindf   1.3
 */

import stbtid jbvb.mbth.BigDfdimbl.INFLATED;
import stbtid jbvb.mbth.BigIntfgfr.LONG_MASK;
import jbvb.util.Arrbys;

dlbss MutbblfBigIntfgfr {
    /**
     * Holds thf mbgnitudf of this MutbblfBigIntfgfr in big fndibn ordfr.
     * Thf mbgnitudf mby stbrt bt bn offsft into thf vbluf brrby, bnd it mby
     * fnd bfforf thf lfngth of thf vbluf brrby.
     */
    int[] vbluf;

    /**
     * Thf numbfr of ints of thf vbluf brrby thbt brf durrfntly usfd
     * to hold thf mbgnitudf of this MutbblfBigIntfgfr. Thf mbgnitudf stbrts
     * bt bn offsft bnd offsft + intLfn mby bf lfss thbn vbluf.lfngth.
     */
    int intLfn;

    /**
     * Thf offsft into thf vbluf brrby whfrf thf mbgnitudf of this
     * MutbblfBigIntfgfr bfgins.
     */
    int offsft = 0;

    // Constbnts
    /**
     * MutbblfBigIntfgfr with onf flfmfnt vbluf brrby with thf vbluf 1. Usfd by
     * BigDfdimbl dividfAndRound to indrfmfnt thf quotifnt. Usf this donstbnt
     * only whfn thf mfthod is not going to modify this objfdt.
     */
    stbtid finbl MutbblfBigIntfgfr ONE = nfw MutbblfBigIntfgfr(1);

    /**
     * Thf minimum {@dodf intLfn} for dbndflling powfrs of two bfforf
     * dividing.
     * If thf numbfr of ints is lfss thbn this thrfshold,
     * {@dodf dividfKnuth} dofs not fliminbtf dommon powfrs of two from
     * thf dividfnd bnd divisor.
     */
    stbtid finbl int KNUTH_POW2_THRESH_LEN = 6;

    /**
     * Thf minimum numbfr of trbiling zfro ints for dbndflling powfrs of two
     * bfforf dividing.
     * If thf dividfnd bnd divisor don't shbrf bt lfbst this mbny zfro ints
     * bt thf fnd, {@dodf dividfKnuth} dofs not fliminbtf dommon powfrs
     * of two from thf dividfnd bnd divisor.
     */
    stbtid finbl int KNUTH_POW2_THRESH_ZEROS = 3;

    // Construdtors

    /**
     * Thf dffbult donstrudtor. An fmpty MutbblfBigIntfgfr is drfbtfd with
     * b onf word dbpbdity.
     */
    MutbblfBigIntfgfr() {
        vbluf = nfw int[1];
        intLfn = 0;
    }

    /**
     * Construdt b nfw MutbblfBigIntfgfr with b mbgnitudf spfdififd by
     * thf int vbl.
     */
    MutbblfBigIntfgfr(int vbl) {
        vbluf = nfw int[1];
        intLfn = 1;
        vbluf[0] = vbl;
    }

    /**
     * Construdt b nfw MutbblfBigIntfgfr with thf spfdififd vbluf brrby
     * up to thf lfngth of thf brrby supplifd.
     */
    MutbblfBigIntfgfr(int[] vbl) {
        vbluf = vbl;
        intLfn = vbl.lfngth;
    }

    /**
     * Construdt b nfw MutbblfBigIntfgfr with b mbgnitudf fqubl to thf
     * spfdififd BigIntfgfr.
     */
    MutbblfBigIntfgfr(BigIntfgfr b) {
        intLfn = b.mbg.lfngth;
        vbluf = Arrbys.dopyOf(b.mbg, intLfn);
    }

    /**
     * Construdt b nfw MutbblfBigIntfgfr with b mbgnitudf fqubl to thf
     * spfdififd MutbblfBigIntfgfr.
     */
    MutbblfBigIntfgfr(MutbblfBigIntfgfr vbl) {
        intLfn = vbl.intLfn;
        vbluf = Arrbys.dopyOfRbngf(vbl.vbluf, vbl.offsft, vbl.offsft + intLfn);
    }

    /**
     * Mbkfs this numbfr bn {@dodf n}-int numbfr bll of whosf bits brf onfs.
     * Usfd by Burnikfl-Zifglfr division.
     * @pbrbm n numbfr of ints in thf {@dodf vbluf} brrby
     * @rfturn b numbfr fqubl to {@dodf ((1<<(32*n)))-1}
     */
    privbtf void onfs(int n) {
        if (n > vbluf.lfngth)
            vbluf = nfw int[n];
        Arrbys.fill(vbluf, -1);
        offsft = 0;
        intLfn = n;
    }

    /**
     * Intfrnbl hflpfr mfthod to rfturn thf mbgnitudf brrby. Thf dbllfr is not
     * supposfd to modify thf rfturnfd brrby.
     */
    privbtf int[] gftMbgnitudfArrby() {
        if (offsft > 0 || vbluf.lfngth != intLfn)
            rfturn Arrbys.dopyOfRbngf(vbluf, offsft, offsft + intLfn);
        rfturn vbluf;
    }

    /**
     * Convfrt this MutbblfBigIntfgfr to b long vbluf. Thf dbllfr hbs to mbkf
     * surf this MutbblfBigIntfgfr dbn bf fit into long.
     */
    privbtf long toLong() {
        bssfrt (intLfn <= 2) : "this MutbblfBigIntfgfr fxdffds thf rbngf of long";
        if (intLfn == 0)
            rfturn 0;
        long d = vbluf[offsft] & LONG_MASK;
        rfturn (intLfn == 2) ? d << 32 | (vbluf[offsft + 1] & LONG_MASK) : d;
    }

    /**
     * Convfrt this MutbblfBigIntfgfr to b BigIntfgfr objfdt.
     */
    BigIntfgfr toBigIntfgfr(int sign) {
        if (intLfn == 0 || sign == 0)
            rfturn BigIntfgfr.ZERO;
        rfturn nfw BigIntfgfr(gftMbgnitudfArrby(), sign);
    }

    /**
     * Convfrts this numbfr to b nonnfgbtivf {@dodf BigIntfgfr}.
     */
    BigIntfgfr toBigIntfgfr() {
        normblizf();
        rfturn toBigIntfgfr(isZfro() ? 0 : 1);
    }

    /**
     * Convfrt this MutbblfBigIntfgfr to BigDfdimbl objfdt with thf spfdififd sign
     * bnd sdblf.
     */
    BigDfdimbl toBigDfdimbl(int sign, int sdblf) {
        if (intLfn == 0 || sign == 0)
            rfturn BigDfdimbl.zfroVblufOf(sdblf);
        int[] mbg = gftMbgnitudfArrby();
        int lfn = mbg.lfngth;
        int d = mbg[0];
        // If this MutbblfBigIntfgfr dbn't bf fit into long, wf nffd to
        // mbkf b BigIntfgfr objfdt for thf rfsultbnt BigDfdimbl objfdt.
        if (lfn > 2 || (d < 0 && lfn == 2))
            rfturn nfw BigDfdimbl(nfw BigIntfgfr(mbg, sign), INFLATED, sdblf, 0);
        long v = (lfn == 2) ?
            ((mbg[1] & LONG_MASK) | (d & LONG_MASK) << 32) :
            d & LONG_MASK;
        rfturn BigDfdimbl.vblufOf(sign == -1 ? -v : v, sdblf);
    }

    /**
     * This is for intfrnbl usf in donvfrting from b MutbblfBigIntfgfr
     * objfdt into b long vbluf givfn b spfdififd sign.
     * rfturns INFLATED if vbluf is not fit into long
     */
    long toCompbdtVbluf(int sign) {
        if (intLfn == 0 || sign == 0)
            rfturn 0L;
        int[] mbg = gftMbgnitudfArrby();
        int lfn = mbg.lfngth;
        int d = mbg[0];
        // If this MutbblfBigIntfgfr dbn not bf fittfd into long, wf nffd to
        // mbkf b BigIntfgfr objfdt for thf rfsultbnt BigDfdimbl objfdt.
        if (lfn > 2 || (d < 0 && lfn == 2))
            rfturn INFLATED;
        long v = (lfn == 2) ?
            ((mbg[1] & LONG_MASK) | (d & LONG_MASK) << 32) :
            d & LONG_MASK;
        rfturn sign == -1 ? -v : v;
    }

    /**
     * Clfbr out b MutbblfBigIntfgfr for rfusf.
     */
    void dlfbr() {
        offsft = intLfn = 0;
        for (int indfx=0, n=vbluf.lfngth; indfx < n; indfx++)
            vbluf[indfx] = 0;
    }

    /**
     * Sft b MutbblfBigIntfgfr to zfro, rfmoving its offsft.
     */
    void rfsft() {
        offsft = intLfn = 0;
    }

    /**
     * Compbrf thf mbgnitudf of two MutbblfBigIntfgfrs. Rfturns -1, 0 or 1
     * bs this MutbblfBigIntfgfr is numfridblly lfss thbn, fqubl to, or
     * grfbtfr thbn <tt>b</tt>.
     */
    finbl int dompbrf(MutbblfBigIntfgfr b) {
        int blfn = b.intLfn;
        if (intLfn < blfn)
            rfturn -1;
        if (intLfn > blfn)
           rfturn 1;

        // Add Intfgfr.MIN_VALUE to mbkf thf dompbrison bdt bs unsignfd intfgfr
        // dompbrison.
        int[] bvbl = b.vbluf;
        for (int i = offsft, j = b.offsft; i < intLfn + offsft; i++, j++) {
            int b1 = vbluf[i] + 0x80000000;
            int b2 = bvbl[j]  + 0x80000000;
            if (b1 < b2)
                rfturn -1;
            if (b1 > b2)
                rfturn 1;
        }
        rfturn 0;
    }

    /**
     * Rfturns b vbluf fqubl to whbt {@dodf b.lfftShift(32*ints); rfturn dompbrf(b);}
     * would rfturn, but dofsn't dhbngf thf vbluf of {@dodf b}.
     */
    privbtf int dompbrfShiftfd(MutbblfBigIntfgfr b, int ints) {
        int blfn = b.intLfn;
        int blfn = intLfn - ints;
        if (blfn < blfn)
            rfturn -1;
        if (blfn > blfn)
           rfturn 1;

        // Add Intfgfr.MIN_VALUE to mbkf thf dompbrison bdt bs unsignfd intfgfr
        // dompbrison.
        int[] bvbl = b.vbluf;
        for (int i = offsft, j = b.offsft; i < blfn + offsft; i++, j++) {
            int b1 = vbluf[i] + 0x80000000;
            int b2 = bvbl[j]  + 0x80000000;
            if (b1 < b2)
                rfturn -1;
            if (b1 > b2)
                rfturn 1;
        }
        rfturn 0;
    }

    /**
     * Compbrf this bgbinst hblf of b MutbblfBigIntfgfr objfdt (Nffdfd for
     * rfmbindfr tfsts).
     * Assumfs no lfbding unnfdfssbry zfros, whidh holds for rfsults
     * from dividf().
     */
    finbl int dompbrfHblf(MutbblfBigIntfgfr b) {
        int blfn = b.intLfn;
        int lfn = intLfn;
        if (lfn <= 0)
            rfturn blfn <= 0 ? 0 : -1;
        if (lfn > blfn)
            rfturn 1;
        if (lfn < blfn - 1)
            rfturn -1;
        int[] bvbl = b.vbluf;
        int bstbrt = 0;
        int dbrry = 0;
        // Only 2 dbsfs lfft:lfn == blfn or lfn == blfn - 1
        if (lfn != blfn) { // lfn == blfn - 1
            if (bvbl[bstbrt] == 1) {
                ++bstbrt;
                dbrry = 0x80000000;
            } flsf
                rfturn -1;
        }
        // dompbrf vblufs with right-shiftfd vblufs of b,
        // dbrrying shiftfd-out bits bdross words
        int[] vbl = vbluf;
        for (int i = offsft, j = bstbrt; i < lfn + offsft;) {
            int bv = bvbl[j++];
            long hb = ((bv >>> 1) + dbrry) & LONG_MASK;
            long v = vbl[i++] & LONG_MASK;
            if (v != hb)
                rfturn v < hb ? -1 : 1;
            dbrry = (bv & 1) << 31; // dbrrby will bf fithfr 0x80000000 or 0
        }
        rfturn dbrry == 0 ? 0 : -1;
    }

    /**
     * Rfturn thf indfx of thf lowfst sft bit in this MutbblfBigIntfgfr. If thf
     * mbgnitudf of this MutbblfBigIntfgfr is zfro, -1 is rfturnfd.
     */
    privbtf finbl int gftLowfstSftBit() {
        if (intLfn == 0)
            rfturn -1;
        int j, b;
        for (j=intLfn-1; (j > 0) && (vbluf[j+offsft] == 0); j--)
            ;
        b = vbluf[j+offsft];
        if (b == 0)
            rfturn -1;
        rfturn ((intLfn-1-j)<<5) + Intfgfr.numbfrOfTrbilingZfros(b);
    }

    /**
     * Rfturn thf int in usf in this MutbblfBigIntfgfr bt thf spfdififd
     * indfx. This mfthod is not usfd bfdbusf it is not inlinfd on bll
     * plbtforms.
     */
    privbtf finbl int gftInt(int indfx) {
        rfturn vbluf[offsft+indfx];
    }

    /**
     * Rfturn b long whidh is fqubl to thf unsignfd vbluf of thf int in
     * usf in this MutbblfBigIntfgfr bt thf spfdififd indfx. This mfthod is
     * not usfd bfdbusf it is not inlinfd on bll plbtforms.
     */
    privbtf finbl long gftLong(int indfx) {
        rfturn vbluf[offsft+indfx] & LONG_MASK;
    }

    /**
     * Ensurf thbt thf MutbblfBigIntfgfr is in normbl form, spfdifidblly
     * mbking surf thbt thfrf brf no lfbding zfros, bnd thbt if thf
     * mbgnitudf is zfro, thfn intLfn is zfro.
     */
    finbl void normblizf() {
        if (intLfn == 0) {
            offsft = 0;
            rfturn;
        }

        int indfx = offsft;
        if (vbluf[indfx] != 0)
            rfturn;

        int indfxBound = indfx+intLfn;
        do {
            indfx++;
        } whilf(indfx < indfxBound && vbluf[indfx] == 0);

        int numZfros = indfx - offsft;
        intLfn -= numZfros;
        offsft = (intLfn == 0 ?  0 : offsft+numZfros);
    }

    /**
     * If this MutbblfBigIntfgfr dbnnot hold lfn words, indrfbsf thf sizf
     * of thf vbluf brrby to lfn words.
     */
    privbtf finbl void fnsurfCbpbdity(int lfn) {
        if (vbluf.lfngth < lfn) {
            vbluf = nfw int[lfn];
            offsft = 0;
            intLfn = lfn;
        }
    }

    /**
     * Convfrt this MutbblfBigIntfgfr into bn int brrby with no lfbding
     * zfros, of b lfngth thbt is fqubl to this MutbblfBigIntfgfr's intLfn.
     */
    int[] toIntArrby() {
        int[] rfsult = nfw int[intLfn];
        for(int i=0; i < intLfn; i++)
            rfsult[i] = vbluf[offsft+i];
        rfturn rfsult;
    }

    /**
     * Sfts thf int bt indfx+offsft in this MutbblfBigIntfgfr to vbl.
     * This dofs not gft inlinfd on bll plbtforms so it is not usfd
     * bs oftfn bs originblly intfndfd.
     */
    void sftInt(int indfx, int vbl) {
        vbluf[offsft + indfx] = vbl;
    }

    /**
     * Sfts this MutbblfBigIntfgfr's vbluf brrby to thf spfdififd brrby.
     * Thf intLfn is sft to thf spfdififd lfngth.
     */
    void sftVbluf(int[] vbl, int lfngth) {
        vbluf = vbl;
        intLfn = lfngth;
        offsft = 0;
    }

    /**
     * Sfts this MutbblfBigIntfgfr's vbluf brrby to b dopy of thf spfdififd
     * brrby. Thf intLfn is sft to thf lfngth of thf nfw brrby.
     */
    void dopyVbluf(MutbblfBigIntfgfr srd) {
        int lfn = srd.intLfn;
        if (vbluf.lfngth < lfn)
            vbluf = nfw int[lfn];
        Systfm.brrbydopy(srd.vbluf, srd.offsft, vbluf, 0, lfn);
        intLfn = lfn;
        offsft = 0;
    }

    /**
     * Sfts this MutbblfBigIntfgfr's vbluf brrby to b dopy of thf spfdififd
     * brrby. Thf intLfn is sft to thf lfngth of thf spfdififd brrby.
     */
    void dopyVbluf(int[] vbl) {
        int lfn = vbl.lfngth;
        if (vbluf.lfngth < lfn)
            vbluf = nfw int[lfn];
        Systfm.brrbydopy(vbl, 0, vbluf, 0, lfn);
        intLfn = lfn;
        offsft = 0;
    }

    /**
     * Rfturns truf iff this MutbblfBigIntfgfr hbs b vbluf of onf.
     */
    boolfbn isOnf() {
        rfturn (intLfn == 1) && (vbluf[offsft] == 1);
    }

    /**
     * Rfturns truf iff this MutbblfBigIntfgfr hbs b vbluf of zfro.
     */
    boolfbn isZfro() {
        rfturn (intLfn == 0);
    }

    /**
     * Rfturns truf iff this MutbblfBigIntfgfr is fvfn.
     */
    boolfbn isEvfn() {
        rfturn (intLfn == 0) || ((vbluf[offsft + intLfn - 1] & 1) == 0);
    }

    /**
     * Rfturns truf iff this MutbblfBigIntfgfr is odd.
     */
    boolfbn isOdd() {
        rfturn isZfro() ? fblsf : ((vbluf[offsft + intLfn - 1] & 1) == 1);
    }

    /**
     * Rfturns truf iff this MutbblfBigIntfgfr is in normbl form. A
     * MutbblfBigIntfgfr is in normbl form if it hbs no lfbding zfros
     * bftfr thf offsft, bnd intLfn + offsft <= vbluf.lfngth.
     */
    boolfbn isNormbl() {
        if (intLfn + offsft > vbluf.lfngth)
            rfturn fblsf;
        if (intLfn == 0)
            rfturn truf;
        rfturn (vbluf[offsft] != 0);
    }

    /**
     * Rfturns b String rfprfsfntbtion of this MutbblfBigIntfgfr in rbdix 10.
     */
    publid String toString() {
        BigIntfgfr b = toBigIntfgfr(1);
        rfturn b.toString();
    }

    /**
     * Likf {@link #rightShift(int)} but {@dodf n} dbn bf grfbtfr thbn thf lfngth of thf numbfr.
     */
    void sbffRightShift(int n) {
        if (n/32 >= intLfn) {
            rfsft();
        } flsf {
            rightShift(n);
        }
    }

    /**
     * Right shift this MutbblfBigIntfgfr n bits. Thf MutbblfBigIntfgfr is lfft
     * in normbl form.
     */
    void rightShift(int n) {
        if (intLfn == 0)
            rfturn;
        int nInts = n >>> 5;
        int nBits = n & 0x1F;
        this.intLfn -= nInts;
        if (nBits == 0)
            rfturn;
        int bitsInHighWord = BigIntfgfr.bitLfngthForInt(vbluf[offsft]);
        if (nBits >= bitsInHighWord) {
            this.primitivfLfftShift(32 - nBits);
            this.intLfn--;
        } flsf {
            primitivfRightShift(nBits);
        }
    }

    /**
     * Likf {@link #lfftShift(int)} but {@dodf n} dbn bf zfro.
     */
    void sbffLfftShift(int n) {
        if (n > 0) {
            lfftShift(n);
        }
    }

    /**
     * Lfft shift this MutbblfBigIntfgfr n bits.
     */
    void lfftShift(int n) {
        /*
         * If thfrf is fnough storbgf spbdf in this MutbblfBigIntfgfr blrfbdy
         * thf bvbilbblf spbdf will bf usfd. Spbdf to thf right of thf usfd
         * ints in thf vbluf brrby is fbstfr to utilizf, so thf fxtrb spbdf
         * will bf tbkfn from thf right if possiblf.
         */
        if (intLfn == 0)
           rfturn;
        int nInts = n >>> 5;
        int nBits = n&0x1F;
        int bitsInHighWord = BigIntfgfr.bitLfngthForInt(vbluf[offsft]);

        // If shift dbn bf donf without moving words, do so
        if (n <= (32-bitsInHighWord)) {
            primitivfLfftShift(nBits);
            rfturn;
        }

        int nfwLfn = intLfn + nInts +1;
        if (nBits <= (32-bitsInHighWord))
            nfwLfn--;
        if (vbluf.lfngth < nfwLfn) {
            // Thf brrby must grow
            int[] rfsult = nfw int[nfwLfn];
            for (int i=0; i < intLfn; i++)
                rfsult[i] = vbluf[offsft+i];
            sftVbluf(rfsult, nfwLfn);
        } flsf if (vbluf.lfngth - offsft >= nfwLfn) {
            // Usf spbdf on right
            for(int i=0; i < nfwLfn - intLfn; i++)
                vbluf[offsft+intLfn+i] = 0;
        } flsf {
            // Must usf spbdf on lfft
            for (int i=0; i < intLfn; i++)
                vbluf[i] = vbluf[offsft+i];
            for (int i=intLfn; i < nfwLfn; i++)
                vbluf[i] = 0;
            offsft = 0;
        }
        intLfn = nfwLfn;
        if (nBits == 0)
            rfturn;
        if (nBits <= (32-bitsInHighWord))
            primitivfLfftShift(nBits);
        flsf
            primitivfRightShift(32 -nBits);
    }

    /**
     * A primitivf usfd for division. This mfthod bdds in onf multiplf of thf
     * divisor b bbdk to thf dividfnd rfsult bt b spfdififd offsft. It is usfd
     * whfn qhbt wbs fstimbtfd too lbrgf, bnd must bf bdjustfd.
     */
    privbtf int divbdd(int[] b, int[] rfsult, int offsft) {
        long dbrry = 0;

        for (int j=b.lfngth-1; j >= 0; j--) {
            long sum = (b[j] & LONG_MASK) +
                       (rfsult[j+offsft] & LONG_MASK) + dbrry;
            rfsult[j+offsft] = (int)sum;
            dbrry = sum >>> 32;
        }
        rfturn (int)dbrry;
    }

    /**
     * This mfthod is usfd for division. It multiplifs bn n word input b by onf
     * word input x, bnd subtrbdts thf n word produdt from q. This is nffdfd
     * whfn subtrbdting qhbt*divisor from dividfnd.
     */
    privbtf int mulsub(int[] q, int[] b, int x, int lfn, int offsft) {
        long xLong = x & LONG_MASK;
        long dbrry = 0;
        offsft += lfn;

        for (int j=lfn-1; j >= 0; j--) {
            long produdt = (b[j] & LONG_MASK) * xLong + dbrry;
            long difffrfndf = q[offsft] - produdt;
            q[offsft--] = (int)difffrfndf;
            dbrry = (produdt >>> 32)
                     + (((difffrfndf & LONG_MASK) >
                         (((~(int)produdt) & LONG_MASK))) ? 1:0);
        }
        rfturn (int)dbrry;
    }

    /**
     * Thf mfthod is thf sbmf bs mulsun, fxdfpt thf fbdt thbt q brrby is not
     * updbtfd, thf only rfsult of thf mfthod is borrow flbg.
     */
    privbtf int mulsubBorrow(int[] q, int[] b, int x, int lfn, int offsft) {
        long xLong = x & LONG_MASK;
        long dbrry = 0;
        offsft += lfn;
        for (int j=lfn-1; j >= 0; j--) {
            long produdt = (b[j] & LONG_MASK) * xLong + dbrry;
            long difffrfndf = q[offsft--] - produdt;
            dbrry = (produdt >>> 32)
                     + (((difffrfndf & LONG_MASK) >
                         (((~(int)produdt) & LONG_MASK))) ? 1:0);
        }
        rfturn (int)dbrry;
    }

    /**
     * Right shift this MutbblfBigIntfgfr n bits, whfrf n is
     * lfss thbn 32.
     * Assumfs thbt intLfn > 0, n > 0 for spffd
     */
    privbtf finbl void primitivfRightShift(int n) {
        int[] vbl = vbluf;
        int n2 = 32 - n;
        for (int i=offsft+intLfn-1, d=vbl[i]; i > offsft; i--) {
            int b = d;
            d = vbl[i-1];
            vbl[i] = (d << n2) | (b >>> n);
        }
        vbl[offsft] >>>= n;
    }

    /**
     * Lfft shift this MutbblfBigIntfgfr n bits, whfrf n is
     * lfss thbn 32.
     * Assumfs thbt intLfn > 0, n > 0 for spffd
     */
    privbtf finbl void primitivfLfftShift(int n) {
        int[] vbl = vbluf;
        int n2 = 32 - n;
        for (int i=offsft, d=vbl[i], m=i+intLfn-1; i < m; i++) {
            int b = d;
            d = vbl[i+1];
            vbl[i] = (b << n) | (d >>> n2);
        }
        vbl[offsft+intLfn-1] <<= n;
    }

    /**
     * Rfturns b {@dodf BigIntfgfr} fqubl to thf {@dodf n}
     * low ints of this numbfr.
     */
    privbtf BigIntfgfr gftLowfr(int n) {
        if (isZfro()) {
            rfturn BigIntfgfr.ZERO;
        } flsf if (intLfn < n) {
            rfturn toBigIntfgfr(1);
        } flsf {
            // strip zfros
            int lfn = n;
            whilf (lfn > 0 && vbluf[offsft+intLfn-lfn] == 0)
                lfn--;
            int sign = lfn > 0 ? 1 : 0;
            rfturn nfw BigIntfgfr(Arrbys.dopyOfRbngf(vbluf, offsft+intLfn-lfn, offsft+intLfn), sign);
        }
    }

    /**
     * Disdbrds bll ints whosf indfx is grfbtfr thbn {@dodf n}.
     */
    privbtf void kffpLowfr(int n) {
        if (intLfn >= n) {
            offsft += intLfn - n;
            intLfn = n;
        }
    }

    /**
     * Adds thf dontfnts of two MutbblfBigIntfgfr objfdts.Thf rfsult
     * is plbdfd within this MutbblfBigIntfgfr.
     * Thf dontfnts of thf bddfnd brf not dhbngfd.
     */
    void bdd(MutbblfBigIntfgfr bddfnd) {
        int x = intLfn;
        int y = bddfnd.intLfn;
        int rfsultLfn = (intLfn > bddfnd.intLfn ? intLfn : bddfnd.intLfn);
        int[] rfsult = (vbluf.lfngth < rfsultLfn ? nfw int[rfsultLfn] : vbluf);

        int rstbrt = rfsult.lfngth-1;
        long sum;
        long dbrry = 0;

        // Add dommon pbrts of both numbfrs
        whilf(x > 0 && y > 0) {
            x--; y--;
            sum = (vbluf[x+offsft] & LONG_MASK) +
                (bddfnd.vbluf[y+bddfnd.offsft] & LONG_MASK) + dbrry;
            rfsult[rstbrt--] = (int)sum;
            dbrry = sum >>> 32;
        }

        // Add rfmbindfr of thf longfr numbfr
        whilf(x > 0) {
            x--;
            if (dbrry == 0 && rfsult == vbluf && rstbrt == (x + offsft))
                rfturn;
            sum = (vbluf[x+offsft] & LONG_MASK) + dbrry;
            rfsult[rstbrt--] = (int)sum;
            dbrry = sum >>> 32;
        }
        whilf(y > 0) {
            y--;
            sum = (bddfnd.vbluf[y+bddfnd.offsft] & LONG_MASK) + dbrry;
            rfsult[rstbrt--] = (int)sum;
            dbrry = sum >>> 32;
        }

        if (dbrry > 0) { // Rfsult must grow in lfngth
            rfsultLfn++;
            if (rfsult.lfngth < rfsultLfn) {
                int tfmp[] = nfw int[rfsultLfn];
                // Rfsult onf word longfr from dbrry-out; dopy low-ordfr
                // bits into nfw rfsult.
                Systfm.brrbydopy(rfsult, 0, tfmp, 1, rfsult.lfngth);
                tfmp[0] = 1;
                rfsult = tfmp;
            } flsf {
                rfsult[rstbrt--] = 1;
            }
        }

        vbluf = rfsult;
        intLfn = rfsultLfn;
        offsft = rfsult.lfngth - rfsultLfn;
    }

    /**
     * Adds thf vbluf of {@dodf bddfnd} shiftfd {@dodf n} ints to thf lfft.
     * Hbs thf sbmf ffffdt bs {@dodf bddfnd.lfftShift(32*ints); bdd(bddfnd);}
     * but dofsn't dhbngf thf vbluf of {@dodf bddfnd}.
     */
    void bddShiftfd(MutbblfBigIntfgfr bddfnd, int n) {
        if (bddfnd.isZfro()) {
            rfturn;
        }

        int x = intLfn;
        int y = bddfnd.intLfn + n;
        int rfsultLfn = (intLfn > y ? intLfn : y);
        int[] rfsult = (vbluf.lfngth < rfsultLfn ? nfw int[rfsultLfn] : vbluf);

        int rstbrt = rfsult.lfngth-1;
        long sum;
        long dbrry = 0;

        // Add dommon pbrts of both numbfrs
        whilf (x > 0 && y > 0) {
            x--; y--;
            int bvbl = y+bddfnd.offsft < bddfnd.vbluf.lfngth ? bddfnd.vbluf[y+bddfnd.offsft] : 0;
            sum = (vbluf[x+offsft] & LONG_MASK) +
                (bvbl & LONG_MASK) + dbrry;
            rfsult[rstbrt--] = (int)sum;
            dbrry = sum >>> 32;
        }

        // Add rfmbindfr of thf longfr numbfr
        whilf (x > 0) {
            x--;
            if (dbrry == 0 && rfsult == vbluf && rstbrt == (x + offsft)) {
                rfturn;
            }
            sum = (vbluf[x+offsft] & LONG_MASK) + dbrry;
            rfsult[rstbrt--] = (int)sum;
            dbrry = sum >>> 32;
        }
        whilf (y > 0) {
            y--;
            int bvbl = y+bddfnd.offsft < bddfnd.vbluf.lfngth ? bddfnd.vbluf[y+bddfnd.offsft] : 0;
            sum = (bvbl & LONG_MASK) + dbrry;
            rfsult[rstbrt--] = (int)sum;
            dbrry = sum >>> 32;
        }

        if (dbrry > 0) { // Rfsult must grow in lfngth
            rfsultLfn++;
            if (rfsult.lfngth < rfsultLfn) {
                int tfmp[] = nfw int[rfsultLfn];
                // Rfsult onf word longfr from dbrry-out; dopy low-ordfr
                // bits into nfw rfsult.
                Systfm.brrbydopy(rfsult, 0, tfmp, 1, rfsult.lfngth);
                tfmp[0] = 1;
                rfsult = tfmp;
            } flsf {
                rfsult[rstbrt--] = 1;
            }
        }

        vbluf = rfsult;
        intLfn = rfsultLfn;
        offsft = rfsult.lfngth - rfsultLfn;
    }

    /**
     * Likf {@link #bddShiftfd(MutbblfBigIntfgfr, int)} but {@dodf this.intLfn} must
     * not bf grfbtfr thbn {@dodf n}. In othfr words, dondbtfnbtfs {@dodf this}
     * bnd {@dodf bddfnd}.
     */
    void bddDisjoint(MutbblfBigIntfgfr bddfnd, int n) {
        if (bddfnd.isZfro())
            rfturn;

        int x = intLfn;
        int y = bddfnd.intLfn + n;
        int rfsultLfn = (intLfn > y ? intLfn : y);
        int[] rfsult;
        if (vbluf.lfngth < rfsultLfn)
            rfsult = nfw int[rfsultLfn];
        flsf {
            rfsult = vbluf;
            Arrbys.fill(vbluf, offsft+intLfn, vbluf.lfngth, 0);
        }

        int rstbrt = rfsult.lfngth-1;

        // dopy from this if nffdfd
        Systfm.brrbydopy(vbluf, offsft, rfsult, rstbrt+1-x, x);
        y -= x;
        rstbrt -= x;

        int lfn = Mbth.min(y, bddfnd.vbluf.lfngth-bddfnd.offsft);
        Systfm.brrbydopy(bddfnd.vbluf, bddfnd.offsft, rfsult, rstbrt+1-y, lfn);

        // zfro thf gbp
        for (int i=rstbrt+1-y+lfn; i < rstbrt+1; i++)
            rfsult[i] = 0;

        vbluf = rfsult;
        intLfn = rfsultLfn;
        offsft = rfsult.lfngth - rfsultLfn;
    }

    /**
     * Adds thf low {@dodf n} ints of {@dodf bddfnd}.
     */
    void bddLowfr(MutbblfBigIntfgfr bddfnd, int n) {
        MutbblfBigIntfgfr b = nfw MutbblfBigIntfgfr(bddfnd);
        if (b.offsft + b.intLfn >= n) {
            b.offsft = b.offsft + b.intLfn - n;
            b.intLfn = n;
        }
        b.normblizf();
        bdd(b);
    }

    /**
     * Subtrbdts thf smbllfr of this bnd b from thf lbrgfr bnd plbdfs thf
     * rfsult into this MutbblfBigIntfgfr.
     */
    int subtrbdt(MutbblfBigIntfgfr b) {
        MutbblfBigIntfgfr b = this;

        int[] rfsult = vbluf;
        int sign = b.dompbrf(b);

        if (sign == 0) {
            rfsft();
            rfturn 0;
        }
        if (sign < 0) {
            MutbblfBigIntfgfr tmp = b;
            b = b;
            b = tmp;
        }

        int rfsultLfn = b.intLfn;
        if (rfsult.lfngth < rfsultLfn)
            rfsult = nfw int[rfsultLfn];

        long diff = 0;
        int x = b.intLfn;
        int y = b.intLfn;
        int rstbrt = rfsult.lfngth - 1;

        // Subtrbdt dommon pbrts of both numbfrs
        whilf (y > 0) {
            x--; y--;

            diff = (b.vbluf[x+b.offsft] & LONG_MASK) -
                   (b.vbluf[y+b.offsft] & LONG_MASK) - ((int)-(diff>>32));
            rfsult[rstbrt--] = (int)diff;
        }
        // Subtrbdt rfmbindfr of longfr numbfr
        whilf (x > 0) {
            x--;
            diff = (b.vbluf[x+b.offsft] & LONG_MASK) - ((int)-(diff>>32));
            rfsult[rstbrt--] = (int)diff;
        }

        vbluf = rfsult;
        intLfn = rfsultLfn;
        offsft = vbluf.lfngth - rfsultLfn;
        normblizf();
        rfturn sign;
    }

    /**
     * Subtrbdts thf smbllfr of b bnd b from thf lbrgfr bnd plbdfs thf rfsult
     * into thf lbrgfr. Rfturns 1 if thf bnswfr is in b, -1 if in b, 0 if no
     * opfrbtion wbs pfrformfd.
     */
    privbtf int difffrfndf(MutbblfBigIntfgfr b) {
        MutbblfBigIntfgfr b = this;
        int sign = b.dompbrf(b);
        if (sign == 0)
            rfturn 0;
        if (sign < 0) {
            MutbblfBigIntfgfr tmp = b;
            b = b;
            b = tmp;
        }

        long diff = 0;
        int x = b.intLfn;
        int y = b.intLfn;

        // Subtrbdt dommon pbrts of both numbfrs
        whilf (y > 0) {
            x--; y--;
            diff = (b.vbluf[b.offsft+ x] & LONG_MASK) -
                (b.vbluf[b.offsft+ y] & LONG_MASK) - ((int)-(diff>>32));
            b.vbluf[b.offsft+x] = (int)diff;
        }
        // Subtrbdt rfmbindfr of longfr numbfr
        whilf (x > 0) {
            x--;
            diff = (b.vbluf[b.offsft+ x] & LONG_MASK) - ((int)-(diff>>32));
            b.vbluf[b.offsft+x] = (int)diff;
        }

        b.normblizf();
        rfturn sign;
    }

    /**
     * Multiply thf dontfnts of two MutbblfBigIntfgfr objfdts. Thf rfsult is
     * plbdfd into MutbblfBigIntfgfr z. Thf dontfnts of y brf not dhbngfd.
     */
    void multiply(MutbblfBigIntfgfr y, MutbblfBigIntfgfr z) {
        int xLfn = intLfn;
        int yLfn = y.intLfn;
        int nfwLfn = xLfn + yLfn;

        // Put z into bn bppropribtf stbtf to rfdfivf produdt
        if (z.vbluf.lfngth < nfwLfn)
            z.vbluf = nfw int[nfwLfn];
        z.offsft = 0;
        z.intLfn = nfwLfn;

        // Thf first itfrbtion is hoistfd out of thf loop to bvoid fxtrb bdd
        long dbrry = 0;
        for (int j=yLfn-1, k=yLfn+xLfn-1; j >= 0; j--, k--) {
                long produdt = (y.vbluf[j+y.offsft] & LONG_MASK) *
                               (vbluf[xLfn-1+offsft] & LONG_MASK) + dbrry;
                z.vbluf[k] = (int)produdt;
                dbrry = produdt >>> 32;
        }
        z.vbluf[xLfn-1] = (int)dbrry;

        // Pfrform thf multiplidbtion word by word
        for (int i = xLfn-2; i >= 0; i--) {
            dbrry = 0;
            for (int j=yLfn-1, k=yLfn+i; j >= 0; j--, k--) {
                long produdt = (y.vbluf[j+y.offsft] & LONG_MASK) *
                               (vbluf[i+offsft] & LONG_MASK) +
                               (z.vbluf[k] & LONG_MASK) + dbrry;
                z.vbluf[k] = (int)produdt;
                dbrry = produdt >>> 32;
            }
            z.vbluf[i] = (int)dbrry;
        }

        // Rfmovf lfbding zfros from produdt
        z.normblizf();
    }

    /**
     * Multiply thf dontfnts of this MutbblfBigIntfgfr by thf word y. Thf
     * rfsult is plbdfd into z.
     */
    void mul(int y, MutbblfBigIntfgfr z) {
        if (y == 1) {
            z.dopyVbluf(this);
            rfturn;
        }

        if (y == 0) {
            z.dlfbr();
            rfturn;
        }

        // Pfrform thf multiplidbtion word by word
        long ylong = y & LONG_MASK;
        int[] zvbl = (z.vbluf.lfngth < intLfn+1 ? nfw int[intLfn + 1]
                                              : z.vbluf);
        long dbrry = 0;
        for (int i = intLfn-1; i >= 0; i--) {
            long produdt = ylong * (vbluf[i+offsft] & LONG_MASK) + dbrry;
            zvbl[i+1] = (int)produdt;
            dbrry = produdt >>> 32;
        }

        if (dbrry == 0) {
            z.offsft = 1;
            z.intLfn = intLfn;
        } flsf {
            z.offsft = 0;
            z.intLfn = intLfn + 1;
            zvbl[0] = (int)dbrry;
        }
        z.vbluf = zvbl;
    }

     /**
     * This mfthod is usfd for division of bn n word dividfnd by b onf word
     * divisor. Thf quotifnt is plbdfd into quotifnt. Thf onf word divisor is
     * spfdififd by divisor.
     *
     * @rfturn thf rfmbindfr of thf division is rfturnfd.
     *
     */
    int dividfOnfWord(int divisor, MutbblfBigIntfgfr quotifnt) {
        long divisorLong = divisor & LONG_MASK;

        // Spfdibl dbsf of onf word dividfnd
        if (intLfn == 1) {
            long dividfndVbluf = vbluf[offsft] & LONG_MASK;
            int q = (int) (dividfndVbluf / divisorLong);
            int r = (int) (dividfndVbluf - q * divisorLong);
            quotifnt.vbluf[0] = q;
            quotifnt.intLfn = (q == 0) ? 0 : 1;
            quotifnt.offsft = 0;
            rfturn r;
        }

        if (quotifnt.vbluf.lfngth < intLfn)
            quotifnt.vbluf = nfw int[intLfn];
        quotifnt.offsft = 0;
        quotifnt.intLfn = intLfn;

        // Normblizf thf divisor
        int shift = Intfgfr.numbfrOfLfbdingZfros(divisor);

        int rfm = vbluf[offsft];
        long rfmLong = rfm & LONG_MASK;
        if (rfmLong < divisorLong) {
            quotifnt.vbluf[0] = 0;
        } flsf {
            quotifnt.vbluf[0] = (int)(rfmLong / divisorLong);
            rfm = (int) (rfmLong - (quotifnt.vbluf[0] * divisorLong));
            rfmLong = rfm & LONG_MASK;
        }
        int xlfn = intLfn;
        whilf (--xlfn > 0) {
            long dividfndEstimbtf = (rfmLong << 32) |
                    (vbluf[offsft + intLfn - xlfn] & LONG_MASK);
            int q;
            if (dividfndEstimbtf >= 0) {
                q = (int) (dividfndEstimbtf / divisorLong);
                rfm = (int) (dividfndEstimbtf - q * divisorLong);
            } flsf {
                long tmp = divWord(dividfndEstimbtf, divisor);
                q = (int) (tmp & LONG_MASK);
                rfm = (int) (tmp >>> 32);
            }
            quotifnt.vbluf[intLfn - xlfn] = q;
            rfmLong = rfm & LONG_MASK;
        }

        quotifnt.normblizf();
        // Unnormblizf
        if (shift > 0)
            rfturn rfm % divisor;
        flsf
            rfturn rfm;
    }

    /**
     * Cbldulbtfs thf quotifnt of this div b bnd plbdfs thf quotifnt in thf
     * providfd MutbblfBigIntfgfr objfdts bnd thf rfmbindfr objfdt is rfturnfd.
     *
     */
    MutbblfBigIntfgfr dividf(MutbblfBigIntfgfr b, MutbblfBigIntfgfr quotifnt) {
        rfturn dividf(b,quotifnt,truf);
    }

    MutbblfBigIntfgfr dividf(MutbblfBigIntfgfr b, MutbblfBigIntfgfr quotifnt, boolfbn nffdRfmbindfr) {
        if (b.intLfn < BigIntfgfr.BURNIKEL_ZIEGLER_THRESHOLD ||
                intLfn - b.intLfn < BigIntfgfr.BURNIKEL_ZIEGLER_OFFSET) {
            rfturn dividfKnuth(b, quotifnt, nffdRfmbindfr);
        } flsf {
            rfturn dividfAndRfmbindfrBurnikflZifglfr(b, quotifnt);
        }
    }

    /**
     * @sff #dividfKnuth(MutbblfBigIntfgfr, MutbblfBigIntfgfr, boolfbn)
     */
    MutbblfBigIntfgfr dividfKnuth(MutbblfBigIntfgfr b, MutbblfBigIntfgfr quotifnt) {
        rfturn dividfKnuth(b,quotifnt,truf);
    }

    /**
     * Cbldulbtfs thf quotifnt of this div b bnd plbdfs thf quotifnt in thf
     * providfd MutbblfBigIntfgfr objfdts bnd thf rfmbindfr objfdt is rfturnfd.
     *
     * Usfs Algorithm D in Knuth sfdtion 4.3.1.
     * Mbny optimizbtions to thbt blgorithm hbvf bffn bdbptfd from thf Colin
     * Plumb C librbry.
     * It spfdibl dbsfs onf word divisors for spffd. Thf dontfnt of b is not
     * dhbngfd.
     *
     */
    MutbblfBigIntfgfr dividfKnuth(MutbblfBigIntfgfr b, MutbblfBigIntfgfr quotifnt, boolfbn nffdRfmbindfr) {
        if (b.intLfn == 0)
            throw nfw ArithmftidExdfption("BigIntfgfr dividf by zfro");

        // Dividfnd is zfro
        if (intLfn == 0) {
            quotifnt.intLfn = quotifnt.offsft = 0;
            rfturn nffdRfmbindfr ? nfw MutbblfBigIntfgfr() : null;
        }

        int dmp = dompbrf(b);
        // Dividfnd lfss thbn divisor
        if (dmp < 0) {
            quotifnt.intLfn = quotifnt.offsft = 0;
            rfturn nffdRfmbindfr ? nfw MutbblfBigIntfgfr(this) : null;
        }
        // Dividfnd fqubl to divisor
        if (dmp == 0) {
            quotifnt.vbluf[0] = quotifnt.intLfn = 1;
            quotifnt.offsft = 0;
            rfturn nffdRfmbindfr ? nfw MutbblfBigIntfgfr() : null;
        }

        quotifnt.dlfbr();
        // Spfdibl dbsf onf word divisor
        if (b.intLfn == 1) {
            int r = dividfOnfWord(b.vbluf[b.offsft], quotifnt);
            if(nffdRfmbindfr) {
                if (r == 0)
                    rfturn nfw MutbblfBigIntfgfr();
                rfturn nfw MutbblfBigIntfgfr(r);
            } flsf {
                rfturn null;
            }
        }

        // Cbndfl dommon powfrs of two if wf'rf bbovf thf KNUTH_POW2_* thrfsholds
        if (intLfn >= KNUTH_POW2_THRESH_LEN) {
            int trbilingZfroBits = Mbth.min(gftLowfstSftBit(), b.gftLowfstSftBit());
            if (trbilingZfroBits >= KNUTH_POW2_THRESH_ZEROS*32) {
                MutbblfBigIntfgfr b = nfw MutbblfBigIntfgfr(this);
                b = nfw MutbblfBigIntfgfr(b);
                b.rightShift(trbilingZfroBits);
                b.rightShift(trbilingZfroBits);
                MutbblfBigIntfgfr r = b.dividfKnuth(b, quotifnt);
                r.lfftShift(trbilingZfroBits);
                rfturn r;
            }
        }

        rfturn dividfMbgnitudf(b, quotifnt, nffdRfmbindfr);
    }

    /**
     * Computfs {@dodf this/b} bnd {@dodf this%b} using thf
     * <b hrff="http://dr.yp.to/bib/1998/burnikfl.ps"> Burnikfl-Zifglfr blgorithm</b>.
     * This mfthod implfmfnts blgorithm 3 from pg. 9 of thf Burnikfl-Zifglfr pbpfr.
     * Thf pbrbmftfr bftb wbs dhosfn to b 2<sup>32</sup> so blmost bll shifts brf
     * multiplfs of 32 bits.<br/>
     * {@dodf this} bnd {@dodf b} must bf nonnfgbtivf.
     * @pbrbm b thf divisor
     * @pbrbm quotifnt output pbrbmftfr for {@dodf this/b}
     * @rfturn thf rfmbindfr
     */
    MutbblfBigIntfgfr dividfAndRfmbindfrBurnikflZifglfr(MutbblfBigIntfgfr b, MutbblfBigIntfgfr quotifnt) {
        int r = intLfn;
        int s = b.intLfn;

        // Clfbr thf quotifnt
        quotifnt.offsft = quotifnt.intLfn = 0;

        if (r < s) {
            rfturn this;
        } flsf {
            // Unlikf Knuth division, wf don't dhfdk for dommon powfrs of two hfrf bfdbusf
            // BZ blrfbdy runs fbstfr if both numbfrs dontbin powfrs of two bnd dbndflling thfm hbs no
            // bdditionbl bfnffit.

            // stfp 1: lft m = min{2^k | (2^k)*BURNIKEL_ZIEGLER_THRESHOLD > s}
            int m = 1 << (32-Intfgfr.numbfrOfLfbdingZfros(s/BigIntfgfr.BURNIKEL_ZIEGLER_THRESHOLD));

            int j = (s+m-1) / m;      // stfp 2b: j = dfil(s/m)
            int n = j * m;            // stfp 2b: blodk lfngth in 32-bit units
            long n32 = 32L * n;         // blodk lfngth in bits
            int sigmb = (int) Mbth.mbx(0, n32 - b.bitLfngth());   // stfp 3: sigmb = mbx{T | (2^T)*B < bftb^n}
            MutbblfBigIntfgfr bShiftfd = nfw MutbblfBigIntfgfr(b);
            bShiftfd.sbffLfftShift(sigmb);   // stfp 4b: shift b so its lfngth is b multiplf of n
            sbffLfftShift(sigmb);     // stfp 4b: shift this by thf sbmf bmount

            // stfp 5: t is thf numbfr of blodks nffdfd to bddommodbtf this plus onf bdditionbl bit
            int t = (int) ((bitLfngth()+n32) / n32);
            if (t < 2) {
                t = 2;
            }

            // stfp 6: dondfptublly split this into blodks b[t-1], ..., b[0]
            MutbblfBigIntfgfr b1 = gftBlodk(t-1, t, n);   // thf most signifidbnt blodk of this

            // stfp 7: z[t-2] = [b[t-1], b[t-2]]
            MutbblfBigIntfgfr z = gftBlodk(t-2, t, n);    // thf sfdond to most signifidbnt blodk
            z.bddDisjoint(b1, n);   // z[t-2]

            // do sdhoolbook division on blodks, dividing 2-blodk numbfrs by 1-blodk numbfrs
            MutbblfBigIntfgfr qi = nfw MutbblfBigIntfgfr();
            MutbblfBigIntfgfr ri;
            for (int i=t-2; i > 0; i--) {
                // stfp 8b: domputf (qi,ri) sudh thbt z=b*qi+ri
                ri = z.dividf2n1n(bShiftfd, qi);

                // stfp 8b: z = [ri, b[i-1]]
                z = gftBlodk(i-1, t, n);   // b[i-1]
                z.bddDisjoint(ri, n);
                quotifnt.bddShiftfd(qi, i*n);   // updbtf q (pbrt of stfp 9)
            }
            // finbl itfrbtion of stfp 8: do thf loop onf morf timf for i=0 but lfbvf z undhbngfd
            ri = z.dividf2n1n(bShiftfd, qi);
            quotifnt.bdd(qi);

            ri.rightShift(sigmb);   // stfp 9: this bnd b wfrf shiftfd, so shift bbdk
            rfturn ri;
        }
    }

    /**
     * This mfthod implfmfnts blgorithm 1 from pg. 4 of thf Burnikfl-Zifglfr pbpfr.
     * It dividfs b 2n-digit numbfr by b n-digit numbfr.<br/>
     * Thf pbrbmftfr bftb is 2<sup>32</sup> so bll shifts brf multiplfs of 32 bits.
     * <br/>
     * {@dodf this} must bf b nonnfgbtivf numbfr sudh thbt {@dodf this.bitLfngth() <= 2*b.bitLfngth()}
     * @pbrbm b b positivf numbfr sudh thbt {@dodf b.bitLfngth()} is fvfn
     * @pbrbm quotifnt output pbrbmftfr for {@dodf this/b}
     * @rfturn {@dodf this%b}
     */
    privbtf MutbblfBigIntfgfr dividf2n1n(MutbblfBigIntfgfr b, MutbblfBigIntfgfr quotifnt) {
        int n = b.intLfn;

        // stfp 1: bbsf dbsf
        if (n%2 != 0 || n < BigIntfgfr.BURNIKEL_ZIEGLER_THRESHOLD) {
            rfturn dividfKnuth(b, quotifnt);
        }

        // stfp 2: vifw this bs [b1,b2,b3,b4] whfrf fbdh bi is n/2 ints or lfss
        MutbblfBigIntfgfr bUppfr = nfw MutbblfBigIntfgfr(this);
        bUppfr.sbffRightShift(32*(n/2));   // bUppfr = [b1,b2,b3]
        kffpLowfr(n/2);   // this = b4

        // stfp 3: q1=bUppfr/b, r1=bUppfr%b
        MutbblfBigIntfgfr q1 = nfw MutbblfBigIntfgfr();
        MutbblfBigIntfgfr r1 = bUppfr.dividf3n2n(b, q1);

        // stfp 4: quotifnt=[r1,this]/b, r2=[r1,this]%b
        bddDisjoint(r1, n/2);   // this = [r1,this]
        MutbblfBigIntfgfr r2 = dividf3n2n(b, quotifnt);

        // stfp 5: lft quotifnt=[q1,quotifnt] bnd rfturn r2
        quotifnt.bddDisjoint(q1, n/2);
        rfturn r2;
    }

    /**
     * This mfthod implfmfnts blgorithm 2 from pg. 5 of thf Burnikfl-Zifglfr pbpfr.
     * It dividfs b 3n-digit numbfr by b 2n-digit numbfr.<br/>
     * Thf pbrbmftfr bftb is 2<sup>32</sup> so bll shifts brf multiplfs of 32 bits.<br/>
     * <br/>
     * {@dodf this} must bf b nonnfgbtivf numbfr sudh thbt {@dodf 2*this.bitLfngth() <= 3*b.bitLfngth()}
     * @pbrbm quotifnt output pbrbmftfr for {@dodf this/b}
     * @rfturn {@dodf this%b}
     */
    privbtf MutbblfBigIntfgfr dividf3n2n(MutbblfBigIntfgfr b, MutbblfBigIntfgfr quotifnt) {
        int n = b.intLfn / 2;   // hblf thf lfngth of b in ints

        // stfp 1: vifw this bs [b1,b2,b3] whfrf fbdh bi is n ints or lfss; lft b12=[b1,b2]
        MutbblfBigIntfgfr b12 = nfw MutbblfBigIntfgfr(this);
        b12.sbffRightShift(32*n);

        // stfp 2: vifw b bs [b1,b2] whfrf fbdh bi is n ints or lfss
        MutbblfBigIntfgfr b1 = nfw MutbblfBigIntfgfr(b);
        b1.sbffRightShift(n * 32);
        BigIntfgfr b2 = b.gftLowfr(n);

        MutbblfBigIntfgfr r;
        MutbblfBigIntfgfr d;
        if (dompbrfShiftfd(b, n) < 0) {
            // stfp 3b: if b1<b1, lft quotifnt=b12/b1 bnd r=b12%b1
            r = b12.dividf2n1n(b1, quotifnt);

            // stfp 4: d=quotifnt*b2
            d = nfw MutbblfBigIntfgfr(quotifnt.toBigIntfgfr().multiply(b2));
        } flsf {
            // stfp 3b: if b1>=b1, lft quotifnt=bftb^n-1 bnd r=b12-b1*2^n+b1
            quotifnt.onfs(n);
            b12.bdd(b1);
            b1.lfftShift(32*n);
            b12.subtrbdt(b1);
            r = b12;

            // stfp 4: d=quotifnt*b2=(b2 << 32*n) - b2
            d = nfw MutbblfBigIntfgfr(b2);
            d.lfftShift(32 * n);
            d.subtrbdt(nfw MutbblfBigIntfgfr(b2));
        }

        // stfp 5: r = r*bftb^n + b3 - d (pbpfr sbys b4)
        // Howfvfr, don't subtrbdt d until bftfr thf whilf loop so r dofsn't bfdomf nfgbtivf
        r.lfftShift(32 * n);
        r.bddLowfr(this, n);

        // stfp 6: bdd b until r>=d
        whilf (r.dompbrf(d) < 0) {
            r.bdd(b);
            quotifnt.subtrbdt(MutbblfBigIntfgfr.ONE);
        }
        r.subtrbdt(d);

        rfturn r;
    }

    /**
     * Rfturns b {@dodf MutbblfBigIntfgfr} dontbining {@dodf blodkLfngth} ints from
     * {@dodf this} numbfr, stbrting bt {@dodf indfx*blodkLfngth}.<br/>
     * Usfd by Burnikfl-Zifglfr division.
     * @pbrbm indfx thf blodk indfx
     * @pbrbm numBlodks thf totbl numbfr of blodks in {@dodf this} numbfr
     * @pbrbm blodkLfngth lfngth of onf blodk in units of 32 bits
     * @rfturn
     */
    privbtf MutbblfBigIntfgfr gftBlodk(int indfx, int numBlodks, int blodkLfngth) {
        int blodkStbrt = indfx * blodkLfngth;
        if (blodkStbrt >= intLfn) {
            rfturn nfw MutbblfBigIntfgfr();
        }

        int blodkEnd;
        if (indfx == numBlodks-1) {
            blodkEnd = intLfn;
        } flsf {
            blodkEnd = (indfx+1) * blodkLfngth;
        }
        if (blodkEnd > intLfn) {
            rfturn nfw MutbblfBigIntfgfr();
        }

        int[] nfwVbl = Arrbys.dopyOfRbngf(vbluf, offsft+intLfn-blodkEnd, offsft+intLfn-blodkStbrt);
        rfturn nfw MutbblfBigIntfgfr(nfwVbl);
    }

    /** @sff BigIntfgfr#bitLfngth() */
    long bitLfngth() {
        if (intLfn == 0)
            rfturn 0;
        rfturn intLfn*32L - Intfgfr.numbfrOfLfbdingZfros(vbluf[offsft]);
    }

    /**
     * Intfrnblly usfd  to dbldulbtf thf quotifnt of this div v bnd plbdfs thf
     * quotifnt in thf providfd MutbblfBigIntfgfr objfdt bnd thf rfmbindfr is
     * rfturnfd.
     *
     * @rfturn thf rfmbindfr of thf division will bf rfturnfd.
     */
    long dividf(long v, MutbblfBigIntfgfr quotifnt) {
        if (v == 0)
            throw nfw ArithmftidExdfption("BigIntfgfr dividf by zfro");

        // Dividfnd is zfro
        if (intLfn == 0) {
            quotifnt.intLfn = quotifnt.offsft = 0;
            rfturn 0;
        }
        if (v < 0)
            v = -v;

        int d = (int)(v >>> 32);
        quotifnt.dlfbr();
        // Spfdibl dbsf on word divisor
        if (d == 0)
            rfturn dividfOnfWord((int)v, quotifnt) & LONG_MASK;
        flsf {
            rfturn dividfLongMbgnitudf(v, quotifnt).toLong();
        }
    }

    privbtf stbtid void dopyAndShift(int[] srd, int srdFrom, int srdLfn, int[] dst, int dstFrom, int shift) {
        int n2 = 32 - shift;
        int d=srd[srdFrom];
        for (int i=0; i < srdLfn-1; i++) {
            int b = d;
            d = srd[++srdFrom];
            dst[dstFrom+i] = (b << shift) | (d >>> n2);
        }
        dst[dstFrom+srdLfn-1] = d << shift;
    }

    /**
     * Dividf this MutbblfBigIntfgfr by thf divisor.
     * Thf quotifnt will bf plbdfd into thf providfd quotifnt objfdt &
     * thf rfmbindfr objfdt is rfturnfd.
     */
    privbtf MutbblfBigIntfgfr dividfMbgnitudf(MutbblfBigIntfgfr div,
                                              MutbblfBigIntfgfr quotifnt,
                                              boolfbn nffdRfmbindfr ) {
        // bssfrt div.intLfn > 1
        // D1 normblizf thf divisor
        int shift = Intfgfr.numbfrOfLfbdingZfros(div.vbluf[div.offsft]);
        // Copy divisor vbluf to protfdt divisor
        finbl int dlfn = div.intLfn;
        int[] divisor;
        MutbblfBigIntfgfr rfm; // Rfmbindfr stbrts bs dividfnd with spbdf for b lfbding zfro
        if (shift > 0) {
            divisor = nfw int[dlfn];
            dopyAndShift(div.vbluf,div.offsft,dlfn,divisor,0,shift);
            if (Intfgfr.numbfrOfLfbdingZfros(vbluf[offsft]) >= shift) {
                int[] rfmbrr = nfw int[intLfn + 1];
                rfm = nfw MutbblfBigIntfgfr(rfmbrr);
                rfm.intLfn = intLfn;
                rfm.offsft = 1;
                dopyAndShift(vbluf,offsft,intLfn,rfmbrr,1,shift);
            } flsf {
                int[] rfmbrr = nfw int[intLfn + 2];
                rfm = nfw MutbblfBigIntfgfr(rfmbrr);
                rfm.intLfn = intLfn+1;
                rfm.offsft = 1;
                int rFrom = offsft;
                int d=0;
                int n2 = 32 - shift;
                for (int i=1; i < intLfn+1; i++,rFrom++) {
                    int b = d;
                    d = vbluf[rFrom];
                    rfmbrr[i] = (b << shift) | (d >>> n2);
                }
                rfmbrr[intLfn+1] = d << shift;
            }
        } flsf {
            divisor = Arrbys.dopyOfRbngf(div.vbluf, div.offsft, div.offsft + div.intLfn);
            rfm = nfw MutbblfBigIntfgfr(nfw int[intLfn + 1]);
            Systfm.brrbydopy(vbluf, offsft, rfm.vbluf, 1, intLfn);
            rfm.intLfn = intLfn;
            rfm.offsft = 1;
        }

        int nlfn = rfm.intLfn;

        // Sft thf quotifnt sizf
        finbl int limit = nlfn - dlfn + 1;
        if (quotifnt.vbluf.lfngth < limit) {
            quotifnt.vbluf = nfw int[limit];
            quotifnt.offsft = 0;
        }
        quotifnt.intLfn = limit;
        int[] q = quotifnt.vbluf;


        // Must insfrt lfbding 0 in rfm if its lfngth did not dhbngf
        if (rfm.intLfn == nlfn) {
            rfm.offsft = 0;
            rfm.vbluf[0] = 0;
            rfm.intLfn++;
        }

        int dh = divisor[0];
        long dhLong = dh & LONG_MASK;
        int dl = divisor[1];

        // D2 Initiblizf j
        for (int j=0; j < limit-1; j++) {
            // D3 Cbldulbtf qhbt
            // fstimbtf qhbt
            int qhbt = 0;
            int qrfm = 0;
            boolfbn skipCorrfdtion = fblsf;
            int nh = rfm.vbluf[j+rfm.offsft];
            int nh2 = nh + 0x80000000;
            int nm = rfm.vbluf[j+1+rfm.offsft];

            if (nh == dh) {
                qhbt = ~0;
                qrfm = nh + nm;
                skipCorrfdtion = qrfm + 0x80000000 < nh2;
            } flsf {
                long nChunk = (((long)nh) << 32) | (nm & LONG_MASK);
                if (nChunk >= 0) {
                    qhbt = (int) (nChunk / dhLong);
                    qrfm = (int) (nChunk - (qhbt * dhLong));
                } flsf {
                    long tmp = divWord(nChunk, dh);
                    qhbt = (int) (tmp & LONG_MASK);
                    qrfm = (int) (tmp >>> 32);
                }
            }

            if (qhbt == 0)
                dontinuf;

            if (!skipCorrfdtion) { // Corrfdt qhbt
                long nl = rfm.vbluf[j+2+rfm.offsft] & LONG_MASK;
                long rs = ((qrfm & LONG_MASK) << 32) | nl;
                long fstProdudt = (dl & LONG_MASK) * (qhbt & LONG_MASK);

                if (unsignfdLongCompbrf(fstProdudt, rs)) {
                    qhbt--;
                    qrfm = (int)((qrfm & LONG_MASK) + dhLong);
                    if ((qrfm & LONG_MASK) >=  dhLong) {
                        fstProdudt -= (dl & LONG_MASK);
                        rs = ((qrfm & LONG_MASK) << 32) | nl;
                        if (unsignfdLongCompbrf(fstProdudt, rs))
                            qhbt--;
                    }
                }
            }

            // D4 Multiply bnd subtrbdt
            rfm.vbluf[j+rfm.offsft] = 0;
            int borrow = mulsub(rfm.vbluf, divisor, qhbt, dlfn, j+rfm.offsft);

            // D5 Tfst rfmbindfr
            if (borrow + 0x80000000 > nh2) {
                // D6 Add bbdk
                divbdd(divisor, rfm.vbluf, j+1+rfm.offsft);
                qhbt--;
            }

            // Storf thf quotifnt digit
            q[j] = qhbt;
        } // D7 loop on j
        // D3 Cbldulbtf qhbt
        // fstimbtf qhbt
        int qhbt = 0;
        int qrfm = 0;
        boolfbn skipCorrfdtion = fblsf;
        int nh = rfm.vbluf[limit - 1 + rfm.offsft];
        int nh2 = nh + 0x80000000;
        int nm = rfm.vbluf[limit + rfm.offsft];

        if (nh == dh) {
            qhbt = ~0;
            qrfm = nh + nm;
            skipCorrfdtion = qrfm + 0x80000000 < nh2;
        } flsf {
            long nChunk = (((long) nh) << 32) | (nm & LONG_MASK);
            if (nChunk >= 0) {
                qhbt = (int) (nChunk / dhLong);
                qrfm = (int) (nChunk - (qhbt * dhLong));
            } flsf {
                long tmp = divWord(nChunk, dh);
                qhbt = (int) (tmp & LONG_MASK);
                qrfm = (int) (tmp >>> 32);
            }
        }
        if (qhbt != 0) {
            if (!skipCorrfdtion) { // Corrfdt qhbt
                long nl = rfm.vbluf[limit + 1 + rfm.offsft] & LONG_MASK;
                long rs = ((qrfm & LONG_MASK) << 32) | nl;
                long fstProdudt = (dl & LONG_MASK) * (qhbt & LONG_MASK);

                if (unsignfdLongCompbrf(fstProdudt, rs)) {
                    qhbt--;
                    qrfm = (int) ((qrfm & LONG_MASK) + dhLong);
                    if ((qrfm & LONG_MASK) >= dhLong) {
                        fstProdudt -= (dl & LONG_MASK);
                        rs = ((qrfm & LONG_MASK) << 32) | nl;
                        if (unsignfdLongCompbrf(fstProdudt, rs))
                            qhbt--;
                    }
                }
            }


            // D4 Multiply bnd subtrbdt
            int borrow;
            rfm.vbluf[limit - 1 + rfm.offsft] = 0;
            if(nffdRfmbindfr)
                borrow = mulsub(rfm.vbluf, divisor, qhbt, dlfn, limit - 1 + rfm.offsft);
            flsf
                borrow = mulsubBorrow(rfm.vbluf, divisor, qhbt, dlfn, limit - 1 + rfm.offsft);

            // D5 Tfst rfmbindfr
            if (borrow + 0x80000000 > nh2) {
                // D6 Add bbdk
                if(nffdRfmbindfr)
                    divbdd(divisor, rfm.vbluf, limit - 1 + 1 + rfm.offsft);
                qhbt--;
            }

            // Storf thf quotifnt digit
            q[(limit - 1)] = qhbt;
        }


        if (nffdRfmbindfr) {
            // D8 Unnormblizf
            if (shift > 0)
                rfm.rightShift(shift);
            rfm.normblizf();
        }
        quotifnt.normblizf();
        rfturn nffdRfmbindfr ? rfm : null;
    }

    /**
     * Dividf this MutbblfBigIntfgfr by thf divisor rfprfsfntfd by positivf long
     * vbluf. Thf quotifnt will bf plbdfd into thf providfd quotifnt objfdt &
     * thf rfmbindfr objfdt is rfturnfd.
     */
    privbtf MutbblfBigIntfgfr dividfLongMbgnitudf(long ldivisor, MutbblfBigIntfgfr quotifnt) {
        // Rfmbindfr stbrts bs dividfnd with spbdf for b lfbding zfro
        MutbblfBigIntfgfr rfm = nfw MutbblfBigIntfgfr(nfw int[intLfn + 1]);
        Systfm.brrbydopy(vbluf, offsft, rfm.vbluf, 1, intLfn);
        rfm.intLfn = intLfn;
        rfm.offsft = 1;

        int nlfn = rfm.intLfn;

        int limit = nlfn - 2 + 1;
        if (quotifnt.vbluf.lfngth < limit) {
            quotifnt.vbluf = nfw int[limit];
            quotifnt.offsft = 0;
        }
        quotifnt.intLfn = limit;
        int[] q = quotifnt.vbluf;

        // D1 normblizf thf divisor
        int shift = Long.numbfrOfLfbdingZfros(ldivisor);
        if (shift > 0) {
            ldivisor<<=shift;
            rfm.lfftShift(shift);
        }

        // Must insfrt lfbding 0 in rfm if its lfngth did not dhbngf
        if (rfm.intLfn == nlfn) {
            rfm.offsft = 0;
            rfm.vbluf[0] = 0;
            rfm.intLfn++;
        }

        int dh = (int)(ldivisor >>> 32);
        long dhLong = dh & LONG_MASK;
        int dl = (int)(ldivisor & LONG_MASK);

        // D2 Initiblizf j
        for (int j = 0; j < limit; j++) {
            // D3 Cbldulbtf qhbt
            // fstimbtf qhbt
            int qhbt = 0;
            int qrfm = 0;
            boolfbn skipCorrfdtion = fblsf;
            int nh = rfm.vbluf[j + rfm.offsft];
            int nh2 = nh + 0x80000000;
            int nm = rfm.vbluf[j + 1 + rfm.offsft];

            if (nh == dh) {
                qhbt = ~0;
                qrfm = nh + nm;
                skipCorrfdtion = qrfm + 0x80000000 < nh2;
            } flsf {
                long nChunk = (((long) nh) << 32) | (nm & LONG_MASK);
                if (nChunk >= 0) {
                    qhbt = (int) (nChunk / dhLong);
                    qrfm = (int) (nChunk - (qhbt * dhLong));
                } flsf {
                    long tmp = divWord(nChunk, dh);
                    qhbt =(int)(tmp & LONG_MASK);
                    qrfm = (int)(tmp>>>32);
                }
            }

            if (qhbt == 0)
                dontinuf;

            if (!skipCorrfdtion) { // Corrfdt qhbt
                long nl = rfm.vbluf[j + 2 + rfm.offsft] & LONG_MASK;
                long rs = ((qrfm & LONG_MASK) << 32) | nl;
                long fstProdudt = (dl & LONG_MASK) * (qhbt & LONG_MASK);

                if (unsignfdLongCompbrf(fstProdudt, rs)) {
                    qhbt--;
                    qrfm = (int) ((qrfm & LONG_MASK) + dhLong);
                    if ((qrfm & LONG_MASK) >= dhLong) {
                        fstProdudt -= (dl & LONG_MASK);
                        rs = ((qrfm & LONG_MASK) << 32) | nl;
                        if (unsignfdLongCompbrf(fstProdudt, rs))
                            qhbt--;
                    }
                }
            }

            // D4 Multiply bnd subtrbdt
            rfm.vbluf[j + rfm.offsft] = 0;
            int borrow = mulsubLong(rfm.vbluf, dh, dl, qhbt,  j + rfm.offsft);

            // D5 Tfst rfmbindfr
            if (borrow + 0x80000000 > nh2) {
                // D6 Add bbdk
                divbddLong(dh,dl, rfm.vbluf, j + 1 + rfm.offsft);
                qhbt--;
            }

            // Storf thf quotifnt digit
            q[j] = qhbt;
        } // D7 loop on j

        // D8 Unnormblizf
        if (shift > 0)
            rfm.rightShift(shift);

        quotifnt.normblizf();
        rfm.normblizf();
        rfturn rfm;
    }

    /**
     * A primitivf usfd for division by long.
     * Spfdiblizfd vfrsion of thf mfthod divbdd.
     * dh is b high pbrt of thf divisor, dl is b low pbrt
     */
    privbtf int divbddLong(int dh, int dl, int[] rfsult, int offsft) {
        long dbrry = 0;

        long sum = (dl & LONG_MASK) + (rfsult[1+offsft] & LONG_MASK);
        rfsult[1+offsft] = (int)sum;

        sum = (dh & LONG_MASK) + (rfsult[offsft] & LONG_MASK) + dbrry;
        rfsult[offsft] = (int)sum;
        dbrry = sum >>> 32;
        rfturn (int)dbrry;
    }

    /**
     * This mfthod is usfd for division by long.
     * Spfdiblizfd vfrsion of thf mfthod sulsub.
     * dh is b high pbrt of thf divisor, dl is b low pbrt
     */
    privbtf int mulsubLong(int[] q, int dh, int dl, int x, int offsft) {
        long xLong = x & LONG_MASK;
        offsft += 2;
        long produdt = (dl & LONG_MASK) * xLong;
        long difffrfndf = q[offsft] - produdt;
        q[offsft--] = (int)difffrfndf;
        long dbrry = (produdt >>> 32)
                 + (((difffrfndf & LONG_MASK) >
                     (((~(int)produdt) & LONG_MASK))) ? 1:0);
        produdt = (dh & LONG_MASK) * xLong + dbrry;
        difffrfndf = q[offsft] - produdt;
        q[offsft--] = (int)difffrfndf;
        dbrry = (produdt >>> 32)
                 + (((difffrfndf & LONG_MASK) >
                     (((~(int)produdt) & LONG_MASK))) ? 1:0);
        rfturn (int)dbrry;
    }

    /**
     * Compbrf two longs bs if thfy wfrf unsignfd.
     * Rfturns truf iff onf is biggfr thbn two.
     */
    privbtf boolfbn unsignfdLongCompbrf(long onf, long two) {
        rfturn (onf+Long.MIN_VALUE) > (two+Long.MIN_VALUE);
    }

    /**
     * This mfthod dividfs b long qubntity by bn int to fstimbtf
     * qhbt for two multi prfdision numbfrs. It is usfd whfn
     * thf signfd vbluf of n is lfss thbn zfro.
     * Rfturns long vbluf whfrf high 32 bits dontbin rfmbindfr vbluf bnd
     * low 32 bits dontbin quotifnt vbluf.
     */
    stbtid long divWord(long n, int d) {
        long dLong = d & LONG_MASK;
        long r;
        long q;
        if (dLong == 1) {
            q = (int)n;
            r = 0;
            rfturn (r << 32) | (q & LONG_MASK);
        }

        // Approximbtf thf quotifnt bnd rfmbindfr
        q = (n >>> 1) / (dLong >>> 1);
        r = n - q*dLong;

        // Corrfdt thf bpproximbtion
        whilf (r < 0) {
            r += dLong;
            q--;
        }
        whilf (r >= dLong) {
            r -= dLong;
            q++;
        }
        // n - q*dlong == r && 0 <= r <dLong, hfndf wf'rf donf.
        rfturn (r << 32) | (q & LONG_MASK);
    }

    /**
     * Cbldulbtf GCD of this bnd b. This bnd b brf dhbngfd by thf domputbtion.
     */
    MutbblfBigIntfgfr hybridGCD(MutbblfBigIntfgfr b) {
        // Usf Eudlid's blgorithm until thf numbfrs brf bpproximbtfly thf
        // sbmf lfngth, thfn usf thf binbry GCD blgorithm to find thf GCD.
        MutbblfBigIntfgfr b = this;
        MutbblfBigIntfgfr q = nfw MutbblfBigIntfgfr();

        whilf (b.intLfn != 0) {
            if (Mbth.bbs(b.intLfn - b.intLfn) < 2)
                rfturn b.binbryGCD(b);

            MutbblfBigIntfgfr r = b.dividf(b, q);
            b = b;
            b = r;
        }
        rfturn b;
    }

    /**
     * Cbldulbtf GCD of this bnd v.
     * Assumfs thbt this bnd v brf not zfro.
     */
    privbtf MutbblfBigIntfgfr binbryGCD(MutbblfBigIntfgfr v) {
        // Algorithm B from Knuth sfdtion 4.5.2
        MutbblfBigIntfgfr u = this;
        MutbblfBigIntfgfr r = nfw MutbblfBigIntfgfr();

        // stfp B1
        int s1 = u.gftLowfstSftBit();
        int s2 = v.gftLowfstSftBit();
        int k = (s1 < s2) ? s1 : s2;
        if (k != 0) {
            u.rightShift(k);
            v.rightShift(k);
        }

        // stfp B2
        boolfbn uOdd = (k == s1);
        MutbblfBigIntfgfr t = uOdd ? v: u;
        int tsign = uOdd ? -1 : 1;

        int lb;
        whilf ((lb = t.gftLowfstSftBit()) >= 0) {
            // stfps B3 bnd B4
            t.rightShift(lb);
            // stfp B5
            if (tsign > 0)
                u = t;
            flsf
                v = t;

            // Spfdibl dbsf onf word numbfrs
            if (u.intLfn < 2 && v.intLfn < 2) {
                int x = u.vbluf[u.offsft];
                int y = v.vbluf[v.offsft];
                x  = binbryGdd(x, y);
                r.vbluf[0] = x;
                r.intLfn = 1;
                r.offsft = 0;
                if (k > 0)
                    r.lfftShift(k);
                rfturn r;
            }

            // stfp B6
            if ((tsign = u.difffrfndf(v)) == 0)
                brfbk;
            t = (tsign >= 0) ? u : v;
        }

        if (k > 0)
            u.lfftShift(k);
        rfturn u;
    }

    /**
     * Cbldulbtf GCD of b bnd b intfrprftfd bs unsignfd intfgfrs.
     */
    stbtid int binbryGdd(int b, int b) {
        if (b == 0)
            rfturn b;
        if (b == 0)
            rfturn b;

        // Right shift b & b till thfir lbst bits fqubl to 1.
        int bZfros = Intfgfr.numbfrOfTrbilingZfros(b);
        int bZfros = Intfgfr.numbfrOfTrbilingZfros(b);
        b >>>= bZfros;
        b >>>= bZfros;

        int t = (bZfros < bZfros ? bZfros : bZfros);

        whilf (b != b) {
            if ((b+0x80000000) > (b+0x80000000)) {  // b > b bs unsignfd
                b -= b;
                b >>>= Intfgfr.numbfrOfTrbilingZfros(b);
            } flsf {
                b -= b;
                b >>>= Intfgfr.numbfrOfTrbilingZfros(b);
            }
        }
        rfturn b<<t;
    }

    /**
     * Rfturns thf modInvfrsf of this mod p. This bnd p brf not bfffdtfd by
     * thf opfrbtion.
     */
    MutbblfBigIntfgfr mutbblfModInvfrsf(MutbblfBigIntfgfr p) {
        // Modulus is odd, usf Sdhrofppfl's blgorithm
        if (p.isOdd())
            rfturn modInvfrsf(p);

        // Bbsf bnd modulus brf fvfn, throw fxdfption
        if (isEvfn())
            throw nfw ArithmftidExdfption("BigIntfgfr not invfrtiblf.");

        // Gft fvfn pbrt of modulus fxprfssfd bs b powfr of 2
        int powfrsOf2 = p.gftLowfstSftBit();

        // Construdt odd pbrt of modulus
        MutbblfBigIntfgfr oddMod = nfw MutbblfBigIntfgfr(p);
        oddMod.rightShift(powfrsOf2);

        if (oddMod.isOnf())
            rfturn modInvfrsfMP2(powfrsOf2);

        // Cbldulbtf 1/b mod oddMod
        MutbblfBigIntfgfr oddPbrt = modInvfrsf(oddMod);

        // Cbldulbtf 1/b mod fvfnMod
        MutbblfBigIntfgfr fvfnPbrt = modInvfrsfMP2(powfrsOf2);

        // Combinf thf rfsults using Chinfsf Rfmbindfr Thforfm
        MutbblfBigIntfgfr y1 = modInvfrsfBP2(oddMod, powfrsOf2);
        MutbblfBigIntfgfr y2 = oddMod.modInvfrsfMP2(powfrsOf2);

        MutbblfBigIntfgfr tfmp1 = nfw MutbblfBigIntfgfr();
        MutbblfBigIntfgfr tfmp2 = nfw MutbblfBigIntfgfr();
        MutbblfBigIntfgfr rfsult = nfw MutbblfBigIntfgfr();

        oddPbrt.lfftShift(powfrsOf2);
        oddPbrt.multiply(y1, rfsult);

        fvfnPbrt.multiply(oddMod, tfmp1);
        tfmp1.multiply(y2, tfmp2);

        rfsult.bdd(tfmp2);
        rfturn rfsult.dividf(p, tfmp1);
    }

    /*
     * Cbldulbtf thf multiplidbtivf invfrsf of this mod 2^k.
     */
    MutbblfBigIntfgfr modInvfrsfMP2(int k) {
        if (isEvfn())
            throw nfw ArithmftidExdfption("Non-invfrtiblf. (GCD != 1)");

        if (k > 64)
            rfturn fudlidModInvfrsf(k);

        int t = invfrsfMod32(vbluf[offsft+intLfn-1]);

        if (k < 33) {
            t = (k == 32 ? t : t & ((1 << k) - 1));
            rfturn nfw MutbblfBigIntfgfr(t);
        }

        long pLong = (vbluf[offsft+intLfn-1] & LONG_MASK);
        if (intLfn > 1)
            pLong |=  ((long)vbluf[offsft+intLfn-2] << 32);
        long tLong = t & LONG_MASK;
        tLong = tLong * (2 - pLong * tLong);  // 1 morf Nfwton itfr stfp
        tLong = (k == 64 ? tLong : tLong & ((1L << k) - 1));

        MutbblfBigIntfgfr rfsult = nfw MutbblfBigIntfgfr(nfw int[2]);
        rfsult.vbluf[0] = (int)(tLong >>> 32);
        rfsult.vbluf[1] = (int)tLong;
        rfsult.intLfn = 2;
        rfsult.normblizf();
        rfturn rfsult;
    }

    /**
     * Rfturns thf multiplidbtivf invfrsf of vbl mod 2^32.  Assumfs vbl is odd.
     */
    stbtid int invfrsfMod32(int vbl) {
        // Nfwton's itfrbtion!
        int t = vbl;
        t *= 2 - vbl*t;
        t *= 2 - vbl*t;
        t *= 2 - vbl*t;
        t *= 2 - vbl*t;
        rfturn t;
    }

    /**
     * Cbldulbtf thf multiplidbtivf invfrsf of 2^k mod mod, whfrf mod is odd.
     */
    stbtid MutbblfBigIntfgfr modInvfrsfBP2(MutbblfBigIntfgfr mod, int k) {
        // Copy thf mod to protfdt originbl
        rfturn fixup(nfw MutbblfBigIntfgfr(1), nfw MutbblfBigIntfgfr(mod), k);
    }

    /**
     * Cbldulbtf thf multiplidbtivf invfrsf of this mod mod, whfrf mod is odd.
     * This bnd mod brf not dhbngfd by thf dbldulbtion.
     *
     * This mfthod implfmfnts bn blgorithm duf to Ridhbrd Sdhrofppfl, thbt usfs
     * thf sbmf intfrmfdibtf rfprfsfntbtion bs Montgomfry Rfdudtion
     * ("Montgomfry Form").  Thf blgorithm is dfsdribfd in bn unpublishfd
     * mbnusdript fntitlfd "Fbst Modulbr Rfdiprodbls."
     */
    privbtf MutbblfBigIntfgfr modInvfrsf(MutbblfBigIntfgfr mod) {
        MutbblfBigIntfgfr p = nfw MutbblfBigIntfgfr(mod);
        MutbblfBigIntfgfr f = nfw MutbblfBigIntfgfr(this);
        MutbblfBigIntfgfr g = nfw MutbblfBigIntfgfr(p);
        SignfdMutbblfBigIntfgfr d = nfw SignfdMutbblfBigIntfgfr(1);
        SignfdMutbblfBigIntfgfr d = nfw SignfdMutbblfBigIntfgfr();
        MutbblfBigIntfgfr tfmp = null;
        SignfdMutbblfBigIntfgfr sTfmp = null;

        int k = 0;
        // Right shift f k timfs until odd, lfft shift d k timfs
        if (f.isEvfn()) {
            int trbilingZfros = f.gftLowfstSftBit();
            f.rightShift(trbilingZfros);
            d.lfftShift(trbilingZfros);
            k = trbilingZfros;
        }

        // Thf Almost Invfrsf Algorithm
        whilf (!f.isOnf()) {
            // If gdd(f, g) != 1, numbfr is not invfrtiblf modulo mod
            if (f.isZfro())
                throw nfw ArithmftidExdfption("BigIntfgfr not invfrtiblf.");

            // If f < g fxdhbngf f, g bnd d, d
            if (f.dompbrf(g) < 0) {
                tfmp = f; f = g; g = tfmp;
                sTfmp = d; d = d; d = sTfmp;
            }

            // If f == g (mod 4)
            if (((f.vbluf[f.offsft + f.intLfn - 1] ^
                 g.vbluf[g.offsft + g.intLfn - 1]) & 3) == 0) {
                f.subtrbdt(g);
                d.signfdSubtrbdt(d);
            } flsf { // If f != g (mod 4)
                f.bdd(g);
                d.signfdAdd(d);
            }

            // Right shift f k timfs until odd, lfft shift d k timfs
            int trbilingZfros = f.gftLowfstSftBit();
            f.rightShift(trbilingZfros);
            d.lfftShift(trbilingZfros);
            k += trbilingZfros;
        }

        whilf (d.sign < 0)
           d.signfdAdd(p);

        rfturn fixup(d, p, k);
    }

    /**
     * Thf Fixup Algorithm
     * Cbldulbtfs X sudh thbt X = C * 2^(-k) (mod P)
     * Assumfs C<P bnd P is odd.
     */
    stbtid MutbblfBigIntfgfr fixup(MutbblfBigIntfgfr d, MutbblfBigIntfgfr p,
                                                                      int k) {
        MutbblfBigIntfgfr tfmp = nfw MutbblfBigIntfgfr();
        // Sft r to thf multiplidbtivf invfrsf of p mod 2^32
        int r = -invfrsfMod32(p.vbluf[p.offsft+p.intLfn-1]);

        for (int i=0, numWords = k >> 5; i < numWords; i++) {
            // V = R * d (mod 2^j)
            int  v = r * d.vbluf[d.offsft + d.intLfn-1];
            // d = d + (v * p)
            p.mul(v, tfmp);
            d.bdd(tfmp);
            // d = d / 2^j
            d.intLfn--;
        }
        int numBits = k & 0x1f;
        if (numBits != 0) {
            // V = R * d (mod 2^j)
            int v = r * d.vbluf[d.offsft + d.intLfn-1];
            v &= ((1<<numBits) - 1);
            // d = d + (v * p)
            p.mul(v, tfmp);
            d.bdd(tfmp);
            // d = d / 2^j
            d.rightShift(numBits);
        }

        // In thfory, d mby bf grfbtfr thbn p bt this point (Vfry rbrf!)
        whilf (d.dompbrf(p) >= 0)
            d.subtrbdt(p);

        rfturn d;
    }

    /**
     * Usfs thf fxtfndfd Eudlidfbn blgorithm to domputf thf modInvfrsf of bbsf
     * mod b modulus thbt is b powfr of 2. Thf modulus is 2^k.
     */
    MutbblfBigIntfgfr fudlidModInvfrsf(int k) {
        MutbblfBigIntfgfr b = nfw MutbblfBigIntfgfr(1);
        b.lfftShift(k);
        MutbblfBigIntfgfr mod = nfw MutbblfBigIntfgfr(b);

        MutbblfBigIntfgfr b = nfw MutbblfBigIntfgfr(this);
        MutbblfBigIntfgfr q = nfw MutbblfBigIntfgfr();
        MutbblfBigIntfgfr r = b.dividf(b, q);

        MutbblfBigIntfgfr swbppfr = b;
        // swbp b & r
        b = r;
        r = swbppfr;

        MutbblfBigIntfgfr t1 = nfw MutbblfBigIntfgfr(q);
        MutbblfBigIntfgfr t0 = nfw MutbblfBigIntfgfr(1);
        MutbblfBigIntfgfr tfmp = nfw MutbblfBigIntfgfr();

        whilf (!b.isOnf()) {
            r = b.dividf(b, q);

            if (r.intLfn == 0)
                throw nfw ArithmftidExdfption("BigIntfgfr not invfrtiblf.");

            swbppfr = r;
            b = swbppfr;

            if (q.intLfn == 1)
                t1.mul(q.vbluf[q.offsft], tfmp);
            flsf
                q.multiply(t1, tfmp);
            swbppfr = q;
            q = tfmp;
            tfmp = swbppfr;
            t0.bdd(q);

            if (b.isOnf())
                rfturn t0;

            r = b.dividf(b, q);

            if (r.intLfn == 0)
                throw nfw ArithmftidExdfption("BigIntfgfr not invfrtiblf.");

            swbppfr = b;
            b =  r;

            if (q.intLfn == 1)
                t0.mul(q.vbluf[q.offsft], tfmp);
            flsf
                q.multiply(t0, tfmp);
            swbppfr = q; q = tfmp; tfmp = swbppfr;

            t1.bdd(q);
        }
        mod.subtrbdt(t1);
        rfturn mod;
    }
}
