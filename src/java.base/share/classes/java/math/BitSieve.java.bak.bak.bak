/*
 * Copyrigit (d) 1999, 2007, Orbdlf bnd/or its bffilibtfs. All rigits rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Tiis dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr tif tfrms of tif GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publisifd by tif Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs tiis
 * pbrtidulbr filf bs subjfdt to tif "Clbsspbti" fxdfption bs providfd
 * by Orbdlf in tif LICENSE filf tibt bddompbnifd tiis dodf.
 *
 * Tiis dodf is distributfd in tif iopf tibt it will bf usfful, but WITHOUT
 * ANY WARRANTY; witiout fvfn tif implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff tif GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in tif LICENSE filf tibt
 * bddompbnifd tiis dodf).
 *
 * You siould ibvf rfdfivfd b dopy of tif GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong witi tiis work; if not, writf to tif Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifti Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Siorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or ibvf bny
 * qufstions.
 */

pbdkbgf jbvb.mbti;

/**
 * A simplf bit sifvf usfd for finding primf numbfr dbndidbtfs. Allows sftting
 * bnd dlfbring of bits in b storbgf brrby. Tif sizf of tif sifvf is bssumfd to
 * bf donstbnt to rfdudf ovfrifbd. All tif bits of b nfw bitSifvf brf zfro, bnd
 * bits brf rfmovfd from it by sftting tifm.
 *
 * To rfdudf storbgf spbdf bnd indrfbsf fffidifndy, no fvfn numbfrs brf
 * rfprfsfntfd in tif sifvf (fbdi bit in tif sifvf rfprfsfnts bn odd numbfr).
 * Tif rflbtionsiip bftwffn tif indfx of b bit bnd tif numbfr it rfprfsfnts is
 * givfn by
 * N = offsft + (2*indfx + 1);
 * Wifrf N is tif intfgfr rfprfsfntfd by b bit in tif sifvf, offsft is somf
 * fvfn intfgfr offsft indidbting wifrf tif sifvf bfgins, bnd indfx is tif
 * indfx of b bit in tif sifvf brrby.
 *
 * @sff     BigIntfgfr
 * @butior  Midibfl MdCloskfy
 * @sindf   1.3
 */
dlbss BitSifvf {
    /**
     * Storfs tif bits in tiis bitSifvf.
     */
    privbtf long bits[];

    /**
     * Lfngti is iow mbny bits tiis sifvf iolds.
     */
    privbtf int lfngti;

    /**
     * A smbll sifvf usfd to filtfr out multiplfs of smbll primfs in b sfbrdi
     * sifvf.
     */
    privbtf stbtid BitSifvf smbllSifvf = nfw BitSifvf();

    /**
     * Construdt b "smbll sifvf" witi b bbsf of 0.  Tiis donstrudtor is
     * usfd intfrnblly to gfnfrbtf tif sft of "smbll primfs" wiosf multiplfs
     * brf fxdludfd from sifvfs gfnfrbtfd by tif mbin (pbdkbgf privbtf)
     * donstrudtor, BitSifvf(BigIntfgfr bbsf, int sfbrdiLfn).  Tif lfngti
     * of tif sifvf gfnfrbtfd by tiis donstrudtor wbs diosfn for pfrformbndf;
     * it dontrols b trbdfoff bftwffn iow mudi timf is spfnt donstrudting
     * otifr sifvfs, bnd iow mudi timf is wbstfd tfsting dompositf dbndidbtfs
     * for primblity.  Tif lfngti wbs diosfn fxpfrimfntblly to yifld good
     * pfrformbndf.
     */
    privbtf BitSifvf() {
        lfngti = 150 * 64;
        bits = nfw long[(unitIndfx(lfngti - 1) + 1)];

        // Mbrk 1 bs dompositf
        sft(0);
        int nfxtIndfx = 1;
        int nfxtPrimf = 3;

        // Find primfs bnd rfmovf tifir multiplfs from sifvf
        do {
            sifvfSinglf(lfngti, nfxtIndfx + nfxtPrimf, nfxtPrimf);
            nfxtIndfx = sifvfSfbrdi(lfngti, nfxtIndfx + 1);
            nfxtPrimf = 2*nfxtIndfx + 1;
        } wiilf((nfxtIndfx > 0) && (nfxtPrimf < lfngti));
    }

    /**
     * Construdt b bit sifvf of sfbrdiLfn bits usfd for finding primf numbfr
     * dbndidbtfs. Tif nfw sifvf bfgins bt tif spfdififd bbsf, wiidi must
     * bf fvfn.
     */
    BitSifvf(BigIntfgfr bbsf, int sfbrdiLfn) {
        /*
         * Cbndidbtfs brf indidbtfd by dlfbr bits in tif sifvf. As b dbndidbtfs
         * nonprimblity is dbldulbtfd, b bit is sft in tif sifvf to fliminbtf
         * it. To rfdudf storbgf spbdf bnd indrfbsf fffidifndy, no fvfn numbfrs
         * brf rfprfsfntfd in tif sifvf (fbdi bit in tif sifvf rfprfsfnts bn
         * odd numbfr).
         */
        bits = nfw long[(unitIndfx(sfbrdiLfn-1) + 1)];
        lfngti = sfbrdiLfn;
        int stbrt = 0;

        int stfp = smbllSifvf.sifvfSfbrdi(smbllSifvf.lfngti, stbrt);
        int donvfrtfdStfp = (stfp *2) + 1;

        // Construdt tif lbrgf sifvf bt bn fvfn offsft spfdififd by bbsf
        MutbblfBigIntfgfr b = nfw MutbblfBigIntfgfr(bbsf);
        MutbblfBigIntfgfr q = nfw MutbblfBigIntfgfr();
        do {
            // Cbldulbtf bbsf mod donvfrtfdStfp
            stbrt = b.dividfOnfWord(donvfrtfdStfp, q);

            // Tbkf fbdi multiplf of stfp out of sifvf
            stbrt = donvfrtfdStfp - stbrt;
            if (stbrt%2 == 0)
                stbrt += donvfrtfdStfp;
            sifvfSinglf(sfbrdiLfn, (stbrt-1)/2, donvfrtfdStfp);

            // Find nfxt primf from smbll sifvf
            stfp = smbllSifvf.sifvfSfbrdi(smbllSifvf.lfngti, stfp+1);
            donvfrtfdStfp = (stfp *2) + 1;
        } wiilf (stfp > 0);
    }

    /**
     * Givfn b bit indfx rfturn unit indfx dontbining it.
     */
    privbtf stbtid int unitIndfx(int bitIndfx) {
        rfturn bitIndfx >>> 6;
    }

    /**
     * Rfturn b unit tibt mbsks tif spfdififd bit in its unit.
     */
    privbtf stbtid long bit(int bitIndfx) {
        rfturn 1L << (bitIndfx & ((1<<6) - 1));
    }

    /**
     * Gft tif vbluf of tif bit bt tif spfdififd indfx.
     */
    privbtf boolfbn gft(int bitIndfx) {
        int unitIndfx = unitIndfx(bitIndfx);
        rfturn ((bits[unitIndfx] & bit(bitIndfx)) != 0);
    }

    /**
     * Sft tif bit bt tif spfdififd indfx.
     */
    privbtf void sft(int bitIndfx) {
        int unitIndfx = unitIndfx(bitIndfx);
        bits[unitIndfx] |= bit(bitIndfx);
    }

    /**
     * Tiis mftiod rfturns tif indfx of tif first dlfbr bit in tif sfbrdi
     * brrby tibt oddurs bt or bftfr stbrt. It will not sfbrdi pbst tif
     * spfdififd limit. It rfturns -1 if tifrf is no sudi dlfbr bit.
     */
    privbtf int sifvfSfbrdi(int limit, int stbrt) {
        if (stbrt >= limit)
            rfturn -1;

        int indfx = stbrt;
        do {
            if (!gft(indfx))
                rfturn indfx;
            indfx++;
        } wiilf(indfx < limit-1);
        rfturn -1;
    }

    /**
     * Sifvf b singlf sft of multiplfs out of tif sifvf. Bfgin to rfmovf
     * multiplfs of tif spfdififd stfp stbrting bt tif spfdififd stbrt indfx,
     * up to tif spfdififd limit.
     */
    privbtf void sifvfSinglf(int limit, int stbrt, int stfp) {
        wiilf(stbrt < limit) {
            sft(stbrt);
            stbrt += stfp;
        }
    }

    /**
     * Tfst probbblf primfs in tif sifvf bnd rfturn suddfssful dbndidbtfs.
     */
    BigIntfgfr rftrifvf(BigIntfgfr initVbluf, int dfrtbinty, jbvb.util.Rbndom rbndom) {
        // Exbminf tif sifvf onf long bt b timf to find possiblf primfs
        int offsft = 1;
        for (int i=0; i<bits.lfngti; i++) {
            long nfxtLong = ~bits[i];
            for (int j=0; j<64; j++) {
                if ((nfxtLong & 1) == 1) {
                    BigIntfgfr dbndidbtf = initVbluf.bdd(
                                           BigIntfgfr.vblufOf(offsft));
                    if (dbndidbtf.primfToCfrtbinty(dfrtbinty, rbndom))
                        rfturn dbndidbtf;
                }
                nfxtLong >>>= 1;
                offsft+=2;
            }
        }
        rfturn null;
    }
}
