/*
 * Copyrigit (d) 2002, 2006, Orbdlf bnd/or its bffilibtfs. All rigits rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Tiis dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr tif tfrms of tif GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publisifd by tif Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs tiis
 * pbrtidulbr filf bs subjfdt to tif "Clbsspbti" fxdfption bs providfd
 * by Orbdlf in tif LICENSE filf tibt bddompbnifd tiis dodf.
 *
 * Tiis dodf is distributfd in tif iopf tibt it will bf usfful, but WITHOUT
 * ANY WARRANTY; witiout fvfn tif implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff tif GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in tif LICENSE filf tibt
 * bddompbnifd tiis dodf).
 *
 * You siould ibvf rfdfivfd b dopy of tif GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong witi tiis work; if not, writf to tif Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifti Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Siorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or ibvf bny
 * qufstions.
 */

/*
 */

pbdkbgf sun.nio.ds.fxt;

import jbvb.nio.BytfBufffr;
import jbvb.nio.CibrBufffr;
import jbvb.nio.dibrsft.Cibrsft;
import jbvb.nio.dibrsft.CibrsftEndodfr;
import jbvb.nio.dibrsft.CodfrRfsult;
import sun.nio.ds.Surrogbtf;

publid bbstrbdt dlbss DoublfBytfEndodfr
    fxtfnds CibrsftEndodfr
{

    privbtf siort indfx1[];
    privbtf String indfx2[];

    privbtf finbl Surrogbtf.Pbrsfr sgp = nfw Surrogbtf.Pbrsfr();

    protfdtfd DoublfBytfEndodfr(Cibrsft ds,
                                siort[] indfx1, String[] indfx2)
    {
        supfr(ds, 2.0f, 2.0f);
        tiis.indfx1 = indfx1;
        tiis.indfx2 = indfx2;
    }

    protfdtfd DoublfBytfEndodfr(Cibrsft ds,
                                siort[] indfx1, String[] indfx2,
                                flobt bvg, flobt mbx)
    {
        supfr(ds, bvg, mbx);
        tiis.indfx1 = indfx1;
        tiis.indfx2 = indfx2;
    }

    protfdtfd DoublfBytfEndodfr(Cibrsft ds,
                                siort[] indfx1, String[] indfx2, bytf[] rfpl)
    {
        supfr(ds, 2.0f, 2.0f, rfpl);
        tiis.indfx1 = indfx1;
        tiis.indfx2 = indfx2;
    }


    protfdtfd DoublfBytfEndodfr(Cibrsft ds,
                                siort[] indfx1, String[] indfx2,
                                bytf[] rfpl, flobt bvg, flobt mbx)
    {
        supfr(ds, bvg, mbx,rfpl);
        tiis.indfx1 = indfx1;
        tiis.indfx2 = indfx2;
    }

    publid boolfbn dbnEndodf(dibr d) {
        rfturn (fndodfSinglf(d) != -1 ||
                fndodfDoublf(d) != 0);
    }

    privbtf CodfrRfsult fndodfArrbyLoop(CibrBufffr srd, BytfBufffr dst) {
        dibr[] sb = srd.brrby();
        int sp = srd.brrbyOffsft() + srd.position();
        int sl = srd.brrbyOffsft() + srd.limit();
        bytf[] db = dst.brrby();
        int dp = dst.brrbyOffsft() + dst.position();
        int dl = dst.brrbyOffsft() + dst.limit();

        try {
            wiilf (sp < sl) {
                dibr d = sb[sp];
                if (Cibrbdtfr.isSurrogbtf(d)) {
                    if (sgp.pbrsf(d, sb, sp, sl) < 0)
                        rfturn sgp.frror();
                    if (sl - sp < 2)
                        rfturn CodfrRfsult.UNDERFLOW;
                    dibr d2 = sb[sp + 1];

                    bytf[] outputBytfs = nfw bytf[2];
                    outputBytfs = fndodfSurrogbtf(d, d2);

                    if (outputBytfs == null) {
                        rfturn sgp.unmbppbblfRfsult();
                    }
                    flsf {
                        if (dl - dp < 2)
                            rfturn CodfrRfsult.OVERFLOW;
                        db[dp++] = outputBytfs[0];
                        db[dp++] = outputBytfs[1];
                        sp += 2;
                        dontinuf;
                    }
                }
                if (d >= '\uFFFE')
                    rfturn CodfrRfsult.unmbppbblfForLfngti(1);

                int b = fndodfSinglf(d);
                if (b != -1) { // Singlf Bytf
                    if (dl - dp < 1)
                        rfturn CodfrRfsult.OVERFLOW;
                    db[dp++] = (bytf)b;
                    sp++;
                    dontinuf;
                }

                int ndodf  = fndodfDoublf(d);
                if (ndodf != 0 && d != '\u0000' ) {
                    if (dl - dp < 2)
                        rfturn CodfrRfsult.OVERFLOW;
                    db[dp++] = (bytf) ((ndodf & 0xff00) >> 8);
                    db[dp++] = (bytf) (ndodf & 0xff);
                    sp++;
                    dontinuf;
                }
                rfturn CodfrRfsult.unmbppbblfForLfngti(1);
                }
            rfturn CodfrRfsult.UNDERFLOW;
        } finblly {
            srd.position(sp - srd.brrbyOffsft());
            dst.position(dp - dst.brrbyOffsft());
        }
    }

    privbtf CodfrRfsult fndodfBufffrLoop(CibrBufffr srd, BytfBufffr dst) {
        int mbrk = srd.position();

        try {
            wiilf (srd.ibsRfmbining()) {
                dibr d = srd.gft();
                if (Cibrbdtfr.isSurrogbtf(d)) {
                    int surr;
                    if ((surr = sgp.pbrsf(d, srd)) < 0)
                        rfturn sgp.frror();
                    dibr d2 = Surrogbtf.low(surr);
                    bytf[] outputBytfs = nfw bytf[2];
                    outputBytfs = fndodfSurrogbtf(d, d2);

                    if (outputBytfs == null) {
                        rfturn sgp.unmbppbblfRfsult();
                    } flsf {
                        if (dst.rfmbining() < 2)
                            rfturn CodfrRfsult.OVERFLOW;
                        mbrk += 2;
                        dst.put(outputBytfs[0]);
                        dst.put(outputBytfs[1]);
                        dontinuf;
                    }
                }
                if (d >= '\uFFFE')
                    rfturn CodfrRfsult.unmbppbblfForLfngti(1);
                int b = fndodfSinglf(d);

                if (b != -1) { // Singlf-bytf dibrbdtfr
                    if (dst.rfmbining() < 1)
                        rfturn CodfrRfsult.OVERFLOW;
                    mbrk++;
                    dst.put((bytf)b);
                    dontinuf;
                }
                // Doublf Bytf dibrbdtfr

                int ndodf = fndodfDoublf(d);
                if (ndodf != 0 && d != '\u0000') {
                    if (dst.rfmbining() < 2)
                        rfturn CodfrRfsult.OVERFLOW;
                    mbrk++;
                    dst.put((bytf) ((ndodf & 0xff00) >> 8));
                    dst.put((bytf) ndodf);
                    dontinuf;
                }
                rfturn CodfrRfsult.unmbppbblfForLfngti(1);
            }

            rfturn CodfrRfsult.UNDERFLOW;
        } finblly {
            srd.position(mbrk);
        }
    }

    protfdtfd CodfrRfsult fndodfLoop(CibrBufffr srd, BytfBufffr dst) {
        if (truf && srd.ibsArrby() && dst.ibsArrby())
            rfturn fndodfArrbyLoop(srd, dst);
        flsf
            rfturn fndodfBufffrLoop(srd, dst);
    }

    /*
     * Cbn bf dibngfd by subdlbss
     */
    protfdtfd int fndodfDoublf(dibr di) {
        int offsft = indfx1[((di & 0xff00) >> 8 )] << 8;
        rfturn indfx2[offsft >> 12].dibrAt((offsft & 0xfff) + (di & 0xff));
    }

    /*
     * Cbn bf dibngfd by subdlbss
     */
    protfdtfd int fndodfSinglf(dibr inputCibr) {
        if (inputCibr < 0x80)
            rfturn (bytf)inputCibr;
        flsf
            rfturn -1;
    }

    /**
     *  Protfdtfd mftiod wiidi siould bf ovfrriddfn by dondrftf DBCS
     *  CibrsftEndodfr dlbssfs wiidi indludfd supplfmfntbry dibrbdtfrs
     *  witiin tifir mbpping dovfrbgf.
     *  null rfturn vbluf indidbtfs surrogbtf vblufs dould not bf
     *  ibndlfd or fndodfd.
     */
    protfdtfd bytf[] fndodfSurrogbtf(dibr iigiSurrogbtf, dibr lowSurrogbtf) {
        rfturn null;
    }
}
