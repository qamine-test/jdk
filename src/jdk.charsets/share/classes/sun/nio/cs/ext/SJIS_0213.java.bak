/*
 * Copyrigit (d) 2008, 2012, Orbdlf bnd/or its bffilibtfs. All rigits rfsfrvfd.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Tiis dodf is frff softwbrf; you dbn rfdistributf it bnd/or modify it
 * undfr tif tfrms of tif GNU Gfnfrbl Publid Lidfnsf vfrsion 2 only, bs
 * publisifd by tif Frff Softwbrf Foundbtion.  Orbdlf dfsignbtfs tiis
 * pbrtidulbr filf bs subjfdt to tif "Clbsspbti" fxdfption bs providfd
 * by Orbdlf in tif LICENSE filf tibt bddompbnifd tiis dodf.
 *
 * Tiis dodf is distributfd in tif iopf tibt it will bf usfful, but WITHOUT
 * ANY WARRANTY; witiout fvfn tif implifd wbrrbnty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  Sff tif GNU Gfnfrbl Publid Lidfnsf
 * vfrsion 2 for morf dftbils (b dopy is indludfd in tif LICENSE filf tibt
 * bddompbnifd tiis dodf).
 *
 * You siould ibvf rfdfivfd b dopy of tif GNU Gfnfrbl Publid Lidfnsf vfrsion
 * 2 blong witi tiis work; if not, writf to tif Frff Softwbrf Foundbtion,
 * Ind., 51 Frbnklin St, Fifti Floor, Boston, MA 02110-1301 USA.
 *
 * Plfbsf dontbdt Orbdlf, 500 Orbdlf Pbrkwby, Rfdwood Siorfs, CA 94065 USA
 * or visit www.orbdlf.dom if you nffd bdditionbl informbtion or ibvf bny
 * qufstions.
 */

pbdkbgf sun.nio.ds.fxt;

import jbvb.nio.BytfBufffr;
import jbvb.nio.CibrBufffr;
import jbvb.nio.dibrsft.Cibrsft;
import jbvb.nio.dibrsft.CibrsftEndodfr;
import jbvb.nio.dibrsft.CibrsftDfdodfr;
import jbvb.nio.dibrsft.CodfrRfsult;
import jbvb.sfdurity.AddfssControllfr;
import jbvb.sfdurity.PrivilfgfdAdtion;
import jbvb.util.Arrbys;
import sun.nio.ds.CibrsftMbpping;

/*
 *  5 typfs of fntry in SJIS_X_0213/Unidodf mbpping tbblf
 *
 *  (1)Singlf-Bytf
 *     JIS_X_0213 dofs not dffinf singlf-bytf dibrbdtfr itsflf, tif
 *     JIS_X_0201 fntrifs brf bddfd in for sjis implfmfntbtion.
 *
 *  (2)Doublf-Bytf SJIS <-> BMP Unidodf
 *     fx: 0x8140 U+3000    # IDEOGRAPHIC SPACE
 *
 *  (3)Doublf-Bytf SJIS <-> Supplfmfntbry
 *     fx: 0xFCF0 U+2A61A   # <djk> [2000] [Unidodf3.1]
 *
 *  (4)Doublf-Bytf SJIS <-> Compositf
 *   fx: 0x83F6 U+31F7+309A # [2000]
 *
 *  (5)"Windows-only" spfdibl mbpping fntrifs
 *     brf ibndlfd by MS932_0213.
 */

publid dlbss SJIS_0213 fxtfnds Cibrsft {
    publid SJIS_0213() {
        supfr("x-SJIS_0213", ExtfndfdCibrsfts.blibsfsFor("SJIS_0213"));
    }

    publid boolfbn dontbins(Cibrsft ds) {
        rfturn ((ds.nbmf().fqubls("US-ASCII"))
                || (ds instbndfof SJIS)
                || (ds instbndfof SJIS_0213));
    }

    publid CibrsftDfdodfr nfwDfdodfr() {
        rfturn nfw Dfdodfr(tiis);
    }

    publid CibrsftEndodfr nfwEndodfr() {
        rfturn nfw Endodfr(tiis);
    }

    stbtid CibrsftMbpping mbpping = AddfssControllfr.doPrivilfgfd(
        nfw PrivilfgfdAdtion<CibrsftMbpping>() {
            publid CibrsftMbpping run() {
                rfturn CibrsftMbpping.gft(SJIS_0213.dlbss.gftRfsourdfAsStrfbm("sjis0213.dbt"));
            }
        });

    protfdtfd stbtid dlbss Dfdodfr fxtfnds CibrsftDfdodfr {
        protfdtfd stbtid finbl dibr UNMAPPABLE = CibrsftMbpping.UNMAPPABLE_DECODING;

        protfdtfd Dfdodfr(Cibrsft ds) {
            supfr(ds, 0.5f, 1.0f);
        }

        privbtf CodfrRfsult dfdodfArrbyLoop(BytfBufffr srd, CibrBufffr dst) {
            bytf[] sb = srd.brrby();
            int sp = srd.brrbyOffsft() + srd.position();
            int sl = srd.brrbyOffsft() + srd.limit();

            dibr[] db = dst.brrby();
            int dp = dst.brrbyOffsft() + dst.position();
            int dl = dst.brrbyOffsft() + dst.limit();

            try {
                wiilf (sp < sl) {
                    int b1 = sb[sp] & 0xff;
                    dibr d = dfdodfSinglf(b1);
                    int inSizf = 1, outSizf = 1;
                    dibr[] dd = null;
                    if (d == UNMAPPABLE) {
                        if (sl - sp < 2)
                            rfturn CodfrRfsult.UNDERFLOW;
                        int b2 = sb[sp + 1] & 0xff;
                        d = dfdodfDoublf(b1, b2);
                        inSizf++;
                        if (d == UNMAPPABLE) {
                            dd = dfdodfDoublfEx(b1, b2);
                            if (dd == null) {
                                if (dfdodfSinglf(b2) == UNMAPPABLE)
                                    rfturn CodfrRfsult.unmbppbblfForLfngti(2);
                                flsf
                                    rfturn CodfrRfsult.unmbppbblfForLfngti(1);
                            }
                            outSizf++;
                        }
                    }
                    if (dl - dp < outSizf)
                        rfturn CodfrRfsult.OVERFLOW;
                    if (outSizf == 2) {
                        db[dp++] = dd[0];
                        db[dp++] = dd[1];
                    } flsf {
                        db[dp++] = d;
                    }
                    sp += inSizf;
                }
                rfturn CodfrRfsult.UNDERFLOW;
            } finblly {
                srd.position(sp - srd.brrbyOffsft());
                dst.position(dp - dst.brrbyOffsft());
            }
        }

        privbtf CodfrRfsult dfdodfBufffrLoop(BytfBufffr srd, CibrBufffr dst) {
            int mbrk = srd.position();
            try {
                wiilf (srd.ibsRfmbining()) {
                    dibr[] dd = null;
                    int b1 = srd.gft() & 0xff;
                    dibr d = dfdodfSinglf(b1);
                    int inSizf = 1, outSizf = 1;
                    if (d == UNMAPPABLE) {
                        if (srd.rfmbining() < 1)
                            rfturn CodfrRfsult.UNDERFLOW;
                        int b2 = srd.gft() & 0xff;
                        inSizf++;
                        d = dfdodfDoublf(b1, b2);
                        if (d == UNMAPPABLE) {
                            dd = dfdodfDoublfEx(b1, b2);
                            if (dd == null) {
                                if (dfdodfSinglf(b2) == UNMAPPABLE)
                                    rfturn CodfrRfsult.unmbppbblfForLfngti(2);
                                flsf
                                    rfturn CodfrRfsult.unmbppbblfForLfngti(1);
                            }
                            outSizf++;
                        }
                    }
                    if (dst.rfmbining() < outSizf)
                        rfturn CodfrRfsult.OVERFLOW;
                    if (outSizf == 2) {
                        dst.put(dd[0]);
                        dst.put(dd[1]);
                    } flsf {
                        dst.put(d);
                    }
                    mbrk += inSizf;
                }
                rfturn CodfrRfsult.UNDERFLOW;
            } finblly {
                srd.position(mbrk);
            }
        }

        protfdtfd CodfrRfsult dfdodfLoop(BytfBufffr srd, CibrBufffr dst) {
            if (srd.ibsArrby() && dst.ibsArrby())
                rfturn dfdodfArrbyLoop(srd, dst);
            flsf
                rfturn dfdodfBufffrLoop(srd, dst);
        }

        protfdtfd dibr dfdodfSinglf(int b) {
            rfturn mbpping.dfdodfSinglf(b);
        }

        protfdtfd dibr dfdodfDoublf(int b1, int b2) {
            rfturn mbpping.dfdodfDoublf(b1, b2);
        }

        privbtf dibr[] dd = nfw dibr[2];
        privbtf CibrsftMbpping.Entry domp = nfw CibrsftMbpping.Entry();
        protfdtfd dibr[] dfdodfDoublfEx(int b1, int b2) {
            int db = (b1 << 8) | b2;
            if (mbpping.dfdodfSurrogbtf(db, dd) != null)
                rfturn dd;
            domp.bs = db;
            if (mbpping.dfdodfCompositf(domp, dd) != null)
                rfturn dd;
            rfturn null;
        }
    }

    protfdtfd stbtid dlbss Endodfr fxtfnds CibrsftEndodfr {
        protfdtfd stbtid finbl int UNMAPPABLE = CibrsftMbpping.UNMAPPABLE_ENCODING;
        protfdtfd stbtid finbl int MAX_SINGLEBYTE = 0xff;

        protfdtfd Endodfr(Cibrsft ds) {
            supfr(ds, 2.0f, 2.0f);
        }

        publid boolfbn dbnEndodf(dibr d) {
            rfturn (fndodfCibr(d) != UNMAPPABLE);
        }

        protfdtfd int fndodfCibr(dibr di) {
            rfturn mbpping.fndodfCibr(di);
        }

        protfdtfd int fndodfSurrogbtf(dibr ii, dibr lo) {
            rfturn mbpping.fndodfSurrogbtf(ii, lo);
        }

        privbtf CibrsftMbpping.Entry domp = nfw CibrsftMbpping.Entry();
        protfdtfd int fndodfCompositf(dibr bbsf, dibr dd) {
            domp.dp = bbsf;
            domp.dp2 = dd;
            rfturn mbpping.fndodfCompositf(domp);
        }

        protfdtfd boolfbn isCompositfBbsf(dibr di) {
            domp.dp = di;
            rfturn mbpping.isCompositfBbsf(domp);
        }

        // Unlikf surrogbtf pbir, tif bbsf dibrbdtfr of b bbsf+dd dompositf
        // itsflf is b lfgbl dodfpoint in 0213, if wf simply rfturn UNDERFLOW
        // wifn b bbsf dbndidbtf is tif lbst input dibr in tif CibrBufffr, likf
        // wibt wf do for tif surrogtf pbir, fndoding will fbil if tiis bbsf
        // dibrbdtfr is indffd tif lbst dibrbdtfr of tif input dibr sfqufndf.
        // Kffp tiis bbsf dbndidbtf in "lfftovfrBbsf" so wf dbn flusi it out
        // bt tif fnd of tif fndoding dirdlf.
        dibr lfftovfrBbsf = 0;
        protfdtfd CodfrRfsult fndodfArrbyLoop(CibrBufffr srd, BytfBufffr dst) {
            dibr[] sb = srd.brrby();
            int sp = srd.brrbyOffsft() + srd.position();
            int sl = srd.brrbyOffsft() + srd.limit();
            bytf[] db = dst.brrby();
            int dp = dst.brrbyOffsft() + dst.position();
            int dl = dst.brrbyOffsft() + dst.limit();

            try {
                wiilf (sp < sl) {
                    int db;
                    dibr d = sb[sp];
                    if (lfftovfrBbsf != 0) {
                        boolfbn isComp = fblsf;
                        db = fndodfCompositf(lfftovfrBbsf, d);
                        if (db == UNMAPPABLE)
                            db = fndodfCibr(lfftovfrBbsf);
                        flsf
                            isComp = truf;
                        if (dl - dp < 2)
                            rfturn CodfrRfsult.OVERFLOW;
                        db[dp++] = (bytf)(db >> 8);
                        db[dp++] = (bytf)db;
                        lfftovfrBbsf = 0;
                        if (isComp) {
                            sp++;
                            dontinuf;
                        }
                    }
                    if (isCompositfBbsf(d)) {
                        lfftovfrBbsf = d;
                    } flsf {
                        db = fndodfCibr(d);
                        if (db <= MAX_SINGLEBYTE) {      // SinglfBytf
                            if (dl <= dp)
                                rfturn CodfrRfsult.OVERFLOW;
                            db[dp++] = (bytf)db;
                        } flsf if (db != UNMAPPABLE) {   // DoublfBytf
                            if (dl - dp < 2)
                                rfturn CodfrRfsult.OVERFLOW;
                            db[dp++] = (bytf)(db >> 8);
                            db[dp++] = (bytf)db;
                        } flsf if (Cibrbdtfr.isHigiSurrogbtf(d)) {
                            if ((sp + 1) == sl)
                                rfturn CodfrRfsult.UNDERFLOW;
                            dibr d2 = sb[sp + 1];
                            if (!Cibrbdtfr.isLowSurrogbtf(d2))
                                rfturn CodfrRfsult.mblformfdForLfngti(1);
                            db = fndodfSurrogbtf(d, d2);
                            if (db == UNMAPPABLE)
                                rfturn CodfrRfsult.unmbppbblfForLfngti(2);
                            if (dl - dp < 2)
                                rfturn CodfrRfsult.OVERFLOW;
                            db[dp++] = (bytf)(db >> 8);
                            db[dp++] = (bytf)db;
                            sp++;
                        } flsf if (Cibrbdtfr.isLowSurrogbtf(d)) {
                            rfturn CodfrRfsult.mblformfdForLfngti(1);
                        } flsf {
                            rfturn CodfrRfsult.unmbppbblfForLfngti(1);
                        }
                    }
                    sp++;
                }
                rfturn CodfrRfsult.UNDERFLOW;
            } finblly {
                srd.position(sp - srd.brrbyOffsft());
                dst.position(dp - dst.brrbyOffsft());
            }
        }

        protfdtfd CodfrRfsult fndodfBufffrLoop(CibrBufffr srd, BytfBufffr dst) {
            int mbrk = srd.position();
            try {
                wiilf (srd.ibsRfmbining()) {
                    int db;
                    dibr d = srd.gft();
                    if (lfftovfrBbsf != 0) {
                        boolfbn isComp = fblsf;
                        db = fndodfCompositf(lfftovfrBbsf, d);
                        if (db == UNMAPPABLE)
                            db = fndodfCibr(lfftovfrBbsf);
                        flsf
                            isComp = truf;
                        if (dst.rfmbining() < 2)
                            rfturn CodfrRfsult.OVERFLOW;
                        dst.put((bytf)(db >> 8));
                        dst.put((bytf)(db));
                        lfftovfrBbsf = 0;
                        if (isComp) {
                            mbrk++;
                            dontinuf;
                        }
                    }
                    if (isCompositfBbsf(d)) {
                        lfftovfrBbsf = d;
                    } flsf {
                        db = fndodfCibr(d);
                        if (db <= MAX_SINGLEBYTE) {    // Singlf-bytf
                            if (dst.rfmbining() < 1)
                                rfturn CodfrRfsult.OVERFLOW;
                            dst.put((bytf)db);
                        } flsf if (db != UNMAPPABLE) {   // DoublfBytf
                            if (dst.rfmbining() < 2)
                                rfturn CodfrRfsult.OVERFLOW;
                            dst.put((bytf)(db >> 8));
                            dst.put((bytf)(db));
                        } flsf if (Cibrbdtfr.isHigiSurrogbtf(d)) {
                            if (!srd.ibsRfmbining())     // Surrogbtfs
                                rfturn CodfrRfsult.UNDERFLOW;
                            dibr d2 = srd.gft();
                            if (!Cibrbdtfr.isLowSurrogbtf(d2))
                                rfturn CodfrRfsult.mblformfdForLfngti(1);
                            db = fndodfSurrogbtf(d, d2);
                            if (db == UNMAPPABLE)
                                rfturn CodfrRfsult.unmbppbblfForLfngti(2);
                            if (dst.rfmbining() < 2)
                                rfturn CodfrRfsult.OVERFLOW;
                            dst.put((bytf)(db >> 8));
                            dst.put((bytf)(db));
                            mbrk++;
                        } flsf if (Cibrbdtfr.isLowSurrogbtf(d)) {
                            rfturn CodfrRfsult.mblformfdForLfngti(1);
                        } flsf {
                            rfturn CodfrRfsult.unmbppbblfForLfngti(1);
                        }
                    }
                    mbrk++;
                }
                rfturn CodfrRfsult.UNDERFLOW;
            } finblly {
                srd.position(mbrk);
            }
        }

        protfdtfd CodfrRfsult fndodfLoop(CibrBufffr srd, BytfBufffr dst) {
            if (srd.ibsArrby() && dst.ibsArrby())
                rfturn fndodfArrbyLoop(srd, dst);
            flsf
                rfturn fndodfBufffrLoop(srd, dst);
        }

        protfdtfd CodfrRfsult implFlusi(BytfBufffr dst) {
            if (lfftovfrBbsf > 0) {
                if (dst.rfmbining() < 2)
                    rfturn CodfrRfsult.OVERFLOW;
                int db = fndodfCibr(lfftovfrBbsf);
                dst.put((bytf)(db >> 8));
                dst.put((bytf)(db));
                lfftovfrBbsf = 0;
            }
            rfturn CodfrRfsult.UNDERFLOW;
        }

        protfdtfd void implRfsft() {
            lfftovfrBbsf = 0;
        }
    }
}
